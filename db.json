{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/Chic/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/Chic/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/Chic/source/assets/beian.png","path":"assets/beian.png","modified":1,"renderable":1},{"_id":"themes/Chic/source/assets/example_qr.png","path":"assets/example_qr.png","modified":1,"renderable":1},{"_id":"themes/Chic/source/assets/loading.svg","path":"assets/loading.svg","modified":1,"renderable":1},{"_id":"themes/Chic/source/assets/favicon.ico","path":"assets/favicon.ico","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/base.styl","path":"css/base.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/custom.styl","path":"css/custom.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/font.styl","path":"css/font.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/layout.styl","path":"css/layout.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/media.styl","path":"css/media.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/normalize.styl","path":"css/normalize.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/variable.styl","path":"css/variable.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/image/avatar.jpg","path":"image/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/Chic/source/js/mathjax2.7.5.js","path":"js/mathjax2.7.5.js","modified":1,"renderable":1},{"_id":"themes/Chic/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/Chic/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.TTF","path":"fonts/lanting/lanting.TTF","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.eot","path":"fonts/lanting/lanting.eot","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.otf","path":"fonts/lanting/lanting.otf","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff","path":"fonts/lanting/lanting.woff","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff2","path":"fonts/lanting/lanting.woff2","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/demo.css","path":"fonts/iconfont/demo.css","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/demo_index.html","path":"fonts/iconfont/demo_index.html","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.css","path":"fonts/iconfont/iconfont.css","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.eot","path":"fonts/iconfont/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.js","path":"fonts/iconfont/iconfont.js","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.json","path":"fonts/iconfont/iconfont.json","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.svg","path":"fonts/iconfont/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.ttf","path":"fonts/iconfont/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff","path":"fonts/iconfont/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff2","path":"fonts/iconfont/iconfont.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/Hilbert's Nullstellensatz.md","hash":"d4a5815955e91a8acb59acb10a4677861c0477b6","modified":1704008707300},{"_id":"source/_posts/75 Problems.md","hash":"517f3943f289d8f0223efe602e134be644272755","modified":1704008680099},{"_id":"source/_posts/Cichon's Diagram.md","hash":"f6df2ed9e93a44fba5d2c44c8347ac407d2da714","modified":1704008688585},{"_id":"source/_posts/Hilbert13.md","hash":"9c897be08a2dac27e89b66ffec23d3188789c8bf","modified":1704250584240},{"_id":"source/_posts/Nowicki Conjecture.md","hash":"67efd815236c924aef4c31653b0b0cd94d4caa37","modified":1704008736966},{"_id":"source/_posts/Nevanlinna Theory2.md","hash":"57ab7faf49d39ce01756a1773dc6dc609905c342","modified":1704008726158},{"_id":"source/_posts/Nevanlinna Theory.md","hash":"0a37f0f9ecf2c9f1fd14f94338ff86b401f4ef9a","modified":1704008717870},{"_id":"source/_posts/P=NP.md","hash":"44131872752033094aeab5b2e679818940ef324d","modified":1704008745736},{"_id":"source/_posts/Quadratic Reciprocity Law.md","hash":"de960752fe8c6c646c85dfbb98db164758560cb5","modified":1704008754943},{"_id":"source/_posts/The Discovery of Neptune.md","hash":"32b17688a9a42afd863c545d0c8afae9fc7b2a32","modified":1704008766691},{"_id":"source/category/index.md","hash":"c238a88d51be7e34ba5ff7cdf265ad513e3e7bfa","modified":1704072678438},{"_id":"source/_posts/The Naimark Problem.md","hash":"c1dde8532f847f9cbfd94e3639221e2037f9bee5","modified":1704084782181},{"_id":"source/_posts/Zariski topology.md","hash":"fa76f14b9235f96876e0d366409709bd592dff33","modified":1704008791957},{"_id":"source/_drafts/75 Probelms (French).md","hash":"98161844690a52fe704e9a2556b458a738895d6d","modified":1703656821838},{"_id":"source/about/index.md","hash":"e730165876573d376d1717d4950df29b29b4b984","modified":1704209626918},{"_id":"source/_drafts/Cyclotomic Fields.md","hash":"47d4b11979989f4eb6b56657915b629d949cc06b","modified":1680779867057},{"_id":"source/css/gitment.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1704010959464},{"_id":"source/_drafts/Divisor Theory.md","hash":"420303e89d641e29366c368ee2bc9e412ae213bd","modified":1680779867057},{"_id":"source/_drafts/Dedekind Domain.md","hash":"17c64f4f79835089c6bf1aa726ab27cba70acd87","modified":1680779867057},{"_id":"source/_drafts/Kronecker-dream-of-youth.md","hash":"ddd1b0af53776725f976766c58d467b3fd2373bd","modified":1702227075502},{"_id":"source/_drafts/Nevanlinna Theory (German).md","hash":"4dad06564c3c2d0dede5fa63940f42403f1712be","modified":1682599604548},{"_id":"source/tag/index.md","hash":"f9dd628afc6beeda63a838a4ca2a081e4af0b3ed","modified":1680779867062},{"_id":"source/_drafts/Nowicki Conjecture.md","hash":"e79cd201d519b54532ba32198f19803ac19aa2f7","modified":1681307241000},{"_id":"source/css/_common/comments/third_party/gitment.styl","hash":"cbf73a76ddfb8fbd0f5ef5d8bc62b7d18205b752","modified":1704011513383},{"_id":"source/css/_common/comments/third_party/third_party.styl","hash":"03397d363df01191f4cc5c1e6385f37d0d08ae54","modified":1704011547343},{"_id":"source/js/gitment.js","hash":"b15dfd8a35c949cbe1f23f2b49e78905c7525c82","modified":1704006243956},{"_id":"themes/Chic/LICENSE.md","hash":"9911bdafa287bd65a822f84cc12012980bd10247","modified":1680779867063},{"_id":"themes/Chic/ChangeLogs.md","hash":"0244985e7e4797e3d0a0e173dce4e341f6aa5dd0","modified":1680779867063},{"_id":"themes/Chic/README-CN.md","hash":"af0765f26b72d49f1b29afe1a9d0c4a492912aaa","modified":1680779867064},{"_id":"themes/Chic/README.md","hash":"e0bd27664e1d0b4ed1c8101d2bf69886c66c31d9","modified":1680779867064},{"_id":"themes/Chic/_config.yml","hash":"2c28bdbc105c74724f095d4af709f75a1a1cef3b","modified":1704270705422},{"_id":"themes/Chic/package.json","hash":"8b4072879307eed0e74ae35390825c5e03b9229c","modified":1680779867065},{"_id":"themes/Chic/_default/single.html","hash":"e45092de238a2082a1d7954e5bcf39a396197620","modified":1704067920226},{"_id":"themes/Chic/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1680404818728},{"_id":"themes/Chic/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1680404818727},{"_id":"themes/Chic/languages/default.yml","hash":"0628773c9f7466a9eac73a2a2fcc86fc5a9f7e73","modified":1704011201791},{"_id":"themes/Chic/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1680404818729},{"_id":"themes/Chic/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1680404818729},{"_id":"themes/Chic/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1680404818728},{"_id":"themes/Chic/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1680404818728},{"_id":"themes/Chic/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1680404818730},{"_id":"themes/Chic/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1680404818730},{"_id":"themes/Chic/layout/comments.swig","hash":"994959bf2179719ac6236347aef661a516eb4796","modified":1704070856438},{"_id":"themes/Chic/layout/category.ejs","hash":"cae7483c92ff639f74f8efe67959f37c97350800","modified":1680404818738},{"_id":"themes/Chic/layout/archive.ejs","hash":"48cdf67b628eb6a1c24d484ed252f5b0e3f06ddf","modified":1680404818737},{"_id":"themes/Chic/scripts/imageTag.js","hash":"4b69804c1e4bf638eda7022499c440ce24e28587","modified":1680404818740},{"_id":"themes/Chic/layout/layout.ejs","hash":"8565bbea5e904e75e8d1ff5186b3a53650a7fa70","modified":1680404818739},{"_id":"themes/Chic/layout/index.ejs","hash":"b3344720176ad12dc88745cc5b31d497356ca4fa","modified":1680404818738},{"_id":"themes/Chic/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1680404818730},{"_id":"themes/Chic/layout/post.ejs","hash":"b6264a94a84f79a5f6adbc603dd973ce1eac82a1","modified":1704258160986},{"_id":"themes/Chic/languages/zh-TW.yml","hash":"a652c6f1e34d576cdf1f5931286e3ec9d244d45a","modified":1704011261399},{"_id":"themes/Chic/languages/zh-CN.yml","hash":"ebc9773a3ab233fae36eea8eec39d3ba21e8ed52","modified":1704011244612},{"_id":"themes/Chic/source/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1680404818782},{"_id":"themes/Chic/layout/tag.ejs","hash":"d85ca78392be138b1589499cba95186b20c3a902","modified":1680404818740},{"_id":"themes/Chic/layout/_page/category.ejs","hash":"e8464e11d08a711fe815ea1cd101aa41d7310ebf","modified":1680404818732},{"_id":"themes/Chic/layout/page.ejs","hash":"96a5db03943ca9fcc8943618cc39bbde5fa04239","modified":1704258498841},{"_id":"themes/Chic/layout/_plugins/gitalk.ejs","hash":"396e8c86e49c72f99431cd48001ae75c06d8b529","modified":1704209685647},{"_id":"themes/Chic/layout/_page/post.ejs","hash":"6eb9cd3ee904e99ff78509298ae31a29fdbf49cf","modified":1680404818733},{"_id":"themes/Chic/layout/_page/page.ejs","hash":"1d875d59cf4d6b681cc8cf755f19b5355e5d1144","modified":1680404818732},{"_id":"themes/Chic/layout/_page/archive.ejs","hash":"464549286c92ea0d6cb057c6936e0f1a5d1c1dd2","modified":1680404818732},{"_id":"themes/Chic/layout/_page/tag.ejs","hash":"0c20ff00532103f9a59639ca9956fc0bce4aabc2","modified":1680404818734},{"_id":"themes/Chic/source/assets/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1679489292473},{"_id":"themes/Chic/layout/_page/profile.ejs","hash":"f49991a55cc08a1d90d8d6ae8d15a692163272e1","modified":1680404818734},{"_id":"themes/Chic/source/assets/example_qr.png","hash":"a79b7399f81fe05c8a69440a9ef01b47c2dfb5b6","modified":1679698479501},{"_id":"themes/Chic/layout/_plugins/mathjax.ejs","hash":"53f088fe44d51c4d9fb61aeac4c23b3cfcc19762","modified":1680404818737},{"_id":"themes/Chic/source/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1679489292473},{"_id":"themes/Chic/source/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1679489292473},{"_id":"themes/Chic/layout/_plugins/site-visitor.ejs","hash":"5224474c5e145df97f9bfe1e6bf1d8b607823701","modified":1704261275620},{"_id":"themes/Chic/source/assets/loading.svg","hash":"85082b002bae1335114b71550350907884187e38","modified":1679489292473},{"_id":"themes/Chic/layout/_plugins/valine.ejs","hash":"dd78cef244bc22d64bcd885073b7763948b86807","modified":1704270656153},{"_id":"themes/Chic/source/css/custom.styl","hash":"b434721f720d43be984e24301fd5e2b6b8d44f32","modified":1704084401635},{"_id":"themes/Chic/source/css/base.styl","hash":"72aef06d738853f13f1697b091002d6d776bd56d","modified":1680404818780},{"_id":"themes/Chic/source/css/font.styl","hash":"8c1da30e223c0a3d7ef452abc9f0e4cc71dbc140","modified":1680404818780},{"_id":"themes/Chic/source/css/layout.styl","hash":"4d9f83b5a3bac81e7857358744858fae708320de","modified":1680404818780},{"_id":"themes/Chic/source/css/media.styl","hash":"f96c0dbb9653667906a6dc271f637543ac5c7212","modified":1680404818780},{"_id":"themes/Chic/source/css/normalize.styl","hash":"b3337320133b7a336db7033aa6bbe94b054c0b21","modified":1680404818781},{"_id":"themes/Chic/source/css/variable.styl","hash":"906faa95457eba70118a0705e13b8f43409e502f","modified":1680404818781},{"_id":"themes/Chic/layout/_partial/after-footer.ejs","hash":"860366fcf074c59ad7a8f36608b0636e06c47fa2","modified":1704196535141},{"_id":"themes/Chic/layout/_partial/comments.swig","hash":"a252e287237a8bb627408d9a871550ed9b8d8190","modified":1704011369788},{"_id":"themes/Chic/source/css/style.styl","hash":"a13f2c38070a89b06a2ede599f5ce5fd160e11c9","modified":1680404818781},{"_id":"themes/Chic/layout/_partial/article-full.ejs","hash":"88b863f5375f3e633209488960225dc3979faafe","modified":1704253946238},{"_id":"themes/Chic/layout/_partial/article.ejs","hash":"901983fb54e375b539d71ccc860c2b0004f24fa0","modified":1704258005744},{"_id":"themes/Chic/layout/_partial/footer.ejs","hash":"4a7c4d5d503fd28db42dfd8d73b40ad47b1474a5","modified":1704268713612},{"_id":"themes/Chic/layout/_partial/counter.ejs","hash":"9a7f5c9543c9752c8bcf5606a9eb5b6c1bfaa0a1","modified":1704199856933},{"_id":"themes/Chic/layout/_partial/gitalk.html","hash":"4bad67042a6de9b94bcde905eba99bccdfdde212","modified":1704067629486},{"_id":"themes/Chic/layout/_partial/gitment.ejs","hash":"0704032fb2000245b647087a394e92665c02b76e","modified":1704010779075},{"_id":"themes/Chic/layout/_widget/popular_post.ejs","hash":"56527a452f78a024628bdb2a64de353bf58dfe2a","modified":1704196764141},{"_id":"themes/Chic/layout/_partial/head.ejs","hash":"8c91a3575037c2210cdfc4e78b0d863ac5ba5893","modified":1704254244281},{"_id":"themes/Chic/layout/_partial/header.ejs","hash":"8f1e5272a4de96a3ed94de1db988b05b34515463","modified":1680404818735},{"_id":"themes/Chic/layout/_partial/toc.ejs","hash":"c47e8a5047ce0016f74b76028878d386af78bb7c","modified":1680404818736},{"_id":"themes/Chic/source/image/avatar.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1679489292473},{"_id":"themes/Chic/source/js/mathjax2.7.5.js","hash":"7ba18c783d543cfb4b45a0118ccb73d3f68cd46e","modified":1680404818848},{"_id":"themes/Chic/layout/_partial/paginator.ejs","hash":"ab59d5db77f2aa64dfe03656e72fd49702c62e23","modified":1680404818736},{"_id":"themes/Chic/source/js/script.js","hash":"5dd8ce4fa55a7201d7e2ffe417b48c95943a906b","modified":1680404818849},{"_id":"themes/Chic/source/css/_lib/looper.css","hash":"863144dc9af7c1e181670515bc85eaf768f4e287","modified":1680404818771},{"_id":"themes/Chic/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1680404818849},{"_id":"themes/Chic/source/css/_page/archive.styl","hash":"71ea842f068b29b4418dd09450db09d27dcf0947","modified":1680404818776},{"_id":"themes/Chic/source/css/_page/page.styl","hash":"34e33b52d2e046aa2f5494e81ff4ac2d5ca78058","modified":1680404818777},{"_id":"themes/Chic/source/css/_page/category.styl","hash":"cead361269616b7a6ddec3090d9fa34c3c6ac722","modified":1680404818776},{"_id":"themes/Chic/source/css/_lib/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1680404818772},{"_id":"themes/Chic/source/css/_highlight/agate.styl","hash":"53027913ed8d4f75ac3e49e76aad824f0df62da3","modified":1680404818741},{"_id":"themes/Chic/source/css/_page/tag.styl","hash":"55b220cc58011876fb3a470cd1fde8ed87c93079","modified":1680404818778},{"_id":"themes/Chic/source/css/_page/profile.styl","hash":"057097e714284e72e97ab8a808a30df45555a342","modified":1680404818777},{"_id":"themes/Chic/source/css/_highlight/androidstudio.styl","hash":"2af0861725f97f0ee2ded67c3d2d4548c62b2d16","modified":1680404818741},{"_id":"themes/Chic/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1680404818742},{"_id":"themes/Chic/source/css/_highlight/arta.styl","hash":"b3e81e3e694ceb8deed178adb8b91013c5120e30","modified":1680404818742},{"_id":"themes/Chic/source/css/_highlight/atelier-cave-dark.styl","hash":"ce63dd8548688d88254405eedfa75b1d7c82449e","modified":1680404818744},{"_id":"themes/Chic/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1680404818744},{"_id":"themes/Chic/source/css/_highlight/atelier-dune-dark.styl","hash":"c196ff0ee064af0e507823694ae39020addfc280","modified":1680404818745},{"_id":"themes/Chic/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1680404818744},{"_id":"themes/Chic/source/css/_highlight/atelier-estuary-dark.styl","hash":"0bb16a4eff93688f40787abc2f9e56e7d5cc93e7","modified":1680404818746},{"_id":"themes/Chic/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1680404818745},{"_id":"themes/Chic/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1680404818746},{"_id":"themes/Chic/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1680404818747},{"_id":"themes/Chic/source/css/_highlight/atelier-forest-dark.styl","hash":"effbc5d75fa87203c847039869c22031b40d5b7d","modified":1680404818747},{"_id":"themes/Chic/source/css/_highlight/atelier-heath-dark.styl","hash":"9a2e9a1d0a01bbdf158560c3ed1c134e098b2c68","modified":1680404818748},{"_id":"themes/Chic/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1680404818748},{"_id":"themes/Chic/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1680404818749},{"_id":"themes/Chic/source/css/_highlight/atelier-lakeside-dark.styl","hash":"10ee3882fca7b97a37bd309d2d35fce9868647bb","modified":1680404818748},{"_id":"themes/Chic/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1680404818750},{"_id":"themes/Chic/source/css/_highlight/atelier-plateau-dark.styl","hash":"84c80e6f67f62fce958d25817c277d2360272617","modified":1680404818750},{"_id":"themes/Chic/source/css/_highlight/atelier-savanna-dark.styl","hash":"e32c1c70def8060fce5e790979a126da650ac642","modified":1680404818750},{"_id":"themes/Chic/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1680404818751},{"_id":"themes/Chic/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1680404818751},{"_id":"themes/Chic/source/css/_highlight/atelier-seaside-dark.styl","hash":"2edf385215bbe1985b1a10106525d362667d28c2","modified":1680404818751},{"_id":"themes/Chic/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1680404818752},{"_id":"themes/Chic/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"538a14321193cd8abf2ddc484306631e54149ffb","modified":1680404818752},{"_id":"themes/Chic/source/css/_highlight/codepen-embed.styl","hash":"8b7b34484f76a6c2c3b1a9e49abb9b382f439ae8","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/brown-paper.styl","hash":"329b85ae9130a5587a6fb1c6f80396f9cca5ddc1","modified":1680404818752},{"_id":"themes/Chic/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1680404818752},{"_id":"themes/Chic/source/css/_highlight/dark.styl","hash":"f5e6e75958de59e87fc6be3a1668e870e20bc836","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/far.styl","hash":"aaac3028f5e33123cd123a583cddc9290c45ec8e","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/darkula.styl","hash":"9717efa9194837ba3fb4d762997d33075dcf8bfa","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/highlightjs.styl","hash":"65b5981dc3c57cedd1cb668c0e377230987e08d1","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/gruvbox-dark.styl","hash":"76b744c14fd5600bea64731c05df97c2df75523f","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/hopscotch.styl","hash":"1378a6bc67a32c0cbff72ab771268b53f9aa586d","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/hybrid.styl","hash":"b8eb5c69d12f2ee5ebc50265ae271699d7f1a8d3","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1680404818761},{"_id":"themes/Chic/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1680404818760},{"_id":"themes/Chic/source/css/_highlight/ir-black.styl","hash":"53e5d74326a4527b92272bbd6946d4fec92720e8","modified":1680404818753},{"_id":"themes/Chic/source/css/_highlight/kimbie.styl","hash":"51b889ca7c6fe178cfbbe28d875a6ea427184441","modified":1680404818761},{"_id":"themes/Chic/source/css/_highlight/monokai-sublime.styl","hash":"c385b11345894be7e6ce3c5f08663e199933b8e4","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1680404818762},{"_id":"themes/Chic/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1680404818761},{"_id":"themes/Chic/source/css/_highlight/monokai.styl","hash":"f87be027848ea6bee623a08ad1e17b2f5b7937ee","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/obsidian.styl","hash":"199e28326be8590883f0813ebbd54fcfaa4750fd","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/paraiso.styl","hash":"75f181eece6b71d033ea0c8d6cf00ae7efb9e29b","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/pojoaque.styl","hash":"2601b4285803a7cea5ccded8d624ca95f80e3d88","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/railscasts.styl","hash":"b6674db9210e0c4444e4835fff2d1361f3ebd64c","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/rainbow.styl","hash":"c0cf97aae3e10fdcd10414547a711c9effbc39b8","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/school-book.styl","hash":"beabbbcc7930f8de19159381a01c0ba41dc2291f","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/sunburst.styl","hash":"af3eec0fd56151e55bbd49c31b151f36717611d8","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/solarized-dark.styl","hash":"90c9da5aa594383697e5b18892a7f95beb053f55","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-blue.styl","hash":"f24c17d0ab815dcfaab3438cb9fe2ab4839f5e0d","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-bright.styl","hash":"7674fecb6d27350727dc0d2dc93bc018382ebbd0","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-eighties.styl","hash":"28d751075ebabf7d0327a36f725076fe82fdf626","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night.styl","hash":"16ba09b2db501e4e3e2e7d62595d9bf935bf27c4","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1680404818763},{"_id":"themes/Chic/source/css/_partial/footer.styl","hash":"4f58e607eaa59cda3b5a9fdb3404ffb75c4d1a03","modified":1680404818778},{"_id":"themes/Chic/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1680404818763},{"_id":"themes/Chic/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1680404818763},{"_id":"themes/Chic/source/css/_partial/header.styl","hash":"be70b4ab3bcc977f1055664899742804c716929d","modified":1680404818778},{"_id":"themes/Chic/source/css/_highlight/zenburn.styl","hash":"68ff9332ccc03f9389b15b713415cde016f8088f","modified":1680404818763},{"_id":"themes/Chic/source/css/_partial/paginator.styl","hash":"b4f4a5180c4cbc70d186792b8a1fd0f5855bd86a","modified":1680404818779},{"_id":"themes/Chic/source/fonts/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1680404818784},{"_id":"themes/Chic/source/fonts/iconfont/demo_index.html","hash":"16e01463756a77b4acd15ade4e6b73f0376d75e1","modified":1680404818784},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.css","hash":"1e5540dca41dc53879226750f936e72daf616662","modified":1680404818784},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.eot","hash":"d18736f7885569e497698d17f49b9167add67dc6","modified":1680404818785},{"_id":"themes/Chic/layout/_third-party/comments/gitment.swig","hash":"53f605bb2554b096adbbe6e51ed834cf9bec84e2","modified":1704008358199},{"_id":"themes/Chic/layout/_third-party/comments/index.swig","hash":"10af34b4d39cf344ee4921fd3aff2fc497298b44","modified":1704070896128},{"_id":"themes/Chic/layout/_third-party/comments/gitalk.swig","hash":"0460af10c54d9d97f6c4a1bcb3940c5675a9df20","modified":1704070815291},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.js","hash":"87bfdaae31251f4d605646c5ae9c67196f6cc4e2","modified":1680404818785},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.json","hash":"eae94b803d34035008842855d0bead92d2035281","modified":1680404818785},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.svg","hash":"5c9c4e44179a7435d0f91df4ce1154dd677ad8c2","modified":1680404818786},{"_id":"themes/Chic/layout/_partial/post/gitalk.ejs","hash":"dac239a8dba1159648cce6f8012144860604a79b","modified":1704071529745},{"_id":"themes/Chic/layout/_partial/post/date.ejs","hash":"a999230f31f16ecc370b168974191d149d3bf08b","modified":1704199937630},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.ttf","hash":"41c4f4dc82e42452dcfd19caed6c7dc333ee769e","modified":1680404818786},{"_id":"themes/Chic/layout/_partial/post/single.html","hash":"2f8c008433b7bb053550e55eba198b20169063cb","modified":1704267670805},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff","hash":"a57593c49b56c16ac1def0e1f3dbca3f658b3579","modified":1680404818786},{"_id":"themes/Chic/source/css/_common/components/third-party.styl","hash":"20c47711e7ed6c5f46d4c4d58ac24f48102dd082","modified":1704071075397},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff2","hash":"39d97a0f72417487f5c1e0a0abf8e27dd6ebda31","modified":1680404818787},{"_id":"themes/Chic/source/css/_page/_post/post_code.styl","hash":"06c3a3524ffd4b27e03e79489001997ea5d727d3","modified":1680404818773},{"_id":"themes/Chic/source/css/_page/_post/post_nav.styl","hash":"03accaba13c995cbe65a05a88549ff74e992eb3f","modified":1680404818774},{"_id":"themes/Chic/source/css/_page/_post/post_content.styl","hash":"5e3d63077549d8e2e5ff8c452e809760f5a99c17","modified":1680404818773},{"_id":"themes/Chic/source/css/_page/_post/post_copyright.styl","hash":"64fd9f07ed45f035057d46740af0db70218714aa","modified":1680404818773},{"_id":"themes/Chic/source/css/_page/_post/post_header.styl","hash":"d37b032bc5edca92c84bf62070a28fa40939df55","modified":1680404818774},{"_id":"themes/Chic/source/css/_page/_post/post_tags.styl","hash":"2ff93677aa4d81da83c659b4dd4e3cb482d9ce7d","modified":1680404818774},{"_id":"themes/Chic/source/css/_common/components/third-party/gitalk.styl","hash":"ac7753d536341aa824d7bce0332735e838916995","modified":1704071030409},{"_id":"themes/Chic/source/css/_page/_post/post_toc.styl","hash":"15e1ec7af93f41184f986aba21991a79923b0a0e","modified":1680404818775},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff2","hash":"5f325fcd2726a5b44e08b7004a5219e14847cbfa","modified":1680404818845},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff","hash":"642ad1f17d27d4b1010d1a0571d1b44cbc823d9d","modified":1680404818842},{"_id":"themes/Chic/source/fonts/lanting/lanting.eot","hash":"3e184614f037939a6f98d607da3ed7dffb350e65","modified":1680404818816},{"_id":"themes/Chic/source/fonts/lanting/lanting.TTF","hash":"97e9a4538cceef4b17d54c7dc589524905d1b685","modified":1680404818802},{"_id":"themes/Chic/source/fonts/lanting/lanting.otf","hash":"4e184da596772d3ef6e5763cdee3e46a1ce2f2dd","modified":1680404818837},{"_id":"public/css/gitment.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1704270748038},{"_id":"public/js/gitment.js","hash":"b15dfd8a35c949cbe1f23f2b49e78905c7525c82","modified":1704270748038},{"_id":"public/content.json","hash":"7f6ebc04cad6455cf06282574bd3b69b76eb25bb","modified":1704270748038},{"_id":"public/atom.xml","hash":"c8286f5e409bd79ab35225f92040eb89804dac9d","modified":1704270748038},{"_id":"public/sitemap.xml","hash":"b865adadb4ae8c4a5f70188982801045f6192b49","modified":1704270748038},{"_id":"public/sitemap.txt","hash":"783b6e29885000f7d3568c17df2a37a81cad0099","modified":1704270748038},{"_id":"public/about/index.html","hash":"8e3ba90b5b4f907b420a8d913a52da5880314790","modified":1704270748038},{"_id":"public/tag/index.html","hash":"e700b1c05ed0eb4dbef6ad5b48b880af729cc530","modified":1704270748038},{"_id":"public/2023/04/10/The Naimark Problem/index.html","hash":"68a6a7a93dfddfc4bcb0caec0d49a24cbfdcd2da","modified":1704270748038},{"_id":"public/2023/03/27/Nevanlinna Theory2/index.html","hash":"66a7c339833ef3b0588a9c39851144d671f05934","modified":1704270748038},{"_id":"public/category/index.html","hash":"9941e1c6281c0306edd90231c554624605b51553","modified":1704270748038},{"_id":"public/2023/04/11/Nowicki Conjecture/index.html","hash":"e24b02925f423d1ee745d006fb08e8193c0a7af6","modified":1704270748038},{"_id":"public/2023/09/22/75 Problems/index.html","hash":"40070d939c5045fc59fe43ac42f28cdf5f17b532","modified":1704270748038},{"_id":"public/2023/07/31/Cichon's Diagram/index.html","hash":"144e6778fd2b4731ccedb7031d73f805a58047ad","modified":1704270748038},{"_id":"public/2023/04/10/P=NP/index.html","hash":"07f1fd9ba6550f6f4be9fed743d1c048e4c45322","modified":1704270748038},{"_id":"public/2023/04/04/The Discovery of Neptune/index.html","hash":"3f060b44310b21897a4a67103e2b99b119f741fb","modified":1704270748038},{"_id":"public/2023/03/27/Quadratic Reciprocity Law/index.html","hash":"84ec776976a7210d3d68460c78993bcf1a6c817f","modified":1704270748038},{"_id":"public/2023/03/27/Nevanlinna Theory/index.html","hash":"86373538027e085553b601ff4387bc3bd3d0f680","modified":1704270748038},{"_id":"public/archives/index.html","hash":"9a54b1830f40e4929d67b25d6d0e503d5aecff68","modified":1704270748038},{"_id":"public/archives/page/2/index.html","hash":"e21532db0668521320f313e686760c7060bb4d1f","modified":1704270748038},{"_id":"public/archives/2023/index.html","hash":"eb7cd37ec58c4e218fa17cbdb06d7e0745139df9","modified":1704270748038},{"_id":"public/archives/2023/page/2/index.html","hash":"2e1256b305ec69793dfd32fea37aa4e48a044b7b","modified":1704270748038},{"_id":"public/archives/2023/03/index.html","hash":"3b7d5272db2e939d375325fa99f0c4728063c8bb","modified":1704270748038},{"_id":"public/archives/2023/04/index.html","hash":"4e2a881e665820727d84f792f6877af4ff1857c5","modified":1704270748038},{"_id":"public/archives/2023/07/index.html","hash":"c569315cac19915369ffae541c8056f16d19556a","modified":1704270748038},{"_id":"public/archives/2023/09/index.html","hash":"1d471f9bf860d3785127133c58648c377e823b80","modified":1704270748038},{"_id":"public/categories/Set-Theory/index.html","hash":"4bc5f92a654664f846b33246c4ef2224ba8ed7a8","modified":1704270748038},{"_id":"public/categories/Commutative-Algebra/index.html","hash":"6451f8d68a1fd0cb5c0da39ae7a0456e19026c10","modified":1704270748038},{"_id":"public/categories/Notes/index.html","hash":"ff72b44a61c92d1bd2608940c49585bf7b65e4ec","modified":1704270748038},{"_id":"public/categories/Sevaral-Complex-Variables/index.html","hash":"f89156e2cdd64d60216a645602ef2ba957175123","modified":1704270748038},{"_id":"public/categories/Commutative-Algebra/Algebraic-Geometry/index.html","hash":"b41f19f6bdc503c7a8f5b7490d64a125f83ceac0","modified":1704270748038},{"_id":"public/categories/Algebraic-Number-Theory/index.html","hash":"02c11a2a9846aa86fdc478504069e885ce279f91","modified":1704270748038},{"_id":"public/categories/History-of-Mathematics/index.html","hash":"5954e35f503123921bc790172fe5c7a9c7de019f","modified":1704270748038},{"_id":"public/categories/Sevaral-Complex-Variables/Nevanlinna-Theory/index.html","hash":"53dcb45f9be7b31d055ed1f207626326eaf23882","modified":1704270748038},{"_id":"public/categories/Mathematical-Logic/index.html","hash":"695c3bec567867b34753a6ae7c5967bebd089d5c","modified":1704270748038},{"_id":"public/categories/History-of-Mathematics/Hilbert-s-23-Problems/index.html","hash":"d53c8487778f58115a2cb08192c359ef9374f57a","modified":1704270748038},{"_id":"public/page/2/index.html","hash":"90f205ae3d4216660b5b6ed96d9df12892949224","modified":1704270748038},{"_id":"public/tags/Set-Theory/index.html","hash":"ce3528de93bf97fdb220fda20353db0173740711","modified":1704270748038},{"_id":"public/tags/Notes/index.html","hash":"73e4e4ab07b01414d575fcac864b92fdae1a6f5f","modified":1704270748038},{"_id":"public/index.html","hash":"90f205ae3d4216660b5b6ed96d9df12892949224","modified":1704270748038},{"_id":"public/tags/Hilbert-s-23-Problems/index.html","hash":"6fc079d273e990b482453a334eedfa213598a64a","modified":1704270748038},{"_id":"public/tags/Sevaral-Complex-Variables/index.html","hash":"e1d634ef62577af85993f39869d8568bdcaeeddc","modified":1704270748038},{"_id":"public/tags/Algebraic-Number-Theory/index.html","hash":"90d30d74e8801d9777767d0b28ae20bd045c9307","modified":1704270748038},{"_id":"public/tags/Mathematical-Logic/index.html","hash":"0bd4e11de69a195a675c7f24a735d1e9516a69b6","modified":1704270748038},{"_id":"public/tags/Algebraic-Geometry/index.html","hash":"2097b217e1fb3f8799912311cba4cb7ba609f029","modified":1704270748038},{"_id":"public/2023/03/23/Hilbert13/index.html","hash":"8cc4e3287cafbd0376e67a5317b3ec05810d520a","modified":1704270748038},{"_id":"public/2023/03/23/Zariski topology/index.html","hash":"3f9b3a64a967a5da853bfc98bbc0e68998012140","modified":1704270748038},{"_id":"public/2023/03/23/Hilbert's Nullstellensatz/index.html","hash":"0324d2b2c52e9be36a381a5361c922cdf249e647","modified":1704270748038},{"_id":"public/assets/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1704270748038},{"_id":"public/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1704270748038},{"_id":"public/assets/example_qr.png","hash":"a79b7399f81fe05c8a69440a9ef01b47c2dfb5b6","modified":1704270748038},{"_id":"public/assets/loading.svg","hash":"85082b002bae1335114b71550350907884187e38","modified":1704270748038},{"_id":"public/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1704270748038},{"_id":"public/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1704270748038},{"_id":"public/fonts/iconfont/iconfont.eot","hash":"d18736f7885569e497698d17f49b9167add67dc6","modified":1704270748038},{"_id":"public/fonts/iconfont/iconfont.svg","hash":"5c9c4e44179a7435d0f91df4ce1154dd677ad8c2","modified":1704270748038},{"_id":"public/image/avatar.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1704270748038},{"_id":"public/fonts/iconfont/iconfont.ttf","hash":"41c4f4dc82e42452dcfd19caed6c7dc333ee769e","modified":1704270748038},{"_id":"public/fonts/iconfont/iconfont.woff","hash":"a57593c49b56c16ac1def0e1f3dbca3f658b3579","modified":1704270748038},{"_id":"public/fonts/iconfont/iconfont.woff2","hash":"39d97a0f72417487f5c1e0a0abf8e27dd6ebda31","modified":1704270748038},{"_id":"public/css/layout.css","hash":"9b81d7e5146871ae2d1010f3a10089bbb43e81e3","modified":1704270748038},{"_id":"public/css/base.css","hash":"2fce73a3c2df8f93edeb5e34a53b7d83e5191d85","modified":1704270748038},{"_id":"public/css/font.css","hash":"87059edd1f2bfc4296f5599e73208893f2b06458","modified":1704270748038},{"_id":"public/css/custom.css","hash":"966bacf523742f4bc2d99deef1c25019dd988eea","modified":1704270748038},{"_id":"public/css/normalize.css","hash":"2d4b663b6a4c68295b6ba240fa2dd9fb3863093c","modified":1704270748038},{"_id":"public/css/variable.css","hash":"cb4180b3bbad471e30cf52ebb40e998d58a30d7d","modified":1704270748038},{"_id":"public/css/media.css","hash":"5023ee404900a47d61ca0591b2d4e9eace0fe88e","modified":1704270748038},{"_id":"public/js/script.js","hash":"5dd8ce4fa55a7201d7e2ffe417b48c95943a906b","modified":1704270748038},{"_id":"public/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1704270748038},{"_id":"public/fonts/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1704270748038},{"_id":"public/fonts/iconfont/iconfont.css","hash":"1e5540dca41dc53879226750f936e72daf616662","modified":1704270748038},{"_id":"public/fonts/iconfont/iconfont.json","hash":"3123aa840109e385d58a75d34e88a2d621e1ada8","modified":1704270748038},{"_id":"public/js/mathjax2.7.5.js","hash":"7ba18c783d543cfb4b45a0118ccb73d3f68cd46e","modified":1704270748038},{"_id":"public/css/style.css","hash":"b03bba06fb21891f5e00e0d3bac8239528531c69","modified":1704270748038},{"_id":"public/fonts/iconfont/demo_index.html","hash":"16e01463756a77b4acd15ade4e6b73f0376d75e1","modified":1704270748038},{"_id":"public/fonts/iconfont/iconfont.js","hash":"87bfdaae31251f4d605646c5ae9c67196f6cc4e2","modified":1704270748038},{"_id":"public/fonts/lanting/lanting.woff2","hash":"5f325fcd2726a5b44e08b7004a5219e14847cbfa","modified":1704270748038},{"_id":"public/fonts/lanting/lanting.woff","hash":"642ad1f17d27d4b1010d1a0571d1b44cbc823d9d","modified":1704270748038},{"_id":"public/fonts/lanting/lanting.eot","hash":"3e184614f037939a6f98d607da3ed7dffb350e65","modified":1704270748038},{"_id":"public/fonts/lanting/lanting.TTF","hash":"97e9a4538cceef4b17d54c7dc589524905d1b685","modified":1704270748038},{"_id":"public/fonts/lanting/lanting.otf","hash":"4e184da596772d3ef6e5763cdee3e46a1ce2f2dd","modified":1704270748038}],"Category":[{"name":"Set Theory","_id":"clqxisunb0007eslr6fiq5jrz"},{"name":"Commutative Algebra","_id":"clqxisune000deslr98nlc8um"},{"name":"Notes","_id":"clqxisunj000oeslr6e9r404q"},{"name":"Sevaral Complex Variables","_id":"clqxisunn0010eslr6baxdgam"},{"name":"Algebraic Geometry","parent":"clqxisune000deslr98nlc8um","_id":"clqxisunq001aeslrf62q3ra3"},{"name":"Algebraic Number Theory","_id":"clqxisunt001meslr7bo62wmk"},{"name":"History of Mathematics","_id":"clqxisunv0023eslrct6ghg41"},{"name":"Nevanlinna Theory","parent":"clqxisunn0010eslr6baxdgam","_id":"clqxisunw0028eslr90xh6y3v"},{"name":"Algebraic Geometry","_id":"clqxisunx002ceslr78smcdkt"},{"name":"Hilbert's 12th Problem","_id":"clqxisunx002feslr3ug406we"},{"name":"Mathematical Logic","_id":"clqxisuny002keslrhug3dwr9"},{"name":"Hilbert's 23 Problems","parent":"clqxisunv0023eslrct6ghg41","_id":"clqxisuny002leslrbk6z28jd"},{"name":"Commutative Algebra","parent":"clqxisunx002feslr3ug406we","_id":"clqxisuny002oeslr33upaz82"},{"name":"Algebraic Number Theory","parent":"clqxisuny002oeslr33upaz82","_id":"clqxisunz002seslrhgewd47w"},{"name":"Algebraic Geometry","parent":"clqxisunz002seslrhgewd47w","_id":"clqxisunz002veslre2sb5bbp"}],"Data":[],"Page":[{"title":"about","layout":"about","date":"2023-03-22T12:52:41.000Z","sticky":100,"top":true,"mathjax":true,"_content":"\nI'm now a Phd student from Sun Yat-sen university. Here's my math blog sharing new ideas and reading notes.\n\n\nThis site is built with [Hexo](https://hexo.io/) + [GitHub](https://github.com/). Math is supported by [Mathjax](https://www.mathjax.org/). Any questions please contact me trough QR code below or [GitHub](https://blueairm.github.io/)\n\n\n","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ndate: 2023-03-22 20:52:41\nsticky: 100\ntop: true\nmathjax: true\n---\n\nI'm now a Phd student from Sun Yat-sen university. Here's my math blog sharing new ideas and reading notes.\n\n\nThis site is built with [Hexo](https://hexo.io/) + [GitHub](https://github.com/). Math is supported by [Mathjax](https://www.mathjax.org/). Any questions please contact me trough QR code below or [GitHub](https://blueairm.github.io/)\n\n\n","updated":"2024-01-02T15:33:46.918Z","path":"about/index.html","comments":1,"_id":"clqxisun00000eslr0spf00nk","content":"<p>I'm now a Phd student from Sun Yat-sen university. Here's my math\r\nblog sharing new ideas and reading notes.</p>\r\n<p>This site is built with <a href=\"https://hexo.io/\">Hexo</a> + <a\r\nhref=\"https://github.com/\">GitHub</a>. Math is supported by <a\r\nhref=\"https://www.mathjax.org/\">Mathjax</a>. Any questions please\r\ncontact me trough QR code below or <a\r\nhref=\"https://blueairm.github.io/\">GitHub</a></p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>I'm now a Phd student from Sun Yat-sen university. Here's my math\r\nblog sharing new ideas and reading notes.</p>\r\n<p>This site is built with <a href=\"https://hexo.io/\">Hexo</a> + <a\r\nhref=\"https://github.com/\">GitHub</a>. Math is supported by <a\r\nhref=\"https://www.mathjax.org/\">Mathjax</a>. Any questions please\r\ncontact me trough QR code below or <a\r\nhref=\"https://blueairm.github.io/\">GitHub</a></p>\r\n"},{"title":"category","layout":"category","date":"2023-04-02T03:14:35.000Z","_content":"","source":"category/index.md","raw":"---\ntitle: category\nlayout: category\ndate: 2023-04-02 11:14:35\n---\n","updated":"2024-01-01T01:31:18.438Z","path":"category/index.html","comments":1,"_id":"clqxisun60002eslr3ny8876y","content":"\r\n","site":{"data":{}},"excerpt":"","more":"\r\n"},{"_content":".gitment-container {\n  font-family: sans-serif;\n  font-size: 14px;\n  line-height: 1.5;\n  color: #333;\n  word-wrap: break-word;\n}\n\n.gitment-container * {\n  box-sizing: border-box;\n}\n\n.gitment-container *:disabled {\n  cursor: not-allowed;\n}\n\n.gitment-container a,\n.gitment-container a:visited {\n  cursor: pointer;\n  text-decoration: none;\n}\n\n.gitment-container a:hover {\n  text-decoration: underline;\n}\n\n.gitment-container .gitment-hidden {\n  display: none;\n}\n\n.gitment-container .gitment-spinner-icon {\n  fill: #333;\n\n  -webkit-animation: gitment-spin 1s steps(12) infinite;\n  animation: gitment-spin 1s steps(12) infinite;\n}\n\n@-webkit-keyframes gitment-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg)\n  }\n}\n\n@keyframes gitment-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg)\n  }\n}\n\n.gitment-root-container {\n  margin: 19px 0;\n}\n\n.gitment-header-container {\n  margin: 19px 0;\n}\n\n.gitment-header-like-btn,\n.gitment-comment-like-btn {\n  cursor: pointer;\n}\n\n.gitment-comment-like-btn {\n  float: right;\n}\n\n.gitment-comment-like-btn.liked {\n  color: #F44336;\n}\n\n.gitment-header-like-btn svg {\n  vertical-align: middle;\n  height: 30px;\n}\n\n.gitment-comment-like-btn svg {\n  vertical-align: middle;\n  height: 20px;\n}\n\n.gitment-header-like-btn.liked svg,\n.gitment-comment-like-btn.liked svg {\n  fill: #F44336;\n}\n\na.gitment-header-issue-link,\na.gitment-header-issue-link:visited {\n  float: right;\n  line-height: 30px;\n  color: #666;\n}\n\na.gitment-header-issue-link:hover {\n  color: #666;\n}\n\n.gitment-comments-loading,\n.gitment-comments-error,\n.gitment-comments-empty {\n  text-align: center;\n  margin: 50px 0;\n}\n\n.gitment-comments-list {\n  list-style: none;\n  padding-left: 0;\n  margin: 0 0 38px;\n}\n\n.gitment-comment,\n.gitment-editor-container {\n  position: relative;\n  min-height: 60px;\n  padding-left: 60px;\n  margin: 19px 0;\n}\n\n.gitment-comment-avatar,\n.gitment-editor-avatar {\n  float: left;\n  margin-left: -60px;\n}\n\n.gitment-comment-avatar,\n.gitment-comment-avatar-img,\n.gitment-comment-avatar,\n.gitment-editor-avatar-img,\n.gitment-editor-avatar svg {\n  width: 44px;\n  height: 44px;\n  border-radius: 3px;\n}\n\n.gitment-editor-avatar .gitment-github-icon {\n  fill: #fff;\n  background-color: #333;\n}\n\n.gitment-comment-main,\n.gitment-editor-main {\n  position: relative;\n  border: 1px solid #CFD8DC;\n  border-radius: 0;\n}\n\n.gitment-editor-main::before,\n.gitment-editor-main::after,\n.gitment-comment-main::before,\n.gitment-comment-main::after {\n  position: absolute;\n  top: 11px;\n  left: -16px;\n  display: block;\n  width: 0;\n  height: 0;\n  pointer-events: none;\n  content: \"\";\n  border-color: transparent;\n  border-style: solid solid outset;\n}\n\n.gitment-editor-main::before,\n.gitment-comment-main::before {\n  border-width: 8px;\n  border-right-color: #CFD8DC;\n}\n\n.gitment-editor-main::after,\n.gitment-comment-main::after {\n  margin-top: 1px;\n  margin-left: 2px;\n  border-width: 7px;\n  border-right-color: #fff;\n}\n\n.gitment-comment-header {\n  margin: 12px 15px;\n  color: #666;\n  background-color: #fff;\n  border-radius: 3px;\n}\n\n.gitment-editor-header {\n  padding: 0;\n  margin: 0;\n  border-bottom: 1px solid #CFD8DC;\n}\n\na.gitment-comment-name,\na.gitment-comment-name:visited {\n  font-weight: 600;\n  color: #666;\n}\n\n.gitment-editor-tabs {\n  margin-bottom: -1px;\n  margin-left: -1px;\n}\n\n.gitment-editor-tab {\n  display: inline-block;\n  padding: 11px 12px;\n  font-size: 14px;\n  line-height: 20px;\n  color: #666;\n  text-decoration: none;\n  background-color: transparent;\n  border-width: 0 1px;\n  border-style: solid;\n  border-color: transparent;\n  border-radius: 0;\n\n  white-space: nowrap;\n  cursor: pointer;\n  user-select: none;\n\n  outline: none;\n}\n\n.gitment-editor-tab.gitment-selected {\n  color: #333;\n  background-color: #fff;\n  border-color: #CFD8DC;\n}\n\n.gitment-editor-login {\n  float: right;\n  margin-top: -30px;\n  margin-right: 15px;\n}\n\na.gitment-footer-project-link,\na.gitment-footer-project-link:visited,\na.gitment-editor-login-link,\na.gitment-editor-login-link:visited {\n  color: #2196F3;\n}\n\na.gitment-editor-logout-link,\na.gitment-editor-logout-link:visited {\n  color: #666;\n}\n\na.gitment-editor-logout-link:hover {\n  color: #2196F3;\n  text-decoration: none;\n}\n\n.gitment-comment-body {\n  position: relative;\n  margin: 12px 15px;\n  overflow: hidden;\n  border-radius: 3px;\n}\n\n.gitment-comment-body-folded {\n  cursor: pointer;\n}\n\n.gitment-comment-body-folded::before {\n  display: block !important;\n  content: \"\";\n  position: absolute;\n  width: 100%;\n  left: 0;\n  top: 0;\n  bottom: 50px;\n  pointer-events: none;\n  background: -webkit-linear-gradient(top, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9));\n  background: linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9));\n}\n\n.gitment-comment-body-folded::after {\n  display: block !important;\n  content: \"Click to Expand\" !important;\n  text-align: center;\n  color: #666;\n  position: absolute;\n  width: 100%;\n  height: 50px;\n  line-height: 50px;\n  left: 0;\n  bottom: 0;\n  pointer-events: none;\n  background: rgba(255, 255, 255, .9);\n}\n\n.gitment-editor-body {\n  margin: 0;\n}\n\n.gitment-comment-body > *:first-child,\n.gitment-editor-preview > *:first-child {\n  margin-top: 0 !important;\n}\n\n.gitment-comment-body > *:last-child,\n.gitment-editor-preview > *:last-child {\n  margin-bottom: 0 !important;\n}\n\n.gitment-editor-body textarea {\n  display: block;\n  width: 100%;\n  min-height: 150px;\n  max-height: 500px;\n  padding: 16px;\n  resize: vertical;\n\n  max-width: 100%;\n  margin: 0;\n  font-size: 14px;\n  line-height: 1.6;\n\n  background-color: #fff;\n\n  color: #333;\n  vertical-align: middle;\n  border: none;\n  border-radius: 0;\n  outline: none;\n  box-shadow: none;\n\n  overflow: visible;\n}\n\n.gitment-editor-body textarea:focus {\n  background-color: #fff;\n}\n\n.gitment-editor-preview {\n  min-height: 150px;\n\n  padding: 16px;\n  background-color: transparent;\n\n  width: 100%;\n  font-size: 14px;\n\n  line-height: 1.5;\n  word-wrap: break-word;\n}\n\n.gitment-editor-footer {\n  padding: 0;\n  margin-top: 10px;\n}\n\n.gitment-editor-footer::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\na.gitment-editor-footer-tip {\n  display: inline-block;\n  padding-top: 10px;\n  font-size: 12px;\n  color: #666;\n}\n\na.gitment-editor-footer-tip:hover {\n  color: #2196F3;\n  text-decoration: none;\n}\n\n.gitment-comments-pagination {\n  list-style: none;\n  text-align: right;\n  border-radius: 0;\n  margin: -19px 0 19px 0;\n}\n\n.gitment-comments-page-item {\n  display: inline-block;\n  cursor: pointer;\n  border: 1px solid #CFD8DC;\n  margin-left: -1px;\n  padding: .25rem .5rem;\n}\n\n.gitment-comments-page-item:hover {\n  background-color: #f5f5f5;\n}\n\n.gitment-comments-page-item.gitment-selected {\n  background-color: #f5f5f5;\n}\n\n.gitment-editor-submit,\n.gitment-comments-init-btn {\n  color: #fff;\n  background-color: #00BCD4;\n\n  position: relative;\n  display: inline-block;\n  padding: 7px 13px;\n  font-size: 14px;\n  font-weight: 600;\n  line-height: 20px;\n  white-space: nowrap;\n  vertical-align: middle;\n  cursor: pointer;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  background-size: 110% 110%;\n  border: none;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n}\n\n.gitment-editor-submit:hover,\n.gitment-comments-init-btn:hover {\n  background-color: #00ACC1;\n}\n\n.gitment-comments-init-btn:disabled,\n.gitment-editor-submit:disabled {\n  color: rgba(255,255,255,0.75);\n  background-color: #4DD0E1;\n  box-shadow: none;\n}\n\n.gitment-editor-submit {\n  float: right;\n}\n\n.gitment-footer-container {\n  margin-top: 30px;\n  margin-bottom: 20px;\n  text-align: right;\n  font-size: 12px;\n}\n\n/*\n * Markdown CSS\n * Copied from https://github.com/sindresorhus/github-markdown-css\n */\n.gitment-markdown {\n  -ms-text-size-adjust: 100%;\n  -webkit-text-size-adjust: 100%;\n  line-height: 1.5;\n  color: #333;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n  font-size: 16px;\n  line-height: 1.5;\n  word-wrap: break-word;\n}\n\n.gitment-markdown .pl-c {\n  color: #969896;\n}\n\n.gitment-markdown .pl-c1,\n.gitment-markdown .pl-s .pl-v {\n  color: #0086b3;\n}\n\n.gitment-markdown .pl-e,\n.gitment-markdown .pl-en {\n  color: #795da3;\n}\n\n.gitment-markdown .pl-smi,\n.gitment-markdown .pl-s .pl-s1 {\n  color: #333;\n}\n\n.gitment-markdown .pl-ent {\n  color: #63a35c;\n}\n\n.gitment-markdown .pl-k {\n  color: #a71d5d;\n}\n\n.gitment-markdown .pl-s,\n.gitment-markdown .pl-pds,\n.gitment-markdown .pl-s .pl-pse .pl-s1,\n.gitment-markdown .pl-sr,\n.gitment-markdown .pl-sr .pl-cce,\n.gitment-markdown .pl-sr .pl-sre,\n.gitment-markdown .pl-sr .pl-sra {\n  color: #183691;\n}\n\n.gitment-markdown .pl-v,\n.gitment-markdown .pl-smw {\n  color: #ed6a43;\n}\n\n.gitment-markdown .pl-bu {\n  color: #b52a1d;\n}\n\n.gitment-markdown .pl-ii {\n  color: #f8f8f8;\n  background-color: #b52a1d;\n}\n\n.gitment-markdown .pl-c2 {\n  color: #f8f8f8;\n  background-color: #b52a1d;\n}\n\n.gitment-markdown .pl-c2::before {\n  content: \"^M\";\n}\n\n.gitment-markdown .pl-sr .pl-cce {\n  font-weight: bold;\n  color: #63a35c;\n}\n\n.gitment-markdown .pl-ml {\n  color: #693a17;\n}\n\n.gitment-markdown .pl-mh,\n.gitment-markdown .pl-mh .pl-en,\n.gitment-markdown .pl-ms {\n  font-weight: bold;\n  color: #1d3e81;\n}\n\n.gitment-markdown .pl-mq {\n  color: #008080;\n}\n\n.gitment-markdown .pl-mi {\n  font-style: italic;\n  color: #333;\n}\n\n.gitment-markdown .pl-mb {\n  font-weight: bold;\n  color: #333;\n}\n\n.gitment-markdown .pl-md {\n  color: #bd2c00;\n  background-color: #ffecec;\n}\n\n.gitment-markdown .pl-mi1 {\n  color: #55a532;\n  background-color: #eaffea;\n}\n\n.gitment-markdown .pl-mc {\n  color: #ef9700;\n  background-color: #ffe3b4;\n}\n\n.gitment-markdown .pl-mi2 {\n  color: #d8d8d8;\n  background-color: #808080;\n}\n\n.gitment-markdown .pl-mdr {\n  font-weight: bold;\n  color: #795da3;\n}\n\n.gitment-markdown .pl-mo {\n  color: #1d3e81;\n}\n\n.gitment-markdown .pl-ba {\n  color: #595e62;\n}\n\n.gitment-markdown .pl-sg {\n  color: #c0c0c0;\n}\n\n.gitment-markdown .pl-corl {\n  text-decoration: underline;\n  color: #183691;\n}\n\n.gitment-markdown .octicon {\n  display: inline-block;\n  vertical-align: text-top;\n  fill: currentColor;\n}\n\n.gitment-markdown a {\n  background-color: transparent;\n  -webkit-text-decoration-skip: objects;\n}\n\n.gitment-markdown a:active,\n.gitment-markdown a:hover {\n  outline-width: 0;\n}\n\n.gitment-markdown strong {\n  font-weight: inherit;\n}\n\n.gitment-markdown strong {\n  font-weight: bolder;\n}\n\n.gitment-markdown h1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n.gitment-markdown img {\n  border-style: none;\n}\n\n.gitment-markdown svg:not(:root) {\n  overflow: hidden;\n}\n\n.gitment-markdown code,\n.gitment-markdown kbd,\n.gitment-markdown pre {\n  font-family: monospace, monospace;\n  font-size: 1em;\n}\n\n.gitment-markdown hr {\n  box-sizing: content-box;\n  height: 0;\n  overflow: visible;\n}\n\n.gitment-markdown input {\n  font: inherit;\n  margin: 0;\n}\n\n.gitment-markdown input {\n  overflow: visible;\n}\n\n.gitment-markdown [type=\"checkbox\"] {\n  box-sizing: border-box;\n  padding: 0;\n}\n\n.gitment-markdown * {\n  box-sizing: border-box;\n}\n\n.gitment-markdown input {\n  font-family: inherit;\n  font-size: inherit;\n  line-height: inherit;\n}\n\n.gitment-markdown a {\n  color: #0366d6;\n  text-decoration: none;\n}\n\n.gitment-markdown a:hover {\n  text-decoration: underline;\n}\n\n.gitment-markdown strong {\n  font-weight: 600;\n}\n\n.gitment-markdown hr {\n  height: 0;\n  margin: 15px 0;\n  overflow: hidden;\n  background: transparent;\n  border: 0;\n  border-bottom: 1px solid #dfe2e5;\n}\n\n.gitment-markdown hr::before {\n  display: table;\n  content: \"\";\n}\n\n.gitment-markdown hr::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\n.gitment-markdown table {\n  border-spacing: 0;\n  border-collapse: collapse;\n}\n\n.gitment-markdown td,\n.gitment-markdown th {\n  padding: 0;\n}\n\n.gitment-markdown h1,\n.gitment-markdown h2,\n.gitment-markdown h3,\n.gitment-markdown h4,\n.gitment-markdown h5,\n.gitment-markdown h6 {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown h1 {\n  font-size: 32px;\n  font-weight: 600;\n}\n\n.gitment-markdown h2 {\n  font-size: 24px;\n  font-weight: 600;\n}\n\n.gitment-markdown h3 {\n  font-size: 20px;\n  font-weight: 600;\n}\n\n.gitment-markdown h4 {\n  font-size: 16px;\n  font-weight: 600;\n}\n\n.gitment-markdown h5 {\n  font-size: 14px;\n  font-weight: 600;\n}\n\n.gitment-markdown h6 {\n  font-size: 12px;\n  font-weight: 600;\n}\n\n.gitment-markdown p {\n  margin-top: 0;\n  margin-bottom: 10px;\n}\n\n.gitment-markdown blockquote {\n  margin: 0;\n}\n\n.gitment-markdown ul,\n.gitment-markdown ol {\n  padding-left: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown ol ol,\n.gitment-markdown ul ol {\n  list-style-type: lower-roman;\n}\n\n.gitment-markdown ul ul ol,\n.gitment-markdown ul ol ol,\n.gitment-markdown ol ul ol,\n.gitment-markdown ol ol ol {\n  list-style-type: lower-alpha;\n}\n\n.gitment-markdown dd {\n  margin-left: 0;\n}\n\n.gitment-markdown code {\n  font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  font-size: 12px;\n}\n\n.gitment-markdown pre {\n  margin-top: 0;\n  margin-bottom: 0;\n  font: 12px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n}\n\n.gitment-markdown .octicon {\n  vertical-align: text-bottom;\n}\n\n.gitment-markdown .pl-0 {\n  padding-left: 0 !important;\n}\n\n.gitment-markdown .pl-1 {\n  padding-left: 4px !important;\n}\n\n.gitment-markdown .pl-2 {\n  padding-left: 8px !important;\n}\n\n.gitment-markdown .pl-3 {\n  padding-left: 16px !important;\n}\n\n.gitment-markdown .pl-4 {\n  padding-left: 24px !important;\n}\n\n.gitment-markdown .pl-5 {\n  padding-left: 32px !important;\n}\n\n.gitment-markdown .pl-6 {\n  padding-left: 40px !important;\n}\n\n.gitment-markdown::before {\n  display: table;\n  content: \"\";\n}\n\n.gitment-markdown::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\n.gitment-markdown>*:first-child {\n  margin-top: 0 !important;\n}\n\n.gitment-markdown>*:last-child {\n  margin-bottom: 0 !important;\n}\n\n.gitment-markdown a:not([href]) {\n  color: inherit;\n  text-decoration: none;\n}\n\n.gitment-markdown .anchor {\n  float: left;\n  padding-right: 4px;\n  margin-left: -20px;\n  line-height: 1;\n}\n\n.gitment-markdown .anchor:focus {\n  outline: none;\n}\n\n.gitment-markdown p,\n.gitment-markdown blockquote,\n.gitment-markdown ul,\n.gitment-markdown ol,\n.gitment-markdown dl,\n.gitment-markdown table,\n.gitment-markdown pre {\n  margin-top: 0;\n  margin-bottom: 16px;\n}\n\n.gitment-markdown hr {\n  height: 0.25em;\n  padding: 0;\n  margin: 24px 0;\n  background-color: #e1e4e8;\n  border: 0;\n}\n\n.gitment-markdown blockquote {\n  padding: 0 1em;\n  color: #6a737d;\n  border-left: 0.25em solid #dfe2e5;\n}\n\n.gitment-markdown blockquote>:first-child {\n  margin-top: 0;\n}\n\n.gitment-markdown blockquote>:last-child {\n  margin-bottom: 0;\n}\n\n.gitment-markdown kbd {\n  display: inline-block;\n  padding: 3px 5px;\n  font-size: 11px;\n  line-height: 10px;\n  color: #444d56;\n  vertical-align: middle;\n  background-color: #fafbfc;\n  border: solid 1px #c6cbd1;\n  border-bottom-color: #959da5;\n  border-radius: 0;\n  box-shadow: inset 0 -1px 0 #959da5;\n}\n\n.gitment-markdown h1,\n.gitment-markdown h2,\n.gitment-markdown h3,\n.gitment-markdown h4,\n.gitment-markdown h5,\n.gitment-markdown h6 {\n  margin-top: 24px;\n  margin-bottom: 16px;\n  font-weight: 600;\n  line-height: 1.25;\n}\n\n.gitment-markdown h1 .octicon-link,\n.gitment-markdown h2 .octicon-link,\n.gitment-markdown h3 .octicon-link,\n.gitment-markdown h4 .octicon-link,\n.gitment-markdown h5 .octicon-link,\n.gitment-markdown h6 .octicon-link {\n  color: #1b1f23;\n  vertical-align: middle;\n  visibility: hidden;\n}\n\n.gitment-markdown h1:hover .anchor,\n.gitment-markdown h2:hover .anchor,\n.gitment-markdown h3:hover .anchor,\n.gitment-markdown h4:hover .anchor,\n.gitment-markdown h5:hover .anchor,\n.gitment-markdown h6:hover .anchor {\n  text-decoration: none;\n}\n\n.gitment-markdown h1:hover .anchor .octicon-link,\n.gitment-markdown h2:hover .anchor .octicon-link,\n.gitment-markdown h3:hover .anchor .octicon-link,\n.gitment-markdown h4:hover .anchor .octicon-link,\n.gitment-markdown h5:hover .anchor .octicon-link,\n.gitment-markdown h6:hover .anchor .octicon-link {\n  visibility: visible;\n}\n\n.gitment-markdown h1 {\n  padding-bottom: 0.3em;\n  font-size: 2em;\n  border-bottom: 1px solid #eaecef;\n}\n\n.gitment-markdown h2 {\n  padding-bottom: 0.3em;\n  font-size: 1.5em;\n  border-bottom: 1px solid #eaecef;\n}\n\n.gitment-markdown h3 {\n  font-size: 1.25em;\n}\n\n.gitment-markdown h4 {\n  font-size: 1em;\n}\n\n.gitment-markdown h5 {\n  font-size: 0.875em;\n}\n\n.gitment-markdown h6 {\n  font-size: 0.85em;\n  color: #6a737d;\n}\n\n.gitment-markdown ul,\n.gitment-markdown ol {\n  padding-left: 2em;\n}\n\n.gitment-markdown ul ul,\n.gitment-markdown ul ol,\n.gitment-markdown ol ol,\n.gitment-markdown ol ul {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown li>p {\n  margin-top: 16px;\n}\n\n.gitment-markdown li+li {\n  margin-top: 0.25em;\n}\n\n.gitment-markdown dl {\n  padding: 0;\n}\n\n.gitment-markdown dl dt {\n  padding: 0;\n  margin-top: 16px;\n  font-size: 1em;\n  font-style: italic;\n  font-weight: 600;\n}\n\n.gitment-markdown dl dd {\n  padding: 0 16px;\n  margin-bottom: 16px;\n}\n\n.gitment-markdown table {\n  display: block;\n  width: 100%;\n  overflow: auto;\n}\n\n.gitment-markdown table th {\n  font-weight: 600;\n}\n\n.gitment-markdown table th,\n.gitment-markdown table td {\n  padding: 6px 13px;\n  border: 1px solid #dfe2e5;\n}\n\n.gitment-markdown table tr {\n  background-color: #fff;\n  border-top: 1px solid #c6cbd1;\n}\n\n.gitment-markdown table tr:nth-child(2n) {\n  background-color: #f5f5f5;\n}\n\n.gitment-markdown img {\n  max-width: 100%;\n  box-sizing: content-box;\n  background-color: #fff;\n}\n\n.gitment-markdown code {\n  padding: 0;\n  padding-top: 0.2em;\n  padding-bottom: 0.2em;\n  margin: 0;\n  font-size: 85%;\n  background-color: rgba(27,31,35,0.05);\n  border-radius: 0;\n}\n\n.gitment-markdown code::before,\n.gitment-markdown code::after {\n  letter-spacing: -0.2em;\n  content: \"\\00a0\";\n}\n\n.gitment-markdown pre {\n  word-wrap: normal;\n}\n\n.gitment-markdown pre>code {\n  padding: 0;\n  margin: 0;\n  font-size: 100%;\n  word-break: normal;\n  white-space: pre;\n  background: transparent;\n  border: 0;\n}\n\n.gitment-markdown .highlight {\n  margin-bottom: 16px;\n}\n\n.gitment-markdown .highlight pre {\n  margin-bottom: 0;\n  word-break: normal;\n}\n\n.gitment-markdown .highlight pre,\n.gitment-markdown pre {\n  padding: 16px;\n  overflow: auto;\n  font-size: 85%;\n  line-height: 1.45;\n  background-color: #f5f5f5;\n  border-radius: 0;\n}\n\n.gitment-markdown pre code {\n  display: inline;\n  max-width: auto;\n  padding: 0;\n  margin: 0;\n  overflow: visible;\n  line-height: inherit;\n  word-wrap: normal;\n  background-color: transparent;\n  border: 0;\n}\n\n.gitment-markdown pre code::before,\n.gitment-markdown pre code::after {\n  content: normal;\n}\n\n.gitment-markdown .full-commit .btn-outline:not(:disabled):hover {\n  color: #005cc5;\n  border-color: #005cc5;\n}\n\n.gitment-markdown kbd {\n  display: inline-block;\n  padding: 3px 5px;\n  font: 11px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  line-height: 10px;\n  color: #444d56;\n  vertical-align: middle;\n  background-color: #fcfcfc;\n  border: solid 1px #c6cbd1;\n  border-bottom-color: #959da5;\n  border-radius: 0;\n  box-shadow: inset 0 -1px 0 #959da5;\n}\n\n.gitment-markdown :checked+.radio-label {\n  position: relative;\n  z-index: 1;\n  border-color: #0366d6;\n}\n\n.gitment-markdown .task-list-item {\n  list-style-type: none;\n}\n\n.gitment-markdown .task-list-item+.task-list-item {\n  margin-top: 3px;\n}\n\n.gitment-markdown .task-list-item input {\n  margin: 0 0.2em 0.25em -1.6em;\n  vertical-align: middle;\n}\n\n.gitment-markdown hr {\n  border-bottom-color: #eee;\n}\n","source":"css/gitment.css","raw":".gitment-container {\n  font-family: sans-serif;\n  font-size: 14px;\n  line-height: 1.5;\n  color: #333;\n  word-wrap: break-word;\n}\n\n.gitment-container * {\n  box-sizing: border-box;\n}\n\n.gitment-container *:disabled {\n  cursor: not-allowed;\n}\n\n.gitment-container a,\n.gitment-container a:visited {\n  cursor: pointer;\n  text-decoration: none;\n}\n\n.gitment-container a:hover {\n  text-decoration: underline;\n}\n\n.gitment-container .gitment-hidden {\n  display: none;\n}\n\n.gitment-container .gitment-spinner-icon {\n  fill: #333;\n\n  -webkit-animation: gitment-spin 1s steps(12) infinite;\n  animation: gitment-spin 1s steps(12) infinite;\n}\n\n@-webkit-keyframes gitment-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg)\n  }\n}\n\n@keyframes gitment-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg)\n  }\n}\n\n.gitment-root-container {\n  margin: 19px 0;\n}\n\n.gitment-header-container {\n  margin: 19px 0;\n}\n\n.gitment-header-like-btn,\n.gitment-comment-like-btn {\n  cursor: pointer;\n}\n\n.gitment-comment-like-btn {\n  float: right;\n}\n\n.gitment-comment-like-btn.liked {\n  color: #F44336;\n}\n\n.gitment-header-like-btn svg {\n  vertical-align: middle;\n  height: 30px;\n}\n\n.gitment-comment-like-btn svg {\n  vertical-align: middle;\n  height: 20px;\n}\n\n.gitment-header-like-btn.liked svg,\n.gitment-comment-like-btn.liked svg {\n  fill: #F44336;\n}\n\na.gitment-header-issue-link,\na.gitment-header-issue-link:visited {\n  float: right;\n  line-height: 30px;\n  color: #666;\n}\n\na.gitment-header-issue-link:hover {\n  color: #666;\n}\n\n.gitment-comments-loading,\n.gitment-comments-error,\n.gitment-comments-empty {\n  text-align: center;\n  margin: 50px 0;\n}\n\n.gitment-comments-list {\n  list-style: none;\n  padding-left: 0;\n  margin: 0 0 38px;\n}\n\n.gitment-comment,\n.gitment-editor-container {\n  position: relative;\n  min-height: 60px;\n  padding-left: 60px;\n  margin: 19px 0;\n}\n\n.gitment-comment-avatar,\n.gitment-editor-avatar {\n  float: left;\n  margin-left: -60px;\n}\n\n.gitment-comment-avatar,\n.gitment-comment-avatar-img,\n.gitment-comment-avatar,\n.gitment-editor-avatar-img,\n.gitment-editor-avatar svg {\n  width: 44px;\n  height: 44px;\n  border-radius: 3px;\n}\n\n.gitment-editor-avatar .gitment-github-icon {\n  fill: #fff;\n  background-color: #333;\n}\n\n.gitment-comment-main,\n.gitment-editor-main {\n  position: relative;\n  border: 1px solid #CFD8DC;\n  border-radius: 0;\n}\n\n.gitment-editor-main::before,\n.gitment-editor-main::after,\n.gitment-comment-main::before,\n.gitment-comment-main::after {\n  position: absolute;\n  top: 11px;\n  left: -16px;\n  display: block;\n  width: 0;\n  height: 0;\n  pointer-events: none;\n  content: \"\";\n  border-color: transparent;\n  border-style: solid solid outset;\n}\n\n.gitment-editor-main::before,\n.gitment-comment-main::before {\n  border-width: 8px;\n  border-right-color: #CFD8DC;\n}\n\n.gitment-editor-main::after,\n.gitment-comment-main::after {\n  margin-top: 1px;\n  margin-left: 2px;\n  border-width: 7px;\n  border-right-color: #fff;\n}\n\n.gitment-comment-header {\n  margin: 12px 15px;\n  color: #666;\n  background-color: #fff;\n  border-radius: 3px;\n}\n\n.gitment-editor-header {\n  padding: 0;\n  margin: 0;\n  border-bottom: 1px solid #CFD8DC;\n}\n\na.gitment-comment-name,\na.gitment-comment-name:visited {\n  font-weight: 600;\n  color: #666;\n}\n\n.gitment-editor-tabs {\n  margin-bottom: -1px;\n  margin-left: -1px;\n}\n\n.gitment-editor-tab {\n  display: inline-block;\n  padding: 11px 12px;\n  font-size: 14px;\n  line-height: 20px;\n  color: #666;\n  text-decoration: none;\n  background-color: transparent;\n  border-width: 0 1px;\n  border-style: solid;\n  border-color: transparent;\n  border-radius: 0;\n\n  white-space: nowrap;\n  cursor: pointer;\n  user-select: none;\n\n  outline: none;\n}\n\n.gitment-editor-tab.gitment-selected {\n  color: #333;\n  background-color: #fff;\n  border-color: #CFD8DC;\n}\n\n.gitment-editor-login {\n  float: right;\n  margin-top: -30px;\n  margin-right: 15px;\n}\n\na.gitment-footer-project-link,\na.gitment-footer-project-link:visited,\na.gitment-editor-login-link,\na.gitment-editor-login-link:visited {\n  color: #2196F3;\n}\n\na.gitment-editor-logout-link,\na.gitment-editor-logout-link:visited {\n  color: #666;\n}\n\na.gitment-editor-logout-link:hover {\n  color: #2196F3;\n  text-decoration: none;\n}\n\n.gitment-comment-body {\n  position: relative;\n  margin: 12px 15px;\n  overflow: hidden;\n  border-radius: 3px;\n}\n\n.gitment-comment-body-folded {\n  cursor: pointer;\n}\n\n.gitment-comment-body-folded::before {\n  display: block !important;\n  content: \"\";\n  position: absolute;\n  width: 100%;\n  left: 0;\n  top: 0;\n  bottom: 50px;\n  pointer-events: none;\n  background: -webkit-linear-gradient(top, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9));\n  background: linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9));\n}\n\n.gitment-comment-body-folded::after {\n  display: block !important;\n  content: \"Click to Expand\" !important;\n  text-align: center;\n  color: #666;\n  position: absolute;\n  width: 100%;\n  height: 50px;\n  line-height: 50px;\n  left: 0;\n  bottom: 0;\n  pointer-events: none;\n  background: rgba(255, 255, 255, .9);\n}\n\n.gitment-editor-body {\n  margin: 0;\n}\n\n.gitment-comment-body > *:first-child,\n.gitment-editor-preview > *:first-child {\n  margin-top: 0 !important;\n}\n\n.gitment-comment-body > *:last-child,\n.gitment-editor-preview > *:last-child {\n  margin-bottom: 0 !important;\n}\n\n.gitment-editor-body textarea {\n  display: block;\n  width: 100%;\n  min-height: 150px;\n  max-height: 500px;\n  padding: 16px;\n  resize: vertical;\n\n  max-width: 100%;\n  margin: 0;\n  font-size: 14px;\n  line-height: 1.6;\n\n  background-color: #fff;\n\n  color: #333;\n  vertical-align: middle;\n  border: none;\n  border-radius: 0;\n  outline: none;\n  box-shadow: none;\n\n  overflow: visible;\n}\n\n.gitment-editor-body textarea:focus {\n  background-color: #fff;\n}\n\n.gitment-editor-preview {\n  min-height: 150px;\n\n  padding: 16px;\n  background-color: transparent;\n\n  width: 100%;\n  font-size: 14px;\n\n  line-height: 1.5;\n  word-wrap: break-word;\n}\n\n.gitment-editor-footer {\n  padding: 0;\n  margin-top: 10px;\n}\n\n.gitment-editor-footer::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\na.gitment-editor-footer-tip {\n  display: inline-block;\n  padding-top: 10px;\n  font-size: 12px;\n  color: #666;\n}\n\na.gitment-editor-footer-tip:hover {\n  color: #2196F3;\n  text-decoration: none;\n}\n\n.gitment-comments-pagination {\n  list-style: none;\n  text-align: right;\n  border-radius: 0;\n  margin: -19px 0 19px 0;\n}\n\n.gitment-comments-page-item {\n  display: inline-block;\n  cursor: pointer;\n  border: 1px solid #CFD8DC;\n  margin-left: -1px;\n  padding: .25rem .5rem;\n}\n\n.gitment-comments-page-item:hover {\n  background-color: #f5f5f5;\n}\n\n.gitment-comments-page-item.gitment-selected {\n  background-color: #f5f5f5;\n}\n\n.gitment-editor-submit,\n.gitment-comments-init-btn {\n  color: #fff;\n  background-color: #00BCD4;\n\n  position: relative;\n  display: inline-block;\n  padding: 7px 13px;\n  font-size: 14px;\n  font-weight: 600;\n  line-height: 20px;\n  white-space: nowrap;\n  vertical-align: middle;\n  cursor: pointer;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  background-size: 110% 110%;\n  border: none;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n}\n\n.gitment-editor-submit:hover,\n.gitment-comments-init-btn:hover {\n  background-color: #00ACC1;\n}\n\n.gitment-comments-init-btn:disabled,\n.gitment-editor-submit:disabled {\n  color: rgba(255,255,255,0.75);\n  background-color: #4DD0E1;\n  box-shadow: none;\n}\n\n.gitment-editor-submit {\n  float: right;\n}\n\n.gitment-footer-container {\n  margin-top: 30px;\n  margin-bottom: 20px;\n  text-align: right;\n  font-size: 12px;\n}\n\n/*\n * Markdown CSS\n * Copied from https://github.com/sindresorhus/github-markdown-css\n */\n.gitment-markdown {\n  -ms-text-size-adjust: 100%;\n  -webkit-text-size-adjust: 100%;\n  line-height: 1.5;\n  color: #333;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n  font-size: 16px;\n  line-height: 1.5;\n  word-wrap: break-word;\n}\n\n.gitment-markdown .pl-c {\n  color: #969896;\n}\n\n.gitment-markdown .pl-c1,\n.gitment-markdown .pl-s .pl-v {\n  color: #0086b3;\n}\n\n.gitment-markdown .pl-e,\n.gitment-markdown .pl-en {\n  color: #795da3;\n}\n\n.gitment-markdown .pl-smi,\n.gitment-markdown .pl-s .pl-s1 {\n  color: #333;\n}\n\n.gitment-markdown .pl-ent {\n  color: #63a35c;\n}\n\n.gitment-markdown .pl-k {\n  color: #a71d5d;\n}\n\n.gitment-markdown .pl-s,\n.gitment-markdown .pl-pds,\n.gitment-markdown .pl-s .pl-pse .pl-s1,\n.gitment-markdown .pl-sr,\n.gitment-markdown .pl-sr .pl-cce,\n.gitment-markdown .pl-sr .pl-sre,\n.gitment-markdown .pl-sr .pl-sra {\n  color: #183691;\n}\n\n.gitment-markdown .pl-v,\n.gitment-markdown .pl-smw {\n  color: #ed6a43;\n}\n\n.gitment-markdown .pl-bu {\n  color: #b52a1d;\n}\n\n.gitment-markdown .pl-ii {\n  color: #f8f8f8;\n  background-color: #b52a1d;\n}\n\n.gitment-markdown .pl-c2 {\n  color: #f8f8f8;\n  background-color: #b52a1d;\n}\n\n.gitment-markdown .pl-c2::before {\n  content: \"^M\";\n}\n\n.gitment-markdown .pl-sr .pl-cce {\n  font-weight: bold;\n  color: #63a35c;\n}\n\n.gitment-markdown .pl-ml {\n  color: #693a17;\n}\n\n.gitment-markdown .pl-mh,\n.gitment-markdown .pl-mh .pl-en,\n.gitment-markdown .pl-ms {\n  font-weight: bold;\n  color: #1d3e81;\n}\n\n.gitment-markdown .pl-mq {\n  color: #008080;\n}\n\n.gitment-markdown .pl-mi {\n  font-style: italic;\n  color: #333;\n}\n\n.gitment-markdown .pl-mb {\n  font-weight: bold;\n  color: #333;\n}\n\n.gitment-markdown .pl-md {\n  color: #bd2c00;\n  background-color: #ffecec;\n}\n\n.gitment-markdown .pl-mi1 {\n  color: #55a532;\n  background-color: #eaffea;\n}\n\n.gitment-markdown .pl-mc {\n  color: #ef9700;\n  background-color: #ffe3b4;\n}\n\n.gitment-markdown .pl-mi2 {\n  color: #d8d8d8;\n  background-color: #808080;\n}\n\n.gitment-markdown .pl-mdr {\n  font-weight: bold;\n  color: #795da3;\n}\n\n.gitment-markdown .pl-mo {\n  color: #1d3e81;\n}\n\n.gitment-markdown .pl-ba {\n  color: #595e62;\n}\n\n.gitment-markdown .pl-sg {\n  color: #c0c0c0;\n}\n\n.gitment-markdown .pl-corl {\n  text-decoration: underline;\n  color: #183691;\n}\n\n.gitment-markdown .octicon {\n  display: inline-block;\n  vertical-align: text-top;\n  fill: currentColor;\n}\n\n.gitment-markdown a {\n  background-color: transparent;\n  -webkit-text-decoration-skip: objects;\n}\n\n.gitment-markdown a:active,\n.gitment-markdown a:hover {\n  outline-width: 0;\n}\n\n.gitment-markdown strong {\n  font-weight: inherit;\n}\n\n.gitment-markdown strong {\n  font-weight: bolder;\n}\n\n.gitment-markdown h1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n.gitment-markdown img {\n  border-style: none;\n}\n\n.gitment-markdown svg:not(:root) {\n  overflow: hidden;\n}\n\n.gitment-markdown code,\n.gitment-markdown kbd,\n.gitment-markdown pre {\n  font-family: monospace, monospace;\n  font-size: 1em;\n}\n\n.gitment-markdown hr {\n  box-sizing: content-box;\n  height: 0;\n  overflow: visible;\n}\n\n.gitment-markdown input {\n  font: inherit;\n  margin: 0;\n}\n\n.gitment-markdown input {\n  overflow: visible;\n}\n\n.gitment-markdown [type=\"checkbox\"] {\n  box-sizing: border-box;\n  padding: 0;\n}\n\n.gitment-markdown * {\n  box-sizing: border-box;\n}\n\n.gitment-markdown input {\n  font-family: inherit;\n  font-size: inherit;\n  line-height: inherit;\n}\n\n.gitment-markdown a {\n  color: #0366d6;\n  text-decoration: none;\n}\n\n.gitment-markdown a:hover {\n  text-decoration: underline;\n}\n\n.gitment-markdown strong {\n  font-weight: 600;\n}\n\n.gitment-markdown hr {\n  height: 0;\n  margin: 15px 0;\n  overflow: hidden;\n  background: transparent;\n  border: 0;\n  border-bottom: 1px solid #dfe2e5;\n}\n\n.gitment-markdown hr::before {\n  display: table;\n  content: \"\";\n}\n\n.gitment-markdown hr::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\n.gitment-markdown table {\n  border-spacing: 0;\n  border-collapse: collapse;\n}\n\n.gitment-markdown td,\n.gitment-markdown th {\n  padding: 0;\n}\n\n.gitment-markdown h1,\n.gitment-markdown h2,\n.gitment-markdown h3,\n.gitment-markdown h4,\n.gitment-markdown h5,\n.gitment-markdown h6 {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown h1 {\n  font-size: 32px;\n  font-weight: 600;\n}\n\n.gitment-markdown h2 {\n  font-size: 24px;\n  font-weight: 600;\n}\n\n.gitment-markdown h3 {\n  font-size: 20px;\n  font-weight: 600;\n}\n\n.gitment-markdown h4 {\n  font-size: 16px;\n  font-weight: 600;\n}\n\n.gitment-markdown h5 {\n  font-size: 14px;\n  font-weight: 600;\n}\n\n.gitment-markdown h6 {\n  font-size: 12px;\n  font-weight: 600;\n}\n\n.gitment-markdown p {\n  margin-top: 0;\n  margin-bottom: 10px;\n}\n\n.gitment-markdown blockquote {\n  margin: 0;\n}\n\n.gitment-markdown ul,\n.gitment-markdown ol {\n  padding-left: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown ol ol,\n.gitment-markdown ul ol {\n  list-style-type: lower-roman;\n}\n\n.gitment-markdown ul ul ol,\n.gitment-markdown ul ol ol,\n.gitment-markdown ol ul ol,\n.gitment-markdown ol ol ol {\n  list-style-type: lower-alpha;\n}\n\n.gitment-markdown dd {\n  margin-left: 0;\n}\n\n.gitment-markdown code {\n  font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  font-size: 12px;\n}\n\n.gitment-markdown pre {\n  margin-top: 0;\n  margin-bottom: 0;\n  font: 12px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n}\n\n.gitment-markdown .octicon {\n  vertical-align: text-bottom;\n}\n\n.gitment-markdown .pl-0 {\n  padding-left: 0 !important;\n}\n\n.gitment-markdown .pl-1 {\n  padding-left: 4px !important;\n}\n\n.gitment-markdown .pl-2 {\n  padding-left: 8px !important;\n}\n\n.gitment-markdown .pl-3 {\n  padding-left: 16px !important;\n}\n\n.gitment-markdown .pl-4 {\n  padding-left: 24px !important;\n}\n\n.gitment-markdown .pl-5 {\n  padding-left: 32px !important;\n}\n\n.gitment-markdown .pl-6 {\n  padding-left: 40px !important;\n}\n\n.gitment-markdown::before {\n  display: table;\n  content: \"\";\n}\n\n.gitment-markdown::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\n.gitment-markdown>*:first-child {\n  margin-top: 0 !important;\n}\n\n.gitment-markdown>*:last-child {\n  margin-bottom: 0 !important;\n}\n\n.gitment-markdown a:not([href]) {\n  color: inherit;\n  text-decoration: none;\n}\n\n.gitment-markdown .anchor {\n  float: left;\n  padding-right: 4px;\n  margin-left: -20px;\n  line-height: 1;\n}\n\n.gitment-markdown .anchor:focus {\n  outline: none;\n}\n\n.gitment-markdown p,\n.gitment-markdown blockquote,\n.gitment-markdown ul,\n.gitment-markdown ol,\n.gitment-markdown dl,\n.gitment-markdown table,\n.gitment-markdown pre {\n  margin-top: 0;\n  margin-bottom: 16px;\n}\n\n.gitment-markdown hr {\n  height: 0.25em;\n  padding: 0;\n  margin: 24px 0;\n  background-color: #e1e4e8;\n  border: 0;\n}\n\n.gitment-markdown blockquote {\n  padding: 0 1em;\n  color: #6a737d;\n  border-left: 0.25em solid #dfe2e5;\n}\n\n.gitment-markdown blockquote>:first-child {\n  margin-top: 0;\n}\n\n.gitment-markdown blockquote>:last-child {\n  margin-bottom: 0;\n}\n\n.gitment-markdown kbd {\n  display: inline-block;\n  padding: 3px 5px;\n  font-size: 11px;\n  line-height: 10px;\n  color: #444d56;\n  vertical-align: middle;\n  background-color: #fafbfc;\n  border: solid 1px #c6cbd1;\n  border-bottom-color: #959da5;\n  border-radius: 0;\n  box-shadow: inset 0 -1px 0 #959da5;\n}\n\n.gitment-markdown h1,\n.gitment-markdown h2,\n.gitment-markdown h3,\n.gitment-markdown h4,\n.gitment-markdown h5,\n.gitment-markdown h6 {\n  margin-top: 24px;\n  margin-bottom: 16px;\n  font-weight: 600;\n  line-height: 1.25;\n}\n\n.gitment-markdown h1 .octicon-link,\n.gitment-markdown h2 .octicon-link,\n.gitment-markdown h3 .octicon-link,\n.gitment-markdown h4 .octicon-link,\n.gitment-markdown h5 .octicon-link,\n.gitment-markdown h6 .octicon-link {\n  color: #1b1f23;\n  vertical-align: middle;\n  visibility: hidden;\n}\n\n.gitment-markdown h1:hover .anchor,\n.gitment-markdown h2:hover .anchor,\n.gitment-markdown h3:hover .anchor,\n.gitment-markdown h4:hover .anchor,\n.gitment-markdown h5:hover .anchor,\n.gitment-markdown h6:hover .anchor {\n  text-decoration: none;\n}\n\n.gitment-markdown h1:hover .anchor .octicon-link,\n.gitment-markdown h2:hover .anchor .octicon-link,\n.gitment-markdown h3:hover .anchor .octicon-link,\n.gitment-markdown h4:hover .anchor .octicon-link,\n.gitment-markdown h5:hover .anchor .octicon-link,\n.gitment-markdown h6:hover .anchor .octicon-link {\n  visibility: visible;\n}\n\n.gitment-markdown h1 {\n  padding-bottom: 0.3em;\n  font-size: 2em;\n  border-bottom: 1px solid #eaecef;\n}\n\n.gitment-markdown h2 {\n  padding-bottom: 0.3em;\n  font-size: 1.5em;\n  border-bottom: 1px solid #eaecef;\n}\n\n.gitment-markdown h3 {\n  font-size: 1.25em;\n}\n\n.gitment-markdown h4 {\n  font-size: 1em;\n}\n\n.gitment-markdown h5 {\n  font-size: 0.875em;\n}\n\n.gitment-markdown h6 {\n  font-size: 0.85em;\n  color: #6a737d;\n}\n\n.gitment-markdown ul,\n.gitment-markdown ol {\n  padding-left: 2em;\n}\n\n.gitment-markdown ul ul,\n.gitment-markdown ul ol,\n.gitment-markdown ol ol,\n.gitment-markdown ol ul {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown li>p {\n  margin-top: 16px;\n}\n\n.gitment-markdown li+li {\n  margin-top: 0.25em;\n}\n\n.gitment-markdown dl {\n  padding: 0;\n}\n\n.gitment-markdown dl dt {\n  padding: 0;\n  margin-top: 16px;\n  font-size: 1em;\n  font-style: italic;\n  font-weight: 600;\n}\n\n.gitment-markdown dl dd {\n  padding: 0 16px;\n  margin-bottom: 16px;\n}\n\n.gitment-markdown table {\n  display: block;\n  width: 100%;\n  overflow: auto;\n}\n\n.gitment-markdown table th {\n  font-weight: 600;\n}\n\n.gitment-markdown table th,\n.gitment-markdown table td {\n  padding: 6px 13px;\n  border: 1px solid #dfe2e5;\n}\n\n.gitment-markdown table tr {\n  background-color: #fff;\n  border-top: 1px solid #c6cbd1;\n}\n\n.gitment-markdown table tr:nth-child(2n) {\n  background-color: #f5f5f5;\n}\n\n.gitment-markdown img {\n  max-width: 100%;\n  box-sizing: content-box;\n  background-color: #fff;\n}\n\n.gitment-markdown code {\n  padding: 0;\n  padding-top: 0.2em;\n  padding-bottom: 0.2em;\n  margin: 0;\n  font-size: 85%;\n  background-color: rgba(27,31,35,0.05);\n  border-radius: 0;\n}\n\n.gitment-markdown code::before,\n.gitment-markdown code::after {\n  letter-spacing: -0.2em;\n  content: \"\\00a0\";\n}\n\n.gitment-markdown pre {\n  word-wrap: normal;\n}\n\n.gitment-markdown pre>code {\n  padding: 0;\n  margin: 0;\n  font-size: 100%;\n  word-break: normal;\n  white-space: pre;\n  background: transparent;\n  border: 0;\n}\n\n.gitment-markdown .highlight {\n  margin-bottom: 16px;\n}\n\n.gitment-markdown .highlight pre {\n  margin-bottom: 0;\n  word-break: normal;\n}\n\n.gitment-markdown .highlight pre,\n.gitment-markdown pre {\n  padding: 16px;\n  overflow: auto;\n  font-size: 85%;\n  line-height: 1.45;\n  background-color: #f5f5f5;\n  border-radius: 0;\n}\n\n.gitment-markdown pre code {\n  display: inline;\n  max-width: auto;\n  padding: 0;\n  margin: 0;\n  overflow: visible;\n  line-height: inherit;\n  word-wrap: normal;\n  background-color: transparent;\n  border: 0;\n}\n\n.gitment-markdown pre code::before,\n.gitment-markdown pre code::after {\n  content: normal;\n}\n\n.gitment-markdown .full-commit .btn-outline:not(:disabled):hover {\n  color: #005cc5;\n  border-color: #005cc5;\n}\n\n.gitment-markdown kbd {\n  display: inline-block;\n  padding: 3px 5px;\n  font: 11px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  line-height: 10px;\n  color: #444d56;\n  vertical-align: middle;\n  background-color: #fcfcfc;\n  border: solid 1px #c6cbd1;\n  border-bottom-color: #959da5;\n  border-radius: 0;\n  box-shadow: inset 0 -1px 0 #959da5;\n}\n\n.gitment-markdown :checked+.radio-label {\n  position: relative;\n  z-index: 1;\n  border-color: #0366d6;\n}\n\n.gitment-markdown .task-list-item {\n  list-style-type: none;\n}\n\n.gitment-markdown .task-list-item+.task-list-item {\n  margin-top: 3px;\n}\n\n.gitment-markdown .task-list-item input {\n  margin: 0 0.2em 0.25em -1.6em;\n  vertical-align: middle;\n}\n\n.gitment-markdown hr {\n  border-bottom-color: #eee;\n}\n","date":"2023-12-31T08:22:39.464Z","updated":"2023-12-31T08:22:39.464Z","path":"css/gitment.css","layout":"false","title":"","comments":1,"_id":"clqxisuna0005eslr930danux","content":".gitment-container {\n  font-family: sans-serif;\n  font-size: 14px;\n  line-height: 1.5;\n  color: #333;\n  word-wrap: break-word;\n}\n\n.gitment-container * {\n  box-sizing: border-box;\n}\n\n.gitment-container *:disabled {\n  cursor: not-allowed;\n}\n\n.gitment-container a,\n.gitment-container a:visited {\n  cursor: pointer;\n  text-decoration: none;\n}\n\n.gitment-container a:hover {\n  text-decoration: underline;\n}\n\n.gitment-container .gitment-hidden {\n  display: none;\n}\n\n.gitment-container .gitment-spinner-icon {\n  fill: #333;\n\n  -webkit-animation: gitment-spin 1s steps(12) infinite;\n  animation: gitment-spin 1s steps(12) infinite;\n}\n\n@-webkit-keyframes gitment-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg)\n  }\n}\n\n@keyframes gitment-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg)\n  }\n}\n\n.gitment-root-container {\n  margin: 19px 0;\n}\n\n.gitment-header-container {\n  margin: 19px 0;\n}\n\n.gitment-header-like-btn,\n.gitment-comment-like-btn {\n  cursor: pointer;\n}\n\n.gitment-comment-like-btn {\n  float: right;\n}\n\n.gitment-comment-like-btn.liked {\n  color: #F44336;\n}\n\n.gitment-header-like-btn svg {\n  vertical-align: middle;\n  height: 30px;\n}\n\n.gitment-comment-like-btn svg {\n  vertical-align: middle;\n  height: 20px;\n}\n\n.gitment-header-like-btn.liked svg,\n.gitment-comment-like-btn.liked svg {\n  fill: #F44336;\n}\n\na.gitment-header-issue-link,\na.gitment-header-issue-link:visited {\n  float: right;\n  line-height: 30px;\n  color: #666;\n}\n\na.gitment-header-issue-link:hover {\n  color: #666;\n}\n\n.gitment-comments-loading,\n.gitment-comments-error,\n.gitment-comments-empty {\n  text-align: center;\n  margin: 50px 0;\n}\n\n.gitment-comments-list {\n  list-style: none;\n  padding-left: 0;\n  margin: 0 0 38px;\n}\n\n.gitment-comment,\n.gitment-editor-container {\n  position: relative;\n  min-height: 60px;\n  padding-left: 60px;\n  margin: 19px 0;\n}\n\n.gitment-comment-avatar,\n.gitment-editor-avatar {\n  float: left;\n  margin-left: -60px;\n}\n\n.gitment-comment-avatar,\n.gitment-comment-avatar-img,\n.gitment-comment-avatar,\n.gitment-editor-avatar-img,\n.gitment-editor-avatar svg {\n  width: 44px;\n  height: 44px;\n  border-radius: 3px;\n}\n\n.gitment-editor-avatar .gitment-github-icon {\n  fill: #fff;\n  background-color: #333;\n}\n\n.gitment-comment-main,\n.gitment-editor-main {\n  position: relative;\n  border: 1px solid #CFD8DC;\n  border-radius: 0;\n}\n\n.gitment-editor-main::before,\n.gitment-editor-main::after,\n.gitment-comment-main::before,\n.gitment-comment-main::after {\n  position: absolute;\n  top: 11px;\n  left: -16px;\n  display: block;\n  width: 0;\n  height: 0;\n  pointer-events: none;\n  content: \"\";\n  border-color: transparent;\n  border-style: solid solid outset;\n}\n\n.gitment-editor-main::before,\n.gitment-comment-main::before {\n  border-width: 8px;\n  border-right-color: #CFD8DC;\n}\n\n.gitment-editor-main::after,\n.gitment-comment-main::after {\n  margin-top: 1px;\n  margin-left: 2px;\n  border-width: 7px;\n  border-right-color: #fff;\n}\n\n.gitment-comment-header {\n  margin: 12px 15px;\n  color: #666;\n  background-color: #fff;\n  border-radius: 3px;\n}\n\n.gitment-editor-header {\n  padding: 0;\n  margin: 0;\n  border-bottom: 1px solid #CFD8DC;\n}\n\na.gitment-comment-name,\na.gitment-comment-name:visited {\n  font-weight: 600;\n  color: #666;\n}\n\n.gitment-editor-tabs {\n  margin-bottom: -1px;\n  margin-left: -1px;\n}\n\n.gitment-editor-tab {\n  display: inline-block;\n  padding: 11px 12px;\n  font-size: 14px;\n  line-height: 20px;\n  color: #666;\n  text-decoration: none;\n  background-color: transparent;\n  border-width: 0 1px;\n  border-style: solid;\n  border-color: transparent;\n  border-radius: 0;\n\n  white-space: nowrap;\n  cursor: pointer;\n  user-select: none;\n\n  outline: none;\n}\n\n.gitment-editor-tab.gitment-selected {\n  color: #333;\n  background-color: #fff;\n  border-color: #CFD8DC;\n}\n\n.gitment-editor-login {\n  float: right;\n  margin-top: -30px;\n  margin-right: 15px;\n}\n\na.gitment-footer-project-link,\na.gitment-footer-project-link:visited,\na.gitment-editor-login-link,\na.gitment-editor-login-link:visited {\n  color: #2196F3;\n}\n\na.gitment-editor-logout-link,\na.gitment-editor-logout-link:visited {\n  color: #666;\n}\n\na.gitment-editor-logout-link:hover {\n  color: #2196F3;\n  text-decoration: none;\n}\n\n.gitment-comment-body {\n  position: relative;\n  margin: 12px 15px;\n  overflow: hidden;\n  border-radius: 3px;\n}\n\n.gitment-comment-body-folded {\n  cursor: pointer;\n}\n\n.gitment-comment-body-folded::before {\n  display: block !important;\n  content: \"\";\n  position: absolute;\n  width: 100%;\n  left: 0;\n  top: 0;\n  bottom: 50px;\n  pointer-events: none;\n  background: -webkit-linear-gradient(top, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9));\n  background: linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9));\n}\n\n.gitment-comment-body-folded::after {\n  display: block !important;\n  content: \"Click to Expand\" !important;\n  text-align: center;\n  color: #666;\n  position: absolute;\n  width: 100%;\n  height: 50px;\n  line-height: 50px;\n  left: 0;\n  bottom: 0;\n  pointer-events: none;\n  background: rgba(255, 255, 255, .9);\n}\n\n.gitment-editor-body {\n  margin: 0;\n}\n\n.gitment-comment-body > *:first-child,\n.gitment-editor-preview > *:first-child {\n  margin-top: 0 !important;\n}\n\n.gitment-comment-body > *:last-child,\n.gitment-editor-preview > *:last-child {\n  margin-bottom: 0 !important;\n}\n\n.gitment-editor-body textarea {\n  display: block;\n  width: 100%;\n  min-height: 150px;\n  max-height: 500px;\n  padding: 16px;\n  resize: vertical;\n\n  max-width: 100%;\n  margin: 0;\n  font-size: 14px;\n  line-height: 1.6;\n\n  background-color: #fff;\n\n  color: #333;\n  vertical-align: middle;\n  border: none;\n  border-radius: 0;\n  outline: none;\n  box-shadow: none;\n\n  overflow: visible;\n}\n\n.gitment-editor-body textarea:focus {\n  background-color: #fff;\n}\n\n.gitment-editor-preview {\n  min-height: 150px;\n\n  padding: 16px;\n  background-color: transparent;\n\n  width: 100%;\n  font-size: 14px;\n\n  line-height: 1.5;\n  word-wrap: break-word;\n}\n\n.gitment-editor-footer {\n  padding: 0;\n  margin-top: 10px;\n}\n\n.gitment-editor-footer::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\na.gitment-editor-footer-tip {\n  display: inline-block;\n  padding-top: 10px;\n  font-size: 12px;\n  color: #666;\n}\n\na.gitment-editor-footer-tip:hover {\n  color: #2196F3;\n  text-decoration: none;\n}\n\n.gitment-comments-pagination {\n  list-style: none;\n  text-align: right;\n  border-radius: 0;\n  margin: -19px 0 19px 0;\n}\n\n.gitment-comments-page-item {\n  display: inline-block;\n  cursor: pointer;\n  border: 1px solid #CFD8DC;\n  margin-left: -1px;\n  padding: .25rem .5rem;\n}\n\n.gitment-comments-page-item:hover {\n  background-color: #f5f5f5;\n}\n\n.gitment-comments-page-item.gitment-selected {\n  background-color: #f5f5f5;\n}\n\n.gitment-editor-submit,\n.gitment-comments-init-btn {\n  color: #fff;\n  background-color: #00BCD4;\n\n  position: relative;\n  display: inline-block;\n  padding: 7px 13px;\n  font-size: 14px;\n  font-weight: 600;\n  line-height: 20px;\n  white-space: nowrap;\n  vertical-align: middle;\n  cursor: pointer;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  background-size: 110% 110%;\n  border: none;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n}\n\n.gitment-editor-submit:hover,\n.gitment-comments-init-btn:hover {\n  background-color: #00ACC1;\n}\n\n.gitment-comments-init-btn:disabled,\n.gitment-editor-submit:disabled {\n  color: rgba(255,255,255,0.75);\n  background-color: #4DD0E1;\n  box-shadow: none;\n}\n\n.gitment-editor-submit {\n  float: right;\n}\n\n.gitment-footer-container {\n  margin-top: 30px;\n  margin-bottom: 20px;\n  text-align: right;\n  font-size: 12px;\n}\n\n/*\n * Markdown CSS\n * Copied from https://github.com/sindresorhus/github-markdown-css\n */\n.gitment-markdown {\n  -ms-text-size-adjust: 100%;\n  -webkit-text-size-adjust: 100%;\n  line-height: 1.5;\n  color: #333;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n  font-size: 16px;\n  line-height: 1.5;\n  word-wrap: break-word;\n}\n\n.gitment-markdown .pl-c {\n  color: #969896;\n}\n\n.gitment-markdown .pl-c1,\n.gitment-markdown .pl-s .pl-v {\n  color: #0086b3;\n}\n\n.gitment-markdown .pl-e,\n.gitment-markdown .pl-en {\n  color: #795da3;\n}\n\n.gitment-markdown .pl-smi,\n.gitment-markdown .pl-s .pl-s1 {\n  color: #333;\n}\n\n.gitment-markdown .pl-ent {\n  color: #63a35c;\n}\n\n.gitment-markdown .pl-k {\n  color: #a71d5d;\n}\n\n.gitment-markdown .pl-s,\n.gitment-markdown .pl-pds,\n.gitment-markdown .pl-s .pl-pse .pl-s1,\n.gitment-markdown .pl-sr,\n.gitment-markdown .pl-sr .pl-cce,\n.gitment-markdown .pl-sr .pl-sre,\n.gitment-markdown .pl-sr .pl-sra {\n  color: #183691;\n}\n\n.gitment-markdown .pl-v,\n.gitment-markdown .pl-smw {\n  color: #ed6a43;\n}\n\n.gitment-markdown .pl-bu {\n  color: #b52a1d;\n}\n\n.gitment-markdown .pl-ii {\n  color: #f8f8f8;\n  background-color: #b52a1d;\n}\n\n.gitment-markdown .pl-c2 {\n  color: #f8f8f8;\n  background-color: #b52a1d;\n}\n\n.gitment-markdown .pl-c2::before {\n  content: \"^M\";\n}\n\n.gitment-markdown .pl-sr .pl-cce {\n  font-weight: bold;\n  color: #63a35c;\n}\n\n.gitment-markdown .pl-ml {\n  color: #693a17;\n}\n\n.gitment-markdown .pl-mh,\n.gitment-markdown .pl-mh .pl-en,\n.gitment-markdown .pl-ms {\n  font-weight: bold;\n  color: #1d3e81;\n}\n\n.gitment-markdown .pl-mq {\n  color: #008080;\n}\n\n.gitment-markdown .pl-mi {\n  font-style: italic;\n  color: #333;\n}\n\n.gitment-markdown .pl-mb {\n  font-weight: bold;\n  color: #333;\n}\n\n.gitment-markdown .pl-md {\n  color: #bd2c00;\n  background-color: #ffecec;\n}\n\n.gitment-markdown .pl-mi1 {\n  color: #55a532;\n  background-color: #eaffea;\n}\n\n.gitment-markdown .pl-mc {\n  color: #ef9700;\n  background-color: #ffe3b4;\n}\n\n.gitment-markdown .pl-mi2 {\n  color: #d8d8d8;\n  background-color: #808080;\n}\n\n.gitment-markdown .pl-mdr {\n  font-weight: bold;\n  color: #795da3;\n}\n\n.gitment-markdown .pl-mo {\n  color: #1d3e81;\n}\n\n.gitment-markdown .pl-ba {\n  color: #595e62;\n}\n\n.gitment-markdown .pl-sg {\n  color: #c0c0c0;\n}\n\n.gitment-markdown .pl-corl {\n  text-decoration: underline;\n  color: #183691;\n}\n\n.gitment-markdown .octicon {\n  display: inline-block;\n  vertical-align: text-top;\n  fill: currentColor;\n}\n\n.gitment-markdown a {\n  background-color: transparent;\n  -webkit-text-decoration-skip: objects;\n}\n\n.gitment-markdown a:active,\n.gitment-markdown a:hover {\n  outline-width: 0;\n}\n\n.gitment-markdown strong {\n  font-weight: inherit;\n}\n\n.gitment-markdown strong {\n  font-weight: bolder;\n}\n\n.gitment-markdown h1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n.gitment-markdown img {\n  border-style: none;\n}\n\n.gitment-markdown svg:not(:root) {\n  overflow: hidden;\n}\n\n.gitment-markdown code,\n.gitment-markdown kbd,\n.gitment-markdown pre {\n  font-family: monospace, monospace;\n  font-size: 1em;\n}\n\n.gitment-markdown hr {\n  box-sizing: content-box;\n  height: 0;\n  overflow: visible;\n}\n\n.gitment-markdown input {\n  font: inherit;\n  margin: 0;\n}\n\n.gitment-markdown input {\n  overflow: visible;\n}\n\n.gitment-markdown [type=\"checkbox\"] {\n  box-sizing: border-box;\n  padding: 0;\n}\n\n.gitment-markdown * {\n  box-sizing: border-box;\n}\n\n.gitment-markdown input {\n  font-family: inherit;\n  font-size: inherit;\n  line-height: inherit;\n}\n\n.gitment-markdown a {\n  color: #0366d6;\n  text-decoration: none;\n}\n\n.gitment-markdown a:hover {\n  text-decoration: underline;\n}\n\n.gitment-markdown strong {\n  font-weight: 600;\n}\n\n.gitment-markdown hr {\n  height: 0;\n  margin: 15px 0;\n  overflow: hidden;\n  background: transparent;\n  border: 0;\n  border-bottom: 1px solid #dfe2e5;\n}\n\n.gitment-markdown hr::before {\n  display: table;\n  content: \"\";\n}\n\n.gitment-markdown hr::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\n.gitment-markdown table {\n  border-spacing: 0;\n  border-collapse: collapse;\n}\n\n.gitment-markdown td,\n.gitment-markdown th {\n  padding: 0;\n}\n\n.gitment-markdown h1,\n.gitment-markdown h2,\n.gitment-markdown h3,\n.gitment-markdown h4,\n.gitment-markdown h5,\n.gitment-markdown h6 {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown h1 {\n  font-size: 32px;\n  font-weight: 600;\n}\n\n.gitment-markdown h2 {\n  font-size: 24px;\n  font-weight: 600;\n}\n\n.gitment-markdown h3 {\n  font-size: 20px;\n  font-weight: 600;\n}\n\n.gitment-markdown h4 {\n  font-size: 16px;\n  font-weight: 600;\n}\n\n.gitment-markdown h5 {\n  font-size: 14px;\n  font-weight: 600;\n}\n\n.gitment-markdown h6 {\n  font-size: 12px;\n  font-weight: 600;\n}\n\n.gitment-markdown p {\n  margin-top: 0;\n  margin-bottom: 10px;\n}\n\n.gitment-markdown blockquote {\n  margin: 0;\n}\n\n.gitment-markdown ul,\n.gitment-markdown ol {\n  padding-left: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown ol ol,\n.gitment-markdown ul ol {\n  list-style-type: lower-roman;\n}\n\n.gitment-markdown ul ul ol,\n.gitment-markdown ul ol ol,\n.gitment-markdown ol ul ol,\n.gitment-markdown ol ol ol {\n  list-style-type: lower-alpha;\n}\n\n.gitment-markdown dd {\n  margin-left: 0;\n}\n\n.gitment-markdown code {\n  font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  font-size: 12px;\n}\n\n.gitment-markdown pre {\n  margin-top: 0;\n  margin-bottom: 0;\n  font: 12px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n}\n\n.gitment-markdown .octicon {\n  vertical-align: text-bottom;\n}\n\n.gitment-markdown .pl-0 {\n  padding-left: 0 !important;\n}\n\n.gitment-markdown .pl-1 {\n  padding-left: 4px !important;\n}\n\n.gitment-markdown .pl-2 {\n  padding-left: 8px !important;\n}\n\n.gitment-markdown .pl-3 {\n  padding-left: 16px !important;\n}\n\n.gitment-markdown .pl-4 {\n  padding-left: 24px !important;\n}\n\n.gitment-markdown .pl-5 {\n  padding-left: 32px !important;\n}\n\n.gitment-markdown .pl-6 {\n  padding-left: 40px !important;\n}\n\n.gitment-markdown::before {\n  display: table;\n  content: \"\";\n}\n\n.gitment-markdown::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\n.gitment-markdown>*:first-child {\n  margin-top: 0 !important;\n}\n\n.gitment-markdown>*:last-child {\n  margin-bottom: 0 !important;\n}\n\n.gitment-markdown a:not([href]) {\n  color: inherit;\n  text-decoration: none;\n}\n\n.gitment-markdown .anchor {\n  float: left;\n  padding-right: 4px;\n  margin-left: -20px;\n  line-height: 1;\n}\n\n.gitment-markdown .anchor:focus {\n  outline: none;\n}\n\n.gitment-markdown p,\n.gitment-markdown blockquote,\n.gitment-markdown ul,\n.gitment-markdown ol,\n.gitment-markdown dl,\n.gitment-markdown table,\n.gitment-markdown pre {\n  margin-top: 0;\n  margin-bottom: 16px;\n}\n\n.gitment-markdown hr {\n  height: 0.25em;\n  padding: 0;\n  margin: 24px 0;\n  background-color: #e1e4e8;\n  border: 0;\n}\n\n.gitment-markdown blockquote {\n  padding: 0 1em;\n  color: #6a737d;\n  border-left: 0.25em solid #dfe2e5;\n}\n\n.gitment-markdown blockquote>:first-child {\n  margin-top: 0;\n}\n\n.gitment-markdown blockquote>:last-child {\n  margin-bottom: 0;\n}\n\n.gitment-markdown kbd {\n  display: inline-block;\n  padding: 3px 5px;\n  font-size: 11px;\n  line-height: 10px;\n  color: #444d56;\n  vertical-align: middle;\n  background-color: #fafbfc;\n  border: solid 1px #c6cbd1;\n  border-bottom-color: #959da5;\n  border-radius: 0;\n  box-shadow: inset 0 -1px 0 #959da5;\n}\n\n.gitment-markdown h1,\n.gitment-markdown h2,\n.gitment-markdown h3,\n.gitment-markdown h4,\n.gitment-markdown h5,\n.gitment-markdown h6 {\n  margin-top: 24px;\n  margin-bottom: 16px;\n  font-weight: 600;\n  line-height: 1.25;\n}\n\n.gitment-markdown h1 .octicon-link,\n.gitment-markdown h2 .octicon-link,\n.gitment-markdown h3 .octicon-link,\n.gitment-markdown h4 .octicon-link,\n.gitment-markdown h5 .octicon-link,\n.gitment-markdown h6 .octicon-link {\n  color: #1b1f23;\n  vertical-align: middle;\n  visibility: hidden;\n}\n\n.gitment-markdown h1:hover .anchor,\n.gitment-markdown h2:hover .anchor,\n.gitment-markdown h3:hover .anchor,\n.gitment-markdown h4:hover .anchor,\n.gitment-markdown h5:hover .anchor,\n.gitment-markdown h6:hover .anchor {\n  text-decoration: none;\n}\n\n.gitment-markdown h1:hover .anchor .octicon-link,\n.gitment-markdown h2:hover .anchor .octicon-link,\n.gitment-markdown h3:hover .anchor .octicon-link,\n.gitment-markdown h4:hover .anchor .octicon-link,\n.gitment-markdown h5:hover .anchor .octicon-link,\n.gitment-markdown h6:hover .anchor .octicon-link {\n  visibility: visible;\n}\n\n.gitment-markdown h1 {\n  padding-bottom: 0.3em;\n  font-size: 2em;\n  border-bottom: 1px solid #eaecef;\n}\n\n.gitment-markdown h2 {\n  padding-bottom: 0.3em;\n  font-size: 1.5em;\n  border-bottom: 1px solid #eaecef;\n}\n\n.gitment-markdown h3 {\n  font-size: 1.25em;\n}\n\n.gitment-markdown h4 {\n  font-size: 1em;\n}\n\n.gitment-markdown h5 {\n  font-size: 0.875em;\n}\n\n.gitment-markdown h6 {\n  font-size: 0.85em;\n  color: #6a737d;\n}\n\n.gitment-markdown ul,\n.gitment-markdown ol {\n  padding-left: 2em;\n}\n\n.gitment-markdown ul ul,\n.gitment-markdown ul ol,\n.gitment-markdown ol ol,\n.gitment-markdown ol ul {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown li>p {\n  margin-top: 16px;\n}\n\n.gitment-markdown li+li {\n  margin-top: 0.25em;\n}\n\n.gitment-markdown dl {\n  padding: 0;\n}\n\n.gitment-markdown dl dt {\n  padding: 0;\n  margin-top: 16px;\n  font-size: 1em;\n  font-style: italic;\n  font-weight: 600;\n}\n\n.gitment-markdown dl dd {\n  padding: 0 16px;\n  margin-bottom: 16px;\n}\n\n.gitment-markdown table {\n  display: block;\n  width: 100%;\n  overflow: auto;\n}\n\n.gitment-markdown table th {\n  font-weight: 600;\n}\n\n.gitment-markdown table th,\n.gitment-markdown table td {\n  padding: 6px 13px;\n  border: 1px solid #dfe2e5;\n}\n\n.gitment-markdown table tr {\n  background-color: #fff;\n  border-top: 1px solid #c6cbd1;\n}\n\n.gitment-markdown table tr:nth-child(2n) {\n  background-color: #f5f5f5;\n}\n\n.gitment-markdown img {\n  max-width: 100%;\n  box-sizing: content-box;\n  background-color: #fff;\n}\n\n.gitment-markdown code {\n  padding: 0;\n  padding-top: 0.2em;\n  padding-bottom: 0.2em;\n  margin: 0;\n  font-size: 85%;\n  background-color: rgba(27,31,35,0.05);\n  border-radius: 0;\n}\n\n.gitment-markdown code::before,\n.gitment-markdown code::after {\n  letter-spacing: -0.2em;\n  content: \"\\00a0\";\n}\n\n.gitment-markdown pre {\n  word-wrap: normal;\n}\n\n.gitment-markdown pre>code {\n  padding: 0;\n  margin: 0;\n  font-size: 100%;\n  word-break: normal;\n  white-space: pre;\n  background: transparent;\n  border: 0;\n}\n\n.gitment-markdown .highlight {\n  margin-bottom: 16px;\n}\n\n.gitment-markdown .highlight pre {\n  margin-bottom: 0;\n  word-break: normal;\n}\n\n.gitment-markdown .highlight pre,\n.gitment-markdown pre {\n  padding: 16px;\n  overflow: auto;\n  font-size: 85%;\n  line-height: 1.45;\n  background-color: #f5f5f5;\n  border-radius: 0;\n}\n\n.gitment-markdown pre code {\n  display: inline;\n  max-width: auto;\n  padding: 0;\n  margin: 0;\n  overflow: visible;\n  line-height: inherit;\n  word-wrap: normal;\n  background-color: transparent;\n  border: 0;\n}\n\n.gitment-markdown pre code::before,\n.gitment-markdown pre code::after {\n  content: normal;\n}\n\n.gitment-markdown .full-commit .btn-outline:not(:disabled):hover {\n  color: #005cc5;\n  border-color: #005cc5;\n}\n\n.gitment-markdown kbd {\n  display: inline-block;\n  padding: 3px 5px;\n  font: 11px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  line-height: 10px;\n  color: #444d56;\n  vertical-align: middle;\n  background-color: #fcfcfc;\n  border: solid 1px #c6cbd1;\n  border-bottom-color: #959da5;\n  border-radius: 0;\n  box-shadow: inset 0 -1px 0 #959da5;\n}\n\n.gitment-markdown :checked+.radio-label {\n  position: relative;\n  z-index: 1;\n  border-color: #0366d6;\n}\n\n.gitment-markdown .task-list-item {\n  list-style-type: none;\n}\n\n.gitment-markdown .task-list-item+.task-list-item {\n  margin-top: 3px;\n}\n\n.gitment-markdown .task-list-item input {\n  margin: 0 0.2em 0.25em -1.6em;\n  vertical-align: middle;\n}\n\n.gitment-markdown hr {\n  border-bottom-color: #eee;\n}\n","site":{"data":{}},"excerpt":"","more":".gitment-container {\n  font-family: sans-serif;\n  font-size: 14px;\n  line-height: 1.5;\n  color: #333;\n  word-wrap: break-word;\n}\n\n.gitment-container * {\n  box-sizing: border-box;\n}\n\n.gitment-container *:disabled {\n  cursor: not-allowed;\n}\n\n.gitment-container a,\n.gitment-container a:visited {\n  cursor: pointer;\n  text-decoration: none;\n}\n\n.gitment-container a:hover {\n  text-decoration: underline;\n}\n\n.gitment-container .gitment-hidden {\n  display: none;\n}\n\n.gitment-container .gitment-spinner-icon {\n  fill: #333;\n\n  -webkit-animation: gitment-spin 1s steps(12) infinite;\n  animation: gitment-spin 1s steps(12) infinite;\n}\n\n@-webkit-keyframes gitment-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg)\n  }\n}\n\n@keyframes gitment-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg)\n  }\n}\n\n.gitment-root-container {\n  margin: 19px 0;\n}\n\n.gitment-header-container {\n  margin: 19px 0;\n}\n\n.gitment-header-like-btn,\n.gitment-comment-like-btn {\n  cursor: pointer;\n}\n\n.gitment-comment-like-btn {\n  float: right;\n}\n\n.gitment-comment-like-btn.liked {\n  color: #F44336;\n}\n\n.gitment-header-like-btn svg {\n  vertical-align: middle;\n  height: 30px;\n}\n\n.gitment-comment-like-btn svg {\n  vertical-align: middle;\n  height: 20px;\n}\n\n.gitment-header-like-btn.liked svg,\n.gitment-comment-like-btn.liked svg {\n  fill: #F44336;\n}\n\na.gitment-header-issue-link,\na.gitment-header-issue-link:visited {\n  float: right;\n  line-height: 30px;\n  color: #666;\n}\n\na.gitment-header-issue-link:hover {\n  color: #666;\n}\n\n.gitment-comments-loading,\n.gitment-comments-error,\n.gitment-comments-empty {\n  text-align: center;\n  margin: 50px 0;\n}\n\n.gitment-comments-list {\n  list-style: none;\n  padding-left: 0;\n  margin: 0 0 38px;\n}\n\n.gitment-comment,\n.gitment-editor-container {\n  position: relative;\n  min-height: 60px;\n  padding-left: 60px;\n  margin: 19px 0;\n}\n\n.gitment-comment-avatar,\n.gitment-editor-avatar {\n  float: left;\n  margin-left: -60px;\n}\n\n.gitment-comment-avatar,\n.gitment-comment-avatar-img,\n.gitment-comment-avatar,\n.gitment-editor-avatar-img,\n.gitment-editor-avatar svg {\n  width: 44px;\n  height: 44px;\n  border-radius: 3px;\n}\n\n.gitment-editor-avatar .gitment-github-icon {\n  fill: #fff;\n  background-color: #333;\n}\n\n.gitment-comment-main,\n.gitment-editor-main {\n  position: relative;\n  border: 1px solid #CFD8DC;\n  border-radius: 0;\n}\n\n.gitment-editor-main::before,\n.gitment-editor-main::after,\n.gitment-comment-main::before,\n.gitment-comment-main::after {\n  position: absolute;\n  top: 11px;\n  left: -16px;\n  display: block;\n  width: 0;\n  height: 0;\n  pointer-events: none;\n  content: \"\";\n  border-color: transparent;\n  border-style: solid solid outset;\n}\n\n.gitment-editor-main::before,\n.gitment-comment-main::before {\n  border-width: 8px;\n  border-right-color: #CFD8DC;\n}\n\n.gitment-editor-main::after,\n.gitment-comment-main::after {\n  margin-top: 1px;\n  margin-left: 2px;\n  border-width: 7px;\n  border-right-color: #fff;\n}\n\n.gitment-comment-header {\n  margin: 12px 15px;\n  color: #666;\n  background-color: #fff;\n  border-radius: 3px;\n}\n\n.gitment-editor-header {\n  padding: 0;\n  margin: 0;\n  border-bottom: 1px solid #CFD8DC;\n}\n\na.gitment-comment-name,\na.gitment-comment-name:visited {\n  font-weight: 600;\n  color: #666;\n}\n\n.gitment-editor-tabs {\n  margin-bottom: -1px;\n  margin-left: -1px;\n}\n\n.gitment-editor-tab {\n  display: inline-block;\n  padding: 11px 12px;\n  font-size: 14px;\n  line-height: 20px;\n  color: #666;\n  text-decoration: none;\n  background-color: transparent;\n  border-width: 0 1px;\n  border-style: solid;\n  border-color: transparent;\n  border-radius: 0;\n\n  white-space: nowrap;\n  cursor: pointer;\n  user-select: none;\n\n  outline: none;\n}\n\n.gitment-editor-tab.gitment-selected {\n  color: #333;\n  background-color: #fff;\n  border-color: #CFD8DC;\n}\n\n.gitment-editor-login {\n  float: right;\n  margin-top: -30px;\n  margin-right: 15px;\n}\n\na.gitment-footer-project-link,\na.gitment-footer-project-link:visited,\na.gitment-editor-login-link,\na.gitment-editor-login-link:visited {\n  color: #2196F3;\n}\n\na.gitment-editor-logout-link,\na.gitment-editor-logout-link:visited {\n  color: #666;\n}\n\na.gitment-editor-logout-link:hover {\n  color: #2196F3;\n  text-decoration: none;\n}\n\n.gitment-comment-body {\n  position: relative;\n  margin: 12px 15px;\n  overflow: hidden;\n  border-radius: 3px;\n}\n\n.gitment-comment-body-folded {\n  cursor: pointer;\n}\n\n.gitment-comment-body-folded::before {\n  display: block !important;\n  content: \"\";\n  position: absolute;\n  width: 100%;\n  left: 0;\n  top: 0;\n  bottom: 50px;\n  pointer-events: none;\n  background: -webkit-linear-gradient(top, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9));\n  background: linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9));\n}\n\n.gitment-comment-body-folded::after {\n  display: block !important;\n  content: \"Click to Expand\" !important;\n  text-align: center;\n  color: #666;\n  position: absolute;\n  width: 100%;\n  height: 50px;\n  line-height: 50px;\n  left: 0;\n  bottom: 0;\n  pointer-events: none;\n  background: rgba(255, 255, 255, .9);\n}\n\n.gitment-editor-body {\n  margin: 0;\n}\n\n.gitment-comment-body > *:first-child,\n.gitment-editor-preview > *:first-child {\n  margin-top: 0 !important;\n}\n\n.gitment-comment-body > *:last-child,\n.gitment-editor-preview > *:last-child {\n  margin-bottom: 0 !important;\n}\n\n.gitment-editor-body textarea {\n  display: block;\n  width: 100%;\n  min-height: 150px;\n  max-height: 500px;\n  padding: 16px;\n  resize: vertical;\n\n  max-width: 100%;\n  margin: 0;\n  font-size: 14px;\n  line-height: 1.6;\n\n  background-color: #fff;\n\n  color: #333;\n  vertical-align: middle;\n  border: none;\n  border-radius: 0;\n  outline: none;\n  box-shadow: none;\n\n  overflow: visible;\n}\n\n.gitment-editor-body textarea:focus {\n  background-color: #fff;\n}\n\n.gitment-editor-preview {\n  min-height: 150px;\n\n  padding: 16px;\n  background-color: transparent;\n\n  width: 100%;\n  font-size: 14px;\n\n  line-height: 1.5;\n  word-wrap: break-word;\n}\n\n.gitment-editor-footer {\n  padding: 0;\n  margin-top: 10px;\n}\n\n.gitment-editor-footer::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\na.gitment-editor-footer-tip {\n  display: inline-block;\n  padding-top: 10px;\n  font-size: 12px;\n  color: #666;\n}\n\na.gitment-editor-footer-tip:hover {\n  color: #2196F3;\n  text-decoration: none;\n}\n\n.gitment-comments-pagination {\n  list-style: none;\n  text-align: right;\n  border-radius: 0;\n  margin: -19px 0 19px 0;\n}\n\n.gitment-comments-page-item {\n  display: inline-block;\n  cursor: pointer;\n  border: 1px solid #CFD8DC;\n  margin-left: -1px;\n  padding: .25rem .5rem;\n}\n\n.gitment-comments-page-item:hover {\n  background-color: #f5f5f5;\n}\n\n.gitment-comments-page-item.gitment-selected {\n  background-color: #f5f5f5;\n}\n\n.gitment-editor-submit,\n.gitment-comments-init-btn {\n  color: #fff;\n  background-color: #00BCD4;\n\n  position: relative;\n  display: inline-block;\n  padding: 7px 13px;\n  font-size: 14px;\n  font-weight: 600;\n  line-height: 20px;\n  white-space: nowrap;\n  vertical-align: middle;\n  cursor: pointer;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  background-size: 110% 110%;\n  border: none;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n}\n\n.gitment-editor-submit:hover,\n.gitment-comments-init-btn:hover {\n  background-color: #00ACC1;\n}\n\n.gitment-comments-init-btn:disabled,\n.gitment-editor-submit:disabled {\n  color: rgba(255,255,255,0.75);\n  background-color: #4DD0E1;\n  box-shadow: none;\n}\n\n.gitment-editor-submit {\n  float: right;\n}\n\n.gitment-footer-container {\n  margin-top: 30px;\n  margin-bottom: 20px;\n  text-align: right;\n  font-size: 12px;\n}\n\n/*\n * Markdown CSS\n * Copied from https://github.com/sindresorhus/github-markdown-css\n */\n.gitment-markdown {\n  -ms-text-size-adjust: 100%;\n  -webkit-text-size-adjust: 100%;\n  line-height: 1.5;\n  color: #333;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n  font-size: 16px;\n  line-height: 1.5;\n  word-wrap: break-word;\n}\n\n.gitment-markdown .pl-c {\n  color: #969896;\n}\n\n.gitment-markdown .pl-c1,\n.gitment-markdown .pl-s .pl-v {\n  color: #0086b3;\n}\n\n.gitment-markdown .pl-e,\n.gitment-markdown .pl-en {\n  color: #795da3;\n}\n\n.gitment-markdown .pl-smi,\n.gitment-markdown .pl-s .pl-s1 {\n  color: #333;\n}\n\n.gitment-markdown .pl-ent {\n  color: #63a35c;\n}\n\n.gitment-markdown .pl-k {\n  color: #a71d5d;\n}\n\n.gitment-markdown .pl-s,\n.gitment-markdown .pl-pds,\n.gitment-markdown .pl-s .pl-pse .pl-s1,\n.gitment-markdown .pl-sr,\n.gitment-markdown .pl-sr .pl-cce,\n.gitment-markdown .pl-sr .pl-sre,\n.gitment-markdown .pl-sr .pl-sra {\n  color: #183691;\n}\n\n.gitment-markdown .pl-v,\n.gitment-markdown .pl-smw {\n  color: #ed6a43;\n}\n\n.gitment-markdown .pl-bu {\n  color: #b52a1d;\n}\n\n.gitment-markdown .pl-ii {\n  color: #f8f8f8;\n  background-color: #b52a1d;\n}\n\n.gitment-markdown .pl-c2 {\n  color: #f8f8f8;\n  background-color: #b52a1d;\n}\n\n.gitment-markdown .pl-c2::before {\n  content: \"^M\";\n}\n\n.gitment-markdown .pl-sr .pl-cce {\n  font-weight: bold;\n  color: #63a35c;\n}\n\n.gitment-markdown .pl-ml {\n  color: #693a17;\n}\n\n.gitment-markdown .pl-mh,\n.gitment-markdown .pl-mh .pl-en,\n.gitment-markdown .pl-ms {\n  font-weight: bold;\n  color: #1d3e81;\n}\n\n.gitment-markdown .pl-mq {\n  color: #008080;\n}\n\n.gitment-markdown .pl-mi {\n  font-style: italic;\n  color: #333;\n}\n\n.gitment-markdown .pl-mb {\n  font-weight: bold;\n  color: #333;\n}\n\n.gitment-markdown .pl-md {\n  color: #bd2c00;\n  background-color: #ffecec;\n}\n\n.gitment-markdown .pl-mi1 {\n  color: #55a532;\n  background-color: #eaffea;\n}\n\n.gitment-markdown .pl-mc {\n  color: #ef9700;\n  background-color: #ffe3b4;\n}\n\n.gitment-markdown .pl-mi2 {\n  color: #d8d8d8;\n  background-color: #808080;\n}\n\n.gitment-markdown .pl-mdr {\n  font-weight: bold;\n  color: #795da3;\n}\n\n.gitment-markdown .pl-mo {\n  color: #1d3e81;\n}\n\n.gitment-markdown .pl-ba {\n  color: #595e62;\n}\n\n.gitment-markdown .pl-sg {\n  color: #c0c0c0;\n}\n\n.gitment-markdown .pl-corl {\n  text-decoration: underline;\n  color: #183691;\n}\n\n.gitment-markdown .octicon {\n  display: inline-block;\n  vertical-align: text-top;\n  fill: currentColor;\n}\n\n.gitment-markdown a {\n  background-color: transparent;\n  -webkit-text-decoration-skip: objects;\n}\n\n.gitment-markdown a:active,\n.gitment-markdown a:hover {\n  outline-width: 0;\n}\n\n.gitment-markdown strong {\n  font-weight: inherit;\n}\n\n.gitment-markdown strong {\n  font-weight: bolder;\n}\n\n.gitment-markdown h1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n.gitment-markdown img {\n  border-style: none;\n}\n\n.gitment-markdown svg:not(:root) {\n  overflow: hidden;\n}\n\n.gitment-markdown code,\n.gitment-markdown kbd,\n.gitment-markdown pre {\n  font-family: monospace, monospace;\n  font-size: 1em;\n}\n\n.gitment-markdown hr {\n  box-sizing: content-box;\n  height: 0;\n  overflow: visible;\n}\n\n.gitment-markdown input {\n  font: inherit;\n  margin: 0;\n}\n\n.gitment-markdown input {\n  overflow: visible;\n}\n\n.gitment-markdown [type=\"checkbox\"] {\n  box-sizing: border-box;\n  padding: 0;\n}\n\n.gitment-markdown * {\n  box-sizing: border-box;\n}\n\n.gitment-markdown input {\n  font-family: inherit;\n  font-size: inherit;\n  line-height: inherit;\n}\n\n.gitment-markdown a {\n  color: #0366d6;\n  text-decoration: none;\n}\n\n.gitment-markdown a:hover {\n  text-decoration: underline;\n}\n\n.gitment-markdown strong {\n  font-weight: 600;\n}\n\n.gitment-markdown hr {\n  height: 0;\n  margin: 15px 0;\n  overflow: hidden;\n  background: transparent;\n  border: 0;\n  border-bottom: 1px solid #dfe2e5;\n}\n\n.gitment-markdown hr::before {\n  display: table;\n  content: \"\";\n}\n\n.gitment-markdown hr::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\n.gitment-markdown table {\n  border-spacing: 0;\n  border-collapse: collapse;\n}\n\n.gitment-markdown td,\n.gitment-markdown th {\n  padding: 0;\n}\n\n.gitment-markdown h1,\n.gitment-markdown h2,\n.gitment-markdown h3,\n.gitment-markdown h4,\n.gitment-markdown h5,\n.gitment-markdown h6 {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown h1 {\n  font-size: 32px;\n  font-weight: 600;\n}\n\n.gitment-markdown h2 {\n  font-size: 24px;\n  font-weight: 600;\n}\n\n.gitment-markdown h3 {\n  font-size: 20px;\n  font-weight: 600;\n}\n\n.gitment-markdown h4 {\n  font-size: 16px;\n  font-weight: 600;\n}\n\n.gitment-markdown h5 {\n  font-size: 14px;\n  font-weight: 600;\n}\n\n.gitment-markdown h6 {\n  font-size: 12px;\n  font-weight: 600;\n}\n\n.gitment-markdown p {\n  margin-top: 0;\n  margin-bottom: 10px;\n}\n\n.gitment-markdown blockquote {\n  margin: 0;\n}\n\n.gitment-markdown ul,\n.gitment-markdown ol {\n  padding-left: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown ol ol,\n.gitment-markdown ul ol {\n  list-style-type: lower-roman;\n}\n\n.gitment-markdown ul ul ol,\n.gitment-markdown ul ol ol,\n.gitment-markdown ol ul ol,\n.gitment-markdown ol ol ol {\n  list-style-type: lower-alpha;\n}\n\n.gitment-markdown dd {\n  margin-left: 0;\n}\n\n.gitment-markdown code {\n  font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  font-size: 12px;\n}\n\n.gitment-markdown pre {\n  margin-top: 0;\n  margin-bottom: 0;\n  font: 12px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n}\n\n.gitment-markdown .octicon {\n  vertical-align: text-bottom;\n}\n\n.gitment-markdown .pl-0 {\n  padding-left: 0 !important;\n}\n\n.gitment-markdown .pl-1 {\n  padding-left: 4px !important;\n}\n\n.gitment-markdown .pl-2 {\n  padding-left: 8px !important;\n}\n\n.gitment-markdown .pl-3 {\n  padding-left: 16px !important;\n}\n\n.gitment-markdown .pl-4 {\n  padding-left: 24px !important;\n}\n\n.gitment-markdown .pl-5 {\n  padding-left: 32px !important;\n}\n\n.gitment-markdown .pl-6 {\n  padding-left: 40px !important;\n}\n\n.gitment-markdown::before {\n  display: table;\n  content: \"\";\n}\n\n.gitment-markdown::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\n.gitment-markdown>*:first-child {\n  margin-top: 0 !important;\n}\n\n.gitment-markdown>*:last-child {\n  margin-bottom: 0 !important;\n}\n\n.gitment-markdown a:not([href]) {\n  color: inherit;\n  text-decoration: none;\n}\n\n.gitment-markdown .anchor {\n  float: left;\n  padding-right: 4px;\n  margin-left: -20px;\n  line-height: 1;\n}\n\n.gitment-markdown .anchor:focus {\n  outline: none;\n}\n\n.gitment-markdown p,\n.gitment-markdown blockquote,\n.gitment-markdown ul,\n.gitment-markdown ol,\n.gitment-markdown dl,\n.gitment-markdown table,\n.gitment-markdown pre {\n  margin-top: 0;\n  margin-bottom: 16px;\n}\n\n.gitment-markdown hr {\n  height: 0.25em;\n  padding: 0;\n  margin: 24px 0;\n  background-color: #e1e4e8;\n  border: 0;\n}\n\n.gitment-markdown blockquote {\n  padding: 0 1em;\n  color: #6a737d;\n  border-left: 0.25em solid #dfe2e5;\n}\n\n.gitment-markdown blockquote>:first-child {\n  margin-top: 0;\n}\n\n.gitment-markdown blockquote>:last-child {\n  margin-bottom: 0;\n}\n\n.gitment-markdown kbd {\n  display: inline-block;\n  padding: 3px 5px;\n  font-size: 11px;\n  line-height: 10px;\n  color: #444d56;\n  vertical-align: middle;\n  background-color: #fafbfc;\n  border: solid 1px #c6cbd1;\n  border-bottom-color: #959da5;\n  border-radius: 0;\n  box-shadow: inset 0 -1px 0 #959da5;\n}\n\n.gitment-markdown h1,\n.gitment-markdown h2,\n.gitment-markdown h3,\n.gitment-markdown h4,\n.gitment-markdown h5,\n.gitment-markdown h6 {\n  margin-top: 24px;\n  margin-bottom: 16px;\n  font-weight: 600;\n  line-height: 1.25;\n}\n\n.gitment-markdown h1 .octicon-link,\n.gitment-markdown h2 .octicon-link,\n.gitment-markdown h3 .octicon-link,\n.gitment-markdown h4 .octicon-link,\n.gitment-markdown h5 .octicon-link,\n.gitment-markdown h6 .octicon-link {\n  color: #1b1f23;\n  vertical-align: middle;\n  visibility: hidden;\n}\n\n.gitment-markdown h1:hover .anchor,\n.gitment-markdown h2:hover .anchor,\n.gitment-markdown h3:hover .anchor,\n.gitment-markdown h4:hover .anchor,\n.gitment-markdown h5:hover .anchor,\n.gitment-markdown h6:hover .anchor {\n  text-decoration: none;\n}\n\n.gitment-markdown h1:hover .anchor .octicon-link,\n.gitment-markdown h2:hover .anchor .octicon-link,\n.gitment-markdown h3:hover .anchor .octicon-link,\n.gitment-markdown h4:hover .anchor .octicon-link,\n.gitment-markdown h5:hover .anchor .octicon-link,\n.gitment-markdown h6:hover .anchor .octicon-link {\n  visibility: visible;\n}\n\n.gitment-markdown h1 {\n  padding-bottom: 0.3em;\n  font-size: 2em;\n  border-bottom: 1px solid #eaecef;\n}\n\n.gitment-markdown h2 {\n  padding-bottom: 0.3em;\n  font-size: 1.5em;\n  border-bottom: 1px solid #eaecef;\n}\n\n.gitment-markdown h3 {\n  font-size: 1.25em;\n}\n\n.gitment-markdown h4 {\n  font-size: 1em;\n}\n\n.gitment-markdown h5 {\n  font-size: 0.875em;\n}\n\n.gitment-markdown h6 {\n  font-size: 0.85em;\n  color: #6a737d;\n}\n\n.gitment-markdown ul,\n.gitment-markdown ol {\n  padding-left: 2em;\n}\n\n.gitment-markdown ul ul,\n.gitment-markdown ul ol,\n.gitment-markdown ol ol,\n.gitment-markdown ol ul {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown li>p {\n  margin-top: 16px;\n}\n\n.gitment-markdown li+li {\n  margin-top: 0.25em;\n}\n\n.gitment-markdown dl {\n  padding: 0;\n}\n\n.gitment-markdown dl dt {\n  padding: 0;\n  margin-top: 16px;\n  font-size: 1em;\n  font-style: italic;\n  font-weight: 600;\n}\n\n.gitment-markdown dl dd {\n  padding: 0 16px;\n  margin-bottom: 16px;\n}\n\n.gitment-markdown table {\n  display: block;\n  width: 100%;\n  overflow: auto;\n}\n\n.gitment-markdown table th {\n  font-weight: 600;\n}\n\n.gitment-markdown table th,\n.gitment-markdown table td {\n  padding: 6px 13px;\n  border: 1px solid #dfe2e5;\n}\n\n.gitment-markdown table tr {\n  background-color: #fff;\n  border-top: 1px solid #c6cbd1;\n}\n\n.gitment-markdown table tr:nth-child(2n) {\n  background-color: #f5f5f5;\n}\n\n.gitment-markdown img {\n  max-width: 100%;\n  box-sizing: content-box;\n  background-color: #fff;\n}\n\n.gitment-markdown code {\n  padding: 0;\n  padding-top: 0.2em;\n  padding-bottom: 0.2em;\n  margin: 0;\n  font-size: 85%;\n  background-color: rgba(27,31,35,0.05);\n  border-radius: 0;\n}\n\n.gitment-markdown code::before,\n.gitment-markdown code::after {\n  letter-spacing: -0.2em;\n  content: \"\\00a0\";\n}\n\n.gitment-markdown pre {\n  word-wrap: normal;\n}\n\n.gitment-markdown pre>code {\n  padding: 0;\n  margin: 0;\n  font-size: 100%;\n  word-break: normal;\n  white-space: pre;\n  background: transparent;\n  border: 0;\n}\n\n.gitment-markdown .highlight {\n  margin-bottom: 16px;\n}\n\n.gitment-markdown .highlight pre {\n  margin-bottom: 0;\n  word-break: normal;\n}\n\n.gitment-markdown .highlight pre,\n.gitment-markdown pre {\n  padding: 16px;\n  overflow: auto;\n  font-size: 85%;\n  line-height: 1.45;\n  background-color: #f5f5f5;\n  border-radius: 0;\n}\n\n.gitment-markdown pre code {\n  display: inline;\n  max-width: auto;\n  padding: 0;\n  margin: 0;\n  overflow: visible;\n  line-height: inherit;\n  word-wrap: normal;\n  background-color: transparent;\n  border: 0;\n}\n\n.gitment-markdown pre code::before,\n.gitment-markdown pre code::after {\n  content: normal;\n}\n\n.gitment-markdown .full-commit .btn-outline:not(:disabled):hover {\n  color: #005cc5;\n  border-color: #005cc5;\n}\n\n.gitment-markdown kbd {\n  display: inline-block;\n  padding: 3px 5px;\n  font: 11px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  line-height: 10px;\n  color: #444d56;\n  vertical-align: middle;\n  background-color: #fcfcfc;\n  border: solid 1px #c6cbd1;\n  border-bottom-color: #959da5;\n  border-radius: 0;\n  box-shadow: inset 0 -1px 0 #959da5;\n}\n\n.gitment-markdown :checked+.radio-label {\n  position: relative;\n  z-index: 1;\n  border-color: #0366d6;\n}\n\n.gitment-markdown .task-list-item {\n  list-style-type: none;\n}\n\n.gitment-markdown .task-list-item+.task-list-item {\n  margin-top: 3px;\n}\n\n.gitment-markdown .task-list-item input {\n  margin: 0 0.2em 0.25em -1.6em;\n  vertical-align: middle;\n}\n\n.gitment-markdown hr {\n  border-bottom-color: #eee;\n}\n"},{"title":"tag","layout":"tag","date":"2023-04-02T03:14:07.000Z","_content":"","source":"tag/index.md","raw":"---\ntitle: tag\nlayout: tag\ndate: 2023-04-02 11:14:07\n---\n","updated":"2023-04-06T11:17:47.062Z","path":"tag/index.html","comments":1,"_id":"clqxisunc0008eslrd1bn46d2","content":"\r\n","site":{"data":{}},"excerpt":"","more":"\r\n"},{"_content":"var Gitment =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar LS_ACCESS_TOKEN_KEY = exports.LS_ACCESS_TOKEN_KEY = 'gitment-comments-token';\nvar LS_USER_KEY = exports.LS_USER_KEY = 'gitment-user-info';\n\nvar NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = new Error('Comments Not Initialized');\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) {\n            if (b.hasOwnProperty(p)) d[p] = b[p];\n        }\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nregisterGlobals();\nexports.extras = {\n    allowStateChanges: allowStateChanges,\n    deepEqual: deepEqual,\n    getAtom: getAtom,\n    getDebugName: getDebugName,\n    getDependencyTree: getDependencyTree,\n    getAdministration: getAdministration,\n    getGlobalState: getGlobalState,\n    getObserverTree: getObserverTree,\n    isComputingDerivation: isComputingDerivation,\n    isSpyEnabled: isSpyEnabled,\n    onReactionError: onReactionError,\n    resetGlobalState: resetGlobalState,\n    shareGlobalState: shareGlobalState,\n    spyReport: spyReport,\n    spyReportEnd: spyReportEnd,\n    spyReportStart: spyReportStart,\n    setReactionScheduler: setReactionScheduler\n};\nif ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" ? \"undefined\" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === \"object\") {\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx(module.exports);\n}\nmodule.exports.default = module.exports;\nvar actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {\n    var actionName = args && args.length === 1 ? args[0] : value.name || key || \"<unnamed action>\";\n    var wrappedAction = action(actionName, value);\n    addHiddenProp(target, key, wrappedAction);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, true);\nvar boundActionDecorator = createClassPropertyDecorator(function (target, key, value) {\n    defineBoundAction(target, key, value);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, false);\nvar action = function action(arg1, arg2, arg3, arg4) {\n    if (arguments.length === 1 && typeof arg1 === \"function\") return createAction(arg1.name || \"<unnamed action>\", arg1);\n    if (arguments.length === 2 && typeof arg2 === \"function\") return createAction(arg1, arg2);\n    if (arguments.length === 1 && typeof arg1 === \"string\") return namedActionDecorator(arg1);\n    return namedActionDecorator(arg2).apply(null, arguments);\n};\nexports.action = action;\naction.bound = function boundAction(arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n        var action_1 = createAction(\"<not yet bound action>\", arg1);\n        action_1.autoBind = true;\n        return action_1;\n    }\n    return boundActionDecorator.apply(null, arguments);\n};\nfunction namedActionDecorator(name) {\n    return function (target, prop, descriptor) {\n        if (descriptor && typeof descriptor.value === \"function\") {\n            descriptor.value = createAction(name, descriptor.value);\n            descriptor.enumerable = false;\n            descriptor.configurable = true;\n            return descriptor;\n        }\n        return actionFieldDecorator(name).apply(this, arguments);\n    };\n}\nfunction runInAction(arg1, arg2, arg3) {\n    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action>\";\n    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\n    var scope = typeof arg1 === \"function\" ? arg2 : arg3;\n    invariant(typeof fn === \"function\", getMessage(\"m002\"));\n    invariant(fn.length === 0, getMessage(\"m003\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    return executeAction(actionName, fn, scope, undefined);\n}\nexports.runInAction = runInAction;\nfunction isAction(thing) {\n    return typeof thing === \"function\" && thing.isMobxAction === true;\n}\nexports.isAction = isAction;\nfunction defineBoundAction(target, propertyName, fn) {\n    var res = function res() {\n        return executeAction(propertyName, fn, target, arguments);\n    };\n    res.isMobxAction = true;\n    addHiddenProp(target, propertyName, res);\n}\nfunction autorun(arg1, arg2, arg3) {\n    var name, view, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        view = arg2;\n        scope = arg3;\n    } else {\n        name = arg1.name || \"Autorun@\" + getNextId();\n        view = arg1;\n        scope = arg2;\n    }\n    invariant(typeof view === \"function\", getMessage(\"m004\"));\n    invariant(isAction(view) === false, getMessage(\"m005\"));\n    if (scope) view = view.bind(scope);\n    var reaction = new Reaction(name, function () {\n        this.track(reactionRunner);\n    });\n    function reactionRunner() {\n        view(reaction);\n    }\n    reaction.schedule();\n    return reaction.getDisposer();\n}\nexports.autorun = autorun;\nfunction when(arg1, arg2, arg3, arg4) {\n    var name, predicate, effect, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        predicate = arg2;\n        effect = arg3;\n        scope = arg4;\n    } else {\n        name = \"When@\" + getNextId();\n        predicate = arg1;\n        effect = arg2;\n        scope = arg3;\n    }\n    var disposer = autorun(name, function (r) {\n        if (predicate.call(scope)) {\n            r.dispose();\n            var prevUntracked = untrackedStart();\n            effect.call(scope);\n            untrackedEnd(prevUntracked);\n        }\n    });\n    return disposer;\n}\nexports.when = when;\nfunction autorunAsync(arg1, arg2, arg3, arg4) {\n    var name, func, delay, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        func = arg2;\n        delay = arg3;\n        scope = arg4;\n    } else {\n        name = arg1.name || \"AutorunAsync@\" + getNextId();\n        func = arg1;\n        delay = arg2;\n        scope = arg3;\n    }\n    invariant(isAction(func) === false, getMessage(\"m006\"));\n    if (delay === void 0) delay = 1;\n    if (scope) func = func.bind(scope);\n    var isScheduled = false;\n    var r = new Reaction(name, function () {\n        if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                if (!r.isDisposed) r.track(reactionRunner);\n            }, delay);\n        }\n    });\n    function reactionRunner() {\n        func(r);\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.autorunAsync = autorunAsync;\nfunction reaction(expression, effect, arg3) {\n    if (arguments.length > 3) {\n        fail(getMessage(\"m007\"));\n    }\n    if (isModifierDescriptor(expression)) {\n        fail(getMessage(\"m008\"));\n    }\n    var opts;\n    if ((typeof arg3 === \"undefined\" ? \"undefined\" : _typeof(arg3)) === \"object\") {\n        opts = arg3;\n    } else {\n        opts = {};\n    }\n    opts.name = opts.name || expression.name || effect.name || \"Reaction@\" + getNextId();\n    opts.fireImmediately = arg3 === true || opts.fireImmediately === true;\n    opts.delay = opts.delay || 0;\n    opts.compareStructural = opts.compareStructural || opts.struct || false;\n    effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect);\n    if (opts.context) {\n        expression = expression.bind(opts.context);\n    }\n    var firstTime = true;\n    var isScheduled = false;\n    var nextValue;\n    var r = new Reaction(opts.name, function () {\n        if (firstTime || opts.delay < 1) {\n            reactionRunner();\n        } else if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                reactionRunner();\n            }, opts.delay);\n        }\n    });\n    function reactionRunner() {\n        if (r.isDisposed) return;\n        var changed = false;\n        r.track(function () {\n            var v = expression(r);\n            changed = valueDidChange(opts.compareStructural, nextValue, v);\n            nextValue = v;\n        });\n        if (firstTime && opts.fireImmediately) effect(nextValue, r);\n        if (!firstTime && changed === true) effect(nextValue, r);\n        if (firstTime) firstTime = false;\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.reaction = reaction;\nfunction createComputedDecorator(compareStructural) {\n    return createClassPropertyDecorator(function (target, name, _, __, originalDescriptor) {\n        invariant(typeof originalDescriptor !== \"undefined\", getMessage(\"m009\"));\n        invariant(typeof originalDescriptor.get === \"function\", getMessage(\"m010\"));\n        var adm = asObservableObject(target, \"\");\n        defineComputedProperty(adm, name, originalDescriptor.get, originalDescriptor.set, compareStructural, false);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        this.$mobx.values[name].set(value);\n    }, false, false);\n}\nvar computedDecorator = createComputedDecorator(false);\nvar computedStructDecorator = createComputedDecorator(true);\nvar computed = function computed(arg1, arg2, arg3) {\n    if (typeof arg2 === \"string\") {\n        return computedDecorator.apply(null, arguments);\n    }\n    invariant(typeof arg1 === \"function\", getMessage(\"m011\"));\n    invariant(arguments.length < 3, getMessage(\"m012\"));\n    var opts = (typeof arg2 === \"undefined\" ? \"undefined\" : _typeof(arg2)) === \"object\" ? arg2 : {};\n    opts.setter = typeof arg2 === \"function\" ? arg2 : opts.setter;\n    return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || \"\", opts.setter);\n};\nexports.computed = computed;\ncomputed.struct = computedStructDecorator;\nfunction createTransformer(transformer, onCleanup) {\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\n    var objectCache = {};\n    var resetId = globalState.resetId;\n    var Transformer = function (_super) {\n        __extends(Transformer, _super);\n        function Transformer(sourceIdentifier, sourceObject) {\n            var _this = _super.call(this, function () {\n                return transformer(sourceObject);\n            }, undefined, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier, undefined) || this;\n            _this.sourceIdentifier = sourceIdentifier;\n            _this.sourceObject = sourceObject;\n            return _this;\n        }\n        Transformer.prototype.onBecomeUnobserved = function () {\n            var lastValue = this.value;\n            _super.prototype.onBecomeUnobserved.call(this);\n            delete objectCache[this.sourceIdentifier];\n            if (onCleanup) onCleanup(lastValue, this.sourceObject);\n        };\n        return Transformer;\n    }(ComputedValue);\n    return function (object) {\n        if (resetId !== globalState.resetId) {\n            objectCache = {};\n            resetId = globalState.resetId;\n        }\n        var identifier = getMemoizationId(object);\n        var reactiveTransformer = objectCache[identifier];\n        if (reactiveTransformer) return reactiveTransformer.get();\n        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);\n        return reactiveTransformer.get();\n    };\n}\nexports.createTransformer = createTransformer;\nfunction getMemoizationId(object) {\n    if (object === null || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") throw new Error(\"[mobx] transform expected some kind of object, got: \" + object);\n    var tid = object.$transformId;\n    if (tid === undefined) {\n        tid = getNextId();\n        addHiddenProp(object, \"$transformId\", tid);\n    }\n    return tid;\n}\nfunction expr(expr, scope) {\n    if (!isComputingDerivation()) console.warn(getMessage(\"m013\"));\n    return computed(expr, { context: scope }).get();\n}\nexports.expr = expr;\nfunction extendObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, deepEnhancer, properties);\n}\nexports.extendObservable = extendObservable;\nfunction extendShallowObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, referenceEnhancer, properties);\n}\nexports.extendShallowObservable = extendShallowObservable;\nfunction extendObservableHelper(target, defaultEnhancer, properties) {\n    invariant(arguments.length >= 2, getMessage(\"m014\"));\n    invariant((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\", getMessage(\"m015\"));\n    invariant(!isObservableMap(target), getMessage(\"m016\"));\n    properties.forEach(function (propSet) {\n        invariant((typeof propSet === \"undefined\" ? \"undefined\" : _typeof(propSet)) === \"object\", getMessage(\"m017\"));\n        invariant(!isObservable(propSet), getMessage(\"m018\"));\n    });\n    var adm = asObservableObject(target);\n    var definedProps = {};\n    for (var i = properties.length - 1; i >= 0; i--) {\n        var propSet = properties[i];\n        for (var key in propSet) {\n            if (definedProps[key] !== true && hasOwnProperty(propSet, key)) {\n                definedProps[key] = true;\n                if (target === propSet && !isPropertyConfigurable(target, key)) continue;\n                var descriptor = Object.getOwnPropertyDescriptor(propSet, key);\n                defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer);\n            }\n        }\n    }\n    return target;\n}\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree);\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (hasObservers(node)) result.observers = getObservers(node).map(nodeToObserverTree);\n    return result;\n}\nfunction intercept(thing, propOrHandler, handler) {\n    if (typeof handler === \"function\") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);\n}\nexports.intercept = intercept;\nfunction interceptInterceptable(thing, handler) {\n    return getAdministration(thing).intercept(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    return getAdministration(thing, property).intercept(handler);\n}\nfunction isComputed(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableObject(value) === false) return false;\n        var atom = getAtom(value, property);\n        return isComputedValue(atom);\n    }\n    return isComputedValue(value);\n}\nexports.isComputed = isComputed;\nfunction isObservable(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableArray(value) || isObservableMap(value)) throw new Error(getMessage(\"m019\"));else if (isObservableObject(value)) {\n            var o = value.$mobx;\n            return o.values && !!o.values[property];\n        }\n        return false;\n    }\n    return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value);\n}\nexports.isObservable = isObservable;\nvar deepDecorator = createDecoratorForEnhancer(deepEnhancer);\nvar shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);\nvar refDecorator = createDecoratorForEnhancer(referenceEnhancer);\nvar deepStructDecorator = createDecoratorForEnhancer(deepStructEnhancer);\nvar refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);\nfunction createObservable(v) {\n    if (v === void 0) {\n        v = undefined;\n    }\n    if (typeof arguments[1] === \"string\") return deepDecorator.apply(null, arguments);\n    invariant(arguments.length <= 1, getMessage(\"m021\"));\n    invariant(!isModifierDescriptor(v), getMessage(\"m020\"));\n    if (isObservable(v)) return v;\n    var res = deepEnhancer(v, undefined, undefined);\n    if (res !== v) return res;\n    return observable.box(v);\n}\nvar IObservableFactories = function () {\n    function IObservableFactories() {}\n    IObservableFactories.prototype.box = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"box\");\n        return new ObservableValue(value, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowBox = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowBox\");\n        return new ObservableValue(value, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.array = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"array\");\n        return new ObservableArray(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowArray = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowArray\");\n        return new ObservableArray(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.map = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"map\");\n        return new ObservableMap(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowMap = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowMap\");\n        return new ObservableMap(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.object = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"object\");\n        var res = {};\n        asObservableObject(res, name);\n        extendObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.shallowObject = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowObject\");\n        var res = {};\n        asObservableObject(res, name);\n        extendShallowObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.ref = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(referenceEnhancer, arguments[0]);\n        } else {\n            return refDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.shallow = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(shallowEnhancer, arguments[0]);\n        } else {\n            return shallowDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.deep = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepEnhancer, arguments[0]);\n        } else {\n            return deepDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.struct = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepStructEnhancer, arguments[0]);\n        } else {\n            return deepStructDecorator.apply(null, arguments);\n        }\n    };\n    return IObservableFactories;\n}();\nexports.IObservableFactories = IObservableFactories;\nvar observable = createObservable;\nexports.observable = observable;\nObject.keys(IObservableFactories.prototype).forEach(function (key) {\n    return observable[key] = IObservableFactories.prototype[key];\n});\nobservable.deep.struct = observable.struct;\nobservable.ref.struct = function () {\n    if (arguments.length < 2) {\n        return createModifierDescriptor(refStructEnhancer, arguments[0]);\n    } else {\n        return refStructDecorator.apply(null, arguments);\n    }\n};\nfunction incorrectlyUsedAsDecorator(methodName) {\n    fail(\"Expected one or two arguments to observable.\" + methodName + \". Did you accidentally try to use observable.\" + methodName + \" as decorator?\");\n}\nfunction createDecoratorForEnhancer(enhancer) {\n    invariant(!!enhancer, \":(\");\n    return createClassPropertyDecorator(function (target, name, baseValue, _, baseDescriptor) {\n        assertPropertyConfigurable(target, name);\n        invariant(!baseDescriptor || !baseDescriptor.get, getMessage(\"m022\"));\n        var adm = asObservableObject(target, undefined);\n        defineObservableProperty(adm, name, baseValue, enhancer);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        setPropertyValue(this, name, value);\n    }, true, false);\n}\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (typeof cbOrFire === \"function\") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);\n}\nexports.observe = observe;\nfunction observeObservable(thing, listener, fireImmediately) {\n    return getAdministration(thing).observe(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    return getAdministration(thing, property).observe(listener, fireImmediately);\n}\nfunction toJS(source, detectCycles, __alreadySeen) {\n    if (detectCycles === void 0) {\n        detectCycles = true;\n    }\n    if (__alreadySeen === void 0) {\n        __alreadySeen = [];\n    }\n    function cache(value) {\n        if (detectCycles) __alreadySeen.push([source, value]);\n        return value;\n    }\n    if (isObservable(source)) {\n        if (detectCycles && __alreadySeen === null) __alreadySeen = [];\n        if (detectCycles && source !== null && (typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") {\n            for (var i = 0, l = __alreadySeen.length; i < l; i++) {\n                if (__alreadySeen[i][0] === source) return __alreadySeen[i][1];\n            }\n        }\n        if (isObservableArray(source)) {\n            var res = cache([]);\n            var toAdd = source.map(function (value) {\n                return toJS(value, detectCycles, __alreadySeen);\n            });\n            res.length = toAdd.length;\n            for (var i = 0, l = toAdd.length; i < l; i++) {\n                res[i] = toAdd[i];\n            }return res;\n        }\n        if (isObservableObject(source)) {\n            var res = cache({});\n            for (var key in source) {\n                res[key] = toJS(source[key], detectCycles, __alreadySeen);\n            }return res;\n        }\n        if (isObservableMap(source)) {\n            var res_1 = cache({});\n            source.forEach(function (value, key) {\n                return res_1[key] = toJS(value, detectCycles, __alreadySeen);\n            });\n            return res_1;\n        }\n        if (isObservableValue(source)) return toJS(source.get(), detectCycles, __alreadySeen);\n    }\n    return source;\n}\nexports.toJS = toJS;\nfunction transaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    deprecated(getMessage(\"m023\"));\n    return runInTransaction.apply(undefined, arguments);\n}\nexports.transaction = transaction;\nfunction runInTransaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    return executeAction(\"\", action);\n}\nfunction log(msg) {\n    console.log(msg);\n    return msg;\n}\nfunction whyRun(thing, prop) {\n    switch (arguments.length) {\n        case 0:\n            thing = globalState.trackingDerivation;\n            if (!thing) return log(getMessage(\"m024\"));\n            break;\n        case 2:\n            thing = getAtom(thing, prop);\n            break;\n    }\n    thing = getAtom(thing);\n    if (isComputedValue(thing)) return log(thing.whyRun());else if (isReaction(thing)) return log(thing.whyRun());\n    return fail(getMessage(\"m025\"));\n}\nexports.whyRun = whyRun;\nfunction createAction(actionName, fn) {\n    invariant(typeof fn === \"function\", getMessage(\"m026\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    var res = function res() {\n        return executeAction(actionName, fn, this, arguments);\n    };\n    res.originalFn = fn;\n    res.isMobxAction = true;\n    return res;\n}\nfunction executeAction(actionName, fn, scope, args) {\n    var runInfo = startAction(actionName, fn, scope, args);\n    try {\n        return fn.apply(scope, args);\n    } finally {\n        endAction(runInfo);\n    }\n}\nfunction startAction(actionName, fn, scope, args) {\n    var notifySpy = isSpyEnabled() && !!actionName;\n    var startTime = 0;\n    if (notifySpy) {\n        startTime = Date.now();\n        var l = args && args.length || 0;\n        var flattendArgs = new Array(l);\n        if (l > 0) for (var i = 0; i < l; i++) {\n            flattendArgs[i] = args[i];\n        }spyReportStart({\n            type: \"action\",\n            name: actionName,\n            fn: fn,\n            object: scope,\n            arguments: flattendArgs\n        });\n    }\n    var prevDerivation = untrackedStart();\n    startBatch();\n    var prevAllowStateChanges = allowStateChangesStart(true);\n    return {\n        prevDerivation: prevDerivation,\n        prevAllowStateChanges: prevAllowStateChanges,\n        notifySpy: notifySpy,\n        startTime: startTime\n    };\n}\nfunction endAction(runInfo) {\n    allowStateChangesEnd(runInfo.prevAllowStateChanges);\n    endBatch();\n    untrackedEnd(runInfo.prevDerivation);\n    if (runInfo.notifySpy) spyReportEnd({ time: Date.now() - runInfo.startTime });\n}\nfunction useStrict(strict) {\n    invariant(globalState.trackingDerivation === null, getMessage(\"m028\"));\n    globalState.strictMode = strict;\n    globalState.allowStateChanges = !strict;\n}\nexports.useStrict = useStrict;\nfunction isStrictModeEnabled() {\n    return globalState.strictMode;\n}\nexports.isStrictModeEnabled = isStrictModeEnabled;\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    var res;\n    try {\n        res = func();\n    } finally {\n        allowStateChangesEnd(prev);\n    }\n    return res;\n}\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nvar BaseAtom = function () {\n    function BaseAtom(name) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        this.name = name;\n        this.isPendingUnobservation = true;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.NOT_TRACKING;\n    }\n    BaseAtom.prototype.onBecomeUnobserved = function () {};\n    BaseAtom.prototype.reportObserved = function () {\n        reportObserved(this);\n    };\n    BaseAtom.prototype.reportChanged = function () {\n        startBatch();\n        propagateChanged(this);\n        endBatch();\n    };\n    BaseAtom.prototype.toString = function () {\n        return this.name;\n    };\n    return BaseAtom;\n}();\nexports.BaseAtom = BaseAtom;\nvar Atom = function (_super) {\n    __extends(Atom, _super);\n    function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        if (onBecomeObservedHandler === void 0) {\n            onBecomeObservedHandler = noop;\n        }\n        if (onBecomeUnobservedHandler === void 0) {\n            onBecomeUnobservedHandler = noop;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.name = name;\n        _this.onBecomeObservedHandler = onBecomeObservedHandler;\n        _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;\n        _this.isPendingUnobservation = false;\n        _this.isBeingTracked = false;\n        return _this;\n    }\n    Atom.prototype.reportObserved = function () {\n        startBatch();\n        _super.prototype.reportObserved.call(this);\n        if (!this.isBeingTracked) {\n            this.isBeingTracked = true;\n            this.onBecomeObservedHandler();\n        }\n        endBatch();\n        return !!globalState.trackingDerivation;\n    };\n    Atom.prototype.onBecomeUnobserved = function () {\n        this.isBeingTracked = false;\n        this.onBecomeUnobservedHandler();\n    };\n    return Atom;\n}(BaseAtom);\nexports.Atom = Atom;\nvar isAtom = createInstanceofPredicate(\"Atom\", BaseAtom);\nvar ComputedValue = function () {\n    function ComputedValue(derivation, scope, compareStructural, name, setter) {\n        this.derivation = derivation;\n        this.scope = scope;\n        this.compareStructural = compareStructural;\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.observing = [];\n        this.newObserving = null;\n        this.isPendingUnobservation = false;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.runId = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.UP_TO_DATE;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.value = undefined;\n        this.isComputing = false;\n        this.isRunningSetter = false;\n        this.name = name || \"ComputedValue@\" + getNextId();\n        if (setter) this.setter = createAction(name + \"-setter\", setter);\n    }\n    ComputedValue.prototype.onBecomeStale = function () {\n        propagateMaybeChanged(this);\n    };\n    ComputedValue.prototype.onBecomeUnobserved = function () {\n        invariant(this.dependenciesState !== IDerivationState.NOT_TRACKING, getMessage(\"m029\"));\n        clearObserving(this);\n        this.value = undefined;\n    };\n    ComputedValue.prototype.get = function () {\n        invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation);\n        if (globalState.inBatch === 0) {\n            startBatch();\n            if (shouldCompute(this)) this.value = this.computeValue(false);\n            endBatch();\n        } else {\n            reportObserved(this);\n            if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this);\n        }\n        var result = this.value;\n        if (isCaughtException(result)) throw result.cause;\n        return result;\n    };\n    ComputedValue.prototype.peek = function () {\n        var res = this.computeValue(false);\n        if (isCaughtException(res)) throw res.cause;\n        return res;\n    };\n    ComputedValue.prototype.set = function (value) {\n        if (this.setter) {\n            invariant(!this.isRunningSetter, \"The setter of computed value '\" + this.name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\");\n            this.isRunningSetter = true;\n            try {\n                this.setter.call(this.scope, value);\n            } finally {\n                this.isRunningSetter = false;\n            }\n        } else invariant(false, \"[ComputedValue '\" + this.name + \"'] It is not possible to assign a new value to a computed value.\");\n    };\n    ComputedValue.prototype.trackAndCompute = function () {\n        if (isSpyEnabled()) {\n            spyReport({\n                object: this.scope,\n                type: \"compute\",\n                fn: this.derivation\n            });\n        }\n        var oldValue = this.value;\n        var newValue = this.value = this.computeValue(true);\n        return isCaughtException(newValue) || valueDidChange(this.compareStructural, newValue, oldValue);\n    };\n    ComputedValue.prototype.computeValue = function (track) {\n        this.isComputing = true;\n        globalState.computationDepth++;\n        var res;\n        if (track) {\n            res = trackDerivedFunction(this, this.derivation, this.scope);\n        } else {\n            try {\n                res = this.derivation.call(this.scope);\n            } catch (e) {\n                res = new CaughtException(e);\n            }\n        }\n        globalState.computationDepth--;\n        this.isComputing = false;\n        return res;\n    };\n    ;\n    ComputedValue.prototype.observe = function (listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function () {\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener({\n                    type: \"update\",\n                    object: _this,\n                    newValue: newValue,\n                    oldValue: prevValue\n                });\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    ComputedValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ComputedValue.prototype.toString = function () {\n        return this.name + \"[\" + this.derivation.toString() + \"]\";\n    };\n    ComputedValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    ;\n    ComputedValue.prototype.whyRun = function () {\n        var isTracking = Boolean(globalState.trackingDerivation);\n        var observing = unique(this.isComputing ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        var observers = unique(getObservers(this).map(function (dep) {\n            return dep.name;\n        }));\n        return \"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + (isTracking ? \"[active] the value of this computation is needed by a reaction\" : this.isComputing ? \"[get] The value of this computed was requested outside a reaction\" : \"[idle] not running at the moment\") + \"\\n\" + (this.dependenciesState === IDerivationState.NOT_TRACKING ? getMessage(\"m032\") : \" * This computation will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this.isComputing && isTracking ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\\n  * If the outcome of this computation changes, the following observers will be re-run:\\n    \" + joinStrings(observers) + \"\\n\");\n    };\n    return ComputedValue;\n}();\nComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf;\nvar isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue);\nvar IDerivationState;\n(function (IDerivationState) {\n    IDerivationState[IDerivationState[\"NOT_TRACKING\"] = -1] = \"NOT_TRACKING\";\n    IDerivationState[IDerivationState[\"UP_TO_DATE\"] = 0] = \"UP_TO_DATE\";\n    IDerivationState[IDerivationState[\"POSSIBLY_STALE\"] = 1] = \"POSSIBLY_STALE\";\n    IDerivationState[IDerivationState[\"STALE\"] = 2] = \"STALE\";\n})(IDerivationState || (IDerivationState = {}));\nexports.IDerivationState = IDerivationState;\nvar CaughtException = function () {\n    function CaughtException(cause) {\n        this.cause = cause;\n    }\n    return CaughtException;\n}();\nfunction isCaughtException(e) {\n    return e instanceof CaughtException;\n}\nfunction shouldCompute(derivation) {\n    switch (derivation.dependenciesState) {\n        case IDerivationState.UP_TO_DATE:\n            return false;\n        case IDerivationState.NOT_TRACKING:\n        case IDerivationState.STALE:\n            return true;\n        case IDerivationState.POSSIBLY_STALE:\n            {\n                var prevUntracked = untrackedStart();\n                var obs = derivation.observing,\n                    l = obs.length;\n                for (var i = 0; i < l; i++) {\n                    var obj = obs[i];\n                    if (isComputedValue(obj)) {\n                        try {\n                            obj.get();\n                        } catch (e) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                        if (derivation.dependenciesState === IDerivationState.STALE) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                    }\n                }\n                changeDependenciesStateTo0(derivation);\n                untrackedEnd(prevUntracked);\n                return false;\n            }\n    }\n}\nfunction isComputingDerivation() {\n    return globalState.trackingDerivation !== null;\n}\nfunction checkIfStateModificationsAreAllowed(atom) {\n    var hasObservers = atom.observers.length > 0;\n    if (globalState.computationDepth > 0 && hasObservers) fail(getMessage(\"m031\") + atom.name);\n    if (!globalState.allowStateChanges && hasObservers) fail(getMessage(globalState.strictMode ? \"m030a\" : \"m030b\") + atom.name);\n}\nfunction trackDerivedFunction(derivation, f, context) {\n    changeDependenciesStateTo0(derivation);\n    derivation.newObserving = new Array(derivation.observing.length + 100);\n    derivation.unboundDepsCount = 0;\n    derivation.runId = ++globalState.runId;\n    var prevTracking = globalState.trackingDerivation;\n    globalState.trackingDerivation = derivation;\n    var result;\n    try {\n        result = f.call(context);\n    } catch (e) {\n        result = new CaughtException(e);\n    }\n    globalState.trackingDerivation = prevTracking;\n    bindDependencies(derivation);\n    return result;\n}\nfunction bindDependencies(derivation) {\n    var prevObserving = derivation.observing;\n    var observing = derivation.observing = derivation.newObserving;\n    derivation.newObserving = null;\n    var i0 = 0,\n        l = derivation.unboundDepsCount;\n    for (var i = 0; i < l; i++) {\n        var dep = observing[i];\n        if (dep.diffValue === 0) {\n            dep.diffValue = 1;\n            if (i0 !== i) observing[i0] = dep;\n            i0++;\n        }\n    }\n    observing.length = i0;\n    l = prevObserving.length;\n    while (l--) {\n        var dep = prevObserving[l];\n        if (dep.diffValue === 0) {\n            removeObserver(dep, derivation);\n        }\n        dep.diffValue = 0;\n    }\n    while (i0--) {\n        var dep = observing[i0];\n        if (dep.diffValue === 1) {\n            dep.diffValue = 0;\n            addObserver(dep, derivation);\n        }\n    }\n}\nfunction clearObserving(derivation) {\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        removeObserver(obs[i], derivation);\n    }derivation.dependenciesState = IDerivationState.NOT_TRACKING;\n    obs.length = 0;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    var res = action();\n    untrackedEnd(prev);\n    return res;\n}\nexports.untracked = untracked;\nfunction untrackedStart() {\n    var prev = globalState.trackingDerivation;\n    globalState.trackingDerivation = null;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.trackingDerivation = prev;\n}\nfunction changeDependenciesStateTo0(derivation) {\n    if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return;\n    derivation.dependenciesState = IDerivationState.UP_TO_DATE;\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nvar persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"];\nvar MobXGlobals = function () {\n    function MobXGlobals() {\n        this.version = 5;\n        this.trackingDerivation = null;\n        this.computationDepth = 0;\n        this.runId = 0;\n        this.mobxGuid = 0;\n        this.inBatch = 0;\n        this.pendingUnobservations = [];\n        this.pendingReactions = [];\n        this.isRunningReactions = false;\n        this.allowStateChanges = true;\n        this.strictMode = false;\n        this.resetId = 0;\n        this.spyListeners = [];\n        this.globalReactionErrorHandlers = [];\n    }\n    return MobXGlobals;\n}();\nvar globalState = new MobXGlobals();\nfunction shareGlobalState() {\n    var global = getGlobal();\n    var ownState = globalState;\n    if (global.__mobservableTrackingStack || global.__mobservableViewStack) throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\");\n    if (global.__mobxGlobal && global.__mobxGlobal.version !== ownState.version) throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\");\n    if (global.__mobxGlobal) globalState = global.__mobxGlobal;else global.__mobxGlobal = ownState;\n}\nfunction getGlobalState() {\n    return globalState;\n}\nfunction registerGlobals() {}\nfunction resetGlobalState() {\n    globalState.resetId++;\n    var defaultGlobals = new MobXGlobals();\n    for (var key in defaultGlobals) {\n        if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];\n    }globalState.allowStateChanges = !globalState.strictMode;\n}\nfunction hasObservers(observable) {\n    return observable.observers && observable.observers.length > 0;\n}\nfunction getObservers(observable) {\n    return observable.observers;\n}\nfunction invariantObservers(observable) {\n    var list = observable.observers;\n    var map = observable.observersIndexes;\n    var l = list.length;\n    for (var i = 0; i < l; i++) {\n        var id = list[i].__mapid;\n        if (i) {\n            invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\");\n        } else {\n            invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldnt be held in map.\");\n        }\n    }\n    invariant(list.length === 0 || Object.keys(map).length === list.length - 1, \"INTERNAL ERROR there is no junk in map\");\n}\nfunction addObserver(observable, node) {\n    var l = observable.observers.length;\n    if (l) {\n        observable.observersIndexes[node.__mapid] = l;\n    }\n    observable.observers[l] = node;\n    if (observable.lowestObserverState > node.dependenciesState) observable.lowestObserverState = node.dependenciesState;\n}\nfunction removeObserver(observable, node) {\n    if (observable.observers.length === 1) {\n        observable.observers.length = 0;\n        queueForUnobservation(observable);\n    } else {\n        var list = observable.observers;\n        var map_1 = observable.observersIndexes;\n        var filler = list.pop();\n        if (filler !== node) {\n            var index = map_1[node.__mapid] || 0;\n            if (index) {\n                map_1[filler.__mapid] = index;\n            } else {\n                delete map_1[filler.__mapid];\n            }\n            list[index] = filler;\n        }\n        delete map_1[node.__mapid];\n    }\n}\nfunction queueForUnobservation(observable) {\n    if (!observable.isPendingUnobservation) {\n        observable.isPendingUnobservation = true;\n        globalState.pendingUnobservations.push(observable);\n    }\n}\nfunction startBatch() {\n    globalState.inBatch++;\n}\nfunction endBatch() {\n    if (--globalState.inBatch === 0) {\n        runReactions();\n        var list = globalState.pendingUnobservations;\n        for (var i = 0; i < list.length; i++) {\n            var observable_1 = list[i];\n            observable_1.isPendingUnobservation = false;\n            if (observable_1.observers.length === 0) {\n                observable_1.onBecomeUnobserved();\n            }\n        }\n        globalState.pendingUnobservations = [];\n    }\n}\nfunction reportObserved(observable) {\n    var derivation = globalState.trackingDerivation;\n    if (derivation !== null) {\n        if (derivation.runId !== observable.lastAccessedBy) {\n            observable.lastAccessedBy = derivation.runId;\n            derivation.newObserving[derivation.unboundDepsCount++] = observable;\n        }\n    } else if (observable.observers.length === 0) {\n        queueForUnobservation(observable);\n    }\n}\nfunction invariantLOS(observable, msg) {\n    var min = getObservers(observable).reduce(function (a, b) {\n        return Math.min(a, b.dependenciesState);\n    }, 2);\n    if (min >= observable.lowestObserverState) return;\n    throw new Error(\"lowestObserverState is wrong for \" + msg + \" because \" + min + \" < \" + observable.lowestObserverState);\n}\nfunction propagateChanged(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale();\n        d.dependenciesState = IDerivationState.STALE;\n    }\n}\nfunction propagateChangeConfirmed(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.POSSIBLY_STALE) d.dependenciesState = IDerivationState.STALE;else if (d.dependenciesState === IDerivationState.UP_TO_DATE) observable.lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nfunction propagateMaybeChanged(observable) {\n    if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return;\n    observable.lowestObserverState = IDerivationState.POSSIBLY_STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {\n            d.dependenciesState = IDerivationState.POSSIBLY_STALE;\n            d.onBecomeStale();\n        }\n    }\n}\nvar Reaction = function () {\n    function Reaction(name, onInvalidate) {\n        if (name === void 0) {\n            name = \"Reaction@\" + getNextId();\n        }\n        this.name = name;\n        this.onInvalidate = onInvalidate;\n        this.observing = [];\n        this.newObserving = [];\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.diffValue = 0;\n        this.runId = 0;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.isDisposed = false;\n        this._isScheduled = false;\n        this._isTrackPending = false;\n        this._isRunning = false;\n    }\n    Reaction.prototype.onBecomeStale = function () {\n        this.schedule();\n    };\n    Reaction.prototype.schedule = function () {\n        if (!this._isScheduled) {\n            this._isScheduled = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    };\n    Reaction.prototype.isScheduled = function () {\n        return this._isScheduled;\n    };\n    Reaction.prototype.runReaction = function () {\n        if (!this.isDisposed) {\n            startBatch();\n            this._isScheduled = false;\n            if (shouldCompute(this)) {\n                this._isTrackPending = true;\n                this.onInvalidate();\n                if (this._isTrackPending && isSpyEnabled()) {\n                    spyReport({\n                        object: this,\n                        type: \"scheduled-reaction\"\n                    });\n                }\n            }\n            endBatch();\n        }\n    };\n    Reaction.prototype.track = function (fn) {\n        startBatch();\n        var notify = isSpyEnabled();\n        var startTime;\n        if (notify) {\n            startTime = Date.now();\n            spyReportStart({\n                object: this,\n                type: \"reaction\",\n                fn: fn\n            });\n        }\n        this._isRunning = true;\n        var result = trackDerivedFunction(this, fn, undefined);\n        this._isRunning = false;\n        this._isTrackPending = false;\n        if (this.isDisposed) {\n            clearObserving(this);\n        }\n        if (isCaughtException(result)) this.reportExceptionInDerivation(result.cause);\n        if (notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n        endBatch();\n    };\n    Reaction.prototype.reportExceptionInDerivation = function (error) {\n        var _this = this;\n        if (this.errorHandler) {\n            this.errorHandler(error, this);\n            return;\n        }\n        var message = \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this;\n        var messageToUser = getMessage(\"m037\");\n        console.error(message || messageToUser, error);\n        if (isSpyEnabled()) {\n            spyReport({\n                type: \"error\",\n                message: message,\n                error: error,\n                object: this\n            });\n        }\n        globalState.globalReactionErrorHandlers.forEach(function (f) {\n            return f(error, _this);\n        });\n    };\n    Reaction.prototype.dispose = function () {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            if (!this._isRunning) {\n                startBatch();\n                clearObserving(this);\n                endBatch();\n            }\n        }\n    };\n    Reaction.prototype.getDisposer = function () {\n        var r = this.dispose.bind(this);\n        r.$mobx = this;\n        r.onError = registerErrorHandler;\n        return r;\n    };\n    Reaction.prototype.toString = function () {\n        return \"Reaction[\" + this.name + \"]\";\n    };\n    Reaction.prototype.whyRun = function () {\n        var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        return \"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this._isRunning ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\";\n    };\n    return Reaction;\n}();\nexports.Reaction = Reaction;\nfunction registerErrorHandler(handler) {\n    invariant(this && this.$mobx && isReaction(this.$mobx), \"Invalid `this`\");\n    invariant(!this.$mobx.errorHandler, \"Only one onErrorHandler can be registered\");\n    this.$mobx.errorHandler = handler;\n}\nfunction onReactionError(handler) {\n    globalState.globalReactionErrorHandlers.push(handler);\n    return function () {\n        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n        if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);\n    };\n}\nvar MAX_REACTION_ITERATIONS = 100;\nvar reactionScheduler = function reactionScheduler(f) {\n    return f();\n};\nfunction runReactions() {\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) return;\n    reactionScheduler(runReactionsHelper);\n}\nfunction runReactionsHelper() {\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    while (allReactions.length > 0) {\n        if (++iterations === MAX_REACTION_ITERATIONS) {\n            console.error(\"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0]));\n            allReactions.splice(0);\n        }\n        var remainingReactions = allReactions.splice(0);\n        for (var i = 0, l = remainingReactions.length; i < l; i++) {\n            remainingReactions[i].runReaction();\n        }\n    }\n    globalState.isRunningReactions = false;\n}\nvar isReaction = createInstanceofPredicate(\"Reaction\", Reaction);\nfunction setReactionScheduler(fn) {\n    var baseScheduler = reactionScheduler;\n    reactionScheduler = function reactionScheduler(f) {\n        return fn(function () {\n            return baseScheduler(f);\n        });\n    };\n}\nfunction isSpyEnabled() {\n    return !!globalState.spyListeners.length;\n}\nfunction spyReport(event) {\n    if (!globalState.spyListeners.length) return;\n    var listeners = globalState.spyListeners;\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](event);\n    }\n}\nfunction spyReportStart(event) {\n    var change = objectAssign({}, event, { spyReportStart: true });\n    spyReport(change);\n}\nvar END_EVENT = { spyReportEnd: true };\nfunction spyReportEnd(change) {\n    if (change) spyReport(objectAssign({}, change, END_EVENT));else spyReport(END_EVENT);\n}\nfunction spy(listener) {\n    globalState.spyListeners.push(listener);\n    return once(function () {\n        var idx = globalState.spyListeners.indexOf(listener);\n        if (idx !== -1) globalState.spyListeners.splice(idx, 1);\n    });\n}\nexports.spy = spy;\nfunction hasInterceptors(interceptable) {\n    return interceptable.interceptors && interceptable.interceptors.length > 0;\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);\n    interceptors.push(handler);\n    return once(function () {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1) interceptors.splice(idx, 1);\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    try {\n        var interceptors = interceptable.interceptors;\n        if (interceptors) for (var i = 0, l = interceptors.length; i < l; i++) {\n            change = interceptors[i](change);\n            invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\");\n            if (!change) break;\n        }\n        return change;\n    } finally {\n        untrackedEnd(prevU);\n    }\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners && listenable.changeListeners.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners || (listenable.changeListeners = []);\n    listeners.push(handler);\n    return once(function () {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1) listeners.splice(idx, 1);\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners;\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](change);\n    }\n    untrackedEnd(prevU);\n}\nfunction asReference(value) {\n    deprecated(\"asReference is deprecated, use observable.ref instead\");\n    return observable.ref(value);\n}\nexports.asReference = asReference;\nfunction asStructure(value) {\n    deprecated(\"asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.\");\n    return observable.struct(value);\n}\nexports.asStructure = asStructure;\nfunction asFlat(value) {\n    deprecated(\"asFlat is deprecated, use observable.shallow instead\");\n    return observable.shallow(value);\n}\nexports.asFlat = asFlat;\nfunction asMap(data) {\n    deprecated(\"asMap is deprecated, use observable.map or observable.shallowMap instead\");\n    return observable.map(data || {});\n}\nexports.asMap = asMap;\nfunction isModifierDescriptor(thing) {\n    return (typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null && thing.isMobxModifierDescriptor === true;\n}\nexports.isModifierDescriptor = isModifierDescriptor;\nfunction createModifierDescriptor(enhancer, initialValue) {\n    invariant(!isModifierDescriptor(initialValue), \"Modifiers cannot be nested\");\n    return {\n        isMobxModifierDescriptor: true,\n        initialValue: initialValue,\n        enhancer: enhancer\n    };\n}\nfunction deepEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return observable.array(v, name);\n    if (isPlainObject(v)) return observable.object(v, name);\n    if (isES6Map(v)) return observable.map(v, name);\n    return v;\n}\nfunction shallowEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (v === undefined || v === null) return v;\n    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v)) return v;\n    if (Array.isArray(v)) return observable.shallowArray(v, name);\n    if (isPlainObject(v)) return observable.shallowObject(v, name);\n    if (isES6Map(v)) return observable.shallowMap(v, name);\n    return fail(\"The shallow modifier / decorator can only used in combination with arrays, objects and maps\");\n}\nfunction referenceEnhancer(newValue) {\n    return newValue;\n}\nfunction deepStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return new ObservableArray(v, deepStructEnhancer, name);\n    if (isES6Map(v)) return new ObservableMap(v, deepStructEnhancer, name);\n    if (isPlainObject(v)) {\n        var res = {};\n        asObservableObject(res, name);\n        extendObservableHelper(res, deepStructEnhancer, [v]);\n        return res;\n    }\n    return v;\n}\nfunction refStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    return v;\n}\nvar MAX_SPLICE_SIZE = 10000;\nvar safariPrototypeSetterInheritanceBug = function () {\n    var v = false;\n    var p = {};\n    Object.defineProperty(p, \"0\", { set: function set() {\n            v = true;\n        } });\n    Object.create(p)[\"0\"] = 1;\n    return v === false;\n}();\nvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\nvar StubArray = function () {\n    function StubArray() {}\n    return StubArray;\n}();\nStubArray.prototype = [];\nvar ObservableArrayAdministration = function () {\n    function ObservableArrayAdministration(name, enhancer, array, owned) {\n        this.array = array;\n        this.owned = owned;\n        this.lastKnownLength = 0;\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.atom = new BaseAtom(name || \"ObservableArray@\" + getNextId());\n        this.enhancer = function (newV, oldV) {\n            return enhancer(newV, oldV, name + \"[..]\");\n        };\n    }\n    ObservableArrayAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        if (fireImmediately) {\n            listener({\n                object: this.array,\n                type: \"splice\",\n                index: 0,\n                added: this.values.slice(),\n                addedCount: this.values.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    ObservableArrayAdministration.prototype.getArrayLength = function () {\n        this.atom.reportObserved();\n        return this.values.length;\n    };\n    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {\n        if (typeof newLength !== \"number\" || newLength < 0) throw new Error(\"[mobx.array] Out of range: \" + newLength);\n        var currentLength = this.values.length;\n        if (newLength === currentLength) return;else if (newLength > currentLength) {\n            var newItems = new Array(newLength - currentLength);\n            for (var i = 0; i < newLength - currentLength; i++) {\n                newItems[i] = undefined;\n            }this.spliceWithArray(currentLength, 0, newItems);\n        } else this.spliceWithArray(newLength, currentLength - newLength);\n    };\n    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {\n        if (oldLength !== this.lastKnownLength) throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\");\n        this.lastKnownLength += delta;\n        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1);\n    };\n    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        var _this = this;\n        checkIfStateModificationsAreAllowed(this.atom);\n        var length = this.values.length;\n        if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);\n        if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        if (newItems === undefined) newItems = [];\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.array,\n                type: \"splice\",\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change) return EMPTY_ARRAY;\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.map(function (v) {\n            return _this.enhancer(v, undefined);\n        });\n        var lengthDelta = newItems.length - deleteCount;\n        this.updateArrayLength(length, lengthDelta);\n        var res = this.spliceItemsIntoValues(index, deleteCount, newItems);\n        if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res);\n        return res;\n    };\n    ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) {\n        if (newItems.length < MAX_SPLICE_SIZE) {\n            return (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));\n        } else {\n            var res = this.values.slice(index, index + deleteCount);\n            this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount));\n            return res;\n        }\n        var _a;\n    };\n    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"update\",\n            index: index, newValue: newValue, oldValue: oldValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"splice\",\n            index: index, removed: removed, added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    return ObservableArrayAdministration;\n}();\nvar ObservableArray = function (_super) {\n    __extends(ObservableArray, _super);\n    function ObservableArray(initialValues, enhancer, name, owned) {\n        if (name === void 0) {\n            name = \"ObservableArray@\" + getNextId();\n        }\n        if (owned === void 0) {\n            owned = false;\n        }\n        var _this = _super.call(this) || this;\n        var adm = new ObservableArrayAdministration(name, enhancer, _this, owned);\n        addHiddenFinalProp(_this, \"$mobx\", adm);\n        if (initialValues && initialValues.length) {\n            adm.updateArrayLength(0, initialValues.length);\n            adm.values = initialValues.map(function (v) {\n                return enhancer(v, undefined, name + \"[..]\");\n            });\n            adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY);\n        } else {\n            adm.values = [];\n        }\n        if (safariPrototypeSetterInheritanceBug) {\n            Object.defineProperty(adm.array, \"0\", ENTRY_0);\n        }\n        return _this;\n    }\n    ObservableArray.prototype.intercept = function (handler) {\n        return this.$mobx.intercept(handler);\n    };\n    ObservableArray.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        return this.$mobx.observe(listener, fireImmediately);\n    };\n    ObservableArray.prototype.clear = function () {\n        return this.splice(0);\n    };\n    ObservableArray.prototype.concat = function () {\n        var arrays = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            arrays[_i] = arguments[_i];\n        }\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) {\n            return isObservableArray(a) ? a.peek() : a;\n        }));\n    };\n    ObservableArray.prototype.replace = function (newItems) {\n        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);\n    };\n    ObservableArray.prototype.toJS = function () {\n        return this.slice();\n    };\n    ObservableArray.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableArray.prototype.peek = function () {\n        return this.$mobx.values;\n    };\n    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {\n        if (fromIndex === void 0) {\n            fromIndex = 0;\n        }\n        this.$mobx.atom.reportObserved();\n        var items = this.$mobx.values,\n            l = items.length;\n        for (var i = fromIndex; i < l; i++) {\n            if (predicate.call(thisArg, items[i], i, this)) return items[i];\n        }return undefined;\n    };\n    ObservableArray.prototype.splice = function (index, deleteCount) {\n        var newItems = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            newItems[_i - 2] = arguments[_i];\n        }\n        switch (arguments.length) {\n            case 0:\n                return [];\n            case 1:\n                return this.$mobx.spliceWithArray(index);\n            case 2:\n                return this.$mobx.spliceWithArray(index, deleteCount);\n        }\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.push = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(adm.values.length, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.pop = function () {\n        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];\n    };\n    ObservableArray.prototype.shift = function () {\n        return this.splice(0, 1)[0];\n    };\n    ObservableArray.prototype.unshift = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(0, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.reverse = function () {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.reverse.apply(clone, arguments);\n    };\n    ObservableArray.prototype.sort = function (compareFn) {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.sort.apply(clone, arguments);\n    };\n    ObservableArray.prototype.remove = function (value) {\n        var idx = this.$mobx.values.indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    };\n    ObservableArray.prototype.move = function (fromIndex, toIndex) {\n        function checkIndex(index) {\n            if (index < 0) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\n            }\n            var length = this.$mobx.values.length;\n            if (index >= length) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\n            }\n        }\n        checkIndex.call(this, fromIndex);\n        checkIndex.call(this, toIndex);\n        if (fromIndex === toIndex) {\n            return;\n        }\n        var oldItems = this.$mobx.values;\n        var newItems;\n        if (fromIndex < toIndex) {\n            newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1));\n        } else {\n            newItems = oldItems.slice(0, toIndex).concat([oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\n        }\n        this.replace(newItems);\n    };\n    ObservableArray.prototype.toString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toString.apply(this.$mobx.values, arguments);\n    };\n    ObservableArray.prototype.toLocaleString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toLocaleString.apply(this.$mobx.values, arguments);\n    };\n    return ObservableArray;\n}(StubArray);\ndeclareIterator(ObservableArray.prototype, function () {\n    return arrayAsIterator(this.slice());\n});\nmakeNonEnumerable(ObservableArray.prototype, [\"constructor\", \"intercept\", \"observe\", \"clear\", \"concat\", \"replace\", \"toJS\", \"toJSON\", \"peek\", \"find\", \"splice\", \"spliceWithArray\", \"push\", \"pop\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"remove\", \"move\", \"toString\", \"toLocaleString\"]);\nObject.defineProperty(ObservableArray.prototype, \"length\", {\n    enumerable: false,\n    configurable: true,\n    get: function get() {\n        return this.$mobx.getArrayLength();\n    },\n    set: function set(newLength) {\n        this.$mobx.setArrayLength(newLength);\n    }\n});\n[\"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function (funcName) {\n    var baseFunc = Array.prototype[funcName];\n    invariant(typeof baseFunc === \"function\", \"Base function not defined on Array prototype: '\" + funcName + \"'\");\n    addHiddenProp(ObservableArray.prototype, funcName, function () {\n        this.$mobx.atom.reportObserved();\n        return baseFunc.apply(this.$mobx.values, arguments);\n    });\n});\nvar ENTRY_0 = {\n    configurable: true,\n    enumerable: false,\n    set: createArraySetter(0),\n    get: createArrayGetter(0)\n};\nfunction createArrayBufferItem(index) {\n    var set = createArraySetter(index);\n    var get = createArrayGetter(index);\n    Object.defineProperty(ObservableArray.prototype, \"\" + index, {\n        enumerable: false,\n        configurable: true,\n        set: set, get: get\n    });\n}\nfunction createArraySetter(index) {\n    return function (newValue) {\n        var adm = this.$mobx;\n        var values = adm.values;\n        if (index < values.length) {\n            checkIfStateModificationsAreAllowed(adm.atom);\n            var oldValue = values[index];\n            if (hasInterceptors(adm)) {\n                var change = interceptChange(adm, {\n                    type: \"update\",\n                    object: adm.array,\n                    index: index, newValue: newValue\n                });\n                if (!change) return;\n                newValue = change.newValue;\n            }\n            newValue = adm.enhancer(newValue, oldValue);\n            var changed = newValue !== oldValue;\n            if (changed) {\n                values[index] = newValue;\n                adm.notifyArrayChildUpdate(index, newValue, oldValue);\n            }\n        } else if (index === values.length) {\n            adm.spliceWithArray(index, 0, [newValue]);\n        } else throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length);\n    };\n}\nfunction createArrayGetter(index) {\n    return function () {\n        var impl = this.$mobx;\n        if (impl) {\n            if (index < impl.values.length) {\n                impl.atom.reportObserved();\n                return impl.values[index];\n            }\n            console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\");\n        }\n        return undefined;\n    };\n}\nfunction reserveArrayBuffer(max) {\n    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) {\n        createArrayBufferItem(index);\n    }OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n}\nreserveArrayBuffer(1000);\nvar isObservableArrayAdministration = createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\nfunction isObservableArray(thing) {\n    return isObject(thing) && isObservableArrayAdministration(thing.$mobx);\n}\nexports.isObservableArray = isObservableArray;\nvar ObservableMapMarker = {};\nvar ObservableMap = function () {\n    function ObservableMap(initialData, enhancer, name) {\n        if (enhancer === void 0) {\n            enhancer = deepEnhancer;\n        }\n        if (name === void 0) {\n            name = \"ObservableMap@\" + getNextId();\n        }\n        this.enhancer = enhancer;\n        this.name = name;\n        this.$mobx = ObservableMapMarker;\n        this._data = {};\n        this._hasMap = {};\n        this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + \".keys()\", true);\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.merge(initialData);\n    }\n    ObservableMap.prototype._has = function (key) {\n        return typeof this._data[key] !== \"undefined\";\n    };\n    ObservableMap.prototype.has = function (key) {\n        if (!this.isValidKey(key)) return false;\n        key = \"\" + key;\n        if (this._hasMap[key]) return this._hasMap[key].get();\n        return this._updateHasMapEntry(key, false).get();\n    };\n    ObservableMap.prototype.set = function (key, value) {\n        this.assertValidKey(key);\n        key = \"\" + key;\n        var hasKey = this._has(key);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? \"update\" : \"add\",\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change) return this;\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this._updateValue(key, value);\n        } else {\n            this._addValue(key, value);\n        }\n        return this;\n    };\n    ObservableMap.prototype.delete = function (key) {\n        var _this = this;\n        this.assertValidKey(key);\n        key = \"\" + key;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: \"delete\",\n                object: this,\n                name: key\n            });\n            if (!change) return false;\n        }\n        if (this._has(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"delete\",\n                object: this,\n                oldValue: this._data[key].value,\n                name: key\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            runInTransaction(function () {\n                _this._keys.remove(key);\n                _this._updateHasMapEntry(key, false);\n                var observable = _this._data[key];\n                observable.setNewValue(undefined);\n                _this._data[key] = undefined;\n            });\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n            return true;\n        }\n        return false;\n    };\n    ObservableMap.prototype._updateHasMapEntry = function (key, value) {\n        var entry = this._hasMap[key];\n        if (entry) {\n            entry.setNewValue(value);\n        } else {\n            entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + \".\" + key + \"?\", false);\n        }\n        return entry;\n    };\n    ObservableMap.prototype._updateValue = function (name, newValue) {\n        var observable = this._data[name];\n        newValue = observable.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"update\",\n                object: this,\n                oldValue: observable.value,\n                name: name, newValue: newValue\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            observable.setNewValue(newValue);\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableMap.prototype._addValue = function (name, newValue) {\n        var _this = this;\n        runInTransaction(function () {\n            var observable = _this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + \".\" + name, false);\n            newValue = observable.value;\n            _this._updateHasMapEntry(name, true);\n            _this._keys.push(name);\n        });\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            type: \"add\",\n            object: this,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableMap.prototype.get = function (key) {\n        key = \"\" + key;\n        if (this.has(key)) return this._data[key].get();\n        return undefined;\n    };\n    ObservableMap.prototype.keys = function () {\n        return arrayAsIterator(this._keys.slice());\n    };\n    ObservableMap.prototype.values = function () {\n        return arrayAsIterator(this._keys.map(this.get, this));\n    };\n    ObservableMap.prototype.entries = function () {\n        var _this = this;\n        return arrayAsIterator(this._keys.map(function (key) {\n            return [key, _this.get(key)];\n        }));\n    };\n    ObservableMap.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        this.keys().forEach(function (key) {\n            return callback.call(thisArg, _this.get(key), key, _this);\n        });\n    };\n    ObservableMap.prototype.merge = function (other) {\n        var _this = this;\n        if (isObservableMap(other)) {\n            other = other.toJS();\n        }\n        runInTransaction(function () {\n            if (isPlainObject(other)) Object.keys(other).forEach(function (key) {\n                return _this.set(key, other[key]);\n            });else if (Array.isArray(other)) other.forEach(function (_a) {\n                var key = _a[0],\n                    value = _a[1];\n                return _this.set(key, value);\n            });else if (isES6Map(other)) other.forEach(function (value, key) {\n                return _this.set(key, value);\n            });else if (other !== null && other !== undefined) fail(\"Cannot initialize map from \" + other);\n        });\n        return this;\n    };\n    ObservableMap.prototype.clear = function () {\n        var _this = this;\n        runInTransaction(function () {\n            untracked(function () {\n                _this.keys().forEach(_this.delete, _this);\n            });\n        });\n    };\n    ObservableMap.prototype.replace = function (values) {\n        var _this = this;\n        runInTransaction(function () {\n            _this.clear();\n            _this.merge(values);\n        });\n        return this;\n    };\n    Object.defineProperty(ObservableMap.prototype, \"size\", {\n        get: function get() {\n            return this._keys.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObservableMap.prototype.toJS = function () {\n        var _this = this;\n        var res = {};\n        this.keys().forEach(function (key) {\n            return res[key] = _this.get(key);\n        });\n        return res;\n    };\n    ObservableMap.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableMap.prototype.isValidKey = function (key) {\n        if (key === null || key === undefined) return false;\n        if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"boolean\") return true;\n        return false;\n    };\n    ObservableMap.prototype.assertValidKey = function (key) {\n        if (!this.isValidKey(key)) throw new Error(\"[mobx.map] Invalid key: '\" + key + \"', only strings, numbers and booleans are accepted as key in observable maps.\");\n    };\n    ObservableMap.prototype.toString = function () {\n        var _this = this;\n        return this.name + \"[{ \" + this.keys().map(function (key) {\n            return key + \": \" + (\"\" + _this.get(key));\n        }).join(\", \") + \" }]\";\n    };\n    ObservableMap.prototype.observe = function (listener, fireImmediately) {\n        invariant(fireImmediately !== true, getMessage(\"m033\"));\n        return registerListener(this, listener);\n    };\n    ObservableMap.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableMap;\n}();\nexports.ObservableMap = ObservableMap;\ndeclareIterator(ObservableMap.prototype, function () {\n    return this.entries();\n});\nfunction map(initialValues) {\n    deprecated(\"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\");\n    return observable.map(initialValues);\n}\nexports.map = map;\nvar isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap);\nexports.isObservableMap = isObservableMap;\nvar ObservableObjectAdministration = function () {\n    function ObservableObjectAdministration(target, name) {\n        this.target = target;\n        this.name = name;\n        this.values = {};\n        this.changeListeners = null;\n        this.interceptors = null;\n    }\n    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {\n        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\");\n        return registerListener(this, callback);\n    };\n    ObservableObjectAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableObjectAdministration;\n}();\nfunction asObservableObject(target, name) {\n    if (isObservableObject(target)) return target.$mobx;\n    invariant(Object.isExtensible(target), getMessage(\"m035\"));\n    if (!isPlainObject(target)) name = (target.constructor.name || \"ObservableObject\") + \"@\" + getNextId();\n    if (!name) name = \"ObservableObject@\" + getNextId();\n    var adm = new ObservableObjectAdministration(target, name);\n    addHiddenFinalProp(target, \"$mobx\", adm);\n    return adm;\n}\nfunction defineObservablePropertyFromDescriptor(adm, propName, descriptor, defaultEnhancer) {\n    if (adm.values[propName]) {\n        invariant(\"value\" in descriptor, \"The property \" + propName + \" in \" + adm.name + \" is already observable, cannot redefine it as computed property\");\n        adm.target[propName] = descriptor.value;\n        return;\n    }\n    if (\"value\" in descriptor) {\n        if (isModifierDescriptor(descriptor.value)) {\n            var modifierDescriptor = descriptor.value;\n            defineObservableProperty(adm, propName, modifierDescriptor.initialValue, modifierDescriptor.enhancer);\n        } else if (isAction(descriptor.value) && descriptor.value.autoBind === true) {\n            defineBoundAction(adm.target, propName, descriptor.value.originalFn);\n        } else if (isComputedValue(descriptor.value)) {\n            defineComputedPropertyFromComputedValue(adm, propName, descriptor.value);\n        } else {\n            defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer);\n        }\n    } else {\n        defineComputedProperty(adm, propName, descriptor.get, descriptor.set, false, true);\n    }\n}\nfunction defineObservableProperty(adm, propName, newValue, enhancer) {\n    assertPropertyConfigurable(adm.target, propName);\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            object: adm.target,\n            name: propName,\n            type: \"add\",\n            newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    var observable = adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + \".\" + propName, false);\n    newValue = observable.value;\n    Object.defineProperty(adm.target, propName, generateObservablePropConfig(propName));\n    notifyPropertyAddition(adm, adm.target, propName, newValue);\n}\nfunction defineComputedProperty(adm, propName, getter, setter, compareStructural, asInstanceProperty) {\n    if (asInstanceProperty) assertPropertyConfigurable(adm.target, propName);\n    adm.values[propName] = new ComputedValue(getter, adm.target, compareStructural, adm.name + \".\" + propName, setter);\n    if (asInstanceProperty) {\n        Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n    }\n}\nfunction defineComputedPropertyFromComputedValue(adm, propName, computedValue) {\n    var name = adm.name + \".\" + propName;\n    computedValue.name = name;\n    if (!computedValue.scope) computedValue.scope = adm.target;\n    adm.values[propName] = computedValue;\n    Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n}\nvar observablePropertyConfigs = {};\nvar computedPropertyConfigs = {};\nfunction generateObservablePropConfig(propName) {\n    return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            setPropertyValue(this, propName, v);\n        }\n    });\n}\nfunction generateComputedPropConfig(propName) {\n    return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: false,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            return this.$mobx.values[propName].set(v);\n        }\n    });\n}\nfunction setPropertyValue(instance, name, newValue) {\n    var adm = instance.$mobx;\n    var observable = adm.values[name];\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            type: \"update\",\n            object: instance,\n            name: name, newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    newValue = observable.prepareNewValue(newValue);\n    if (newValue !== UNCHANGED) {\n        var notify = hasListeners(adm);\n        var notifySpy = isSpyEnabled();\n        var change = notify || notifySpy ? {\n            type: \"update\",\n            object: instance,\n            oldValue: observable.value,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        observable.setNewValue(newValue);\n        if (notify) notifyListeners(adm, change);\n        if (notifySpy) spyReportEnd();\n    }\n}\nfunction notifyPropertyAddition(adm, object, name, newValue) {\n    var notify = hasListeners(adm);\n    var notifySpy = isSpyEnabled();\n    var change = notify || notifySpy ? {\n        type: \"add\",\n        object: object, name: name, newValue: newValue\n    } : null;\n    if (notifySpy) spyReportStart(change);\n    if (notify) notifyListeners(adm, change);\n    if (notifySpy) spyReportEnd();\n}\nvar isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\nfunction isObservableObject(thing) {\n    if (isObject(thing)) {\n        runLazyInitializers(thing);\n        return isObservableObjectAdministration(thing.$mobx);\n    }\n    return false;\n}\nexports.isObservableObject = isObservableObject;\nvar UNCHANGED = {};\nvar ObservableValue = function (_super) {\n    __extends(ObservableValue, _super);\n    function ObservableValue(value, enhancer, name, notifySpy) {\n        if (name === void 0) {\n            name = \"ObservableValue@\" + getNextId();\n        }\n        if (notifySpy === void 0) {\n            notifySpy = true;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.enhancer = enhancer;\n        _this.hasUnreportedChange = false;\n        _this.value = enhancer(value, undefined, name);\n        if (notifySpy && isSpyEnabled()) {\n            spyReport({ type: \"create\", object: _this, newValue: _this.value });\n        }\n        return _this;\n    }\n    ObservableValue.prototype.set = function (newValue) {\n        var oldValue = this.value;\n        newValue = this.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if (notifySpy) {\n                spyReportStart({\n                    type: \"update\",\n                    object: this,\n                    newValue: newValue, oldValue: oldValue\n                });\n            }\n            this.setNewValue(newValue);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableValue.prototype.prepareNewValue = function (newValue) {\n        checkIfStateModificationsAreAllowed(this);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue });\n            if (!change) return UNCHANGED;\n            newValue = change.newValue;\n        }\n        newValue = this.enhancer(newValue, this.value, this.name);\n        return this.value !== newValue ? newValue : UNCHANGED;\n    };\n    ObservableValue.prototype.setNewValue = function (newValue) {\n        var oldValue = this.value;\n        this.value = newValue;\n        this.reportChanged();\n        if (hasListeners(this)) {\n            notifyListeners(this, {\n                type: \"update\",\n                object: this,\n                newValue: newValue,\n                oldValue: oldValue\n            });\n        }\n    };\n    ObservableValue.prototype.get = function () {\n        this.reportObserved();\n        return this.value;\n    };\n    ObservableValue.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableValue.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately) listener({\n            object: this,\n            type: \"update\",\n            newValue: this.value,\n            oldValue: undefined\n        });\n        return registerListener(this, listener);\n    };\n    ObservableValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ObservableValue.prototype.toString = function () {\n        return this.name + \"[\" + this.value + \"]\";\n    };\n    ObservableValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    return ObservableValue;\n}(BaseAtom);\nObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf;\nvar isObservableValue = createInstanceofPredicate(\"ObservableValue\", ObservableValue);\nexports.isBoxedObservable = isObservableValue;\nfunction getAtom(thing, property) {\n    if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            invariant(property === undefined, getMessage(\"m036\"));\n            return thing.$mobx.atom;\n        }\n        if (isObservableMap(thing)) {\n            var anyThing = thing;\n            if (property === undefined) return getAtom(anyThing._keys);\n            var observable_2 = anyThing._data[property] || anyThing._hasMap[property];\n            invariant(!!observable_2, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\");\n            return observable_2;\n        }\n        runLazyInitializers(thing);\n        if (isObservableObject(thing)) {\n            if (!property) return fail(\"please specify a property\");\n            var observable_3 = thing.$mobx.values[property];\n            invariant(!!observable_3, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\");\n            return observable_3;\n        }\n        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n            return thing;\n        }\n    } else if (typeof thing === \"function\") {\n        if (isReaction(thing.$mobx)) {\n            return thing.$mobx;\n        }\n    }\n    return fail(\"Cannot obtain atom from \" + thing);\n}\nfunction getAdministration(thing, property) {\n    invariant(thing, \"Expecting some object\");\n    if (property !== undefined) return getAdministration(getAtom(thing, property));\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;\n    if (isObservableMap(thing)) return thing;\n    runLazyInitializers(thing);\n    if (thing.$mobx) return thing.$mobx;\n    invariant(false, \"Cannot obtain administration from \" + thing);\n}\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing)) named = getAdministration(thing);else named = getAtom(thing);\n    return named.name;\n}\nfunction createClassPropertyDecorator(onInitialize, _get, _set, enumerable, allowCustomArguments) {\n    function classPropertyDecorator(target, key, descriptor, customArgs, argLen) {\n        if (argLen === void 0) {\n            argLen = 0;\n        }\n        invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\");\n        if (!descriptor) {\n            var newDescriptor = {\n                enumerable: enumerable,\n                configurable: true,\n                get: function get() {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {\n                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);\n                    } else {\n                        _set.call(this, key, v);\n                    }\n                }\n            };\n            if (arguments.length < 3 || arguments.length === 5 && argLen < 3) {\n                Object.defineProperty(target, key, newDescriptor);\n            }\n            return newDescriptor;\n        } else {\n            if (!hasOwnProperty(target, \"__mobxLazyInitializers\")) {\n                addHiddenProp(target, \"__mobxLazyInitializers\", target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice() || []);\n            }\n            var value_1 = descriptor.value,\n                initializer_1 = descriptor.initializer;\n            target.__mobxLazyInitializers.push(function (instance) {\n                onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor);\n            });\n            return {\n                enumerable: enumerable, configurable: true,\n                get: function get() {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    _set.call(this, key, v);\n                }\n            };\n        }\n    }\n    if (allowCustomArguments) {\n        return function () {\n            if (quacksLikeADecorator(arguments)) return classPropertyDecorator.apply(null, arguments);\n            var outerArgs = arguments;\n            var argLen = arguments.length;\n            return function (target, key, descriptor) {\n                return classPropertyDecorator(target, key, descriptor, outerArgs, argLen);\n            };\n        };\n    }\n    return classPropertyDecorator;\n}\nfunction typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {\n    if (!hasOwnProperty(instance, \"__mobxInitializedProps\")) addHiddenProp(instance, \"__mobxInitializedProps\", {});\n    instance.__mobxInitializedProps[key] = true;\n    onInitialize(instance, key, v, customArgs, baseDescriptor);\n}\nfunction runLazyInitializers(instance) {\n    if (instance.__mobxDidRunLazyInitializers === true) return;\n    if (instance.__mobxLazyInitializers) {\n        addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true);\n        instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) {\n            return initializer(instance);\n        });\n    }\n}\nfunction quacksLikeADecorator(args) {\n    return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\";\n}\nfunction iteratorSymbol() {\n    return typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n}\nvar IS_ITERATING_MARKER = \"__$$iterating\";\nfunction arrayAsIterator(array) {\n    invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\");\n    addHiddenFinalProp(array, IS_ITERATING_MARKER, true);\n    var idx = -1;\n    addHiddenFinalProp(array, \"next\", function next() {\n        idx++;\n        return {\n            done: idx >= this.length,\n            value: idx < this.length ? this[idx] : undefined\n        };\n    });\n    return array;\n}\nfunction declareIterator(prototType, iteratorFactory) {\n    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);\n}\nvar messages = {\n    \"m001\": \"It is not allowed to assign new values to @action fields\",\n    \"m002\": \"`runInAction` expects a function\",\n    \"m003\": \"`runInAction` expects a function without arguments\",\n    \"m004\": \"autorun expects a function\",\n    \"m005\": \"Warning: attempted to pass an action to autorun. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m006\": \"Warning: attempted to pass an action to autorunAsync. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m007\": \"reaction only accepts 2 or 3 arguments. If migrating from MobX 2, please provide an options object\",\n    \"m008\": \"wrapping reaction expression in `asReference` is no longer supported, use options object instead\",\n    \"m009\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\",\n    \"m010\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\",\n    \"m011\": \"First argument to `computed` should be an expression. If using computed as decorator, don't pass it arguments\",\n    \"m012\": \"computed takes one or two arguments if used as function\",\n    \"m013\": \"[mobx.expr] 'expr' should only be used inside other reactive functions.\",\n    \"m014\": \"extendObservable expected 2 or more arguments\",\n    \"m015\": \"extendObservable expects an object as first argument\",\n    \"m016\": \"extendObservable should not be used on maps, use map.merge instead\",\n    \"m017\": \"all arguments of extendObservable should be objects\",\n    \"m018\": \"extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540\",\n    \"m019\": \"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\",\n    \"m020\": \"modifiers can only be used for individual object properties\",\n    \"m021\": \"observable expects zero or one arguments\",\n    \"m022\": \"@observable can not be used on getters, use @computed instead\",\n    \"m023\": \"Using `transaction` is deprecated, use `runInAction` or `(@)action` instead.\",\n    \"m024\": \"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested its value.\",\n    \"m025\": \"whyRun can only be used on reactions and computed values\",\n    \"m026\": \"`action` can only be invoked on functions\",\n    \"m028\": \"It is not allowed to set `useStrict` when a derivation is running\",\n    \"m029\": \"INTERNAL ERROR only onBecomeUnobserved shouldn't be called twice in a row\",\n    \"m030a\": \"Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: \",\n    \"m030b\": \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: \",\n    \"m031\": \"Computed values are not allowed to not cause side effects by changing observables that are already being observed. Tried to modify: \",\n    \"m032\": \"* This computation is suspended (not in use by any reaction) and won't run automatically.\\n\tDidn't expect this computation to be suspended at this point?\\n\t  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n\t  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\",\n    \"m033\": \"`observe` doesn't support the fire immediately property for observable maps.\",\n    \"m034\": \"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\",\n    \"m035\": \"Cannot make the designated object observable; it is not extensible\",\n    \"m036\": \"It is not possible to get index atoms from arrays\",\n    \"m037\": \"Hi there! I'm sorry you have just run into an exception.\\nIf your debugger ends up here, know that some reaction (like the render() of an observer component, autorun or reaction)\\nthrew an exception and that mobx caught it, to avoid that it brings the rest of your application down.\\nThe original cause of the exception (the code that caused this reaction to run (again)), is still in the stack.\\n\\nHowever, more interesting is the actual stack trace of the error itself.\\nHopefully the error is an instanceof Error, because in that case you can inspect the original stack of the error from where it was thrown.\\nSee `error.stack` property, or press the very subtle \\\"(...)\\\" link you see near the console.error message that probably brought you here.\\nThat stack is more interesting than the stack of this console.error itself.\\n\\nIf the exception you see is an exception you created yourself, make sure to use `throw new Error(\\\"Oops\\\")` instead of `throw \\\"Oops\\\"`,\\nbecause the javascript environment will only preserve the original stack trace in the first form.\\n\\nYou can also make sure the debugger pauses the next time this very same exception is thrown by enabling \\\"Pause on caught exception\\\".\\n(Note that it might pause on many other, unrelated exception as well).\\n\\nIf that all doesn't help you out, feel free to open an issue https://github.com/mobxjs/mobx/issues!\\n\",\n    \"m038\": \"Missing items in this list?\\n    1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n    2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\"\n};\nfunction getMessage(id) {\n    return messages[id];\n}\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nfunction getGlobal() {\n    return global;\n}\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\nfunction fail(message, thing) {\n    invariant(false, message, thing);\n    throw \"X\";\n}\nfunction invariant(check, message, thing) {\n    if (!check) throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\"));\n}\nvar deprecatedMessages = [];\nfunction deprecated(msg) {\n    if (deprecatedMessages.indexOf(msg) !== -1) return false;\n    deprecatedMessages.push(msg);\n    console.error(\"[mobx] Deprecated: \" + msg);\n    return true;\n}\nfunction once(func) {\n    var invoked = false;\n    return function () {\n        if (invoked) return;\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function noop() {};\nfunction unique(list) {\n    var res = [];\n    list.forEach(function (item) {\n        if (res.indexOf(item) === -1) res.push(item);\n    });\n    return res;\n}\nfunction joinStrings(things, limit, separator) {\n    if (limit === void 0) {\n        limit = 100;\n    }\n    if (separator === void 0) {\n        separator = \" - \";\n    }\n    if (!things) return \"\";\n    var sliced = things.slice(0, limit);\n    return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\");\n}\nfunction isObject(value) {\n    return value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\";\n}\nfunction isPlainObject(value) {\n    if (value === null || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false;\n    var proto = Object.getPrototypeOf(value);\n    return proto === Object.prototype || proto === null;\n}\nfunction objectAssign() {\n    var res = arguments[0];\n    for (var i = 1, l = arguments.length; i < l; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n            if (hasOwnProperty(source, key)) {\n                res[key] = source[key];\n            }\n        }\n    }\n    return res;\n}\nfunction valueDidChange(compareStructural, oldValue, newValue) {\n    if (typeof oldValue === 'number' && isNaN(oldValue)) {\n        return typeof newValue !== 'number' || !isNaN(newValue);\n    }\n    return compareStructural ? !deepEqual(oldValue, newValue) : oldValue !== newValue;\n}\nvar prototypeHasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(object, propName) {\n    return prototypeHasOwnProperty.call(object, propName);\n}\nfunction makeNonEnumerable(object, propNames) {\n    for (var i = 0; i < propNames.length; i++) {\n        addHiddenProp(object, propNames[i], object[propNames[i]]);\n    }\n}\nfunction addHiddenProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\nfunction isPropertyConfigurable(object, prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(object, prop);\n    return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;\n}\nfunction assertPropertyConfigurable(object, prop) {\n    invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\");\n}\nfunction getEnumerableKeys(obj) {\n    var res = [];\n    for (var key in obj) {\n        res.push(key);\n    }return res;\n}\nfunction deepEqual(a, b) {\n    if (a === null && b === null) return true;\n    if (a === undefined && b === undefined) return true;\n    if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) !== \"object\") return a === b;\n    var aIsArray = isArrayLike(a);\n    var aIsMap = isMapLike(a);\n    if (aIsArray !== isArrayLike(b)) {\n        return false;\n    } else if (aIsMap !== isMapLike(b)) {\n        return false;\n    } else if (aIsArray) {\n        if (a.length !== b.length) return false;\n        for (var i = a.length - 1; i >= 0; i--) {\n            if (!deepEqual(a[i], b[i])) return false;\n        }return true;\n    } else if (aIsMap) {\n        if (a.size !== b.size) return false;\n        var equals_1 = true;\n        a.forEach(function (value, key) {\n            equals_1 = equals_1 && deepEqual(b.get(key), value);\n        });\n        return equals_1;\n    } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === \"object\" && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === \"object\") {\n        if (a === null || b === null) return false;\n        if (isMapLike(a) && isMapLike(b)) {\n            if (a.size !== b.size) return false;\n            return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries());\n        }\n        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length) return false;\n        for (var prop in a) {\n            if (!(prop in b)) return false;\n            if (!deepEqual(a[prop], b[prop])) return false;\n        }\n        return true;\n    }\n    return false;\n}\nfunction createInstanceofPredicate(name, clazz) {\n    var propName = \"isMobX\" + name;\n    clazz.prototype[propName] = true;\n    return function (x) {\n        return isObject(x) && x[propName] === true;\n    };\n}\nfunction isArrayLike(x) {\n    return Array.isArray(x) || isObservableArray(x);\n}\nexports.isArrayLike = isArrayLike;\nfunction isMapLike(x) {\n    return isES6Map(x) || isObservableMap(x);\n}\nfunction isES6Map(thing) {\n    if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map) return true;\n    return false;\n}\nfunction primitiveSymbol() {\n    return typeof Symbol === \"function\" && Symbol.toPrimitive || \"@@toPrimitive\";\n}\nfunction toPrimitive(value) {\n    return value === null ? null : (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? \"\" + value : value;\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _icons = __webpack_require__(6);\n\nvar _constants = __webpack_require__(0);\n\nfunction renderHeader(_ref, instance) {\n  var meta = _ref.meta,\n      user = _ref.user,\n      reactions = _ref.reactions;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-header-container';\n\n  var likeButton = document.createElement('span');\n  var likedReaction = reactions.find(function (reaction) {\n    return reaction.content === 'heart' && reaction.user.login === user.login;\n  });\n  likeButton.className = 'gitment-header-like-btn';\n  likeButton.innerHTML = '\\n    ' + _icons.heart + '\\n    ' + (likedReaction ? 'Unlike' : 'Like') + '\\n    ' + (meta.reactions && meta.reactions.heart ? ' \\u2022 <strong>' + meta.reactions.heart + '</strong> Liked' : '') + '\\n  ';\n\n  if (likedReaction) {\n    likeButton.classList.add('liked');\n    likeButton.onclick = function () {\n      return instance.unlike();\n    };\n  } else {\n    likeButton.classList.remove('liked');\n    likeButton.onclick = function () {\n      return instance.like();\n    };\n  }\n  container.appendChild(likeButton);\n\n  var commentsCount = document.createElement('span');\n  commentsCount.innerHTML = '\\n    ' + (meta.comments ? ' \\u2022 <strong>' + meta.comments + '</strong> Comments' : '') + '\\n  ';\n  container.appendChild(commentsCount);\n\n  var issueLink = document.createElement('a');\n  issueLink.className = 'gitment-header-issue-link';\n  issueLink.href = meta.html_url;\n  issueLink.target = '_blank';\n  issueLink.innerText = 'Issue Page';\n  container.appendChild(issueLink);\n\n  return container;\n}\n\nfunction renderComments(_ref2, instance) {\n  var meta = _ref2.meta,\n      comments = _ref2.comments,\n      commentReactions = _ref2.commentReactions,\n      currentPage = _ref2.currentPage,\n      user = _ref2.user,\n      error = _ref2.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-comments-container';\n\n  if (error) {\n    var errorBlock = document.createElement('div');\n    errorBlock.className = 'gitment-comments-error';\n\n    if (error === _constants.NOT_INITIALIZED_ERROR && user.login && user.login.toLowerCase() === instance.owner.toLowerCase()) {\n      var initHint = document.createElement('div');\n      var initButton = document.createElement('button');\n      initButton.className = 'gitment-comments-init-btn';\n      initButton.onclick = function () {\n        initButton.setAttribute('disabled', true);\n        instance.init().catch(function (e) {\n          initButton.removeAttribute('disabled');\n          alert(e);\n        });\n      };\n      initButton.innerText = 'Initialize Comments';\n      initHint.appendChild(initButton);\n      errorBlock.appendChild(initHint);\n    } else {\n      errorBlock.innerText = error;\n    }\n    container.appendChild(errorBlock);\n    return container;\n  } else if (comments === undefined) {\n    var loading = document.createElement('div');\n    loading.innerText = 'Loading comments...';\n    loading.className = 'gitment-comments-loading';\n    container.appendChild(loading);\n    return container;\n  } else if (!comments.length) {\n    var emptyBlock = document.createElement('div');\n    emptyBlock.className = 'gitment-comments-empty';\n    emptyBlock.innerText = 'No Comment Yet';\n    container.appendChild(emptyBlock);\n    return container;\n  }\n\n  var commentsList = document.createElement('ul');\n  commentsList.className = 'gitment-comments-list';\n\n  comments.forEach(function (comment) {\n    var createDate = new Date(comment.created_at);\n    var updateDate = new Date(comment.updated_at);\n    var commentItem = document.createElement('li');\n    commentItem.className = 'gitment-comment';\n    commentItem.innerHTML = '\\n      <a class=\"gitment-comment-avatar\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n        <img class=\"gitment-comment-avatar-img\" src=\"' + comment.user.avatar_url + '\"/>\\n      </a>\\n      <div class=\"gitment-comment-main\">\\n        <div class=\"gitment-comment-header\">\\n          <a class=\"gitment-comment-name\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n            ' + comment.user.login + '\\n          </a>\\n          commented on\\n          <span title=\"' + createDate + '\">' + createDate.toDateString() + '</span>\\n          ' + (createDate.toString() !== updateDate.toString() ? ' \\u2022 <span title=\"comment was edited at ' + updateDate + '\">edited</span>' : '') + '\\n          <div class=\"gitment-comment-like-btn\">' + _icons.heart + ' ' + (comment.reactions.heart || '') + '</div>\\n        </div>\\n        <div class=\"gitment-comment-body gitment-markdown\">' + comment.body_html + '</div>\\n      </div>\\n    ';\n    var likeButton = commentItem.querySelector('.gitment-comment-like-btn');\n    var likedReaction = commentReactions[comment.id] && commentReactions[comment.id].find(function (reaction) {\n      return reaction.content === 'heart' && reaction.user.login === user.login;\n    });\n    if (likedReaction) {\n      likeButton.classList.add('liked');\n      likeButton.onclick = function () {\n        return instance.unlikeAComment(comment.id);\n      };\n    } else {\n      likeButton.classList.remove('liked');\n      likeButton.onclick = function () {\n        return instance.likeAComment(comment.id);\n      };\n    }\n\n    // dirty\n    // use a blank image to trigger height calculating when element rendered\n    var imgTrigger = document.createElement('img');\n    var markdownBody = commentItem.querySelector('.gitment-comment-body');\n    imgTrigger.className = 'gitment-hidden';\n    imgTrigger.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    imgTrigger.onload = function () {\n      if (markdownBody.clientHeight > instance.maxCommentHeight) {\n        markdownBody.classList.add('gitment-comment-body-folded');\n        markdownBody.style.maxHeight = instance.maxCommentHeight + 'px';\n        markdownBody.title = 'Click to Expand';\n        markdownBody.onclick = function () {\n          markdownBody.classList.remove('gitment-comment-body-folded');\n          markdownBody.style.maxHeight = '';\n          markdownBody.title = '';\n          markdownBody.onclick = null;\n        };\n      }\n    };\n    commentItem.appendChild(imgTrigger);\n\n    commentsList.appendChild(commentItem);\n  });\n\n  container.appendChild(commentsList);\n\n  if (meta) {\n    var pageCount = Math.ceil(meta.comments / instance.perPage);\n    if (pageCount > 1) {\n      var pagination = document.createElement('ul');\n      pagination.className = 'gitment-comments-pagination';\n\n      if (currentPage > 1) {\n        var previousButton = document.createElement('li');\n        previousButton.className = 'gitment-comments-page-item';\n        previousButton.innerText = 'Previous';\n        previousButton.onclick = function () {\n          return instance.goto(currentPage - 1);\n        };\n        pagination.appendChild(previousButton);\n      }\n\n      var _loop = function _loop(i) {\n        var pageItem = document.createElement('li');\n        pageItem.className = 'gitment-comments-page-item';\n        pageItem.innerText = i;\n        pageItem.onclick = function () {\n          return instance.goto(i);\n        };\n        if (currentPage === i) pageItem.classList.add('gitment-selected');\n        pagination.appendChild(pageItem);\n      };\n\n      for (var i = 1; i <= pageCount; i++) {\n        _loop(i);\n      }\n\n      if (currentPage < pageCount) {\n        var nextButton = document.createElement('li');\n        nextButton.className = 'gitment-comments-page-item';\n        nextButton.innerText = 'Next';\n        nextButton.onclick = function () {\n          return instance.goto(currentPage + 1);\n        };\n        pagination.appendChild(nextButton);\n      }\n\n      container.appendChild(pagination);\n    }\n  }\n\n  return container;\n}\n\nfunction renderEditor(_ref3, instance) {\n  var user = _ref3.user,\n      error = _ref3.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-editor-container';\n\n  var shouldDisable = user.login && !error ? '' : 'disabled';\n  var disabledTip = user.login ? '' : 'Login to Comment';\n  container.innerHTML = '\\n      ' + (user.login ? '<a class=\"gitment-editor-avatar\" href=\"' + user.html_url + '\" target=\"_blank\">\\n            <img class=\"gitment-editor-avatar-img\" src=\"' + user.avatar_url + '\"/>\\n          </a>' : user.isLoggingIn ? '<div class=\"gitment-editor-avatar\">' + _icons.spinner + '</div>' : '<a class=\"gitment-editor-avatar\" href=\"' + instance.loginLink + '\" title=\"login with GitHub\">\\n              ' + _icons.github + '\\n            </a>') + '\\n    </a>\\n    <div class=\"gitment-editor-main\">\\n      <div class=\"gitment-editor-header\">\\n        <nav class=\"gitment-editor-tabs\">\\n          <button class=\"gitment-editor-tab gitment-selected\">Write</button>\\n          <button class=\"gitment-editor-tab\">Preview</button>\\n        </nav>\\n        <div class=\"gitment-editor-login\">\\n          ' + (user.login ? '<a class=\"gitment-editor-logout-link\">Logout</a>' : user.isLoggingIn ? 'Logging in...' : '<a class=\"gitment-editor-login-link\" href=\"' + instance.loginLink + '\">Login</a> with GitHub') + '\\n        </div>\\n      </div>\\n      <div class=\"gitment-editor-body\">\\n        <div class=\"gitment-editor-write-field\">\\n          <textarea placeholder=\"Leave a comment\" title=\"' + disabledTip + '\" ' + shouldDisable + '></textarea>\\n        </div>\\n        <div class=\"gitment-editor-preview-field gitment-hidden\">\\n          <div class=\"gitment-editor-preview gitment-markdown\"></div>\\n        </div>\\n      </div>\\n    </div>\\n    <div class=\"gitment-editor-footer\">\\n      <a class=\"gitment-editor-footer-tip\" href=\"https://guides.github.com/features/mastering-markdown/\" target=\"_blank\">\\n        Styling with Markdown is supported\\n      </a>\\n      <button class=\"gitment-editor-submit\" title=\"' + disabledTip + '\" ' + shouldDisable + '>Comment</button>\\n    </div>\\n  ';\n  if (user.login) {\n    container.querySelector('.gitment-editor-logout-link').onclick = function () {\n      return instance.logout();\n    };\n  }\n\n  var writeField = container.querySelector('.gitment-editor-write-field');\n  var previewField = container.querySelector('.gitment-editor-preview-field');\n\n  var textarea = writeField.querySelector('textarea');\n  textarea.oninput = function () {\n    textarea.style.height = 'auto';\n    var style = window.getComputedStyle(textarea, null);\n    var height = parseInt(style.height, 10);\n    var clientHeight = textarea.clientHeight;\n    var scrollHeight = textarea.scrollHeight;\n    if (clientHeight < scrollHeight) {\n      textarea.style.height = height + scrollHeight - clientHeight + 'px';\n    }\n  };\n\n  var _container$querySelec = container.querySelectorAll('.gitment-editor-tab'),\n      _container$querySelec2 = _slicedToArray(_container$querySelec, 2),\n      writeTab = _container$querySelec2[0],\n      previewTab = _container$querySelec2[1];\n\n  writeTab.onclick = function () {\n    writeTab.classList.add('gitment-selected');\n    previewTab.classList.remove('gitment-selected');\n    writeField.classList.remove('gitment-hidden');\n    previewField.classList.add('gitment-hidden');\n\n    textarea.focus();\n  };\n  previewTab.onclick = function () {\n    previewTab.classList.add('gitment-selected');\n    writeTab.classList.remove('gitment-selected');\n    previewField.classList.remove('gitment-hidden');\n    writeField.classList.add('gitment-hidden');\n\n    var preview = previewField.querySelector('.gitment-editor-preview');\n    var content = textarea.value.trim();\n    if (!content) {\n      preview.innerText = 'Nothing to preview';\n      return;\n    }\n\n    preview.innerText = 'Loading preview...';\n    instance.markdown(content).then(function (html) {\n      return preview.innerHTML = html;\n    });\n  };\n\n  var submitButton = container.querySelector('.gitment-editor-submit');\n  submitButton.onclick = function () {\n    submitButton.innerText = 'Submitting...';\n    submitButton.setAttribute('disabled', true);\n    instance.post(textarea.value.trim()).then(function (data) {\n      textarea.value = '';\n      textarea.style.height = 'auto';\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    }).catch(function (e) {\n      alert(e);\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    });\n  };\n\n  return container;\n}\n\nfunction renderFooter() {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-footer-container';\n  container.innerHTML = '\\n    Powered by\\n    <a class=\"gitment-footer-project-link\" href=\"https://github.com/imsun/gitment\" target=\"_blank\">\\n      Gitment\\n    </a>\\n  ';\n  return container;\n}\n\nfunction render(state, instance) {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-root-container';\n  container.appendChild(instance.renderHeader(state, instance));\n  container.appendChild(instance.renderComments(state, instance));\n  container.appendChild(instance.renderEditor(state, instance));\n  container.appendChild(instance.renderFooter(state, instance));\n  return container;\n}\n\nexports.default = { render: render, renderHeader: renderHeader, renderComments: renderComments, renderEditor: renderEditor, renderFooter: renderFooter };\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.http = exports.Query = exports.isString = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.getTargetContainer = getTargetContainer;\n\nvar _constants = __webpack_require__(0);\n\nvar isString = exports.isString = function isString(s) {\n  return toString.call(s) === '[object String]';\n};\n\nfunction getTargetContainer(container) {\n  var targetContainer = void 0;\n  if (container instanceof Element) {\n    targetContainer = container;\n  } else if (isString(container)) {\n    targetContainer = document.getElementById(container);\n  } else {\n    targetContainer = document.createElement('div');\n  }\n\n  return targetContainer;\n}\n\nvar Query = exports.Query = {\n  parse: function parse() {\n    var search = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.search;\n\n    if (!search) return {};\n    var queryString = search[0] === '?' ? search.substring(1) : search;\n    var query = {};\n    queryString.split('&').forEach(function (queryStr) {\n      var _queryStr$split = queryStr.split('='),\n          _queryStr$split2 = _slicedToArray(_queryStr$split, 2),\n          key = _queryStr$split2[0],\n          value = _queryStr$split2[1];\n\n      if (key) query[key] = value;\n    });\n\n    return query;\n  },\n  stringify: function stringify(query) {\n    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '?';\n\n    var queryString = Object.keys(query).map(function (key) {\n      return key + '=' + encodeURIComponent(query[key] || '');\n    }).join('&');\n    return queryString ? prefix + queryString : '';\n  }\n};\n\nfunction ajaxFactory(method) {\n  return function (apiPath) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://api.github.com';\n\n    var req = new XMLHttpRequest();\n    var token = localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n\n    var url = '' + base + apiPath;\n    var body = null;\n    if (method === 'GET' || method === 'DELETE') {\n      url += Query.stringify(data);\n    }\n\n    var p = new Promise(function (resolve, reject) {\n      req.addEventListener('load', function () {\n        var contentType = req.getResponseHeader('content-type');\n        var res = req.responseText;\n        if (!/json/.test(contentType)) {\n          resolve(res);\n          return;\n        }\n        var data = req.responseText ? JSON.parse(res) : {};\n        if (data.message) {\n          reject(new Error(data.message));\n        } else {\n          resolve(data);\n        }\n      });\n      req.addEventListener('error', function (error) {\n        return reject(error);\n      });\n    });\n    req.open(method, url, true);\n\n    req.setRequestHeader('Accept', 'application/vnd.github.squirrel-girl-preview, application/vnd.github.html+json');\n    if (token) {\n      req.setRequestHeader('Authorization', 'token ' + token);\n    }\n    if (method !== 'GET' && method !== 'DELETE') {\n      body = JSON.stringify(data);\n      req.setRequestHeader('Content-Type', 'application/json');\n    }\n\n    req.send(body);\n    return p;\n  };\n}\n\nvar http = exports.http = {\n  get: ajaxFactory('GET'),\n  post: ajaxFactory('POST'),\n  delete: ajaxFactory('DELETE'),\n  put: ajaxFactory('PUT')\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mobx = __webpack_require__(1);\n\nvar _constants = __webpack_require__(0);\n\nvar _utils = __webpack_require__(3);\n\nvar _default = __webpack_require__(2);\n\nvar _default2 = _interopRequireDefault(_default);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar scope = 'public_repo';\n\nfunction extendRenderer(instance, renderer) {\n  instance[renderer] = function (container) {\n    var targetContainer = (0, _utils.getTargetContainer)(container);\n    var render = instance.theme[renderer] || instance.defaultTheme[renderer];\n\n    (0, _mobx.autorun)(function () {\n      var e = render(instance.state, instance);\n      if (targetContainer.firstChild) {\n        targetContainer.replaceChild(e, targetContainer.firstChild);\n      } else {\n        targetContainer.appendChild(e);\n      }\n    });\n\n    return targetContainer;\n  };\n}\n\nvar Gitment = function () {\n  _createClass(Gitment, [{\n    key: 'accessToken',\n    get: function get() {\n      return localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n    },\n    set: function set(token) {\n      localStorage.setItem(_constants.LS_ACCESS_TOKEN_KEY, token);\n    }\n  }, {\n    key: 'loginLink',\n    get: function get() {\n      var oauthUri = 'https://github.com/login/oauth/authorize';\n      var redirect_uri = this.oauth.redirect_uri || window.location.href;\n\n      var oauthParams = Object.assign({\n        scope: scope,\n        redirect_uri: redirect_uri\n      }, this.oauth);\n\n      return '' + oauthUri + _utils.Query.stringify(oauthParams);\n    }\n  }]);\n\n  function Gitment() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Gitment);\n\n    this.defaultTheme = _default2.default;\n    this.useTheme(_default2.default);\n\n    Object.assign(this, {\n      id: window.location.href,\n      title: window.document.title,\n      link: window.location.href,\n      desc: '',\n      labels: [],\n      theme: _default2.default,\n      oauth: {},\n      perPage: 20,\n      maxCommentHeight: 250\n    }, options);\n\n    this.useTheme(this.theme);\n\n    var user = {};\n    try {\n      var userInfo = localStorage.getItem(_constants.LS_USER_KEY);\n      if (this.accessToken && userInfo) {\n        Object.assign(user, JSON.parse(userInfo), {\n          fromCache: true\n        });\n      }\n    } catch (e) {\n      localStorage.removeItem(_constants.LS_USER_KEY);\n    }\n\n    this.state = (0, _mobx.observable)({\n      user: user,\n      error: null,\n      meta: {},\n      comments: undefined,\n      reactions: [],\n      commentReactions: {},\n      currentPage: 1\n    });\n\n    var query = _utils.Query.parse();\n    if (query.code) {\n      var _oauth = this.oauth,\n          client_id = _oauth.client_id,\n          client_secret = _oauth.client_secret;\n\n      var code = query.code;\n      delete query.code;\n      var search = _utils.Query.stringify(query);\n      var replacedUrl = '' + window.location.origin + window.location.pathname + search + window.location.hash;\n      history.replaceState({}, '', replacedUrl);\n\n      Object.assign(this, {\n        id: replacedUrl,\n        link: replacedUrl\n      }, options);\n\n      this.state.user.isLoggingIn = true;\n      _utils.http.post('https://github.com/login/oauth/access_token', {\n        code: code,\n        client_id: client_id,\n        client_secret: client_secret\n      }, '').then(function (data) {\n        _this.accessToken = data.access_token;\n        _this.update();\n      }).catch(function (e) {\n        _this.state.user.isLoggingIn = false;\n        alert(e);\n      });\n    } else {\n      this.update();\n    }\n  }\n\n  _createClass(Gitment, [{\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      return this.createIssue().then(function () {\n        return _this2.loadComments();\n      }).then(function (comments) {\n        _this2.state.error = null;\n        return comments;\n      });\n    }\n  }, {\n    key: 'useTheme',\n    value: function useTheme() {\n      var _this3 = this;\n\n      var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this.theme = theme;\n\n      var renderers = Object.keys(this.theme);\n      renderers.forEach(function (renderer) {\n        return extendRenderer(_this3, renderer);\n      });\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var _this4 = this;\n\n      return Promise.all([this.loadMeta(), this.loadUserInfo()]).then(function () {\n        return Promise.all([_this4.loadComments().then(function () {\n          return _this4.loadCommentReactions();\n        }), _this4.loadReactions()]);\n      }).catch(function (e) {\n        return _this4.state.error = e;\n      });\n    }\n  }, {\n    key: 'markdown',\n    value: function markdown(text) {\n      return _utils.http.post('/markdown', {\n        text: text,\n        mode: 'gfm'\n      });\n    }\n  }, {\n    key: 'createIssue',\n    value: function createIssue() {\n      var _this5 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo,\n          title = this.title,\n          link = this.link,\n          desc = this.desc,\n          labels = this.labels;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues', {\n        title: title,\n        labels: labels.concat(['gitment', id]),\n        body: link + '\\n\\n' + desc\n      }).then(function (meta) {\n        _this5.state.meta = meta;\n        return meta;\n      });\n    }\n  }, {\n    key: 'getIssue',\n    value: function getIssue() {\n      if (this.state.meta.id) return Promise.resolve(this.state.meta);\n\n      return this.loadMeta();\n    }\n  }, {\n    key: 'post',\n    value: function post(body) {\n      var _this6 = this;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.post(issue.comments_url, { body: body }, '');\n      }).then(function (data) {\n        _this6.state.meta.comments++;\n        var pageCount = Math.ceil(_this6.state.meta.comments / _this6.perPage);\n        if (_this6.state.currentPage === pageCount) {\n          _this6.state.comments.push(data);\n        }\n        return data;\n      });\n    }\n  }, {\n    key: 'loadMeta',\n    value: function loadMeta() {\n      var _this7 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo;\n\n      return _utils.http.get('/repos/' + owner + '/' + repo + '/issues', {\n        creator: owner,\n        labels: id\n      }).then(function (issues) {\n        if (!issues.length) return Promise.reject(_constants.NOT_INITIALIZED_ERROR);\n        _this7.state.meta = issues[0];\n        return issues[0];\n      });\n    }\n  }, {\n    key: 'loadComments',\n    value: function loadComments() {\n      var _this8 = this;\n\n      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentPage;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.get(issue.comments_url, { page: page, per_page: _this8.perPage }, '');\n      }).then(function (comments) {\n        _this8.state.comments = comments;\n        return comments;\n      });\n    }\n  }, {\n    key: 'loadUserInfo',\n    value: function loadUserInfo() {\n      var _this9 = this;\n\n      if (!this.accessToken) {\n        this.logout();\n        return Promise.resolve({});\n      }\n\n      return _utils.http.get('/user').then(function (user) {\n        _this9.state.user = user;\n        localStorage.setItem(_constants.LS_USER_KEY, JSON.stringify(user));\n        return user;\n      });\n    }\n  }, {\n    key: 'loadReactions',\n    value: function loadReactions() {\n      var _this10 = this;\n\n      if (!this.accessToken) {\n        this.state.reactions = [];\n        return Promise.resolve([]);\n      }\n\n      return this.getIssue().then(function (issue) {\n        if (!issue.reactions.total_count) return [];\n        return _utils.http.get(issue.reactions.url, {}, '');\n      }).then(function (reactions) {\n        _this10.state.reactions = reactions;\n        return reactions;\n      });\n    }\n  }, {\n    key: 'loadCommentReactions',\n    value: function loadCommentReactions() {\n      var _this11 = this;\n\n      if (!this.accessToken) {\n        this.state.commentReactions = {};\n        return Promise.resolve([]);\n      }\n\n      var comments = this.state.comments;\n      var comentReactions = {};\n\n      return Promise.all(comments.map(function (comment) {\n        if (!comment.reactions.total_count) return [];\n\n        var owner = _this11.owner,\n            repo = _this11.repo;\n\n        return _utils.http.get('/repos/' + owner + '/' + repo + '/issues/comments/' + comment.id + '/reactions', {});\n      })).then(function (reactionsArray) {\n        comments.forEach(function (comment, index) {\n          comentReactions[comment.id] = reactionsArray[index];\n        });\n        _this11.state.commentReactions = comentReactions;\n\n        return comentReactions;\n      });\n    }\n  }, {\n    key: 'login',\n    value: function login() {\n      window.location.href = this.loginLink;\n    }\n  }, {\n    key: 'logout',\n    value: function logout() {\n      localStorage.removeItem(_constants.LS_ACCESS_TOKEN_KEY);\n      localStorage.removeItem(_constants.LS_USER_KEY);\n      this.state.user = {};\n    }\n  }, {\n    key: 'goto',\n    value: function goto(page) {\n      this.state.currentPage = page;\n      this.state.comments = undefined;\n      return this.loadComments(page);\n    }\n  }, {\n    key: 'like',\n    value: function like() {\n      var _this12 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/' + this.state.meta.number + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this12.state.reactions.push(reaction);\n        _this12.state.meta.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlike',\n    value: function unlike() {\n      var _this13 = this;\n\n      if (!this.accessToken) return Promise.reject();\n\n      var _state = this.state,\n          user = _state.user,\n          reactions = _state.reactions;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        _this13.state.meta.reactions.heart--;\n      });\n    }\n  }, {\n    key: 'likeAComment',\n    value: function likeAComment(commentId) {\n      var _this14 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/comments/' + commentId + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this14.state.commentReactions[commentId].push(reaction);\n        comment.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlikeAComment',\n    value: function unlikeAComment(commentId) {\n      if (!this.accessToken) return Promise.reject();\n\n      var reactions = this.state.commentReactions[commentId];\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n      var user = this.state.user;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        comment.reactions.heart--;\n      });\n    }\n  }]);\n\n  return Gitment;\n}();\n\nmodule.exports = Gitment;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Modified from https://github.com/evil-icons/evil-icons\n */\n\nvar close = exports.close = '<svg class=\"gitment-close-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M37.304 11.282l1.414 1.414-26.022 26.02-1.414-1.413z\"/><path d=\"M12.696 11.282l26.022 26.02-1.414 1.415-26.022-26.02z\"/></svg>';\nvar github = exports.github = '<svg class=\"gitment-github-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 10c-8.3 0-15 6.7-15 15 0 6.6 4.3 12.2 10.3 14.2.8.1 1-.3 1-.7v-2.6c-4.2.9-5.1-2-5.1-2-.7-1.7-1.7-2.2-1.7-2.2-1.4-.9.1-.9.1-.9 1.5.1 2.3 1.5 2.3 1.5 1.3 2.3 3.5 1.6 4.4 1.2.1-1 .5-1.6 1-2-3.3-.4-6.8-1.7-6.8-7.4 0-1.6.6-3 1.5-4-.2-.4-.7-1.9.1-4 0 0 1.3-.4 4.1 1.5 1.2-.3 2.5-.5 3.8-.5 1.3 0 2.6.2 3.8.5 2.9-1.9 4.1-1.5 4.1-1.5.8 2.1.3 3.6.1 4 1 1 1.5 2.4 1.5 4 0 5.8-3.5 7-6.8 7.4.5.5 1 1.4 1 2.8v4.1c0 .4.3.9 1 .7 6-2 10.2-7.6 10.2-14.2C40 16.7 33.3 10 25 10z\"/></svg>';\nvar heart = exports.heart = '<svg class=\"gitment-heart-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 39.7l-.6-.5C11.5 28.7 8 25 8 19c0-5 4-9 9-9 4.1 0 6.4 2.3 8 4.1 1.6-1.8 3.9-4.1 8-4.1 5 0 9 4 9 9 0 6-3.5 9.7-16.4 20.2l-.6.5zM17 12c-3.9 0-7 3.1-7 7 0 5.1 3.2 8.5 15 18.1 11.8-9.6 15-13 15-18.1 0-3.9-3.1-7-7-7-3.5 0-5.4 2.1-6.9 3.8L25 17.1l-1.1-1.3C22.4 14.1 20.5 12 17 12z\"/></svg>';\nvar spinner = exports.spinner = '<svg class=\"gitment-spinner-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 18c-.6 0-1-.4-1-1V9c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M25 42c-.6 0-1-.4-1-1v-8c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M29 19c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M17 39.8c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".93\" d=\"M21 19c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M33 39.8c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.1-.3.2-.5.2z\"/><path opacity=\".65\" d=\"M17 26H9c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".3\" d=\"M41 26h-8c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".86\" d=\"M18.1 21.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M38.9 33.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".44\" d=\"M11.1 33.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.1.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M31.9 21.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.2.2-.3.2-.5.2z\"/></svg>';\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=gitment.browser.js.map","source":"js/gitment.js","raw":"var Gitment =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar LS_ACCESS_TOKEN_KEY = exports.LS_ACCESS_TOKEN_KEY = 'gitment-comments-token';\nvar LS_USER_KEY = exports.LS_USER_KEY = 'gitment-user-info';\n\nvar NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = new Error('Comments Not Initialized');\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) {\n            if (b.hasOwnProperty(p)) d[p] = b[p];\n        }\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nregisterGlobals();\nexports.extras = {\n    allowStateChanges: allowStateChanges,\n    deepEqual: deepEqual,\n    getAtom: getAtom,\n    getDebugName: getDebugName,\n    getDependencyTree: getDependencyTree,\n    getAdministration: getAdministration,\n    getGlobalState: getGlobalState,\n    getObserverTree: getObserverTree,\n    isComputingDerivation: isComputingDerivation,\n    isSpyEnabled: isSpyEnabled,\n    onReactionError: onReactionError,\n    resetGlobalState: resetGlobalState,\n    shareGlobalState: shareGlobalState,\n    spyReport: spyReport,\n    spyReportEnd: spyReportEnd,\n    spyReportStart: spyReportStart,\n    setReactionScheduler: setReactionScheduler\n};\nif ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" ? \"undefined\" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === \"object\") {\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx(module.exports);\n}\nmodule.exports.default = module.exports;\nvar actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {\n    var actionName = args && args.length === 1 ? args[0] : value.name || key || \"<unnamed action>\";\n    var wrappedAction = action(actionName, value);\n    addHiddenProp(target, key, wrappedAction);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, true);\nvar boundActionDecorator = createClassPropertyDecorator(function (target, key, value) {\n    defineBoundAction(target, key, value);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, false);\nvar action = function action(arg1, arg2, arg3, arg4) {\n    if (arguments.length === 1 && typeof arg1 === \"function\") return createAction(arg1.name || \"<unnamed action>\", arg1);\n    if (arguments.length === 2 && typeof arg2 === \"function\") return createAction(arg1, arg2);\n    if (arguments.length === 1 && typeof arg1 === \"string\") return namedActionDecorator(arg1);\n    return namedActionDecorator(arg2).apply(null, arguments);\n};\nexports.action = action;\naction.bound = function boundAction(arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n        var action_1 = createAction(\"<not yet bound action>\", arg1);\n        action_1.autoBind = true;\n        return action_1;\n    }\n    return boundActionDecorator.apply(null, arguments);\n};\nfunction namedActionDecorator(name) {\n    return function (target, prop, descriptor) {\n        if (descriptor && typeof descriptor.value === \"function\") {\n            descriptor.value = createAction(name, descriptor.value);\n            descriptor.enumerable = false;\n            descriptor.configurable = true;\n            return descriptor;\n        }\n        return actionFieldDecorator(name).apply(this, arguments);\n    };\n}\nfunction runInAction(arg1, arg2, arg3) {\n    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action>\";\n    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\n    var scope = typeof arg1 === \"function\" ? arg2 : arg3;\n    invariant(typeof fn === \"function\", getMessage(\"m002\"));\n    invariant(fn.length === 0, getMessage(\"m003\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    return executeAction(actionName, fn, scope, undefined);\n}\nexports.runInAction = runInAction;\nfunction isAction(thing) {\n    return typeof thing === \"function\" && thing.isMobxAction === true;\n}\nexports.isAction = isAction;\nfunction defineBoundAction(target, propertyName, fn) {\n    var res = function res() {\n        return executeAction(propertyName, fn, target, arguments);\n    };\n    res.isMobxAction = true;\n    addHiddenProp(target, propertyName, res);\n}\nfunction autorun(arg1, arg2, arg3) {\n    var name, view, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        view = arg2;\n        scope = arg3;\n    } else {\n        name = arg1.name || \"Autorun@\" + getNextId();\n        view = arg1;\n        scope = arg2;\n    }\n    invariant(typeof view === \"function\", getMessage(\"m004\"));\n    invariant(isAction(view) === false, getMessage(\"m005\"));\n    if (scope) view = view.bind(scope);\n    var reaction = new Reaction(name, function () {\n        this.track(reactionRunner);\n    });\n    function reactionRunner() {\n        view(reaction);\n    }\n    reaction.schedule();\n    return reaction.getDisposer();\n}\nexports.autorun = autorun;\nfunction when(arg1, arg2, arg3, arg4) {\n    var name, predicate, effect, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        predicate = arg2;\n        effect = arg3;\n        scope = arg4;\n    } else {\n        name = \"When@\" + getNextId();\n        predicate = arg1;\n        effect = arg2;\n        scope = arg3;\n    }\n    var disposer = autorun(name, function (r) {\n        if (predicate.call(scope)) {\n            r.dispose();\n            var prevUntracked = untrackedStart();\n            effect.call(scope);\n            untrackedEnd(prevUntracked);\n        }\n    });\n    return disposer;\n}\nexports.when = when;\nfunction autorunAsync(arg1, arg2, arg3, arg4) {\n    var name, func, delay, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        func = arg2;\n        delay = arg3;\n        scope = arg4;\n    } else {\n        name = arg1.name || \"AutorunAsync@\" + getNextId();\n        func = arg1;\n        delay = arg2;\n        scope = arg3;\n    }\n    invariant(isAction(func) === false, getMessage(\"m006\"));\n    if (delay === void 0) delay = 1;\n    if (scope) func = func.bind(scope);\n    var isScheduled = false;\n    var r = new Reaction(name, function () {\n        if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                if (!r.isDisposed) r.track(reactionRunner);\n            }, delay);\n        }\n    });\n    function reactionRunner() {\n        func(r);\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.autorunAsync = autorunAsync;\nfunction reaction(expression, effect, arg3) {\n    if (arguments.length > 3) {\n        fail(getMessage(\"m007\"));\n    }\n    if (isModifierDescriptor(expression)) {\n        fail(getMessage(\"m008\"));\n    }\n    var opts;\n    if ((typeof arg3 === \"undefined\" ? \"undefined\" : _typeof(arg3)) === \"object\") {\n        opts = arg3;\n    } else {\n        opts = {};\n    }\n    opts.name = opts.name || expression.name || effect.name || \"Reaction@\" + getNextId();\n    opts.fireImmediately = arg3 === true || opts.fireImmediately === true;\n    opts.delay = opts.delay || 0;\n    opts.compareStructural = opts.compareStructural || opts.struct || false;\n    effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect);\n    if (opts.context) {\n        expression = expression.bind(opts.context);\n    }\n    var firstTime = true;\n    var isScheduled = false;\n    var nextValue;\n    var r = new Reaction(opts.name, function () {\n        if (firstTime || opts.delay < 1) {\n            reactionRunner();\n        } else if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                reactionRunner();\n            }, opts.delay);\n        }\n    });\n    function reactionRunner() {\n        if (r.isDisposed) return;\n        var changed = false;\n        r.track(function () {\n            var v = expression(r);\n            changed = valueDidChange(opts.compareStructural, nextValue, v);\n            nextValue = v;\n        });\n        if (firstTime && opts.fireImmediately) effect(nextValue, r);\n        if (!firstTime && changed === true) effect(nextValue, r);\n        if (firstTime) firstTime = false;\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.reaction = reaction;\nfunction createComputedDecorator(compareStructural) {\n    return createClassPropertyDecorator(function (target, name, _, __, originalDescriptor) {\n        invariant(typeof originalDescriptor !== \"undefined\", getMessage(\"m009\"));\n        invariant(typeof originalDescriptor.get === \"function\", getMessage(\"m010\"));\n        var adm = asObservableObject(target, \"\");\n        defineComputedProperty(adm, name, originalDescriptor.get, originalDescriptor.set, compareStructural, false);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        this.$mobx.values[name].set(value);\n    }, false, false);\n}\nvar computedDecorator = createComputedDecorator(false);\nvar computedStructDecorator = createComputedDecorator(true);\nvar computed = function computed(arg1, arg2, arg3) {\n    if (typeof arg2 === \"string\") {\n        return computedDecorator.apply(null, arguments);\n    }\n    invariant(typeof arg1 === \"function\", getMessage(\"m011\"));\n    invariant(arguments.length < 3, getMessage(\"m012\"));\n    var opts = (typeof arg2 === \"undefined\" ? \"undefined\" : _typeof(arg2)) === \"object\" ? arg2 : {};\n    opts.setter = typeof arg2 === \"function\" ? arg2 : opts.setter;\n    return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || \"\", opts.setter);\n};\nexports.computed = computed;\ncomputed.struct = computedStructDecorator;\nfunction createTransformer(transformer, onCleanup) {\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\n    var objectCache = {};\n    var resetId = globalState.resetId;\n    var Transformer = function (_super) {\n        __extends(Transformer, _super);\n        function Transformer(sourceIdentifier, sourceObject) {\n            var _this = _super.call(this, function () {\n                return transformer(sourceObject);\n            }, undefined, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier, undefined) || this;\n            _this.sourceIdentifier = sourceIdentifier;\n            _this.sourceObject = sourceObject;\n            return _this;\n        }\n        Transformer.prototype.onBecomeUnobserved = function () {\n            var lastValue = this.value;\n            _super.prototype.onBecomeUnobserved.call(this);\n            delete objectCache[this.sourceIdentifier];\n            if (onCleanup) onCleanup(lastValue, this.sourceObject);\n        };\n        return Transformer;\n    }(ComputedValue);\n    return function (object) {\n        if (resetId !== globalState.resetId) {\n            objectCache = {};\n            resetId = globalState.resetId;\n        }\n        var identifier = getMemoizationId(object);\n        var reactiveTransformer = objectCache[identifier];\n        if (reactiveTransformer) return reactiveTransformer.get();\n        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);\n        return reactiveTransformer.get();\n    };\n}\nexports.createTransformer = createTransformer;\nfunction getMemoizationId(object) {\n    if (object === null || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") throw new Error(\"[mobx] transform expected some kind of object, got: \" + object);\n    var tid = object.$transformId;\n    if (tid === undefined) {\n        tid = getNextId();\n        addHiddenProp(object, \"$transformId\", tid);\n    }\n    return tid;\n}\nfunction expr(expr, scope) {\n    if (!isComputingDerivation()) console.warn(getMessage(\"m013\"));\n    return computed(expr, { context: scope }).get();\n}\nexports.expr = expr;\nfunction extendObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, deepEnhancer, properties);\n}\nexports.extendObservable = extendObservable;\nfunction extendShallowObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, referenceEnhancer, properties);\n}\nexports.extendShallowObservable = extendShallowObservable;\nfunction extendObservableHelper(target, defaultEnhancer, properties) {\n    invariant(arguments.length >= 2, getMessage(\"m014\"));\n    invariant((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\", getMessage(\"m015\"));\n    invariant(!isObservableMap(target), getMessage(\"m016\"));\n    properties.forEach(function (propSet) {\n        invariant((typeof propSet === \"undefined\" ? \"undefined\" : _typeof(propSet)) === \"object\", getMessage(\"m017\"));\n        invariant(!isObservable(propSet), getMessage(\"m018\"));\n    });\n    var adm = asObservableObject(target);\n    var definedProps = {};\n    for (var i = properties.length - 1; i >= 0; i--) {\n        var propSet = properties[i];\n        for (var key in propSet) {\n            if (definedProps[key] !== true && hasOwnProperty(propSet, key)) {\n                definedProps[key] = true;\n                if (target === propSet && !isPropertyConfigurable(target, key)) continue;\n                var descriptor = Object.getOwnPropertyDescriptor(propSet, key);\n                defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer);\n            }\n        }\n    }\n    return target;\n}\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree);\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (hasObservers(node)) result.observers = getObservers(node).map(nodeToObserverTree);\n    return result;\n}\nfunction intercept(thing, propOrHandler, handler) {\n    if (typeof handler === \"function\") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);\n}\nexports.intercept = intercept;\nfunction interceptInterceptable(thing, handler) {\n    return getAdministration(thing).intercept(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    return getAdministration(thing, property).intercept(handler);\n}\nfunction isComputed(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableObject(value) === false) return false;\n        var atom = getAtom(value, property);\n        return isComputedValue(atom);\n    }\n    return isComputedValue(value);\n}\nexports.isComputed = isComputed;\nfunction isObservable(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableArray(value) || isObservableMap(value)) throw new Error(getMessage(\"m019\"));else if (isObservableObject(value)) {\n            var o = value.$mobx;\n            return o.values && !!o.values[property];\n        }\n        return false;\n    }\n    return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value);\n}\nexports.isObservable = isObservable;\nvar deepDecorator = createDecoratorForEnhancer(deepEnhancer);\nvar shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);\nvar refDecorator = createDecoratorForEnhancer(referenceEnhancer);\nvar deepStructDecorator = createDecoratorForEnhancer(deepStructEnhancer);\nvar refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);\nfunction createObservable(v) {\n    if (v === void 0) {\n        v = undefined;\n    }\n    if (typeof arguments[1] === \"string\") return deepDecorator.apply(null, arguments);\n    invariant(arguments.length <= 1, getMessage(\"m021\"));\n    invariant(!isModifierDescriptor(v), getMessage(\"m020\"));\n    if (isObservable(v)) return v;\n    var res = deepEnhancer(v, undefined, undefined);\n    if (res !== v) return res;\n    return observable.box(v);\n}\nvar IObservableFactories = function () {\n    function IObservableFactories() {}\n    IObservableFactories.prototype.box = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"box\");\n        return new ObservableValue(value, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowBox = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowBox\");\n        return new ObservableValue(value, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.array = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"array\");\n        return new ObservableArray(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowArray = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowArray\");\n        return new ObservableArray(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.map = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"map\");\n        return new ObservableMap(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowMap = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowMap\");\n        return new ObservableMap(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.object = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"object\");\n        var res = {};\n        asObservableObject(res, name);\n        extendObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.shallowObject = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowObject\");\n        var res = {};\n        asObservableObject(res, name);\n        extendShallowObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.ref = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(referenceEnhancer, arguments[0]);\n        } else {\n            return refDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.shallow = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(shallowEnhancer, arguments[0]);\n        } else {\n            return shallowDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.deep = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepEnhancer, arguments[0]);\n        } else {\n            return deepDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.struct = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepStructEnhancer, arguments[0]);\n        } else {\n            return deepStructDecorator.apply(null, arguments);\n        }\n    };\n    return IObservableFactories;\n}();\nexports.IObservableFactories = IObservableFactories;\nvar observable = createObservable;\nexports.observable = observable;\nObject.keys(IObservableFactories.prototype).forEach(function (key) {\n    return observable[key] = IObservableFactories.prototype[key];\n});\nobservable.deep.struct = observable.struct;\nobservable.ref.struct = function () {\n    if (arguments.length < 2) {\n        return createModifierDescriptor(refStructEnhancer, arguments[0]);\n    } else {\n        return refStructDecorator.apply(null, arguments);\n    }\n};\nfunction incorrectlyUsedAsDecorator(methodName) {\n    fail(\"Expected one or two arguments to observable.\" + methodName + \". Did you accidentally try to use observable.\" + methodName + \" as decorator?\");\n}\nfunction createDecoratorForEnhancer(enhancer) {\n    invariant(!!enhancer, \":(\");\n    return createClassPropertyDecorator(function (target, name, baseValue, _, baseDescriptor) {\n        assertPropertyConfigurable(target, name);\n        invariant(!baseDescriptor || !baseDescriptor.get, getMessage(\"m022\"));\n        var adm = asObservableObject(target, undefined);\n        defineObservableProperty(adm, name, baseValue, enhancer);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        setPropertyValue(this, name, value);\n    }, true, false);\n}\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (typeof cbOrFire === \"function\") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);\n}\nexports.observe = observe;\nfunction observeObservable(thing, listener, fireImmediately) {\n    return getAdministration(thing).observe(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    return getAdministration(thing, property).observe(listener, fireImmediately);\n}\nfunction toJS(source, detectCycles, __alreadySeen) {\n    if (detectCycles === void 0) {\n        detectCycles = true;\n    }\n    if (__alreadySeen === void 0) {\n        __alreadySeen = [];\n    }\n    function cache(value) {\n        if (detectCycles) __alreadySeen.push([source, value]);\n        return value;\n    }\n    if (isObservable(source)) {\n        if (detectCycles && __alreadySeen === null) __alreadySeen = [];\n        if (detectCycles && source !== null && (typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") {\n            for (var i = 0, l = __alreadySeen.length; i < l; i++) {\n                if (__alreadySeen[i][0] === source) return __alreadySeen[i][1];\n            }\n        }\n        if (isObservableArray(source)) {\n            var res = cache([]);\n            var toAdd = source.map(function (value) {\n                return toJS(value, detectCycles, __alreadySeen);\n            });\n            res.length = toAdd.length;\n            for (var i = 0, l = toAdd.length; i < l; i++) {\n                res[i] = toAdd[i];\n            }return res;\n        }\n        if (isObservableObject(source)) {\n            var res = cache({});\n            for (var key in source) {\n                res[key] = toJS(source[key], detectCycles, __alreadySeen);\n            }return res;\n        }\n        if (isObservableMap(source)) {\n            var res_1 = cache({});\n            source.forEach(function (value, key) {\n                return res_1[key] = toJS(value, detectCycles, __alreadySeen);\n            });\n            return res_1;\n        }\n        if (isObservableValue(source)) return toJS(source.get(), detectCycles, __alreadySeen);\n    }\n    return source;\n}\nexports.toJS = toJS;\nfunction transaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    deprecated(getMessage(\"m023\"));\n    return runInTransaction.apply(undefined, arguments);\n}\nexports.transaction = transaction;\nfunction runInTransaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    return executeAction(\"\", action);\n}\nfunction log(msg) {\n    console.log(msg);\n    return msg;\n}\nfunction whyRun(thing, prop) {\n    switch (arguments.length) {\n        case 0:\n            thing = globalState.trackingDerivation;\n            if (!thing) return log(getMessage(\"m024\"));\n            break;\n        case 2:\n            thing = getAtom(thing, prop);\n            break;\n    }\n    thing = getAtom(thing);\n    if (isComputedValue(thing)) return log(thing.whyRun());else if (isReaction(thing)) return log(thing.whyRun());\n    return fail(getMessage(\"m025\"));\n}\nexports.whyRun = whyRun;\nfunction createAction(actionName, fn) {\n    invariant(typeof fn === \"function\", getMessage(\"m026\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    var res = function res() {\n        return executeAction(actionName, fn, this, arguments);\n    };\n    res.originalFn = fn;\n    res.isMobxAction = true;\n    return res;\n}\nfunction executeAction(actionName, fn, scope, args) {\n    var runInfo = startAction(actionName, fn, scope, args);\n    try {\n        return fn.apply(scope, args);\n    } finally {\n        endAction(runInfo);\n    }\n}\nfunction startAction(actionName, fn, scope, args) {\n    var notifySpy = isSpyEnabled() && !!actionName;\n    var startTime = 0;\n    if (notifySpy) {\n        startTime = Date.now();\n        var l = args && args.length || 0;\n        var flattendArgs = new Array(l);\n        if (l > 0) for (var i = 0; i < l; i++) {\n            flattendArgs[i] = args[i];\n        }spyReportStart({\n            type: \"action\",\n            name: actionName,\n            fn: fn,\n            object: scope,\n            arguments: flattendArgs\n        });\n    }\n    var prevDerivation = untrackedStart();\n    startBatch();\n    var prevAllowStateChanges = allowStateChangesStart(true);\n    return {\n        prevDerivation: prevDerivation,\n        prevAllowStateChanges: prevAllowStateChanges,\n        notifySpy: notifySpy,\n        startTime: startTime\n    };\n}\nfunction endAction(runInfo) {\n    allowStateChangesEnd(runInfo.prevAllowStateChanges);\n    endBatch();\n    untrackedEnd(runInfo.prevDerivation);\n    if (runInfo.notifySpy) spyReportEnd({ time: Date.now() - runInfo.startTime });\n}\nfunction useStrict(strict) {\n    invariant(globalState.trackingDerivation === null, getMessage(\"m028\"));\n    globalState.strictMode = strict;\n    globalState.allowStateChanges = !strict;\n}\nexports.useStrict = useStrict;\nfunction isStrictModeEnabled() {\n    return globalState.strictMode;\n}\nexports.isStrictModeEnabled = isStrictModeEnabled;\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    var res;\n    try {\n        res = func();\n    } finally {\n        allowStateChangesEnd(prev);\n    }\n    return res;\n}\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nvar BaseAtom = function () {\n    function BaseAtom(name) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        this.name = name;\n        this.isPendingUnobservation = true;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.NOT_TRACKING;\n    }\n    BaseAtom.prototype.onBecomeUnobserved = function () {};\n    BaseAtom.prototype.reportObserved = function () {\n        reportObserved(this);\n    };\n    BaseAtom.prototype.reportChanged = function () {\n        startBatch();\n        propagateChanged(this);\n        endBatch();\n    };\n    BaseAtom.prototype.toString = function () {\n        return this.name;\n    };\n    return BaseAtom;\n}();\nexports.BaseAtom = BaseAtom;\nvar Atom = function (_super) {\n    __extends(Atom, _super);\n    function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        if (onBecomeObservedHandler === void 0) {\n            onBecomeObservedHandler = noop;\n        }\n        if (onBecomeUnobservedHandler === void 0) {\n            onBecomeUnobservedHandler = noop;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.name = name;\n        _this.onBecomeObservedHandler = onBecomeObservedHandler;\n        _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;\n        _this.isPendingUnobservation = false;\n        _this.isBeingTracked = false;\n        return _this;\n    }\n    Atom.prototype.reportObserved = function () {\n        startBatch();\n        _super.prototype.reportObserved.call(this);\n        if (!this.isBeingTracked) {\n            this.isBeingTracked = true;\n            this.onBecomeObservedHandler();\n        }\n        endBatch();\n        return !!globalState.trackingDerivation;\n    };\n    Atom.prototype.onBecomeUnobserved = function () {\n        this.isBeingTracked = false;\n        this.onBecomeUnobservedHandler();\n    };\n    return Atom;\n}(BaseAtom);\nexports.Atom = Atom;\nvar isAtom = createInstanceofPredicate(\"Atom\", BaseAtom);\nvar ComputedValue = function () {\n    function ComputedValue(derivation, scope, compareStructural, name, setter) {\n        this.derivation = derivation;\n        this.scope = scope;\n        this.compareStructural = compareStructural;\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.observing = [];\n        this.newObserving = null;\n        this.isPendingUnobservation = false;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.runId = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.UP_TO_DATE;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.value = undefined;\n        this.isComputing = false;\n        this.isRunningSetter = false;\n        this.name = name || \"ComputedValue@\" + getNextId();\n        if (setter) this.setter = createAction(name + \"-setter\", setter);\n    }\n    ComputedValue.prototype.onBecomeStale = function () {\n        propagateMaybeChanged(this);\n    };\n    ComputedValue.prototype.onBecomeUnobserved = function () {\n        invariant(this.dependenciesState !== IDerivationState.NOT_TRACKING, getMessage(\"m029\"));\n        clearObserving(this);\n        this.value = undefined;\n    };\n    ComputedValue.prototype.get = function () {\n        invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation);\n        if (globalState.inBatch === 0) {\n            startBatch();\n            if (shouldCompute(this)) this.value = this.computeValue(false);\n            endBatch();\n        } else {\n            reportObserved(this);\n            if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this);\n        }\n        var result = this.value;\n        if (isCaughtException(result)) throw result.cause;\n        return result;\n    };\n    ComputedValue.prototype.peek = function () {\n        var res = this.computeValue(false);\n        if (isCaughtException(res)) throw res.cause;\n        return res;\n    };\n    ComputedValue.prototype.set = function (value) {\n        if (this.setter) {\n            invariant(!this.isRunningSetter, \"The setter of computed value '\" + this.name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\");\n            this.isRunningSetter = true;\n            try {\n                this.setter.call(this.scope, value);\n            } finally {\n                this.isRunningSetter = false;\n            }\n        } else invariant(false, \"[ComputedValue '\" + this.name + \"'] It is not possible to assign a new value to a computed value.\");\n    };\n    ComputedValue.prototype.trackAndCompute = function () {\n        if (isSpyEnabled()) {\n            spyReport({\n                object: this.scope,\n                type: \"compute\",\n                fn: this.derivation\n            });\n        }\n        var oldValue = this.value;\n        var newValue = this.value = this.computeValue(true);\n        return isCaughtException(newValue) || valueDidChange(this.compareStructural, newValue, oldValue);\n    };\n    ComputedValue.prototype.computeValue = function (track) {\n        this.isComputing = true;\n        globalState.computationDepth++;\n        var res;\n        if (track) {\n            res = trackDerivedFunction(this, this.derivation, this.scope);\n        } else {\n            try {\n                res = this.derivation.call(this.scope);\n            } catch (e) {\n                res = new CaughtException(e);\n            }\n        }\n        globalState.computationDepth--;\n        this.isComputing = false;\n        return res;\n    };\n    ;\n    ComputedValue.prototype.observe = function (listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function () {\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener({\n                    type: \"update\",\n                    object: _this,\n                    newValue: newValue,\n                    oldValue: prevValue\n                });\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    ComputedValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ComputedValue.prototype.toString = function () {\n        return this.name + \"[\" + this.derivation.toString() + \"]\";\n    };\n    ComputedValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    ;\n    ComputedValue.prototype.whyRun = function () {\n        var isTracking = Boolean(globalState.trackingDerivation);\n        var observing = unique(this.isComputing ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        var observers = unique(getObservers(this).map(function (dep) {\n            return dep.name;\n        }));\n        return \"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + (isTracking ? \"[active] the value of this computation is needed by a reaction\" : this.isComputing ? \"[get] The value of this computed was requested outside a reaction\" : \"[idle] not running at the moment\") + \"\\n\" + (this.dependenciesState === IDerivationState.NOT_TRACKING ? getMessage(\"m032\") : \" * This computation will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this.isComputing && isTracking ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\\n  * If the outcome of this computation changes, the following observers will be re-run:\\n    \" + joinStrings(observers) + \"\\n\");\n    };\n    return ComputedValue;\n}();\nComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf;\nvar isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue);\nvar IDerivationState;\n(function (IDerivationState) {\n    IDerivationState[IDerivationState[\"NOT_TRACKING\"] = -1] = \"NOT_TRACKING\";\n    IDerivationState[IDerivationState[\"UP_TO_DATE\"] = 0] = \"UP_TO_DATE\";\n    IDerivationState[IDerivationState[\"POSSIBLY_STALE\"] = 1] = \"POSSIBLY_STALE\";\n    IDerivationState[IDerivationState[\"STALE\"] = 2] = \"STALE\";\n})(IDerivationState || (IDerivationState = {}));\nexports.IDerivationState = IDerivationState;\nvar CaughtException = function () {\n    function CaughtException(cause) {\n        this.cause = cause;\n    }\n    return CaughtException;\n}();\nfunction isCaughtException(e) {\n    return e instanceof CaughtException;\n}\nfunction shouldCompute(derivation) {\n    switch (derivation.dependenciesState) {\n        case IDerivationState.UP_TO_DATE:\n            return false;\n        case IDerivationState.NOT_TRACKING:\n        case IDerivationState.STALE:\n            return true;\n        case IDerivationState.POSSIBLY_STALE:\n            {\n                var prevUntracked = untrackedStart();\n                var obs = derivation.observing,\n                    l = obs.length;\n                for (var i = 0; i < l; i++) {\n                    var obj = obs[i];\n                    if (isComputedValue(obj)) {\n                        try {\n                            obj.get();\n                        } catch (e) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                        if (derivation.dependenciesState === IDerivationState.STALE) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                    }\n                }\n                changeDependenciesStateTo0(derivation);\n                untrackedEnd(prevUntracked);\n                return false;\n            }\n    }\n}\nfunction isComputingDerivation() {\n    return globalState.trackingDerivation !== null;\n}\nfunction checkIfStateModificationsAreAllowed(atom) {\n    var hasObservers = atom.observers.length > 0;\n    if (globalState.computationDepth > 0 && hasObservers) fail(getMessage(\"m031\") + atom.name);\n    if (!globalState.allowStateChanges && hasObservers) fail(getMessage(globalState.strictMode ? \"m030a\" : \"m030b\") + atom.name);\n}\nfunction trackDerivedFunction(derivation, f, context) {\n    changeDependenciesStateTo0(derivation);\n    derivation.newObserving = new Array(derivation.observing.length + 100);\n    derivation.unboundDepsCount = 0;\n    derivation.runId = ++globalState.runId;\n    var prevTracking = globalState.trackingDerivation;\n    globalState.trackingDerivation = derivation;\n    var result;\n    try {\n        result = f.call(context);\n    } catch (e) {\n        result = new CaughtException(e);\n    }\n    globalState.trackingDerivation = prevTracking;\n    bindDependencies(derivation);\n    return result;\n}\nfunction bindDependencies(derivation) {\n    var prevObserving = derivation.observing;\n    var observing = derivation.observing = derivation.newObserving;\n    derivation.newObserving = null;\n    var i0 = 0,\n        l = derivation.unboundDepsCount;\n    for (var i = 0; i < l; i++) {\n        var dep = observing[i];\n        if (dep.diffValue === 0) {\n            dep.diffValue = 1;\n            if (i0 !== i) observing[i0] = dep;\n            i0++;\n        }\n    }\n    observing.length = i0;\n    l = prevObserving.length;\n    while (l--) {\n        var dep = prevObserving[l];\n        if (dep.diffValue === 0) {\n            removeObserver(dep, derivation);\n        }\n        dep.diffValue = 0;\n    }\n    while (i0--) {\n        var dep = observing[i0];\n        if (dep.diffValue === 1) {\n            dep.diffValue = 0;\n            addObserver(dep, derivation);\n        }\n    }\n}\nfunction clearObserving(derivation) {\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        removeObserver(obs[i], derivation);\n    }derivation.dependenciesState = IDerivationState.NOT_TRACKING;\n    obs.length = 0;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    var res = action();\n    untrackedEnd(prev);\n    return res;\n}\nexports.untracked = untracked;\nfunction untrackedStart() {\n    var prev = globalState.trackingDerivation;\n    globalState.trackingDerivation = null;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.trackingDerivation = prev;\n}\nfunction changeDependenciesStateTo0(derivation) {\n    if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return;\n    derivation.dependenciesState = IDerivationState.UP_TO_DATE;\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nvar persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"];\nvar MobXGlobals = function () {\n    function MobXGlobals() {\n        this.version = 5;\n        this.trackingDerivation = null;\n        this.computationDepth = 0;\n        this.runId = 0;\n        this.mobxGuid = 0;\n        this.inBatch = 0;\n        this.pendingUnobservations = [];\n        this.pendingReactions = [];\n        this.isRunningReactions = false;\n        this.allowStateChanges = true;\n        this.strictMode = false;\n        this.resetId = 0;\n        this.spyListeners = [];\n        this.globalReactionErrorHandlers = [];\n    }\n    return MobXGlobals;\n}();\nvar globalState = new MobXGlobals();\nfunction shareGlobalState() {\n    var global = getGlobal();\n    var ownState = globalState;\n    if (global.__mobservableTrackingStack || global.__mobservableViewStack) throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\");\n    if (global.__mobxGlobal && global.__mobxGlobal.version !== ownState.version) throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\");\n    if (global.__mobxGlobal) globalState = global.__mobxGlobal;else global.__mobxGlobal = ownState;\n}\nfunction getGlobalState() {\n    return globalState;\n}\nfunction registerGlobals() {}\nfunction resetGlobalState() {\n    globalState.resetId++;\n    var defaultGlobals = new MobXGlobals();\n    for (var key in defaultGlobals) {\n        if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];\n    }globalState.allowStateChanges = !globalState.strictMode;\n}\nfunction hasObservers(observable) {\n    return observable.observers && observable.observers.length > 0;\n}\nfunction getObservers(observable) {\n    return observable.observers;\n}\nfunction invariantObservers(observable) {\n    var list = observable.observers;\n    var map = observable.observersIndexes;\n    var l = list.length;\n    for (var i = 0; i < l; i++) {\n        var id = list[i].__mapid;\n        if (i) {\n            invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\");\n        } else {\n            invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldnt be held in map.\");\n        }\n    }\n    invariant(list.length === 0 || Object.keys(map).length === list.length - 1, \"INTERNAL ERROR there is no junk in map\");\n}\nfunction addObserver(observable, node) {\n    var l = observable.observers.length;\n    if (l) {\n        observable.observersIndexes[node.__mapid] = l;\n    }\n    observable.observers[l] = node;\n    if (observable.lowestObserverState > node.dependenciesState) observable.lowestObserverState = node.dependenciesState;\n}\nfunction removeObserver(observable, node) {\n    if (observable.observers.length === 1) {\n        observable.observers.length = 0;\n        queueForUnobservation(observable);\n    } else {\n        var list = observable.observers;\n        var map_1 = observable.observersIndexes;\n        var filler = list.pop();\n        if (filler !== node) {\n            var index = map_1[node.__mapid] || 0;\n            if (index) {\n                map_1[filler.__mapid] = index;\n            } else {\n                delete map_1[filler.__mapid];\n            }\n            list[index] = filler;\n        }\n        delete map_1[node.__mapid];\n    }\n}\nfunction queueForUnobservation(observable) {\n    if (!observable.isPendingUnobservation) {\n        observable.isPendingUnobservation = true;\n        globalState.pendingUnobservations.push(observable);\n    }\n}\nfunction startBatch() {\n    globalState.inBatch++;\n}\nfunction endBatch() {\n    if (--globalState.inBatch === 0) {\n        runReactions();\n        var list = globalState.pendingUnobservations;\n        for (var i = 0; i < list.length; i++) {\n            var observable_1 = list[i];\n            observable_1.isPendingUnobservation = false;\n            if (observable_1.observers.length === 0) {\n                observable_1.onBecomeUnobserved();\n            }\n        }\n        globalState.pendingUnobservations = [];\n    }\n}\nfunction reportObserved(observable) {\n    var derivation = globalState.trackingDerivation;\n    if (derivation !== null) {\n        if (derivation.runId !== observable.lastAccessedBy) {\n            observable.lastAccessedBy = derivation.runId;\n            derivation.newObserving[derivation.unboundDepsCount++] = observable;\n        }\n    } else if (observable.observers.length === 0) {\n        queueForUnobservation(observable);\n    }\n}\nfunction invariantLOS(observable, msg) {\n    var min = getObservers(observable).reduce(function (a, b) {\n        return Math.min(a, b.dependenciesState);\n    }, 2);\n    if (min >= observable.lowestObserverState) return;\n    throw new Error(\"lowestObserverState is wrong for \" + msg + \" because \" + min + \" < \" + observable.lowestObserverState);\n}\nfunction propagateChanged(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale();\n        d.dependenciesState = IDerivationState.STALE;\n    }\n}\nfunction propagateChangeConfirmed(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.POSSIBLY_STALE) d.dependenciesState = IDerivationState.STALE;else if (d.dependenciesState === IDerivationState.UP_TO_DATE) observable.lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nfunction propagateMaybeChanged(observable) {\n    if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return;\n    observable.lowestObserverState = IDerivationState.POSSIBLY_STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {\n            d.dependenciesState = IDerivationState.POSSIBLY_STALE;\n            d.onBecomeStale();\n        }\n    }\n}\nvar Reaction = function () {\n    function Reaction(name, onInvalidate) {\n        if (name === void 0) {\n            name = \"Reaction@\" + getNextId();\n        }\n        this.name = name;\n        this.onInvalidate = onInvalidate;\n        this.observing = [];\n        this.newObserving = [];\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.diffValue = 0;\n        this.runId = 0;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.isDisposed = false;\n        this._isScheduled = false;\n        this._isTrackPending = false;\n        this._isRunning = false;\n    }\n    Reaction.prototype.onBecomeStale = function () {\n        this.schedule();\n    };\n    Reaction.prototype.schedule = function () {\n        if (!this._isScheduled) {\n            this._isScheduled = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    };\n    Reaction.prototype.isScheduled = function () {\n        return this._isScheduled;\n    };\n    Reaction.prototype.runReaction = function () {\n        if (!this.isDisposed) {\n            startBatch();\n            this._isScheduled = false;\n            if (shouldCompute(this)) {\n                this._isTrackPending = true;\n                this.onInvalidate();\n                if (this._isTrackPending && isSpyEnabled()) {\n                    spyReport({\n                        object: this,\n                        type: \"scheduled-reaction\"\n                    });\n                }\n            }\n            endBatch();\n        }\n    };\n    Reaction.prototype.track = function (fn) {\n        startBatch();\n        var notify = isSpyEnabled();\n        var startTime;\n        if (notify) {\n            startTime = Date.now();\n            spyReportStart({\n                object: this,\n                type: \"reaction\",\n                fn: fn\n            });\n        }\n        this._isRunning = true;\n        var result = trackDerivedFunction(this, fn, undefined);\n        this._isRunning = false;\n        this._isTrackPending = false;\n        if (this.isDisposed) {\n            clearObserving(this);\n        }\n        if (isCaughtException(result)) this.reportExceptionInDerivation(result.cause);\n        if (notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n        endBatch();\n    };\n    Reaction.prototype.reportExceptionInDerivation = function (error) {\n        var _this = this;\n        if (this.errorHandler) {\n            this.errorHandler(error, this);\n            return;\n        }\n        var message = \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this;\n        var messageToUser = getMessage(\"m037\");\n        console.error(message || messageToUser, error);\n        if (isSpyEnabled()) {\n            spyReport({\n                type: \"error\",\n                message: message,\n                error: error,\n                object: this\n            });\n        }\n        globalState.globalReactionErrorHandlers.forEach(function (f) {\n            return f(error, _this);\n        });\n    };\n    Reaction.prototype.dispose = function () {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            if (!this._isRunning) {\n                startBatch();\n                clearObserving(this);\n                endBatch();\n            }\n        }\n    };\n    Reaction.prototype.getDisposer = function () {\n        var r = this.dispose.bind(this);\n        r.$mobx = this;\n        r.onError = registerErrorHandler;\n        return r;\n    };\n    Reaction.prototype.toString = function () {\n        return \"Reaction[\" + this.name + \"]\";\n    };\n    Reaction.prototype.whyRun = function () {\n        var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        return \"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this._isRunning ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\";\n    };\n    return Reaction;\n}();\nexports.Reaction = Reaction;\nfunction registerErrorHandler(handler) {\n    invariant(this && this.$mobx && isReaction(this.$mobx), \"Invalid `this`\");\n    invariant(!this.$mobx.errorHandler, \"Only one onErrorHandler can be registered\");\n    this.$mobx.errorHandler = handler;\n}\nfunction onReactionError(handler) {\n    globalState.globalReactionErrorHandlers.push(handler);\n    return function () {\n        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n        if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);\n    };\n}\nvar MAX_REACTION_ITERATIONS = 100;\nvar reactionScheduler = function reactionScheduler(f) {\n    return f();\n};\nfunction runReactions() {\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) return;\n    reactionScheduler(runReactionsHelper);\n}\nfunction runReactionsHelper() {\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    while (allReactions.length > 0) {\n        if (++iterations === MAX_REACTION_ITERATIONS) {\n            console.error(\"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0]));\n            allReactions.splice(0);\n        }\n        var remainingReactions = allReactions.splice(0);\n        for (var i = 0, l = remainingReactions.length; i < l; i++) {\n            remainingReactions[i].runReaction();\n        }\n    }\n    globalState.isRunningReactions = false;\n}\nvar isReaction = createInstanceofPredicate(\"Reaction\", Reaction);\nfunction setReactionScheduler(fn) {\n    var baseScheduler = reactionScheduler;\n    reactionScheduler = function reactionScheduler(f) {\n        return fn(function () {\n            return baseScheduler(f);\n        });\n    };\n}\nfunction isSpyEnabled() {\n    return !!globalState.spyListeners.length;\n}\nfunction spyReport(event) {\n    if (!globalState.spyListeners.length) return;\n    var listeners = globalState.spyListeners;\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](event);\n    }\n}\nfunction spyReportStart(event) {\n    var change = objectAssign({}, event, { spyReportStart: true });\n    spyReport(change);\n}\nvar END_EVENT = { spyReportEnd: true };\nfunction spyReportEnd(change) {\n    if (change) spyReport(objectAssign({}, change, END_EVENT));else spyReport(END_EVENT);\n}\nfunction spy(listener) {\n    globalState.spyListeners.push(listener);\n    return once(function () {\n        var idx = globalState.spyListeners.indexOf(listener);\n        if (idx !== -1) globalState.spyListeners.splice(idx, 1);\n    });\n}\nexports.spy = spy;\nfunction hasInterceptors(interceptable) {\n    return interceptable.interceptors && interceptable.interceptors.length > 0;\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);\n    interceptors.push(handler);\n    return once(function () {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1) interceptors.splice(idx, 1);\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    try {\n        var interceptors = interceptable.interceptors;\n        if (interceptors) for (var i = 0, l = interceptors.length; i < l; i++) {\n            change = interceptors[i](change);\n            invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\");\n            if (!change) break;\n        }\n        return change;\n    } finally {\n        untrackedEnd(prevU);\n    }\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners && listenable.changeListeners.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners || (listenable.changeListeners = []);\n    listeners.push(handler);\n    return once(function () {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1) listeners.splice(idx, 1);\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners;\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](change);\n    }\n    untrackedEnd(prevU);\n}\nfunction asReference(value) {\n    deprecated(\"asReference is deprecated, use observable.ref instead\");\n    return observable.ref(value);\n}\nexports.asReference = asReference;\nfunction asStructure(value) {\n    deprecated(\"asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.\");\n    return observable.struct(value);\n}\nexports.asStructure = asStructure;\nfunction asFlat(value) {\n    deprecated(\"asFlat is deprecated, use observable.shallow instead\");\n    return observable.shallow(value);\n}\nexports.asFlat = asFlat;\nfunction asMap(data) {\n    deprecated(\"asMap is deprecated, use observable.map or observable.shallowMap instead\");\n    return observable.map(data || {});\n}\nexports.asMap = asMap;\nfunction isModifierDescriptor(thing) {\n    return (typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null && thing.isMobxModifierDescriptor === true;\n}\nexports.isModifierDescriptor = isModifierDescriptor;\nfunction createModifierDescriptor(enhancer, initialValue) {\n    invariant(!isModifierDescriptor(initialValue), \"Modifiers cannot be nested\");\n    return {\n        isMobxModifierDescriptor: true,\n        initialValue: initialValue,\n        enhancer: enhancer\n    };\n}\nfunction deepEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return observable.array(v, name);\n    if (isPlainObject(v)) return observable.object(v, name);\n    if (isES6Map(v)) return observable.map(v, name);\n    return v;\n}\nfunction shallowEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (v === undefined || v === null) return v;\n    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v)) return v;\n    if (Array.isArray(v)) return observable.shallowArray(v, name);\n    if (isPlainObject(v)) return observable.shallowObject(v, name);\n    if (isES6Map(v)) return observable.shallowMap(v, name);\n    return fail(\"The shallow modifier / decorator can only used in combination with arrays, objects and maps\");\n}\nfunction referenceEnhancer(newValue) {\n    return newValue;\n}\nfunction deepStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return new ObservableArray(v, deepStructEnhancer, name);\n    if (isES6Map(v)) return new ObservableMap(v, deepStructEnhancer, name);\n    if (isPlainObject(v)) {\n        var res = {};\n        asObservableObject(res, name);\n        extendObservableHelper(res, deepStructEnhancer, [v]);\n        return res;\n    }\n    return v;\n}\nfunction refStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    return v;\n}\nvar MAX_SPLICE_SIZE = 10000;\nvar safariPrototypeSetterInheritanceBug = function () {\n    var v = false;\n    var p = {};\n    Object.defineProperty(p, \"0\", { set: function set() {\n            v = true;\n        } });\n    Object.create(p)[\"0\"] = 1;\n    return v === false;\n}();\nvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\nvar StubArray = function () {\n    function StubArray() {}\n    return StubArray;\n}();\nStubArray.prototype = [];\nvar ObservableArrayAdministration = function () {\n    function ObservableArrayAdministration(name, enhancer, array, owned) {\n        this.array = array;\n        this.owned = owned;\n        this.lastKnownLength = 0;\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.atom = new BaseAtom(name || \"ObservableArray@\" + getNextId());\n        this.enhancer = function (newV, oldV) {\n            return enhancer(newV, oldV, name + \"[..]\");\n        };\n    }\n    ObservableArrayAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        if (fireImmediately) {\n            listener({\n                object: this.array,\n                type: \"splice\",\n                index: 0,\n                added: this.values.slice(),\n                addedCount: this.values.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    ObservableArrayAdministration.prototype.getArrayLength = function () {\n        this.atom.reportObserved();\n        return this.values.length;\n    };\n    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {\n        if (typeof newLength !== \"number\" || newLength < 0) throw new Error(\"[mobx.array] Out of range: \" + newLength);\n        var currentLength = this.values.length;\n        if (newLength === currentLength) return;else if (newLength > currentLength) {\n            var newItems = new Array(newLength - currentLength);\n            for (var i = 0; i < newLength - currentLength; i++) {\n                newItems[i] = undefined;\n            }this.spliceWithArray(currentLength, 0, newItems);\n        } else this.spliceWithArray(newLength, currentLength - newLength);\n    };\n    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {\n        if (oldLength !== this.lastKnownLength) throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\");\n        this.lastKnownLength += delta;\n        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1);\n    };\n    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        var _this = this;\n        checkIfStateModificationsAreAllowed(this.atom);\n        var length = this.values.length;\n        if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);\n        if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        if (newItems === undefined) newItems = [];\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.array,\n                type: \"splice\",\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change) return EMPTY_ARRAY;\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.map(function (v) {\n            return _this.enhancer(v, undefined);\n        });\n        var lengthDelta = newItems.length - deleteCount;\n        this.updateArrayLength(length, lengthDelta);\n        var res = this.spliceItemsIntoValues(index, deleteCount, newItems);\n        if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res);\n        return res;\n    };\n    ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) {\n        if (newItems.length < MAX_SPLICE_SIZE) {\n            return (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));\n        } else {\n            var res = this.values.slice(index, index + deleteCount);\n            this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount));\n            return res;\n        }\n        var _a;\n    };\n    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"update\",\n            index: index, newValue: newValue, oldValue: oldValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"splice\",\n            index: index, removed: removed, added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    return ObservableArrayAdministration;\n}();\nvar ObservableArray = function (_super) {\n    __extends(ObservableArray, _super);\n    function ObservableArray(initialValues, enhancer, name, owned) {\n        if (name === void 0) {\n            name = \"ObservableArray@\" + getNextId();\n        }\n        if (owned === void 0) {\n            owned = false;\n        }\n        var _this = _super.call(this) || this;\n        var adm = new ObservableArrayAdministration(name, enhancer, _this, owned);\n        addHiddenFinalProp(_this, \"$mobx\", adm);\n        if (initialValues && initialValues.length) {\n            adm.updateArrayLength(0, initialValues.length);\n            adm.values = initialValues.map(function (v) {\n                return enhancer(v, undefined, name + \"[..]\");\n            });\n            adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY);\n        } else {\n            adm.values = [];\n        }\n        if (safariPrototypeSetterInheritanceBug) {\n            Object.defineProperty(adm.array, \"0\", ENTRY_0);\n        }\n        return _this;\n    }\n    ObservableArray.prototype.intercept = function (handler) {\n        return this.$mobx.intercept(handler);\n    };\n    ObservableArray.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        return this.$mobx.observe(listener, fireImmediately);\n    };\n    ObservableArray.prototype.clear = function () {\n        return this.splice(0);\n    };\n    ObservableArray.prototype.concat = function () {\n        var arrays = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            arrays[_i] = arguments[_i];\n        }\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) {\n            return isObservableArray(a) ? a.peek() : a;\n        }));\n    };\n    ObservableArray.prototype.replace = function (newItems) {\n        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);\n    };\n    ObservableArray.prototype.toJS = function () {\n        return this.slice();\n    };\n    ObservableArray.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableArray.prototype.peek = function () {\n        return this.$mobx.values;\n    };\n    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {\n        if (fromIndex === void 0) {\n            fromIndex = 0;\n        }\n        this.$mobx.atom.reportObserved();\n        var items = this.$mobx.values,\n            l = items.length;\n        for (var i = fromIndex; i < l; i++) {\n            if (predicate.call(thisArg, items[i], i, this)) return items[i];\n        }return undefined;\n    };\n    ObservableArray.prototype.splice = function (index, deleteCount) {\n        var newItems = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            newItems[_i - 2] = arguments[_i];\n        }\n        switch (arguments.length) {\n            case 0:\n                return [];\n            case 1:\n                return this.$mobx.spliceWithArray(index);\n            case 2:\n                return this.$mobx.spliceWithArray(index, deleteCount);\n        }\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.push = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(adm.values.length, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.pop = function () {\n        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];\n    };\n    ObservableArray.prototype.shift = function () {\n        return this.splice(0, 1)[0];\n    };\n    ObservableArray.prototype.unshift = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(0, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.reverse = function () {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.reverse.apply(clone, arguments);\n    };\n    ObservableArray.prototype.sort = function (compareFn) {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.sort.apply(clone, arguments);\n    };\n    ObservableArray.prototype.remove = function (value) {\n        var idx = this.$mobx.values.indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    };\n    ObservableArray.prototype.move = function (fromIndex, toIndex) {\n        function checkIndex(index) {\n            if (index < 0) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\n            }\n            var length = this.$mobx.values.length;\n            if (index >= length) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\n            }\n        }\n        checkIndex.call(this, fromIndex);\n        checkIndex.call(this, toIndex);\n        if (fromIndex === toIndex) {\n            return;\n        }\n        var oldItems = this.$mobx.values;\n        var newItems;\n        if (fromIndex < toIndex) {\n            newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1));\n        } else {\n            newItems = oldItems.slice(0, toIndex).concat([oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\n        }\n        this.replace(newItems);\n    };\n    ObservableArray.prototype.toString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toString.apply(this.$mobx.values, arguments);\n    };\n    ObservableArray.prototype.toLocaleString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toLocaleString.apply(this.$mobx.values, arguments);\n    };\n    return ObservableArray;\n}(StubArray);\ndeclareIterator(ObservableArray.prototype, function () {\n    return arrayAsIterator(this.slice());\n});\nmakeNonEnumerable(ObservableArray.prototype, [\"constructor\", \"intercept\", \"observe\", \"clear\", \"concat\", \"replace\", \"toJS\", \"toJSON\", \"peek\", \"find\", \"splice\", \"spliceWithArray\", \"push\", \"pop\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"remove\", \"move\", \"toString\", \"toLocaleString\"]);\nObject.defineProperty(ObservableArray.prototype, \"length\", {\n    enumerable: false,\n    configurable: true,\n    get: function get() {\n        return this.$mobx.getArrayLength();\n    },\n    set: function set(newLength) {\n        this.$mobx.setArrayLength(newLength);\n    }\n});\n[\"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function (funcName) {\n    var baseFunc = Array.prototype[funcName];\n    invariant(typeof baseFunc === \"function\", \"Base function not defined on Array prototype: '\" + funcName + \"'\");\n    addHiddenProp(ObservableArray.prototype, funcName, function () {\n        this.$mobx.atom.reportObserved();\n        return baseFunc.apply(this.$mobx.values, arguments);\n    });\n});\nvar ENTRY_0 = {\n    configurable: true,\n    enumerable: false,\n    set: createArraySetter(0),\n    get: createArrayGetter(0)\n};\nfunction createArrayBufferItem(index) {\n    var set = createArraySetter(index);\n    var get = createArrayGetter(index);\n    Object.defineProperty(ObservableArray.prototype, \"\" + index, {\n        enumerable: false,\n        configurable: true,\n        set: set, get: get\n    });\n}\nfunction createArraySetter(index) {\n    return function (newValue) {\n        var adm = this.$mobx;\n        var values = adm.values;\n        if (index < values.length) {\n            checkIfStateModificationsAreAllowed(adm.atom);\n            var oldValue = values[index];\n            if (hasInterceptors(adm)) {\n                var change = interceptChange(adm, {\n                    type: \"update\",\n                    object: adm.array,\n                    index: index, newValue: newValue\n                });\n                if (!change) return;\n                newValue = change.newValue;\n            }\n            newValue = adm.enhancer(newValue, oldValue);\n            var changed = newValue !== oldValue;\n            if (changed) {\n                values[index] = newValue;\n                adm.notifyArrayChildUpdate(index, newValue, oldValue);\n            }\n        } else if (index === values.length) {\n            adm.spliceWithArray(index, 0, [newValue]);\n        } else throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length);\n    };\n}\nfunction createArrayGetter(index) {\n    return function () {\n        var impl = this.$mobx;\n        if (impl) {\n            if (index < impl.values.length) {\n                impl.atom.reportObserved();\n                return impl.values[index];\n            }\n            console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\");\n        }\n        return undefined;\n    };\n}\nfunction reserveArrayBuffer(max) {\n    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) {\n        createArrayBufferItem(index);\n    }OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n}\nreserveArrayBuffer(1000);\nvar isObservableArrayAdministration = createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\nfunction isObservableArray(thing) {\n    return isObject(thing) && isObservableArrayAdministration(thing.$mobx);\n}\nexports.isObservableArray = isObservableArray;\nvar ObservableMapMarker = {};\nvar ObservableMap = function () {\n    function ObservableMap(initialData, enhancer, name) {\n        if (enhancer === void 0) {\n            enhancer = deepEnhancer;\n        }\n        if (name === void 0) {\n            name = \"ObservableMap@\" + getNextId();\n        }\n        this.enhancer = enhancer;\n        this.name = name;\n        this.$mobx = ObservableMapMarker;\n        this._data = {};\n        this._hasMap = {};\n        this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + \".keys()\", true);\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.merge(initialData);\n    }\n    ObservableMap.prototype._has = function (key) {\n        return typeof this._data[key] !== \"undefined\";\n    };\n    ObservableMap.prototype.has = function (key) {\n        if (!this.isValidKey(key)) return false;\n        key = \"\" + key;\n        if (this._hasMap[key]) return this._hasMap[key].get();\n        return this._updateHasMapEntry(key, false).get();\n    };\n    ObservableMap.prototype.set = function (key, value) {\n        this.assertValidKey(key);\n        key = \"\" + key;\n        var hasKey = this._has(key);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? \"update\" : \"add\",\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change) return this;\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this._updateValue(key, value);\n        } else {\n            this._addValue(key, value);\n        }\n        return this;\n    };\n    ObservableMap.prototype.delete = function (key) {\n        var _this = this;\n        this.assertValidKey(key);\n        key = \"\" + key;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: \"delete\",\n                object: this,\n                name: key\n            });\n            if (!change) return false;\n        }\n        if (this._has(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"delete\",\n                object: this,\n                oldValue: this._data[key].value,\n                name: key\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            runInTransaction(function () {\n                _this._keys.remove(key);\n                _this._updateHasMapEntry(key, false);\n                var observable = _this._data[key];\n                observable.setNewValue(undefined);\n                _this._data[key] = undefined;\n            });\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n            return true;\n        }\n        return false;\n    };\n    ObservableMap.prototype._updateHasMapEntry = function (key, value) {\n        var entry = this._hasMap[key];\n        if (entry) {\n            entry.setNewValue(value);\n        } else {\n            entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + \".\" + key + \"?\", false);\n        }\n        return entry;\n    };\n    ObservableMap.prototype._updateValue = function (name, newValue) {\n        var observable = this._data[name];\n        newValue = observable.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"update\",\n                object: this,\n                oldValue: observable.value,\n                name: name, newValue: newValue\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            observable.setNewValue(newValue);\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableMap.prototype._addValue = function (name, newValue) {\n        var _this = this;\n        runInTransaction(function () {\n            var observable = _this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + \".\" + name, false);\n            newValue = observable.value;\n            _this._updateHasMapEntry(name, true);\n            _this._keys.push(name);\n        });\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            type: \"add\",\n            object: this,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableMap.prototype.get = function (key) {\n        key = \"\" + key;\n        if (this.has(key)) return this._data[key].get();\n        return undefined;\n    };\n    ObservableMap.prototype.keys = function () {\n        return arrayAsIterator(this._keys.slice());\n    };\n    ObservableMap.prototype.values = function () {\n        return arrayAsIterator(this._keys.map(this.get, this));\n    };\n    ObservableMap.prototype.entries = function () {\n        var _this = this;\n        return arrayAsIterator(this._keys.map(function (key) {\n            return [key, _this.get(key)];\n        }));\n    };\n    ObservableMap.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        this.keys().forEach(function (key) {\n            return callback.call(thisArg, _this.get(key), key, _this);\n        });\n    };\n    ObservableMap.prototype.merge = function (other) {\n        var _this = this;\n        if (isObservableMap(other)) {\n            other = other.toJS();\n        }\n        runInTransaction(function () {\n            if (isPlainObject(other)) Object.keys(other).forEach(function (key) {\n                return _this.set(key, other[key]);\n            });else if (Array.isArray(other)) other.forEach(function (_a) {\n                var key = _a[0],\n                    value = _a[1];\n                return _this.set(key, value);\n            });else if (isES6Map(other)) other.forEach(function (value, key) {\n                return _this.set(key, value);\n            });else if (other !== null && other !== undefined) fail(\"Cannot initialize map from \" + other);\n        });\n        return this;\n    };\n    ObservableMap.prototype.clear = function () {\n        var _this = this;\n        runInTransaction(function () {\n            untracked(function () {\n                _this.keys().forEach(_this.delete, _this);\n            });\n        });\n    };\n    ObservableMap.prototype.replace = function (values) {\n        var _this = this;\n        runInTransaction(function () {\n            _this.clear();\n            _this.merge(values);\n        });\n        return this;\n    };\n    Object.defineProperty(ObservableMap.prototype, \"size\", {\n        get: function get() {\n            return this._keys.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObservableMap.prototype.toJS = function () {\n        var _this = this;\n        var res = {};\n        this.keys().forEach(function (key) {\n            return res[key] = _this.get(key);\n        });\n        return res;\n    };\n    ObservableMap.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableMap.prototype.isValidKey = function (key) {\n        if (key === null || key === undefined) return false;\n        if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"boolean\") return true;\n        return false;\n    };\n    ObservableMap.prototype.assertValidKey = function (key) {\n        if (!this.isValidKey(key)) throw new Error(\"[mobx.map] Invalid key: '\" + key + \"', only strings, numbers and booleans are accepted as key in observable maps.\");\n    };\n    ObservableMap.prototype.toString = function () {\n        var _this = this;\n        return this.name + \"[{ \" + this.keys().map(function (key) {\n            return key + \": \" + (\"\" + _this.get(key));\n        }).join(\", \") + \" }]\";\n    };\n    ObservableMap.prototype.observe = function (listener, fireImmediately) {\n        invariant(fireImmediately !== true, getMessage(\"m033\"));\n        return registerListener(this, listener);\n    };\n    ObservableMap.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableMap;\n}();\nexports.ObservableMap = ObservableMap;\ndeclareIterator(ObservableMap.prototype, function () {\n    return this.entries();\n});\nfunction map(initialValues) {\n    deprecated(\"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\");\n    return observable.map(initialValues);\n}\nexports.map = map;\nvar isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap);\nexports.isObservableMap = isObservableMap;\nvar ObservableObjectAdministration = function () {\n    function ObservableObjectAdministration(target, name) {\n        this.target = target;\n        this.name = name;\n        this.values = {};\n        this.changeListeners = null;\n        this.interceptors = null;\n    }\n    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {\n        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\");\n        return registerListener(this, callback);\n    };\n    ObservableObjectAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableObjectAdministration;\n}();\nfunction asObservableObject(target, name) {\n    if (isObservableObject(target)) return target.$mobx;\n    invariant(Object.isExtensible(target), getMessage(\"m035\"));\n    if (!isPlainObject(target)) name = (target.constructor.name || \"ObservableObject\") + \"@\" + getNextId();\n    if (!name) name = \"ObservableObject@\" + getNextId();\n    var adm = new ObservableObjectAdministration(target, name);\n    addHiddenFinalProp(target, \"$mobx\", adm);\n    return adm;\n}\nfunction defineObservablePropertyFromDescriptor(adm, propName, descriptor, defaultEnhancer) {\n    if (adm.values[propName]) {\n        invariant(\"value\" in descriptor, \"The property \" + propName + \" in \" + adm.name + \" is already observable, cannot redefine it as computed property\");\n        adm.target[propName] = descriptor.value;\n        return;\n    }\n    if (\"value\" in descriptor) {\n        if (isModifierDescriptor(descriptor.value)) {\n            var modifierDescriptor = descriptor.value;\n            defineObservableProperty(adm, propName, modifierDescriptor.initialValue, modifierDescriptor.enhancer);\n        } else if (isAction(descriptor.value) && descriptor.value.autoBind === true) {\n            defineBoundAction(adm.target, propName, descriptor.value.originalFn);\n        } else if (isComputedValue(descriptor.value)) {\n            defineComputedPropertyFromComputedValue(adm, propName, descriptor.value);\n        } else {\n            defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer);\n        }\n    } else {\n        defineComputedProperty(adm, propName, descriptor.get, descriptor.set, false, true);\n    }\n}\nfunction defineObservableProperty(adm, propName, newValue, enhancer) {\n    assertPropertyConfigurable(adm.target, propName);\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            object: adm.target,\n            name: propName,\n            type: \"add\",\n            newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    var observable = adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + \".\" + propName, false);\n    newValue = observable.value;\n    Object.defineProperty(adm.target, propName, generateObservablePropConfig(propName));\n    notifyPropertyAddition(adm, adm.target, propName, newValue);\n}\nfunction defineComputedProperty(adm, propName, getter, setter, compareStructural, asInstanceProperty) {\n    if (asInstanceProperty) assertPropertyConfigurable(adm.target, propName);\n    adm.values[propName] = new ComputedValue(getter, adm.target, compareStructural, adm.name + \".\" + propName, setter);\n    if (asInstanceProperty) {\n        Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n    }\n}\nfunction defineComputedPropertyFromComputedValue(adm, propName, computedValue) {\n    var name = adm.name + \".\" + propName;\n    computedValue.name = name;\n    if (!computedValue.scope) computedValue.scope = adm.target;\n    adm.values[propName] = computedValue;\n    Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n}\nvar observablePropertyConfigs = {};\nvar computedPropertyConfigs = {};\nfunction generateObservablePropConfig(propName) {\n    return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            setPropertyValue(this, propName, v);\n        }\n    });\n}\nfunction generateComputedPropConfig(propName) {\n    return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: false,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            return this.$mobx.values[propName].set(v);\n        }\n    });\n}\nfunction setPropertyValue(instance, name, newValue) {\n    var adm = instance.$mobx;\n    var observable = adm.values[name];\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            type: \"update\",\n            object: instance,\n            name: name, newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    newValue = observable.prepareNewValue(newValue);\n    if (newValue !== UNCHANGED) {\n        var notify = hasListeners(adm);\n        var notifySpy = isSpyEnabled();\n        var change = notify || notifySpy ? {\n            type: \"update\",\n            object: instance,\n            oldValue: observable.value,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        observable.setNewValue(newValue);\n        if (notify) notifyListeners(adm, change);\n        if (notifySpy) spyReportEnd();\n    }\n}\nfunction notifyPropertyAddition(adm, object, name, newValue) {\n    var notify = hasListeners(adm);\n    var notifySpy = isSpyEnabled();\n    var change = notify || notifySpy ? {\n        type: \"add\",\n        object: object, name: name, newValue: newValue\n    } : null;\n    if (notifySpy) spyReportStart(change);\n    if (notify) notifyListeners(adm, change);\n    if (notifySpy) spyReportEnd();\n}\nvar isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\nfunction isObservableObject(thing) {\n    if (isObject(thing)) {\n        runLazyInitializers(thing);\n        return isObservableObjectAdministration(thing.$mobx);\n    }\n    return false;\n}\nexports.isObservableObject = isObservableObject;\nvar UNCHANGED = {};\nvar ObservableValue = function (_super) {\n    __extends(ObservableValue, _super);\n    function ObservableValue(value, enhancer, name, notifySpy) {\n        if (name === void 0) {\n            name = \"ObservableValue@\" + getNextId();\n        }\n        if (notifySpy === void 0) {\n            notifySpy = true;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.enhancer = enhancer;\n        _this.hasUnreportedChange = false;\n        _this.value = enhancer(value, undefined, name);\n        if (notifySpy && isSpyEnabled()) {\n            spyReport({ type: \"create\", object: _this, newValue: _this.value });\n        }\n        return _this;\n    }\n    ObservableValue.prototype.set = function (newValue) {\n        var oldValue = this.value;\n        newValue = this.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if (notifySpy) {\n                spyReportStart({\n                    type: \"update\",\n                    object: this,\n                    newValue: newValue, oldValue: oldValue\n                });\n            }\n            this.setNewValue(newValue);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableValue.prototype.prepareNewValue = function (newValue) {\n        checkIfStateModificationsAreAllowed(this);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue });\n            if (!change) return UNCHANGED;\n            newValue = change.newValue;\n        }\n        newValue = this.enhancer(newValue, this.value, this.name);\n        return this.value !== newValue ? newValue : UNCHANGED;\n    };\n    ObservableValue.prototype.setNewValue = function (newValue) {\n        var oldValue = this.value;\n        this.value = newValue;\n        this.reportChanged();\n        if (hasListeners(this)) {\n            notifyListeners(this, {\n                type: \"update\",\n                object: this,\n                newValue: newValue,\n                oldValue: oldValue\n            });\n        }\n    };\n    ObservableValue.prototype.get = function () {\n        this.reportObserved();\n        return this.value;\n    };\n    ObservableValue.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableValue.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately) listener({\n            object: this,\n            type: \"update\",\n            newValue: this.value,\n            oldValue: undefined\n        });\n        return registerListener(this, listener);\n    };\n    ObservableValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ObservableValue.prototype.toString = function () {\n        return this.name + \"[\" + this.value + \"]\";\n    };\n    ObservableValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    return ObservableValue;\n}(BaseAtom);\nObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf;\nvar isObservableValue = createInstanceofPredicate(\"ObservableValue\", ObservableValue);\nexports.isBoxedObservable = isObservableValue;\nfunction getAtom(thing, property) {\n    if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            invariant(property === undefined, getMessage(\"m036\"));\n            return thing.$mobx.atom;\n        }\n        if (isObservableMap(thing)) {\n            var anyThing = thing;\n            if (property === undefined) return getAtom(anyThing._keys);\n            var observable_2 = anyThing._data[property] || anyThing._hasMap[property];\n            invariant(!!observable_2, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\");\n            return observable_2;\n        }\n        runLazyInitializers(thing);\n        if (isObservableObject(thing)) {\n            if (!property) return fail(\"please specify a property\");\n            var observable_3 = thing.$mobx.values[property];\n            invariant(!!observable_3, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\");\n            return observable_3;\n        }\n        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n            return thing;\n        }\n    } else if (typeof thing === \"function\") {\n        if (isReaction(thing.$mobx)) {\n            return thing.$mobx;\n        }\n    }\n    return fail(\"Cannot obtain atom from \" + thing);\n}\nfunction getAdministration(thing, property) {\n    invariant(thing, \"Expecting some object\");\n    if (property !== undefined) return getAdministration(getAtom(thing, property));\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;\n    if (isObservableMap(thing)) return thing;\n    runLazyInitializers(thing);\n    if (thing.$mobx) return thing.$mobx;\n    invariant(false, \"Cannot obtain administration from \" + thing);\n}\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing)) named = getAdministration(thing);else named = getAtom(thing);\n    return named.name;\n}\nfunction createClassPropertyDecorator(onInitialize, _get, _set, enumerable, allowCustomArguments) {\n    function classPropertyDecorator(target, key, descriptor, customArgs, argLen) {\n        if (argLen === void 0) {\n            argLen = 0;\n        }\n        invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\");\n        if (!descriptor) {\n            var newDescriptor = {\n                enumerable: enumerable,\n                configurable: true,\n                get: function get() {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {\n                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);\n                    } else {\n                        _set.call(this, key, v);\n                    }\n                }\n            };\n            if (arguments.length < 3 || arguments.length === 5 && argLen < 3) {\n                Object.defineProperty(target, key, newDescriptor);\n            }\n            return newDescriptor;\n        } else {\n            if (!hasOwnProperty(target, \"__mobxLazyInitializers\")) {\n                addHiddenProp(target, \"__mobxLazyInitializers\", target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice() || []);\n            }\n            var value_1 = descriptor.value,\n                initializer_1 = descriptor.initializer;\n            target.__mobxLazyInitializers.push(function (instance) {\n                onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor);\n            });\n            return {\n                enumerable: enumerable, configurable: true,\n                get: function get() {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    _set.call(this, key, v);\n                }\n            };\n        }\n    }\n    if (allowCustomArguments) {\n        return function () {\n            if (quacksLikeADecorator(arguments)) return classPropertyDecorator.apply(null, arguments);\n            var outerArgs = arguments;\n            var argLen = arguments.length;\n            return function (target, key, descriptor) {\n                return classPropertyDecorator(target, key, descriptor, outerArgs, argLen);\n            };\n        };\n    }\n    return classPropertyDecorator;\n}\nfunction typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {\n    if (!hasOwnProperty(instance, \"__mobxInitializedProps\")) addHiddenProp(instance, \"__mobxInitializedProps\", {});\n    instance.__mobxInitializedProps[key] = true;\n    onInitialize(instance, key, v, customArgs, baseDescriptor);\n}\nfunction runLazyInitializers(instance) {\n    if (instance.__mobxDidRunLazyInitializers === true) return;\n    if (instance.__mobxLazyInitializers) {\n        addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true);\n        instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) {\n            return initializer(instance);\n        });\n    }\n}\nfunction quacksLikeADecorator(args) {\n    return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\";\n}\nfunction iteratorSymbol() {\n    return typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n}\nvar IS_ITERATING_MARKER = \"__$$iterating\";\nfunction arrayAsIterator(array) {\n    invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\");\n    addHiddenFinalProp(array, IS_ITERATING_MARKER, true);\n    var idx = -1;\n    addHiddenFinalProp(array, \"next\", function next() {\n        idx++;\n        return {\n            done: idx >= this.length,\n            value: idx < this.length ? this[idx] : undefined\n        };\n    });\n    return array;\n}\nfunction declareIterator(prototType, iteratorFactory) {\n    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);\n}\nvar messages = {\n    \"m001\": \"It is not allowed to assign new values to @action fields\",\n    \"m002\": \"`runInAction` expects a function\",\n    \"m003\": \"`runInAction` expects a function without arguments\",\n    \"m004\": \"autorun expects a function\",\n    \"m005\": \"Warning: attempted to pass an action to autorun. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m006\": \"Warning: attempted to pass an action to autorunAsync. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m007\": \"reaction only accepts 2 or 3 arguments. If migrating from MobX 2, please provide an options object\",\n    \"m008\": \"wrapping reaction expression in `asReference` is no longer supported, use options object instead\",\n    \"m009\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\",\n    \"m010\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\",\n    \"m011\": \"First argument to `computed` should be an expression. If using computed as decorator, don't pass it arguments\",\n    \"m012\": \"computed takes one or two arguments if used as function\",\n    \"m013\": \"[mobx.expr] 'expr' should only be used inside other reactive functions.\",\n    \"m014\": \"extendObservable expected 2 or more arguments\",\n    \"m015\": \"extendObservable expects an object as first argument\",\n    \"m016\": \"extendObservable should not be used on maps, use map.merge instead\",\n    \"m017\": \"all arguments of extendObservable should be objects\",\n    \"m018\": \"extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540\",\n    \"m019\": \"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\",\n    \"m020\": \"modifiers can only be used for individual object properties\",\n    \"m021\": \"observable expects zero or one arguments\",\n    \"m022\": \"@observable can not be used on getters, use @computed instead\",\n    \"m023\": \"Using `transaction` is deprecated, use `runInAction` or `(@)action` instead.\",\n    \"m024\": \"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested its value.\",\n    \"m025\": \"whyRun can only be used on reactions and computed values\",\n    \"m026\": \"`action` can only be invoked on functions\",\n    \"m028\": \"It is not allowed to set `useStrict` when a derivation is running\",\n    \"m029\": \"INTERNAL ERROR only onBecomeUnobserved shouldn't be called twice in a row\",\n    \"m030a\": \"Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: \",\n    \"m030b\": \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: \",\n    \"m031\": \"Computed values are not allowed to not cause side effects by changing observables that are already being observed. Tried to modify: \",\n    \"m032\": \"* This computation is suspended (not in use by any reaction) and won't run automatically.\\n\tDidn't expect this computation to be suspended at this point?\\n\t  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n\t  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\",\n    \"m033\": \"`observe` doesn't support the fire immediately property for observable maps.\",\n    \"m034\": \"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\",\n    \"m035\": \"Cannot make the designated object observable; it is not extensible\",\n    \"m036\": \"It is not possible to get index atoms from arrays\",\n    \"m037\": \"Hi there! I'm sorry you have just run into an exception.\\nIf your debugger ends up here, know that some reaction (like the render() of an observer component, autorun or reaction)\\nthrew an exception and that mobx caught it, to avoid that it brings the rest of your application down.\\nThe original cause of the exception (the code that caused this reaction to run (again)), is still in the stack.\\n\\nHowever, more interesting is the actual stack trace of the error itself.\\nHopefully the error is an instanceof Error, because in that case you can inspect the original stack of the error from where it was thrown.\\nSee `error.stack` property, or press the very subtle \\\"(...)\\\" link you see near the console.error message that probably brought you here.\\nThat stack is more interesting than the stack of this console.error itself.\\n\\nIf the exception you see is an exception you created yourself, make sure to use `throw new Error(\\\"Oops\\\")` instead of `throw \\\"Oops\\\"`,\\nbecause the javascript environment will only preserve the original stack trace in the first form.\\n\\nYou can also make sure the debugger pauses the next time this very same exception is thrown by enabling \\\"Pause on caught exception\\\".\\n(Note that it might pause on many other, unrelated exception as well).\\n\\nIf that all doesn't help you out, feel free to open an issue https://github.com/mobxjs/mobx/issues!\\n\",\n    \"m038\": \"Missing items in this list?\\n    1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n    2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\"\n};\nfunction getMessage(id) {\n    return messages[id];\n}\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nfunction getGlobal() {\n    return global;\n}\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\nfunction fail(message, thing) {\n    invariant(false, message, thing);\n    throw \"X\";\n}\nfunction invariant(check, message, thing) {\n    if (!check) throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\"));\n}\nvar deprecatedMessages = [];\nfunction deprecated(msg) {\n    if (deprecatedMessages.indexOf(msg) !== -1) return false;\n    deprecatedMessages.push(msg);\n    console.error(\"[mobx] Deprecated: \" + msg);\n    return true;\n}\nfunction once(func) {\n    var invoked = false;\n    return function () {\n        if (invoked) return;\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function noop() {};\nfunction unique(list) {\n    var res = [];\n    list.forEach(function (item) {\n        if (res.indexOf(item) === -1) res.push(item);\n    });\n    return res;\n}\nfunction joinStrings(things, limit, separator) {\n    if (limit === void 0) {\n        limit = 100;\n    }\n    if (separator === void 0) {\n        separator = \" - \";\n    }\n    if (!things) return \"\";\n    var sliced = things.slice(0, limit);\n    return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\");\n}\nfunction isObject(value) {\n    return value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\";\n}\nfunction isPlainObject(value) {\n    if (value === null || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false;\n    var proto = Object.getPrototypeOf(value);\n    return proto === Object.prototype || proto === null;\n}\nfunction objectAssign() {\n    var res = arguments[0];\n    for (var i = 1, l = arguments.length; i < l; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n            if (hasOwnProperty(source, key)) {\n                res[key] = source[key];\n            }\n        }\n    }\n    return res;\n}\nfunction valueDidChange(compareStructural, oldValue, newValue) {\n    if (typeof oldValue === 'number' && isNaN(oldValue)) {\n        return typeof newValue !== 'number' || !isNaN(newValue);\n    }\n    return compareStructural ? !deepEqual(oldValue, newValue) : oldValue !== newValue;\n}\nvar prototypeHasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(object, propName) {\n    return prototypeHasOwnProperty.call(object, propName);\n}\nfunction makeNonEnumerable(object, propNames) {\n    for (var i = 0; i < propNames.length; i++) {\n        addHiddenProp(object, propNames[i], object[propNames[i]]);\n    }\n}\nfunction addHiddenProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\nfunction isPropertyConfigurable(object, prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(object, prop);\n    return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;\n}\nfunction assertPropertyConfigurable(object, prop) {\n    invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\");\n}\nfunction getEnumerableKeys(obj) {\n    var res = [];\n    for (var key in obj) {\n        res.push(key);\n    }return res;\n}\nfunction deepEqual(a, b) {\n    if (a === null && b === null) return true;\n    if (a === undefined && b === undefined) return true;\n    if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) !== \"object\") return a === b;\n    var aIsArray = isArrayLike(a);\n    var aIsMap = isMapLike(a);\n    if (aIsArray !== isArrayLike(b)) {\n        return false;\n    } else if (aIsMap !== isMapLike(b)) {\n        return false;\n    } else if (aIsArray) {\n        if (a.length !== b.length) return false;\n        for (var i = a.length - 1; i >= 0; i--) {\n            if (!deepEqual(a[i], b[i])) return false;\n        }return true;\n    } else if (aIsMap) {\n        if (a.size !== b.size) return false;\n        var equals_1 = true;\n        a.forEach(function (value, key) {\n            equals_1 = equals_1 && deepEqual(b.get(key), value);\n        });\n        return equals_1;\n    } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === \"object\" && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === \"object\") {\n        if (a === null || b === null) return false;\n        if (isMapLike(a) && isMapLike(b)) {\n            if (a.size !== b.size) return false;\n            return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries());\n        }\n        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length) return false;\n        for (var prop in a) {\n            if (!(prop in b)) return false;\n            if (!deepEqual(a[prop], b[prop])) return false;\n        }\n        return true;\n    }\n    return false;\n}\nfunction createInstanceofPredicate(name, clazz) {\n    var propName = \"isMobX\" + name;\n    clazz.prototype[propName] = true;\n    return function (x) {\n        return isObject(x) && x[propName] === true;\n    };\n}\nfunction isArrayLike(x) {\n    return Array.isArray(x) || isObservableArray(x);\n}\nexports.isArrayLike = isArrayLike;\nfunction isMapLike(x) {\n    return isES6Map(x) || isObservableMap(x);\n}\nfunction isES6Map(thing) {\n    if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map) return true;\n    return false;\n}\nfunction primitiveSymbol() {\n    return typeof Symbol === \"function\" && Symbol.toPrimitive || \"@@toPrimitive\";\n}\nfunction toPrimitive(value) {\n    return value === null ? null : (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? \"\" + value : value;\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _icons = __webpack_require__(6);\n\nvar _constants = __webpack_require__(0);\n\nfunction renderHeader(_ref, instance) {\n  var meta = _ref.meta,\n      user = _ref.user,\n      reactions = _ref.reactions;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-header-container';\n\n  var likeButton = document.createElement('span');\n  var likedReaction = reactions.find(function (reaction) {\n    return reaction.content === 'heart' && reaction.user.login === user.login;\n  });\n  likeButton.className = 'gitment-header-like-btn';\n  likeButton.innerHTML = '\\n    ' + _icons.heart + '\\n    ' + (likedReaction ? 'Unlike' : 'Like') + '\\n    ' + (meta.reactions && meta.reactions.heart ? ' \\u2022 <strong>' + meta.reactions.heart + '</strong> Liked' : '') + '\\n  ';\n\n  if (likedReaction) {\n    likeButton.classList.add('liked');\n    likeButton.onclick = function () {\n      return instance.unlike();\n    };\n  } else {\n    likeButton.classList.remove('liked');\n    likeButton.onclick = function () {\n      return instance.like();\n    };\n  }\n  container.appendChild(likeButton);\n\n  var commentsCount = document.createElement('span');\n  commentsCount.innerHTML = '\\n    ' + (meta.comments ? ' \\u2022 <strong>' + meta.comments + '</strong> Comments' : '') + '\\n  ';\n  container.appendChild(commentsCount);\n\n  var issueLink = document.createElement('a');\n  issueLink.className = 'gitment-header-issue-link';\n  issueLink.href = meta.html_url;\n  issueLink.target = '_blank';\n  issueLink.innerText = 'Issue Page';\n  container.appendChild(issueLink);\n\n  return container;\n}\n\nfunction renderComments(_ref2, instance) {\n  var meta = _ref2.meta,\n      comments = _ref2.comments,\n      commentReactions = _ref2.commentReactions,\n      currentPage = _ref2.currentPage,\n      user = _ref2.user,\n      error = _ref2.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-comments-container';\n\n  if (error) {\n    var errorBlock = document.createElement('div');\n    errorBlock.className = 'gitment-comments-error';\n\n    if (error === _constants.NOT_INITIALIZED_ERROR && user.login && user.login.toLowerCase() === instance.owner.toLowerCase()) {\n      var initHint = document.createElement('div');\n      var initButton = document.createElement('button');\n      initButton.className = 'gitment-comments-init-btn';\n      initButton.onclick = function () {\n        initButton.setAttribute('disabled', true);\n        instance.init().catch(function (e) {\n          initButton.removeAttribute('disabled');\n          alert(e);\n        });\n      };\n      initButton.innerText = 'Initialize Comments';\n      initHint.appendChild(initButton);\n      errorBlock.appendChild(initHint);\n    } else {\n      errorBlock.innerText = error;\n    }\n    container.appendChild(errorBlock);\n    return container;\n  } else if (comments === undefined) {\n    var loading = document.createElement('div');\n    loading.innerText = 'Loading comments...';\n    loading.className = 'gitment-comments-loading';\n    container.appendChild(loading);\n    return container;\n  } else if (!comments.length) {\n    var emptyBlock = document.createElement('div');\n    emptyBlock.className = 'gitment-comments-empty';\n    emptyBlock.innerText = 'No Comment Yet';\n    container.appendChild(emptyBlock);\n    return container;\n  }\n\n  var commentsList = document.createElement('ul');\n  commentsList.className = 'gitment-comments-list';\n\n  comments.forEach(function (comment) {\n    var createDate = new Date(comment.created_at);\n    var updateDate = new Date(comment.updated_at);\n    var commentItem = document.createElement('li');\n    commentItem.className = 'gitment-comment';\n    commentItem.innerHTML = '\\n      <a class=\"gitment-comment-avatar\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n        <img class=\"gitment-comment-avatar-img\" src=\"' + comment.user.avatar_url + '\"/>\\n      </a>\\n      <div class=\"gitment-comment-main\">\\n        <div class=\"gitment-comment-header\">\\n          <a class=\"gitment-comment-name\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n            ' + comment.user.login + '\\n          </a>\\n          commented on\\n          <span title=\"' + createDate + '\">' + createDate.toDateString() + '</span>\\n          ' + (createDate.toString() !== updateDate.toString() ? ' \\u2022 <span title=\"comment was edited at ' + updateDate + '\">edited</span>' : '') + '\\n          <div class=\"gitment-comment-like-btn\">' + _icons.heart + ' ' + (comment.reactions.heart || '') + '</div>\\n        </div>\\n        <div class=\"gitment-comment-body gitment-markdown\">' + comment.body_html + '</div>\\n      </div>\\n    ';\n    var likeButton = commentItem.querySelector('.gitment-comment-like-btn');\n    var likedReaction = commentReactions[comment.id] && commentReactions[comment.id].find(function (reaction) {\n      return reaction.content === 'heart' && reaction.user.login === user.login;\n    });\n    if (likedReaction) {\n      likeButton.classList.add('liked');\n      likeButton.onclick = function () {\n        return instance.unlikeAComment(comment.id);\n      };\n    } else {\n      likeButton.classList.remove('liked');\n      likeButton.onclick = function () {\n        return instance.likeAComment(comment.id);\n      };\n    }\n\n    // dirty\n    // use a blank image to trigger height calculating when element rendered\n    var imgTrigger = document.createElement('img');\n    var markdownBody = commentItem.querySelector('.gitment-comment-body');\n    imgTrigger.className = 'gitment-hidden';\n    imgTrigger.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    imgTrigger.onload = function () {\n      if (markdownBody.clientHeight > instance.maxCommentHeight) {\n        markdownBody.classList.add('gitment-comment-body-folded');\n        markdownBody.style.maxHeight = instance.maxCommentHeight + 'px';\n        markdownBody.title = 'Click to Expand';\n        markdownBody.onclick = function () {\n          markdownBody.classList.remove('gitment-comment-body-folded');\n          markdownBody.style.maxHeight = '';\n          markdownBody.title = '';\n          markdownBody.onclick = null;\n        };\n      }\n    };\n    commentItem.appendChild(imgTrigger);\n\n    commentsList.appendChild(commentItem);\n  });\n\n  container.appendChild(commentsList);\n\n  if (meta) {\n    var pageCount = Math.ceil(meta.comments / instance.perPage);\n    if (pageCount > 1) {\n      var pagination = document.createElement('ul');\n      pagination.className = 'gitment-comments-pagination';\n\n      if (currentPage > 1) {\n        var previousButton = document.createElement('li');\n        previousButton.className = 'gitment-comments-page-item';\n        previousButton.innerText = 'Previous';\n        previousButton.onclick = function () {\n          return instance.goto(currentPage - 1);\n        };\n        pagination.appendChild(previousButton);\n      }\n\n      var _loop = function _loop(i) {\n        var pageItem = document.createElement('li');\n        pageItem.className = 'gitment-comments-page-item';\n        pageItem.innerText = i;\n        pageItem.onclick = function () {\n          return instance.goto(i);\n        };\n        if (currentPage === i) pageItem.classList.add('gitment-selected');\n        pagination.appendChild(pageItem);\n      };\n\n      for (var i = 1; i <= pageCount; i++) {\n        _loop(i);\n      }\n\n      if (currentPage < pageCount) {\n        var nextButton = document.createElement('li');\n        nextButton.className = 'gitment-comments-page-item';\n        nextButton.innerText = 'Next';\n        nextButton.onclick = function () {\n          return instance.goto(currentPage + 1);\n        };\n        pagination.appendChild(nextButton);\n      }\n\n      container.appendChild(pagination);\n    }\n  }\n\n  return container;\n}\n\nfunction renderEditor(_ref3, instance) {\n  var user = _ref3.user,\n      error = _ref3.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-editor-container';\n\n  var shouldDisable = user.login && !error ? '' : 'disabled';\n  var disabledTip = user.login ? '' : 'Login to Comment';\n  container.innerHTML = '\\n      ' + (user.login ? '<a class=\"gitment-editor-avatar\" href=\"' + user.html_url + '\" target=\"_blank\">\\n            <img class=\"gitment-editor-avatar-img\" src=\"' + user.avatar_url + '\"/>\\n          </a>' : user.isLoggingIn ? '<div class=\"gitment-editor-avatar\">' + _icons.spinner + '</div>' : '<a class=\"gitment-editor-avatar\" href=\"' + instance.loginLink + '\" title=\"login with GitHub\">\\n              ' + _icons.github + '\\n            </a>') + '\\n    </a>\\n    <div class=\"gitment-editor-main\">\\n      <div class=\"gitment-editor-header\">\\n        <nav class=\"gitment-editor-tabs\">\\n          <button class=\"gitment-editor-tab gitment-selected\">Write</button>\\n          <button class=\"gitment-editor-tab\">Preview</button>\\n        </nav>\\n        <div class=\"gitment-editor-login\">\\n          ' + (user.login ? '<a class=\"gitment-editor-logout-link\">Logout</a>' : user.isLoggingIn ? 'Logging in...' : '<a class=\"gitment-editor-login-link\" href=\"' + instance.loginLink + '\">Login</a> with GitHub') + '\\n        </div>\\n      </div>\\n      <div class=\"gitment-editor-body\">\\n        <div class=\"gitment-editor-write-field\">\\n          <textarea placeholder=\"Leave a comment\" title=\"' + disabledTip + '\" ' + shouldDisable + '></textarea>\\n        </div>\\n        <div class=\"gitment-editor-preview-field gitment-hidden\">\\n          <div class=\"gitment-editor-preview gitment-markdown\"></div>\\n        </div>\\n      </div>\\n    </div>\\n    <div class=\"gitment-editor-footer\">\\n      <a class=\"gitment-editor-footer-tip\" href=\"https://guides.github.com/features/mastering-markdown/\" target=\"_blank\">\\n        Styling with Markdown is supported\\n      </a>\\n      <button class=\"gitment-editor-submit\" title=\"' + disabledTip + '\" ' + shouldDisable + '>Comment</button>\\n    </div>\\n  ';\n  if (user.login) {\n    container.querySelector('.gitment-editor-logout-link').onclick = function () {\n      return instance.logout();\n    };\n  }\n\n  var writeField = container.querySelector('.gitment-editor-write-field');\n  var previewField = container.querySelector('.gitment-editor-preview-field');\n\n  var textarea = writeField.querySelector('textarea');\n  textarea.oninput = function () {\n    textarea.style.height = 'auto';\n    var style = window.getComputedStyle(textarea, null);\n    var height = parseInt(style.height, 10);\n    var clientHeight = textarea.clientHeight;\n    var scrollHeight = textarea.scrollHeight;\n    if (clientHeight < scrollHeight) {\n      textarea.style.height = height + scrollHeight - clientHeight + 'px';\n    }\n  };\n\n  var _container$querySelec = container.querySelectorAll('.gitment-editor-tab'),\n      _container$querySelec2 = _slicedToArray(_container$querySelec, 2),\n      writeTab = _container$querySelec2[0],\n      previewTab = _container$querySelec2[1];\n\n  writeTab.onclick = function () {\n    writeTab.classList.add('gitment-selected');\n    previewTab.classList.remove('gitment-selected');\n    writeField.classList.remove('gitment-hidden');\n    previewField.classList.add('gitment-hidden');\n\n    textarea.focus();\n  };\n  previewTab.onclick = function () {\n    previewTab.classList.add('gitment-selected');\n    writeTab.classList.remove('gitment-selected');\n    previewField.classList.remove('gitment-hidden');\n    writeField.classList.add('gitment-hidden');\n\n    var preview = previewField.querySelector('.gitment-editor-preview');\n    var content = textarea.value.trim();\n    if (!content) {\n      preview.innerText = 'Nothing to preview';\n      return;\n    }\n\n    preview.innerText = 'Loading preview...';\n    instance.markdown(content).then(function (html) {\n      return preview.innerHTML = html;\n    });\n  };\n\n  var submitButton = container.querySelector('.gitment-editor-submit');\n  submitButton.onclick = function () {\n    submitButton.innerText = 'Submitting...';\n    submitButton.setAttribute('disabled', true);\n    instance.post(textarea.value.trim()).then(function (data) {\n      textarea.value = '';\n      textarea.style.height = 'auto';\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    }).catch(function (e) {\n      alert(e);\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    });\n  };\n\n  return container;\n}\n\nfunction renderFooter() {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-footer-container';\n  container.innerHTML = '\\n    Powered by\\n    <a class=\"gitment-footer-project-link\" href=\"https://github.com/imsun/gitment\" target=\"_blank\">\\n      Gitment\\n    </a>\\n  ';\n  return container;\n}\n\nfunction render(state, instance) {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-root-container';\n  container.appendChild(instance.renderHeader(state, instance));\n  container.appendChild(instance.renderComments(state, instance));\n  container.appendChild(instance.renderEditor(state, instance));\n  container.appendChild(instance.renderFooter(state, instance));\n  return container;\n}\n\nexports.default = { render: render, renderHeader: renderHeader, renderComments: renderComments, renderEditor: renderEditor, renderFooter: renderFooter };\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.http = exports.Query = exports.isString = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.getTargetContainer = getTargetContainer;\n\nvar _constants = __webpack_require__(0);\n\nvar isString = exports.isString = function isString(s) {\n  return toString.call(s) === '[object String]';\n};\n\nfunction getTargetContainer(container) {\n  var targetContainer = void 0;\n  if (container instanceof Element) {\n    targetContainer = container;\n  } else if (isString(container)) {\n    targetContainer = document.getElementById(container);\n  } else {\n    targetContainer = document.createElement('div');\n  }\n\n  return targetContainer;\n}\n\nvar Query = exports.Query = {\n  parse: function parse() {\n    var search = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.search;\n\n    if (!search) return {};\n    var queryString = search[0] === '?' ? search.substring(1) : search;\n    var query = {};\n    queryString.split('&').forEach(function (queryStr) {\n      var _queryStr$split = queryStr.split('='),\n          _queryStr$split2 = _slicedToArray(_queryStr$split, 2),\n          key = _queryStr$split2[0],\n          value = _queryStr$split2[1];\n\n      if (key) query[key] = value;\n    });\n\n    return query;\n  },\n  stringify: function stringify(query) {\n    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '?';\n\n    var queryString = Object.keys(query).map(function (key) {\n      return key + '=' + encodeURIComponent(query[key] || '');\n    }).join('&');\n    return queryString ? prefix + queryString : '';\n  }\n};\n\nfunction ajaxFactory(method) {\n  return function (apiPath) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://api.github.com';\n\n    var req = new XMLHttpRequest();\n    var token = localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n\n    var url = '' + base + apiPath;\n    var body = null;\n    if (method === 'GET' || method === 'DELETE') {\n      url += Query.stringify(data);\n    }\n\n    var p = new Promise(function (resolve, reject) {\n      req.addEventListener('load', function () {\n        var contentType = req.getResponseHeader('content-type');\n        var res = req.responseText;\n        if (!/json/.test(contentType)) {\n          resolve(res);\n          return;\n        }\n        var data = req.responseText ? JSON.parse(res) : {};\n        if (data.message) {\n          reject(new Error(data.message));\n        } else {\n          resolve(data);\n        }\n      });\n      req.addEventListener('error', function (error) {\n        return reject(error);\n      });\n    });\n    req.open(method, url, true);\n\n    req.setRequestHeader('Accept', 'application/vnd.github.squirrel-girl-preview, application/vnd.github.html+json');\n    if (token) {\n      req.setRequestHeader('Authorization', 'token ' + token);\n    }\n    if (method !== 'GET' && method !== 'DELETE') {\n      body = JSON.stringify(data);\n      req.setRequestHeader('Content-Type', 'application/json');\n    }\n\n    req.send(body);\n    return p;\n  };\n}\n\nvar http = exports.http = {\n  get: ajaxFactory('GET'),\n  post: ajaxFactory('POST'),\n  delete: ajaxFactory('DELETE'),\n  put: ajaxFactory('PUT')\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mobx = __webpack_require__(1);\n\nvar _constants = __webpack_require__(0);\n\nvar _utils = __webpack_require__(3);\n\nvar _default = __webpack_require__(2);\n\nvar _default2 = _interopRequireDefault(_default);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar scope = 'public_repo';\n\nfunction extendRenderer(instance, renderer) {\n  instance[renderer] = function (container) {\n    var targetContainer = (0, _utils.getTargetContainer)(container);\n    var render = instance.theme[renderer] || instance.defaultTheme[renderer];\n\n    (0, _mobx.autorun)(function () {\n      var e = render(instance.state, instance);\n      if (targetContainer.firstChild) {\n        targetContainer.replaceChild(e, targetContainer.firstChild);\n      } else {\n        targetContainer.appendChild(e);\n      }\n    });\n\n    return targetContainer;\n  };\n}\n\nvar Gitment = function () {\n  _createClass(Gitment, [{\n    key: 'accessToken',\n    get: function get() {\n      return localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n    },\n    set: function set(token) {\n      localStorage.setItem(_constants.LS_ACCESS_TOKEN_KEY, token);\n    }\n  }, {\n    key: 'loginLink',\n    get: function get() {\n      var oauthUri = 'https://github.com/login/oauth/authorize';\n      var redirect_uri = this.oauth.redirect_uri || window.location.href;\n\n      var oauthParams = Object.assign({\n        scope: scope,\n        redirect_uri: redirect_uri\n      }, this.oauth);\n\n      return '' + oauthUri + _utils.Query.stringify(oauthParams);\n    }\n  }]);\n\n  function Gitment() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Gitment);\n\n    this.defaultTheme = _default2.default;\n    this.useTheme(_default2.default);\n\n    Object.assign(this, {\n      id: window.location.href,\n      title: window.document.title,\n      link: window.location.href,\n      desc: '',\n      labels: [],\n      theme: _default2.default,\n      oauth: {},\n      perPage: 20,\n      maxCommentHeight: 250\n    }, options);\n\n    this.useTheme(this.theme);\n\n    var user = {};\n    try {\n      var userInfo = localStorage.getItem(_constants.LS_USER_KEY);\n      if (this.accessToken && userInfo) {\n        Object.assign(user, JSON.parse(userInfo), {\n          fromCache: true\n        });\n      }\n    } catch (e) {\n      localStorage.removeItem(_constants.LS_USER_KEY);\n    }\n\n    this.state = (0, _mobx.observable)({\n      user: user,\n      error: null,\n      meta: {},\n      comments: undefined,\n      reactions: [],\n      commentReactions: {},\n      currentPage: 1\n    });\n\n    var query = _utils.Query.parse();\n    if (query.code) {\n      var _oauth = this.oauth,\n          client_id = _oauth.client_id,\n          client_secret = _oauth.client_secret;\n\n      var code = query.code;\n      delete query.code;\n      var search = _utils.Query.stringify(query);\n      var replacedUrl = '' + window.location.origin + window.location.pathname + search + window.location.hash;\n      history.replaceState({}, '', replacedUrl);\n\n      Object.assign(this, {\n        id: replacedUrl,\n        link: replacedUrl\n      }, options);\n\n      this.state.user.isLoggingIn = true;\n      _utils.http.post('https://github.com/login/oauth/access_token', {\n        code: code,\n        client_id: client_id,\n        client_secret: client_secret\n      }, '').then(function (data) {\n        _this.accessToken = data.access_token;\n        _this.update();\n      }).catch(function (e) {\n        _this.state.user.isLoggingIn = false;\n        alert(e);\n      });\n    } else {\n      this.update();\n    }\n  }\n\n  _createClass(Gitment, [{\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      return this.createIssue().then(function () {\n        return _this2.loadComments();\n      }).then(function (comments) {\n        _this2.state.error = null;\n        return comments;\n      });\n    }\n  }, {\n    key: 'useTheme',\n    value: function useTheme() {\n      var _this3 = this;\n\n      var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this.theme = theme;\n\n      var renderers = Object.keys(this.theme);\n      renderers.forEach(function (renderer) {\n        return extendRenderer(_this3, renderer);\n      });\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var _this4 = this;\n\n      return Promise.all([this.loadMeta(), this.loadUserInfo()]).then(function () {\n        return Promise.all([_this4.loadComments().then(function () {\n          return _this4.loadCommentReactions();\n        }), _this4.loadReactions()]);\n      }).catch(function (e) {\n        return _this4.state.error = e;\n      });\n    }\n  }, {\n    key: 'markdown',\n    value: function markdown(text) {\n      return _utils.http.post('/markdown', {\n        text: text,\n        mode: 'gfm'\n      });\n    }\n  }, {\n    key: 'createIssue',\n    value: function createIssue() {\n      var _this5 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo,\n          title = this.title,\n          link = this.link,\n          desc = this.desc,\n          labels = this.labels;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues', {\n        title: title,\n        labels: labels.concat(['gitment', id]),\n        body: link + '\\n\\n' + desc\n      }).then(function (meta) {\n        _this5.state.meta = meta;\n        return meta;\n      });\n    }\n  }, {\n    key: 'getIssue',\n    value: function getIssue() {\n      if (this.state.meta.id) return Promise.resolve(this.state.meta);\n\n      return this.loadMeta();\n    }\n  }, {\n    key: 'post',\n    value: function post(body) {\n      var _this6 = this;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.post(issue.comments_url, { body: body }, '');\n      }).then(function (data) {\n        _this6.state.meta.comments++;\n        var pageCount = Math.ceil(_this6.state.meta.comments / _this6.perPage);\n        if (_this6.state.currentPage === pageCount) {\n          _this6.state.comments.push(data);\n        }\n        return data;\n      });\n    }\n  }, {\n    key: 'loadMeta',\n    value: function loadMeta() {\n      var _this7 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo;\n\n      return _utils.http.get('/repos/' + owner + '/' + repo + '/issues', {\n        creator: owner,\n        labels: id\n      }).then(function (issues) {\n        if (!issues.length) return Promise.reject(_constants.NOT_INITIALIZED_ERROR);\n        _this7.state.meta = issues[0];\n        return issues[0];\n      });\n    }\n  }, {\n    key: 'loadComments',\n    value: function loadComments() {\n      var _this8 = this;\n\n      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentPage;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.get(issue.comments_url, { page: page, per_page: _this8.perPage }, '');\n      }).then(function (comments) {\n        _this8.state.comments = comments;\n        return comments;\n      });\n    }\n  }, {\n    key: 'loadUserInfo',\n    value: function loadUserInfo() {\n      var _this9 = this;\n\n      if (!this.accessToken) {\n        this.logout();\n        return Promise.resolve({});\n      }\n\n      return _utils.http.get('/user').then(function (user) {\n        _this9.state.user = user;\n        localStorage.setItem(_constants.LS_USER_KEY, JSON.stringify(user));\n        return user;\n      });\n    }\n  }, {\n    key: 'loadReactions',\n    value: function loadReactions() {\n      var _this10 = this;\n\n      if (!this.accessToken) {\n        this.state.reactions = [];\n        return Promise.resolve([]);\n      }\n\n      return this.getIssue().then(function (issue) {\n        if (!issue.reactions.total_count) return [];\n        return _utils.http.get(issue.reactions.url, {}, '');\n      }).then(function (reactions) {\n        _this10.state.reactions = reactions;\n        return reactions;\n      });\n    }\n  }, {\n    key: 'loadCommentReactions',\n    value: function loadCommentReactions() {\n      var _this11 = this;\n\n      if (!this.accessToken) {\n        this.state.commentReactions = {};\n        return Promise.resolve([]);\n      }\n\n      var comments = this.state.comments;\n      var comentReactions = {};\n\n      return Promise.all(comments.map(function (comment) {\n        if (!comment.reactions.total_count) return [];\n\n        var owner = _this11.owner,\n            repo = _this11.repo;\n\n        return _utils.http.get('/repos/' + owner + '/' + repo + '/issues/comments/' + comment.id + '/reactions', {});\n      })).then(function (reactionsArray) {\n        comments.forEach(function (comment, index) {\n          comentReactions[comment.id] = reactionsArray[index];\n        });\n        _this11.state.commentReactions = comentReactions;\n\n        return comentReactions;\n      });\n    }\n  }, {\n    key: 'login',\n    value: function login() {\n      window.location.href = this.loginLink;\n    }\n  }, {\n    key: 'logout',\n    value: function logout() {\n      localStorage.removeItem(_constants.LS_ACCESS_TOKEN_KEY);\n      localStorage.removeItem(_constants.LS_USER_KEY);\n      this.state.user = {};\n    }\n  }, {\n    key: 'goto',\n    value: function goto(page) {\n      this.state.currentPage = page;\n      this.state.comments = undefined;\n      return this.loadComments(page);\n    }\n  }, {\n    key: 'like',\n    value: function like() {\n      var _this12 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/' + this.state.meta.number + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this12.state.reactions.push(reaction);\n        _this12.state.meta.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlike',\n    value: function unlike() {\n      var _this13 = this;\n\n      if (!this.accessToken) return Promise.reject();\n\n      var _state = this.state,\n          user = _state.user,\n          reactions = _state.reactions;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        _this13.state.meta.reactions.heart--;\n      });\n    }\n  }, {\n    key: 'likeAComment',\n    value: function likeAComment(commentId) {\n      var _this14 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/comments/' + commentId + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this14.state.commentReactions[commentId].push(reaction);\n        comment.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlikeAComment',\n    value: function unlikeAComment(commentId) {\n      if (!this.accessToken) return Promise.reject();\n\n      var reactions = this.state.commentReactions[commentId];\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n      var user = this.state.user;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        comment.reactions.heart--;\n      });\n    }\n  }]);\n\n  return Gitment;\n}();\n\nmodule.exports = Gitment;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Modified from https://github.com/evil-icons/evil-icons\n */\n\nvar close = exports.close = '<svg class=\"gitment-close-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M37.304 11.282l1.414 1.414-26.022 26.02-1.414-1.413z\"/><path d=\"M12.696 11.282l26.022 26.02-1.414 1.415-26.022-26.02z\"/></svg>';\nvar github = exports.github = '<svg class=\"gitment-github-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 10c-8.3 0-15 6.7-15 15 0 6.6 4.3 12.2 10.3 14.2.8.1 1-.3 1-.7v-2.6c-4.2.9-5.1-2-5.1-2-.7-1.7-1.7-2.2-1.7-2.2-1.4-.9.1-.9.1-.9 1.5.1 2.3 1.5 2.3 1.5 1.3 2.3 3.5 1.6 4.4 1.2.1-1 .5-1.6 1-2-3.3-.4-6.8-1.7-6.8-7.4 0-1.6.6-3 1.5-4-.2-.4-.7-1.9.1-4 0 0 1.3-.4 4.1 1.5 1.2-.3 2.5-.5 3.8-.5 1.3 0 2.6.2 3.8.5 2.9-1.9 4.1-1.5 4.1-1.5.8 2.1.3 3.6.1 4 1 1 1.5 2.4 1.5 4 0 5.8-3.5 7-6.8 7.4.5.5 1 1.4 1 2.8v4.1c0 .4.3.9 1 .7 6-2 10.2-7.6 10.2-14.2C40 16.7 33.3 10 25 10z\"/></svg>';\nvar heart = exports.heart = '<svg class=\"gitment-heart-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 39.7l-.6-.5C11.5 28.7 8 25 8 19c0-5 4-9 9-9 4.1 0 6.4 2.3 8 4.1 1.6-1.8 3.9-4.1 8-4.1 5 0 9 4 9 9 0 6-3.5 9.7-16.4 20.2l-.6.5zM17 12c-3.9 0-7 3.1-7 7 0 5.1 3.2 8.5 15 18.1 11.8-9.6 15-13 15-18.1 0-3.9-3.1-7-7-7-3.5 0-5.4 2.1-6.9 3.8L25 17.1l-1.1-1.3C22.4 14.1 20.5 12 17 12z\"/></svg>';\nvar spinner = exports.spinner = '<svg class=\"gitment-spinner-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 18c-.6 0-1-.4-1-1V9c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M25 42c-.6 0-1-.4-1-1v-8c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M29 19c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M17 39.8c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".93\" d=\"M21 19c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M33 39.8c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.1-.3.2-.5.2z\"/><path opacity=\".65\" d=\"M17 26H9c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".3\" d=\"M41 26h-8c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".86\" d=\"M18.1 21.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M38.9 33.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".44\" d=\"M11.1 33.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.1.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M31.9 21.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.2.2-.3.2-.5.2z\"/></svg>';\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=gitment.browser.js.map","date":"2023-12-31T07:04:03.956Z","updated":"2023-12-31T07:04:03.956Z","path":"js/gitment.js","layout":"false","title":"","comments":1,"_id":"clqxisund000aeslr5xffcf9q","content":"var Gitment =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar LS_ACCESS_TOKEN_KEY = exports.LS_ACCESS_TOKEN_KEY = 'gitment-comments-token';\nvar LS_USER_KEY = exports.LS_USER_KEY = 'gitment-user-info';\n\nvar NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = new Error('Comments Not Initialized');\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) {\n            if (b.hasOwnProperty(p)) d[p] = b[p];\n        }\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nregisterGlobals();\nexports.extras = {\n    allowStateChanges: allowStateChanges,\n    deepEqual: deepEqual,\n    getAtom: getAtom,\n    getDebugName: getDebugName,\n    getDependencyTree: getDependencyTree,\n    getAdministration: getAdministration,\n    getGlobalState: getGlobalState,\n    getObserverTree: getObserverTree,\n    isComputingDerivation: isComputingDerivation,\n    isSpyEnabled: isSpyEnabled,\n    onReactionError: onReactionError,\n    resetGlobalState: resetGlobalState,\n    shareGlobalState: shareGlobalState,\n    spyReport: spyReport,\n    spyReportEnd: spyReportEnd,\n    spyReportStart: spyReportStart,\n    setReactionScheduler: setReactionScheduler\n};\nif ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" ? \"undefined\" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === \"object\") {\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx(module.exports);\n}\nmodule.exports.default = module.exports;\nvar actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {\n    var actionName = args && args.length === 1 ? args[0] : value.name || key || \"<unnamed action>\";\n    var wrappedAction = action(actionName, value);\n    addHiddenProp(target, key, wrappedAction);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, true);\nvar boundActionDecorator = createClassPropertyDecorator(function (target, key, value) {\n    defineBoundAction(target, key, value);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, false);\nvar action = function action(arg1, arg2, arg3, arg4) {\n    if (arguments.length === 1 && typeof arg1 === \"function\") return createAction(arg1.name || \"<unnamed action>\", arg1);\n    if (arguments.length === 2 && typeof arg2 === \"function\") return createAction(arg1, arg2);\n    if (arguments.length === 1 && typeof arg1 === \"string\") return namedActionDecorator(arg1);\n    return namedActionDecorator(arg2).apply(null, arguments);\n};\nexports.action = action;\naction.bound = function boundAction(arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n        var action_1 = createAction(\"<not yet bound action>\", arg1);\n        action_1.autoBind = true;\n        return action_1;\n    }\n    return boundActionDecorator.apply(null, arguments);\n};\nfunction namedActionDecorator(name) {\n    return function (target, prop, descriptor) {\n        if (descriptor && typeof descriptor.value === \"function\") {\n            descriptor.value = createAction(name, descriptor.value);\n            descriptor.enumerable = false;\n            descriptor.configurable = true;\n            return descriptor;\n        }\n        return actionFieldDecorator(name).apply(this, arguments);\n    };\n}\nfunction runInAction(arg1, arg2, arg3) {\n    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action>\";\n    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\n    var scope = typeof arg1 === \"function\" ? arg2 : arg3;\n    invariant(typeof fn === \"function\", getMessage(\"m002\"));\n    invariant(fn.length === 0, getMessage(\"m003\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    return executeAction(actionName, fn, scope, undefined);\n}\nexports.runInAction = runInAction;\nfunction isAction(thing) {\n    return typeof thing === \"function\" && thing.isMobxAction === true;\n}\nexports.isAction = isAction;\nfunction defineBoundAction(target, propertyName, fn) {\n    var res = function res() {\n        return executeAction(propertyName, fn, target, arguments);\n    };\n    res.isMobxAction = true;\n    addHiddenProp(target, propertyName, res);\n}\nfunction autorun(arg1, arg2, arg3) {\n    var name, view, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        view = arg2;\n        scope = arg3;\n    } else {\n        name = arg1.name || \"Autorun@\" + getNextId();\n        view = arg1;\n        scope = arg2;\n    }\n    invariant(typeof view === \"function\", getMessage(\"m004\"));\n    invariant(isAction(view) === false, getMessage(\"m005\"));\n    if (scope) view = view.bind(scope);\n    var reaction = new Reaction(name, function () {\n        this.track(reactionRunner);\n    });\n    function reactionRunner() {\n        view(reaction);\n    }\n    reaction.schedule();\n    return reaction.getDisposer();\n}\nexports.autorun = autorun;\nfunction when(arg1, arg2, arg3, arg4) {\n    var name, predicate, effect, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        predicate = arg2;\n        effect = arg3;\n        scope = arg4;\n    } else {\n        name = \"When@\" + getNextId();\n        predicate = arg1;\n        effect = arg2;\n        scope = arg3;\n    }\n    var disposer = autorun(name, function (r) {\n        if (predicate.call(scope)) {\n            r.dispose();\n            var prevUntracked = untrackedStart();\n            effect.call(scope);\n            untrackedEnd(prevUntracked);\n        }\n    });\n    return disposer;\n}\nexports.when = when;\nfunction autorunAsync(arg1, arg2, arg3, arg4) {\n    var name, func, delay, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        func = arg2;\n        delay = arg3;\n        scope = arg4;\n    } else {\n        name = arg1.name || \"AutorunAsync@\" + getNextId();\n        func = arg1;\n        delay = arg2;\n        scope = arg3;\n    }\n    invariant(isAction(func) === false, getMessage(\"m006\"));\n    if (delay === void 0) delay = 1;\n    if (scope) func = func.bind(scope);\n    var isScheduled = false;\n    var r = new Reaction(name, function () {\n        if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                if (!r.isDisposed) r.track(reactionRunner);\n            }, delay);\n        }\n    });\n    function reactionRunner() {\n        func(r);\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.autorunAsync = autorunAsync;\nfunction reaction(expression, effect, arg3) {\n    if (arguments.length > 3) {\n        fail(getMessage(\"m007\"));\n    }\n    if (isModifierDescriptor(expression)) {\n        fail(getMessage(\"m008\"));\n    }\n    var opts;\n    if ((typeof arg3 === \"undefined\" ? \"undefined\" : _typeof(arg3)) === \"object\") {\n        opts = arg3;\n    } else {\n        opts = {};\n    }\n    opts.name = opts.name || expression.name || effect.name || \"Reaction@\" + getNextId();\n    opts.fireImmediately = arg3 === true || opts.fireImmediately === true;\n    opts.delay = opts.delay || 0;\n    opts.compareStructural = opts.compareStructural || opts.struct || false;\n    effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect);\n    if (opts.context) {\n        expression = expression.bind(opts.context);\n    }\n    var firstTime = true;\n    var isScheduled = false;\n    var nextValue;\n    var r = new Reaction(opts.name, function () {\n        if (firstTime || opts.delay < 1) {\n            reactionRunner();\n        } else if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                reactionRunner();\n            }, opts.delay);\n        }\n    });\n    function reactionRunner() {\n        if (r.isDisposed) return;\n        var changed = false;\n        r.track(function () {\n            var v = expression(r);\n            changed = valueDidChange(opts.compareStructural, nextValue, v);\n            nextValue = v;\n        });\n        if (firstTime && opts.fireImmediately) effect(nextValue, r);\n        if (!firstTime && changed === true) effect(nextValue, r);\n        if (firstTime) firstTime = false;\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.reaction = reaction;\nfunction createComputedDecorator(compareStructural) {\n    return createClassPropertyDecorator(function (target, name, _, __, originalDescriptor) {\n        invariant(typeof originalDescriptor !== \"undefined\", getMessage(\"m009\"));\n        invariant(typeof originalDescriptor.get === \"function\", getMessage(\"m010\"));\n        var adm = asObservableObject(target, \"\");\n        defineComputedProperty(adm, name, originalDescriptor.get, originalDescriptor.set, compareStructural, false);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        this.$mobx.values[name].set(value);\n    }, false, false);\n}\nvar computedDecorator = createComputedDecorator(false);\nvar computedStructDecorator = createComputedDecorator(true);\nvar computed = function computed(arg1, arg2, arg3) {\n    if (typeof arg2 === \"string\") {\n        return computedDecorator.apply(null, arguments);\n    }\n    invariant(typeof arg1 === \"function\", getMessage(\"m011\"));\n    invariant(arguments.length < 3, getMessage(\"m012\"));\n    var opts = (typeof arg2 === \"undefined\" ? \"undefined\" : _typeof(arg2)) === \"object\" ? arg2 : {};\n    opts.setter = typeof arg2 === \"function\" ? arg2 : opts.setter;\n    return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || \"\", opts.setter);\n};\nexports.computed = computed;\ncomputed.struct = computedStructDecorator;\nfunction createTransformer(transformer, onCleanup) {\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\n    var objectCache = {};\n    var resetId = globalState.resetId;\n    var Transformer = function (_super) {\n        __extends(Transformer, _super);\n        function Transformer(sourceIdentifier, sourceObject) {\n            var _this = _super.call(this, function () {\n                return transformer(sourceObject);\n            }, undefined, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier, undefined) || this;\n            _this.sourceIdentifier = sourceIdentifier;\n            _this.sourceObject = sourceObject;\n            return _this;\n        }\n        Transformer.prototype.onBecomeUnobserved = function () {\n            var lastValue = this.value;\n            _super.prototype.onBecomeUnobserved.call(this);\n            delete objectCache[this.sourceIdentifier];\n            if (onCleanup) onCleanup(lastValue, this.sourceObject);\n        };\n        return Transformer;\n    }(ComputedValue);\n    return function (object) {\n        if (resetId !== globalState.resetId) {\n            objectCache = {};\n            resetId = globalState.resetId;\n        }\n        var identifier = getMemoizationId(object);\n        var reactiveTransformer = objectCache[identifier];\n        if (reactiveTransformer) return reactiveTransformer.get();\n        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);\n        return reactiveTransformer.get();\n    };\n}\nexports.createTransformer = createTransformer;\nfunction getMemoizationId(object) {\n    if (object === null || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") throw new Error(\"[mobx] transform expected some kind of object, got: \" + object);\n    var tid = object.$transformId;\n    if (tid === undefined) {\n        tid = getNextId();\n        addHiddenProp(object, \"$transformId\", tid);\n    }\n    return tid;\n}\nfunction expr(expr, scope) {\n    if (!isComputingDerivation()) console.warn(getMessage(\"m013\"));\n    return computed(expr, { context: scope }).get();\n}\nexports.expr = expr;\nfunction extendObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, deepEnhancer, properties);\n}\nexports.extendObservable = extendObservable;\nfunction extendShallowObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, referenceEnhancer, properties);\n}\nexports.extendShallowObservable = extendShallowObservable;\nfunction extendObservableHelper(target, defaultEnhancer, properties) {\n    invariant(arguments.length >= 2, getMessage(\"m014\"));\n    invariant((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\", getMessage(\"m015\"));\n    invariant(!isObservableMap(target), getMessage(\"m016\"));\n    properties.forEach(function (propSet) {\n        invariant((typeof propSet === \"undefined\" ? \"undefined\" : _typeof(propSet)) === \"object\", getMessage(\"m017\"));\n        invariant(!isObservable(propSet), getMessage(\"m018\"));\n    });\n    var adm = asObservableObject(target);\n    var definedProps = {};\n    for (var i = properties.length - 1; i >= 0; i--) {\n        var propSet = properties[i];\n        for (var key in propSet) {\n            if (definedProps[key] !== true && hasOwnProperty(propSet, key)) {\n                definedProps[key] = true;\n                if (target === propSet && !isPropertyConfigurable(target, key)) continue;\n                var descriptor = Object.getOwnPropertyDescriptor(propSet, key);\n                defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer);\n            }\n        }\n    }\n    return target;\n}\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree);\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (hasObservers(node)) result.observers = getObservers(node).map(nodeToObserverTree);\n    return result;\n}\nfunction intercept(thing, propOrHandler, handler) {\n    if (typeof handler === \"function\") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);\n}\nexports.intercept = intercept;\nfunction interceptInterceptable(thing, handler) {\n    return getAdministration(thing).intercept(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    return getAdministration(thing, property).intercept(handler);\n}\nfunction isComputed(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableObject(value) === false) return false;\n        var atom = getAtom(value, property);\n        return isComputedValue(atom);\n    }\n    return isComputedValue(value);\n}\nexports.isComputed = isComputed;\nfunction isObservable(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableArray(value) || isObservableMap(value)) throw new Error(getMessage(\"m019\"));else if (isObservableObject(value)) {\n            var o = value.$mobx;\n            return o.values && !!o.values[property];\n        }\n        return false;\n    }\n    return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value);\n}\nexports.isObservable = isObservable;\nvar deepDecorator = createDecoratorForEnhancer(deepEnhancer);\nvar shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);\nvar refDecorator = createDecoratorForEnhancer(referenceEnhancer);\nvar deepStructDecorator = createDecoratorForEnhancer(deepStructEnhancer);\nvar refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);\nfunction createObservable(v) {\n    if (v === void 0) {\n        v = undefined;\n    }\n    if (typeof arguments[1] === \"string\") return deepDecorator.apply(null, arguments);\n    invariant(arguments.length <= 1, getMessage(\"m021\"));\n    invariant(!isModifierDescriptor(v), getMessage(\"m020\"));\n    if (isObservable(v)) return v;\n    var res = deepEnhancer(v, undefined, undefined);\n    if (res !== v) return res;\n    return observable.box(v);\n}\nvar IObservableFactories = function () {\n    function IObservableFactories() {}\n    IObservableFactories.prototype.box = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"box\");\n        return new ObservableValue(value, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowBox = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowBox\");\n        return new ObservableValue(value, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.array = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"array\");\n        return new ObservableArray(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowArray = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowArray\");\n        return new ObservableArray(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.map = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"map\");\n        return new ObservableMap(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowMap = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowMap\");\n        return new ObservableMap(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.object = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"object\");\n        var res = {};\n        asObservableObject(res, name);\n        extendObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.shallowObject = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowObject\");\n        var res = {};\n        asObservableObject(res, name);\n        extendShallowObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.ref = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(referenceEnhancer, arguments[0]);\n        } else {\n            return refDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.shallow = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(shallowEnhancer, arguments[0]);\n        } else {\n            return shallowDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.deep = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepEnhancer, arguments[0]);\n        } else {\n            return deepDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.struct = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepStructEnhancer, arguments[0]);\n        } else {\n            return deepStructDecorator.apply(null, arguments);\n        }\n    };\n    return IObservableFactories;\n}();\nexports.IObservableFactories = IObservableFactories;\nvar observable = createObservable;\nexports.observable = observable;\nObject.keys(IObservableFactories.prototype).forEach(function (key) {\n    return observable[key] = IObservableFactories.prototype[key];\n});\nobservable.deep.struct = observable.struct;\nobservable.ref.struct = function () {\n    if (arguments.length < 2) {\n        return createModifierDescriptor(refStructEnhancer, arguments[0]);\n    } else {\n        return refStructDecorator.apply(null, arguments);\n    }\n};\nfunction incorrectlyUsedAsDecorator(methodName) {\n    fail(\"Expected one or two arguments to observable.\" + methodName + \". Did you accidentally try to use observable.\" + methodName + \" as decorator?\");\n}\nfunction createDecoratorForEnhancer(enhancer) {\n    invariant(!!enhancer, \":(\");\n    return createClassPropertyDecorator(function (target, name, baseValue, _, baseDescriptor) {\n        assertPropertyConfigurable(target, name);\n        invariant(!baseDescriptor || !baseDescriptor.get, getMessage(\"m022\"));\n        var adm = asObservableObject(target, undefined);\n        defineObservableProperty(adm, name, baseValue, enhancer);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        setPropertyValue(this, name, value);\n    }, true, false);\n}\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (typeof cbOrFire === \"function\") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);\n}\nexports.observe = observe;\nfunction observeObservable(thing, listener, fireImmediately) {\n    return getAdministration(thing).observe(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    return getAdministration(thing, property).observe(listener, fireImmediately);\n}\nfunction toJS(source, detectCycles, __alreadySeen) {\n    if (detectCycles === void 0) {\n        detectCycles = true;\n    }\n    if (__alreadySeen === void 0) {\n        __alreadySeen = [];\n    }\n    function cache(value) {\n        if (detectCycles) __alreadySeen.push([source, value]);\n        return value;\n    }\n    if (isObservable(source)) {\n        if (detectCycles && __alreadySeen === null) __alreadySeen = [];\n        if (detectCycles && source !== null && (typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") {\n            for (var i = 0, l = __alreadySeen.length; i < l; i++) {\n                if (__alreadySeen[i][0] === source) return __alreadySeen[i][1];\n            }\n        }\n        if (isObservableArray(source)) {\n            var res = cache([]);\n            var toAdd = source.map(function (value) {\n                return toJS(value, detectCycles, __alreadySeen);\n            });\n            res.length = toAdd.length;\n            for (var i = 0, l = toAdd.length; i < l; i++) {\n                res[i] = toAdd[i];\n            }return res;\n        }\n        if (isObservableObject(source)) {\n            var res = cache({});\n            for (var key in source) {\n                res[key] = toJS(source[key], detectCycles, __alreadySeen);\n            }return res;\n        }\n        if (isObservableMap(source)) {\n            var res_1 = cache({});\n            source.forEach(function (value, key) {\n                return res_1[key] = toJS(value, detectCycles, __alreadySeen);\n            });\n            return res_1;\n        }\n        if (isObservableValue(source)) return toJS(source.get(), detectCycles, __alreadySeen);\n    }\n    return source;\n}\nexports.toJS = toJS;\nfunction transaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    deprecated(getMessage(\"m023\"));\n    return runInTransaction.apply(undefined, arguments);\n}\nexports.transaction = transaction;\nfunction runInTransaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    return executeAction(\"\", action);\n}\nfunction log(msg) {\n    console.log(msg);\n    return msg;\n}\nfunction whyRun(thing, prop) {\n    switch (arguments.length) {\n        case 0:\n            thing = globalState.trackingDerivation;\n            if (!thing) return log(getMessage(\"m024\"));\n            break;\n        case 2:\n            thing = getAtom(thing, prop);\n            break;\n    }\n    thing = getAtom(thing);\n    if (isComputedValue(thing)) return log(thing.whyRun());else if (isReaction(thing)) return log(thing.whyRun());\n    return fail(getMessage(\"m025\"));\n}\nexports.whyRun = whyRun;\nfunction createAction(actionName, fn) {\n    invariant(typeof fn === \"function\", getMessage(\"m026\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    var res = function res() {\n        return executeAction(actionName, fn, this, arguments);\n    };\n    res.originalFn = fn;\n    res.isMobxAction = true;\n    return res;\n}\nfunction executeAction(actionName, fn, scope, args) {\n    var runInfo = startAction(actionName, fn, scope, args);\n    try {\n        return fn.apply(scope, args);\n    } finally {\n        endAction(runInfo);\n    }\n}\nfunction startAction(actionName, fn, scope, args) {\n    var notifySpy = isSpyEnabled() && !!actionName;\n    var startTime = 0;\n    if (notifySpy) {\n        startTime = Date.now();\n        var l = args && args.length || 0;\n        var flattendArgs = new Array(l);\n        if (l > 0) for (var i = 0; i < l; i++) {\n            flattendArgs[i] = args[i];\n        }spyReportStart({\n            type: \"action\",\n            name: actionName,\n            fn: fn,\n            object: scope,\n            arguments: flattendArgs\n        });\n    }\n    var prevDerivation = untrackedStart();\n    startBatch();\n    var prevAllowStateChanges = allowStateChangesStart(true);\n    return {\n        prevDerivation: prevDerivation,\n        prevAllowStateChanges: prevAllowStateChanges,\n        notifySpy: notifySpy,\n        startTime: startTime\n    };\n}\nfunction endAction(runInfo) {\n    allowStateChangesEnd(runInfo.prevAllowStateChanges);\n    endBatch();\n    untrackedEnd(runInfo.prevDerivation);\n    if (runInfo.notifySpy) spyReportEnd({ time: Date.now() - runInfo.startTime });\n}\nfunction useStrict(strict) {\n    invariant(globalState.trackingDerivation === null, getMessage(\"m028\"));\n    globalState.strictMode = strict;\n    globalState.allowStateChanges = !strict;\n}\nexports.useStrict = useStrict;\nfunction isStrictModeEnabled() {\n    return globalState.strictMode;\n}\nexports.isStrictModeEnabled = isStrictModeEnabled;\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    var res;\n    try {\n        res = func();\n    } finally {\n        allowStateChangesEnd(prev);\n    }\n    return res;\n}\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nvar BaseAtom = function () {\n    function BaseAtom(name) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        this.name = name;\n        this.isPendingUnobservation = true;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.NOT_TRACKING;\n    }\n    BaseAtom.prototype.onBecomeUnobserved = function () {};\n    BaseAtom.prototype.reportObserved = function () {\n        reportObserved(this);\n    };\n    BaseAtom.prototype.reportChanged = function () {\n        startBatch();\n        propagateChanged(this);\n        endBatch();\n    };\n    BaseAtom.prototype.toString = function () {\n        return this.name;\n    };\n    return BaseAtom;\n}();\nexports.BaseAtom = BaseAtom;\nvar Atom = function (_super) {\n    __extends(Atom, _super);\n    function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        if (onBecomeObservedHandler === void 0) {\n            onBecomeObservedHandler = noop;\n        }\n        if (onBecomeUnobservedHandler === void 0) {\n            onBecomeUnobservedHandler = noop;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.name = name;\n        _this.onBecomeObservedHandler = onBecomeObservedHandler;\n        _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;\n        _this.isPendingUnobservation = false;\n        _this.isBeingTracked = false;\n        return _this;\n    }\n    Atom.prototype.reportObserved = function () {\n        startBatch();\n        _super.prototype.reportObserved.call(this);\n        if (!this.isBeingTracked) {\n            this.isBeingTracked = true;\n            this.onBecomeObservedHandler();\n        }\n        endBatch();\n        return !!globalState.trackingDerivation;\n    };\n    Atom.prototype.onBecomeUnobserved = function () {\n        this.isBeingTracked = false;\n        this.onBecomeUnobservedHandler();\n    };\n    return Atom;\n}(BaseAtom);\nexports.Atom = Atom;\nvar isAtom = createInstanceofPredicate(\"Atom\", BaseAtom);\nvar ComputedValue = function () {\n    function ComputedValue(derivation, scope, compareStructural, name, setter) {\n        this.derivation = derivation;\n        this.scope = scope;\n        this.compareStructural = compareStructural;\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.observing = [];\n        this.newObserving = null;\n        this.isPendingUnobservation = false;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.runId = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.UP_TO_DATE;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.value = undefined;\n        this.isComputing = false;\n        this.isRunningSetter = false;\n        this.name = name || \"ComputedValue@\" + getNextId();\n        if (setter) this.setter = createAction(name + \"-setter\", setter);\n    }\n    ComputedValue.prototype.onBecomeStale = function () {\n        propagateMaybeChanged(this);\n    };\n    ComputedValue.prototype.onBecomeUnobserved = function () {\n        invariant(this.dependenciesState !== IDerivationState.NOT_TRACKING, getMessage(\"m029\"));\n        clearObserving(this);\n        this.value = undefined;\n    };\n    ComputedValue.prototype.get = function () {\n        invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation);\n        if (globalState.inBatch === 0) {\n            startBatch();\n            if (shouldCompute(this)) this.value = this.computeValue(false);\n            endBatch();\n        } else {\n            reportObserved(this);\n            if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this);\n        }\n        var result = this.value;\n        if (isCaughtException(result)) throw result.cause;\n        return result;\n    };\n    ComputedValue.prototype.peek = function () {\n        var res = this.computeValue(false);\n        if (isCaughtException(res)) throw res.cause;\n        return res;\n    };\n    ComputedValue.prototype.set = function (value) {\n        if (this.setter) {\n            invariant(!this.isRunningSetter, \"The setter of computed value '\" + this.name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\");\n            this.isRunningSetter = true;\n            try {\n                this.setter.call(this.scope, value);\n            } finally {\n                this.isRunningSetter = false;\n            }\n        } else invariant(false, \"[ComputedValue '\" + this.name + \"'] It is not possible to assign a new value to a computed value.\");\n    };\n    ComputedValue.prototype.trackAndCompute = function () {\n        if (isSpyEnabled()) {\n            spyReport({\n                object: this.scope,\n                type: \"compute\",\n                fn: this.derivation\n            });\n        }\n        var oldValue = this.value;\n        var newValue = this.value = this.computeValue(true);\n        return isCaughtException(newValue) || valueDidChange(this.compareStructural, newValue, oldValue);\n    };\n    ComputedValue.prototype.computeValue = function (track) {\n        this.isComputing = true;\n        globalState.computationDepth++;\n        var res;\n        if (track) {\n            res = trackDerivedFunction(this, this.derivation, this.scope);\n        } else {\n            try {\n                res = this.derivation.call(this.scope);\n            } catch (e) {\n                res = new CaughtException(e);\n            }\n        }\n        globalState.computationDepth--;\n        this.isComputing = false;\n        return res;\n    };\n    ;\n    ComputedValue.prototype.observe = function (listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function () {\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener({\n                    type: \"update\",\n                    object: _this,\n                    newValue: newValue,\n                    oldValue: prevValue\n                });\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    ComputedValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ComputedValue.prototype.toString = function () {\n        return this.name + \"[\" + this.derivation.toString() + \"]\";\n    };\n    ComputedValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    ;\n    ComputedValue.prototype.whyRun = function () {\n        var isTracking = Boolean(globalState.trackingDerivation);\n        var observing = unique(this.isComputing ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        var observers = unique(getObservers(this).map(function (dep) {\n            return dep.name;\n        }));\n        return \"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + (isTracking ? \"[active] the value of this computation is needed by a reaction\" : this.isComputing ? \"[get] The value of this computed was requested outside a reaction\" : \"[idle] not running at the moment\") + \"\\n\" + (this.dependenciesState === IDerivationState.NOT_TRACKING ? getMessage(\"m032\") : \" * This computation will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this.isComputing && isTracking ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\\n  * If the outcome of this computation changes, the following observers will be re-run:\\n    \" + joinStrings(observers) + \"\\n\");\n    };\n    return ComputedValue;\n}();\nComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf;\nvar isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue);\nvar IDerivationState;\n(function (IDerivationState) {\n    IDerivationState[IDerivationState[\"NOT_TRACKING\"] = -1] = \"NOT_TRACKING\";\n    IDerivationState[IDerivationState[\"UP_TO_DATE\"] = 0] = \"UP_TO_DATE\";\n    IDerivationState[IDerivationState[\"POSSIBLY_STALE\"] = 1] = \"POSSIBLY_STALE\";\n    IDerivationState[IDerivationState[\"STALE\"] = 2] = \"STALE\";\n})(IDerivationState || (IDerivationState = {}));\nexports.IDerivationState = IDerivationState;\nvar CaughtException = function () {\n    function CaughtException(cause) {\n        this.cause = cause;\n    }\n    return CaughtException;\n}();\nfunction isCaughtException(e) {\n    return e instanceof CaughtException;\n}\nfunction shouldCompute(derivation) {\n    switch (derivation.dependenciesState) {\n        case IDerivationState.UP_TO_DATE:\n            return false;\n        case IDerivationState.NOT_TRACKING:\n        case IDerivationState.STALE:\n            return true;\n        case IDerivationState.POSSIBLY_STALE:\n            {\n                var prevUntracked = untrackedStart();\n                var obs = derivation.observing,\n                    l = obs.length;\n                for (var i = 0; i < l; i++) {\n                    var obj = obs[i];\n                    if (isComputedValue(obj)) {\n                        try {\n                            obj.get();\n                        } catch (e) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                        if (derivation.dependenciesState === IDerivationState.STALE) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                    }\n                }\n                changeDependenciesStateTo0(derivation);\n                untrackedEnd(prevUntracked);\n                return false;\n            }\n    }\n}\nfunction isComputingDerivation() {\n    return globalState.trackingDerivation !== null;\n}\nfunction checkIfStateModificationsAreAllowed(atom) {\n    var hasObservers = atom.observers.length > 0;\n    if (globalState.computationDepth > 0 && hasObservers) fail(getMessage(\"m031\") + atom.name);\n    if (!globalState.allowStateChanges && hasObservers) fail(getMessage(globalState.strictMode ? \"m030a\" : \"m030b\") + atom.name);\n}\nfunction trackDerivedFunction(derivation, f, context) {\n    changeDependenciesStateTo0(derivation);\n    derivation.newObserving = new Array(derivation.observing.length + 100);\n    derivation.unboundDepsCount = 0;\n    derivation.runId = ++globalState.runId;\n    var prevTracking = globalState.trackingDerivation;\n    globalState.trackingDerivation = derivation;\n    var result;\n    try {\n        result = f.call(context);\n    } catch (e) {\n        result = new CaughtException(e);\n    }\n    globalState.trackingDerivation = prevTracking;\n    bindDependencies(derivation);\n    return result;\n}\nfunction bindDependencies(derivation) {\n    var prevObserving = derivation.observing;\n    var observing = derivation.observing = derivation.newObserving;\n    derivation.newObserving = null;\n    var i0 = 0,\n        l = derivation.unboundDepsCount;\n    for (var i = 0; i < l; i++) {\n        var dep = observing[i];\n        if (dep.diffValue === 0) {\n            dep.diffValue = 1;\n            if (i0 !== i) observing[i0] = dep;\n            i0++;\n        }\n    }\n    observing.length = i0;\n    l = prevObserving.length;\n    while (l--) {\n        var dep = prevObserving[l];\n        if (dep.diffValue === 0) {\n            removeObserver(dep, derivation);\n        }\n        dep.diffValue = 0;\n    }\n    while (i0--) {\n        var dep = observing[i0];\n        if (dep.diffValue === 1) {\n            dep.diffValue = 0;\n            addObserver(dep, derivation);\n        }\n    }\n}\nfunction clearObserving(derivation) {\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        removeObserver(obs[i], derivation);\n    }derivation.dependenciesState = IDerivationState.NOT_TRACKING;\n    obs.length = 0;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    var res = action();\n    untrackedEnd(prev);\n    return res;\n}\nexports.untracked = untracked;\nfunction untrackedStart() {\n    var prev = globalState.trackingDerivation;\n    globalState.trackingDerivation = null;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.trackingDerivation = prev;\n}\nfunction changeDependenciesStateTo0(derivation) {\n    if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return;\n    derivation.dependenciesState = IDerivationState.UP_TO_DATE;\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nvar persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"];\nvar MobXGlobals = function () {\n    function MobXGlobals() {\n        this.version = 5;\n        this.trackingDerivation = null;\n        this.computationDepth = 0;\n        this.runId = 0;\n        this.mobxGuid = 0;\n        this.inBatch = 0;\n        this.pendingUnobservations = [];\n        this.pendingReactions = [];\n        this.isRunningReactions = false;\n        this.allowStateChanges = true;\n        this.strictMode = false;\n        this.resetId = 0;\n        this.spyListeners = [];\n        this.globalReactionErrorHandlers = [];\n    }\n    return MobXGlobals;\n}();\nvar globalState = new MobXGlobals();\nfunction shareGlobalState() {\n    var global = getGlobal();\n    var ownState = globalState;\n    if (global.__mobservableTrackingStack || global.__mobservableViewStack) throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\");\n    if (global.__mobxGlobal && global.__mobxGlobal.version !== ownState.version) throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\");\n    if (global.__mobxGlobal) globalState = global.__mobxGlobal;else global.__mobxGlobal = ownState;\n}\nfunction getGlobalState() {\n    return globalState;\n}\nfunction registerGlobals() {}\nfunction resetGlobalState() {\n    globalState.resetId++;\n    var defaultGlobals = new MobXGlobals();\n    for (var key in defaultGlobals) {\n        if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];\n    }globalState.allowStateChanges = !globalState.strictMode;\n}\nfunction hasObservers(observable) {\n    return observable.observers && observable.observers.length > 0;\n}\nfunction getObservers(observable) {\n    return observable.observers;\n}\nfunction invariantObservers(observable) {\n    var list = observable.observers;\n    var map = observable.observersIndexes;\n    var l = list.length;\n    for (var i = 0; i < l; i++) {\n        var id = list[i].__mapid;\n        if (i) {\n            invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\");\n        } else {\n            invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldnt be held in map.\");\n        }\n    }\n    invariant(list.length === 0 || Object.keys(map).length === list.length - 1, \"INTERNAL ERROR there is no junk in map\");\n}\nfunction addObserver(observable, node) {\n    var l = observable.observers.length;\n    if (l) {\n        observable.observersIndexes[node.__mapid] = l;\n    }\n    observable.observers[l] = node;\n    if (observable.lowestObserverState > node.dependenciesState) observable.lowestObserverState = node.dependenciesState;\n}\nfunction removeObserver(observable, node) {\n    if (observable.observers.length === 1) {\n        observable.observers.length = 0;\n        queueForUnobservation(observable);\n    } else {\n        var list = observable.observers;\n        var map_1 = observable.observersIndexes;\n        var filler = list.pop();\n        if (filler !== node) {\n            var index = map_1[node.__mapid] || 0;\n            if (index) {\n                map_1[filler.__mapid] = index;\n            } else {\n                delete map_1[filler.__mapid];\n            }\n            list[index] = filler;\n        }\n        delete map_1[node.__mapid];\n    }\n}\nfunction queueForUnobservation(observable) {\n    if (!observable.isPendingUnobservation) {\n        observable.isPendingUnobservation = true;\n        globalState.pendingUnobservations.push(observable);\n    }\n}\nfunction startBatch() {\n    globalState.inBatch++;\n}\nfunction endBatch() {\n    if (--globalState.inBatch === 0) {\n        runReactions();\n        var list = globalState.pendingUnobservations;\n        for (var i = 0; i < list.length; i++) {\n            var observable_1 = list[i];\n            observable_1.isPendingUnobservation = false;\n            if (observable_1.observers.length === 0) {\n                observable_1.onBecomeUnobserved();\n            }\n        }\n        globalState.pendingUnobservations = [];\n    }\n}\nfunction reportObserved(observable) {\n    var derivation = globalState.trackingDerivation;\n    if (derivation !== null) {\n        if (derivation.runId !== observable.lastAccessedBy) {\n            observable.lastAccessedBy = derivation.runId;\n            derivation.newObserving[derivation.unboundDepsCount++] = observable;\n        }\n    } else if (observable.observers.length === 0) {\n        queueForUnobservation(observable);\n    }\n}\nfunction invariantLOS(observable, msg) {\n    var min = getObservers(observable).reduce(function (a, b) {\n        return Math.min(a, b.dependenciesState);\n    }, 2);\n    if (min >= observable.lowestObserverState) return;\n    throw new Error(\"lowestObserverState is wrong for \" + msg + \" because \" + min + \" < \" + observable.lowestObserverState);\n}\nfunction propagateChanged(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale();\n        d.dependenciesState = IDerivationState.STALE;\n    }\n}\nfunction propagateChangeConfirmed(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.POSSIBLY_STALE) d.dependenciesState = IDerivationState.STALE;else if (d.dependenciesState === IDerivationState.UP_TO_DATE) observable.lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nfunction propagateMaybeChanged(observable) {\n    if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return;\n    observable.lowestObserverState = IDerivationState.POSSIBLY_STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {\n            d.dependenciesState = IDerivationState.POSSIBLY_STALE;\n            d.onBecomeStale();\n        }\n    }\n}\nvar Reaction = function () {\n    function Reaction(name, onInvalidate) {\n        if (name === void 0) {\n            name = \"Reaction@\" + getNextId();\n        }\n        this.name = name;\n        this.onInvalidate = onInvalidate;\n        this.observing = [];\n        this.newObserving = [];\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.diffValue = 0;\n        this.runId = 0;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.isDisposed = false;\n        this._isScheduled = false;\n        this._isTrackPending = false;\n        this._isRunning = false;\n    }\n    Reaction.prototype.onBecomeStale = function () {\n        this.schedule();\n    };\n    Reaction.prototype.schedule = function () {\n        if (!this._isScheduled) {\n            this._isScheduled = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    };\n    Reaction.prototype.isScheduled = function () {\n        return this._isScheduled;\n    };\n    Reaction.prototype.runReaction = function () {\n        if (!this.isDisposed) {\n            startBatch();\n            this._isScheduled = false;\n            if (shouldCompute(this)) {\n                this._isTrackPending = true;\n                this.onInvalidate();\n                if (this._isTrackPending && isSpyEnabled()) {\n                    spyReport({\n                        object: this,\n                        type: \"scheduled-reaction\"\n                    });\n                }\n            }\n            endBatch();\n        }\n    };\n    Reaction.prototype.track = function (fn) {\n        startBatch();\n        var notify = isSpyEnabled();\n        var startTime;\n        if (notify) {\n            startTime = Date.now();\n            spyReportStart({\n                object: this,\n                type: \"reaction\",\n                fn: fn\n            });\n        }\n        this._isRunning = true;\n        var result = trackDerivedFunction(this, fn, undefined);\n        this._isRunning = false;\n        this._isTrackPending = false;\n        if (this.isDisposed) {\n            clearObserving(this);\n        }\n        if (isCaughtException(result)) this.reportExceptionInDerivation(result.cause);\n        if (notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n        endBatch();\n    };\n    Reaction.prototype.reportExceptionInDerivation = function (error) {\n        var _this = this;\n        if (this.errorHandler) {\n            this.errorHandler(error, this);\n            return;\n        }\n        var message = \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this;\n        var messageToUser = getMessage(\"m037\");\n        console.error(message || messageToUser, error);\n        if (isSpyEnabled()) {\n            spyReport({\n                type: \"error\",\n                message: message,\n                error: error,\n                object: this\n            });\n        }\n        globalState.globalReactionErrorHandlers.forEach(function (f) {\n            return f(error, _this);\n        });\n    };\n    Reaction.prototype.dispose = function () {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            if (!this._isRunning) {\n                startBatch();\n                clearObserving(this);\n                endBatch();\n            }\n        }\n    };\n    Reaction.prototype.getDisposer = function () {\n        var r = this.dispose.bind(this);\n        r.$mobx = this;\n        r.onError = registerErrorHandler;\n        return r;\n    };\n    Reaction.prototype.toString = function () {\n        return \"Reaction[\" + this.name + \"]\";\n    };\n    Reaction.prototype.whyRun = function () {\n        var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        return \"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this._isRunning ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\";\n    };\n    return Reaction;\n}();\nexports.Reaction = Reaction;\nfunction registerErrorHandler(handler) {\n    invariant(this && this.$mobx && isReaction(this.$mobx), \"Invalid `this`\");\n    invariant(!this.$mobx.errorHandler, \"Only one onErrorHandler can be registered\");\n    this.$mobx.errorHandler = handler;\n}\nfunction onReactionError(handler) {\n    globalState.globalReactionErrorHandlers.push(handler);\n    return function () {\n        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n        if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);\n    };\n}\nvar MAX_REACTION_ITERATIONS = 100;\nvar reactionScheduler = function reactionScheduler(f) {\n    return f();\n};\nfunction runReactions() {\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) return;\n    reactionScheduler(runReactionsHelper);\n}\nfunction runReactionsHelper() {\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    while (allReactions.length > 0) {\n        if (++iterations === MAX_REACTION_ITERATIONS) {\n            console.error(\"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0]));\n            allReactions.splice(0);\n        }\n        var remainingReactions = allReactions.splice(0);\n        for (var i = 0, l = remainingReactions.length; i < l; i++) {\n            remainingReactions[i].runReaction();\n        }\n    }\n    globalState.isRunningReactions = false;\n}\nvar isReaction = createInstanceofPredicate(\"Reaction\", Reaction);\nfunction setReactionScheduler(fn) {\n    var baseScheduler = reactionScheduler;\n    reactionScheduler = function reactionScheduler(f) {\n        return fn(function () {\n            return baseScheduler(f);\n        });\n    };\n}\nfunction isSpyEnabled() {\n    return !!globalState.spyListeners.length;\n}\nfunction spyReport(event) {\n    if (!globalState.spyListeners.length) return;\n    var listeners = globalState.spyListeners;\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](event);\n    }\n}\nfunction spyReportStart(event) {\n    var change = objectAssign({}, event, { spyReportStart: true });\n    spyReport(change);\n}\nvar END_EVENT = { spyReportEnd: true };\nfunction spyReportEnd(change) {\n    if (change) spyReport(objectAssign({}, change, END_EVENT));else spyReport(END_EVENT);\n}\nfunction spy(listener) {\n    globalState.spyListeners.push(listener);\n    return once(function () {\n        var idx = globalState.spyListeners.indexOf(listener);\n        if (idx !== -1) globalState.spyListeners.splice(idx, 1);\n    });\n}\nexports.spy = spy;\nfunction hasInterceptors(interceptable) {\n    return interceptable.interceptors && interceptable.interceptors.length > 0;\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);\n    interceptors.push(handler);\n    return once(function () {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1) interceptors.splice(idx, 1);\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    try {\n        var interceptors = interceptable.interceptors;\n        if (interceptors) for (var i = 0, l = interceptors.length; i < l; i++) {\n            change = interceptors[i](change);\n            invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\");\n            if (!change) break;\n        }\n        return change;\n    } finally {\n        untrackedEnd(prevU);\n    }\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners && listenable.changeListeners.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners || (listenable.changeListeners = []);\n    listeners.push(handler);\n    return once(function () {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1) listeners.splice(idx, 1);\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners;\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](change);\n    }\n    untrackedEnd(prevU);\n}\nfunction asReference(value) {\n    deprecated(\"asReference is deprecated, use observable.ref instead\");\n    return observable.ref(value);\n}\nexports.asReference = asReference;\nfunction asStructure(value) {\n    deprecated(\"asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.\");\n    return observable.struct(value);\n}\nexports.asStructure = asStructure;\nfunction asFlat(value) {\n    deprecated(\"asFlat is deprecated, use observable.shallow instead\");\n    return observable.shallow(value);\n}\nexports.asFlat = asFlat;\nfunction asMap(data) {\n    deprecated(\"asMap is deprecated, use observable.map or observable.shallowMap instead\");\n    return observable.map(data || {});\n}\nexports.asMap = asMap;\nfunction isModifierDescriptor(thing) {\n    return (typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null && thing.isMobxModifierDescriptor === true;\n}\nexports.isModifierDescriptor = isModifierDescriptor;\nfunction createModifierDescriptor(enhancer, initialValue) {\n    invariant(!isModifierDescriptor(initialValue), \"Modifiers cannot be nested\");\n    return {\n        isMobxModifierDescriptor: true,\n        initialValue: initialValue,\n        enhancer: enhancer\n    };\n}\nfunction deepEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return observable.array(v, name);\n    if (isPlainObject(v)) return observable.object(v, name);\n    if (isES6Map(v)) return observable.map(v, name);\n    return v;\n}\nfunction shallowEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (v === undefined || v === null) return v;\n    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v)) return v;\n    if (Array.isArray(v)) return observable.shallowArray(v, name);\n    if (isPlainObject(v)) return observable.shallowObject(v, name);\n    if (isES6Map(v)) return observable.shallowMap(v, name);\n    return fail(\"The shallow modifier / decorator can only used in combination with arrays, objects and maps\");\n}\nfunction referenceEnhancer(newValue) {\n    return newValue;\n}\nfunction deepStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return new ObservableArray(v, deepStructEnhancer, name);\n    if (isES6Map(v)) return new ObservableMap(v, deepStructEnhancer, name);\n    if (isPlainObject(v)) {\n        var res = {};\n        asObservableObject(res, name);\n        extendObservableHelper(res, deepStructEnhancer, [v]);\n        return res;\n    }\n    return v;\n}\nfunction refStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    return v;\n}\nvar MAX_SPLICE_SIZE = 10000;\nvar safariPrototypeSetterInheritanceBug = function () {\n    var v = false;\n    var p = {};\n    Object.defineProperty(p, \"0\", { set: function set() {\n            v = true;\n        } });\n    Object.create(p)[\"0\"] = 1;\n    return v === false;\n}();\nvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\nvar StubArray = function () {\n    function StubArray() {}\n    return StubArray;\n}();\nStubArray.prototype = [];\nvar ObservableArrayAdministration = function () {\n    function ObservableArrayAdministration(name, enhancer, array, owned) {\n        this.array = array;\n        this.owned = owned;\n        this.lastKnownLength = 0;\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.atom = new BaseAtom(name || \"ObservableArray@\" + getNextId());\n        this.enhancer = function (newV, oldV) {\n            return enhancer(newV, oldV, name + \"[..]\");\n        };\n    }\n    ObservableArrayAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        if (fireImmediately) {\n            listener({\n                object: this.array,\n                type: \"splice\",\n                index: 0,\n                added: this.values.slice(),\n                addedCount: this.values.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    ObservableArrayAdministration.prototype.getArrayLength = function () {\n        this.atom.reportObserved();\n        return this.values.length;\n    };\n    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {\n        if (typeof newLength !== \"number\" || newLength < 0) throw new Error(\"[mobx.array] Out of range: \" + newLength);\n        var currentLength = this.values.length;\n        if (newLength === currentLength) return;else if (newLength > currentLength) {\n            var newItems = new Array(newLength - currentLength);\n            for (var i = 0; i < newLength - currentLength; i++) {\n                newItems[i] = undefined;\n            }this.spliceWithArray(currentLength, 0, newItems);\n        } else this.spliceWithArray(newLength, currentLength - newLength);\n    };\n    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {\n        if (oldLength !== this.lastKnownLength) throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\");\n        this.lastKnownLength += delta;\n        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1);\n    };\n    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        var _this = this;\n        checkIfStateModificationsAreAllowed(this.atom);\n        var length = this.values.length;\n        if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);\n        if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        if (newItems === undefined) newItems = [];\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.array,\n                type: \"splice\",\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change) return EMPTY_ARRAY;\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.map(function (v) {\n            return _this.enhancer(v, undefined);\n        });\n        var lengthDelta = newItems.length - deleteCount;\n        this.updateArrayLength(length, lengthDelta);\n        var res = this.spliceItemsIntoValues(index, deleteCount, newItems);\n        if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res);\n        return res;\n    };\n    ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) {\n        if (newItems.length < MAX_SPLICE_SIZE) {\n            return (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));\n        } else {\n            var res = this.values.slice(index, index + deleteCount);\n            this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount));\n            return res;\n        }\n        var _a;\n    };\n    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"update\",\n            index: index, newValue: newValue, oldValue: oldValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"splice\",\n            index: index, removed: removed, added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    return ObservableArrayAdministration;\n}();\nvar ObservableArray = function (_super) {\n    __extends(ObservableArray, _super);\n    function ObservableArray(initialValues, enhancer, name, owned) {\n        if (name === void 0) {\n            name = \"ObservableArray@\" + getNextId();\n        }\n        if (owned === void 0) {\n            owned = false;\n        }\n        var _this = _super.call(this) || this;\n        var adm = new ObservableArrayAdministration(name, enhancer, _this, owned);\n        addHiddenFinalProp(_this, \"$mobx\", adm);\n        if (initialValues && initialValues.length) {\n            adm.updateArrayLength(0, initialValues.length);\n            adm.values = initialValues.map(function (v) {\n                return enhancer(v, undefined, name + \"[..]\");\n            });\n            adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY);\n        } else {\n            adm.values = [];\n        }\n        if (safariPrototypeSetterInheritanceBug) {\n            Object.defineProperty(adm.array, \"0\", ENTRY_0);\n        }\n        return _this;\n    }\n    ObservableArray.prototype.intercept = function (handler) {\n        return this.$mobx.intercept(handler);\n    };\n    ObservableArray.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        return this.$mobx.observe(listener, fireImmediately);\n    };\n    ObservableArray.prototype.clear = function () {\n        return this.splice(0);\n    };\n    ObservableArray.prototype.concat = function () {\n        var arrays = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            arrays[_i] = arguments[_i];\n        }\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) {\n            return isObservableArray(a) ? a.peek() : a;\n        }));\n    };\n    ObservableArray.prototype.replace = function (newItems) {\n        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);\n    };\n    ObservableArray.prototype.toJS = function () {\n        return this.slice();\n    };\n    ObservableArray.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableArray.prototype.peek = function () {\n        return this.$mobx.values;\n    };\n    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {\n        if (fromIndex === void 0) {\n            fromIndex = 0;\n        }\n        this.$mobx.atom.reportObserved();\n        var items = this.$mobx.values,\n            l = items.length;\n        for (var i = fromIndex; i < l; i++) {\n            if (predicate.call(thisArg, items[i], i, this)) return items[i];\n        }return undefined;\n    };\n    ObservableArray.prototype.splice = function (index, deleteCount) {\n        var newItems = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            newItems[_i - 2] = arguments[_i];\n        }\n        switch (arguments.length) {\n            case 0:\n                return [];\n            case 1:\n                return this.$mobx.spliceWithArray(index);\n            case 2:\n                return this.$mobx.spliceWithArray(index, deleteCount);\n        }\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.push = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(adm.values.length, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.pop = function () {\n        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];\n    };\n    ObservableArray.prototype.shift = function () {\n        return this.splice(0, 1)[0];\n    };\n    ObservableArray.prototype.unshift = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(0, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.reverse = function () {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.reverse.apply(clone, arguments);\n    };\n    ObservableArray.prototype.sort = function (compareFn) {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.sort.apply(clone, arguments);\n    };\n    ObservableArray.prototype.remove = function (value) {\n        var idx = this.$mobx.values.indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    };\n    ObservableArray.prototype.move = function (fromIndex, toIndex) {\n        function checkIndex(index) {\n            if (index < 0) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\n            }\n            var length = this.$mobx.values.length;\n            if (index >= length) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\n            }\n        }\n        checkIndex.call(this, fromIndex);\n        checkIndex.call(this, toIndex);\n        if (fromIndex === toIndex) {\n            return;\n        }\n        var oldItems = this.$mobx.values;\n        var newItems;\n        if (fromIndex < toIndex) {\n            newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1));\n        } else {\n            newItems = oldItems.slice(0, toIndex).concat([oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\n        }\n        this.replace(newItems);\n    };\n    ObservableArray.prototype.toString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toString.apply(this.$mobx.values, arguments);\n    };\n    ObservableArray.prototype.toLocaleString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toLocaleString.apply(this.$mobx.values, arguments);\n    };\n    return ObservableArray;\n}(StubArray);\ndeclareIterator(ObservableArray.prototype, function () {\n    return arrayAsIterator(this.slice());\n});\nmakeNonEnumerable(ObservableArray.prototype, [\"constructor\", \"intercept\", \"observe\", \"clear\", \"concat\", \"replace\", \"toJS\", \"toJSON\", \"peek\", \"find\", \"splice\", \"spliceWithArray\", \"push\", \"pop\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"remove\", \"move\", \"toString\", \"toLocaleString\"]);\nObject.defineProperty(ObservableArray.prototype, \"length\", {\n    enumerable: false,\n    configurable: true,\n    get: function get() {\n        return this.$mobx.getArrayLength();\n    },\n    set: function set(newLength) {\n        this.$mobx.setArrayLength(newLength);\n    }\n});\n[\"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function (funcName) {\n    var baseFunc = Array.prototype[funcName];\n    invariant(typeof baseFunc === \"function\", \"Base function not defined on Array prototype: '\" + funcName + \"'\");\n    addHiddenProp(ObservableArray.prototype, funcName, function () {\n        this.$mobx.atom.reportObserved();\n        return baseFunc.apply(this.$mobx.values, arguments);\n    });\n});\nvar ENTRY_0 = {\n    configurable: true,\n    enumerable: false,\n    set: createArraySetter(0),\n    get: createArrayGetter(0)\n};\nfunction createArrayBufferItem(index) {\n    var set = createArraySetter(index);\n    var get = createArrayGetter(index);\n    Object.defineProperty(ObservableArray.prototype, \"\" + index, {\n        enumerable: false,\n        configurable: true,\n        set: set, get: get\n    });\n}\nfunction createArraySetter(index) {\n    return function (newValue) {\n        var adm = this.$mobx;\n        var values = adm.values;\n        if (index < values.length) {\n            checkIfStateModificationsAreAllowed(adm.atom);\n            var oldValue = values[index];\n            if (hasInterceptors(adm)) {\n                var change = interceptChange(adm, {\n                    type: \"update\",\n                    object: adm.array,\n                    index: index, newValue: newValue\n                });\n                if (!change) return;\n                newValue = change.newValue;\n            }\n            newValue = adm.enhancer(newValue, oldValue);\n            var changed = newValue !== oldValue;\n            if (changed) {\n                values[index] = newValue;\n                adm.notifyArrayChildUpdate(index, newValue, oldValue);\n            }\n        } else if (index === values.length) {\n            adm.spliceWithArray(index, 0, [newValue]);\n        } else throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length);\n    };\n}\nfunction createArrayGetter(index) {\n    return function () {\n        var impl = this.$mobx;\n        if (impl) {\n            if (index < impl.values.length) {\n                impl.atom.reportObserved();\n                return impl.values[index];\n            }\n            console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\");\n        }\n        return undefined;\n    };\n}\nfunction reserveArrayBuffer(max) {\n    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) {\n        createArrayBufferItem(index);\n    }OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n}\nreserveArrayBuffer(1000);\nvar isObservableArrayAdministration = createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\nfunction isObservableArray(thing) {\n    return isObject(thing) && isObservableArrayAdministration(thing.$mobx);\n}\nexports.isObservableArray = isObservableArray;\nvar ObservableMapMarker = {};\nvar ObservableMap = function () {\n    function ObservableMap(initialData, enhancer, name) {\n        if (enhancer === void 0) {\n            enhancer = deepEnhancer;\n        }\n        if (name === void 0) {\n            name = \"ObservableMap@\" + getNextId();\n        }\n        this.enhancer = enhancer;\n        this.name = name;\n        this.$mobx = ObservableMapMarker;\n        this._data = {};\n        this._hasMap = {};\n        this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + \".keys()\", true);\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.merge(initialData);\n    }\n    ObservableMap.prototype._has = function (key) {\n        return typeof this._data[key] !== \"undefined\";\n    };\n    ObservableMap.prototype.has = function (key) {\n        if (!this.isValidKey(key)) return false;\n        key = \"\" + key;\n        if (this._hasMap[key]) return this._hasMap[key].get();\n        return this._updateHasMapEntry(key, false).get();\n    };\n    ObservableMap.prototype.set = function (key, value) {\n        this.assertValidKey(key);\n        key = \"\" + key;\n        var hasKey = this._has(key);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? \"update\" : \"add\",\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change) return this;\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this._updateValue(key, value);\n        } else {\n            this._addValue(key, value);\n        }\n        return this;\n    };\n    ObservableMap.prototype.delete = function (key) {\n        var _this = this;\n        this.assertValidKey(key);\n        key = \"\" + key;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: \"delete\",\n                object: this,\n                name: key\n            });\n            if (!change) return false;\n        }\n        if (this._has(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"delete\",\n                object: this,\n                oldValue: this._data[key].value,\n                name: key\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            runInTransaction(function () {\n                _this._keys.remove(key);\n                _this._updateHasMapEntry(key, false);\n                var observable = _this._data[key];\n                observable.setNewValue(undefined);\n                _this._data[key] = undefined;\n            });\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n            return true;\n        }\n        return false;\n    };\n    ObservableMap.prototype._updateHasMapEntry = function (key, value) {\n        var entry = this._hasMap[key];\n        if (entry) {\n            entry.setNewValue(value);\n        } else {\n            entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + \".\" + key + \"?\", false);\n        }\n        return entry;\n    };\n    ObservableMap.prototype._updateValue = function (name, newValue) {\n        var observable = this._data[name];\n        newValue = observable.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"update\",\n                object: this,\n                oldValue: observable.value,\n                name: name, newValue: newValue\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            observable.setNewValue(newValue);\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableMap.prototype._addValue = function (name, newValue) {\n        var _this = this;\n        runInTransaction(function () {\n            var observable = _this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + \".\" + name, false);\n            newValue = observable.value;\n            _this._updateHasMapEntry(name, true);\n            _this._keys.push(name);\n        });\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            type: \"add\",\n            object: this,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableMap.prototype.get = function (key) {\n        key = \"\" + key;\n        if (this.has(key)) return this._data[key].get();\n        return undefined;\n    };\n    ObservableMap.prototype.keys = function () {\n        return arrayAsIterator(this._keys.slice());\n    };\n    ObservableMap.prototype.values = function () {\n        return arrayAsIterator(this._keys.map(this.get, this));\n    };\n    ObservableMap.prototype.entries = function () {\n        var _this = this;\n        return arrayAsIterator(this._keys.map(function (key) {\n            return [key, _this.get(key)];\n        }));\n    };\n    ObservableMap.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        this.keys().forEach(function (key) {\n            return callback.call(thisArg, _this.get(key), key, _this);\n        });\n    };\n    ObservableMap.prototype.merge = function (other) {\n        var _this = this;\n        if (isObservableMap(other)) {\n            other = other.toJS();\n        }\n        runInTransaction(function () {\n            if (isPlainObject(other)) Object.keys(other).forEach(function (key) {\n                return _this.set(key, other[key]);\n            });else if (Array.isArray(other)) other.forEach(function (_a) {\n                var key = _a[0],\n                    value = _a[1];\n                return _this.set(key, value);\n            });else if (isES6Map(other)) other.forEach(function (value, key) {\n                return _this.set(key, value);\n            });else if (other !== null && other !== undefined) fail(\"Cannot initialize map from \" + other);\n        });\n        return this;\n    };\n    ObservableMap.prototype.clear = function () {\n        var _this = this;\n        runInTransaction(function () {\n            untracked(function () {\n                _this.keys().forEach(_this.delete, _this);\n            });\n        });\n    };\n    ObservableMap.prototype.replace = function (values) {\n        var _this = this;\n        runInTransaction(function () {\n            _this.clear();\n            _this.merge(values);\n        });\n        return this;\n    };\n    Object.defineProperty(ObservableMap.prototype, \"size\", {\n        get: function get() {\n            return this._keys.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObservableMap.prototype.toJS = function () {\n        var _this = this;\n        var res = {};\n        this.keys().forEach(function (key) {\n            return res[key] = _this.get(key);\n        });\n        return res;\n    };\n    ObservableMap.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableMap.prototype.isValidKey = function (key) {\n        if (key === null || key === undefined) return false;\n        if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"boolean\") return true;\n        return false;\n    };\n    ObservableMap.prototype.assertValidKey = function (key) {\n        if (!this.isValidKey(key)) throw new Error(\"[mobx.map] Invalid key: '\" + key + \"', only strings, numbers and booleans are accepted as key in observable maps.\");\n    };\n    ObservableMap.prototype.toString = function () {\n        var _this = this;\n        return this.name + \"[{ \" + this.keys().map(function (key) {\n            return key + \": \" + (\"\" + _this.get(key));\n        }).join(\", \") + \" }]\";\n    };\n    ObservableMap.prototype.observe = function (listener, fireImmediately) {\n        invariant(fireImmediately !== true, getMessage(\"m033\"));\n        return registerListener(this, listener);\n    };\n    ObservableMap.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableMap;\n}();\nexports.ObservableMap = ObservableMap;\ndeclareIterator(ObservableMap.prototype, function () {\n    return this.entries();\n});\nfunction map(initialValues) {\n    deprecated(\"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\");\n    return observable.map(initialValues);\n}\nexports.map = map;\nvar isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap);\nexports.isObservableMap = isObservableMap;\nvar ObservableObjectAdministration = function () {\n    function ObservableObjectAdministration(target, name) {\n        this.target = target;\n        this.name = name;\n        this.values = {};\n        this.changeListeners = null;\n        this.interceptors = null;\n    }\n    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {\n        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\");\n        return registerListener(this, callback);\n    };\n    ObservableObjectAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableObjectAdministration;\n}();\nfunction asObservableObject(target, name) {\n    if (isObservableObject(target)) return target.$mobx;\n    invariant(Object.isExtensible(target), getMessage(\"m035\"));\n    if (!isPlainObject(target)) name = (target.constructor.name || \"ObservableObject\") + \"@\" + getNextId();\n    if (!name) name = \"ObservableObject@\" + getNextId();\n    var adm = new ObservableObjectAdministration(target, name);\n    addHiddenFinalProp(target, \"$mobx\", adm);\n    return adm;\n}\nfunction defineObservablePropertyFromDescriptor(adm, propName, descriptor, defaultEnhancer) {\n    if (adm.values[propName]) {\n        invariant(\"value\" in descriptor, \"The property \" + propName + \" in \" + adm.name + \" is already observable, cannot redefine it as computed property\");\n        adm.target[propName] = descriptor.value;\n        return;\n    }\n    if (\"value\" in descriptor) {\n        if (isModifierDescriptor(descriptor.value)) {\n            var modifierDescriptor = descriptor.value;\n            defineObservableProperty(adm, propName, modifierDescriptor.initialValue, modifierDescriptor.enhancer);\n        } else if (isAction(descriptor.value) && descriptor.value.autoBind === true) {\n            defineBoundAction(adm.target, propName, descriptor.value.originalFn);\n        } else if (isComputedValue(descriptor.value)) {\n            defineComputedPropertyFromComputedValue(adm, propName, descriptor.value);\n        } else {\n            defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer);\n        }\n    } else {\n        defineComputedProperty(adm, propName, descriptor.get, descriptor.set, false, true);\n    }\n}\nfunction defineObservableProperty(adm, propName, newValue, enhancer) {\n    assertPropertyConfigurable(adm.target, propName);\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            object: adm.target,\n            name: propName,\n            type: \"add\",\n            newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    var observable = adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + \".\" + propName, false);\n    newValue = observable.value;\n    Object.defineProperty(adm.target, propName, generateObservablePropConfig(propName));\n    notifyPropertyAddition(adm, adm.target, propName, newValue);\n}\nfunction defineComputedProperty(adm, propName, getter, setter, compareStructural, asInstanceProperty) {\n    if (asInstanceProperty) assertPropertyConfigurable(adm.target, propName);\n    adm.values[propName] = new ComputedValue(getter, adm.target, compareStructural, adm.name + \".\" + propName, setter);\n    if (asInstanceProperty) {\n        Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n    }\n}\nfunction defineComputedPropertyFromComputedValue(adm, propName, computedValue) {\n    var name = adm.name + \".\" + propName;\n    computedValue.name = name;\n    if (!computedValue.scope) computedValue.scope = adm.target;\n    adm.values[propName] = computedValue;\n    Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n}\nvar observablePropertyConfigs = {};\nvar computedPropertyConfigs = {};\nfunction generateObservablePropConfig(propName) {\n    return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            setPropertyValue(this, propName, v);\n        }\n    });\n}\nfunction generateComputedPropConfig(propName) {\n    return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: false,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            return this.$mobx.values[propName].set(v);\n        }\n    });\n}\nfunction setPropertyValue(instance, name, newValue) {\n    var adm = instance.$mobx;\n    var observable = adm.values[name];\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            type: \"update\",\n            object: instance,\n            name: name, newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    newValue = observable.prepareNewValue(newValue);\n    if (newValue !== UNCHANGED) {\n        var notify = hasListeners(adm);\n        var notifySpy = isSpyEnabled();\n        var change = notify || notifySpy ? {\n            type: \"update\",\n            object: instance,\n            oldValue: observable.value,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        observable.setNewValue(newValue);\n        if (notify) notifyListeners(adm, change);\n        if (notifySpy) spyReportEnd();\n    }\n}\nfunction notifyPropertyAddition(adm, object, name, newValue) {\n    var notify = hasListeners(adm);\n    var notifySpy = isSpyEnabled();\n    var change = notify || notifySpy ? {\n        type: \"add\",\n        object: object, name: name, newValue: newValue\n    } : null;\n    if (notifySpy) spyReportStart(change);\n    if (notify) notifyListeners(adm, change);\n    if (notifySpy) spyReportEnd();\n}\nvar isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\nfunction isObservableObject(thing) {\n    if (isObject(thing)) {\n        runLazyInitializers(thing);\n        return isObservableObjectAdministration(thing.$mobx);\n    }\n    return false;\n}\nexports.isObservableObject = isObservableObject;\nvar UNCHANGED = {};\nvar ObservableValue = function (_super) {\n    __extends(ObservableValue, _super);\n    function ObservableValue(value, enhancer, name, notifySpy) {\n        if (name === void 0) {\n            name = \"ObservableValue@\" + getNextId();\n        }\n        if (notifySpy === void 0) {\n            notifySpy = true;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.enhancer = enhancer;\n        _this.hasUnreportedChange = false;\n        _this.value = enhancer(value, undefined, name);\n        if (notifySpy && isSpyEnabled()) {\n            spyReport({ type: \"create\", object: _this, newValue: _this.value });\n        }\n        return _this;\n    }\n    ObservableValue.prototype.set = function (newValue) {\n        var oldValue = this.value;\n        newValue = this.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if (notifySpy) {\n                spyReportStart({\n                    type: \"update\",\n                    object: this,\n                    newValue: newValue, oldValue: oldValue\n                });\n            }\n            this.setNewValue(newValue);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableValue.prototype.prepareNewValue = function (newValue) {\n        checkIfStateModificationsAreAllowed(this);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue });\n            if (!change) return UNCHANGED;\n            newValue = change.newValue;\n        }\n        newValue = this.enhancer(newValue, this.value, this.name);\n        return this.value !== newValue ? newValue : UNCHANGED;\n    };\n    ObservableValue.prototype.setNewValue = function (newValue) {\n        var oldValue = this.value;\n        this.value = newValue;\n        this.reportChanged();\n        if (hasListeners(this)) {\n            notifyListeners(this, {\n                type: \"update\",\n                object: this,\n                newValue: newValue,\n                oldValue: oldValue\n            });\n        }\n    };\n    ObservableValue.prototype.get = function () {\n        this.reportObserved();\n        return this.value;\n    };\n    ObservableValue.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableValue.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately) listener({\n            object: this,\n            type: \"update\",\n            newValue: this.value,\n            oldValue: undefined\n        });\n        return registerListener(this, listener);\n    };\n    ObservableValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ObservableValue.prototype.toString = function () {\n        return this.name + \"[\" + this.value + \"]\";\n    };\n    ObservableValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    return ObservableValue;\n}(BaseAtom);\nObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf;\nvar isObservableValue = createInstanceofPredicate(\"ObservableValue\", ObservableValue);\nexports.isBoxedObservable = isObservableValue;\nfunction getAtom(thing, property) {\n    if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            invariant(property === undefined, getMessage(\"m036\"));\n            return thing.$mobx.atom;\n        }\n        if (isObservableMap(thing)) {\n            var anyThing = thing;\n            if (property === undefined) return getAtom(anyThing._keys);\n            var observable_2 = anyThing._data[property] || anyThing._hasMap[property];\n            invariant(!!observable_2, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\");\n            return observable_2;\n        }\n        runLazyInitializers(thing);\n        if (isObservableObject(thing)) {\n            if (!property) return fail(\"please specify a property\");\n            var observable_3 = thing.$mobx.values[property];\n            invariant(!!observable_3, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\");\n            return observable_3;\n        }\n        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n            return thing;\n        }\n    } else if (typeof thing === \"function\") {\n        if (isReaction(thing.$mobx)) {\n            return thing.$mobx;\n        }\n    }\n    return fail(\"Cannot obtain atom from \" + thing);\n}\nfunction getAdministration(thing, property) {\n    invariant(thing, \"Expecting some object\");\n    if (property !== undefined) return getAdministration(getAtom(thing, property));\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;\n    if (isObservableMap(thing)) return thing;\n    runLazyInitializers(thing);\n    if (thing.$mobx) return thing.$mobx;\n    invariant(false, \"Cannot obtain administration from \" + thing);\n}\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing)) named = getAdministration(thing);else named = getAtom(thing);\n    return named.name;\n}\nfunction createClassPropertyDecorator(onInitialize, _get, _set, enumerable, allowCustomArguments) {\n    function classPropertyDecorator(target, key, descriptor, customArgs, argLen) {\n        if (argLen === void 0) {\n            argLen = 0;\n        }\n        invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\");\n        if (!descriptor) {\n            var newDescriptor = {\n                enumerable: enumerable,\n                configurable: true,\n                get: function get() {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {\n                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);\n                    } else {\n                        _set.call(this, key, v);\n                    }\n                }\n            };\n            if (arguments.length < 3 || arguments.length === 5 && argLen < 3) {\n                Object.defineProperty(target, key, newDescriptor);\n            }\n            return newDescriptor;\n        } else {\n            if (!hasOwnProperty(target, \"__mobxLazyInitializers\")) {\n                addHiddenProp(target, \"__mobxLazyInitializers\", target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice() || []);\n            }\n            var value_1 = descriptor.value,\n                initializer_1 = descriptor.initializer;\n            target.__mobxLazyInitializers.push(function (instance) {\n                onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor);\n            });\n            return {\n                enumerable: enumerable, configurable: true,\n                get: function get() {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    _set.call(this, key, v);\n                }\n            };\n        }\n    }\n    if (allowCustomArguments) {\n        return function () {\n            if (quacksLikeADecorator(arguments)) return classPropertyDecorator.apply(null, arguments);\n            var outerArgs = arguments;\n            var argLen = arguments.length;\n            return function (target, key, descriptor) {\n                return classPropertyDecorator(target, key, descriptor, outerArgs, argLen);\n            };\n        };\n    }\n    return classPropertyDecorator;\n}\nfunction typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {\n    if (!hasOwnProperty(instance, \"__mobxInitializedProps\")) addHiddenProp(instance, \"__mobxInitializedProps\", {});\n    instance.__mobxInitializedProps[key] = true;\n    onInitialize(instance, key, v, customArgs, baseDescriptor);\n}\nfunction runLazyInitializers(instance) {\n    if (instance.__mobxDidRunLazyInitializers === true) return;\n    if (instance.__mobxLazyInitializers) {\n        addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true);\n        instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) {\n            return initializer(instance);\n        });\n    }\n}\nfunction quacksLikeADecorator(args) {\n    return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\";\n}\nfunction iteratorSymbol() {\n    return typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n}\nvar IS_ITERATING_MARKER = \"__$$iterating\";\nfunction arrayAsIterator(array) {\n    invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\");\n    addHiddenFinalProp(array, IS_ITERATING_MARKER, true);\n    var idx = -1;\n    addHiddenFinalProp(array, \"next\", function next() {\n        idx++;\n        return {\n            done: idx >= this.length,\n            value: idx < this.length ? this[idx] : undefined\n        };\n    });\n    return array;\n}\nfunction declareIterator(prototType, iteratorFactory) {\n    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);\n}\nvar messages = {\n    \"m001\": \"It is not allowed to assign new values to @action fields\",\n    \"m002\": \"`runInAction` expects a function\",\n    \"m003\": \"`runInAction` expects a function without arguments\",\n    \"m004\": \"autorun expects a function\",\n    \"m005\": \"Warning: attempted to pass an action to autorun. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m006\": \"Warning: attempted to pass an action to autorunAsync. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m007\": \"reaction only accepts 2 or 3 arguments. If migrating from MobX 2, please provide an options object\",\n    \"m008\": \"wrapping reaction expression in `asReference` is no longer supported, use options object instead\",\n    \"m009\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\",\n    \"m010\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\",\n    \"m011\": \"First argument to `computed` should be an expression. If using computed as decorator, don't pass it arguments\",\n    \"m012\": \"computed takes one or two arguments if used as function\",\n    \"m013\": \"[mobx.expr] 'expr' should only be used inside other reactive functions.\",\n    \"m014\": \"extendObservable expected 2 or more arguments\",\n    \"m015\": \"extendObservable expects an object as first argument\",\n    \"m016\": \"extendObservable should not be used on maps, use map.merge instead\",\n    \"m017\": \"all arguments of extendObservable should be objects\",\n    \"m018\": \"extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540\",\n    \"m019\": \"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\",\n    \"m020\": \"modifiers can only be used for individual object properties\",\n    \"m021\": \"observable expects zero or one arguments\",\n    \"m022\": \"@observable can not be used on getters, use @computed instead\",\n    \"m023\": \"Using `transaction` is deprecated, use `runInAction` or `(@)action` instead.\",\n    \"m024\": \"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested its value.\",\n    \"m025\": \"whyRun can only be used on reactions and computed values\",\n    \"m026\": \"`action` can only be invoked on functions\",\n    \"m028\": \"It is not allowed to set `useStrict` when a derivation is running\",\n    \"m029\": \"INTERNAL ERROR only onBecomeUnobserved shouldn't be called twice in a row\",\n    \"m030a\": \"Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: \",\n    \"m030b\": \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: \",\n    \"m031\": \"Computed values are not allowed to not cause side effects by changing observables that are already being observed. Tried to modify: \",\n    \"m032\": \"* This computation is suspended (not in use by any reaction) and won't run automatically.\\n\tDidn't expect this computation to be suspended at this point?\\n\t  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n\t  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\",\n    \"m033\": \"`observe` doesn't support the fire immediately property for observable maps.\",\n    \"m034\": \"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\",\n    \"m035\": \"Cannot make the designated object observable; it is not extensible\",\n    \"m036\": \"It is not possible to get index atoms from arrays\",\n    \"m037\": \"Hi there! I'm sorry you have just run into an exception.\\nIf your debugger ends up here, know that some reaction (like the render() of an observer component, autorun or reaction)\\nthrew an exception and that mobx caught it, to avoid that it brings the rest of your application down.\\nThe original cause of the exception (the code that caused this reaction to run (again)), is still in the stack.\\n\\nHowever, more interesting is the actual stack trace of the error itself.\\nHopefully the error is an instanceof Error, because in that case you can inspect the original stack of the error from where it was thrown.\\nSee `error.stack` property, or press the very subtle \\\"(...)\\\" link you see near the console.error message that probably brought you here.\\nThat stack is more interesting than the stack of this console.error itself.\\n\\nIf the exception you see is an exception you created yourself, make sure to use `throw new Error(\\\"Oops\\\")` instead of `throw \\\"Oops\\\"`,\\nbecause the javascript environment will only preserve the original stack trace in the first form.\\n\\nYou can also make sure the debugger pauses the next time this very same exception is thrown by enabling \\\"Pause on caught exception\\\".\\n(Note that it might pause on many other, unrelated exception as well).\\n\\nIf that all doesn't help you out, feel free to open an issue https://github.com/mobxjs/mobx/issues!\\n\",\n    \"m038\": \"Missing items in this list?\\n    1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n    2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\"\n};\nfunction getMessage(id) {\n    return messages[id];\n}\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nfunction getGlobal() {\n    return global;\n}\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\nfunction fail(message, thing) {\n    invariant(false, message, thing);\n    throw \"X\";\n}\nfunction invariant(check, message, thing) {\n    if (!check) throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\"));\n}\nvar deprecatedMessages = [];\nfunction deprecated(msg) {\n    if (deprecatedMessages.indexOf(msg) !== -1) return false;\n    deprecatedMessages.push(msg);\n    console.error(\"[mobx] Deprecated: \" + msg);\n    return true;\n}\nfunction once(func) {\n    var invoked = false;\n    return function () {\n        if (invoked) return;\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function noop() {};\nfunction unique(list) {\n    var res = [];\n    list.forEach(function (item) {\n        if (res.indexOf(item) === -1) res.push(item);\n    });\n    return res;\n}\nfunction joinStrings(things, limit, separator) {\n    if (limit === void 0) {\n        limit = 100;\n    }\n    if (separator === void 0) {\n        separator = \" - \";\n    }\n    if (!things) return \"\";\n    var sliced = things.slice(0, limit);\n    return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\");\n}\nfunction isObject(value) {\n    return value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\";\n}\nfunction isPlainObject(value) {\n    if (value === null || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false;\n    var proto = Object.getPrototypeOf(value);\n    return proto === Object.prototype || proto === null;\n}\nfunction objectAssign() {\n    var res = arguments[0];\n    for (var i = 1, l = arguments.length; i < l; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n            if (hasOwnProperty(source, key)) {\n                res[key] = source[key];\n            }\n        }\n    }\n    return res;\n}\nfunction valueDidChange(compareStructural, oldValue, newValue) {\n    if (typeof oldValue === 'number' && isNaN(oldValue)) {\n        return typeof newValue !== 'number' || !isNaN(newValue);\n    }\n    return compareStructural ? !deepEqual(oldValue, newValue) : oldValue !== newValue;\n}\nvar prototypeHasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(object, propName) {\n    return prototypeHasOwnProperty.call(object, propName);\n}\nfunction makeNonEnumerable(object, propNames) {\n    for (var i = 0; i < propNames.length; i++) {\n        addHiddenProp(object, propNames[i], object[propNames[i]]);\n    }\n}\nfunction addHiddenProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\nfunction isPropertyConfigurable(object, prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(object, prop);\n    return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;\n}\nfunction assertPropertyConfigurable(object, prop) {\n    invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\");\n}\nfunction getEnumerableKeys(obj) {\n    var res = [];\n    for (var key in obj) {\n        res.push(key);\n    }return res;\n}\nfunction deepEqual(a, b) {\n    if (a === null && b === null) return true;\n    if (a === undefined && b === undefined) return true;\n    if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) !== \"object\") return a === b;\n    var aIsArray = isArrayLike(a);\n    var aIsMap = isMapLike(a);\n    if (aIsArray !== isArrayLike(b)) {\n        return false;\n    } else if (aIsMap !== isMapLike(b)) {\n        return false;\n    } else if (aIsArray) {\n        if (a.length !== b.length) return false;\n        for (var i = a.length - 1; i >= 0; i--) {\n            if (!deepEqual(a[i], b[i])) return false;\n        }return true;\n    } else if (aIsMap) {\n        if (a.size !== b.size) return false;\n        var equals_1 = true;\n        a.forEach(function (value, key) {\n            equals_1 = equals_1 && deepEqual(b.get(key), value);\n        });\n        return equals_1;\n    } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === \"object\" && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === \"object\") {\n        if (a === null || b === null) return false;\n        if (isMapLike(a) && isMapLike(b)) {\n            if (a.size !== b.size) return false;\n            return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries());\n        }\n        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length) return false;\n        for (var prop in a) {\n            if (!(prop in b)) return false;\n            if (!deepEqual(a[prop], b[prop])) return false;\n        }\n        return true;\n    }\n    return false;\n}\nfunction createInstanceofPredicate(name, clazz) {\n    var propName = \"isMobX\" + name;\n    clazz.prototype[propName] = true;\n    return function (x) {\n        return isObject(x) && x[propName] === true;\n    };\n}\nfunction isArrayLike(x) {\n    return Array.isArray(x) || isObservableArray(x);\n}\nexports.isArrayLike = isArrayLike;\nfunction isMapLike(x) {\n    return isES6Map(x) || isObservableMap(x);\n}\nfunction isES6Map(thing) {\n    if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map) return true;\n    return false;\n}\nfunction primitiveSymbol() {\n    return typeof Symbol === \"function\" && Symbol.toPrimitive || \"@@toPrimitive\";\n}\nfunction toPrimitive(value) {\n    return value === null ? null : (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? \"\" + value : value;\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _icons = __webpack_require__(6);\n\nvar _constants = __webpack_require__(0);\n\nfunction renderHeader(_ref, instance) {\n  var meta = _ref.meta,\n      user = _ref.user,\n      reactions = _ref.reactions;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-header-container';\n\n  var likeButton = document.createElement('span');\n  var likedReaction = reactions.find(function (reaction) {\n    return reaction.content === 'heart' && reaction.user.login === user.login;\n  });\n  likeButton.className = 'gitment-header-like-btn';\n  likeButton.innerHTML = '\\n    ' + _icons.heart + '\\n    ' + (likedReaction ? 'Unlike' : 'Like') + '\\n    ' + (meta.reactions && meta.reactions.heart ? ' \\u2022 <strong>' + meta.reactions.heart + '</strong> Liked' : '') + '\\n  ';\n\n  if (likedReaction) {\n    likeButton.classList.add('liked');\n    likeButton.onclick = function () {\n      return instance.unlike();\n    };\n  } else {\n    likeButton.classList.remove('liked');\n    likeButton.onclick = function () {\n      return instance.like();\n    };\n  }\n  container.appendChild(likeButton);\n\n  var commentsCount = document.createElement('span');\n  commentsCount.innerHTML = '\\n    ' + (meta.comments ? ' \\u2022 <strong>' + meta.comments + '</strong> Comments' : '') + '\\n  ';\n  container.appendChild(commentsCount);\n\n  var issueLink = document.createElement('a');\n  issueLink.className = 'gitment-header-issue-link';\n  issueLink.href = meta.html_url;\n  issueLink.target = '_blank';\n  issueLink.innerText = 'Issue Page';\n  container.appendChild(issueLink);\n\n  return container;\n}\n\nfunction renderComments(_ref2, instance) {\n  var meta = _ref2.meta,\n      comments = _ref2.comments,\n      commentReactions = _ref2.commentReactions,\n      currentPage = _ref2.currentPage,\n      user = _ref2.user,\n      error = _ref2.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-comments-container';\n\n  if (error) {\n    var errorBlock = document.createElement('div');\n    errorBlock.className = 'gitment-comments-error';\n\n    if (error === _constants.NOT_INITIALIZED_ERROR && user.login && user.login.toLowerCase() === instance.owner.toLowerCase()) {\n      var initHint = document.createElement('div');\n      var initButton = document.createElement('button');\n      initButton.className = 'gitment-comments-init-btn';\n      initButton.onclick = function () {\n        initButton.setAttribute('disabled', true);\n        instance.init().catch(function (e) {\n          initButton.removeAttribute('disabled');\n          alert(e);\n        });\n      };\n      initButton.innerText = 'Initialize Comments';\n      initHint.appendChild(initButton);\n      errorBlock.appendChild(initHint);\n    } else {\n      errorBlock.innerText = error;\n    }\n    container.appendChild(errorBlock);\n    return container;\n  } else if (comments === undefined) {\n    var loading = document.createElement('div');\n    loading.innerText = 'Loading comments...';\n    loading.className = 'gitment-comments-loading';\n    container.appendChild(loading);\n    return container;\n  } else if (!comments.length) {\n    var emptyBlock = document.createElement('div');\n    emptyBlock.className = 'gitment-comments-empty';\n    emptyBlock.innerText = 'No Comment Yet';\n    container.appendChild(emptyBlock);\n    return container;\n  }\n\n  var commentsList = document.createElement('ul');\n  commentsList.className = 'gitment-comments-list';\n\n  comments.forEach(function (comment) {\n    var createDate = new Date(comment.created_at);\n    var updateDate = new Date(comment.updated_at);\n    var commentItem = document.createElement('li');\n    commentItem.className = 'gitment-comment';\n    commentItem.innerHTML = '\\n      <a class=\"gitment-comment-avatar\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n        <img class=\"gitment-comment-avatar-img\" src=\"' + comment.user.avatar_url + '\"/>\\n      </a>\\n      <div class=\"gitment-comment-main\">\\n        <div class=\"gitment-comment-header\">\\n          <a class=\"gitment-comment-name\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n            ' + comment.user.login + '\\n          </a>\\n          commented on\\n          <span title=\"' + createDate + '\">' + createDate.toDateString() + '</span>\\n          ' + (createDate.toString() !== updateDate.toString() ? ' \\u2022 <span title=\"comment was edited at ' + updateDate + '\">edited</span>' : '') + '\\n          <div class=\"gitment-comment-like-btn\">' + _icons.heart + ' ' + (comment.reactions.heart || '') + '</div>\\n        </div>\\n        <div class=\"gitment-comment-body gitment-markdown\">' + comment.body_html + '</div>\\n      </div>\\n    ';\n    var likeButton = commentItem.querySelector('.gitment-comment-like-btn');\n    var likedReaction = commentReactions[comment.id] && commentReactions[comment.id].find(function (reaction) {\n      return reaction.content === 'heart' && reaction.user.login === user.login;\n    });\n    if (likedReaction) {\n      likeButton.classList.add('liked');\n      likeButton.onclick = function () {\n        return instance.unlikeAComment(comment.id);\n      };\n    } else {\n      likeButton.classList.remove('liked');\n      likeButton.onclick = function () {\n        return instance.likeAComment(comment.id);\n      };\n    }\n\n    // dirty\n    // use a blank image to trigger height calculating when element rendered\n    var imgTrigger = document.createElement('img');\n    var markdownBody = commentItem.querySelector('.gitment-comment-body');\n    imgTrigger.className = 'gitment-hidden';\n    imgTrigger.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    imgTrigger.onload = function () {\n      if (markdownBody.clientHeight > instance.maxCommentHeight) {\n        markdownBody.classList.add('gitment-comment-body-folded');\n        markdownBody.style.maxHeight = instance.maxCommentHeight + 'px';\n        markdownBody.title = 'Click to Expand';\n        markdownBody.onclick = function () {\n          markdownBody.classList.remove('gitment-comment-body-folded');\n          markdownBody.style.maxHeight = '';\n          markdownBody.title = '';\n          markdownBody.onclick = null;\n        };\n      }\n    };\n    commentItem.appendChild(imgTrigger);\n\n    commentsList.appendChild(commentItem);\n  });\n\n  container.appendChild(commentsList);\n\n  if (meta) {\n    var pageCount = Math.ceil(meta.comments / instance.perPage);\n    if (pageCount > 1) {\n      var pagination = document.createElement('ul');\n      pagination.className = 'gitment-comments-pagination';\n\n      if (currentPage > 1) {\n        var previousButton = document.createElement('li');\n        previousButton.className = 'gitment-comments-page-item';\n        previousButton.innerText = 'Previous';\n        previousButton.onclick = function () {\n          return instance.goto(currentPage - 1);\n        };\n        pagination.appendChild(previousButton);\n      }\n\n      var _loop = function _loop(i) {\n        var pageItem = document.createElement('li');\n        pageItem.className = 'gitment-comments-page-item';\n        pageItem.innerText = i;\n        pageItem.onclick = function () {\n          return instance.goto(i);\n        };\n        if (currentPage === i) pageItem.classList.add('gitment-selected');\n        pagination.appendChild(pageItem);\n      };\n\n      for (var i = 1; i <= pageCount; i++) {\n        _loop(i);\n      }\n\n      if (currentPage < pageCount) {\n        var nextButton = document.createElement('li');\n        nextButton.className = 'gitment-comments-page-item';\n        nextButton.innerText = 'Next';\n        nextButton.onclick = function () {\n          return instance.goto(currentPage + 1);\n        };\n        pagination.appendChild(nextButton);\n      }\n\n      container.appendChild(pagination);\n    }\n  }\n\n  return container;\n}\n\nfunction renderEditor(_ref3, instance) {\n  var user = _ref3.user,\n      error = _ref3.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-editor-container';\n\n  var shouldDisable = user.login && !error ? '' : 'disabled';\n  var disabledTip = user.login ? '' : 'Login to Comment';\n  container.innerHTML = '\\n      ' + (user.login ? '<a class=\"gitment-editor-avatar\" href=\"' + user.html_url + '\" target=\"_blank\">\\n            <img class=\"gitment-editor-avatar-img\" src=\"' + user.avatar_url + '\"/>\\n          </a>' : user.isLoggingIn ? '<div class=\"gitment-editor-avatar\">' + _icons.spinner + '</div>' : '<a class=\"gitment-editor-avatar\" href=\"' + instance.loginLink + '\" title=\"login with GitHub\">\\n              ' + _icons.github + '\\n            </a>') + '\\n    </a>\\n    <div class=\"gitment-editor-main\">\\n      <div class=\"gitment-editor-header\">\\n        <nav class=\"gitment-editor-tabs\">\\n          <button class=\"gitment-editor-tab gitment-selected\">Write</button>\\n          <button class=\"gitment-editor-tab\">Preview</button>\\n        </nav>\\n        <div class=\"gitment-editor-login\">\\n          ' + (user.login ? '<a class=\"gitment-editor-logout-link\">Logout</a>' : user.isLoggingIn ? 'Logging in...' : '<a class=\"gitment-editor-login-link\" href=\"' + instance.loginLink + '\">Login</a> with GitHub') + '\\n        </div>\\n      </div>\\n      <div class=\"gitment-editor-body\">\\n        <div class=\"gitment-editor-write-field\">\\n          <textarea placeholder=\"Leave a comment\" title=\"' + disabledTip + '\" ' + shouldDisable + '></textarea>\\n        </div>\\n        <div class=\"gitment-editor-preview-field gitment-hidden\">\\n          <div class=\"gitment-editor-preview gitment-markdown\"></div>\\n        </div>\\n      </div>\\n    </div>\\n    <div class=\"gitment-editor-footer\">\\n      <a class=\"gitment-editor-footer-tip\" href=\"https://guides.github.com/features/mastering-markdown/\" target=\"_blank\">\\n        Styling with Markdown is supported\\n      </a>\\n      <button class=\"gitment-editor-submit\" title=\"' + disabledTip + '\" ' + shouldDisable + '>Comment</button>\\n    </div>\\n  ';\n  if (user.login) {\n    container.querySelector('.gitment-editor-logout-link').onclick = function () {\n      return instance.logout();\n    };\n  }\n\n  var writeField = container.querySelector('.gitment-editor-write-field');\n  var previewField = container.querySelector('.gitment-editor-preview-field');\n\n  var textarea = writeField.querySelector('textarea');\n  textarea.oninput = function () {\n    textarea.style.height = 'auto';\n    var style = window.getComputedStyle(textarea, null);\n    var height = parseInt(style.height, 10);\n    var clientHeight = textarea.clientHeight;\n    var scrollHeight = textarea.scrollHeight;\n    if (clientHeight < scrollHeight) {\n      textarea.style.height = height + scrollHeight - clientHeight + 'px';\n    }\n  };\n\n  var _container$querySelec = container.querySelectorAll('.gitment-editor-tab'),\n      _container$querySelec2 = _slicedToArray(_container$querySelec, 2),\n      writeTab = _container$querySelec2[0],\n      previewTab = _container$querySelec2[1];\n\n  writeTab.onclick = function () {\n    writeTab.classList.add('gitment-selected');\n    previewTab.classList.remove('gitment-selected');\n    writeField.classList.remove('gitment-hidden');\n    previewField.classList.add('gitment-hidden');\n\n    textarea.focus();\n  };\n  previewTab.onclick = function () {\n    previewTab.classList.add('gitment-selected');\n    writeTab.classList.remove('gitment-selected');\n    previewField.classList.remove('gitment-hidden');\n    writeField.classList.add('gitment-hidden');\n\n    var preview = previewField.querySelector('.gitment-editor-preview');\n    var content = textarea.value.trim();\n    if (!content) {\n      preview.innerText = 'Nothing to preview';\n      return;\n    }\n\n    preview.innerText = 'Loading preview...';\n    instance.markdown(content).then(function (html) {\n      return preview.innerHTML = html;\n    });\n  };\n\n  var submitButton = container.querySelector('.gitment-editor-submit');\n  submitButton.onclick = function () {\n    submitButton.innerText = 'Submitting...';\n    submitButton.setAttribute('disabled', true);\n    instance.post(textarea.value.trim()).then(function (data) {\n      textarea.value = '';\n      textarea.style.height = 'auto';\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    }).catch(function (e) {\n      alert(e);\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    });\n  };\n\n  return container;\n}\n\nfunction renderFooter() {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-footer-container';\n  container.innerHTML = '\\n    Powered by\\n    <a class=\"gitment-footer-project-link\" href=\"https://github.com/imsun/gitment\" target=\"_blank\">\\n      Gitment\\n    </a>\\n  ';\n  return container;\n}\n\nfunction render(state, instance) {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-root-container';\n  container.appendChild(instance.renderHeader(state, instance));\n  container.appendChild(instance.renderComments(state, instance));\n  container.appendChild(instance.renderEditor(state, instance));\n  container.appendChild(instance.renderFooter(state, instance));\n  return container;\n}\n\nexports.default = { render: render, renderHeader: renderHeader, renderComments: renderComments, renderEditor: renderEditor, renderFooter: renderFooter };\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.http = exports.Query = exports.isString = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.getTargetContainer = getTargetContainer;\n\nvar _constants = __webpack_require__(0);\n\nvar isString = exports.isString = function isString(s) {\n  return toString.call(s) === '[object String]';\n};\n\nfunction getTargetContainer(container) {\n  var targetContainer = void 0;\n  if (container instanceof Element) {\n    targetContainer = container;\n  } else if (isString(container)) {\n    targetContainer = document.getElementById(container);\n  } else {\n    targetContainer = document.createElement('div');\n  }\n\n  return targetContainer;\n}\n\nvar Query = exports.Query = {\n  parse: function parse() {\n    var search = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.search;\n\n    if (!search) return {};\n    var queryString = search[0] === '?' ? search.substring(1) : search;\n    var query = {};\n    queryString.split('&').forEach(function (queryStr) {\n      var _queryStr$split = queryStr.split('='),\n          _queryStr$split2 = _slicedToArray(_queryStr$split, 2),\n          key = _queryStr$split2[0],\n          value = _queryStr$split2[1];\n\n      if (key) query[key] = value;\n    });\n\n    return query;\n  },\n  stringify: function stringify(query) {\n    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '?';\n\n    var queryString = Object.keys(query).map(function (key) {\n      return key + '=' + encodeURIComponent(query[key] || '');\n    }).join('&');\n    return queryString ? prefix + queryString : '';\n  }\n};\n\nfunction ajaxFactory(method) {\n  return function (apiPath) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://api.github.com';\n\n    var req = new XMLHttpRequest();\n    var token = localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n\n    var url = '' + base + apiPath;\n    var body = null;\n    if (method === 'GET' || method === 'DELETE') {\n      url += Query.stringify(data);\n    }\n\n    var p = new Promise(function (resolve, reject) {\n      req.addEventListener('load', function () {\n        var contentType = req.getResponseHeader('content-type');\n        var res = req.responseText;\n        if (!/json/.test(contentType)) {\n          resolve(res);\n          return;\n        }\n        var data = req.responseText ? JSON.parse(res) : {};\n        if (data.message) {\n          reject(new Error(data.message));\n        } else {\n          resolve(data);\n        }\n      });\n      req.addEventListener('error', function (error) {\n        return reject(error);\n      });\n    });\n    req.open(method, url, true);\n\n    req.setRequestHeader('Accept', 'application/vnd.github.squirrel-girl-preview, application/vnd.github.html+json');\n    if (token) {\n      req.setRequestHeader('Authorization', 'token ' + token);\n    }\n    if (method !== 'GET' && method !== 'DELETE') {\n      body = JSON.stringify(data);\n      req.setRequestHeader('Content-Type', 'application/json');\n    }\n\n    req.send(body);\n    return p;\n  };\n}\n\nvar http = exports.http = {\n  get: ajaxFactory('GET'),\n  post: ajaxFactory('POST'),\n  delete: ajaxFactory('DELETE'),\n  put: ajaxFactory('PUT')\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mobx = __webpack_require__(1);\n\nvar _constants = __webpack_require__(0);\n\nvar _utils = __webpack_require__(3);\n\nvar _default = __webpack_require__(2);\n\nvar _default2 = _interopRequireDefault(_default);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar scope = 'public_repo';\n\nfunction extendRenderer(instance, renderer) {\n  instance[renderer] = function (container) {\n    var targetContainer = (0, _utils.getTargetContainer)(container);\n    var render = instance.theme[renderer] || instance.defaultTheme[renderer];\n\n    (0, _mobx.autorun)(function () {\n      var e = render(instance.state, instance);\n      if (targetContainer.firstChild) {\n        targetContainer.replaceChild(e, targetContainer.firstChild);\n      } else {\n        targetContainer.appendChild(e);\n      }\n    });\n\n    return targetContainer;\n  };\n}\n\nvar Gitment = function () {\n  _createClass(Gitment, [{\n    key: 'accessToken',\n    get: function get() {\n      return localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n    },\n    set: function set(token) {\n      localStorage.setItem(_constants.LS_ACCESS_TOKEN_KEY, token);\n    }\n  }, {\n    key: 'loginLink',\n    get: function get() {\n      var oauthUri = 'https://github.com/login/oauth/authorize';\n      var redirect_uri = this.oauth.redirect_uri || window.location.href;\n\n      var oauthParams = Object.assign({\n        scope: scope,\n        redirect_uri: redirect_uri\n      }, this.oauth);\n\n      return '' + oauthUri + _utils.Query.stringify(oauthParams);\n    }\n  }]);\n\n  function Gitment() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Gitment);\n\n    this.defaultTheme = _default2.default;\n    this.useTheme(_default2.default);\n\n    Object.assign(this, {\n      id: window.location.href,\n      title: window.document.title,\n      link: window.location.href,\n      desc: '',\n      labels: [],\n      theme: _default2.default,\n      oauth: {},\n      perPage: 20,\n      maxCommentHeight: 250\n    }, options);\n\n    this.useTheme(this.theme);\n\n    var user = {};\n    try {\n      var userInfo = localStorage.getItem(_constants.LS_USER_KEY);\n      if (this.accessToken && userInfo) {\n        Object.assign(user, JSON.parse(userInfo), {\n          fromCache: true\n        });\n      }\n    } catch (e) {\n      localStorage.removeItem(_constants.LS_USER_KEY);\n    }\n\n    this.state = (0, _mobx.observable)({\n      user: user,\n      error: null,\n      meta: {},\n      comments: undefined,\n      reactions: [],\n      commentReactions: {},\n      currentPage: 1\n    });\n\n    var query = _utils.Query.parse();\n    if (query.code) {\n      var _oauth = this.oauth,\n          client_id = _oauth.client_id,\n          client_secret = _oauth.client_secret;\n\n      var code = query.code;\n      delete query.code;\n      var search = _utils.Query.stringify(query);\n      var replacedUrl = '' + window.location.origin + window.location.pathname + search + window.location.hash;\n      history.replaceState({}, '', replacedUrl);\n\n      Object.assign(this, {\n        id: replacedUrl,\n        link: replacedUrl\n      }, options);\n\n      this.state.user.isLoggingIn = true;\n      _utils.http.post('https://github.com/login/oauth/access_token', {\n        code: code,\n        client_id: client_id,\n        client_secret: client_secret\n      }, '').then(function (data) {\n        _this.accessToken = data.access_token;\n        _this.update();\n      }).catch(function (e) {\n        _this.state.user.isLoggingIn = false;\n        alert(e);\n      });\n    } else {\n      this.update();\n    }\n  }\n\n  _createClass(Gitment, [{\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      return this.createIssue().then(function () {\n        return _this2.loadComments();\n      }).then(function (comments) {\n        _this2.state.error = null;\n        return comments;\n      });\n    }\n  }, {\n    key: 'useTheme',\n    value: function useTheme() {\n      var _this3 = this;\n\n      var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this.theme = theme;\n\n      var renderers = Object.keys(this.theme);\n      renderers.forEach(function (renderer) {\n        return extendRenderer(_this3, renderer);\n      });\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var _this4 = this;\n\n      return Promise.all([this.loadMeta(), this.loadUserInfo()]).then(function () {\n        return Promise.all([_this4.loadComments().then(function () {\n          return _this4.loadCommentReactions();\n        }), _this4.loadReactions()]);\n      }).catch(function (e) {\n        return _this4.state.error = e;\n      });\n    }\n  }, {\n    key: 'markdown',\n    value: function markdown(text) {\n      return _utils.http.post('/markdown', {\n        text: text,\n        mode: 'gfm'\n      });\n    }\n  }, {\n    key: 'createIssue',\n    value: function createIssue() {\n      var _this5 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo,\n          title = this.title,\n          link = this.link,\n          desc = this.desc,\n          labels = this.labels;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues', {\n        title: title,\n        labels: labels.concat(['gitment', id]),\n        body: link + '\\n\\n' + desc\n      }).then(function (meta) {\n        _this5.state.meta = meta;\n        return meta;\n      });\n    }\n  }, {\n    key: 'getIssue',\n    value: function getIssue() {\n      if (this.state.meta.id) return Promise.resolve(this.state.meta);\n\n      return this.loadMeta();\n    }\n  }, {\n    key: 'post',\n    value: function post(body) {\n      var _this6 = this;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.post(issue.comments_url, { body: body }, '');\n      }).then(function (data) {\n        _this6.state.meta.comments++;\n        var pageCount = Math.ceil(_this6.state.meta.comments / _this6.perPage);\n        if (_this6.state.currentPage === pageCount) {\n          _this6.state.comments.push(data);\n        }\n        return data;\n      });\n    }\n  }, {\n    key: 'loadMeta',\n    value: function loadMeta() {\n      var _this7 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo;\n\n      return _utils.http.get('/repos/' + owner + '/' + repo + '/issues', {\n        creator: owner,\n        labels: id\n      }).then(function (issues) {\n        if (!issues.length) return Promise.reject(_constants.NOT_INITIALIZED_ERROR);\n        _this7.state.meta = issues[0];\n        return issues[0];\n      });\n    }\n  }, {\n    key: 'loadComments',\n    value: function loadComments() {\n      var _this8 = this;\n\n      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentPage;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.get(issue.comments_url, { page: page, per_page: _this8.perPage }, '');\n      }).then(function (comments) {\n        _this8.state.comments = comments;\n        return comments;\n      });\n    }\n  }, {\n    key: 'loadUserInfo',\n    value: function loadUserInfo() {\n      var _this9 = this;\n\n      if (!this.accessToken) {\n        this.logout();\n        return Promise.resolve({});\n      }\n\n      return _utils.http.get('/user').then(function (user) {\n        _this9.state.user = user;\n        localStorage.setItem(_constants.LS_USER_KEY, JSON.stringify(user));\n        return user;\n      });\n    }\n  }, {\n    key: 'loadReactions',\n    value: function loadReactions() {\n      var _this10 = this;\n\n      if (!this.accessToken) {\n        this.state.reactions = [];\n        return Promise.resolve([]);\n      }\n\n      return this.getIssue().then(function (issue) {\n        if (!issue.reactions.total_count) return [];\n        return _utils.http.get(issue.reactions.url, {}, '');\n      }).then(function (reactions) {\n        _this10.state.reactions = reactions;\n        return reactions;\n      });\n    }\n  }, {\n    key: 'loadCommentReactions',\n    value: function loadCommentReactions() {\n      var _this11 = this;\n\n      if (!this.accessToken) {\n        this.state.commentReactions = {};\n        return Promise.resolve([]);\n      }\n\n      var comments = this.state.comments;\n      var comentReactions = {};\n\n      return Promise.all(comments.map(function (comment) {\n        if (!comment.reactions.total_count) return [];\n\n        var owner = _this11.owner,\n            repo = _this11.repo;\n\n        return _utils.http.get('/repos/' + owner + '/' + repo + '/issues/comments/' + comment.id + '/reactions', {});\n      })).then(function (reactionsArray) {\n        comments.forEach(function (comment, index) {\n          comentReactions[comment.id] = reactionsArray[index];\n        });\n        _this11.state.commentReactions = comentReactions;\n\n        return comentReactions;\n      });\n    }\n  }, {\n    key: 'login',\n    value: function login() {\n      window.location.href = this.loginLink;\n    }\n  }, {\n    key: 'logout',\n    value: function logout() {\n      localStorage.removeItem(_constants.LS_ACCESS_TOKEN_KEY);\n      localStorage.removeItem(_constants.LS_USER_KEY);\n      this.state.user = {};\n    }\n  }, {\n    key: 'goto',\n    value: function goto(page) {\n      this.state.currentPage = page;\n      this.state.comments = undefined;\n      return this.loadComments(page);\n    }\n  }, {\n    key: 'like',\n    value: function like() {\n      var _this12 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/' + this.state.meta.number + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this12.state.reactions.push(reaction);\n        _this12.state.meta.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlike',\n    value: function unlike() {\n      var _this13 = this;\n\n      if (!this.accessToken) return Promise.reject();\n\n      var _state = this.state,\n          user = _state.user,\n          reactions = _state.reactions;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        _this13.state.meta.reactions.heart--;\n      });\n    }\n  }, {\n    key: 'likeAComment',\n    value: function likeAComment(commentId) {\n      var _this14 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/comments/' + commentId + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this14.state.commentReactions[commentId].push(reaction);\n        comment.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlikeAComment',\n    value: function unlikeAComment(commentId) {\n      if (!this.accessToken) return Promise.reject();\n\n      var reactions = this.state.commentReactions[commentId];\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n      var user = this.state.user;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        comment.reactions.heart--;\n      });\n    }\n  }]);\n\n  return Gitment;\n}();\n\nmodule.exports = Gitment;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Modified from https://github.com/evil-icons/evil-icons\n */\n\nvar close = exports.close = '<svg class=\"gitment-close-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M37.304 11.282l1.414 1.414-26.022 26.02-1.414-1.413z\"/><path d=\"M12.696 11.282l26.022 26.02-1.414 1.415-26.022-26.02z\"/></svg>';\nvar github = exports.github = '<svg class=\"gitment-github-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 10c-8.3 0-15 6.7-15 15 0 6.6 4.3 12.2 10.3 14.2.8.1 1-.3 1-.7v-2.6c-4.2.9-5.1-2-5.1-2-.7-1.7-1.7-2.2-1.7-2.2-1.4-.9.1-.9.1-.9 1.5.1 2.3 1.5 2.3 1.5 1.3 2.3 3.5 1.6 4.4 1.2.1-1 .5-1.6 1-2-3.3-.4-6.8-1.7-6.8-7.4 0-1.6.6-3 1.5-4-.2-.4-.7-1.9.1-4 0 0 1.3-.4 4.1 1.5 1.2-.3 2.5-.5 3.8-.5 1.3 0 2.6.2 3.8.5 2.9-1.9 4.1-1.5 4.1-1.5.8 2.1.3 3.6.1 4 1 1 1.5 2.4 1.5 4 0 5.8-3.5 7-6.8 7.4.5.5 1 1.4 1 2.8v4.1c0 .4.3.9 1 .7 6-2 10.2-7.6 10.2-14.2C40 16.7 33.3 10 25 10z\"/></svg>';\nvar heart = exports.heart = '<svg class=\"gitment-heart-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 39.7l-.6-.5C11.5 28.7 8 25 8 19c0-5 4-9 9-9 4.1 0 6.4 2.3 8 4.1 1.6-1.8 3.9-4.1 8-4.1 5 0 9 4 9 9 0 6-3.5 9.7-16.4 20.2l-.6.5zM17 12c-3.9 0-7 3.1-7 7 0 5.1 3.2 8.5 15 18.1 11.8-9.6 15-13 15-18.1 0-3.9-3.1-7-7-7-3.5 0-5.4 2.1-6.9 3.8L25 17.1l-1.1-1.3C22.4 14.1 20.5 12 17 12z\"/></svg>';\nvar spinner = exports.spinner = '<svg class=\"gitment-spinner-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 18c-.6 0-1-.4-1-1V9c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M25 42c-.6 0-1-.4-1-1v-8c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M29 19c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M17 39.8c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".93\" d=\"M21 19c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M33 39.8c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.1-.3.2-.5.2z\"/><path opacity=\".65\" d=\"M17 26H9c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".3\" d=\"M41 26h-8c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".86\" d=\"M18.1 21.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M38.9 33.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".44\" d=\"M11.1 33.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.1.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M31.9 21.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.2.2-.3.2-.5.2z\"/></svg>';\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=gitment.browser.js.map","site":{"data":{}},"excerpt":"","more":"var Gitment =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar LS_ACCESS_TOKEN_KEY = exports.LS_ACCESS_TOKEN_KEY = 'gitment-comments-token';\nvar LS_USER_KEY = exports.LS_USER_KEY = 'gitment-user-info';\n\nvar NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = new Error('Comments Not Initialized');\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) {\n            if (b.hasOwnProperty(p)) d[p] = b[p];\n        }\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nregisterGlobals();\nexports.extras = {\n    allowStateChanges: allowStateChanges,\n    deepEqual: deepEqual,\n    getAtom: getAtom,\n    getDebugName: getDebugName,\n    getDependencyTree: getDependencyTree,\n    getAdministration: getAdministration,\n    getGlobalState: getGlobalState,\n    getObserverTree: getObserverTree,\n    isComputingDerivation: isComputingDerivation,\n    isSpyEnabled: isSpyEnabled,\n    onReactionError: onReactionError,\n    resetGlobalState: resetGlobalState,\n    shareGlobalState: shareGlobalState,\n    spyReport: spyReport,\n    spyReportEnd: spyReportEnd,\n    spyReportStart: spyReportStart,\n    setReactionScheduler: setReactionScheduler\n};\nif ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" ? \"undefined\" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === \"object\") {\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx(module.exports);\n}\nmodule.exports.default = module.exports;\nvar actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {\n    var actionName = args && args.length === 1 ? args[0] : value.name || key || \"<unnamed action>\";\n    var wrappedAction = action(actionName, value);\n    addHiddenProp(target, key, wrappedAction);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, true);\nvar boundActionDecorator = createClassPropertyDecorator(function (target, key, value) {\n    defineBoundAction(target, key, value);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, false);\nvar action = function action(arg1, arg2, arg3, arg4) {\n    if (arguments.length === 1 && typeof arg1 === \"function\") return createAction(arg1.name || \"<unnamed action>\", arg1);\n    if (arguments.length === 2 && typeof arg2 === \"function\") return createAction(arg1, arg2);\n    if (arguments.length === 1 && typeof arg1 === \"string\") return namedActionDecorator(arg1);\n    return namedActionDecorator(arg2).apply(null, arguments);\n};\nexports.action = action;\naction.bound = function boundAction(arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n        var action_1 = createAction(\"<not yet bound action>\", arg1);\n        action_1.autoBind = true;\n        return action_1;\n    }\n    return boundActionDecorator.apply(null, arguments);\n};\nfunction namedActionDecorator(name) {\n    return function (target, prop, descriptor) {\n        if (descriptor && typeof descriptor.value === \"function\") {\n            descriptor.value = createAction(name, descriptor.value);\n            descriptor.enumerable = false;\n            descriptor.configurable = true;\n            return descriptor;\n        }\n        return actionFieldDecorator(name).apply(this, arguments);\n    };\n}\nfunction runInAction(arg1, arg2, arg3) {\n    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action>\";\n    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\n    var scope = typeof arg1 === \"function\" ? arg2 : arg3;\n    invariant(typeof fn === \"function\", getMessage(\"m002\"));\n    invariant(fn.length === 0, getMessage(\"m003\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    return executeAction(actionName, fn, scope, undefined);\n}\nexports.runInAction = runInAction;\nfunction isAction(thing) {\n    return typeof thing === \"function\" && thing.isMobxAction === true;\n}\nexports.isAction = isAction;\nfunction defineBoundAction(target, propertyName, fn) {\n    var res = function res() {\n        return executeAction(propertyName, fn, target, arguments);\n    };\n    res.isMobxAction = true;\n    addHiddenProp(target, propertyName, res);\n}\nfunction autorun(arg1, arg2, arg3) {\n    var name, view, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        view = arg2;\n        scope = arg3;\n    } else {\n        name = arg1.name || \"Autorun@\" + getNextId();\n        view = arg1;\n        scope = arg2;\n    }\n    invariant(typeof view === \"function\", getMessage(\"m004\"));\n    invariant(isAction(view) === false, getMessage(\"m005\"));\n    if (scope) view = view.bind(scope);\n    var reaction = new Reaction(name, function () {\n        this.track(reactionRunner);\n    });\n    function reactionRunner() {\n        view(reaction);\n    }\n    reaction.schedule();\n    return reaction.getDisposer();\n}\nexports.autorun = autorun;\nfunction when(arg1, arg2, arg3, arg4) {\n    var name, predicate, effect, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        predicate = arg2;\n        effect = arg3;\n        scope = arg4;\n    } else {\n        name = \"When@\" + getNextId();\n        predicate = arg1;\n        effect = arg2;\n        scope = arg3;\n    }\n    var disposer = autorun(name, function (r) {\n        if (predicate.call(scope)) {\n            r.dispose();\n            var prevUntracked = untrackedStart();\n            effect.call(scope);\n            untrackedEnd(prevUntracked);\n        }\n    });\n    return disposer;\n}\nexports.when = when;\nfunction autorunAsync(arg1, arg2, arg3, arg4) {\n    var name, func, delay, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        func = arg2;\n        delay = arg3;\n        scope = arg4;\n    } else {\n        name = arg1.name || \"AutorunAsync@\" + getNextId();\n        func = arg1;\n        delay = arg2;\n        scope = arg3;\n    }\n    invariant(isAction(func) === false, getMessage(\"m006\"));\n    if (delay === void 0) delay = 1;\n    if (scope) func = func.bind(scope);\n    var isScheduled = false;\n    var r = new Reaction(name, function () {\n        if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                if (!r.isDisposed) r.track(reactionRunner);\n            }, delay);\n        }\n    });\n    function reactionRunner() {\n        func(r);\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.autorunAsync = autorunAsync;\nfunction reaction(expression, effect, arg3) {\n    if (arguments.length > 3) {\n        fail(getMessage(\"m007\"));\n    }\n    if (isModifierDescriptor(expression)) {\n        fail(getMessage(\"m008\"));\n    }\n    var opts;\n    if ((typeof arg3 === \"undefined\" ? \"undefined\" : _typeof(arg3)) === \"object\") {\n        opts = arg3;\n    } else {\n        opts = {};\n    }\n    opts.name = opts.name || expression.name || effect.name || \"Reaction@\" + getNextId();\n    opts.fireImmediately = arg3 === true || opts.fireImmediately === true;\n    opts.delay = opts.delay || 0;\n    opts.compareStructural = opts.compareStructural || opts.struct || false;\n    effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect);\n    if (opts.context) {\n        expression = expression.bind(opts.context);\n    }\n    var firstTime = true;\n    var isScheduled = false;\n    var nextValue;\n    var r = new Reaction(opts.name, function () {\n        if (firstTime || opts.delay < 1) {\n            reactionRunner();\n        } else if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                reactionRunner();\n            }, opts.delay);\n        }\n    });\n    function reactionRunner() {\n        if (r.isDisposed) return;\n        var changed = false;\n        r.track(function () {\n            var v = expression(r);\n            changed = valueDidChange(opts.compareStructural, nextValue, v);\n            nextValue = v;\n        });\n        if (firstTime && opts.fireImmediately) effect(nextValue, r);\n        if (!firstTime && changed === true) effect(nextValue, r);\n        if (firstTime) firstTime = false;\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.reaction = reaction;\nfunction createComputedDecorator(compareStructural) {\n    return createClassPropertyDecorator(function (target, name, _, __, originalDescriptor) {\n        invariant(typeof originalDescriptor !== \"undefined\", getMessage(\"m009\"));\n        invariant(typeof originalDescriptor.get === \"function\", getMessage(\"m010\"));\n        var adm = asObservableObject(target, \"\");\n        defineComputedProperty(adm, name, originalDescriptor.get, originalDescriptor.set, compareStructural, false);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        this.$mobx.values[name].set(value);\n    }, false, false);\n}\nvar computedDecorator = createComputedDecorator(false);\nvar computedStructDecorator = createComputedDecorator(true);\nvar computed = function computed(arg1, arg2, arg3) {\n    if (typeof arg2 === \"string\") {\n        return computedDecorator.apply(null, arguments);\n    }\n    invariant(typeof arg1 === \"function\", getMessage(\"m011\"));\n    invariant(arguments.length < 3, getMessage(\"m012\"));\n    var opts = (typeof arg2 === \"undefined\" ? \"undefined\" : _typeof(arg2)) === \"object\" ? arg2 : {};\n    opts.setter = typeof arg2 === \"function\" ? arg2 : opts.setter;\n    return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || \"\", opts.setter);\n};\nexports.computed = computed;\ncomputed.struct = computedStructDecorator;\nfunction createTransformer(transformer, onCleanup) {\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\n    var objectCache = {};\n    var resetId = globalState.resetId;\n    var Transformer = function (_super) {\n        __extends(Transformer, _super);\n        function Transformer(sourceIdentifier, sourceObject) {\n            var _this = _super.call(this, function () {\n                return transformer(sourceObject);\n            }, undefined, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier, undefined) || this;\n            _this.sourceIdentifier = sourceIdentifier;\n            _this.sourceObject = sourceObject;\n            return _this;\n        }\n        Transformer.prototype.onBecomeUnobserved = function () {\n            var lastValue = this.value;\n            _super.prototype.onBecomeUnobserved.call(this);\n            delete objectCache[this.sourceIdentifier];\n            if (onCleanup) onCleanup(lastValue, this.sourceObject);\n        };\n        return Transformer;\n    }(ComputedValue);\n    return function (object) {\n        if (resetId !== globalState.resetId) {\n            objectCache = {};\n            resetId = globalState.resetId;\n        }\n        var identifier = getMemoizationId(object);\n        var reactiveTransformer = objectCache[identifier];\n        if (reactiveTransformer) return reactiveTransformer.get();\n        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);\n        return reactiveTransformer.get();\n    };\n}\nexports.createTransformer = createTransformer;\nfunction getMemoizationId(object) {\n    if (object === null || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") throw new Error(\"[mobx] transform expected some kind of object, got: \" + object);\n    var tid = object.$transformId;\n    if (tid === undefined) {\n        tid = getNextId();\n        addHiddenProp(object, \"$transformId\", tid);\n    }\n    return tid;\n}\nfunction expr(expr, scope) {\n    if (!isComputingDerivation()) console.warn(getMessage(\"m013\"));\n    return computed(expr, { context: scope }).get();\n}\nexports.expr = expr;\nfunction extendObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, deepEnhancer, properties);\n}\nexports.extendObservable = extendObservable;\nfunction extendShallowObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, referenceEnhancer, properties);\n}\nexports.extendShallowObservable = extendShallowObservable;\nfunction extendObservableHelper(target, defaultEnhancer, properties) {\n    invariant(arguments.length >= 2, getMessage(\"m014\"));\n    invariant((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\", getMessage(\"m015\"));\n    invariant(!isObservableMap(target), getMessage(\"m016\"));\n    properties.forEach(function (propSet) {\n        invariant((typeof propSet === \"undefined\" ? \"undefined\" : _typeof(propSet)) === \"object\", getMessage(\"m017\"));\n        invariant(!isObservable(propSet), getMessage(\"m018\"));\n    });\n    var adm = asObservableObject(target);\n    var definedProps = {};\n    for (var i = properties.length - 1; i >= 0; i--) {\n        var propSet = properties[i];\n        for (var key in propSet) {\n            if (definedProps[key] !== true && hasOwnProperty(propSet, key)) {\n                definedProps[key] = true;\n                if (target === propSet && !isPropertyConfigurable(target, key)) continue;\n                var descriptor = Object.getOwnPropertyDescriptor(propSet, key);\n                defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer);\n            }\n        }\n    }\n    return target;\n}\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree);\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (hasObservers(node)) result.observers = getObservers(node).map(nodeToObserverTree);\n    return result;\n}\nfunction intercept(thing, propOrHandler, handler) {\n    if (typeof handler === \"function\") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);\n}\nexports.intercept = intercept;\nfunction interceptInterceptable(thing, handler) {\n    return getAdministration(thing).intercept(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    return getAdministration(thing, property).intercept(handler);\n}\nfunction isComputed(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableObject(value) === false) return false;\n        var atom = getAtom(value, property);\n        return isComputedValue(atom);\n    }\n    return isComputedValue(value);\n}\nexports.isComputed = isComputed;\nfunction isObservable(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableArray(value) || isObservableMap(value)) throw new Error(getMessage(\"m019\"));else if (isObservableObject(value)) {\n            var o = value.$mobx;\n            return o.values && !!o.values[property];\n        }\n        return false;\n    }\n    return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value);\n}\nexports.isObservable = isObservable;\nvar deepDecorator = createDecoratorForEnhancer(deepEnhancer);\nvar shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);\nvar refDecorator = createDecoratorForEnhancer(referenceEnhancer);\nvar deepStructDecorator = createDecoratorForEnhancer(deepStructEnhancer);\nvar refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);\nfunction createObservable(v) {\n    if (v === void 0) {\n        v = undefined;\n    }\n    if (typeof arguments[1] === \"string\") return deepDecorator.apply(null, arguments);\n    invariant(arguments.length <= 1, getMessage(\"m021\"));\n    invariant(!isModifierDescriptor(v), getMessage(\"m020\"));\n    if (isObservable(v)) return v;\n    var res = deepEnhancer(v, undefined, undefined);\n    if (res !== v) return res;\n    return observable.box(v);\n}\nvar IObservableFactories = function () {\n    function IObservableFactories() {}\n    IObservableFactories.prototype.box = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"box\");\n        return new ObservableValue(value, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowBox = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowBox\");\n        return new ObservableValue(value, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.array = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"array\");\n        return new ObservableArray(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowArray = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowArray\");\n        return new ObservableArray(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.map = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"map\");\n        return new ObservableMap(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowMap = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowMap\");\n        return new ObservableMap(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.object = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"object\");\n        var res = {};\n        asObservableObject(res, name);\n        extendObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.shallowObject = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowObject\");\n        var res = {};\n        asObservableObject(res, name);\n        extendShallowObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.ref = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(referenceEnhancer, arguments[0]);\n        } else {\n            return refDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.shallow = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(shallowEnhancer, arguments[0]);\n        } else {\n            return shallowDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.deep = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepEnhancer, arguments[0]);\n        } else {\n            return deepDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.struct = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepStructEnhancer, arguments[0]);\n        } else {\n            return deepStructDecorator.apply(null, arguments);\n        }\n    };\n    return IObservableFactories;\n}();\nexports.IObservableFactories = IObservableFactories;\nvar observable = createObservable;\nexports.observable = observable;\nObject.keys(IObservableFactories.prototype).forEach(function (key) {\n    return observable[key] = IObservableFactories.prototype[key];\n});\nobservable.deep.struct = observable.struct;\nobservable.ref.struct = function () {\n    if (arguments.length < 2) {\n        return createModifierDescriptor(refStructEnhancer, arguments[0]);\n    } else {\n        return refStructDecorator.apply(null, arguments);\n    }\n};\nfunction incorrectlyUsedAsDecorator(methodName) {\n    fail(\"Expected one or two arguments to observable.\" + methodName + \". Did you accidentally try to use observable.\" + methodName + \" as decorator?\");\n}\nfunction createDecoratorForEnhancer(enhancer) {\n    invariant(!!enhancer, \":(\");\n    return createClassPropertyDecorator(function (target, name, baseValue, _, baseDescriptor) {\n        assertPropertyConfigurable(target, name);\n        invariant(!baseDescriptor || !baseDescriptor.get, getMessage(\"m022\"));\n        var adm = asObservableObject(target, undefined);\n        defineObservableProperty(adm, name, baseValue, enhancer);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        setPropertyValue(this, name, value);\n    }, true, false);\n}\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (typeof cbOrFire === \"function\") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);\n}\nexports.observe = observe;\nfunction observeObservable(thing, listener, fireImmediately) {\n    return getAdministration(thing).observe(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    return getAdministration(thing, property).observe(listener, fireImmediately);\n}\nfunction toJS(source, detectCycles, __alreadySeen) {\n    if (detectCycles === void 0) {\n        detectCycles = true;\n    }\n    if (__alreadySeen === void 0) {\n        __alreadySeen = [];\n    }\n    function cache(value) {\n        if (detectCycles) __alreadySeen.push([source, value]);\n        return value;\n    }\n    if (isObservable(source)) {\n        if (detectCycles && __alreadySeen === null) __alreadySeen = [];\n        if (detectCycles && source !== null && (typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") {\n            for (var i = 0, l = __alreadySeen.length; i < l; i++) {\n                if (__alreadySeen[i][0] === source) return __alreadySeen[i][1];\n            }\n        }\n        if (isObservableArray(source)) {\n            var res = cache([]);\n            var toAdd = source.map(function (value) {\n                return toJS(value, detectCycles, __alreadySeen);\n            });\n            res.length = toAdd.length;\n            for (var i = 0, l = toAdd.length; i < l; i++) {\n                res[i] = toAdd[i];\n            }return res;\n        }\n        if (isObservableObject(source)) {\n            var res = cache({});\n            for (var key in source) {\n                res[key] = toJS(source[key], detectCycles, __alreadySeen);\n            }return res;\n        }\n        if (isObservableMap(source)) {\n            var res_1 = cache({});\n            source.forEach(function (value, key) {\n                return res_1[key] = toJS(value, detectCycles, __alreadySeen);\n            });\n            return res_1;\n        }\n        if (isObservableValue(source)) return toJS(source.get(), detectCycles, __alreadySeen);\n    }\n    return source;\n}\nexports.toJS = toJS;\nfunction transaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    deprecated(getMessage(\"m023\"));\n    return runInTransaction.apply(undefined, arguments);\n}\nexports.transaction = transaction;\nfunction runInTransaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    return executeAction(\"\", action);\n}\nfunction log(msg) {\n    console.log(msg);\n    return msg;\n}\nfunction whyRun(thing, prop) {\n    switch (arguments.length) {\n        case 0:\n            thing = globalState.trackingDerivation;\n            if (!thing) return log(getMessage(\"m024\"));\n            break;\n        case 2:\n            thing = getAtom(thing, prop);\n            break;\n    }\n    thing = getAtom(thing);\n    if (isComputedValue(thing)) return log(thing.whyRun());else if (isReaction(thing)) return log(thing.whyRun());\n    return fail(getMessage(\"m025\"));\n}\nexports.whyRun = whyRun;\nfunction createAction(actionName, fn) {\n    invariant(typeof fn === \"function\", getMessage(\"m026\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    var res = function res() {\n        return executeAction(actionName, fn, this, arguments);\n    };\n    res.originalFn = fn;\n    res.isMobxAction = true;\n    return res;\n}\nfunction executeAction(actionName, fn, scope, args) {\n    var runInfo = startAction(actionName, fn, scope, args);\n    try {\n        return fn.apply(scope, args);\n    } finally {\n        endAction(runInfo);\n    }\n}\nfunction startAction(actionName, fn, scope, args) {\n    var notifySpy = isSpyEnabled() && !!actionName;\n    var startTime = 0;\n    if (notifySpy) {\n        startTime = Date.now();\n        var l = args && args.length || 0;\n        var flattendArgs = new Array(l);\n        if (l > 0) for (var i = 0; i < l; i++) {\n            flattendArgs[i] = args[i];\n        }spyReportStart({\n            type: \"action\",\n            name: actionName,\n            fn: fn,\n            object: scope,\n            arguments: flattendArgs\n        });\n    }\n    var prevDerivation = untrackedStart();\n    startBatch();\n    var prevAllowStateChanges = allowStateChangesStart(true);\n    return {\n        prevDerivation: prevDerivation,\n        prevAllowStateChanges: prevAllowStateChanges,\n        notifySpy: notifySpy,\n        startTime: startTime\n    };\n}\nfunction endAction(runInfo) {\n    allowStateChangesEnd(runInfo.prevAllowStateChanges);\n    endBatch();\n    untrackedEnd(runInfo.prevDerivation);\n    if (runInfo.notifySpy) spyReportEnd({ time: Date.now() - runInfo.startTime });\n}\nfunction useStrict(strict) {\n    invariant(globalState.trackingDerivation === null, getMessage(\"m028\"));\n    globalState.strictMode = strict;\n    globalState.allowStateChanges = !strict;\n}\nexports.useStrict = useStrict;\nfunction isStrictModeEnabled() {\n    return globalState.strictMode;\n}\nexports.isStrictModeEnabled = isStrictModeEnabled;\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    var res;\n    try {\n        res = func();\n    } finally {\n        allowStateChangesEnd(prev);\n    }\n    return res;\n}\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nvar BaseAtom = function () {\n    function BaseAtom(name) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        this.name = name;\n        this.isPendingUnobservation = true;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.NOT_TRACKING;\n    }\n    BaseAtom.prototype.onBecomeUnobserved = function () {};\n    BaseAtom.prototype.reportObserved = function () {\n        reportObserved(this);\n    };\n    BaseAtom.prototype.reportChanged = function () {\n        startBatch();\n        propagateChanged(this);\n        endBatch();\n    };\n    BaseAtom.prototype.toString = function () {\n        return this.name;\n    };\n    return BaseAtom;\n}();\nexports.BaseAtom = BaseAtom;\nvar Atom = function (_super) {\n    __extends(Atom, _super);\n    function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        if (onBecomeObservedHandler === void 0) {\n            onBecomeObservedHandler = noop;\n        }\n        if (onBecomeUnobservedHandler === void 0) {\n            onBecomeUnobservedHandler = noop;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.name = name;\n        _this.onBecomeObservedHandler = onBecomeObservedHandler;\n        _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;\n        _this.isPendingUnobservation = false;\n        _this.isBeingTracked = false;\n        return _this;\n    }\n    Atom.prototype.reportObserved = function () {\n        startBatch();\n        _super.prototype.reportObserved.call(this);\n        if (!this.isBeingTracked) {\n            this.isBeingTracked = true;\n            this.onBecomeObservedHandler();\n        }\n        endBatch();\n        return !!globalState.trackingDerivation;\n    };\n    Atom.prototype.onBecomeUnobserved = function () {\n        this.isBeingTracked = false;\n        this.onBecomeUnobservedHandler();\n    };\n    return Atom;\n}(BaseAtom);\nexports.Atom = Atom;\nvar isAtom = createInstanceofPredicate(\"Atom\", BaseAtom);\nvar ComputedValue = function () {\n    function ComputedValue(derivation, scope, compareStructural, name, setter) {\n        this.derivation = derivation;\n        this.scope = scope;\n        this.compareStructural = compareStructural;\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.observing = [];\n        this.newObserving = null;\n        this.isPendingUnobservation = false;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.runId = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.UP_TO_DATE;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.value = undefined;\n        this.isComputing = false;\n        this.isRunningSetter = false;\n        this.name = name || \"ComputedValue@\" + getNextId();\n        if (setter) this.setter = createAction(name + \"-setter\", setter);\n    }\n    ComputedValue.prototype.onBecomeStale = function () {\n        propagateMaybeChanged(this);\n    };\n    ComputedValue.prototype.onBecomeUnobserved = function () {\n        invariant(this.dependenciesState !== IDerivationState.NOT_TRACKING, getMessage(\"m029\"));\n        clearObserving(this);\n        this.value = undefined;\n    };\n    ComputedValue.prototype.get = function () {\n        invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation);\n        if (globalState.inBatch === 0) {\n            startBatch();\n            if (shouldCompute(this)) this.value = this.computeValue(false);\n            endBatch();\n        } else {\n            reportObserved(this);\n            if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this);\n        }\n        var result = this.value;\n        if (isCaughtException(result)) throw result.cause;\n        return result;\n    };\n    ComputedValue.prototype.peek = function () {\n        var res = this.computeValue(false);\n        if (isCaughtException(res)) throw res.cause;\n        return res;\n    };\n    ComputedValue.prototype.set = function (value) {\n        if (this.setter) {\n            invariant(!this.isRunningSetter, \"The setter of computed value '\" + this.name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\");\n            this.isRunningSetter = true;\n            try {\n                this.setter.call(this.scope, value);\n            } finally {\n                this.isRunningSetter = false;\n            }\n        } else invariant(false, \"[ComputedValue '\" + this.name + \"'] It is not possible to assign a new value to a computed value.\");\n    };\n    ComputedValue.prototype.trackAndCompute = function () {\n        if (isSpyEnabled()) {\n            spyReport({\n                object: this.scope,\n                type: \"compute\",\n                fn: this.derivation\n            });\n        }\n        var oldValue = this.value;\n        var newValue = this.value = this.computeValue(true);\n        return isCaughtException(newValue) || valueDidChange(this.compareStructural, newValue, oldValue);\n    };\n    ComputedValue.prototype.computeValue = function (track) {\n        this.isComputing = true;\n        globalState.computationDepth++;\n        var res;\n        if (track) {\n            res = trackDerivedFunction(this, this.derivation, this.scope);\n        } else {\n            try {\n                res = this.derivation.call(this.scope);\n            } catch (e) {\n                res = new CaughtException(e);\n            }\n        }\n        globalState.computationDepth--;\n        this.isComputing = false;\n        return res;\n    };\n    ;\n    ComputedValue.prototype.observe = function (listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function () {\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener({\n                    type: \"update\",\n                    object: _this,\n                    newValue: newValue,\n                    oldValue: prevValue\n                });\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    ComputedValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ComputedValue.prototype.toString = function () {\n        return this.name + \"[\" + this.derivation.toString() + \"]\";\n    };\n    ComputedValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    ;\n    ComputedValue.prototype.whyRun = function () {\n        var isTracking = Boolean(globalState.trackingDerivation);\n        var observing = unique(this.isComputing ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        var observers = unique(getObservers(this).map(function (dep) {\n            return dep.name;\n        }));\n        return \"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + (isTracking ? \"[active] the value of this computation is needed by a reaction\" : this.isComputing ? \"[get] The value of this computed was requested outside a reaction\" : \"[idle] not running at the moment\") + \"\\n\" + (this.dependenciesState === IDerivationState.NOT_TRACKING ? getMessage(\"m032\") : \" * This computation will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this.isComputing && isTracking ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\\n  * If the outcome of this computation changes, the following observers will be re-run:\\n    \" + joinStrings(observers) + \"\\n\");\n    };\n    return ComputedValue;\n}();\nComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf;\nvar isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue);\nvar IDerivationState;\n(function (IDerivationState) {\n    IDerivationState[IDerivationState[\"NOT_TRACKING\"] = -1] = \"NOT_TRACKING\";\n    IDerivationState[IDerivationState[\"UP_TO_DATE\"] = 0] = \"UP_TO_DATE\";\n    IDerivationState[IDerivationState[\"POSSIBLY_STALE\"] = 1] = \"POSSIBLY_STALE\";\n    IDerivationState[IDerivationState[\"STALE\"] = 2] = \"STALE\";\n})(IDerivationState || (IDerivationState = {}));\nexports.IDerivationState = IDerivationState;\nvar CaughtException = function () {\n    function CaughtException(cause) {\n        this.cause = cause;\n    }\n    return CaughtException;\n}();\nfunction isCaughtException(e) {\n    return e instanceof CaughtException;\n}\nfunction shouldCompute(derivation) {\n    switch (derivation.dependenciesState) {\n        case IDerivationState.UP_TO_DATE:\n            return false;\n        case IDerivationState.NOT_TRACKING:\n        case IDerivationState.STALE:\n            return true;\n        case IDerivationState.POSSIBLY_STALE:\n            {\n                var prevUntracked = untrackedStart();\n                var obs = derivation.observing,\n                    l = obs.length;\n                for (var i = 0; i < l; i++) {\n                    var obj = obs[i];\n                    if (isComputedValue(obj)) {\n                        try {\n                            obj.get();\n                        } catch (e) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                        if (derivation.dependenciesState === IDerivationState.STALE) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                    }\n                }\n                changeDependenciesStateTo0(derivation);\n                untrackedEnd(prevUntracked);\n                return false;\n            }\n    }\n}\nfunction isComputingDerivation() {\n    return globalState.trackingDerivation !== null;\n}\nfunction checkIfStateModificationsAreAllowed(atom) {\n    var hasObservers = atom.observers.length > 0;\n    if (globalState.computationDepth > 0 && hasObservers) fail(getMessage(\"m031\") + atom.name);\n    if (!globalState.allowStateChanges && hasObservers) fail(getMessage(globalState.strictMode ? \"m030a\" : \"m030b\") + atom.name);\n}\nfunction trackDerivedFunction(derivation, f, context) {\n    changeDependenciesStateTo0(derivation);\n    derivation.newObserving = new Array(derivation.observing.length + 100);\n    derivation.unboundDepsCount = 0;\n    derivation.runId = ++globalState.runId;\n    var prevTracking = globalState.trackingDerivation;\n    globalState.trackingDerivation = derivation;\n    var result;\n    try {\n        result = f.call(context);\n    } catch (e) {\n        result = new CaughtException(e);\n    }\n    globalState.trackingDerivation = prevTracking;\n    bindDependencies(derivation);\n    return result;\n}\nfunction bindDependencies(derivation) {\n    var prevObserving = derivation.observing;\n    var observing = derivation.observing = derivation.newObserving;\n    derivation.newObserving = null;\n    var i0 = 0,\n        l = derivation.unboundDepsCount;\n    for (var i = 0; i < l; i++) {\n        var dep = observing[i];\n        if (dep.diffValue === 0) {\n            dep.diffValue = 1;\n            if (i0 !== i) observing[i0] = dep;\n            i0++;\n        }\n    }\n    observing.length = i0;\n    l = prevObserving.length;\n    while (l--) {\n        var dep = prevObserving[l];\n        if (dep.diffValue === 0) {\n            removeObserver(dep, derivation);\n        }\n        dep.diffValue = 0;\n    }\n    while (i0--) {\n        var dep = observing[i0];\n        if (dep.diffValue === 1) {\n            dep.diffValue = 0;\n            addObserver(dep, derivation);\n        }\n    }\n}\nfunction clearObserving(derivation) {\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        removeObserver(obs[i], derivation);\n    }derivation.dependenciesState = IDerivationState.NOT_TRACKING;\n    obs.length = 0;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    var res = action();\n    untrackedEnd(prev);\n    return res;\n}\nexports.untracked = untracked;\nfunction untrackedStart() {\n    var prev = globalState.trackingDerivation;\n    globalState.trackingDerivation = null;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.trackingDerivation = prev;\n}\nfunction changeDependenciesStateTo0(derivation) {\n    if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return;\n    derivation.dependenciesState = IDerivationState.UP_TO_DATE;\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nvar persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"];\nvar MobXGlobals = function () {\n    function MobXGlobals() {\n        this.version = 5;\n        this.trackingDerivation = null;\n        this.computationDepth = 0;\n        this.runId = 0;\n        this.mobxGuid = 0;\n        this.inBatch = 0;\n        this.pendingUnobservations = [];\n        this.pendingReactions = [];\n        this.isRunningReactions = false;\n        this.allowStateChanges = true;\n        this.strictMode = false;\n        this.resetId = 0;\n        this.spyListeners = [];\n        this.globalReactionErrorHandlers = [];\n    }\n    return MobXGlobals;\n}();\nvar globalState = new MobXGlobals();\nfunction shareGlobalState() {\n    var global = getGlobal();\n    var ownState = globalState;\n    if (global.__mobservableTrackingStack || global.__mobservableViewStack) throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\");\n    if (global.__mobxGlobal && global.__mobxGlobal.version !== ownState.version) throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\");\n    if (global.__mobxGlobal) globalState = global.__mobxGlobal;else global.__mobxGlobal = ownState;\n}\nfunction getGlobalState() {\n    return globalState;\n}\nfunction registerGlobals() {}\nfunction resetGlobalState() {\n    globalState.resetId++;\n    var defaultGlobals = new MobXGlobals();\n    for (var key in defaultGlobals) {\n        if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];\n    }globalState.allowStateChanges = !globalState.strictMode;\n}\nfunction hasObservers(observable) {\n    return observable.observers && observable.observers.length > 0;\n}\nfunction getObservers(observable) {\n    return observable.observers;\n}\nfunction invariantObservers(observable) {\n    var list = observable.observers;\n    var map = observable.observersIndexes;\n    var l = list.length;\n    for (var i = 0; i < l; i++) {\n        var id = list[i].__mapid;\n        if (i) {\n            invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\");\n        } else {\n            invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldnt be held in map.\");\n        }\n    }\n    invariant(list.length === 0 || Object.keys(map).length === list.length - 1, \"INTERNAL ERROR there is no junk in map\");\n}\nfunction addObserver(observable, node) {\n    var l = observable.observers.length;\n    if (l) {\n        observable.observersIndexes[node.__mapid] = l;\n    }\n    observable.observers[l] = node;\n    if (observable.lowestObserverState > node.dependenciesState) observable.lowestObserverState = node.dependenciesState;\n}\nfunction removeObserver(observable, node) {\n    if (observable.observers.length === 1) {\n        observable.observers.length = 0;\n        queueForUnobservation(observable);\n    } else {\n        var list = observable.observers;\n        var map_1 = observable.observersIndexes;\n        var filler = list.pop();\n        if (filler !== node) {\n            var index = map_1[node.__mapid] || 0;\n            if (index) {\n                map_1[filler.__mapid] = index;\n            } else {\n                delete map_1[filler.__mapid];\n            }\n            list[index] = filler;\n        }\n        delete map_1[node.__mapid];\n    }\n}\nfunction queueForUnobservation(observable) {\n    if (!observable.isPendingUnobservation) {\n        observable.isPendingUnobservation = true;\n        globalState.pendingUnobservations.push(observable);\n    }\n}\nfunction startBatch() {\n    globalState.inBatch++;\n}\nfunction endBatch() {\n    if (--globalState.inBatch === 0) {\n        runReactions();\n        var list = globalState.pendingUnobservations;\n        for (var i = 0; i < list.length; i++) {\n            var observable_1 = list[i];\n            observable_1.isPendingUnobservation = false;\n            if (observable_1.observers.length === 0) {\n                observable_1.onBecomeUnobserved();\n            }\n        }\n        globalState.pendingUnobservations = [];\n    }\n}\nfunction reportObserved(observable) {\n    var derivation = globalState.trackingDerivation;\n    if (derivation !== null) {\n        if (derivation.runId !== observable.lastAccessedBy) {\n            observable.lastAccessedBy = derivation.runId;\n            derivation.newObserving[derivation.unboundDepsCount++] = observable;\n        }\n    } else if (observable.observers.length === 0) {\n        queueForUnobservation(observable);\n    }\n}\nfunction invariantLOS(observable, msg) {\n    var min = getObservers(observable).reduce(function (a, b) {\n        return Math.min(a, b.dependenciesState);\n    }, 2);\n    if (min >= observable.lowestObserverState) return;\n    throw new Error(\"lowestObserverState is wrong for \" + msg + \" because \" + min + \" < \" + observable.lowestObserverState);\n}\nfunction propagateChanged(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale();\n        d.dependenciesState = IDerivationState.STALE;\n    }\n}\nfunction propagateChangeConfirmed(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.POSSIBLY_STALE) d.dependenciesState = IDerivationState.STALE;else if (d.dependenciesState === IDerivationState.UP_TO_DATE) observable.lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nfunction propagateMaybeChanged(observable) {\n    if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return;\n    observable.lowestObserverState = IDerivationState.POSSIBLY_STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {\n            d.dependenciesState = IDerivationState.POSSIBLY_STALE;\n            d.onBecomeStale();\n        }\n    }\n}\nvar Reaction = function () {\n    function Reaction(name, onInvalidate) {\n        if (name === void 0) {\n            name = \"Reaction@\" + getNextId();\n        }\n        this.name = name;\n        this.onInvalidate = onInvalidate;\n        this.observing = [];\n        this.newObserving = [];\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.diffValue = 0;\n        this.runId = 0;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.isDisposed = false;\n        this._isScheduled = false;\n        this._isTrackPending = false;\n        this._isRunning = false;\n    }\n    Reaction.prototype.onBecomeStale = function () {\n        this.schedule();\n    };\n    Reaction.prototype.schedule = function () {\n        if (!this._isScheduled) {\n            this._isScheduled = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    };\n    Reaction.prototype.isScheduled = function () {\n        return this._isScheduled;\n    };\n    Reaction.prototype.runReaction = function () {\n        if (!this.isDisposed) {\n            startBatch();\n            this._isScheduled = false;\n            if (shouldCompute(this)) {\n                this._isTrackPending = true;\n                this.onInvalidate();\n                if (this._isTrackPending && isSpyEnabled()) {\n                    spyReport({\n                        object: this,\n                        type: \"scheduled-reaction\"\n                    });\n                }\n            }\n            endBatch();\n        }\n    };\n    Reaction.prototype.track = function (fn) {\n        startBatch();\n        var notify = isSpyEnabled();\n        var startTime;\n        if (notify) {\n            startTime = Date.now();\n            spyReportStart({\n                object: this,\n                type: \"reaction\",\n                fn: fn\n            });\n        }\n        this._isRunning = true;\n        var result = trackDerivedFunction(this, fn, undefined);\n        this._isRunning = false;\n        this._isTrackPending = false;\n        if (this.isDisposed) {\n            clearObserving(this);\n        }\n        if (isCaughtException(result)) this.reportExceptionInDerivation(result.cause);\n        if (notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n        endBatch();\n    };\n    Reaction.prototype.reportExceptionInDerivation = function (error) {\n        var _this = this;\n        if (this.errorHandler) {\n            this.errorHandler(error, this);\n            return;\n        }\n        var message = \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this;\n        var messageToUser = getMessage(\"m037\");\n        console.error(message || messageToUser, error);\n        if (isSpyEnabled()) {\n            spyReport({\n                type: \"error\",\n                message: message,\n                error: error,\n                object: this\n            });\n        }\n        globalState.globalReactionErrorHandlers.forEach(function (f) {\n            return f(error, _this);\n        });\n    };\n    Reaction.prototype.dispose = function () {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            if (!this._isRunning) {\n                startBatch();\n                clearObserving(this);\n                endBatch();\n            }\n        }\n    };\n    Reaction.prototype.getDisposer = function () {\n        var r = this.dispose.bind(this);\n        r.$mobx = this;\n        r.onError = registerErrorHandler;\n        return r;\n    };\n    Reaction.prototype.toString = function () {\n        return \"Reaction[\" + this.name + \"]\";\n    };\n    Reaction.prototype.whyRun = function () {\n        var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        return \"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this._isRunning ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\";\n    };\n    return Reaction;\n}();\nexports.Reaction = Reaction;\nfunction registerErrorHandler(handler) {\n    invariant(this && this.$mobx && isReaction(this.$mobx), \"Invalid `this`\");\n    invariant(!this.$mobx.errorHandler, \"Only one onErrorHandler can be registered\");\n    this.$mobx.errorHandler = handler;\n}\nfunction onReactionError(handler) {\n    globalState.globalReactionErrorHandlers.push(handler);\n    return function () {\n        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n        if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);\n    };\n}\nvar MAX_REACTION_ITERATIONS = 100;\nvar reactionScheduler = function reactionScheduler(f) {\n    return f();\n};\nfunction runReactions() {\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) return;\n    reactionScheduler(runReactionsHelper);\n}\nfunction runReactionsHelper() {\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    while (allReactions.length > 0) {\n        if (++iterations === MAX_REACTION_ITERATIONS) {\n            console.error(\"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0]));\n            allReactions.splice(0);\n        }\n        var remainingReactions = allReactions.splice(0);\n        for (var i = 0, l = remainingReactions.length; i < l; i++) {\n            remainingReactions[i].runReaction();\n        }\n    }\n    globalState.isRunningReactions = false;\n}\nvar isReaction = createInstanceofPredicate(\"Reaction\", Reaction);\nfunction setReactionScheduler(fn) {\n    var baseScheduler = reactionScheduler;\n    reactionScheduler = function reactionScheduler(f) {\n        return fn(function () {\n            return baseScheduler(f);\n        });\n    };\n}\nfunction isSpyEnabled() {\n    return !!globalState.spyListeners.length;\n}\nfunction spyReport(event) {\n    if (!globalState.spyListeners.length) return;\n    var listeners = globalState.spyListeners;\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](event);\n    }\n}\nfunction spyReportStart(event) {\n    var change = objectAssign({}, event, { spyReportStart: true });\n    spyReport(change);\n}\nvar END_EVENT = { spyReportEnd: true };\nfunction spyReportEnd(change) {\n    if (change) spyReport(objectAssign({}, change, END_EVENT));else spyReport(END_EVENT);\n}\nfunction spy(listener) {\n    globalState.spyListeners.push(listener);\n    return once(function () {\n        var idx = globalState.spyListeners.indexOf(listener);\n        if (idx !== -1) globalState.spyListeners.splice(idx, 1);\n    });\n}\nexports.spy = spy;\nfunction hasInterceptors(interceptable) {\n    return interceptable.interceptors && interceptable.interceptors.length > 0;\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);\n    interceptors.push(handler);\n    return once(function () {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1) interceptors.splice(idx, 1);\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    try {\n        var interceptors = interceptable.interceptors;\n        if (interceptors) for (var i = 0, l = interceptors.length; i < l; i++) {\n            change = interceptors[i](change);\n            invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\");\n            if (!change) break;\n        }\n        return change;\n    } finally {\n        untrackedEnd(prevU);\n    }\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners && listenable.changeListeners.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners || (listenable.changeListeners = []);\n    listeners.push(handler);\n    return once(function () {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1) listeners.splice(idx, 1);\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners;\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](change);\n    }\n    untrackedEnd(prevU);\n}\nfunction asReference(value) {\n    deprecated(\"asReference is deprecated, use observable.ref instead\");\n    return observable.ref(value);\n}\nexports.asReference = asReference;\nfunction asStructure(value) {\n    deprecated(\"asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.\");\n    return observable.struct(value);\n}\nexports.asStructure = asStructure;\nfunction asFlat(value) {\n    deprecated(\"asFlat is deprecated, use observable.shallow instead\");\n    return observable.shallow(value);\n}\nexports.asFlat = asFlat;\nfunction asMap(data) {\n    deprecated(\"asMap is deprecated, use observable.map or observable.shallowMap instead\");\n    return observable.map(data || {});\n}\nexports.asMap = asMap;\nfunction isModifierDescriptor(thing) {\n    return (typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null && thing.isMobxModifierDescriptor === true;\n}\nexports.isModifierDescriptor = isModifierDescriptor;\nfunction createModifierDescriptor(enhancer, initialValue) {\n    invariant(!isModifierDescriptor(initialValue), \"Modifiers cannot be nested\");\n    return {\n        isMobxModifierDescriptor: true,\n        initialValue: initialValue,\n        enhancer: enhancer\n    };\n}\nfunction deepEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return observable.array(v, name);\n    if (isPlainObject(v)) return observable.object(v, name);\n    if (isES6Map(v)) return observable.map(v, name);\n    return v;\n}\nfunction shallowEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (v === undefined || v === null) return v;\n    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v)) return v;\n    if (Array.isArray(v)) return observable.shallowArray(v, name);\n    if (isPlainObject(v)) return observable.shallowObject(v, name);\n    if (isES6Map(v)) return observable.shallowMap(v, name);\n    return fail(\"The shallow modifier / decorator can only used in combination with arrays, objects and maps\");\n}\nfunction referenceEnhancer(newValue) {\n    return newValue;\n}\nfunction deepStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return new ObservableArray(v, deepStructEnhancer, name);\n    if (isES6Map(v)) return new ObservableMap(v, deepStructEnhancer, name);\n    if (isPlainObject(v)) {\n        var res = {};\n        asObservableObject(res, name);\n        extendObservableHelper(res, deepStructEnhancer, [v]);\n        return res;\n    }\n    return v;\n}\nfunction refStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    return v;\n}\nvar MAX_SPLICE_SIZE = 10000;\nvar safariPrototypeSetterInheritanceBug = function () {\n    var v = false;\n    var p = {};\n    Object.defineProperty(p, \"0\", { set: function set() {\n            v = true;\n        } });\n    Object.create(p)[\"0\"] = 1;\n    return v === false;\n}();\nvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\nvar StubArray = function () {\n    function StubArray() {}\n    return StubArray;\n}();\nStubArray.prototype = [];\nvar ObservableArrayAdministration = function () {\n    function ObservableArrayAdministration(name, enhancer, array, owned) {\n        this.array = array;\n        this.owned = owned;\n        this.lastKnownLength = 0;\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.atom = new BaseAtom(name || \"ObservableArray@\" + getNextId());\n        this.enhancer = function (newV, oldV) {\n            return enhancer(newV, oldV, name + \"[..]\");\n        };\n    }\n    ObservableArrayAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        if (fireImmediately) {\n            listener({\n                object: this.array,\n                type: \"splice\",\n                index: 0,\n                added: this.values.slice(),\n                addedCount: this.values.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    ObservableArrayAdministration.prototype.getArrayLength = function () {\n        this.atom.reportObserved();\n        return this.values.length;\n    };\n    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {\n        if (typeof newLength !== \"number\" || newLength < 0) throw new Error(\"[mobx.array] Out of range: \" + newLength);\n        var currentLength = this.values.length;\n        if (newLength === currentLength) return;else if (newLength > currentLength) {\n            var newItems = new Array(newLength - currentLength);\n            for (var i = 0; i < newLength - currentLength; i++) {\n                newItems[i] = undefined;\n            }this.spliceWithArray(currentLength, 0, newItems);\n        } else this.spliceWithArray(newLength, currentLength - newLength);\n    };\n    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {\n        if (oldLength !== this.lastKnownLength) throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\");\n        this.lastKnownLength += delta;\n        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1);\n    };\n    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        var _this = this;\n        checkIfStateModificationsAreAllowed(this.atom);\n        var length = this.values.length;\n        if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);\n        if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        if (newItems === undefined) newItems = [];\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.array,\n                type: \"splice\",\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change) return EMPTY_ARRAY;\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.map(function (v) {\n            return _this.enhancer(v, undefined);\n        });\n        var lengthDelta = newItems.length - deleteCount;\n        this.updateArrayLength(length, lengthDelta);\n        var res = this.spliceItemsIntoValues(index, deleteCount, newItems);\n        if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res);\n        return res;\n    };\n    ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) {\n        if (newItems.length < MAX_SPLICE_SIZE) {\n            return (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));\n        } else {\n            var res = this.values.slice(index, index + deleteCount);\n            this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount));\n            return res;\n        }\n        var _a;\n    };\n    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"update\",\n            index: index, newValue: newValue, oldValue: oldValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"splice\",\n            index: index, removed: removed, added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    return ObservableArrayAdministration;\n}();\nvar ObservableArray = function (_super) {\n    __extends(ObservableArray, _super);\n    function ObservableArray(initialValues, enhancer, name, owned) {\n        if (name === void 0) {\n            name = \"ObservableArray@\" + getNextId();\n        }\n        if (owned === void 0) {\n            owned = false;\n        }\n        var _this = _super.call(this) || this;\n        var adm = new ObservableArrayAdministration(name, enhancer, _this, owned);\n        addHiddenFinalProp(_this, \"$mobx\", adm);\n        if (initialValues && initialValues.length) {\n            adm.updateArrayLength(0, initialValues.length);\n            adm.values = initialValues.map(function (v) {\n                return enhancer(v, undefined, name + \"[..]\");\n            });\n            adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY);\n        } else {\n            adm.values = [];\n        }\n        if (safariPrototypeSetterInheritanceBug) {\n            Object.defineProperty(adm.array, \"0\", ENTRY_0);\n        }\n        return _this;\n    }\n    ObservableArray.prototype.intercept = function (handler) {\n        return this.$mobx.intercept(handler);\n    };\n    ObservableArray.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        return this.$mobx.observe(listener, fireImmediately);\n    };\n    ObservableArray.prototype.clear = function () {\n        return this.splice(0);\n    };\n    ObservableArray.prototype.concat = function () {\n        var arrays = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            arrays[_i] = arguments[_i];\n        }\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) {\n            return isObservableArray(a) ? a.peek() : a;\n        }));\n    };\n    ObservableArray.prototype.replace = function (newItems) {\n        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);\n    };\n    ObservableArray.prototype.toJS = function () {\n        return this.slice();\n    };\n    ObservableArray.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableArray.prototype.peek = function () {\n        return this.$mobx.values;\n    };\n    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {\n        if (fromIndex === void 0) {\n            fromIndex = 0;\n        }\n        this.$mobx.atom.reportObserved();\n        var items = this.$mobx.values,\n            l = items.length;\n        for (var i = fromIndex; i < l; i++) {\n            if (predicate.call(thisArg, items[i], i, this)) return items[i];\n        }return undefined;\n    };\n    ObservableArray.prototype.splice = function (index, deleteCount) {\n        var newItems = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            newItems[_i - 2] = arguments[_i];\n        }\n        switch (arguments.length) {\n            case 0:\n                return [];\n            case 1:\n                return this.$mobx.spliceWithArray(index);\n            case 2:\n                return this.$mobx.spliceWithArray(index, deleteCount);\n        }\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.push = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(adm.values.length, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.pop = function () {\n        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];\n    };\n    ObservableArray.prototype.shift = function () {\n        return this.splice(0, 1)[0];\n    };\n    ObservableArray.prototype.unshift = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(0, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.reverse = function () {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.reverse.apply(clone, arguments);\n    };\n    ObservableArray.prototype.sort = function (compareFn) {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.sort.apply(clone, arguments);\n    };\n    ObservableArray.prototype.remove = function (value) {\n        var idx = this.$mobx.values.indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    };\n    ObservableArray.prototype.move = function (fromIndex, toIndex) {\n        function checkIndex(index) {\n            if (index < 0) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\n            }\n            var length = this.$mobx.values.length;\n            if (index >= length) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\n            }\n        }\n        checkIndex.call(this, fromIndex);\n        checkIndex.call(this, toIndex);\n        if (fromIndex === toIndex) {\n            return;\n        }\n        var oldItems = this.$mobx.values;\n        var newItems;\n        if (fromIndex < toIndex) {\n            newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1));\n        } else {\n            newItems = oldItems.slice(0, toIndex).concat([oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\n        }\n        this.replace(newItems);\n    };\n    ObservableArray.prototype.toString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toString.apply(this.$mobx.values, arguments);\n    };\n    ObservableArray.prototype.toLocaleString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toLocaleString.apply(this.$mobx.values, arguments);\n    };\n    return ObservableArray;\n}(StubArray);\ndeclareIterator(ObservableArray.prototype, function () {\n    return arrayAsIterator(this.slice());\n});\nmakeNonEnumerable(ObservableArray.prototype, [\"constructor\", \"intercept\", \"observe\", \"clear\", \"concat\", \"replace\", \"toJS\", \"toJSON\", \"peek\", \"find\", \"splice\", \"spliceWithArray\", \"push\", \"pop\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"remove\", \"move\", \"toString\", \"toLocaleString\"]);\nObject.defineProperty(ObservableArray.prototype, \"length\", {\n    enumerable: false,\n    configurable: true,\n    get: function get() {\n        return this.$mobx.getArrayLength();\n    },\n    set: function set(newLength) {\n        this.$mobx.setArrayLength(newLength);\n    }\n});\n[\"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function (funcName) {\n    var baseFunc = Array.prototype[funcName];\n    invariant(typeof baseFunc === \"function\", \"Base function not defined on Array prototype: '\" + funcName + \"'\");\n    addHiddenProp(ObservableArray.prototype, funcName, function () {\n        this.$mobx.atom.reportObserved();\n        return baseFunc.apply(this.$mobx.values, arguments);\n    });\n});\nvar ENTRY_0 = {\n    configurable: true,\n    enumerable: false,\n    set: createArraySetter(0),\n    get: createArrayGetter(0)\n};\nfunction createArrayBufferItem(index) {\n    var set = createArraySetter(index);\n    var get = createArrayGetter(index);\n    Object.defineProperty(ObservableArray.prototype, \"\" + index, {\n        enumerable: false,\n        configurable: true,\n        set: set, get: get\n    });\n}\nfunction createArraySetter(index) {\n    return function (newValue) {\n        var adm = this.$mobx;\n        var values = adm.values;\n        if (index < values.length) {\n            checkIfStateModificationsAreAllowed(adm.atom);\n            var oldValue = values[index];\n            if (hasInterceptors(adm)) {\n                var change = interceptChange(adm, {\n                    type: \"update\",\n                    object: adm.array,\n                    index: index, newValue: newValue\n                });\n                if (!change) return;\n                newValue = change.newValue;\n            }\n            newValue = adm.enhancer(newValue, oldValue);\n            var changed = newValue !== oldValue;\n            if (changed) {\n                values[index] = newValue;\n                adm.notifyArrayChildUpdate(index, newValue, oldValue);\n            }\n        } else if (index === values.length) {\n            adm.spliceWithArray(index, 0, [newValue]);\n        } else throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length);\n    };\n}\nfunction createArrayGetter(index) {\n    return function () {\n        var impl = this.$mobx;\n        if (impl) {\n            if (index < impl.values.length) {\n                impl.atom.reportObserved();\n                return impl.values[index];\n            }\n            console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\");\n        }\n        return undefined;\n    };\n}\nfunction reserveArrayBuffer(max) {\n    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) {\n        createArrayBufferItem(index);\n    }OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n}\nreserveArrayBuffer(1000);\nvar isObservableArrayAdministration = createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\nfunction isObservableArray(thing) {\n    return isObject(thing) && isObservableArrayAdministration(thing.$mobx);\n}\nexports.isObservableArray = isObservableArray;\nvar ObservableMapMarker = {};\nvar ObservableMap = function () {\n    function ObservableMap(initialData, enhancer, name) {\n        if (enhancer === void 0) {\n            enhancer = deepEnhancer;\n        }\n        if (name === void 0) {\n            name = \"ObservableMap@\" + getNextId();\n        }\n        this.enhancer = enhancer;\n        this.name = name;\n        this.$mobx = ObservableMapMarker;\n        this._data = {};\n        this._hasMap = {};\n        this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + \".keys()\", true);\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.merge(initialData);\n    }\n    ObservableMap.prototype._has = function (key) {\n        return typeof this._data[key] !== \"undefined\";\n    };\n    ObservableMap.prototype.has = function (key) {\n        if (!this.isValidKey(key)) return false;\n        key = \"\" + key;\n        if (this._hasMap[key]) return this._hasMap[key].get();\n        return this._updateHasMapEntry(key, false).get();\n    };\n    ObservableMap.prototype.set = function (key, value) {\n        this.assertValidKey(key);\n        key = \"\" + key;\n        var hasKey = this._has(key);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? \"update\" : \"add\",\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change) return this;\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this._updateValue(key, value);\n        } else {\n            this._addValue(key, value);\n        }\n        return this;\n    };\n    ObservableMap.prototype.delete = function (key) {\n        var _this = this;\n        this.assertValidKey(key);\n        key = \"\" + key;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: \"delete\",\n                object: this,\n                name: key\n            });\n            if (!change) return false;\n        }\n        if (this._has(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"delete\",\n                object: this,\n                oldValue: this._data[key].value,\n                name: key\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            runInTransaction(function () {\n                _this._keys.remove(key);\n                _this._updateHasMapEntry(key, false);\n                var observable = _this._data[key];\n                observable.setNewValue(undefined);\n                _this._data[key] = undefined;\n            });\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n            return true;\n        }\n        return false;\n    };\n    ObservableMap.prototype._updateHasMapEntry = function (key, value) {\n        var entry = this._hasMap[key];\n        if (entry) {\n            entry.setNewValue(value);\n        } else {\n            entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + \".\" + key + \"?\", false);\n        }\n        return entry;\n    };\n    ObservableMap.prototype._updateValue = function (name, newValue) {\n        var observable = this._data[name];\n        newValue = observable.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"update\",\n                object: this,\n                oldValue: observable.value,\n                name: name, newValue: newValue\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            observable.setNewValue(newValue);\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableMap.prototype._addValue = function (name, newValue) {\n        var _this = this;\n        runInTransaction(function () {\n            var observable = _this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + \".\" + name, false);\n            newValue = observable.value;\n            _this._updateHasMapEntry(name, true);\n            _this._keys.push(name);\n        });\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            type: \"add\",\n            object: this,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableMap.prototype.get = function (key) {\n        key = \"\" + key;\n        if (this.has(key)) return this._data[key].get();\n        return undefined;\n    };\n    ObservableMap.prototype.keys = function () {\n        return arrayAsIterator(this._keys.slice());\n    };\n    ObservableMap.prototype.values = function () {\n        return arrayAsIterator(this._keys.map(this.get, this));\n    };\n    ObservableMap.prototype.entries = function () {\n        var _this = this;\n        return arrayAsIterator(this._keys.map(function (key) {\n            return [key, _this.get(key)];\n        }));\n    };\n    ObservableMap.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        this.keys().forEach(function (key) {\n            return callback.call(thisArg, _this.get(key), key, _this);\n        });\n    };\n    ObservableMap.prototype.merge = function (other) {\n        var _this = this;\n        if (isObservableMap(other)) {\n            other = other.toJS();\n        }\n        runInTransaction(function () {\n            if (isPlainObject(other)) Object.keys(other).forEach(function (key) {\n                return _this.set(key, other[key]);\n            });else if (Array.isArray(other)) other.forEach(function (_a) {\n                var key = _a[0],\n                    value = _a[1];\n                return _this.set(key, value);\n            });else if (isES6Map(other)) other.forEach(function (value, key) {\n                return _this.set(key, value);\n            });else if (other !== null && other !== undefined) fail(\"Cannot initialize map from \" + other);\n        });\n        return this;\n    };\n    ObservableMap.prototype.clear = function () {\n        var _this = this;\n        runInTransaction(function () {\n            untracked(function () {\n                _this.keys().forEach(_this.delete, _this);\n            });\n        });\n    };\n    ObservableMap.prototype.replace = function (values) {\n        var _this = this;\n        runInTransaction(function () {\n            _this.clear();\n            _this.merge(values);\n        });\n        return this;\n    };\n    Object.defineProperty(ObservableMap.prototype, \"size\", {\n        get: function get() {\n            return this._keys.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObservableMap.prototype.toJS = function () {\n        var _this = this;\n        var res = {};\n        this.keys().forEach(function (key) {\n            return res[key] = _this.get(key);\n        });\n        return res;\n    };\n    ObservableMap.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableMap.prototype.isValidKey = function (key) {\n        if (key === null || key === undefined) return false;\n        if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"boolean\") return true;\n        return false;\n    };\n    ObservableMap.prototype.assertValidKey = function (key) {\n        if (!this.isValidKey(key)) throw new Error(\"[mobx.map] Invalid key: '\" + key + \"', only strings, numbers and booleans are accepted as key in observable maps.\");\n    };\n    ObservableMap.prototype.toString = function () {\n        var _this = this;\n        return this.name + \"[{ \" + this.keys().map(function (key) {\n            return key + \": \" + (\"\" + _this.get(key));\n        }).join(\", \") + \" }]\";\n    };\n    ObservableMap.prototype.observe = function (listener, fireImmediately) {\n        invariant(fireImmediately !== true, getMessage(\"m033\"));\n        return registerListener(this, listener);\n    };\n    ObservableMap.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableMap;\n}();\nexports.ObservableMap = ObservableMap;\ndeclareIterator(ObservableMap.prototype, function () {\n    return this.entries();\n});\nfunction map(initialValues) {\n    deprecated(\"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\");\n    return observable.map(initialValues);\n}\nexports.map = map;\nvar isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap);\nexports.isObservableMap = isObservableMap;\nvar ObservableObjectAdministration = function () {\n    function ObservableObjectAdministration(target, name) {\n        this.target = target;\n        this.name = name;\n        this.values = {};\n        this.changeListeners = null;\n        this.interceptors = null;\n    }\n    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {\n        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\");\n        return registerListener(this, callback);\n    };\n    ObservableObjectAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableObjectAdministration;\n}();\nfunction asObservableObject(target, name) {\n    if (isObservableObject(target)) return target.$mobx;\n    invariant(Object.isExtensible(target), getMessage(\"m035\"));\n    if (!isPlainObject(target)) name = (target.constructor.name || \"ObservableObject\") + \"@\" + getNextId();\n    if (!name) name = \"ObservableObject@\" + getNextId();\n    var adm = new ObservableObjectAdministration(target, name);\n    addHiddenFinalProp(target, \"$mobx\", adm);\n    return adm;\n}\nfunction defineObservablePropertyFromDescriptor(adm, propName, descriptor, defaultEnhancer) {\n    if (adm.values[propName]) {\n        invariant(\"value\" in descriptor, \"The property \" + propName + \" in \" + adm.name + \" is already observable, cannot redefine it as computed property\");\n        adm.target[propName] = descriptor.value;\n        return;\n    }\n    if (\"value\" in descriptor) {\n        if (isModifierDescriptor(descriptor.value)) {\n            var modifierDescriptor = descriptor.value;\n            defineObservableProperty(adm, propName, modifierDescriptor.initialValue, modifierDescriptor.enhancer);\n        } else if (isAction(descriptor.value) && descriptor.value.autoBind === true) {\n            defineBoundAction(adm.target, propName, descriptor.value.originalFn);\n        } else if (isComputedValue(descriptor.value)) {\n            defineComputedPropertyFromComputedValue(adm, propName, descriptor.value);\n        } else {\n            defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer);\n        }\n    } else {\n        defineComputedProperty(adm, propName, descriptor.get, descriptor.set, false, true);\n    }\n}\nfunction defineObservableProperty(adm, propName, newValue, enhancer) {\n    assertPropertyConfigurable(adm.target, propName);\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            object: adm.target,\n            name: propName,\n            type: \"add\",\n            newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    var observable = adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + \".\" + propName, false);\n    newValue = observable.value;\n    Object.defineProperty(adm.target, propName, generateObservablePropConfig(propName));\n    notifyPropertyAddition(adm, adm.target, propName, newValue);\n}\nfunction defineComputedProperty(adm, propName, getter, setter, compareStructural, asInstanceProperty) {\n    if (asInstanceProperty) assertPropertyConfigurable(adm.target, propName);\n    adm.values[propName] = new ComputedValue(getter, adm.target, compareStructural, adm.name + \".\" + propName, setter);\n    if (asInstanceProperty) {\n        Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n    }\n}\nfunction defineComputedPropertyFromComputedValue(adm, propName, computedValue) {\n    var name = adm.name + \".\" + propName;\n    computedValue.name = name;\n    if (!computedValue.scope) computedValue.scope = adm.target;\n    adm.values[propName] = computedValue;\n    Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n}\nvar observablePropertyConfigs = {};\nvar computedPropertyConfigs = {};\nfunction generateObservablePropConfig(propName) {\n    return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            setPropertyValue(this, propName, v);\n        }\n    });\n}\nfunction generateComputedPropConfig(propName) {\n    return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: false,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            return this.$mobx.values[propName].set(v);\n        }\n    });\n}\nfunction setPropertyValue(instance, name, newValue) {\n    var adm = instance.$mobx;\n    var observable = adm.values[name];\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            type: \"update\",\n            object: instance,\n            name: name, newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    newValue = observable.prepareNewValue(newValue);\n    if (newValue !== UNCHANGED) {\n        var notify = hasListeners(adm);\n        var notifySpy = isSpyEnabled();\n        var change = notify || notifySpy ? {\n            type: \"update\",\n            object: instance,\n            oldValue: observable.value,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        observable.setNewValue(newValue);\n        if (notify) notifyListeners(adm, change);\n        if (notifySpy) spyReportEnd();\n    }\n}\nfunction notifyPropertyAddition(adm, object, name, newValue) {\n    var notify = hasListeners(adm);\n    var notifySpy = isSpyEnabled();\n    var change = notify || notifySpy ? {\n        type: \"add\",\n        object: object, name: name, newValue: newValue\n    } : null;\n    if (notifySpy) spyReportStart(change);\n    if (notify) notifyListeners(adm, change);\n    if (notifySpy) spyReportEnd();\n}\nvar isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\nfunction isObservableObject(thing) {\n    if (isObject(thing)) {\n        runLazyInitializers(thing);\n        return isObservableObjectAdministration(thing.$mobx);\n    }\n    return false;\n}\nexports.isObservableObject = isObservableObject;\nvar UNCHANGED = {};\nvar ObservableValue = function (_super) {\n    __extends(ObservableValue, _super);\n    function ObservableValue(value, enhancer, name, notifySpy) {\n        if (name === void 0) {\n            name = \"ObservableValue@\" + getNextId();\n        }\n        if (notifySpy === void 0) {\n            notifySpy = true;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.enhancer = enhancer;\n        _this.hasUnreportedChange = false;\n        _this.value = enhancer(value, undefined, name);\n        if (notifySpy && isSpyEnabled()) {\n            spyReport({ type: \"create\", object: _this, newValue: _this.value });\n        }\n        return _this;\n    }\n    ObservableValue.prototype.set = function (newValue) {\n        var oldValue = this.value;\n        newValue = this.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if (notifySpy) {\n                spyReportStart({\n                    type: \"update\",\n                    object: this,\n                    newValue: newValue, oldValue: oldValue\n                });\n            }\n            this.setNewValue(newValue);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableValue.prototype.prepareNewValue = function (newValue) {\n        checkIfStateModificationsAreAllowed(this);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue });\n            if (!change) return UNCHANGED;\n            newValue = change.newValue;\n        }\n        newValue = this.enhancer(newValue, this.value, this.name);\n        return this.value !== newValue ? newValue : UNCHANGED;\n    };\n    ObservableValue.prototype.setNewValue = function (newValue) {\n        var oldValue = this.value;\n        this.value = newValue;\n        this.reportChanged();\n        if (hasListeners(this)) {\n            notifyListeners(this, {\n                type: \"update\",\n                object: this,\n                newValue: newValue,\n                oldValue: oldValue\n            });\n        }\n    };\n    ObservableValue.prototype.get = function () {\n        this.reportObserved();\n        return this.value;\n    };\n    ObservableValue.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableValue.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately) listener({\n            object: this,\n            type: \"update\",\n            newValue: this.value,\n            oldValue: undefined\n        });\n        return registerListener(this, listener);\n    };\n    ObservableValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ObservableValue.prototype.toString = function () {\n        return this.name + \"[\" + this.value + \"]\";\n    };\n    ObservableValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    return ObservableValue;\n}(BaseAtom);\nObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf;\nvar isObservableValue = createInstanceofPredicate(\"ObservableValue\", ObservableValue);\nexports.isBoxedObservable = isObservableValue;\nfunction getAtom(thing, property) {\n    if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            invariant(property === undefined, getMessage(\"m036\"));\n            return thing.$mobx.atom;\n        }\n        if (isObservableMap(thing)) {\n            var anyThing = thing;\n            if (property === undefined) return getAtom(anyThing._keys);\n            var observable_2 = anyThing._data[property] || anyThing._hasMap[property];\n            invariant(!!observable_2, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\");\n            return observable_2;\n        }\n        runLazyInitializers(thing);\n        if (isObservableObject(thing)) {\n            if (!property) return fail(\"please specify a property\");\n            var observable_3 = thing.$mobx.values[property];\n            invariant(!!observable_3, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\");\n            return observable_3;\n        }\n        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n            return thing;\n        }\n    } else if (typeof thing === \"function\") {\n        if (isReaction(thing.$mobx)) {\n            return thing.$mobx;\n        }\n    }\n    return fail(\"Cannot obtain atom from \" + thing);\n}\nfunction getAdministration(thing, property) {\n    invariant(thing, \"Expecting some object\");\n    if (property !== undefined) return getAdministration(getAtom(thing, property));\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;\n    if (isObservableMap(thing)) return thing;\n    runLazyInitializers(thing);\n    if (thing.$mobx) return thing.$mobx;\n    invariant(false, \"Cannot obtain administration from \" + thing);\n}\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing)) named = getAdministration(thing);else named = getAtom(thing);\n    return named.name;\n}\nfunction createClassPropertyDecorator(onInitialize, _get, _set, enumerable, allowCustomArguments) {\n    function classPropertyDecorator(target, key, descriptor, customArgs, argLen) {\n        if (argLen === void 0) {\n            argLen = 0;\n        }\n        invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\");\n        if (!descriptor) {\n            var newDescriptor = {\n                enumerable: enumerable,\n                configurable: true,\n                get: function get() {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {\n                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);\n                    } else {\n                        _set.call(this, key, v);\n                    }\n                }\n            };\n            if (arguments.length < 3 || arguments.length === 5 && argLen < 3) {\n                Object.defineProperty(target, key, newDescriptor);\n            }\n            return newDescriptor;\n        } else {\n            if (!hasOwnProperty(target, \"__mobxLazyInitializers\")) {\n                addHiddenProp(target, \"__mobxLazyInitializers\", target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice() || []);\n            }\n            var value_1 = descriptor.value,\n                initializer_1 = descriptor.initializer;\n            target.__mobxLazyInitializers.push(function (instance) {\n                onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor);\n            });\n            return {\n                enumerable: enumerable, configurable: true,\n                get: function get() {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    _set.call(this, key, v);\n                }\n            };\n        }\n    }\n    if (allowCustomArguments) {\n        return function () {\n            if (quacksLikeADecorator(arguments)) return classPropertyDecorator.apply(null, arguments);\n            var outerArgs = arguments;\n            var argLen = arguments.length;\n            return function (target, key, descriptor) {\n                return classPropertyDecorator(target, key, descriptor, outerArgs, argLen);\n            };\n        };\n    }\n    return classPropertyDecorator;\n}\nfunction typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {\n    if (!hasOwnProperty(instance, \"__mobxInitializedProps\")) addHiddenProp(instance, \"__mobxInitializedProps\", {});\n    instance.__mobxInitializedProps[key] = true;\n    onInitialize(instance, key, v, customArgs, baseDescriptor);\n}\nfunction runLazyInitializers(instance) {\n    if (instance.__mobxDidRunLazyInitializers === true) return;\n    if (instance.__mobxLazyInitializers) {\n        addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true);\n        instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) {\n            return initializer(instance);\n        });\n    }\n}\nfunction quacksLikeADecorator(args) {\n    return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\";\n}\nfunction iteratorSymbol() {\n    return typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n}\nvar IS_ITERATING_MARKER = \"__$$iterating\";\nfunction arrayAsIterator(array) {\n    invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\");\n    addHiddenFinalProp(array, IS_ITERATING_MARKER, true);\n    var idx = -1;\n    addHiddenFinalProp(array, \"next\", function next() {\n        idx++;\n        return {\n            done: idx >= this.length,\n            value: idx < this.length ? this[idx] : undefined\n        };\n    });\n    return array;\n}\nfunction declareIterator(prototType, iteratorFactory) {\n    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);\n}\nvar messages = {\n    \"m001\": \"It is not allowed to assign new values to @action fields\",\n    \"m002\": \"`runInAction` expects a function\",\n    \"m003\": \"`runInAction` expects a function without arguments\",\n    \"m004\": \"autorun expects a function\",\n    \"m005\": \"Warning: attempted to pass an action to autorun. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m006\": \"Warning: attempted to pass an action to autorunAsync. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m007\": \"reaction only accepts 2 or 3 arguments. If migrating from MobX 2, please provide an options object\",\n    \"m008\": \"wrapping reaction expression in `asReference` is no longer supported, use options object instead\",\n    \"m009\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\",\n    \"m010\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\",\n    \"m011\": \"First argument to `computed` should be an expression. If using computed as decorator, don't pass it arguments\",\n    \"m012\": \"computed takes one or two arguments if used as function\",\n    \"m013\": \"[mobx.expr] 'expr' should only be used inside other reactive functions.\",\n    \"m014\": \"extendObservable expected 2 or more arguments\",\n    \"m015\": \"extendObservable expects an object as first argument\",\n    \"m016\": \"extendObservable should not be used on maps, use map.merge instead\",\n    \"m017\": \"all arguments of extendObservable should be objects\",\n    \"m018\": \"extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540\",\n    \"m019\": \"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\",\n    \"m020\": \"modifiers can only be used for individual object properties\",\n    \"m021\": \"observable expects zero or one arguments\",\n    \"m022\": \"@observable can not be used on getters, use @computed instead\",\n    \"m023\": \"Using `transaction` is deprecated, use `runInAction` or `(@)action` instead.\",\n    \"m024\": \"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested its value.\",\n    \"m025\": \"whyRun can only be used on reactions and computed values\",\n    \"m026\": \"`action` can only be invoked on functions\",\n    \"m028\": \"It is not allowed to set `useStrict` when a derivation is running\",\n    \"m029\": \"INTERNAL ERROR only onBecomeUnobserved shouldn't be called twice in a row\",\n    \"m030a\": \"Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: \",\n    \"m030b\": \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: \",\n    \"m031\": \"Computed values are not allowed to not cause side effects by changing observables that are already being observed. Tried to modify: \",\n    \"m032\": \"* This computation is suspended (not in use by any reaction) and won't run automatically.\\n\tDidn't expect this computation to be suspended at this point?\\n\t  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n\t  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\",\n    \"m033\": \"`observe` doesn't support the fire immediately property for observable maps.\",\n    \"m034\": \"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\",\n    \"m035\": \"Cannot make the designated object observable; it is not extensible\",\n    \"m036\": \"It is not possible to get index atoms from arrays\",\n    \"m037\": \"Hi there! I'm sorry you have just run into an exception.\\nIf your debugger ends up here, know that some reaction (like the render() of an observer component, autorun or reaction)\\nthrew an exception and that mobx caught it, to avoid that it brings the rest of your application down.\\nThe original cause of the exception (the code that caused this reaction to run (again)), is still in the stack.\\n\\nHowever, more interesting is the actual stack trace of the error itself.\\nHopefully the error is an instanceof Error, because in that case you can inspect the original stack of the error from where it was thrown.\\nSee `error.stack` property, or press the very subtle \\\"(...)\\\" link you see near the console.error message that probably brought you here.\\nThat stack is more interesting than the stack of this console.error itself.\\n\\nIf the exception you see is an exception you created yourself, make sure to use `throw new Error(\\\"Oops\\\")` instead of `throw \\\"Oops\\\"`,\\nbecause the javascript environment will only preserve the original stack trace in the first form.\\n\\nYou can also make sure the debugger pauses the next time this very same exception is thrown by enabling \\\"Pause on caught exception\\\".\\n(Note that it might pause on many other, unrelated exception as well).\\n\\nIf that all doesn't help you out, feel free to open an issue https://github.com/mobxjs/mobx/issues!\\n\",\n    \"m038\": \"Missing items in this list?\\n    1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n    2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\"\n};\nfunction getMessage(id) {\n    return messages[id];\n}\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nfunction getGlobal() {\n    return global;\n}\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\nfunction fail(message, thing) {\n    invariant(false, message, thing);\n    throw \"X\";\n}\nfunction invariant(check, message, thing) {\n    if (!check) throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\"));\n}\nvar deprecatedMessages = [];\nfunction deprecated(msg) {\n    if (deprecatedMessages.indexOf(msg) !== -1) return false;\n    deprecatedMessages.push(msg);\n    console.error(\"[mobx] Deprecated: \" + msg);\n    return true;\n}\nfunction once(func) {\n    var invoked = false;\n    return function () {\n        if (invoked) return;\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function noop() {};\nfunction unique(list) {\n    var res = [];\n    list.forEach(function (item) {\n        if (res.indexOf(item) === -1) res.push(item);\n    });\n    return res;\n}\nfunction joinStrings(things, limit, separator) {\n    if (limit === void 0) {\n        limit = 100;\n    }\n    if (separator === void 0) {\n        separator = \" - \";\n    }\n    if (!things) return \"\";\n    var sliced = things.slice(0, limit);\n    return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\");\n}\nfunction isObject(value) {\n    return value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\";\n}\nfunction isPlainObject(value) {\n    if (value === null || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false;\n    var proto = Object.getPrototypeOf(value);\n    return proto === Object.prototype || proto === null;\n}\nfunction objectAssign() {\n    var res = arguments[0];\n    for (var i = 1, l = arguments.length; i < l; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n            if (hasOwnProperty(source, key)) {\n                res[key] = source[key];\n            }\n        }\n    }\n    return res;\n}\nfunction valueDidChange(compareStructural, oldValue, newValue) {\n    if (typeof oldValue === 'number' && isNaN(oldValue)) {\n        return typeof newValue !== 'number' || !isNaN(newValue);\n    }\n    return compareStructural ? !deepEqual(oldValue, newValue) : oldValue !== newValue;\n}\nvar prototypeHasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(object, propName) {\n    return prototypeHasOwnProperty.call(object, propName);\n}\nfunction makeNonEnumerable(object, propNames) {\n    for (var i = 0; i < propNames.length; i++) {\n        addHiddenProp(object, propNames[i], object[propNames[i]]);\n    }\n}\nfunction addHiddenProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\nfunction isPropertyConfigurable(object, prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(object, prop);\n    return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;\n}\nfunction assertPropertyConfigurable(object, prop) {\n    invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\");\n}\nfunction getEnumerableKeys(obj) {\n    var res = [];\n    for (var key in obj) {\n        res.push(key);\n    }return res;\n}\nfunction deepEqual(a, b) {\n    if (a === null && b === null) return true;\n    if (a === undefined && b === undefined) return true;\n    if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) !== \"object\") return a === b;\n    var aIsArray = isArrayLike(a);\n    var aIsMap = isMapLike(a);\n    if (aIsArray !== isArrayLike(b)) {\n        return false;\n    } else if (aIsMap !== isMapLike(b)) {\n        return false;\n    } else if (aIsArray) {\n        if (a.length !== b.length) return false;\n        for (var i = a.length - 1; i >= 0; i--) {\n            if (!deepEqual(a[i], b[i])) return false;\n        }return true;\n    } else if (aIsMap) {\n        if (a.size !== b.size) return false;\n        var equals_1 = true;\n        a.forEach(function (value, key) {\n            equals_1 = equals_1 && deepEqual(b.get(key), value);\n        });\n        return equals_1;\n    } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === \"object\" && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === \"object\") {\n        if (a === null || b === null) return false;\n        if (isMapLike(a) && isMapLike(b)) {\n            if (a.size !== b.size) return false;\n            return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries());\n        }\n        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length) return false;\n        for (var prop in a) {\n            if (!(prop in b)) return false;\n            if (!deepEqual(a[prop], b[prop])) return false;\n        }\n        return true;\n    }\n    return false;\n}\nfunction createInstanceofPredicate(name, clazz) {\n    var propName = \"isMobX\" + name;\n    clazz.prototype[propName] = true;\n    return function (x) {\n        return isObject(x) && x[propName] === true;\n    };\n}\nfunction isArrayLike(x) {\n    return Array.isArray(x) || isObservableArray(x);\n}\nexports.isArrayLike = isArrayLike;\nfunction isMapLike(x) {\n    return isES6Map(x) || isObservableMap(x);\n}\nfunction isES6Map(thing) {\n    if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map) return true;\n    return false;\n}\nfunction primitiveSymbol() {\n    return typeof Symbol === \"function\" && Symbol.toPrimitive || \"@@toPrimitive\";\n}\nfunction toPrimitive(value) {\n    return value === null ? null : (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? \"\" + value : value;\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _icons = __webpack_require__(6);\n\nvar _constants = __webpack_require__(0);\n\nfunction renderHeader(_ref, instance) {\n  var meta = _ref.meta,\n      user = _ref.user,\n      reactions = _ref.reactions;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-header-container';\n\n  var likeButton = document.createElement('span');\n  var likedReaction = reactions.find(function (reaction) {\n    return reaction.content === 'heart' && reaction.user.login === user.login;\n  });\n  likeButton.className = 'gitment-header-like-btn';\n  likeButton.innerHTML = '\\n    ' + _icons.heart + '\\n    ' + (likedReaction ? 'Unlike' : 'Like') + '\\n    ' + (meta.reactions && meta.reactions.heart ? ' \\u2022 <strong>' + meta.reactions.heart + '</strong> Liked' : '') + '\\n  ';\n\n  if (likedReaction) {\n    likeButton.classList.add('liked');\n    likeButton.onclick = function () {\n      return instance.unlike();\n    };\n  } else {\n    likeButton.classList.remove('liked');\n    likeButton.onclick = function () {\n      return instance.like();\n    };\n  }\n  container.appendChild(likeButton);\n\n  var commentsCount = document.createElement('span');\n  commentsCount.innerHTML = '\\n    ' + (meta.comments ? ' \\u2022 <strong>' + meta.comments + '</strong> Comments' : '') + '\\n  ';\n  container.appendChild(commentsCount);\n\n  var issueLink = document.createElement('a');\n  issueLink.className = 'gitment-header-issue-link';\n  issueLink.href = meta.html_url;\n  issueLink.target = '_blank';\n  issueLink.innerText = 'Issue Page';\n  container.appendChild(issueLink);\n\n  return container;\n}\n\nfunction renderComments(_ref2, instance) {\n  var meta = _ref2.meta,\n      comments = _ref2.comments,\n      commentReactions = _ref2.commentReactions,\n      currentPage = _ref2.currentPage,\n      user = _ref2.user,\n      error = _ref2.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-comments-container';\n\n  if (error) {\n    var errorBlock = document.createElement('div');\n    errorBlock.className = 'gitment-comments-error';\n\n    if (error === _constants.NOT_INITIALIZED_ERROR && user.login && user.login.toLowerCase() === instance.owner.toLowerCase()) {\n      var initHint = document.createElement('div');\n      var initButton = document.createElement('button');\n      initButton.className = 'gitment-comments-init-btn';\n      initButton.onclick = function () {\n        initButton.setAttribute('disabled', true);\n        instance.init().catch(function (e) {\n          initButton.removeAttribute('disabled');\n          alert(e);\n        });\n      };\n      initButton.innerText = 'Initialize Comments';\n      initHint.appendChild(initButton);\n      errorBlock.appendChild(initHint);\n    } else {\n      errorBlock.innerText = error;\n    }\n    container.appendChild(errorBlock);\n    return container;\n  } else if (comments === undefined) {\n    var loading = document.createElement('div');\n    loading.innerText = 'Loading comments...';\n    loading.className = 'gitment-comments-loading';\n    container.appendChild(loading);\n    return container;\n  } else if (!comments.length) {\n    var emptyBlock = document.createElement('div');\n    emptyBlock.className = 'gitment-comments-empty';\n    emptyBlock.innerText = 'No Comment Yet';\n    container.appendChild(emptyBlock);\n    return container;\n  }\n\n  var commentsList = document.createElement('ul');\n  commentsList.className = 'gitment-comments-list';\n\n  comments.forEach(function (comment) {\n    var createDate = new Date(comment.created_at);\n    var updateDate = new Date(comment.updated_at);\n    var commentItem = document.createElement('li');\n    commentItem.className = 'gitment-comment';\n    commentItem.innerHTML = '\\n      <a class=\"gitment-comment-avatar\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n        <img class=\"gitment-comment-avatar-img\" src=\"' + comment.user.avatar_url + '\"/>\\n      </a>\\n      <div class=\"gitment-comment-main\">\\n        <div class=\"gitment-comment-header\">\\n          <a class=\"gitment-comment-name\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n            ' + comment.user.login + '\\n          </a>\\n          commented on\\n          <span title=\"' + createDate + '\">' + createDate.toDateString() + '</span>\\n          ' + (createDate.toString() !== updateDate.toString() ? ' \\u2022 <span title=\"comment was edited at ' + updateDate + '\">edited</span>' : '') + '\\n          <div class=\"gitment-comment-like-btn\">' + _icons.heart + ' ' + (comment.reactions.heart || '') + '</div>\\n        </div>\\n        <div class=\"gitment-comment-body gitment-markdown\">' + comment.body_html + '</div>\\n      </div>\\n    ';\n    var likeButton = commentItem.querySelector('.gitment-comment-like-btn');\n    var likedReaction = commentReactions[comment.id] && commentReactions[comment.id].find(function (reaction) {\n      return reaction.content === 'heart' && reaction.user.login === user.login;\n    });\n    if (likedReaction) {\n      likeButton.classList.add('liked');\n      likeButton.onclick = function () {\n        return instance.unlikeAComment(comment.id);\n      };\n    } else {\n      likeButton.classList.remove('liked');\n      likeButton.onclick = function () {\n        return instance.likeAComment(comment.id);\n      };\n    }\n\n    // dirty\n    // use a blank image to trigger height calculating when element rendered\n    var imgTrigger = document.createElement('img');\n    var markdownBody = commentItem.querySelector('.gitment-comment-body');\n    imgTrigger.className = 'gitment-hidden';\n    imgTrigger.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    imgTrigger.onload = function () {\n      if (markdownBody.clientHeight > instance.maxCommentHeight) {\n        markdownBody.classList.add('gitment-comment-body-folded');\n        markdownBody.style.maxHeight = instance.maxCommentHeight + 'px';\n        markdownBody.title = 'Click to Expand';\n        markdownBody.onclick = function () {\n          markdownBody.classList.remove('gitment-comment-body-folded');\n          markdownBody.style.maxHeight = '';\n          markdownBody.title = '';\n          markdownBody.onclick = null;\n        };\n      }\n    };\n    commentItem.appendChild(imgTrigger);\n\n    commentsList.appendChild(commentItem);\n  });\n\n  container.appendChild(commentsList);\n\n  if (meta) {\n    var pageCount = Math.ceil(meta.comments / instance.perPage);\n    if (pageCount > 1) {\n      var pagination = document.createElement('ul');\n      pagination.className = 'gitment-comments-pagination';\n\n      if (currentPage > 1) {\n        var previousButton = document.createElement('li');\n        previousButton.className = 'gitment-comments-page-item';\n        previousButton.innerText = 'Previous';\n        previousButton.onclick = function () {\n          return instance.goto(currentPage - 1);\n        };\n        pagination.appendChild(previousButton);\n      }\n\n      var _loop = function _loop(i) {\n        var pageItem = document.createElement('li');\n        pageItem.className = 'gitment-comments-page-item';\n        pageItem.innerText = i;\n        pageItem.onclick = function () {\n          return instance.goto(i);\n        };\n        if (currentPage === i) pageItem.classList.add('gitment-selected');\n        pagination.appendChild(pageItem);\n      };\n\n      for (var i = 1; i <= pageCount; i++) {\n        _loop(i);\n      }\n\n      if (currentPage < pageCount) {\n        var nextButton = document.createElement('li');\n        nextButton.className = 'gitment-comments-page-item';\n        nextButton.innerText = 'Next';\n        nextButton.onclick = function () {\n          return instance.goto(currentPage + 1);\n        };\n        pagination.appendChild(nextButton);\n      }\n\n      container.appendChild(pagination);\n    }\n  }\n\n  return container;\n}\n\nfunction renderEditor(_ref3, instance) {\n  var user = _ref3.user,\n      error = _ref3.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-editor-container';\n\n  var shouldDisable = user.login && !error ? '' : 'disabled';\n  var disabledTip = user.login ? '' : 'Login to Comment';\n  container.innerHTML = '\\n      ' + (user.login ? '<a class=\"gitment-editor-avatar\" href=\"' + user.html_url + '\" target=\"_blank\">\\n            <img class=\"gitment-editor-avatar-img\" src=\"' + user.avatar_url + '\"/>\\n          </a>' : user.isLoggingIn ? '<div class=\"gitment-editor-avatar\">' + _icons.spinner + '</div>' : '<a class=\"gitment-editor-avatar\" href=\"' + instance.loginLink + '\" title=\"login with GitHub\">\\n              ' + _icons.github + '\\n            </a>') + '\\n    </a>\\n    <div class=\"gitment-editor-main\">\\n      <div class=\"gitment-editor-header\">\\n        <nav class=\"gitment-editor-tabs\">\\n          <button class=\"gitment-editor-tab gitment-selected\">Write</button>\\n          <button class=\"gitment-editor-tab\">Preview</button>\\n        </nav>\\n        <div class=\"gitment-editor-login\">\\n          ' + (user.login ? '<a class=\"gitment-editor-logout-link\">Logout</a>' : user.isLoggingIn ? 'Logging in...' : '<a class=\"gitment-editor-login-link\" href=\"' + instance.loginLink + '\">Login</a> with GitHub') + '\\n        </div>\\n      </div>\\n      <div class=\"gitment-editor-body\">\\n        <div class=\"gitment-editor-write-field\">\\n          <textarea placeholder=\"Leave a comment\" title=\"' + disabledTip + '\" ' + shouldDisable + '></textarea>\\n        </div>\\n        <div class=\"gitment-editor-preview-field gitment-hidden\">\\n          <div class=\"gitment-editor-preview gitment-markdown\"></div>\\n        </div>\\n      </div>\\n    </div>\\n    <div class=\"gitment-editor-footer\">\\n      <a class=\"gitment-editor-footer-tip\" href=\"https://guides.github.com/features/mastering-markdown/\" target=\"_blank\">\\n        Styling with Markdown is supported\\n      </a>\\n      <button class=\"gitment-editor-submit\" title=\"' + disabledTip + '\" ' + shouldDisable + '>Comment</button>\\n    </div>\\n  ';\n  if (user.login) {\n    container.querySelector('.gitment-editor-logout-link').onclick = function () {\n      return instance.logout();\n    };\n  }\n\n  var writeField = container.querySelector('.gitment-editor-write-field');\n  var previewField = container.querySelector('.gitment-editor-preview-field');\n\n  var textarea = writeField.querySelector('textarea');\n  textarea.oninput = function () {\n    textarea.style.height = 'auto';\n    var style = window.getComputedStyle(textarea, null);\n    var height = parseInt(style.height, 10);\n    var clientHeight = textarea.clientHeight;\n    var scrollHeight = textarea.scrollHeight;\n    if (clientHeight < scrollHeight) {\n      textarea.style.height = height + scrollHeight - clientHeight + 'px';\n    }\n  };\n\n  var _container$querySelec = container.querySelectorAll('.gitment-editor-tab'),\n      _container$querySelec2 = _slicedToArray(_container$querySelec, 2),\n      writeTab = _container$querySelec2[0],\n      previewTab = _container$querySelec2[1];\n\n  writeTab.onclick = function () {\n    writeTab.classList.add('gitment-selected');\n    previewTab.classList.remove('gitment-selected');\n    writeField.classList.remove('gitment-hidden');\n    previewField.classList.add('gitment-hidden');\n\n    textarea.focus();\n  };\n  previewTab.onclick = function () {\n    previewTab.classList.add('gitment-selected');\n    writeTab.classList.remove('gitment-selected');\n    previewField.classList.remove('gitment-hidden');\n    writeField.classList.add('gitment-hidden');\n\n    var preview = previewField.querySelector('.gitment-editor-preview');\n    var content = textarea.value.trim();\n    if (!content) {\n      preview.innerText = 'Nothing to preview';\n      return;\n    }\n\n    preview.innerText = 'Loading preview...';\n    instance.markdown(content).then(function (html) {\n      return preview.innerHTML = html;\n    });\n  };\n\n  var submitButton = container.querySelector('.gitment-editor-submit');\n  submitButton.onclick = function () {\n    submitButton.innerText = 'Submitting...';\n    submitButton.setAttribute('disabled', true);\n    instance.post(textarea.value.trim()).then(function (data) {\n      textarea.value = '';\n      textarea.style.height = 'auto';\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    }).catch(function (e) {\n      alert(e);\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    });\n  };\n\n  return container;\n}\n\nfunction renderFooter() {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-footer-container';\n  container.innerHTML = '\\n    Powered by\\n    <a class=\"gitment-footer-project-link\" href=\"https://github.com/imsun/gitment\" target=\"_blank\">\\n      Gitment\\n    </a>\\n  ';\n  return container;\n}\n\nfunction render(state, instance) {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-root-container';\n  container.appendChild(instance.renderHeader(state, instance));\n  container.appendChild(instance.renderComments(state, instance));\n  container.appendChild(instance.renderEditor(state, instance));\n  container.appendChild(instance.renderFooter(state, instance));\n  return container;\n}\n\nexports.default = { render: render, renderHeader: renderHeader, renderComments: renderComments, renderEditor: renderEditor, renderFooter: renderFooter };\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.http = exports.Query = exports.isString = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.getTargetContainer = getTargetContainer;\n\nvar _constants = __webpack_require__(0);\n\nvar isString = exports.isString = function isString(s) {\n  return toString.call(s) === '[object String]';\n};\n\nfunction getTargetContainer(container) {\n  var targetContainer = void 0;\n  if (container instanceof Element) {\n    targetContainer = container;\n  } else if (isString(container)) {\n    targetContainer = document.getElementById(container);\n  } else {\n    targetContainer = document.createElement('div');\n  }\n\n  return targetContainer;\n}\n\nvar Query = exports.Query = {\n  parse: function parse() {\n    var search = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.search;\n\n    if (!search) return {};\n    var queryString = search[0] === '?' ? search.substring(1) : search;\n    var query = {};\n    queryString.split('&').forEach(function (queryStr) {\n      var _queryStr$split = queryStr.split('='),\n          _queryStr$split2 = _slicedToArray(_queryStr$split, 2),\n          key = _queryStr$split2[0],\n          value = _queryStr$split2[1];\n\n      if (key) query[key] = value;\n    });\n\n    return query;\n  },\n  stringify: function stringify(query) {\n    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '?';\n\n    var queryString = Object.keys(query).map(function (key) {\n      return key + '=' + encodeURIComponent(query[key] || '');\n    }).join('&');\n    return queryString ? prefix + queryString : '';\n  }\n};\n\nfunction ajaxFactory(method) {\n  return function (apiPath) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://api.github.com';\n\n    var req = new XMLHttpRequest();\n    var token = localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n\n    var url = '' + base + apiPath;\n    var body = null;\n    if (method === 'GET' || method === 'DELETE') {\n      url += Query.stringify(data);\n    }\n\n    var p = new Promise(function (resolve, reject) {\n      req.addEventListener('load', function () {\n        var contentType = req.getResponseHeader('content-type');\n        var res = req.responseText;\n        if (!/json/.test(contentType)) {\n          resolve(res);\n          return;\n        }\n        var data = req.responseText ? JSON.parse(res) : {};\n        if (data.message) {\n          reject(new Error(data.message));\n        } else {\n          resolve(data);\n        }\n      });\n      req.addEventListener('error', function (error) {\n        return reject(error);\n      });\n    });\n    req.open(method, url, true);\n\n    req.setRequestHeader('Accept', 'application/vnd.github.squirrel-girl-preview, application/vnd.github.html+json');\n    if (token) {\n      req.setRequestHeader('Authorization', 'token ' + token);\n    }\n    if (method !== 'GET' && method !== 'DELETE') {\n      body = JSON.stringify(data);\n      req.setRequestHeader('Content-Type', 'application/json');\n    }\n\n    req.send(body);\n    return p;\n  };\n}\n\nvar http = exports.http = {\n  get: ajaxFactory('GET'),\n  post: ajaxFactory('POST'),\n  delete: ajaxFactory('DELETE'),\n  put: ajaxFactory('PUT')\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mobx = __webpack_require__(1);\n\nvar _constants = __webpack_require__(0);\n\nvar _utils = __webpack_require__(3);\n\nvar _default = __webpack_require__(2);\n\nvar _default2 = _interopRequireDefault(_default);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar scope = 'public_repo';\n\nfunction extendRenderer(instance, renderer) {\n  instance[renderer] = function (container) {\n    var targetContainer = (0, _utils.getTargetContainer)(container);\n    var render = instance.theme[renderer] || instance.defaultTheme[renderer];\n\n    (0, _mobx.autorun)(function () {\n      var e = render(instance.state, instance);\n      if (targetContainer.firstChild) {\n        targetContainer.replaceChild(e, targetContainer.firstChild);\n      } else {\n        targetContainer.appendChild(e);\n      }\n    });\n\n    return targetContainer;\n  };\n}\n\nvar Gitment = function () {\n  _createClass(Gitment, [{\n    key: 'accessToken',\n    get: function get() {\n      return localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n    },\n    set: function set(token) {\n      localStorage.setItem(_constants.LS_ACCESS_TOKEN_KEY, token);\n    }\n  }, {\n    key: 'loginLink',\n    get: function get() {\n      var oauthUri = 'https://github.com/login/oauth/authorize';\n      var redirect_uri = this.oauth.redirect_uri || window.location.href;\n\n      var oauthParams = Object.assign({\n        scope: scope,\n        redirect_uri: redirect_uri\n      }, this.oauth);\n\n      return '' + oauthUri + _utils.Query.stringify(oauthParams);\n    }\n  }]);\n\n  function Gitment() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Gitment);\n\n    this.defaultTheme = _default2.default;\n    this.useTheme(_default2.default);\n\n    Object.assign(this, {\n      id: window.location.href,\n      title: window.document.title,\n      link: window.location.href,\n      desc: '',\n      labels: [],\n      theme: _default2.default,\n      oauth: {},\n      perPage: 20,\n      maxCommentHeight: 250\n    }, options);\n\n    this.useTheme(this.theme);\n\n    var user = {};\n    try {\n      var userInfo = localStorage.getItem(_constants.LS_USER_KEY);\n      if (this.accessToken && userInfo) {\n        Object.assign(user, JSON.parse(userInfo), {\n          fromCache: true\n        });\n      }\n    } catch (e) {\n      localStorage.removeItem(_constants.LS_USER_KEY);\n    }\n\n    this.state = (0, _mobx.observable)({\n      user: user,\n      error: null,\n      meta: {},\n      comments: undefined,\n      reactions: [],\n      commentReactions: {},\n      currentPage: 1\n    });\n\n    var query = _utils.Query.parse();\n    if (query.code) {\n      var _oauth = this.oauth,\n          client_id = _oauth.client_id,\n          client_secret = _oauth.client_secret;\n\n      var code = query.code;\n      delete query.code;\n      var search = _utils.Query.stringify(query);\n      var replacedUrl = '' + window.location.origin + window.location.pathname + search + window.location.hash;\n      history.replaceState({}, '', replacedUrl);\n\n      Object.assign(this, {\n        id: replacedUrl,\n        link: replacedUrl\n      }, options);\n\n      this.state.user.isLoggingIn = true;\n      _utils.http.post('https://github.com/login/oauth/access_token', {\n        code: code,\n        client_id: client_id,\n        client_secret: client_secret\n      }, '').then(function (data) {\n        _this.accessToken = data.access_token;\n        _this.update();\n      }).catch(function (e) {\n        _this.state.user.isLoggingIn = false;\n        alert(e);\n      });\n    } else {\n      this.update();\n    }\n  }\n\n  _createClass(Gitment, [{\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      return this.createIssue().then(function () {\n        return _this2.loadComments();\n      }).then(function (comments) {\n        _this2.state.error = null;\n        return comments;\n      });\n    }\n  }, {\n    key: 'useTheme',\n    value: function useTheme() {\n      var _this3 = this;\n\n      var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this.theme = theme;\n\n      var renderers = Object.keys(this.theme);\n      renderers.forEach(function (renderer) {\n        return extendRenderer(_this3, renderer);\n      });\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var _this4 = this;\n\n      return Promise.all([this.loadMeta(), this.loadUserInfo()]).then(function () {\n        return Promise.all([_this4.loadComments().then(function () {\n          return _this4.loadCommentReactions();\n        }), _this4.loadReactions()]);\n      }).catch(function (e) {\n        return _this4.state.error = e;\n      });\n    }\n  }, {\n    key: 'markdown',\n    value: function markdown(text) {\n      return _utils.http.post('/markdown', {\n        text: text,\n        mode: 'gfm'\n      });\n    }\n  }, {\n    key: 'createIssue',\n    value: function createIssue() {\n      var _this5 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo,\n          title = this.title,\n          link = this.link,\n          desc = this.desc,\n          labels = this.labels;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues', {\n        title: title,\n        labels: labels.concat(['gitment', id]),\n        body: link + '\\n\\n' + desc\n      }).then(function (meta) {\n        _this5.state.meta = meta;\n        return meta;\n      });\n    }\n  }, {\n    key: 'getIssue',\n    value: function getIssue() {\n      if (this.state.meta.id) return Promise.resolve(this.state.meta);\n\n      return this.loadMeta();\n    }\n  }, {\n    key: 'post',\n    value: function post(body) {\n      var _this6 = this;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.post(issue.comments_url, { body: body }, '');\n      }).then(function (data) {\n        _this6.state.meta.comments++;\n        var pageCount = Math.ceil(_this6.state.meta.comments / _this6.perPage);\n        if (_this6.state.currentPage === pageCount) {\n          _this6.state.comments.push(data);\n        }\n        return data;\n      });\n    }\n  }, {\n    key: 'loadMeta',\n    value: function loadMeta() {\n      var _this7 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo;\n\n      return _utils.http.get('/repos/' + owner + '/' + repo + '/issues', {\n        creator: owner,\n        labels: id\n      }).then(function (issues) {\n        if (!issues.length) return Promise.reject(_constants.NOT_INITIALIZED_ERROR);\n        _this7.state.meta = issues[0];\n        return issues[0];\n      });\n    }\n  }, {\n    key: 'loadComments',\n    value: function loadComments() {\n      var _this8 = this;\n\n      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentPage;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.get(issue.comments_url, { page: page, per_page: _this8.perPage }, '');\n      }).then(function (comments) {\n        _this8.state.comments = comments;\n        return comments;\n      });\n    }\n  }, {\n    key: 'loadUserInfo',\n    value: function loadUserInfo() {\n      var _this9 = this;\n\n      if (!this.accessToken) {\n        this.logout();\n        return Promise.resolve({});\n      }\n\n      return _utils.http.get('/user').then(function (user) {\n        _this9.state.user = user;\n        localStorage.setItem(_constants.LS_USER_KEY, JSON.stringify(user));\n        return user;\n      });\n    }\n  }, {\n    key: 'loadReactions',\n    value: function loadReactions() {\n      var _this10 = this;\n\n      if (!this.accessToken) {\n        this.state.reactions = [];\n        return Promise.resolve([]);\n      }\n\n      return this.getIssue().then(function (issue) {\n        if (!issue.reactions.total_count) return [];\n        return _utils.http.get(issue.reactions.url, {}, '');\n      }).then(function (reactions) {\n        _this10.state.reactions = reactions;\n        return reactions;\n      });\n    }\n  }, {\n    key: 'loadCommentReactions',\n    value: function loadCommentReactions() {\n      var _this11 = this;\n\n      if (!this.accessToken) {\n        this.state.commentReactions = {};\n        return Promise.resolve([]);\n      }\n\n      var comments = this.state.comments;\n      var comentReactions = {};\n\n      return Promise.all(comments.map(function (comment) {\n        if (!comment.reactions.total_count) return [];\n\n        var owner = _this11.owner,\n            repo = _this11.repo;\n\n        return _utils.http.get('/repos/' + owner + '/' + repo + '/issues/comments/' + comment.id + '/reactions', {});\n      })).then(function (reactionsArray) {\n        comments.forEach(function (comment, index) {\n          comentReactions[comment.id] = reactionsArray[index];\n        });\n        _this11.state.commentReactions = comentReactions;\n\n        return comentReactions;\n      });\n    }\n  }, {\n    key: 'login',\n    value: function login() {\n      window.location.href = this.loginLink;\n    }\n  }, {\n    key: 'logout',\n    value: function logout() {\n      localStorage.removeItem(_constants.LS_ACCESS_TOKEN_KEY);\n      localStorage.removeItem(_constants.LS_USER_KEY);\n      this.state.user = {};\n    }\n  }, {\n    key: 'goto',\n    value: function goto(page) {\n      this.state.currentPage = page;\n      this.state.comments = undefined;\n      return this.loadComments(page);\n    }\n  }, {\n    key: 'like',\n    value: function like() {\n      var _this12 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/' + this.state.meta.number + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this12.state.reactions.push(reaction);\n        _this12.state.meta.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlike',\n    value: function unlike() {\n      var _this13 = this;\n\n      if (!this.accessToken) return Promise.reject();\n\n      var _state = this.state,\n          user = _state.user,\n          reactions = _state.reactions;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        _this13.state.meta.reactions.heart--;\n      });\n    }\n  }, {\n    key: 'likeAComment',\n    value: function likeAComment(commentId) {\n      var _this14 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/comments/' + commentId + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this14.state.commentReactions[commentId].push(reaction);\n        comment.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlikeAComment',\n    value: function unlikeAComment(commentId) {\n      if (!this.accessToken) return Promise.reject();\n\n      var reactions = this.state.commentReactions[commentId];\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n      var user = this.state.user;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        comment.reactions.heart--;\n      });\n    }\n  }]);\n\n  return Gitment;\n}();\n\nmodule.exports = Gitment;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Modified from https://github.com/evil-icons/evil-icons\n */\n\nvar close = exports.close = '<svg class=\"gitment-close-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M37.304 11.282l1.414 1.414-26.022 26.02-1.414-1.413z\"/><path d=\"M12.696 11.282l26.022 26.02-1.414 1.415-26.022-26.02z\"/></svg>';\nvar github = exports.github = '<svg class=\"gitment-github-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 10c-8.3 0-15 6.7-15 15 0 6.6 4.3 12.2 10.3 14.2.8.1 1-.3 1-.7v-2.6c-4.2.9-5.1-2-5.1-2-.7-1.7-1.7-2.2-1.7-2.2-1.4-.9.1-.9.1-.9 1.5.1 2.3 1.5 2.3 1.5 1.3 2.3 3.5 1.6 4.4 1.2.1-1 .5-1.6 1-2-3.3-.4-6.8-1.7-6.8-7.4 0-1.6.6-3 1.5-4-.2-.4-.7-1.9.1-4 0 0 1.3-.4 4.1 1.5 1.2-.3 2.5-.5 3.8-.5 1.3 0 2.6.2 3.8.5 2.9-1.9 4.1-1.5 4.1-1.5.8 2.1.3 3.6.1 4 1 1 1.5 2.4 1.5 4 0 5.8-3.5 7-6.8 7.4.5.5 1 1.4 1 2.8v4.1c0 .4.3.9 1 .7 6-2 10.2-7.6 10.2-14.2C40 16.7 33.3 10 25 10z\"/></svg>';\nvar heart = exports.heart = '<svg class=\"gitment-heart-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 39.7l-.6-.5C11.5 28.7 8 25 8 19c0-5 4-9 9-9 4.1 0 6.4 2.3 8 4.1 1.6-1.8 3.9-4.1 8-4.1 5 0 9 4 9 9 0 6-3.5 9.7-16.4 20.2l-.6.5zM17 12c-3.9 0-7 3.1-7 7 0 5.1 3.2 8.5 15 18.1 11.8-9.6 15-13 15-18.1 0-3.9-3.1-7-7-7-3.5 0-5.4 2.1-6.9 3.8L25 17.1l-1.1-1.3C22.4 14.1 20.5 12 17 12z\"/></svg>';\nvar spinner = exports.spinner = '<svg class=\"gitment-spinner-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 18c-.6 0-1-.4-1-1V9c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M25 42c-.6 0-1-.4-1-1v-8c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M29 19c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M17 39.8c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".93\" d=\"M21 19c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M33 39.8c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.1-.3.2-.5.2z\"/><path opacity=\".65\" d=\"M17 26H9c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".3\" d=\"M41 26h-8c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".86\" d=\"M18.1 21.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M38.9 33.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".44\" d=\"M11.1 33.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.1.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M31.9 21.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.2.2-.3.2-.5.2z\"/></svg>';\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=gitment.browser.js.map"}],"Post":[{"title":"Cichon's Diagram","date":"2023-07-31T01:14:51.000Z","mathjax":true,"_content":"\n# Definitions\n\nLet $I$ be an ideal of a given infinite set $X$, that is, a partially ordered collection of subsets such that \n\n1. $\\emptyset \\in I$,\n\n2. $B \\in I$ if $B \\subseteq A$ for some $A \\in I$, and \n\n3. $A \\cup B \\in I$ if $A, B \\in I$.\n\nAssume $I$ contains all finite subsets of $X$. We define the following cardinal coefficients of I:\n\n- $\\operatorname{add} (I) = \\min \\{|A|: A \\subseteq I \\land \\bigcup A \\notin I\\}$.\\\nThe \"additivity\" of $I$ is the smallest number of sets from $I$ whose union is not in $I$ any more. As any ideal is closed under finite unions, this number is always at least $\\aleph_{0}$; if $I$ is a $\\sigma$-ideal, then $\\operatorname{add} (I) \\geq \\aleph_{1}$. \n- $\\operatorname{cov} (I) = \\min \\{|A|: A \\subseteq I \\land \\bigcup A = X\\}$.\\\nThe \"covering number\" of $I$ is the smallest number of sets from $I$ whose union is all of $X$. As $X$ itself is not in $I$, we must have $\\operatorname{add} (I)  \\leq  \\operatorname{cov} (I) $.\n- $\\operatorname{non} (I) = \\min \\{|A|: A \\subseteq X \\land A \\notin I\\}$.\\\nThe \"uniformity number\" of $I$ (sometimes also written $\\operatorname{unif} (I)$) is the size of the smallest set not in $I$. By our assumption on $I$, $\\operatorname{add} (I) \\leq \\operatorname{non} (I)$.\n- $\\operatorname{cof} (I) = \\{|\\mathsf{A}|: \\mathsf{A} \\subseteq I \\land (\\forall B \\in I)(\\exists A \\in \\mathsf{A})(B \\subseteq A)\\}$.\\\nThe \"cofinality\" of $I$ is the cofinality of the partial order $(I, \\subseteq)$. It is easy to see that we must have $\\operatorname{non} (I) \\leq \\operatorname{cof} (I)$ and $\\operatorname{cov} (I) \\leq \\operatorname{cof} (I)$.\n\nFurthermore, the \"bounding number\" or \"unboundedness number\" $\\mathsf{b}$ and the \"dominating number\" $\\mathsf{d}$ are defined as follows:\n\n- $\\mathsf{b} = \\min \\{|F|: F \\subseteq \\mathbb{N}^{\\mathbb{N}} \\land (\\forall g \\in \\mathbb{N}^{\\mathbb{N}}) (\\exists f \\in F) (\\exists^{\\infty}n \\in \\mathbb{N})(g(n)<f(n)) \\}$\n- $\\mathsf{d} = \\min \\{|F|: F \\subseteq \\mathbb{N}^{\\mathbb{N}} \\land (\\forall g \\in \\mathbb{N}^{\\mathbb{N}}) (\\exists f \\in F) (\\forall^{\\infty}n \\in \\mathbb{N})(g(n)<f(n)) \\}$\n\nwhere \"$\\exists^{\\infty} n \\in \\mathbb{N}$\" means: \"there are infinitely many natural numbers $n$ such that ...\", and \"$\\forall^{\\infty} n \\in \\mathbb{N}$\" means \"for all except finitely many natural numbers $n$ we have ...\".\n\n# Diagram\n\nLet $\\mathsf{B}$ be the $\\sigma$-ideal of those subsets of the real line that are meager (or \"of the first category\") in the euclidean topology, and let $\\mathsf{L}$ be the $\\sigma$-ideal of those subsets of the real line that are of Lebesgue measure zero. Then the following inequalities hold:\n\n$$\\require{AMScd} \n\\begin{CD}\n\\, @.\n\\operatorname{cov}(\\mathsf{L}) @>>> \\operatorname{non}(\\mathsf{B}) @>>> \\operatorname{cof}(\\mathsf{B}) @>>>\n\\operatorname{cof}(\\mathsf{L}) @>>> \n2^{\\aleph_{0}}\\\\\n@. @. @AAA @AAA @. @. \\\\ \n@. \\Bigg \\uparrow @. \\mathsf{b} @>>> \\mathsf{d} @. \\Bigg \\uparrow @. \\\\\n@. @. @AAA  @AAA @. @.\\\\\n\\aleph_{1} @>>>\n\\operatorname{add}(\\mathsf{L}) @>>> \\operatorname{add}(\\mathsf{B}) @>>> \\operatorname{cov}(\\mathsf{B}) @>>>\n\\operatorname{non}(\\mathsf{L}) @. \\,\n\\end{CD}$$\n\n\nWhere an arrow from $x$ to $y$ is to mean that \n$x \\leq y$. In addition, the following relations hold:\n\n$$\\begin{aligned} \\operatorname{add}({\\mathsf B}) = & \\min\\{\\operatorname{cov}({\\mathsf B}),{\\mathsf b}\\}, \\text{ and }\\\\\n\\operatorname{cof}({\\mathsf B}) = & \\max\\{\\operatorname{non}({\\mathsf B}),{\\mathsf d}\\}. \n\\end{aligned}$$\n\nIt turns out that the inequalities described by the diagram, together with the relations mentioned above, are all the relations between these cardinals that are provable in ZFC, in the following limited sense. Let $A$ be any assignment of the cardinals $\\aleph_{1}$ and $\\aleph_{2}$ to the $10$ cardinals in Cicho's diagram. Then if $A$ is consistent with the diagram's relations, and if $A$ also satisfies the two additional relations, then $A$ can be realized in some model of ZFC.\n\nFor larger continuum sizes, the situation is less clear. It is consistent with ZFC that all of the Cichon's diagram cardinals are simultaneously different apart from $\\operatorname{add}(B)$ and $\\operatorname{cof}(B)$ (which are equal to other entries), but it remains open whether all combinations of the cardinal orderings consistent with the diagram are consistent.\n\n\n\n\n**Conjecture 1:** Suppose that $P$ is a closed subset of the real line such that $\\lambda(P) = 0$ and $\\lambda(P+P)>0$. Then there exists a set $A \\subseteq P$ such that $A+P$ is a Lebersgue nonmeasurable set. \n\n\n\n","source":"_posts/Cichon's Diagram.md","raw":"---\ntitle: Cichon's Diagram\ndate: 2023-07-31 09:14:51\ntags:\n    - [Set Theory]\ncategories:\n    - [Set Theory]\nmathjax: true\n---\n\n# Definitions\n\nLet $I$ be an ideal of a given infinite set $X$, that is, a partially ordered collection of subsets such that \n\n1. $\\emptyset \\in I$,\n\n2. $B \\in I$ if $B \\subseteq A$ for some $A \\in I$, and \n\n3. $A \\cup B \\in I$ if $A, B \\in I$.\n\nAssume $I$ contains all finite subsets of $X$. We define the following cardinal coefficients of I:\n\n- $\\operatorname{add} (I) = \\min \\{|A|: A \\subseteq I \\land \\bigcup A \\notin I\\}$.\\\nThe \"additivity\" of $I$ is the smallest number of sets from $I$ whose union is not in $I$ any more. As any ideal is closed under finite unions, this number is always at least $\\aleph_{0}$; if $I$ is a $\\sigma$-ideal, then $\\operatorname{add} (I) \\geq \\aleph_{1}$. \n- $\\operatorname{cov} (I) = \\min \\{|A|: A \\subseteq I \\land \\bigcup A = X\\}$.\\\nThe \"covering number\" of $I$ is the smallest number of sets from $I$ whose union is all of $X$. As $X$ itself is not in $I$, we must have $\\operatorname{add} (I)  \\leq  \\operatorname{cov} (I) $.\n- $\\operatorname{non} (I) = \\min \\{|A|: A \\subseteq X \\land A \\notin I\\}$.\\\nThe \"uniformity number\" of $I$ (sometimes also written $\\operatorname{unif} (I)$) is the size of the smallest set not in $I$. By our assumption on $I$, $\\operatorname{add} (I) \\leq \\operatorname{non} (I)$.\n- $\\operatorname{cof} (I) = \\{|\\mathsf{A}|: \\mathsf{A} \\subseteq I \\land (\\forall B \\in I)(\\exists A \\in \\mathsf{A})(B \\subseteq A)\\}$.\\\nThe \"cofinality\" of $I$ is the cofinality of the partial order $(I, \\subseteq)$. It is easy to see that we must have $\\operatorname{non} (I) \\leq \\operatorname{cof} (I)$ and $\\operatorname{cov} (I) \\leq \\operatorname{cof} (I)$.\n\nFurthermore, the \"bounding number\" or \"unboundedness number\" $\\mathsf{b}$ and the \"dominating number\" $\\mathsf{d}$ are defined as follows:\n\n- $\\mathsf{b} = \\min \\{|F|: F \\subseteq \\mathbb{N}^{\\mathbb{N}} \\land (\\forall g \\in \\mathbb{N}^{\\mathbb{N}}) (\\exists f \\in F) (\\exists^{\\infty}n \\in \\mathbb{N})(g(n)<f(n)) \\}$\n- $\\mathsf{d} = \\min \\{|F|: F \\subseteq \\mathbb{N}^{\\mathbb{N}} \\land (\\forall g \\in \\mathbb{N}^{\\mathbb{N}}) (\\exists f \\in F) (\\forall^{\\infty}n \\in \\mathbb{N})(g(n)<f(n)) \\}$\n\nwhere \"$\\exists^{\\infty} n \\in \\mathbb{N}$\" means: \"there are infinitely many natural numbers $n$ such that ...\", and \"$\\forall^{\\infty} n \\in \\mathbb{N}$\" means \"for all except finitely many natural numbers $n$ we have ...\".\n\n# Diagram\n\nLet $\\mathsf{B}$ be the $\\sigma$-ideal of those subsets of the real line that are meager (or \"of the first category\") in the euclidean topology, and let $\\mathsf{L}$ be the $\\sigma$-ideal of those subsets of the real line that are of Lebesgue measure zero. Then the following inequalities hold:\n\n$$\\require{AMScd} \n\\begin{CD}\n\\, @.\n\\operatorname{cov}(\\mathsf{L}) @>>> \\operatorname{non}(\\mathsf{B}) @>>> \\operatorname{cof}(\\mathsf{B}) @>>>\n\\operatorname{cof}(\\mathsf{L}) @>>> \n2^{\\aleph_{0}}\\\\\n@. @. @AAA @AAA @. @. \\\\ \n@. \\Bigg \\uparrow @. \\mathsf{b} @>>> \\mathsf{d} @. \\Bigg \\uparrow @. \\\\\n@. @. @AAA  @AAA @. @.\\\\\n\\aleph_{1} @>>>\n\\operatorname{add}(\\mathsf{L}) @>>> \\operatorname{add}(\\mathsf{B}) @>>> \\operatorname{cov}(\\mathsf{B}) @>>>\n\\operatorname{non}(\\mathsf{L}) @. \\,\n\\end{CD}$$\n\n\nWhere an arrow from $x$ to $y$ is to mean that \n$x \\leq y$. In addition, the following relations hold:\n\n$$\\begin{aligned} \\operatorname{add}({\\mathsf B}) = & \\min\\{\\operatorname{cov}({\\mathsf B}),{\\mathsf b}\\}, \\text{ and }\\\\\n\\operatorname{cof}({\\mathsf B}) = & \\max\\{\\operatorname{non}({\\mathsf B}),{\\mathsf d}\\}. \n\\end{aligned}$$\n\nIt turns out that the inequalities described by the diagram, together with the relations mentioned above, are all the relations between these cardinals that are provable in ZFC, in the following limited sense. Let $A$ be any assignment of the cardinals $\\aleph_{1}$ and $\\aleph_{2}$ to the $10$ cardinals in Cicho's diagram. Then if $A$ is consistent with the diagram's relations, and if $A$ also satisfies the two additional relations, then $A$ can be realized in some model of ZFC.\n\nFor larger continuum sizes, the situation is less clear. It is consistent with ZFC that all of the Cichon's diagram cardinals are simultaneously different apart from $\\operatorname{add}(B)$ and $\\operatorname{cof}(B)$ (which are equal to other entries), but it remains open whether all combinations of the cardinal orderings consistent with the diagram are consistent.\n\n\n\n\n**Conjecture 1:** Suppose that $P$ is a closed subset of the real line such that $\\lambda(P) = 0$ and $\\lambda(P+P)>0$. Then there exists a set $A \\subseteq P$ such that $A+P$ is a Lebersgue nonmeasurable set. \n\n\n\n","slug":"Cichon's Diagram","published":1,"updated":"2023-12-31T07:44:48.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisun30001eslrcdjf7im4","content":"<h1 id=\"definitions\">Definitions</h1>\r\n<p>Let <span class=\"math inline\">\\(I\\)</span> be an ideal of a given\r\ninfinite set <span class=\"math inline\">\\(X\\)</span>, that is, a\r\npartially ordered collection of subsets such that</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(\\emptyset \\in I\\)</span>,</p></li>\r\n<li><p><span class=\"math inline\">\\(B \\in I\\)</span> if <span\r\nclass=\"math inline\">\\(B \\subseteq A\\)</span> for some <span\r\nclass=\"math inline\">\\(A \\in I\\)</span>, and</p></li>\r\n<li><p><span class=\"math inline\">\\(A \\cup B \\in I\\)</span> if <span\r\nclass=\"math inline\">\\(A, B \\in I\\)</span>.</p></li>\r\n</ol>\r\n<p>Assume <span class=\"math inline\">\\(I\\)</span> contains all finite\r\nsubsets of <span class=\"math inline\">\\(X\\)</span>. We define the\r\nfollowing cardinal coefficients of I:</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\operatorname{add} (I) = \\min \\{|A|: A\r\n\\subseteq I \\land \\bigcup A \\notin I\\}\\)</span>.<br />\r\nThe \"additivity\" of <span class=\"math inline\">\\(I\\)</span> is the\r\nsmallest number of sets from <span class=\"math inline\">\\(I\\)</span>\r\nwhose union is not in <span class=\"math inline\">\\(I\\)</span> any more.\r\nAs any ideal is closed under finite unions, this number is always at\r\nleast <span class=\"math inline\">\\(\\aleph_{0}\\)</span>; if <span\r\nclass=\"math inline\">\\(I\\)</span> is a <span\r\nclass=\"math inline\">\\(\\sigma\\)</span>-ideal, then <span\r\nclass=\"math inline\">\\(\\operatorname{add} (I) \\geq\r\n\\aleph_{1}\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(\\operatorname{cov} (I) = \\min \\{|A|: A\r\n\\subseteq I \\land \\bigcup A = X\\}\\)</span>.<br />\r\nThe \"covering number\" of <span class=\"math inline\">\\(I\\)</span> is the\r\nsmallest number of sets from <span class=\"math inline\">\\(I\\)</span>\r\nwhose union is all of <span class=\"math inline\">\\(X\\)</span>. As <span\r\nclass=\"math inline\">\\(X\\)</span> itself is not in <span\r\nclass=\"math inline\">\\(I\\)</span>, we must have $ (I) (I) $.</li>\r\n<li><span class=\"math inline\">\\(\\operatorname{non} (I) = \\min \\{|A|: A\r\n\\subseteq X \\land A \\notin I\\}\\)</span>.<br />\r\nThe \"uniformity number\" of <span class=\"math inline\">\\(I\\)</span>\r\n(sometimes also written <span class=\"math inline\">\\(\\operatorname{unif}\r\n(I)\\)</span>) is the size of the smallest set not in <span\r\nclass=\"math inline\">\\(I\\)</span>. By our assumption on <span\r\nclass=\"math inline\">\\(I\\)</span>, <span\r\nclass=\"math inline\">\\(\\operatorname{add} (I) \\leq \\operatorname{non}\r\n(I)\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(\\operatorname{cof} (I) = \\{|\\mathsf{A}|:\r\n\\mathsf{A} \\subseteq I \\land (\\forall B \\in I)(\\exists A \\in\r\n\\mathsf{A})(B \\subseteq A)\\}\\)</span>.<br />\r\nThe \"cofinality\" of <span class=\"math inline\">\\(I\\)</span> is the\r\ncofinality of the partial order <span class=\"math inline\">\\((I,\r\n\\subseteq)\\)</span>. It is easy to see that we must have <span\r\nclass=\"math inline\">\\(\\operatorname{non} (I) \\leq \\operatorname{cof}\r\n(I)\\)</span> and <span class=\"math inline\">\\(\\operatorname{cov} (I) \\leq\r\n\\operatorname{cof} (I)\\)</span>.</li>\r\n</ul>\r\n<p>Furthermore, the \"bounding number\" or \"unboundedness number\" <span\r\nclass=\"math inline\">\\(\\mathsf{b}\\)</span> and the \"dominating number\"\r\n<span class=\"math inline\">\\(\\mathsf{d}\\)</span> are defined as\r\nfollows:</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\mathsf{b} = \\min \\{|F|: F \\subseteq\r\n\\mathbb{N}^{\\mathbb{N}} \\land (\\forall g \\in \\mathbb{N}^{\\mathbb{N}})\r\n(\\exists f \\in F) (\\exists^{\\infty}n \\in \\mathbb{N})(g(n)&lt;f(n))\r\n\\}\\)</span></li>\r\n<li><span class=\"math inline\">\\(\\mathsf{d} = \\min \\{|F|: F \\subseteq\r\n\\mathbb{N}^{\\mathbb{N}} \\land (\\forall g \\in \\mathbb{N}^{\\mathbb{N}})\r\n(\\exists f \\in F) (\\forall^{\\infty}n \\in \\mathbb{N})(g(n)&lt;f(n))\r\n\\}\\)</span></li>\r\n</ul>\r\n<p>where \"<span class=\"math inline\">\\(\\exists^{\\infty} n \\in\r\n\\mathbb{N}\\)</span>\" means: \"there are infinitely many natural numbers\r\n<span class=\"math inline\">\\(n\\)</span> such that ...\", and \"<span\r\nclass=\"math inline\">\\(\\forall^{\\infty} n \\in \\mathbb{N}\\)</span>\" means\r\n\"for all except finitely many natural numbers <span\r\nclass=\"math inline\">\\(n\\)</span> we have ...\".</p>\r\n<h1 id=\"diagram\">Diagram</h1>\r\n<p>Let <span class=\"math inline\">\\(\\mathsf{B}\\)</span> be the <span\r\nclass=\"math inline\">\\(\\sigma\\)</span>-ideal of those subsets of the real\r\nline that are meager (or \"of the first category\") in the euclidean\r\ntopology, and let <span class=\"math inline\">\\(\\mathsf{L}\\)</span> be the\r\n<span class=\"math inline\">\\(\\sigma\\)</span>-ideal of those subsets of\r\nthe real line that are of Lebesgue measure zero. Then the following\r\ninequalities hold:</p>\r\n<p><span class=\"math display\">\\[\\require{AMScd}\r\n\\begin{CD}\r\n\\, @.\r\n\\operatorname{cov}(\\mathsf{L}) @&gt;&gt;&gt;\r\n\\operatorname{non}(\\mathsf{B}) @&gt;&gt;&gt;\r\n\\operatorname{cof}(\\mathsf{B}) @&gt;&gt;&gt;\r\n\\operatorname{cof}(\\mathsf{L}) @&gt;&gt;&gt;\r\n2^{\\aleph_{0}}\\\\\r\n@. @. @AAA @AAA @. @. \\\\\r\n@. \\Bigg \\uparrow @. \\mathsf{b} @&gt;&gt;&gt; \\mathsf{d} @. \\Bigg\r\n\\uparrow @. \\\\\r\n@. @. @AAA  @AAA @. @.\\\\\r\n\\aleph_{1} @&gt;&gt;&gt;\r\n\\operatorname{add}(\\mathsf{L}) @&gt;&gt;&gt;\r\n\\operatorname{add}(\\mathsf{B}) @&gt;&gt;&gt;\r\n\\operatorname{cov}(\\mathsf{B}) @&gt;&gt;&gt;\r\n\\operatorname{non}(\\mathsf{L}) @. \\,\r\n\\end{CD}\\]</span></p>\r\n<p>Where an arrow from <span class=\"math inline\">\\(x\\)</span> to <span\r\nclass=\"math inline\">\\(y\\)</span> is to mean that <span\r\nclass=\"math inline\">\\(x \\leq y\\)</span>. In addition, the following\r\nrelations hold:</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n\\operatorname{add}({\\mathsf B}) = &amp;\r\n\\min\\{\\operatorname{cov}({\\mathsf B}),{\\mathsf b}\\}, \\text{ and }\\\\\r\n\\operatorname{cof}({\\mathsf B}) = &amp;\r\n\\max\\{\\operatorname{non}({\\mathsf B}),{\\mathsf d}\\}.\r\n\\end{aligned}\\]</span></p>\r\n<p>It turns out that the inequalities described by the diagram, together\r\nwith the relations mentioned above, are all the relations between these\r\ncardinals that are provable in ZFC, in the following limited sense. Let\r\n<span class=\"math inline\">\\(A\\)</span> be any assignment of the\r\ncardinals <span class=\"math inline\">\\(\\aleph_{1}\\)</span> and <span\r\nclass=\"math inline\">\\(\\aleph_{2}\\)</span> to the <span\r\nclass=\"math inline\">\\(10\\)</span> cardinals in Cicho's diagram. Then if\r\n<span class=\"math inline\">\\(A\\)</span> is consistent with the diagram's\r\nrelations, and if <span class=\"math inline\">\\(A\\)</span> also satisfies\r\nthe two additional relations, then <span\r\nclass=\"math inline\">\\(A\\)</span> can be realized in some model of\r\nZFC.</p>\r\n<p>For larger continuum sizes, the situation is less clear. It is\r\nconsistent with ZFC that all of the Cichon's diagram cardinals are\r\nsimultaneously different apart from <span\r\nclass=\"math inline\">\\(\\operatorname{add}(B)\\)</span> and <span\r\nclass=\"math inline\">\\(\\operatorname{cof}(B)\\)</span> (which are equal to\r\nother entries), but it remains open whether all combinations of the\r\ncardinal orderings consistent with the diagram are consistent.</p>\r\n<p><strong>Conjecture 1:</strong> Suppose that <span\r\nclass=\"math inline\">\\(P\\)</span> is a closed subset of the real line\r\nsuch that <span class=\"math inline\">\\(\\lambda(P) = 0\\)</span> and <span\r\nclass=\"math inline\">\\(\\lambda(P+P)&gt;0\\)</span>. Then there exists a\r\nset <span class=\"math inline\">\\(A \\subseteq P\\)</span> such that <span\r\nclass=\"math inline\">\\(A+P\\)</span> is a Lebersgue nonmeasurable set.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"definitions\">Definitions</h1>\r\n<p>Let <span class=\"math inline\">\\(I\\)</span> be an ideal of a given\r\ninfinite set <span class=\"math inline\">\\(X\\)</span>, that is, a\r\npartially ordered collection of subsets such that</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(\\emptyset \\in I\\)</span>,</p></li>\r\n<li><p><span class=\"math inline\">\\(B \\in I\\)</span> if <span\r\nclass=\"math inline\">\\(B \\subseteq A\\)</span> for some <span\r\nclass=\"math inline\">\\(A \\in I\\)</span>, and</p></li>\r\n<li><p><span class=\"math inline\">\\(A \\cup B \\in I\\)</span> if <span\r\nclass=\"math inline\">\\(A, B \\in I\\)</span>.</p></li>\r\n</ol>\r\n<p>Assume <span class=\"math inline\">\\(I\\)</span> contains all finite\r\nsubsets of <span class=\"math inline\">\\(X\\)</span>. We define the\r\nfollowing cardinal coefficients of I:</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\operatorname{add} (I) = \\min \\{|A|: A\r\n\\subseteq I \\land \\bigcup A \\notin I\\}\\)</span>.<br />\r\nThe \"additivity\" of <span class=\"math inline\">\\(I\\)</span> is the\r\nsmallest number of sets from <span class=\"math inline\">\\(I\\)</span>\r\nwhose union is not in <span class=\"math inline\">\\(I\\)</span> any more.\r\nAs any ideal is closed under finite unions, this number is always at\r\nleast <span class=\"math inline\">\\(\\aleph_{0}\\)</span>; if <span\r\nclass=\"math inline\">\\(I\\)</span> is a <span\r\nclass=\"math inline\">\\(\\sigma\\)</span>-ideal, then <span\r\nclass=\"math inline\">\\(\\operatorname{add} (I) \\geq\r\n\\aleph_{1}\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(\\operatorname{cov} (I) = \\min \\{|A|: A\r\n\\subseteq I \\land \\bigcup A = X\\}\\)</span>.<br />\r\nThe \"covering number\" of <span class=\"math inline\">\\(I\\)</span> is the\r\nsmallest number of sets from <span class=\"math inline\">\\(I\\)</span>\r\nwhose union is all of <span class=\"math inline\">\\(X\\)</span>. As <span\r\nclass=\"math inline\">\\(X\\)</span> itself is not in <span\r\nclass=\"math inline\">\\(I\\)</span>, we must have $ (I) (I) $.</li>\r\n<li><span class=\"math inline\">\\(\\operatorname{non} (I) = \\min \\{|A|: A\r\n\\subseteq X \\land A \\notin I\\}\\)</span>.<br />\r\nThe \"uniformity number\" of <span class=\"math inline\">\\(I\\)</span>\r\n(sometimes also written <span class=\"math inline\">\\(\\operatorname{unif}\r\n(I)\\)</span>) is the size of the smallest set not in <span\r\nclass=\"math inline\">\\(I\\)</span>. By our assumption on <span\r\nclass=\"math inline\">\\(I\\)</span>, <span\r\nclass=\"math inline\">\\(\\operatorname{add} (I) \\leq \\operatorname{non}\r\n(I)\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(\\operatorname{cof} (I) = \\{|\\mathsf{A}|:\r\n\\mathsf{A} \\subseteq I \\land (\\forall B \\in I)(\\exists A \\in\r\n\\mathsf{A})(B \\subseteq A)\\}\\)</span>.<br />\r\nThe \"cofinality\" of <span class=\"math inline\">\\(I\\)</span> is the\r\ncofinality of the partial order <span class=\"math inline\">\\((I,\r\n\\subseteq)\\)</span>. It is easy to see that we must have <span\r\nclass=\"math inline\">\\(\\operatorname{non} (I) \\leq \\operatorname{cof}\r\n(I)\\)</span> and <span class=\"math inline\">\\(\\operatorname{cov} (I) \\leq\r\n\\operatorname{cof} (I)\\)</span>.</li>\r\n</ul>\r\n<p>Furthermore, the \"bounding number\" or \"unboundedness number\" <span\r\nclass=\"math inline\">\\(\\mathsf{b}\\)</span> and the \"dominating number\"\r\n<span class=\"math inline\">\\(\\mathsf{d}\\)</span> are defined as\r\nfollows:</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\mathsf{b} = \\min \\{|F|: F \\subseteq\r\n\\mathbb{N}^{\\mathbb{N}} \\land (\\forall g \\in \\mathbb{N}^{\\mathbb{N}})\r\n(\\exists f \\in F) (\\exists^{\\infty}n \\in \\mathbb{N})(g(n)&lt;f(n))\r\n\\}\\)</span></li>\r\n<li><span class=\"math inline\">\\(\\mathsf{d} = \\min \\{|F|: F \\subseteq\r\n\\mathbb{N}^{\\mathbb{N}} \\land (\\forall g \\in \\mathbb{N}^{\\mathbb{N}})\r\n(\\exists f \\in F) (\\forall^{\\infty}n \\in \\mathbb{N})(g(n)&lt;f(n))\r\n\\}\\)</span></li>\r\n</ul>\r\n<p>where \"<span class=\"math inline\">\\(\\exists^{\\infty} n \\in\r\n\\mathbb{N}\\)</span>\" means: \"there are infinitely many natural numbers\r\n<span class=\"math inline\">\\(n\\)</span> such that ...\", and \"<span\r\nclass=\"math inline\">\\(\\forall^{\\infty} n \\in \\mathbb{N}\\)</span>\" means\r\n\"for all except finitely many natural numbers <span\r\nclass=\"math inline\">\\(n\\)</span> we have ...\".</p>\r\n<h1 id=\"diagram\">Diagram</h1>\r\n<p>Let <span class=\"math inline\">\\(\\mathsf{B}\\)</span> be the <span\r\nclass=\"math inline\">\\(\\sigma\\)</span>-ideal of those subsets of the real\r\nline that are meager (or \"of the first category\") in the euclidean\r\ntopology, and let <span class=\"math inline\">\\(\\mathsf{L}\\)</span> be the\r\n<span class=\"math inline\">\\(\\sigma\\)</span>-ideal of those subsets of\r\nthe real line that are of Lebesgue measure zero. Then the following\r\ninequalities hold:</p>\r\n<p><span class=\"math display\">\\[\\require{AMScd}\r\n\\begin{CD}\r\n\\, @.\r\n\\operatorname{cov}(\\mathsf{L}) @&gt;&gt;&gt;\r\n\\operatorname{non}(\\mathsf{B}) @&gt;&gt;&gt;\r\n\\operatorname{cof}(\\mathsf{B}) @&gt;&gt;&gt;\r\n\\operatorname{cof}(\\mathsf{L}) @&gt;&gt;&gt;\r\n2^{\\aleph_{0}}\\\\\r\n@. @. @AAA @AAA @. @. \\\\\r\n@. \\Bigg \\uparrow @. \\mathsf{b} @&gt;&gt;&gt; \\mathsf{d} @. \\Bigg\r\n\\uparrow @. \\\\\r\n@. @. @AAA  @AAA @. @.\\\\\r\n\\aleph_{1} @&gt;&gt;&gt;\r\n\\operatorname{add}(\\mathsf{L}) @&gt;&gt;&gt;\r\n\\operatorname{add}(\\mathsf{B}) @&gt;&gt;&gt;\r\n\\operatorname{cov}(\\mathsf{B}) @&gt;&gt;&gt;\r\n\\operatorname{non}(\\mathsf{L}) @. \\,\r\n\\end{CD}\\]</span></p>\r\n<p>Where an arrow from <span class=\"math inline\">\\(x\\)</span> to <span\r\nclass=\"math inline\">\\(y\\)</span> is to mean that <span\r\nclass=\"math inline\">\\(x \\leq y\\)</span>. In addition, the following\r\nrelations hold:</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n\\operatorname{add}({\\mathsf B}) = &amp;\r\n\\min\\{\\operatorname{cov}({\\mathsf B}),{\\mathsf b}\\}, \\text{ and }\\\\\r\n\\operatorname{cof}({\\mathsf B}) = &amp;\r\n\\max\\{\\operatorname{non}({\\mathsf B}),{\\mathsf d}\\}.\r\n\\end{aligned}\\]</span></p>\r\n<p>It turns out that the inequalities described by the diagram, together\r\nwith the relations mentioned above, are all the relations between these\r\ncardinals that are provable in ZFC, in the following limited sense. Let\r\n<span class=\"math inline\">\\(A\\)</span> be any assignment of the\r\ncardinals <span class=\"math inline\">\\(\\aleph_{1}\\)</span> and <span\r\nclass=\"math inline\">\\(\\aleph_{2}\\)</span> to the <span\r\nclass=\"math inline\">\\(10\\)</span> cardinals in Cicho's diagram. Then if\r\n<span class=\"math inline\">\\(A\\)</span> is consistent with the diagram's\r\nrelations, and if <span class=\"math inline\">\\(A\\)</span> also satisfies\r\nthe two additional relations, then <span\r\nclass=\"math inline\">\\(A\\)</span> can be realized in some model of\r\nZFC.</p>\r\n<p>For larger continuum sizes, the situation is less clear. It is\r\nconsistent with ZFC that all of the Cichon's diagram cardinals are\r\nsimultaneously different apart from <span\r\nclass=\"math inline\">\\(\\operatorname{add}(B)\\)</span> and <span\r\nclass=\"math inline\">\\(\\operatorname{cof}(B)\\)</span> (which are equal to\r\nother entries), but it remains open whether all combinations of the\r\ncardinal orderings consistent with the diagram are consistent.</p>\r\n<p><strong>Conjecture 1:</strong> Suppose that <span\r\nclass=\"math inline\">\\(P\\)</span> is a closed subset of the real line\r\nsuch that <span class=\"math inline\">\\(\\lambda(P) = 0\\)</span> and <span\r\nclass=\"math inline\">\\(\\lambda(P+P)&gt;0\\)</span>. Then there exists a\r\nset <span class=\"math inline\">\\(A \\subseteq P\\)</span> such that <span\r\nclass=\"math inline\">\\(A+P\\)</span> is a Lebersgue nonmeasurable set.</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Dec 31 2023 15:44:48 GMT+0800 ()","title":"Cichon's Diagram","path":"2023/07/31/Cichon's Diagram/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-07-31T01:14:51.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-07-31T01:14:51.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Set Theory","tags":["Set Theory"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Hilbert's Nullstellensatz","date":"2023-03-22T23:51:28.000Z","link":"","author":"Haoming Wang","mathjax":true,"top":true,"sticky":100,"toc":false,"_content":"\n\n\n## Theorem 1 (Weak form)\n\nLet $X$ be an affine algebraic variety in $k^{n}$, where $k$ is an algebraically closed field, and let $I(X)$ be the ideal of $X$ in the polynomial ring $k[t_{1}, \\cdots, t_{n}]$. If $I(X) \\neq (1)$ then $X$ is not empty. Every maximal ideal in the ring $k[t_{1}, \\cdots, t_{n}]$ is of the form $(t_{1} - a_{1},\\cdots,t_{n}- a_{n})$ where $a_{i}\\in k$.\n\n\n\n## Theorem 2 (Strong form)\n\nLet $k$ be an algebraically closed field, let $A$ denote the polynomial ring $k[t_{1}, \\cdots, t_{n}]$ and let $\\mathsf{a}$ be an ideal in $A$. Let $V$ be the variety in $k^{n}$ defined by the ideal $\\mathsf{a}$, so that $V$ is the set of all $x = (x_{1}, \\cdots, x_{n}) \\in k^{n}$ such that $f(x) = 0$ for all $f \\in \\mathsf{a}$. Let $I(V)$ be the ideal of $V$, i.e. the ideal of all polynomials $g \\in A$ such that $g(x) = 0$ for all $x \\in V$. Then $I(V) = r(\\mathsf{a})$.\n\n## Proof\n\nIt is clear that $r(a) \\subseteq I(V)$. Conversely, let $f \\notin r(\\mathsf{a})$, then there is a prime ideal $\\mathsf{p}$ containing $\\mathsf{a}$ such that $f\\notin \\mathsf{p}$. Let $\\bar{f}$ be the image of $f$ in $B = A/\\mathsf{p}$, let $C = B_{f} = B[1/\\bar{f}]$, and let $\\mathsf{m}$ be a maximal ideal of $C$. Since $C$ is a finitely generated, $k$-algebra we have $C/\\mathsf{m} \\cong k$, by (7.9)[1]. The images $x_{i}$ in $C/\\mathsf{m}$ of the generators $t_{i}$ of $A$ thus define a point $x = (x_{1} \\cdots, x_{n}) \\in k^{n}$, and the construction shows that $x \\in V$ and $f(x) \\neq 0$.\n\n\n\n## Corollary 1\nLet $k$ be a field and $B$ a finitely generated $k$-algebra. If $B$ is a\nfield then it is a finite algebraic extension of $k$.\n\n## Corollary 2\nLet $k$ be a field and let $B$ be a finitely generated $k$-algebra. Suppose that $B$ is a field. Then $B$ is a finite algebraic extension of k.\n\n## Corollary 3\nLet $k$ be afield, $A$ a finitely generated $k$-algebra. Let $\\mathsf{m}$ be a maximal ideal of $A$. Then the field $A/\\mathsf{m}$ is a finite algebraic extension of $k$. In particular, if $k$ is algebraically closed then $A/\\mathsf{m} \\cong k$.\n\n\n# Reference \n\n[1] Michael Atiyah. Introduction to commutative algebra. CRC Press, 2018.\n\n\n","source":"_posts/Hilbert's Nullstellensatz.md","raw":"---\ntitle: Hilbert's Nullstellensatz\ndate: 2023-03-23 07:51:28\nlink: \nauthor: Haoming Wang\ntags: \ncategories:\n   - [Commutative Algebra, Algebraic Geometry]\nmathjax: true\ntop: true\nsticky: 100\ntoc: false\n---\n\n\n\n## Theorem 1 (Weak form)\n\nLet $X$ be an affine algebraic variety in $k^{n}$, where $k$ is an algebraically closed field, and let $I(X)$ be the ideal of $X$ in the polynomial ring $k[t_{1}, \\cdots, t_{n}]$. If $I(X) \\neq (1)$ then $X$ is not empty. Every maximal ideal in the ring $k[t_{1}, \\cdots, t_{n}]$ is of the form $(t_{1} - a_{1},\\cdots,t_{n}- a_{n})$ where $a_{i}\\in k$.\n\n\n\n## Theorem 2 (Strong form)\n\nLet $k$ be an algebraically closed field, let $A$ denote the polynomial ring $k[t_{1}, \\cdots, t_{n}]$ and let $\\mathsf{a}$ be an ideal in $A$. Let $V$ be the variety in $k^{n}$ defined by the ideal $\\mathsf{a}$, so that $V$ is the set of all $x = (x_{1}, \\cdots, x_{n}) \\in k^{n}$ such that $f(x) = 0$ for all $f \\in \\mathsf{a}$. Let $I(V)$ be the ideal of $V$, i.e. the ideal of all polynomials $g \\in A$ such that $g(x) = 0$ for all $x \\in V$. Then $I(V) = r(\\mathsf{a})$.\n\n## Proof\n\nIt is clear that $r(a) \\subseteq I(V)$. Conversely, let $f \\notin r(\\mathsf{a})$, then there is a prime ideal $\\mathsf{p}$ containing $\\mathsf{a}$ such that $f\\notin \\mathsf{p}$. Let $\\bar{f}$ be the image of $f$ in $B = A/\\mathsf{p}$, let $C = B_{f} = B[1/\\bar{f}]$, and let $\\mathsf{m}$ be a maximal ideal of $C$. Since $C$ is a finitely generated, $k$-algebra we have $C/\\mathsf{m} \\cong k$, by (7.9)[1]. The images $x_{i}$ in $C/\\mathsf{m}$ of the generators $t_{i}$ of $A$ thus define a point $x = (x_{1} \\cdots, x_{n}) \\in k^{n}$, and the construction shows that $x \\in V$ and $f(x) \\neq 0$.\n\n\n\n## Corollary 1\nLet $k$ be a field and $B$ a finitely generated $k$-algebra. If $B$ is a\nfield then it is a finite algebraic extension of $k$.\n\n## Corollary 2\nLet $k$ be a field and let $B$ be a finitely generated $k$-algebra. Suppose that $B$ is a field. Then $B$ is a finite algebraic extension of k.\n\n## Corollary 3\nLet $k$ be afield, $A$ a finitely generated $k$-algebra. Let $\\mathsf{m}$ be a maximal ideal of $A$. Then the field $A/\\mathsf{m}$ is a finite algebraic extension of $k$. In particular, if $k$ is algebraically closed then $A/\\mathsf{m} \\cong k$.\n\n\n# Reference \n\n[1] Michael Atiyah. Introduction to commutative algebra. CRC Press, 2018.\n\n\n","slug":"Hilbert's Nullstellensatz","published":1,"updated":"2023-12-31T07:45:07.300Z","comments":1,"layout":"post","photos":[],"_id":"clqxisun70003eslrc1u30yul","content":"<h2 id=\"theorem-1-weak-form\">Theorem 1 (Weak form)</h2>\r\n<p>Let <span class=\"math inline\">\\(X\\)</span> be an affine algebraic\r\nvariety in <span class=\"math inline\">\\(k^{n}\\)</span>, where <span\r\nclass=\"math inline\">\\(k\\)</span> is an algebraically closed field, and\r\nlet <span class=\"math inline\">\\(I(X)\\)</span> be the ideal of <span\r\nclass=\"math inline\">\\(X\\)</span> in the polynomial ring <span\r\nclass=\"math inline\">\\(k[t_{1}, \\cdots, t_{n}]\\)</span>. If <span\r\nclass=\"math inline\">\\(I(X) \\neq (1)\\)</span> then <span\r\nclass=\"math inline\">\\(X\\)</span> is not empty. Every maximal ideal in\r\nthe ring <span class=\"math inline\">\\(k[t_{1}, \\cdots, t_{n}]\\)</span> is\r\nof the form <span class=\"math inline\">\\((t_{1} - a_{1},\\cdots,t_{n}-\r\na_{n})\\)</span> where <span class=\"math inline\">\\(a_{i}\\in\r\nk\\)</span>.</p>\r\n<h2 id=\"theorem-2-strong-form\">Theorem 2 (Strong form)</h2>\r\n<p>Let <span class=\"math inline\">\\(k\\)</span> be an algebraically closed\r\nfield, let <span class=\"math inline\">\\(A\\)</span> denote the polynomial\r\nring <span class=\"math inline\">\\(k[t_{1}, \\cdots, t_{n}]\\)</span> and\r\nlet <span class=\"math inline\">\\(\\mathsf{a}\\)</span> be an ideal in <span\r\nclass=\"math inline\">\\(A\\)</span>. Let <span\r\nclass=\"math inline\">\\(V\\)</span> be the variety in <span\r\nclass=\"math inline\">\\(k^{n}\\)</span> defined by the ideal <span\r\nclass=\"math inline\">\\(\\mathsf{a}\\)</span>, so that <span\r\nclass=\"math inline\">\\(V\\)</span> is the set of all <span\r\nclass=\"math inline\">\\(x = (x_{1}, \\cdots, x_{n}) \\in k^{n}\\)</span> such\r\nthat <span class=\"math inline\">\\(f(x) = 0\\)</span> for all <span\r\nclass=\"math inline\">\\(f \\in \\mathsf{a}\\)</span>. Let <span\r\nclass=\"math inline\">\\(I(V)\\)</span> be the ideal of <span\r\nclass=\"math inline\">\\(V\\)</span>, i.e. the ideal of all polynomials\r\n<span class=\"math inline\">\\(g \\in A\\)</span> such that <span\r\nclass=\"math inline\">\\(g(x) = 0\\)</span> for all <span\r\nclass=\"math inline\">\\(x \\in V\\)</span>. Then <span\r\nclass=\"math inline\">\\(I(V) = r(\\mathsf{a})\\)</span>.</p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<p>It is clear that <span class=\"math inline\">\\(r(a) \\subseteq\r\nI(V)\\)</span>. Conversely, let <span class=\"math inline\">\\(f \\notin\r\nr(\\mathsf{a})\\)</span>, then there is a prime ideal <span\r\nclass=\"math inline\">\\(\\mathsf{p}\\)</span> containing <span\r\nclass=\"math inline\">\\(\\mathsf{a}\\)</span> such that <span\r\nclass=\"math inline\">\\(f\\notin \\mathsf{p}\\)</span>. Let <span\r\nclass=\"math inline\">\\(\\bar{f}\\)</span> be the image of <span\r\nclass=\"math inline\">\\(f\\)</span> in <span class=\"math inline\">\\(B =\r\nA/\\mathsf{p}\\)</span>, let <span class=\"math inline\">\\(C = B_{f} =\r\nB[1/\\bar{f}]\\)</span>, and let <span\r\nclass=\"math inline\">\\(\\mathsf{m}\\)</span> be a maximal ideal of <span\r\nclass=\"math inline\">\\(C\\)</span>. Since <span\r\nclass=\"math inline\">\\(C\\)</span> is a finitely generated, <span\r\nclass=\"math inline\">\\(k\\)</span>-algebra we have <span\r\nclass=\"math inline\">\\(C/\\mathsf{m} \\cong k\\)</span>, by (7.9)[1]. The\r\nimages <span class=\"math inline\">\\(x_{i}\\)</span> in <span\r\nclass=\"math inline\">\\(C/\\mathsf{m}\\)</span> of the generators <span\r\nclass=\"math inline\">\\(t_{i}\\)</span> of <span\r\nclass=\"math inline\">\\(A\\)</span> thus define a point <span\r\nclass=\"math inline\">\\(x = (x_{1} \\cdots, x_{n}) \\in k^{n}\\)</span>, and\r\nthe construction shows that <span class=\"math inline\">\\(x \\in V\\)</span>\r\nand <span class=\"math inline\">\\(f(x) \\neq 0\\)</span>.</p>\r\n<h2 id=\"corollary-1\">Corollary 1</h2>\r\n<p>Let <span class=\"math inline\">\\(k\\)</span> be a field and <span\r\nclass=\"math inline\">\\(B\\)</span> a finitely generated <span\r\nclass=\"math inline\">\\(k\\)</span>-algebra. If <span\r\nclass=\"math inline\">\\(B\\)</span> is a field then it is a finite\r\nalgebraic extension of <span class=\"math inline\">\\(k\\)</span>.</p>\r\n<h2 id=\"corollary-2\">Corollary 2</h2>\r\n<p>Let <span class=\"math inline\">\\(k\\)</span> be a field and let <span\r\nclass=\"math inline\">\\(B\\)</span> be a finitely generated <span\r\nclass=\"math inline\">\\(k\\)</span>-algebra. Suppose that <span\r\nclass=\"math inline\">\\(B\\)</span> is a field. Then <span\r\nclass=\"math inline\">\\(B\\)</span> is a finite algebraic extension of\r\nk.</p>\r\n<h2 id=\"corollary-3\">Corollary 3</h2>\r\n<p>Let <span class=\"math inline\">\\(k\\)</span> be afield, <span\r\nclass=\"math inline\">\\(A\\)</span> a finitely generated <span\r\nclass=\"math inline\">\\(k\\)</span>-algebra. Let <span\r\nclass=\"math inline\">\\(\\mathsf{m}\\)</span> be a maximal ideal of <span\r\nclass=\"math inline\">\\(A\\)</span>. Then the field <span\r\nclass=\"math inline\">\\(A/\\mathsf{m}\\)</span> is a finite algebraic\r\nextension of <span class=\"math inline\">\\(k\\)</span>. In particular, if\r\n<span class=\"math inline\">\\(k\\)</span> is algebraically closed then\r\n<span class=\"math inline\">\\(A/\\mathsf{m} \\cong k\\)</span>.</p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Michael Atiyah. Introduction to commutative algebra. CRC Press,\r\n2018.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"theorem-1-weak-form\">Theorem 1 (Weak form)</h2>\r\n<p>Let <span class=\"math inline\">\\(X\\)</span> be an affine algebraic\r\nvariety in <span class=\"math inline\">\\(k^{n}\\)</span>, where <span\r\nclass=\"math inline\">\\(k\\)</span> is an algebraically closed field, and\r\nlet <span class=\"math inline\">\\(I(X)\\)</span> be the ideal of <span\r\nclass=\"math inline\">\\(X\\)</span> in the polynomial ring <span\r\nclass=\"math inline\">\\(k[t_{1}, \\cdots, t_{n}]\\)</span>. If <span\r\nclass=\"math inline\">\\(I(X) \\neq (1)\\)</span> then <span\r\nclass=\"math inline\">\\(X\\)</span> is not empty. Every maximal ideal in\r\nthe ring <span class=\"math inline\">\\(k[t_{1}, \\cdots, t_{n}]\\)</span> is\r\nof the form <span class=\"math inline\">\\((t_{1} - a_{1},\\cdots,t_{n}-\r\na_{n})\\)</span> where <span class=\"math inline\">\\(a_{i}\\in\r\nk\\)</span>.</p>\r\n<h2 id=\"theorem-2-strong-form\">Theorem 2 (Strong form)</h2>\r\n<p>Let <span class=\"math inline\">\\(k\\)</span> be an algebraically closed\r\nfield, let <span class=\"math inline\">\\(A\\)</span> denote the polynomial\r\nring <span class=\"math inline\">\\(k[t_{1}, \\cdots, t_{n}]\\)</span> and\r\nlet <span class=\"math inline\">\\(\\mathsf{a}\\)</span> be an ideal in <span\r\nclass=\"math inline\">\\(A\\)</span>. Let <span\r\nclass=\"math inline\">\\(V\\)</span> be the variety in <span\r\nclass=\"math inline\">\\(k^{n}\\)</span> defined by the ideal <span\r\nclass=\"math inline\">\\(\\mathsf{a}\\)</span>, so that <span\r\nclass=\"math inline\">\\(V\\)</span> is the set of all <span\r\nclass=\"math inline\">\\(x = (x_{1}, \\cdots, x_{n}) \\in k^{n}\\)</span> such\r\nthat <span class=\"math inline\">\\(f(x) = 0\\)</span> for all <span\r\nclass=\"math inline\">\\(f \\in \\mathsf{a}\\)</span>. Let <span\r\nclass=\"math inline\">\\(I(V)\\)</span> be the ideal of <span\r\nclass=\"math inline\">\\(V\\)</span>, i.e. the ideal of all polynomials\r\n<span class=\"math inline\">\\(g \\in A\\)</span> such that <span\r\nclass=\"math inline\">\\(g(x) = 0\\)</span> for all <span\r\nclass=\"math inline\">\\(x \\in V\\)</span>. Then <span\r\nclass=\"math inline\">\\(I(V) = r(\\mathsf{a})\\)</span>.</p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<p>It is clear that <span class=\"math inline\">\\(r(a) \\subseteq\r\nI(V)\\)</span>. Conversely, let <span class=\"math inline\">\\(f \\notin\r\nr(\\mathsf{a})\\)</span>, then there is a prime ideal <span\r\nclass=\"math inline\">\\(\\mathsf{p}\\)</span> containing <span\r\nclass=\"math inline\">\\(\\mathsf{a}\\)</span> such that <span\r\nclass=\"math inline\">\\(f\\notin \\mathsf{p}\\)</span>. Let <span\r\nclass=\"math inline\">\\(\\bar{f}\\)</span> be the image of <span\r\nclass=\"math inline\">\\(f\\)</span> in <span class=\"math inline\">\\(B =\r\nA/\\mathsf{p}\\)</span>, let <span class=\"math inline\">\\(C = B_{f} =\r\nB[1/\\bar{f}]\\)</span>, and let <span\r\nclass=\"math inline\">\\(\\mathsf{m}\\)</span> be a maximal ideal of <span\r\nclass=\"math inline\">\\(C\\)</span>. Since <span\r\nclass=\"math inline\">\\(C\\)</span> is a finitely generated, <span\r\nclass=\"math inline\">\\(k\\)</span>-algebra we have <span\r\nclass=\"math inline\">\\(C/\\mathsf{m} \\cong k\\)</span>, by (7.9)[1]. The\r\nimages <span class=\"math inline\">\\(x_{i}\\)</span> in <span\r\nclass=\"math inline\">\\(C/\\mathsf{m}\\)</span> of the generators <span\r\nclass=\"math inline\">\\(t_{i}\\)</span> of <span\r\nclass=\"math inline\">\\(A\\)</span> thus define a point <span\r\nclass=\"math inline\">\\(x = (x_{1} \\cdots, x_{n}) \\in k^{n}\\)</span>, and\r\nthe construction shows that <span class=\"math inline\">\\(x \\in V\\)</span>\r\nand <span class=\"math inline\">\\(f(x) \\neq 0\\)</span>.</p>\r\n<h2 id=\"corollary-1\">Corollary 1</h2>\r\n<p>Let <span class=\"math inline\">\\(k\\)</span> be a field and <span\r\nclass=\"math inline\">\\(B\\)</span> a finitely generated <span\r\nclass=\"math inline\">\\(k\\)</span>-algebra. If <span\r\nclass=\"math inline\">\\(B\\)</span> is a field then it is a finite\r\nalgebraic extension of <span class=\"math inline\">\\(k\\)</span>.</p>\r\n<h2 id=\"corollary-2\">Corollary 2</h2>\r\n<p>Let <span class=\"math inline\">\\(k\\)</span> be a field and let <span\r\nclass=\"math inline\">\\(B\\)</span> be a finitely generated <span\r\nclass=\"math inline\">\\(k\\)</span>-algebra. Suppose that <span\r\nclass=\"math inline\">\\(B\\)</span> is a field. Then <span\r\nclass=\"math inline\">\\(B\\)</span> is a finite algebraic extension of\r\nk.</p>\r\n<h2 id=\"corollary-3\">Corollary 3</h2>\r\n<p>Let <span class=\"math inline\">\\(k\\)</span> be afield, <span\r\nclass=\"math inline\">\\(A\\)</span> a finitely generated <span\r\nclass=\"math inline\">\\(k\\)</span>-algebra. Let <span\r\nclass=\"math inline\">\\(\\mathsf{m}\\)</span> be a maximal ideal of <span\r\nclass=\"math inline\">\\(A\\)</span>. Then the field <span\r\nclass=\"math inline\">\\(A/\\mathsf{m}\\)</span> is a finite algebraic\r\nextension of <span class=\"math inline\">\\(k\\)</span>. In particular, if\r\n<span class=\"math inline\">\\(k\\)</span> is algebraically closed then\r\n<span class=\"math inline\">\\(A/\\mathsf{m} \\cong k\\)</span>.</p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Michael Atiyah. Introduction to commutative algebra. CRC Press,\r\n2018.</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Dec 31 2023 15:45:07 GMT+0800 ()","title":"Hilbert's Nullstellensatz","path":"2023/03/23/Hilbert's Nullstellensatz/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-03-22T23:51:28.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-03-22T23:51:28.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Commutative Algebra > Algebraic Geometry","tags":[],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"75 Problems in the Foundation of Mathematics","date":"2023-09-22T14:10:39.000Z","mathjax":true,"_content":"\n# Problems\n\n\n\n1) When a set of points $P$ is a one-to-one and continuous image (but not necessarily bi-continuous) of a set $Q$ and when $Q$ is a one-to-one and continuous image of $P$? Are the sets $P$ and $Q $ necessarily homomorphic?\n\nProblem of M. W. Sierpinski. \n\n2) Is a (bounded) plane continuum, topologically homogeneous, necessarily homomorphic to a circumference?\n\n(A set $E$ is said to be *topologically homogeneous *, when there exists for any pair of points $a, b$ of $E$ a one-to-one and bi-continuous transformation of $E$ into itself which transforms $a$ into $b$)\n\nProblem of MM . B. Knaster and C. Kuratowski.\n\n3) A set ordered (linearly) without jumps or gaps and such that any set of its intervals (containing more than one element) does not overlap with each other is at most innumerable, is it necessarily a (ordinary) linear continuum?\n\nProblem of M. M. Souslin.\n\n4) Is there a decomposition of an interval into $\\aleph_{1}$ (non-empty) sets without common points that are $B$ measurable?\n\nProblem of M. W. Sierpinski.\n\n5) Does there exist an uncountable linear set $E$ such that every linear set homeomorphic to $E$ has zero Lebesgue measure? Can we prove the existence of such a set, even assuming that $2^{\\aleph_{0}} = \\aleph_{1}$?\n\nProblem of M. W. Sierpinski.\n\n6) Can we find without the hypothesis of the continuum ($2^{\\aleph_{0}} = \\aleph_{1}$) that a sum of $\\aleph_{1}$ sets of zero Lebesgue measure is not necessarily zero Lebesgue measure? that a sum of $\\aleph_{1} $ sets of the first category is not necessarily of the first category? that a product of $\\aleph_{1}$ sets ($A$) is not necessarily a set $A$?\n\nProblem of M. W. Sierpinski.\n\n7) Can we establish without the hypothesis of the continuum the existence of a plane set which has zero (Lebesgue) measure on any direction parallel to the abscissa axis and whose  complement has zero measure on any direction parallel to the ordinate axis ?\n\nProblem of M. H. Steinhaus.\n\n8) Can we give an effective example of a set of real numbers $E$ such that any sum, any difference, any product and any quotient of two numbers of $E$ (except division by 0) belongs to $E$ and that $E$ is uncountable , but distinct from the set of all real numbers ?\n\nProblem of M. S. Mazurkiewicz.\n\n9) What is the power of sets complementary to sets ($A$)?\n\nProblem of M. N. Lusin.\n\n\n*Noticed*. The linear sets ($A$) are orthogonal projections (on a line) of the measurable plane sets $B$. M. Lusin demonstrated that the power of an uncountable set complementary to a set ($A$) is $\\aleph_{1}$ or $2^{\\aleph_{0}}$, but we do not know if it can really be $\\aleph_{1}$ (in the case where $2^{\\aleph_{0}} > \\aleph_{1}$).\n\n10) Does there exist a second class function that is not a limit of almost everywhere continuous functions? Can we give an effective example of a function which is not a limit of piecewise continuous functions?\n\nProblem of MM . T. Feosztyn and W. Sierpinski.\n\n11) Does there exist a class ($\\mathcal{L}$) of M. Fr\\' echet (i.e. a class in which the limit is defined) of power greater than the continuum, such that any uncountable set of elements of this class contains at least one condensation element?\n\nProblem of M. W. Sierpinski.\n\n12) Does a (linearly) ordered set of which all well-ordered subsets (increasing and decreasing) are at most countable, necessarily have a power not greater than the continuum?\n\nProblem of M. W. Sierpinski.\n\n13) Does there exist a closed plane set which is not the sum of two closed sets without common points, but which is a sum of a countable closed sets without points in common.\n\nProblem of M. W. Sierpinski.\n\n14) Does a continuum in $m$-dimensional space which is homomorphic to any continuum contain necessarily a simple arc (i.e. image of an one-to-one and continuous mapping of the interval $(0,1)$?\n\nProblem of M. Mazurkiewicz.\n\n15) Does there exist a continuum of which every everything under continuous mapping is indecomposable? (A continuum is said to be indecomposable when it is not a sum of two continua different from it.)\n\nProblem of MM . Knaster and Kuratowski.\n\n16) Does there exist a continuum (unbounded) which is a sum of its proper saturated sub-continuums where any two of them do not intersect?\n\n(We say that a real subcontinuum $K$ of $C$ is *saturated*, when there exists no continuum different from $K$ and $C$ which contains $K$ and which is contained in $C$.)\n\nProblem of M. Kuratowski.\n\n17) What is the power of the set of all values that a Baire class 1 function does not take? \n\n(This problem is equivalent to problem 9 of M. Lusin, t . I. p.224. It would be enough to solve this problem for functions admitting uncountable points of discontinuity.)\n\n18) Is a (linear) set of power less than the continuum necessarily of the first category of M. Baire?\n\nProblem of M. Ruziewicz.\n\n19) Does there exist in each biconnected set $B$ a point $p$ such that the set $B - (p)$ contains no connected set?\n\n*Noticed*. According to a theorem of M. Kline (this volume, p.238), there cannot exist in a connected set $B$ more than one point $p$ enjoying the property in question. We know, on the other hand, that, if such a point exists, the set $B$ is biconnected, i.e. it is not the sum of two disjoint connected sets containing more than one point (cf. Knaster and Kuratowski, * Fund . Math.* II, p, 214.)\n\nProblem of M. Kuratowski.\n\n20) Let $f(E)$ be a function defined by any measurable ($L$) set $E$ of a Euclidean space of $m \\geq 3$ dimensions and satisfying the following conditions:\n\n1. $f(E) \\geq 0$.\n2. $f(E_{0}) = 1$ for a certain set $E_{0}$ of measure 1.\n3. $f(E_{1} +E_{2}) = f(E_{1}) + f(E_{2})$, if $E_{1} E_{2} = 0$.\n4. $f(E_{1}) = f(E_{2})$, if $E_{1}$ and $E_{2}$ are superimposable.\n\nIs the function $f(E)$ necessarily coincide with the Lebesgue measure of the set $E$?\n\n(For $m=1$ and $m=2$ the answer is negative, as M. Banach proved in a memoir which will be published in the volume IV of this journal.)\n\nProblem of M. Ruziewicz.\n\n21) Given a set of real numbers which is not of the first category in any interval, is there a decomposition: $A = B + C$, $B \\times C = 0$ such that neither $B$ nor $C$ are of the first category in any interval?\n\n*Noticed*. We could give the affirmative answer in the hypothesis additional that $A$ has the Baire property (in the sense established in this volume), p.319 . M. Sierpinski also pointed out the affirmative answer in the hypothesis of the continuum , $\\aleph_{1} = 2^{\\aleph_{0}}$.\n\nProblem of M. Kuratowski.\n\n22) Let us call the (linear) set $ E$ *perfectly measurable*, if every set homomorphic to $E$ is measurable in the sense of Lebesgue. What is the power of the class of perfectly measurable sets? Is a complementary set to a perf. measurable set always perf. measurable?\n\nProblem of M. Urysohn.\n\n23) Does there exist a function of a real variable $ f(x)$ pantachically dicontinuous and such that we have for all real $x$\n\n$$\\lim_{h \\to 0} \\frac{f( x+h ) - f(x-h)}{2h} = 0?$$\n\nProblem of M. Steinhaus.\n\n24) Is a function satisfying Baire's condition necessarily measurable ($L$)? What is the power of all the functions of a real variable satisfying the Baire condition? (We say that a function $f(x)$ satisfies the Baire condition, if it continues on any perfect set when we do not neglect the sets of the first category with respect to has that perfect set.)\n\nProblem of M. Sierpinski.\n\n25) Can a plane set, such that any straight line meets it at two (and only two) points, be measurable ($B$)? (The existence of such a set has been demonstrated , using M. Zermelos theorem, by MM. Mazurkiewicz[^1] (in 1914) and Rosenthal[^2] (in 1922))\n\n\n[^1]: Accounts of the Soc. of Varsovic Sciences , t. VII, p.382.\n\n[^2]: Sitzungaber d. Bayer. Akad. d. Wiss., math.-phys. K1, 1922, p. 223.\n\n26) Is a class 3 function of M. Baire always a superposition of three class 1 functions, that is to say, does it exist for any function $f(x)$ of class 3 three class 1 functions $\\varphi (x)$, $\\psi(x)$ and $\\vartheta(x)$, such that we have for all real $x$\n\n$$f(x) = \\varphi \\{\\psi[\\vartheta (x)]\\}$$\n\nProblem of M. Lusin.\n\n27) Is the set $D(E)$ of the distances of the points of a linear set $E$ that is ($B$) measurable always ($B$) measurable? ($D(E)$ is therefore the set of all numbers $|x - y|$, where $x$ and $y$ belong to $E$. We can prove the existence of set $E$ that are measurable ($L$), such that $D(E)$ is non-measurable ($L$).)\n\nProblem of M. Sierpinski. \n\n28) If $E$ is a ($B$ measurable) plane set, let us denote by $N(E)$ the set of all real numbers $ a$, such that the line $x = a$ meets $E$ at a uncountable infinite number of points. Is the set $N(E)$ necessarily a set ($A$), or, more simply, is it measurable ($ L $)? (It can be shown that the set of all real numbers $a$, such that the line $x = a$ meets the ($B$ measurable) set $E$ in an infinity number of points is always a set $A$.)\n\nProblem of M. Sierpinski. \n\n29) Let $F$ be a plane set, p. ex. closed (or, more generally, measurable) - A point $x$ of $F$ will be said to be *linearly accessible * if there exists a rectilinear segment $\\overline{xp}$ such that all its points (except the point $x$) are outside $F$. Can it be shown that the set $A$ of all linearly accessible points of $F$ is always measurable ($L$)?\n\nProblem of M. Urysohn.\n\n30) If $f(x)$ is an arbitrarily given function (measurable or not), what is the measure of the sum of all points $x$, such that\n\n$$\\lim \\limits_{h\\to 0} \\left |\\frac{f( x+h ) - f(x)}{h}\\right| = \\infty $$\n\nProblem of M. Ruziewicz.\n\n31) The theorem : \" $\\mathsf{m} = 2\\cdot\\mathsf{m}$ whatever the *transfinite* cardinal number $\\mathsf {m}$\" is it equivalent to *the axiom of choice*?\n\nCf. my Note \"*On some themes which are equivalent to the axiom of choice*\" in this volume, p. 147.\n\nProblem of M. Tajtelbaum-Tarski .\n\n32) Is a closed plane set, where every point is linearly accessible, necessarily of zero surface measure?\n\nProblem of M. Banach.\n\nA point $x$ of $F$ is said to be linearly accessible if there exists a rectilinear segment $\\overline{xp}$ such that all its points (except the point $x$) are outside $F$. M. Urysohn proved that the set of all linearly accessible points of a closed plane set is always a set ($A$) of M. Souslin, but may not be measurable ($B$). But we do not know if the set of all linearly accessible points of a plane set $G_{\\delta}$ is measurable ($L$) (Cf. Problem 29 , * Fund . Math .* t. V, p. 337).\n\n33) Is a one-to-one and continuous map (in one sense) of a set complementary to a set ($A$) of M. Souslin necessarily a homeomorphism?\n\nProblem of Sierpinski.\n\n34) Let us call a ($B$) measurable (linear) set of class $\\alpha$ *irreducible* if it is not of class $<\\alpha$ in any interval. What is the power of the set of all topological types of irreducible sets of class $\\alpha$?\n\nLet us call a set ($A$) *irreducible*, if it is not ($B$) measurable in any interval. What is the power of all the topological types of the sets ($A$) irreducible?\n\nProblem of MM . Alexandroff and Urysohn.\n\n35) Let us call the (linear) set $E$ *perfectly measurable in the narrow sense*, if every unambiguous and continuous image of $E$ is measurable in the sense of Lebesgue. Is a set complementary to a set perfectly measurable in the narrow sense always a homeomorphic image?\n\nCf. Problem 22 of P. Urysohn ( *Fund. Math.* t. IV, p. 368), solved by M. Lavrentieff (*Fund. Math.* t. VI, p. 159).\n\nProbleme de M. O. Nikodym.\n\n36) According to M. Souslin, if $E$ is a set ($A$) and $H$ a complementary set to a set ($A$), and if $E \\subset H$, there exists a set $Q$, ($B$) measurable, such that $E\\ subset Q \\subset H$[^3]. Does this proposition admit a reciprocal, that is to say, *if $E$ is a complementary set to a set ($A$) and $H$ ------ does a set ($A$), such that $E \\subset H$, exist always a  ($B$) measurable set $Q$, such that $E \\subset Q \\subset H$?*\n\nProblem of M. Sierpinski.\n\n[^3]: See p. e. N. Lusin and W. Sierpinski *Journ. of Math.* t. II (1923) p. 60; also *Bull. Acad. Krakow* 1918 p. 40.\n\n37) Is a Jordan (bounded) continuum which contains only a simple closed curve homomorphic to one of its (real) sub-continuums?\n\nProblem of M. Zarankiewicz.\n\n38) Can a square and a circle whose areas are equal be decomposed into a finite number of respectively congruent disjoint subsets?\n\nProblem of M. Tarski.\n\n39) Does there exist a closed set *plane* for which the set of linearly accessible points is non-measurable ($B$)? (In space the problem is resolved in the affirmative sense).\n\nProblem of M. O. Nikodym.\n\n40) If $E$ is a plane set $G_{\\delta}$, is the set of all real numbers $a$, such that the line $x =a$ meets the set $E$ in one and only one point, not necessarily complementary to a set ($A $) of M. Souslin?\n\nProblem of M. Sierpinski.\n\n41) If $E_{1}, E_{2}, E_{3}, \\dots$ are a sequence of countable linear sets each of which is a projection of a complete plane set complementary to a set ($A$) of M. Souslin, is the set $E_{1}E_{2} E_{3} \\dots $ of the same nature?\n\nProblem of M. Sierpinski.\n\n42) Does there exist in every continuum $A$ a continuum $B$ such that the set $AB$ is connected?\n\nProblem of MM . Knaster and Zarankiewicz .\n\n\n43) Let $D$ denote a closed homomorphic set of a plane set and located in 3-dimensional Euclidean space, is every point of $D$ is *accessible* in this space?\n\n(A point $d$ of $D$ is said to be *accessible* in $E$, when there exists a continuum $C \\subset E$ such that $(d) = CD$).\n\nProblem of M. Knaster.\n\n46) It is asked to set up the logical relations between the various concepts of homogeneity, in so far as they refer to small compact sets. In particular, even if the sets are considered to be connected and (or) connected in the small be assumed.\n\n(See D. van Dantzig , \"On topologically homogeneous continua, volume 15, pp. 102, 103).\n\nProblem of M. van Dantzig .\n\n47) Is every (connected, unbounded) $n$-dimensional manifold involutory homogeneous?\n\n(Cf. D. van Dantzig , le p. 104, ^7.)\n\nProblem of M. van Dantzig.\n\n48) Let us call a topological group *monothetic* if an infinite cyclic group is dense in it (in which case it is commutative and can be written additively), and *complete* if every sequence $x_{\\nu} $, which satisfies the Cauchy's convergence criterion $\\lim (x_{\\nu} - x_{\\mu } = 0$ has a limit element in the group, the question is whether a monothetic group can be complete without being compact.\n\n(See lc p. 116 ^{29}a))\n\nProblem of M. van Dantzig .\n\n49) Let $X$ and $Y$ be two Peano continua (= continuous images of the interval) and $Z$ be their topological product (= the space of all pairs $z = (x,y) $ or $\\lim z_{n}=z$ when $\\lim x_{n} = x$ and $\\lim y_{n} = y$).\n\n1^0. If the continuum $X$, as well as $Y$, has the property that in each continuous transformation of this continuum into a subset there exists an invariant point, is it true that $Z$ has the same property?\n\n2^0. If the continuum $X$, as well as $Y$, is uni-consistent (= in each decomposition of this continuum into two sub-continuums the common part of these sub-continuums is connected), is it true that $Z$ is uni-coherent?\n\nProblem of M. Kuratowski.\n\n50) Is the topological circle the only homogeneous small connected curve? (Curve = one-dimensional connected compact space. A space is called homogeneous, if for each of its two points $p$ and $q$ there exist a homeomorphism which sends $p$ to $q$ ). On the plane, the circle is the only small, homogeneous curve.\n\n(Cf. Mazurkiewicz, Fund. Math. V, p. 137).\n\nProblem with M. K. Menger.\n\n51) Are there any or even an infinite number of compact one-dimensional spaces any two of which are incomparable in one dimension? Two spaces $R$ and $R^{\\prime}$ may be called one-dimensionally incomparable , if no one-dimensional subset of $R$, (or of $R^{\\prime}$) is homomorphic with a subset of $R^{\\prime}$ (or of $R^{\\prime}$). For example, a line and a continuum without partial arcs are incomparable in one dimension. (If there are $n$, or $\\aleph_{0}$ in pairs of one-dimensionally incomparable curves, then there exist compact one-dimensional spaces which contains at least $2^{n} +1$, or $2^{\\aleph _{0}}$ monotone, $F_{\\sigma }$-additive, topological, compactifiable systems of subsets).\n\t\n\n(See Monthly Issues f. Math. and Phys. 36, p. 207).\n\nProblem of M. K. Menger.\n\n52) Does there exist a continuum of which every other continuum is a continuous image?\n\nProblem of M. H. Hahn.\n\n53) a. Can every absolute retract be decomposed into a finite number of absolute retracts with arbitrarily small diameters?\n\nb. Let every $R$ set be decomposed into a finite number of absolute retracts?\n\n(The definition of absolute retracts and $R$ sets is given, for example, in Fund. Math. XIX, p. 222).\n\n54) Is every partial continuum $C$ of the Euclidean $n$-dimensional space $R_{n}$, which intersects $R_{n}$ and which is transferred by arbitrarily small transformations (i.e. by a continuous mapping which sends every point from $C$ to an arbitrarily close point of $R_{n}$) into a subset of $R_{n}$ that is foreign to it, a ($n-1$) dimensional space?\n\n55) Can every route image lying in $R_{3}$ and intersecting $R_{3}$ be mapped continuously without fixed points?\n\nProblem of M. K. Borsuk.\n\n56) Let $A$ and $B$ be two topological spaces and $A^{2}$ and $B^{2}$ respectively their squares (a. \\`ad $A^{2}$ p . ex. consists of all your pairs ($a_{1}$, $a_{2}$) extracted from $A$).\n\nIs it true that if $A^{2}$ and $B^{2}$ are homeomorphic, are $A$ and $B$ too?\n\nIn case of a positive answer , we deduce that, if $C$ is a set which is not homeomorphic to none of $C^{n}$, $n>1$, the sets $C^{m}$ and $C^{n}$ are neither homeomorphic for $m \\neq n$; this provides in the case where $C$ is an interval of the theorem of \"invariance of the dimension\" of M. Brouwer .\n\nProblem of M. S. Ulam.\n\n57) Does there exist an infinite-dimensional continuum that does not contain any finite-dimensional continuum?\n\nProblems of M. S. Mazurkiewicz.\n\n\n58) Does there exist in a set $E$ of size $\\aleph_{1}$ a countable system of subsets $A_{1}, A_{2},\\dots$ such that one has the form\n$$X = \\overline{\\lim} A_{p_{n}}$$\nwhere ($p_{1}, p_{2},,\\dots$ is a subsequence of the natural numbers, $\\overline{\\lim}$ means the Borel *complete limit set*) all subsets $X$ received from $E$?\n\n(It is a question of proving the negation without using the continuum hypothesis).\n\nProblems with M. F. Hausdorff. _\n\n59) A function with the Baire property (i.e. continuous on any perfect set, when we neglect a set of $1^{re}$ category relative to this set) of a function with the Baire property, is it of the same nature?\n\nProblem of M. W. Sierpinski.\n\n60) Let $\\rho$ be the set of all homeomorphic transformations of the cartesian plane in itself, of the form:\n$$x^{\\prime} = x, \\quad y^{\\prime} =f( x,y )$$\nand\n$$x^{\\prime}=g( x,y ), \\quad \ty^{\\prime}=y.$$\n\nLet us denote by $\\sigma$ the group formed by all the finite superpositions of all the transformations belonging to $\\rho$. Can an arbitrary homeomorphic transformation of the plane in itself always be approached by those of the group $\\sigma$ ?\n\nAn analogous problem remains for $n>2$ dimensional spaces.\nProblem of M.S. Ulam.\n\n61) Let $E$ be a $G_{\\delta}$ plane set (more generally: a Borel set) all of whose intersections with the lines parallel to the $y$ axis are closed sets (more generally: $F_{\\sigma}$). Is the projection of $E$ on the $x$ axis always a Borel set?\t\n\nProblem of ME Szpilrajsn.\n\n62) The (real) function $f(x)$ of the real variable $x$ is called *symmetric-continuous* if for every $x$\n$$\\lim \\limits_{h \\to 0} [f( x+h ) - f(x - h)] = 0.$$\nCan the set of discontinuities of such a function be uncountable? Can it be an arbitrarily prescribed set $F_{\\sigma}$? (That they are an arbitrarily prescribed countable set is easy to see.)\n\nProblem of M. F. Hausdorff.\n\n63) Two compact spaces $A$ and $B$ have the *same homotopy type*, when there exists a continuous transformation $f$ from $A$ to $B$ and a continuous transformation $\\varphi$ from $B$ to $A$, such as the superpositions $\\ varphi f$ and $f\\varphi $ (consider respectively as transformations of $A$ into $A$ and of $B$ into $B$) are homotopic to the identity . Are two closed varieties of the same homotopy type always homomorphic?\n\nProblem of M. W. Hurewicz.\n\n64) Do there exist two in $R^{n}$ orientable Manifolds $M_{1}^{k}$ and $M_{2}^{k}$, whose Complementary $R^{n} - M_{1}^{k}$ and $R^{n} - M_{2}^{k}$ are homomorphic and whose Homology rings are not isomorphic?\n\n65) Let $B_{0}, B_{1}, B_{2}, \\dots, B_{\\omega}, \\dots, B_{\\alpha}, \\dots$ be Borel classes of sets, formed in starting from any class of abstract sets. We know that $B_{\\alpha} = B_{\\alpha+}$. results in $B_{\\alpha}= B_{\\beta}$ for all $\\beta>\\alpha$; let $\\alpha_{0}$ be the first number $\\alpha$ satisfying this condition. What are the numbers $v$ for which there exist classes $B_{0}$ such that we have $\\alpha_{0} = v$? (Cf. Fund. Math. t. XV, p. 284).\n\nProblem of M. A. Kolmogoroff.\n\n66) Does the *weak* $LC$ property entail the strong $LC$ property for any compact metric space ? Same question for $HLC$ properties . (For definitions see Annals of Mathematics , vol. 85, p. 119-129 and Duke Mathematical Journal, vol . 1, p. 1-18).\n\nProblem of M. S. Lefschetz.\n\n67) Is the property ($C$) of linear sets invariant with respect to homomorphic transformations and, more generally, with respect to continuous transformations? (We say that a set $E$ has the *property ($C$)*, when there exists for each sequence $\\{a_{n}\\}$ of positive numbers a decomposition $E=E_{1}+E_{2} + \\dots $ such that the diameter of $E_{n}$ does not exceed $ a_{n}$ for $n= 1, 2,\\dots$. Cf. Fund. Math, volume XI, p. 304; volume XV, p. 126; volume XXII, p. 310.)\n\nProblem of M. W. Sierpinski.\n\n68) If $E_{1}$ and $ E_{2}$ are two linear sets always of first category (i.e. of first category on any perfect set), the set $E_{1} \\times E_{2}$. (i.e. the set of all points $(x, y)$ of the plane where $x \\in E_{1}$ and $y \\in E_{2}$) Is it of the same nature?\n\nProblem of M. E. Szpilrajn.\n\n69) When a Jordan curve (in a three-dimensional space) has a determinate tangent at each point, does there necessarily exist a parametric representation of this curve expressing the cartesian coordinates of a point of this curve as functions which can be derived from a parameter ( and this without the three derivatives canceling out at the same time)?\n\nIn the event of a negative answer, the question is asked again by admitting a set of zero measurement values of the parameter where the imposed conditions are not both satisfied.\n\nProblem of M. M. Fr\\'echet.\n\n70) Does there exist a linear set $ E$ such that each linear analytical set is a one-to-one and continuous (in one sense) image of $E$?\n\nProblem of M. W. Sierpinski.\n\n71) Does there exist an infinite sequence $S$ of functions of a real variable (measurable or not), such that any function of a real variable of class $2$ Baire is a limit of some sequence extracted from $S$?\n\n(According to M. C. Burstin such a sequence $S$ cannot be composed uniquely of measurable functions[^4])\n\nProblem M. W. Sierpinski.\n\n[^4]: Monatshefte f. Math. u. Phys. 28 (1917), p. 107.\n\n72) Does there exist in the $n$-dimensional cart space ($n>1$) a set always of the first category ( i.e. of first category on each perfect set ) and which is of positive dimension?\n\n(M. W. Hurewicz demonstrated using the continuum hypothesis that there exists in Hilbert space an uncountable set $H$ of which each uncountable subset is of infinite dimension[^5]). M. F. Hausdorff noticed that the set $H$ is always of the first category. This follows easily from the fact that each separable metric space $M$ is the sum of a set of dimension $0$ and a set of first category in $M$. -- *There therefore exists, if $2^{\\aleph} = \\aleph_{1}$, in Hilbert space a set always of first category and of positive dimension*).\n\nProbleme de M. E. Szpilrajn.\n\n[^5]: Fund . Math. 19 (1932), p.8.\n\n\n73) Let, in three-dimensional Euclidean space, $E$ be a homomorphic image of the solid sphere $S$ and $L$ be a rectilinear segment whose interior is contained in the interior, and the ends in the border of $E$ . Does there still exist a homeomorphism transforming $E$ into $S$ such that $L$ is transformed into the diameter of $S$?\n\nProblem of M. K. Borsuk.\n\n74) Let $\\mathbf {B}(\\mathbf {F})$ be the smallest family of sets containing the given family $ \\mathbf {F}$ and closed with respect to the operations $\\sigma$ and $\\delta$ (addition and multiplication of countable values). Is there a family of enumerable $\\mathbf{D}$ of sets, such that all linear analytic sets belong to $\\mathbf {B}(\\mathbf{D})$ ?\n\nProblem of M. S. Ulam.\n\n\n75) Is there an infinite set $E$ ( e.g. the set of all natural numbers) and a function $f(X)$ which maps to any subset $X$ of $E $ a subset $f(X)$ of $E$, so that:\n\n1. $X \\subset f(X)$ for $X \\subset E$,\n2. $f(X+Y) = f(X) + f(Y)$ for $X \\subset E$, $Y \\subset E$,\n3. there exists for every set $Y \\subset E$ at least one set $X \\subset E$, such that $Y = f(X)$,\n4. there exists at least one set $X_{0} \\subset E$, such that $f(X_{0}) \\neq X_{0}$.\n\nIf we replace the relative condition to $f(X+Y)$ by the condition weaker than $f(X) \\subset f(Y)$ pure $X \\subset Y \\subset E$, the positive answer is obvious.\n\nProblem of M. E . $\\check{\\text{C}}$ech.\n\n\n\n\n\n# Problems resolved.\n\nProblem. 1) When a set of points $P$ is a one-to-one and continuous image (in a sense) of $Q$ and $Q$ is a one-to-one and continuous image of $P$, can we affirm that the sets $P$ and $Q$ are homomorphic?\n\n*Negative* solution from M. Kuratowski, Fund. Math. t. II, pp. 158-160\n\n4) Is there a decomposition of an interval into $\\aleph_{1}$ measurable sets ($B$), each non-empty and any two of them without points in common?\n\n*Affirmative* solution from MM. Lusin and Sierpinski, *Comptes Rendus*, t. 175, p.357 (note of August 21, 1922).\n\n6, third part) Can it be shown that a product of $\\aleph_{1}$ sets ($A$) is not necessarily a set ($A$)?\n\n*Affirmative* solution from MM. Lusin and Sierpinski, *Journ, de Math*. 1923 (The authors define a set which is complementary to a set ($A$) is not necessarily a set ($A$).)\n\n8) Can we give an effective example of a set of real numbers $E$, such as any sum, any difference, any product and any quotient of two numbers of $E$ (except\\' e division by 0) belongs to $E_{1}$ and that $E$ is non-countable, distinct from the set of all real numbers?\n\n*Affirmative* solution from M. Souslin, *Fund. Math.* IV, p.311.\n\n10, first part) Is there a second class function which is not the limit of almost everywhere discontinuous functions?\n\n*Affirmative* solution from M. Zalcwasser.\n\n12) Does an ordered set of which all well-ordered subsets (increasing or decreasing) are at most enumerable necessarily have a power no greater than that of the continuum?\n\n*Affirmative* solution from M. Urysohn, *Fund. Math.* V (to appear).\n\n15) Is there a continuum of which any subcontinuum is indecomposable?\n\n*Affirmative* solution from M. Knaster, *Fund. Math.* III pp. 247-286.\n\n16) Does there exist a continuum which is a sum of its proper disjoint saturated subcontinua?\n\n*Affirmative* solution by M. Knaster and Kuratowski, *Fund. Math.* V (to appear).\n\n\n","source":"_posts/75 Problems.md","raw":"---\ntitle: 75 Problems in the Foundation of Mathematics\ndate: 2023-09-22 22:10:39\ntags:\n    - [Set Theory]\ncategories:\n    - [Set Theory]\nmathjax: true\n---\n\n# Problems\n\n\n\n1) When a set of points $P$ is a one-to-one and continuous image (but not necessarily bi-continuous) of a set $Q$ and when $Q$ is a one-to-one and continuous image of $P$? Are the sets $P$ and $Q $ necessarily homomorphic?\n\nProblem of M. W. Sierpinski. \n\n2) Is a (bounded) plane continuum, topologically homogeneous, necessarily homomorphic to a circumference?\n\n(A set $E$ is said to be *topologically homogeneous *, when there exists for any pair of points $a, b$ of $E$ a one-to-one and bi-continuous transformation of $E$ into itself which transforms $a$ into $b$)\n\nProblem of MM . B. Knaster and C. Kuratowski.\n\n3) A set ordered (linearly) without jumps or gaps and such that any set of its intervals (containing more than one element) does not overlap with each other is at most innumerable, is it necessarily a (ordinary) linear continuum?\n\nProblem of M. M. Souslin.\n\n4) Is there a decomposition of an interval into $\\aleph_{1}$ (non-empty) sets without common points that are $B$ measurable?\n\nProblem of M. W. Sierpinski.\n\n5) Does there exist an uncountable linear set $E$ such that every linear set homeomorphic to $E$ has zero Lebesgue measure? Can we prove the existence of such a set, even assuming that $2^{\\aleph_{0}} = \\aleph_{1}$?\n\nProblem of M. W. Sierpinski.\n\n6) Can we find without the hypothesis of the continuum ($2^{\\aleph_{0}} = \\aleph_{1}$) that a sum of $\\aleph_{1}$ sets of zero Lebesgue measure is not necessarily zero Lebesgue measure? that a sum of $\\aleph_{1} $ sets of the first category is not necessarily of the first category? that a product of $\\aleph_{1}$ sets ($A$) is not necessarily a set $A$?\n\nProblem of M. W. Sierpinski.\n\n7) Can we establish without the hypothesis of the continuum the existence of a plane set which has zero (Lebesgue) measure on any direction parallel to the abscissa axis and whose  complement has zero measure on any direction parallel to the ordinate axis ?\n\nProblem of M. H. Steinhaus.\n\n8) Can we give an effective example of a set of real numbers $E$ such that any sum, any difference, any product and any quotient of two numbers of $E$ (except division by 0) belongs to $E$ and that $E$ is uncountable , but distinct from the set of all real numbers ?\n\nProblem of M. S. Mazurkiewicz.\n\n9) What is the power of sets complementary to sets ($A$)?\n\nProblem of M. N. Lusin.\n\n\n*Noticed*. The linear sets ($A$) are orthogonal projections (on a line) of the measurable plane sets $B$. M. Lusin demonstrated that the power of an uncountable set complementary to a set ($A$) is $\\aleph_{1}$ or $2^{\\aleph_{0}}$, but we do not know if it can really be $\\aleph_{1}$ (in the case where $2^{\\aleph_{0}} > \\aleph_{1}$).\n\n10) Does there exist a second class function that is not a limit of almost everywhere continuous functions? Can we give an effective example of a function which is not a limit of piecewise continuous functions?\n\nProblem of MM . T. Feosztyn and W. Sierpinski.\n\n11) Does there exist a class ($\\mathcal{L}$) of M. Fr\\' echet (i.e. a class in which the limit is defined) of power greater than the continuum, such that any uncountable set of elements of this class contains at least one condensation element?\n\nProblem of M. W. Sierpinski.\n\n12) Does a (linearly) ordered set of which all well-ordered subsets (increasing and decreasing) are at most countable, necessarily have a power not greater than the continuum?\n\nProblem of M. W. Sierpinski.\n\n13) Does there exist a closed plane set which is not the sum of two closed sets without common points, but which is a sum of a countable closed sets without points in common.\n\nProblem of M. W. Sierpinski.\n\n14) Does a continuum in $m$-dimensional space which is homomorphic to any continuum contain necessarily a simple arc (i.e. image of an one-to-one and continuous mapping of the interval $(0,1)$?\n\nProblem of M. Mazurkiewicz.\n\n15) Does there exist a continuum of which every everything under continuous mapping is indecomposable? (A continuum is said to be indecomposable when it is not a sum of two continua different from it.)\n\nProblem of MM . Knaster and Kuratowski.\n\n16) Does there exist a continuum (unbounded) which is a sum of its proper saturated sub-continuums where any two of them do not intersect?\n\n(We say that a real subcontinuum $K$ of $C$ is *saturated*, when there exists no continuum different from $K$ and $C$ which contains $K$ and which is contained in $C$.)\n\nProblem of M. Kuratowski.\n\n17) What is the power of the set of all values that a Baire class 1 function does not take? \n\n(This problem is equivalent to problem 9 of M. Lusin, t . I. p.224. It would be enough to solve this problem for functions admitting uncountable points of discontinuity.)\n\n18) Is a (linear) set of power less than the continuum necessarily of the first category of M. Baire?\n\nProblem of M. Ruziewicz.\n\n19) Does there exist in each biconnected set $B$ a point $p$ such that the set $B - (p)$ contains no connected set?\n\n*Noticed*. According to a theorem of M. Kline (this volume, p.238), there cannot exist in a connected set $B$ more than one point $p$ enjoying the property in question. We know, on the other hand, that, if such a point exists, the set $B$ is biconnected, i.e. it is not the sum of two disjoint connected sets containing more than one point (cf. Knaster and Kuratowski, * Fund . Math.* II, p, 214.)\n\nProblem of M. Kuratowski.\n\n20) Let $f(E)$ be a function defined by any measurable ($L$) set $E$ of a Euclidean space of $m \\geq 3$ dimensions and satisfying the following conditions:\n\n1. $f(E) \\geq 0$.\n2. $f(E_{0}) = 1$ for a certain set $E_{0}$ of measure 1.\n3. $f(E_{1} +E_{2}) = f(E_{1}) + f(E_{2})$, if $E_{1} E_{2} = 0$.\n4. $f(E_{1}) = f(E_{2})$, if $E_{1}$ and $E_{2}$ are superimposable.\n\nIs the function $f(E)$ necessarily coincide with the Lebesgue measure of the set $E$?\n\n(For $m=1$ and $m=2$ the answer is negative, as M. Banach proved in a memoir which will be published in the volume IV of this journal.)\n\nProblem of M. Ruziewicz.\n\n21) Given a set of real numbers which is not of the first category in any interval, is there a decomposition: $A = B + C$, $B \\times C = 0$ such that neither $B$ nor $C$ are of the first category in any interval?\n\n*Noticed*. We could give the affirmative answer in the hypothesis additional that $A$ has the Baire property (in the sense established in this volume), p.319 . M. Sierpinski also pointed out the affirmative answer in the hypothesis of the continuum , $\\aleph_{1} = 2^{\\aleph_{0}}$.\n\nProblem of M. Kuratowski.\n\n22) Let us call the (linear) set $ E$ *perfectly measurable*, if every set homomorphic to $E$ is measurable in the sense of Lebesgue. What is the power of the class of perfectly measurable sets? Is a complementary set to a perf. measurable set always perf. measurable?\n\nProblem of M. Urysohn.\n\n23) Does there exist a function of a real variable $ f(x)$ pantachically dicontinuous and such that we have for all real $x$\n\n$$\\lim_{h \\to 0} \\frac{f( x+h ) - f(x-h)}{2h} = 0?$$\n\nProblem of M. Steinhaus.\n\n24) Is a function satisfying Baire's condition necessarily measurable ($L$)? What is the power of all the functions of a real variable satisfying the Baire condition? (We say that a function $f(x)$ satisfies the Baire condition, if it continues on any perfect set when we do not neglect the sets of the first category with respect to has that perfect set.)\n\nProblem of M. Sierpinski.\n\n25) Can a plane set, such that any straight line meets it at two (and only two) points, be measurable ($B$)? (The existence of such a set has been demonstrated , using M. Zermelos theorem, by MM. Mazurkiewicz[^1] (in 1914) and Rosenthal[^2] (in 1922))\n\n\n[^1]: Accounts of the Soc. of Varsovic Sciences , t. VII, p.382.\n\n[^2]: Sitzungaber d. Bayer. Akad. d. Wiss., math.-phys. K1, 1922, p. 223.\n\n26) Is a class 3 function of M. Baire always a superposition of three class 1 functions, that is to say, does it exist for any function $f(x)$ of class 3 three class 1 functions $\\varphi (x)$, $\\psi(x)$ and $\\vartheta(x)$, such that we have for all real $x$\n\n$$f(x) = \\varphi \\{\\psi[\\vartheta (x)]\\}$$\n\nProblem of M. Lusin.\n\n27) Is the set $D(E)$ of the distances of the points of a linear set $E$ that is ($B$) measurable always ($B$) measurable? ($D(E)$ is therefore the set of all numbers $|x - y|$, where $x$ and $y$ belong to $E$. We can prove the existence of set $E$ that are measurable ($L$), such that $D(E)$ is non-measurable ($L$).)\n\nProblem of M. Sierpinski. \n\n28) If $E$ is a ($B$ measurable) plane set, let us denote by $N(E)$ the set of all real numbers $ a$, such that the line $x = a$ meets $E$ at a uncountable infinite number of points. Is the set $N(E)$ necessarily a set ($A$), or, more simply, is it measurable ($ L $)? (It can be shown that the set of all real numbers $a$, such that the line $x = a$ meets the ($B$ measurable) set $E$ in an infinity number of points is always a set $A$.)\n\nProblem of M. Sierpinski. \n\n29) Let $F$ be a plane set, p. ex. closed (or, more generally, measurable) - A point $x$ of $F$ will be said to be *linearly accessible * if there exists a rectilinear segment $\\overline{xp}$ such that all its points (except the point $x$) are outside $F$. Can it be shown that the set $A$ of all linearly accessible points of $F$ is always measurable ($L$)?\n\nProblem of M. Urysohn.\n\n30) If $f(x)$ is an arbitrarily given function (measurable or not), what is the measure of the sum of all points $x$, such that\n\n$$\\lim \\limits_{h\\to 0} \\left |\\frac{f( x+h ) - f(x)}{h}\\right| = \\infty $$\n\nProblem of M. Ruziewicz.\n\n31) The theorem : \" $\\mathsf{m} = 2\\cdot\\mathsf{m}$ whatever the *transfinite* cardinal number $\\mathsf {m}$\" is it equivalent to *the axiom of choice*?\n\nCf. my Note \"*On some themes which are equivalent to the axiom of choice*\" in this volume, p. 147.\n\nProblem of M. Tajtelbaum-Tarski .\n\n32) Is a closed plane set, where every point is linearly accessible, necessarily of zero surface measure?\n\nProblem of M. Banach.\n\nA point $x$ of $F$ is said to be linearly accessible if there exists a rectilinear segment $\\overline{xp}$ such that all its points (except the point $x$) are outside $F$. M. Urysohn proved that the set of all linearly accessible points of a closed plane set is always a set ($A$) of M. Souslin, but may not be measurable ($B$). But we do not know if the set of all linearly accessible points of a plane set $G_{\\delta}$ is measurable ($L$) (Cf. Problem 29 , * Fund . Math .* t. V, p. 337).\n\n33) Is a one-to-one and continuous map (in one sense) of a set complementary to a set ($A$) of M. Souslin necessarily a homeomorphism?\n\nProblem of Sierpinski.\n\n34) Let us call a ($B$) measurable (linear) set of class $\\alpha$ *irreducible* if it is not of class $<\\alpha$ in any interval. What is the power of the set of all topological types of irreducible sets of class $\\alpha$?\n\nLet us call a set ($A$) *irreducible*, if it is not ($B$) measurable in any interval. What is the power of all the topological types of the sets ($A$) irreducible?\n\nProblem of MM . Alexandroff and Urysohn.\n\n35) Let us call the (linear) set $E$ *perfectly measurable in the narrow sense*, if every unambiguous and continuous image of $E$ is measurable in the sense of Lebesgue. Is a set complementary to a set perfectly measurable in the narrow sense always a homeomorphic image?\n\nCf. Problem 22 of P. Urysohn ( *Fund. Math.* t. IV, p. 368), solved by M. Lavrentieff (*Fund. Math.* t. VI, p. 159).\n\nProbleme de M. O. Nikodym.\n\n36) According to M. Souslin, if $E$ is a set ($A$) and $H$ a complementary set to a set ($A$), and if $E \\subset H$, there exists a set $Q$, ($B$) measurable, such that $E\\ subset Q \\subset H$[^3]. Does this proposition admit a reciprocal, that is to say, *if $E$ is a complementary set to a set ($A$) and $H$ ------ does a set ($A$), such that $E \\subset H$, exist always a  ($B$) measurable set $Q$, such that $E \\subset Q \\subset H$?*\n\nProblem of M. Sierpinski.\n\n[^3]: See p. e. N. Lusin and W. Sierpinski *Journ. of Math.* t. II (1923) p. 60; also *Bull. Acad. Krakow* 1918 p. 40.\n\n37) Is a Jordan (bounded) continuum which contains only a simple closed curve homomorphic to one of its (real) sub-continuums?\n\nProblem of M. Zarankiewicz.\n\n38) Can a square and a circle whose areas are equal be decomposed into a finite number of respectively congruent disjoint subsets?\n\nProblem of M. Tarski.\n\n39) Does there exist a closed set *plane* for which the set of linearly accessible points is non-measurable ($B$)? (In space the problem is resolved in the affirmative sense).\n\nProblem of M. O. Nikodym.\n\n40) If $E$ is a plane set $G_{\\delta}$, is the set of all real numbers $a$, such that the line $x =a$ meets the set $E$ in one and only one point, not necessarily complementary to a set ($A $) of M. Souslin?\n\nProblem of M. Sierpinski.\n\n41) If $E_{1}, E_{2}, E_{3}, \\dots$ are a sequence of countable linear sets each of which is a projection of a complete plane set complementary to a set ($A$) of M. Souslin, is the set $E_{1}E_{2} E_{3} \\dots $ of the same nature?\n\nProblem of M. Sierpinski.\n\n42) Does there exist in every continuum $A$ a continuum $B$ such that the set $AB$ is connected?\n\nProblem of MM . Knaster and Zarankiewicz .\n\n\n43) Let $D$ denote a closed homomorphic set of a plane set and located in 3-dimensional Euclidean space, is every point of $D$ is *accessible* in this space?\n\n(A point $d$ of $D$ is said to be *accessible* in $E$, when there exists a continuum $C \\subset E$ such that $(d) = CD$).\n\nProblem of M. Knaster.\n\n46) It is asked to set up the logical relations between the various concepts of homogeneity, in so far as they refer to small compact sets. In particular, even if the sets are considered to be connected and (or) connected in the small be assumed.\n\n(See D. van Dantzig , \"On topologically homogeneous continua, volume 15, pp. 102, 103).\n\nProblem of M. van Dantzig .\n\n47) Is every (connected, unbounded) $n$-dimensional manifold involutory homogeneous?\n\n(Cf. D. van Dantzig , le p. 104, ^7.)\n\nProblem of M. van Dantzig.\n\n48) Let us call a topological group *monothetic* if an infinite cyclic group is dense in it (in which case it is commutative and can be written additively), and *complete* if every sequence $x_{\\nu} $, which satisfies the Cauchy's convergence criterion $\\lim (x_{\\nu} - x_{\\mu } = 0$ has a limit element in the group, the question is whether a monothetic group can be complete without being compact.\n\n(See lc p. 116 ^{29}a))\n\nProblem of M. van Dantzig .\n\n49) Let $X$ and $Y$ be two Peano continua (= continuous images of the interval) and $Z$ be their topological product (= the space of all pairs $z = (x,y) $ or $\\lim z_{n}=z$ when $\\lim x_{n} = x$ and $\\lim y_{n} = y$).\n\n1^0. If the continuum $X$, as well as $Y$, has the property that in each continuous transformation of this continuum into a subset there exists an invariant point, is it true that $Z$ has the same property?\n\n2^0. If the continuum $X$, as well as $Y$, is uni-consistent (= in each decomposition of this continuum into two sub-continuums the common part of these sub-continuums is connected), is it true that $Z$ is uni-coherent?\n\nProblem of M. Kuratowski.\n\n50) Is the topological circle the only homogeneous small connected curve? (Curve = one-dimensional connected compact space. A space is called homogeneous, if for each of its two points $p$ and $q$ there exist a homeomorphism which sends $p$ to $q$ ). On the plane, the circle is the only small, homogeneous curve.\n\n(Cf. Mazurkiewicz, Fund. Math. V, p. 137).\n\nProblem with M. K. Menger.\n\n51) Are there any or even an infinite number of compact one-dimensional spaces any two of which are incomparable in one dimension? Two spaces $R$ and $R^{\\prime}$ may be called one-dimensionally incomparable , if no one-dimensional subset of $R$, (or of $R^{\\prime}$) is homomorphic with a subset of $R^{\\prime}$ (or of $R^{\\prime}$). For example, a line and a continuum without partial arcs are incomparable in one dimension. (If there are $n$, or $\\aleph_{0}$ in pairs of one-dimensionally incomparable curves, then there exist compact one-dimensional spaces which contains at least $2^{n} +1$, or $2^{\\aleph _{0}}$ monotone, $F_{\\sigma }$-additive, topological, compactifiable systems of subsets).\n\t\n\n(See Monthly Issues f. Math. and Phys. 36, p. 207).\n\nProblem of M. K. Menger.\n\n52) Does there exist a continuum of which every other continuum is a continuous image?\n\nProblem of M. H. Hahn.\n\n53) a. Can every absolute retract be decomposed into a finite number of absolute retracts with arbitrarily small diameters?\n\nb. Let every $R$ set be decomposed into a finite number of absolute retracts?\n\n(The definition of absolute retracts and $R$ sets is given, for example, in Fund. Math. XIX, p. 222).\n\n54) Is every partial continuum $C$ of the Euclidean $n$-dimensional space $R_{n}$, which intersects $R_{n}$ and which is transferred by arbitrarily small transformations (i.e. by a continuous mapping which sends every point from $C$ to an arbitrarily close point of $R_{n}$) into a subset of $R_{n}$ that is foreign to it, a ($n-1$) dimensional space?\n\n55) Can every route image lying in $R_{3}$ and intersecting $R_{3}$ be mapped continuously without fixed points?\n\nProblem of M. K. Borsuk.\n\n56) Let $A$ and $B$ be two topological spaces and $A^{2}$ and $B^{2}$ respectively their squares (a. \\`ad $A^{2}$ p . ex. consists of all your pairs ($a_{1}$, $a_{2}$) extracted from $A$).\n\nIs it true that if $A^{2}$ and $B^{2}$ are homeomorphic, are $A$ and $B$ too?\n\nIn case of a positive answer , we deduce that, if $C$ is a set which is not homeomorphic to none of $C^{n}$, $n>1$, the sets $C^{m}$ and $C^{n}$ are neither homeomorphic for $m \\neq n$; this provides in the case where $C$ is an interval of the theorem of \"invariance of the dimension\" of M. Brouwer .\n\nProblem of M. S. Ulam.\n\n57) Does there exist an infinite-dimensional continuum that does not contain any finite-dimensional continuum?\n\nProblems of M. S. Mazurkiewicz.\n\n\n58) Does there exist in a set $E$ of size $\\aleph_{1}$ a countable system of subsets $A_{1}, A_{2},\\dots$ such that one has the form\n$$X = \\overline{\\lim} A_{p_{n}}$$\nwhere ($p_{1}, p_{2},,\\dots$ is a subsequence of the natural numbers, $\\overline{\\lim}$ means the Borel *complete limit set*) all subsets $X$ received from $E$?\n\n(It is a question of proving the negation without using the continuum hypothesis).\n\nProblems with M. F. Hausdorff. _\n\n59) A function with the Baire property (i.e. continuous on any perfect set, when we neglect a set of $1^{re}$ category relative to this set) of a function with the Baire property, is it of the same nature?\n\nProblem of M. W. Sierpinski.\n\n60) Let $\\rho$ be the set of all homeomorphic transformations of the cartesian plane in itself, of the form:\n$$x^{\\prime} = x, \\quad y^{\\prime} =f( x,y )$$\nand\n$$x^{\\prime}=g( x,y ), \\quad \ty^{\\prime}=y.$$\n\nLet us denote by $\\sigma$ the group formed by all the finite superpositions of all the transformations belonging to $\\rho$. Can an arbitrary homeomorphic transformation of the plane in itself always be approached by those of the group $\\sigma$ ?\n\nAn analogous problem remains for $n>2$ dimensional spaces.\nProblem of M.S. Ulam.\n\n61) Let $E$ be a $G_{\\delta}$ plane set (more generally: a Borel set) all of whose intersections with the lines parallel to the $y$ axis are closed sets (more generally: $F_{\\sigma}$). Is the projection of $E$ on the $x$ axis always a Borel set?\t\n\nProblem of ME Szpilrajsn.\n\n62) The (real) function $f(x)$ of the real variable $x$ is called *symmetric-continuous* if for every $x$\n$$\\lim \\limits_{h \\to 0} [f( x+h ) - f(x - h)] = 0.$$\nCan the set of discontinuities of such a function be uncountable? Can it be an arbitrarily prescribed set $F_{\\sigma}$? (That they are an arbitrarily prescribed countable set is easy to see.)\n\nProblem of M. F. Hausdorff.\n\n63) Two compact spaces $A$ and $B$ have the *same homotopy type*, when there exists a continuous transformation $f$ from $A$ to $B$ and a continuous transformation $\\varphi$ from $B$ to $A$, such as the superpositions $\\ varphi f$ and $f\\varphi $ (consider respectively as transformations of $A$ into $A$ and of $B$ into $B$) are homotopic to the identity . Are two closed varieties of the same homotopy type always homomorphic?\n\nProblem of M. W. Hurewicz.\n\n64) Do there exist two in $R^{n}$ orientable Manifolds $M_{1}^{k}$ and $M_{2}^{k}$, whose Complementary $R^{n} - M_{1}^{k}$ and $R^{n} - M_{2}^{k}$ are homomorphic and whose Homology rings are not isomorphic?\n\n65) Let $B_{0}, B_{1}, B_{2}, \\dots, B_{\\omega}, \\dots, B_{\\alpha}, \\dots$ be Borel classes of sets, formed in starting from any class of abstract sets. We know that $B_{\\alpha} = B_{\\alpha+}$. results in $B_{\\alpha}= B_{\\beta}$ for all $\\beta>\\alpha$; let $\\alpha_{0}$ be the first number $\\alpha$ satisfying this condition. What are the numbers $v$ for which there exist classes $B_{0}$ such that we have $\\alpha_{0} = v$? (Cf. Fund. Math. t. XV, p. 284).\n\nProblem of M. A. Kolmogoroff.\n\n66) Does the *weak* $LC$ property entail the strong $LC$ property for any compact metric space ? Same question for $HLC$ properties . (For definitions see Annals of Mathematics , vol. 85, p. 119-129 and Duke Mathematical Journal, vol . 1, p. 1-18).\n\nProblem of M. S. Lefschetz.\n\n67) Is the property ($C$) of linear sets invariant with respect to homomorphic transformations and, more generally, with respect to continuous transformations? (We say that a set $E$ has the *property ($C$)*, when there exists for each sequence $\\{a_{n}\\}$ of positive numbers a decomposition $E=E_{1}+E_{2} + \\dots $ such that the diameter of $E_{n}$ does not exceed $ a_{n}$ for $n= 1, 2,\\dots$. Cf. Fund. Math, volume XI, p. 304; volume XV, p. 126; volume XXII, p. 310.)\n\nProblem of M. W. Sierpinski.\n\n68) If $E_{1}$ and $ E_{2}$ are two linear sets always of first category (i.e. of first category on any perfect set), the set $E_{1} \\times E_{2}$. (i.e. the set of all points $(x, y)$ of the plane where $x \\in E_{1}$ and $y \\in E_{2}$) Is it of the same nature?\n\nProblem of M. E. Szpilrajn.\n\n69) When a Jordan curve (in a three-dimensional space) has a determinate tangent at each point, does there necessarily exist a parametric representation of this curve expressing the cartesian coordinates of a point of this curve as functions which can be derived from a parameter ( and this without the three derivatives canceling out at the same time)?\n\nIn the event of a negative answer, the question is asked again by admitting a set of zero measurement values of the parameter where the imposed conditions are not both satisfied.\n\nProblem of M. M. Fr\\'echet.\n\n70) Does there exist a linear set $ E$ such that each linear analytical set is a one-to-one and continuous (in one sense) image of $E$?\n\nProblem of M. W. Sierpinski.\n\n71) Does there exist an infinite sequence $S$ of functions of a real variable (measurable or not), such that any function of a real variable of class $2$ Baire is a limit of some sequence extracted from $S$?\n\n(According to M. C. Burstin such a sequence $S$ cannot be composed uniquely of measurable functions[^4])\n\nProblem M. W. Sierpinski.\n\n[^4]: Monatshefte f. Math. u. Phys. 28 (1917), p. 107.\n\n72) Does there exist in the $n$-dimensional cart space ($n>1$) a set always of the first category ( i.e. of first category on each perfect set ) and which is of positive dimension?\n\n(M. W. Hurewicz demonstrated using the continuum hypothesis that there exists in Hilbert space an uncountable set $H$ of which each uncountable subset is of infinite dimension[^5]). M. F. Hausdorff noticed that the set $H$ is always of the first category. This follows easily from the fact that each separable metric space $M$ is the sum of a set of dimension $0$ and a set of first category in $M$. -- *There therefore exists, if $2^{\\aleph} = \\aleph_{1}$, in Hilbert space a set always of first category and of positive dimension*).\n\nProbleme de M. E. Szpilrajn.\n\n[^5]: Fund . Math. 19 (1932), p.8.\n\n\n73) Let, in three-dimensional Euclidean space, $E$ be a homomorphic image of the solid sphere $S$ and $L$ be a rectilinear segment whose interior is contained in the interior, and the ends in the border of $E$ . Does there still exist a homeomorphism transforming $E$ into $S$ such that $L$ is transformed into the diameter of $S$?\n\nProblem of M. K. Borsuk.\n\n74) Let $\\mathbf {B}(\\mathbf {F})$ be the smallest family of sets containing the given family $ \\mathbf {F}$ and closed with respect to the operations $\\sigma$ and $\\delta$ (addition and multiplication of countable values). Is there a family of enumerable $\\mathbf{D}$ of sets, such that all linear analytic sets belong to $\\mathbf {B}(\\mathbf{D})$ ?\n\nProblem of M. S. Ulam.\n\n\n75) Is there an infinite set $E$ ( e.g. the set of all natural numbers) and a function $f(X)$ which maps to any subset $X$ of $E $ a subset $f(X)$ of $E$, so that:\n\n1. $X \\subset f(X)$ for $X \\subset E$,\n2. $f(X+Y) = f(X) + f(Y)$ for $X \\subset E$, $Y \\subset E$,\n3. there exists for every set $Y \\subset E$ at least one set $X \\subset E$, such that $Y = f(X)$,\n4. there exists at least one set $X_{0} \\subset E$, such that $f(X_{0}) \\neq X_{0}$.\n\nIf we replace the relative condition to $f(X+Y)$ by the condition weaker than $f(X) \\subset f(Y)$ pure $X \\subset Y \\subset E$, the positive answer is obvious.\n\nProblem of M. E . $\\check{\\text{C}}$ech.\n\n\n\n\n\n# Problems resolved.\n\nProblem. 1) When a set of points $P$ is a one-to-one and continuous image (in a sense) of $Q$ and $Q$ is a one-to-one and continuous image of $P$, can we affirm that the sets $P$ and $Q$ are homomorphic?\n\n*Negative* solution from M. Kuratowski, Fund. Math. t. II, pp. 158-160\n\n4) Is there a decomposition of an interval into $\\aleph_{1}$ measurable sets ($B$), each non-empty and any two of them without points in common?\n\n*Affirmative* solution from MM. Lusin and Sierpinski, *Comptes Rendus*, t. 175, p.357 (note of August 21, 1922).\n\n6, third part) Can it be shown that a product of $\\aleph_{1}$ sets ($A$) is not necessarily a set ($A$)?\n\n*Affirmative* solution from MM. Lusin and Sierpinski, *Journ, de Math*. 1923 (The authors define a set which is complementary to a set ($A$) is not necessarily a set ($A$).)\n\n8) Can we give an effective example of a set of real numbers $E$, such as any sum, any difference, any product and any quotient of two numbers of $E$ (except\\' e division by 0) belongs to $E_{1}$ and that $E$ is non-countable, distinct from the set of all real numbers?\n\n*Affirmative* solution from M. Souslin, *Fund. Math.* IV, p.311.\n\n10, first part) Is there a second class function which is not the limit of almost everywhere discontinuous functions?\n\n*Affirmative* solution from M. Zalcwasser.\n\n12) Does an ordered set of which all well-ordered subsets (increasing or decreasing) are at most enumerable necessarily have a power no greater than that of the continuum?\n\n*Affirmative* solution from M. Urysohn, *Fund. Math.* V (to appear).\n\n15) Is there a continuum of which any subcontinuum is indecomposable?\n\n*Affirmative* solution from M. Knaster, *Fund. Math.* III pp. 247-286.\n\n16) Does there exist a continuum which is a sum of its proper disjoint saturated subcontinua?\n\n*Affirmative* solution by M. Knaster and Kuratowski, *Fund. Math.* V (to appear).\n\n\n","slug":"75 Problems","published":1,"updated":"2023-12-31T07:44:40.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisuna0006eslrcshz8z53","content":"<h1 id=\"problems\">Problems</h1>\r\n<ol type=\"1\">\r\n<li>When a set of points <span class=\"math inline\">\\(P\\)</span> is a\r\none-to-one and continuous image (but not necessarily bi-continuous) of a\r\nset <span class=\"math inline\">\\(Q\\)</span> and when <span\r\nclass=\"math inline\">\\(Q\\)</span> is a one-to-one and continuous image of\r\n<span class=\"math inline\">\\(P\\)</span>? Are the sets <span\r\nclass=\"math inline\">\\(P\\)</span> and $Q $ necessarily homomorphic?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Is a (bounded) plane continuum, topologically homogeneous,\r\nnecessarily homomorphic to a circumference?</li>\r\n</ol>\r\n<p>(A set <span class=\"math inline\">\\(E\\)</span> is said to be\r\n<em>topologically homogeneous </em>, when there exists for any pair of\r\npoints <span class=\"math inline\">\\(a, b\\)</span> of <span\r\nclass=\"math inline\">\\(E\\)</span> a one-to-one and bi-continuous\r\ntransformation of <span class=\"math inline\">\\(E\\)</span> into itself\r\nwhich transforms <span class=\"math inline\">\\(a\\)</span> into <span\r\nclass=\"math inline\">\\(b\\)</span>)</p>\r\n<p>Problem of MM . B. Knaster and C. Kuratowski.</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>A set ordered (linearly) without jumps or gaps and such that any set\r\nof its intervals (containing more than one element) does not overlap\r\nwith each other is at most innumerable, is it necessarily a (ordinary)\r\nlinear continuum?</li>\r\n</ol>\r\n<p>Problem of M. M. Souslin.</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>Is there a decomposition of an interval into <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> (non-empty) sets without\r\ncommon points that are <span class=\"math inline\">\\(B\\)</span>\r\nmeasurable?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"5\" type=\"1\">\r\n<li>Does there exist an uncountable linear set <span\r\nclass=\"math inline\">\\(E\\)</span> such that every linear set homeomorphic\r\nto <span class=\"math inline\">\\(E\\)</span> has zero Lebesgue measure? Can\r\nwe prove the existence of such a set, even assuming that <span\r\nclass=\"math inline\">\\(2^{\\aleph_{0}} = \\aleph_{1}\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"6\" type=\"1\">\r\n<li>Can we find without the hypothesis of the continuum (<span\r\nclass=\"math inline\">\\(2^{\\aleph_{0}} = \\aleph_{1}\\)</span>) that a sum\r\nof <span class=\"math inline\">\\(\\aleph_{1}\\)</span> sets of zero Lebesgue\r\nmeasure is not necessarily zero Lebesgue measure? that a sum of $_{1} $\r\nsets of the first category is not necessarily of the first category?\r\nthat a product of <span class=\"math inline\">\\(\\aleph_{1}\\)</span> sets\r\n(<span class=\"math inline\">\\(A\\)</span>) is not necessarily a set <span\r\nclass=\"math inline\">\\(A\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"7\" type=\"1\">\r\n<li>Can we establish without the hypothesis of the continuum the\r\nexistence of a plane set which has zero (Lebesgue) measure on any\r\ndirection parallel to the abscissa axis and whose complement has zero\r\nmeasure on any direction parallel to the ordinate axis ?</li>\r\n</ol>\r\n<p>Problem of M. H. Steinhaus.</p>\r\n<ol start=\"8\" type=\"1\">\r\n<li>Can we give an effective example of a set of real numbers <span\r\nclass=\"math inline\">\\(E\\)</span> such that any sum, any difference, any\r\nproduct and any quotient of two numbers of <span\r\nclass=\"math inline\">\\(E\\)</span> (except division by 0) belongs to <span\r\nclass=\"math inline\">\\(E\\)</span> and that <span\r\nclass=\"math inline\">\\(E\\)</span> is uncountable , but distinct from the\r\nset of all real numbers ?</li>\r\n</ol>\r\n<p>Problem of M. S. Mazurkiewicz.</p>\r\n<ol start=\"9\" type=\"1\">\r\n<li>What is the power of sets complementary to sets (<span\r\nclass=\"math inline\">\\(A\\)</span>)?</li>\r\n</ol>\r\n<p>Problem of M. N. Lusin.</p>\r\n<p><em>Noticed</em>. The linear sets (<span\r\nclass=\"math inline\">\\(A\\)</span>) are orthogonal projections (on a line)\r\nof the measurable plane sets <span class=\"math inline\">\\(B\\)</span>. M.\r\nLusin demonstrated that the power of an uncountable set complementary to\r\na set (<span class=\"math inline\">\\(A\\)</span>) is <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> or <span\r\nclass=\"math inline\">\\(2^{\\aleph_{0}}\\)</span>, but we do not know if it\r\ncan really be <span class=\"math inline\">\\(\\aleph_{1}\\)</span> (in the\r\ncase where <span class=\"math inline\">\\(2^{\\aleph_{0}} &gt;\r\n\\aleph_{1}\\)</span>).</p>\r\n<ol start=\"10\" type=\"1\">\r\n<li>Does there exist a second class function that is not a limit of\r\nalmost everywhere continuous functions? Can we give an effective example\r\nof a function which is not a limit of piecewise continuous\r\nfunctions?</li>\r\n</ol>\r\n<p>Problem of MM . T. Feosztyn and W. Sierpinski.</p>\r\n<ol start=\"11\" type=\"1\">\r\n<li>Does there exist a class (<span\r\nclass=\"math inline\">\\(\\mathcal{L}\\)</span>) of M. Fr' echet (i.e. a\r\nclass in which the limit is defined) of power greater than the\r\ncontinuum, such that any uncountable set of elements of this class\r\ncontains at least one condensation element?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"12\" type=\"1\">\r\n<li>Does a (linearly) ordered set of which all well-ordered subsets\r\n(increasing and decreasing) are at most countable, necessarily have a\r\npower not greater than the continuum?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"13\" type=\"1\">\r\n<li>Does there exist a closed plane set which is not the sum of two\r\nclosed sets without common points, but which is a sum of a countable\r\nclosed sets without points in common.</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"14\" type=\"1\">\r\n<li>Does a continuum in <span\r\nclass=\"math inline\">\\(m\\)</span>-dimensional space which is homomorphic\r\nto any continuum contain necessarily a simple arc (i.e. image of an\r\none-to-one and continuous mapping of the interval <span\r\nclass=\"math inline\">\\((0,1)\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. Mazurkiewicz.</p>\r\n<ol start=\"15\" type=\"1\">\r\n<li>Does there exist a continuum of which every everything under\r\ncontinuous mapping is indecomposable? (A continuum is said to be\r\nindecomposable when it is not a sum of two continua different from\r\nit.)</li>\r\n</ol>\r\n<p>Problem of MM . Knaster and Kuratowski.</p>\r\n<ol start=\"16\" type=\"1\">\r\n<li>Does there exist a continuum (unbounded) which is a sum of its\r\nproper saturated sub-continuums where any two of them do not\r\nintersect?</li>\r\n</ol>\r\n<p>(We say that a real subcontinuum <span\r\nclass=\"math inline\">\\(K\\)</span> of <span\r\nclass=\"math inline\">\\(C\\)</span> is <em>saturated</em>, when there\r\nexists no continuum different from <span\r\nclass=\"math inline\">\\(K\\)</span> and <span\r\nclass=\"math inline\">\\(C\\)</span> which contains <span\r\nclass=\"math inline\">\\(K\\)</span> and which is contained in <span\r\nclass=\"math inline\">\\(C\\)</span>.)</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"17\" type=\"1\">\r\n<li>What is the power of the set of all values that a Baire class 1\r\nfunction does not take?</li>\r\n</ol>\r\n<p>(This problem is equivalent to problem 9 of M. Lusin, t . I. p.224.\r\nIt would be enough to solve this problem for functions admitting\r\nuncountable points of discontinuity.)</p>\r\n<ol start=\"18\" type=\"1\">\r\n<li>Is a (linear) set of power less than the continuum necessarily of\r\nthe first category of M. Baire?</li>\r\n</ol>\r\n<p>Problem of M. Ruziewicz.</p>\r\n<ol start=\"19\" type=\"1\">\r\n<li>Does there exist in each biconnected set <span\r\nclass=\"math inline\">\\(B\\)</span> a point <span\r\nclass=\"math inline\">\\(p\\)</span> such that the set <span\r\nclass=\"math inline\">\\(B - (p)\\)</span> contains no connected set?</li>\r\n</ol>\r\n<p><em>Noticed</em>. According to a theorem of M. Kline (this volume,\r\np.238), there cannot exist in a connected set <span\r\nclass=\"math inline\">\\(B\\)</span> more than one point <span\r\nclass=\"math inline\">\\(p\\)</span> enjoying the property in question. We\r\nknow, on the other hand, that, if such a point exists, the set <span\r\nclass=\"math inline\">\\(B\\)</span> is biconnected, i.e. it is not the sum\r\nof two disjoint connected sets containing more than one point (cf.\r\nKnaster and Kuratowski, * Fund . Math.* II, p, 214.)</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"20\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(f(E)\\)</span> be a function defined\r\nby any measurable (<span class=\"math inline\">\\(L\\)</span>) set <span\r\nclass=\"math inline\">\\(E\\)</span> of a Euclidean space of <span\r\nclass=\"math inline\">\\(m \\geq 3\\)</span> dimensions and satisfying the\r\nfollowing conditions:</li>\r\n</ol>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(f(E) \\geq 0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(f(E_{0}) = 1\\)</span> for a certain set\r\n<span class=\"math inline\">\\(E_{0}\\)</span> of measure 1.</li>\r\n<li><span class=\"math inline\">\\(f(E_{1} +E_{2}) = f(E_{1}) +\r\nf(E_{2})\\)</span>, if <span class=\"math inline\">\\(E_{1} E_{2} =\r\n0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(f(E_{1}) = f(E_{2})\\)</span>, if <span\r\nclass=\"math inline\">\\(E_{1}\\)</span> and <span\r\nclass=\"math inline\">\\(E_{2}\\)</span> are superimposable.</li>\r\n</ol>\r\n<p>Is the function <span class=\"math inline\">\\(f(E)\\)</span> necessarily\r\ncoincide with the Lebesgue measure of the set <span\r\nclass=\"math inline\">\\(E\\)</span>?</p>\r\n<p>(For <span class=\"math inline\">\\(m=1\\)</span> and <span\r\nclass=\"math inline\">\\(m=2\\)</span> the answer is negative, as M. Banach\r\nproved in a memoir which will be published in the volume IV of this\r\njournal.)</p>\r\n<p>Problem of M. Ruziewicz.</p>\r\n<ol start=\"21\" type=\"1\">\r\n<li>Given a set of real numbers which is not of the first category in\r\nany interval, is there a decomposition: <span class=\"math inline\">\\(A =\r\nB + C\\)</span>, <span class=\"math inline\">\\(B \\times C = 0\\)</span> such\r\nthat neither <span class=\"math inline\">\\(B\\)</span> nor <span\r\nclass=\"math inline\">\\(C\\)</span> are of the first category in any\r\ninterval?</li>\r\n</ol>\r\n<p><em>Noticed</em>. We could give the affirmative answer in the\r\nhypothesis additional that <span class=\"math inline\">\\(A\\)</span> has\r\nthe Baire property (in the sense established in this volume), p.319 . M.\r\nSierpinski also pointed out the affirmative answer in the hypothesis of\r\nthe continuum , <span class=\"math inline\">\\(\\aleph_{1} =\r\n2^{\\aleph_{0}}\\)</span>.</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"22\" type=\"1\">\r\n<li>Let us call the (linear) set $ E$ <em>perfectly measurable</em>, if\r\nevery set homomorphic to <span class=\"math inline\">\\(E\\)</span> is\r\nmeasurable in the sense of Lebesgue. What is the power of the class of\r\nperfectly measurable sets? Is a complementary set to a perf. measurable\r\nset always perf. measurable?</li>\r\n</ol>\r\n<p>Problem of M. Urysohn.</p>\r\n<ol start=\"23\" type=\"1\">\r\n<li>Does there exist a function of a real variable $ f(x)$ pantachically\r\ndicontinuous and such that we have for all real <span\r\nclass=\"math inline\">\\(x\\)</span></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\lim_{h \\to 0} \\frac{f( x+h ) -\r\nf(x-h)}{2h} = 0?\\]</span></p>\r\n<p>Problem of M. Steinhaus.</p>\r\n<ol start=\"24\" type=\"1\">\r\n<li>Is a function satisfying Baire's condition necessarily measurable\r\n(<span class=\"math inline\">\\(L\\)</span>)? What is the power of all the\r\nfunctions of a real variable satisfying the Baire condition? (We say\r\nthat a function <span class=\"math inline\">\\(f(x)\\)</span> satisfies the\r\nBaire condition, if it continues on any perfect set when we do not\r\nneglect the sets of the first category with respect to has that perfect\r\nset.)</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"25\" type=\"1\">\r\n<li>Can a plane set, such that any straight line meets it at two (and\r\nonly two) points, be measurable (<span\r\nclass=\"math inline\">\\(B\\)</span>)? (The existence of such a set has been\r\ndemonstrated , using M. Zermelos theorem, by MM. Mazurkiewicz<a\r\nhref=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\"\r\nrole=\"doc-noteref\"><sup>1</sup></a> (in 1914) and Rosenthal<a\r\nhref=\"#fn2\" class=\"footnote-ref\" id=\"fnref2\"\r\nrole=\"doc-noteref\"><sup>2</sup></a> (in 1922))</li>\r\n</ol>\r\n<ol start=\"26\" type=\"1\">\r\n<li>Is a class 3 function of M. Baire always a superposition of three\r\nclass 1 functions, that is to say, does it exist for any function <span\r\nclass=\"math inline\">\\(f(x)\\)</span> of class 3 three class 1 functions\r\n<span class=\"math inline\">\\(\\varphi (x)\\)</span>, <span\r\nclass=\"math inline\">\\(\\psi(x)\\)</span> and <span\r\nclass=\"math inline\">\\(\\vartheta(x)\\)</span>, such that we have for all\r\nreal <span class=\"math inline\">\\(x\\)</span></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[f(x) = \\varphi \\{\\psi[\\vartheta\r\n(x)]\\}\\]</span></p>\r\n<p>Problem of M. Lusin.</p>\r\n<ol start=\"27\" type=\"1\">\r\n<li>Is the set <span class=\"math inline\">\\(D(E)\\)</span> of the\r\ndistances of the points of a linear set <span\r\nclass=\"math inline\">\\(E\\)</span> that is (<span\r\nclass=\"math inline\">\\(B\\)</span>) measurable always (<span\r\nclass=\"math inline\">\\(B\\)</span>) measurable? (<span\r\nclass=\"math inline\">\\(D(E)\\)</span> is therefore the set of all numbers\r\n<span class=\"math inline\">\\(|x - y|\\)</span>, where <span\r\nclass=\"math inline\">\\(x\\)</span> and <span\r\nclass=\"math inline\">\\(y\\)</span> belong to <span\r\nclass=\"math inline\">\\(E\\)</span>. We can prove the existence of set\r\n<span class=\"math inline\">\\(E\\)</span> that are measurable (<span\r\nclass=\"math inline\">\\(L\\)</span>), such that <span\r\nclass=\"math inline\">\\(D(E)\\)</span> is non-measurable (<span\r\nclass=\"math inline\">\\(L\\)</span>).)</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"28\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(E\\)</span> is a (<span\r\nclass=\"math inline\">\\(B\\)</span> measurable) plane set, let us denote by\r\n<span class=\"math inline\">\\(N(E)\\)</span> the set of all real numbers $\r\na$, such that the line <span class=\"math inline\">\\(x = a\\)</span> meets\r\n<span class=\"math inline\">\\(E\\)</span> at a uncountable infinite number\r\nof points. Is the set <span class=\"math inline\">\\(N(E)\\)</span>\r\nnecessarily a set (<span class=\"math inline\">\\(A\\)</span>), or, more\r\nsimply, is it measurable ($ L $)? (It can be shown that the set of all\r\nreal numbers <span class=\"math inline\">\\(a\\)</span>, such that the line\r\n<span class=\"math inline\">\\(x = a\\)</span> meets the (<span\r\nclass=\"math inline\">\\(B\\)</span> measurable) set <span\r\nclass=\"math inline\">\\(E\\)</span> in an infinity number of points is\r\nalways a set <span class=\"math inline\">\\(A\\)</span>.)</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"29\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(F\\)</span> be a plane set, p. ex.\r\nclosed (or, more generally, measurable) - A point <span\r\nclass=\"math inline\">\\(x\\)</span> of <span\r\nclass=\"math inline\">\\(F\\)</span> will be said to be <em>linearly\r\naccessible </em> if there exists a rectilinear segment <span\r\nclass=\"math inline\">\\(\\overline{xp}\\)</span> such that all its points\r\n(except the point <span class=\"math inline\">\\(x\\)</span>) are outside\r\n<span class=\"math inline\">\\(F\\)</span>. Can it be shown that the set\r\n<span class=\"math inline\">\\(A\\)</span> of all linearly accessible points\r\nof <span class=\"math inline\">\\(F\\)</span> is always measurable (<span\r\nclass=\"math inline\">\\(L\\)</span>)?</li>\r\n</ol>\r\n<p>Problem of M. Urysohn.</p>\r\n<ol start=\"30\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(f(x)\\)</span> is an arbitrarily given\r\nfunction (measurable or not), what is the measure of the sum of all\r\npoints <span class=\"math inline\">\\(x\\)</span>, such that</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\lim \\limits_{h\\to 0} \\left |\\frac{f(\r\nx+h ) - f(x)}{h}\\right| = \\infty \\]</span></p>\r\n<p>Problem of M. Ruziewicz.</p>\r\n<ol start=\"31\" type=\"1\">\r\n<li>The theorem : \" <span class=\"math inline\">\\(\\mathsf{m} =\r\n2\\cdot\\mathsf{m}\\)</span> whatever the <em>transfinite</em> cardinal\r\nnumber <span class=\"math inline\">\\(\\mathsf {m}\\)</span>\" is it\r\nequivalent to <em>the axiom of choice</em>?</li>\r\n</ol>\r\n<p>Cf. my Note \"<em>On some themes which are equivalent to the axiom of\r\nchoice</em>\" in this volume, p. 147.</p>\r\n<p>Problem of M. Tajtelbaum-Tarski .</p>\r\n<ol start=\"32\" type=\"1\">\r\n<li>Is a closed plane set, where every point is linearly accessible,\r\nnecessarily of zero surface measure?</li>\r\n</ol>\r\n<p>Problem of M. Banach.</p>\r\n<p>A point <span class=\"math inline\">\\(x\\)</span> of <span\r\nclass=\"math inline\">\\(F\\)</span> is said to be linearly accessible if\r\nthere exists a rectilinear segment <span\r\nclass=\"math inline\">\\(\\overline{xp}\\)</span> such that all its points\r\n(except the point <span class=\"math inline\">\\(x\\)</span>) are outside\r\n<span class=\"math inline\">\\(F\\)</span>. M. Urysohn proved that the set\r\nof all linearly accessible points of a closed plane set is always a set\r\n(<span class=\"math inline\">\\(A\\)</span>) of M. Souslin, but may not be\r\nmeasurable (<span class=\"math inline\">\\(B\\)</span>). But we do not know\r\nif the set of all linearly accessible points of a plane set <span\r\nclass=\"math inline\">\\(G_{\\delta}\\)</span> is measurable (<span\r\nclass=\"math inline\">\\(L\\)</span>) (Cf. Problem 29 , * Fund . Math .* t.\r\nV, p. 337).</p>\r\n<ol start=\"33\" type=\"1\">\r\n<li>Is a one-to-one and continuous map (in one sense) of a set\r\ncomplementary to a set (<span class=\"math inline\">\\(A\\)</span>) of M.\r\nSouslin necessarily a homeomorphism?</li>\r\n</ol>\r\n<p>Problem of Sierpinski.</p>\r\n<ol start=\"34\" type=\"1\">\r\n<li>Let us call a (<span class=\"math inline\">\\(B\\)</span>) measurable\r\n(linear) set of class <span class=\"math inline\">\\(\\alpha\\)</span>\r\n<em>irreducible</em> if it is not of class <span\r\nclass=\"math inline\">\\(&lt;\\alpha\\)</span> in any interval. What is the\r\npower of the set of all topological types of irreducible sets of class\r\n<span class=\"math inline\">\\(\\alpha\\)</span>?</li>\r\n</ol>\r\n<p>Let us call a set (<span class=\"math inline\">\\(A\\)</span>)\r\n<em>irreducible</em>, if it is not (<span\r\nclass=\"math inline\">\\(B\\)</span>) measurable in any interval. What is\r\nthe power of all the topological types of the sets (<span\r\nclass=\"math inline\">\\(A\\)</span>) irreducible?</p>\r\n<p>Problem of MM . Alexandroff and Urysohn.</p>\r\n<ol start=\"35\" type=\"1\">\r\n<li>Let us call the (linear) set <span class=\"math inline\">\\(E\\)</span>\r\n<em>perfectly measurable in the narrow sense</em>, if every unambiguous\r\nand continuous image of <span class=\"math inline\">\\(E\\)</span> is\r\nmeasurable in the sense of Lebesgue. Is a set complementary to a set\r\nperfectly measurable in the narrow sense always a homeomorphic\r\nimage?</li>\r\n</ol>\r\n<p>Cf. Problem 22 of P. Urysohn ( <em>Fund. Math.</em> t. IV, p. 368),\r\nsolved by M. Lavrentieff (<em>Fund. Math.</em> t. VI, p. 159).</p>\r\n<p>Probleme de M. O. Nikodym.</p>\r\n<ol start=\"36\" type=\"1\">\r\n<li>According to M. Souslin, if <span class=\"math inline\">\\(E\\)</span>\r\nis a set (<span class=\"math inline\">\\(A\\)</span>) and <span\r\nclass=\"math inline\">\\(H\\)</span> a complementary set to a set (<span\r\nclass=\"math inline\">\\(A\\)</span>), and if <span class=\"math inline\">\\(E\r\n\\subset H\\)</span>, there exists a set <span\r\nclass=\"math inline\">\\(Q\\)</span>, (<span\r\nclass=\"math inline\">\\(B\\)</span>) measurable, such that <span\r\nclass=\"math inline\">\\(E\\ subset Q \\subset H\\)</span><a href=\"#fn3\"\r\nclass=\"footnote-ref\" id=\"fnref3\" role=\"doc-noteref\"><sup>3</sup></a>.\r\nDoes this proposition admit a reciprocal, that is to say, <em>if <span\r\nclass=\"math inline\">\\(E\\)</span> is a complementary set to a set (<span\r\nclass=\"math inline\">\\(A\\)</span>) and <span\r\nclass=\"math inline\">\\(H\\)</span> ------ does a set (<span\r\nclass=\"math inline\">\\(A\\)</span>), such that <span\r\nclass=\"math inline\">\\(E \\subset H\\)</span>, exist always a (<span\r\nclass=\"math inline\">\\(B\\)</span>) measurable set <span\r\nclass=\"math inline\">\\(Q\\)</span>, such that <span\r\nclass=\"math inline\">\\(E \\subset Q \\subset H\\)</span>?</em></li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"37\" type=\"1\">\r\n<li>Is a Jordan (bounded) continuum which contains only a simple closed\r\ncurve homomorphic to one of its (real) sub-continuums?</li>\r\n</ol>\r\n<p>Problem of M. Zarankiewicz.</p>\r\n<ol start=\"38\" type=\"1\">\r\n<li>Can a square and a circle whose areas are equal be decomposed into a\r\nfinite number of respectively congruent disjoint subsets?</li>\r\n</ol>\r\n<p>Problem of M. Tarski.</p>\r\n<ol start=\"39\" type=\"1\">\r\n<li>Does there exist a closed set <em>plane</em> for which the set of\r\nlinearly accessible points is non-measurable (<span\r\nclass=\"math inline\">\\(B\\)</span>)? (In space the problem is resolved in\r\nthe affirmative sense).</li>\r\n</ol>\r\n<p>Problem of M. O. Nikodym.</p>\r\n<ol start=\"40\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(E\\)</span> is a plane set <span\r\nclass=\"math inline\">\\(G_{\\delta}\\)</span>, is the set of all real\r\nnumbers <span class=\"math inline\">\\(a\\)</span>, such that the line <span\r\nclass=\"math inline\">\\(x =a\\)</span> meets the set <span\r\nclass=\"math inline\">\\(E\\)</span> in one and only one point, not\r\nnecessarily complementary to a set ($A $) of M. Souslin?</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"41\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(E_{1}, E_{2}, E_{3}, \\dots\\)</span>\r\nare a sequence of countable linear sets each of which is a projection of\r\na complete plane set complementary to a set (<span\r\nclass=\"math inline\">\\(A\\)</span>) of M. Souslin, is the set $E_{1}E_{2}\r\nE_{3} $ of the same nature?</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"42\" type=\"1\">\r\n<li>Does there exist in every continuum <span\r\nclass=\"math inline\">\\(A\\)</span> a continuum <span\r\nclass=\"math inline\">\\(B\\)</span> such that the set <span\r\nclass=\"math inline\">\\(AB\\)</span> is connected?</li>\r\n</ol>\r\n<p>Problem of MM . Knaster and Zarankiewicz .</p>\r\n<ol start=\"43\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(D\\)</span> denote a closed\r\nhomomorphic set of a plane set and located in 3-dimensional Euclidean\r\nspace, is every point of <span class=\"math inline\">\\(D\\)</span> is\r\n<em>accessible</em> in this space?</li>\r\n</ol>\r\n<p>(A point <span class=\"math inline\">\\(d\\)</span> of <span\r\nclass=\"math inline\">\\(D\\)</span> is said to be <em>accessible</em> in\r\n<span class=\"math inline\">\\(E\\)</span>, when there exists a continuum\r\n<span class=\"math inline\">\\(C \\subset E\\)</span> such that <span\r\nclass=\"math inline\">\\((d) = CD\\)</span>).</p>\r\n<p>Problem of M. Knaster.</p>\r\n<ol start=\"46\" type=\"1\">\r\n<li>It is asked to set up the logical relations between the various\r\nconcepts of homogeneity, in so far as they refer to small compact sets.\r\nIn particular, even if the sets are considered to be connected and (or)\r\nconnected in the small be assumed.</li>\r\n</ol>\r\n<p>(See D. van Dantzig , \"On topologically homogeneous continua, volume\r\n15, pp. 102, 103).</p>\r\n<p>Problem of M. van Dantzig .</p>\r\n<ol start=\"47\" type=\"1\">\r\n<li>Is every (connected, unbounded) <span\r\nclass=\"math inline\">\\(n\\)</span>-dimensional manifold involutory\r\nhomogeneous?</li>\r\n</ol>\r\n<p>(Cf. D. van Dantzig , le p. 104, ^7.)</p>\r\n<p>Problem of M. van Dantzig.</p>\r\n<ol start=\"48\" type=\"1\">\r\n<li>Let us call a topological group <em>monothetic</em> if an infinite\r\ncyclic group is dense in it (in which case it is commutative and can be\r\nwritten additively), and <em>complete</em> if every sequence $x_{} $,\r\nwhich satisfies the Cauchy's convergence criterion <span\r\nclass=\"math inline\">\\(\\lim (x_{\\nu} - x_{\\mu } = 0\\)</span> has a limit\r\nelement in the group, the question is whether a monothetic group can be\r\ncomplete without being compact.</li>\r\n</ol>\r\n<p>(See lc p. 116 ^{29}a))</p>\r\n<p>Problem of M. van Dantzig .</p>\r\n<ol start=\"49\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(X\\)</span> and <span\r\nclass=\"math inline\">\\(Y\\)</span> be two Peano continua (= continuous\r\nimages of the interval) and <span class=\"math inline\">\\(Z\\)</span> be\r\ntheir topological product (= the space of all pairs $z = (x,y) $ or\r\n<span class=\"math inline\">\\(\\lim z_{n}=z\\)</span> when <span\r\nclass=\"math inline\">\\(\\lim x_{n} = x\\)</span> and <span\r\nclass=\"math inline\">\\(\\lim y_{n} = y\\)</span>).</li>\r\n</ol>\r\n<p>1^0. If the continuum <span class=\"math inline\">\\(X\\)</span>, as well\r\nas <span class=\"math inline\">\\(Y\\)</span>, has the property that in each\r\ncontinuous transformation of this continuum into a subset there exists\r\nan invariant point, is it true that <span\r\nclass=\"math inline\">\\(Z\\)</span> has the same property?</p>\r\n<p>2^0. If the continuum <span class=\"math inline\">\\(X\\)</span>, as well\r\nas <span class=\"math inline\">\\(Y\\)</span>, is uni-consistent (= in each\r\ndecomposition of this continuum into two sub-continuums the common part\r\nof these sub-continuums is connected), is it true that <span\r\nclass=\"math inline\">\\(Z\\)</span> is uni-coherent?</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"50\" type=\"1\">\r\n<li>Is the topological circle the only homogeneous small connected\r\ncurve? (Curve = one-dimensional connected compact space. A space is\r\ncalled homogeneous, if for each of its two points <span\r\nclass=\"math inline\">\\(p\\)</span> and <span\r\nclass=\"math inline\">\\(q\\)</span> there exist a homeomorphism which sends\r\n<span class=\"math inline\">\\(p\\)</span> to <span\r\nclass=\"math inline\">\\(q\\)</span> ). On the plane, the circle is the only\r\nsmall, homogeneous curve.</li>\r\n</ol>\r\n<p>(Cf. Mazurkiewicz, Fund. Math. V, p. 137).</p>\r\n<p>Problem with M. K. Menger.</p>\r\n<ol start=\"51\" type=\"1\">\r\n<li>Are there any or even an infinite number of compact one-dimensional\r\nspaces any two of which are incomparable in one dimension? Two spaces\r\n<span class=\"math inline\">\\(R\\)</span> and <span\r\nclass=\"math inline\">\\(R^{\\prime}\\)</span> may be called\r\none-dimensionally incomparable , if no one-dimensional subset of <span\r\nclass=\"math inline\">\\(R\\)</span>, (or of <span\r\nclass=\"math inline\">\\(R^{\\prime}\\)</span>) is homomorphic with a subset\r\nof <span class=\"math inline\">\\(R^{\\prime}\\)</span> (or of <span\r\nclass=\"math inline\">\\(R^{\\prime}\\)</span>). For example, a line and a\r\ncontinuum without partial arcs are incomparable in one dimension. (If\r\nthere are <span class=\"math inline\">\\(n\\)</span>, or <span\r\nclass=\"math inline\">\\(\\aleph_{0}\\)</span> in pairs of one-dimensionally\r\nincomparable curves, then there exist compact one-dimensional spaces\r\nwhich contains at least <span class=\"math inline\">\\(2^{n} +1\\)</span>,\r\nor <span class=\"math inline\">\\(2^{\\aleph _{0}}\\)</span> monotone, <span\r\nclass=\"math inline\">\\(F_{\\sigma }\\)</span>-additive, topological,\r\ncompactifiable systems of subsets).</li>\r\n</ol>\r\n<p>(See Monthly Issues f. Math. and Phys. 36, p. 207).</p>\r\n<p>Problem of M. K. Menger.</p>\r\n<ol start=\"52\" type=\"1\">\r\n<li>Does there exist a continuum of which every other continuum is a\r\ncontinuous image?</li>\r\n</ol>\r\n<p>Problem of M. H. Hahn.</p>\r\n<ol start=\"53\" type=\"1\">\r\n<li><ol type=\"a\">\r\n<li>Can every absolute retract be decomposed into a finite number of\r\nabsolute retracts with arbitrarily small diameters?</li>\r\n</ol></li>\r\n</ol>\r\n<ol start=\"2\" type=\"a\">\r\n<li>Let every <span class=\"math inline\">\\(R\\)</span> set be decomposed\r\ninto a finite number of absolute retracts?</li>\r\n</ol>\r\n<p>(The definition of absolute retracts and <span\r\nclass=\"math inline\">\\(R\\)</span> sets is given, for example, in Fund.\r\nMath. XIX, p. 222).</p>\r\n<ol start=\"54\" type=\"1\">\r\n<li><p>Is every partial continuum <span class=\"math inline\">\\(C\\)</span>\r\nof the Euclidean <span class=\"math inline\">\\(n\\)</span>-dimensional\r\nspace <span class=\"math inline\">\\(R_{n}\\)</span>, which intersects <span\r\nclass=\"math inline\">\\(R_{n}\\)</span> and which is transferred by\r\narbitrarily small transformations (i.e. by a continuous mapping which\r\nsends every point from <span class=\"math inline\">\\(C\\)</span> to an\r\narbitrarily close point of <span class=\"math inline\">\\(R_{n}\\)</span>)\r\ninto a subset of <span class=\"math inline\">\\(R_{n}\\)</span> that is\r\nforeign to it, a (<span class=\"math inline\">\\(n-1\\)</span>) dimensional\r\nspace?</p></li>\r\n<li><p>Can every route image lying in <span\r\nclass=\"math inline\">\\(R_{3}\\)</span> and intersecting <span\r\nclass=\"math inline\">\\(R_{3}\\)</span> be mapped continuously without\r\nfixed points?</p></li>\r\n</ol>\r\n<p>Problem of M. K. Borsuk.</p>\r\n<ol start=\"56\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(A\\)</span> and <span\r\nclass=\"math inline\">\\(B\\)</span> be two topological spaces and <span\r\nclass=\"math inline\">\\(A^{2}\\)</span> and <span\r\nclass=\"math inline\">\\(B^{2}\\)</span> respectively their squares (a. `ad\r\n<span class=\"math inline\">\\(A^{2}\\)</span> p . ex. consists of all your\r\npairs (<span class=\"math inline\">\\(a_{1}\\)</span>, <span\r\nclass=\"math inline\">\\(a_{2}\\)</span>) extracted from <span\r\nclass=\"math inline\">\\(A\\)</span>).</li>\r\n</ol>\r\n<p>Is it true that if <span class=\"math inline\">\\(A^{2}\\)</span> and\r\n<span class=\"math inline\">\\(B^{2}\\)</span> are homeomorphic, are <span\r\nclass=\"math inline\">\\(A\\)</span> and <span\r\nclass=\"math inline\">\\(B\\)</span> too?</p>\r\n<p>In case of a positive answer , we deduce that, if <span\r\nclass=\"math inline\">\\(C\\)</span> is a set which is not homeomorphic to\r\nnone of <span class=\"math inline\">\\(C^{n}\\)</span>, <span\r\nclass=\"math inline\">\\(n&gt;1\\)</span>, the sets <span\r\nclass=\"math inline\">\\(C^{m}\\)</span> and <span\r\nclass=\"math inline\">\\(C^{n}\\)</span> are neither homeomorphic for <span\r\nclass=\"math inline\">\\(m \\neq n\\)</span>; this provides in the case where\r\n<span class=\"math inline\">\\(C\\)</span> is an interval of the theorem of\r\n\"invariance of the dimension\" of M. Brouwer .</p>\r\n<p>Problem of M. S. Ulam.</p>\r\n<ol start=\"57\" type=\"1\">\r\n<li>Does there exist an infinite-dimensional continuum that does not\r\ncontain any finite-dimensional continuum?</li>\r\n</ol>\r\n<p>Problems of M. S. Mazurkiewicz.</p>\r\n<ol start=\"58\" type=\"1\">\r\n<li>Does there exist in a set <span class=\"math inline\">\\(E\\)</span> of\r\nsize <span class=\"math inline\">\\(\\aleph_{1}\\)</span> a countable system\r\nof subsets <span class=\"math inline\">\\(A_{1}, A_{2},\\dots\\)</span> such\r\nthat one has the form <span class=\"math display\">\\[X = \\overline{\\lim}\r\nA_{p_{n}}\\]</span> where (<span class=\"math inline\">\\(p_{1},\r\np_{2},,\\dots\\)</span> is a subsequence of the natural numbers, <span\r\nclass=\"math inline\">\\(\\overline{\\lim}\\)</span> means the Borel\r\n<em>complete limit set</em>) all subsets <span\r\nclass=\"math inline\">\\(X\\)</span> received from <span\r\nclass=\"math inline\">\\(E\\)</span>?</li>\r\n</ol>\r\n<p>(It is a question of proving the negation without using the continuum\r\nhypothesis).</p>\r\n<p>Problems with M. F. Hausdorff. _</p>\r\n<ol start=\"59\" type=\"1\">\r\n<li>A function with the Baire property (i.e. continuous on any perfect\r\nset, when we neglect a set of <span\r\nclass=\"math inline\">\\(1^{re}\\)</span> category relative to this set) of\r\na function with the Baire property, is it of the same nature?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"60\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(\\rho\\)</span> be the set of all\r\nhomeomorphic transformations of the cartesian plane in itself, of the\r\nform: <span class=\"math display\">\\[x^{\\prime} = x, \\quad y^{\\prime} =f(\r\nx,y )\\]</span> and <span class=\"math display\">\\[x^{\\prime}=g( x,y ),\r\n\\quad    y^{\\prime}=y.\\]</span></li>\r\n</ol>\r\n<p>Let us denote by <span class=\"math inline\">\\(\\sigma\\)</span> the\r\ngroup formed by all the finite superpositions of all the transformations\r\nbelonging to <span class=\"math inline\">\\(\\rho\\)</span>. Can an arbitrary\r\nhomeomorphic transformation of the plane in itself always be approached\r\nby those of the group <span class=\"math inline\">\\(\\sigma\\)</span> ?</p>\r\n<p>An analogous problem remains for <span\r\nclass=\"math inline\">\\(n&gt;2\\)</span> dimensional spaces. Problem of\r\nM.S. Ulam.</p>\r\n<ol start=\"61\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(E\\)</span> be a <span\r\nclass=\"math inline\">\\(G_{\\delta}\\)</span> plane set (more generally: a\r\nBorel set) all of whose intersections with the lines parallel to the\r\n<span class=\"math inline\">\\(y\\)</span> axis are closed sets (more\r\ngenerally: <span class=\"math inline\">\\(F_{\\sigma}\\)</span>). Is the\r\nprojection of <span class=\"math inline\">\\(E\\)</span> on the <span\r\nclass=\"math inline\">\\(x\\)</span> axis always a Borel set?</li>\r\n</ol>\r\n<p>Problem of ME Szpilrajsn.</p>\r\n<ol start=\"62\" type=\"1\">\r\n<li>The (real) function <span class=\"math inline\">\\(f(x)\\)</span> of the\r\nreal variable <span class=\"math inline\">\\(x\\)</span> is called\r\n<em>symmetric-continuous</em> if for every <span\r\nclass=\"math inline\">\\(x\\)</span> <span class=\"math display\">\\[\\lim\r\n\\limits_{h \\to 0} [f( x+h ) - f(x - h)] = 0.\\]</span> Can the set of\r\ndiscontinuities of such a function be uncountable? Can it be an\r\narbitrarily prescribed set <span\r\nclass=\"math inline\">\\(F_{\\sigma}\\)</span>? (That they are an arbitrarily\r\nprescribed countable set is easy to see.)</li>\r\n</ol>\r\n<p>Problem of M. F. Hausdorff.</p>\r\n<ol start=\"63\" type=\"1\">\r\n<li>Two compact spaces <span class=\"math inline\">\\(A\\)</span> and <span\r\nclass=\"math inline\">\\(B\\)</span> have the <em>same homotopy type</em>,\r\nwhen there exists a continuous transformation <span\r\nclass=\"math inline\">\\(f\\)</span> from <span\r\nclass=\"math inline\">\\(A\\)</span> to <span\r\nclass=\"math inline\">\\(B\\)</span> and a continuous transformation <span\r\nclass=\"math inline\">\\(\\varphi\\)</span> from <span\r\nclass=\"math inline\">\\(B\\)</span> to <span\r\nclass=\"math inline\">\\(A\\)</span>, such as the superpositions <span\r\nclass=\"math inline\">\\(\\ varphi f\\)</span> and $f$ (consider respectively\r\nas transformations of <span class=\"math inline\">\\(A\\)</span> into <span\r\nclass=\"math inline\">\\(A\\)</span> and of <span\r\nclass=\"math inline\">\\(B\\)</span> into <span\r\nclass=\"math inline\">\\(B\\)</span>) are homotopic to the identity . Are\r\ntwo closed varieties of the same homotopy type always homomorphic?</li>\r\n</ol>\r\n<p>Problem of M. W. Hurewicz.</p>\r\n<ol start=\"64\" type=\"1\">\r\n<li><p>Do there exist two in <span class=\"math inline\">\\(R^{n}\\)</span>\r\norientable Manifolds <span class=\"math inline\">\\(M_{1}^{k}\\)</span> and\r\n<span class=\"math inline\">\\(M_{2}^{k}\\)</span>, whose Complementary\r\n<span class=\"math inline\">\\(R^{n} - M_{1}^{k}\\)</span> and <span\r\nclass=\"math inline\">\\(R^{n} - M_{2}^{k}\\)</span> are homomorphic and\r\nwhose Homology rings are not isomorphic?</p></li>\r\n<li><p>Let <span class=\"math inline\">\\(B_{0}, B_{1}, B_{2}, \\dots,\r\nB_{\\omega}, \\dots, B_{\\alpha}, \\dots\\)</span> be Borel classes of sets,\r\nformed in starting from any class of abstract sets. We know that <span\r\nclass=\"math inline\">\\(B_{\\alpha} = B_{\\alpha+}\\)</span>. results in\r\n<span class=\"math inline\">\\(B_{\\alpha}= B_{\\beta}\\)</span> for all <span\r\nclass=\"math inline\">\\(\\beta&gt;\\alpha\\)</span>; let <span\r\nclass=\"math inline\">\\(\\alpha_{0}\\)</span> be the first number <span\r\nclass=\"math inline\">\\(\\alpha\\)</span> satisfying this condition. What\r\nare the numbers <span class=\"math inline\">\\(v\\)</span> for which there\r\nexist classes <span class=\"math inline\">\\(B_{0}\\)</span> such that we\r\nhave <span class=\"math inline\">\\(\\alpha_{0} = v\\)</span>? (Cf. Fund.\r\nMath. t. XV, p. 284).</p></li>\r\n</ol>\r\n<p>Problem of M. A. Kolmogoroff.</p>\r\n<ol start=\"66\" type=\"1\">\r\n<li>Does the <em>weak</em> <span class=\"math inline\">\\(LC\\)</span>\r\nproperty entail the strong <span class=\"math inline\">\\(LC\\)</span>\r\nproperty for any compact metric space ? Same question for <span\r\nclass=\"math inline\">\\(HLC\\)</span> properties . (For definitions see\r\nAnnals of Mathematics , vol. 85, p. 119-129 and Duke Mathematical\r\nJournal, vol . 1, p. 1-18).</li>\r\n</ol>\r\n<p>Problem of M. S. Lefschetz.</p>\r\n<ol start=\"67\" type=\"1\">\r\n<li>Is the property (<span class=\"math inline\">\\(C\\)</span>) of linear\r\nsets invariant with respect to homomorphic transformations and, more\r\ngenerally, with respect to continuous transformations? (We say that a\r\nset <span class=\"math inline\">\\(E\\)</span> has the <em>property (<span\r\nclass=\"math inline\">\\(C\\)</span>)</em>, when there exists for each\r\nsequence <span class=\"math inline\">\\(\\{a_{n}\\}\\)</span> of positive\r\nnumbers a decomposition $E=E_{1}+E_{2} + $ such that the diameter of\r\n<span class=\"math inline\">\\(E_{n}\\)</span> does not exceed $ a_{n}$ for\r\n<span class=\"math inline\">\\(n= 1, 2,\\dots\\)</span>. Cf. Fund. Math,\r\nvolume XI, p. 304; volume XV, p. 126; volume XXII, p. 310.)</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"68\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(E_{1}\\)</span> and $ E_{2}$ are two\r\nlinear sets always of first category (i.e. of first category on any\r\nperfect set), the set <span class=\"math inline\">\\(E_{1} \\times\r\nE_{2}\\)</span>. (i.e. the set of all points <span\r\nclass=\"math inline\">\\((x, y)\\)</span> of the plane where <span\r\nclass=\"math inline\">\\(x \\in E_{1}\\)</span> and <span\r\nclass=\"math inline\">\\(y \\in E_{2}\\)</span>) Is it of the same\r\nnature?</li>\r\n</ol>\r\n<p>Problem of M. E. Szpilrajn.</p>\r\n<ol start=\"69\" type=\"1\">\r\n<li>When a Jordan curve (in a three-dimensional space) has a determinate\r\ntangent at each point, does there necessarily exist a parametric\r\nrepresentation of this curve expressing the cartesian coordinates of a\r\npoint of this curve as functions which can be derived from a parameter (\r\nand this without the three derivatives canceling out at the same\r\ntime)?</li>\r\n</ol>\r\n<p>In the event of a negative answer, the question is asked again by\r\nadmitting a set of zero measurement values of the parameter where the\r\nimposed conditions are not both satisfied.</p>\r\n<p>Problem of M. M. Fr'echet.</p>\r\n<ol start=\"70\" type=\"1\">\r\n<li>Does there exist a linear set $ E$ such that each linear analytical\r\nset is a one-to-one and continuous (in one sense) image of <span\r\nclass=\"math inline\">\\(E\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"71\" type=\"1\">\r\n<li>Does there exist an infinite sequence <span\r\nclass=\"math inline\">\\(S\\)</span> of functions of a real variable\r\n(measurable or not), such that any function of a real variable of class\r\n<span class=\"math inline\">\\(2\\)</span> Baire is a limit of some sequence\r\nextracted from <span class=\"math inline\">\\(S\\)</span>?</li>\r\n</ol>\r\n<p>(According to M. C. Burstin such a sequence <span\r\nclass=\"math inline\">\\(S\\)</span> cannot be composed uniquely of\r\nmeasurable functions<a href=\"#fn4\" class=\"footnote-ref\" id=\"fnref4\"\r\nrole=\"doc-noteref\"><sup>4</sup></a>)</p>\r\n<p>Problem M. W. Sierpinski.</p>\r\n<ol start=\"72\" type=\"1\">\r\n<li>Does there exist in the <span\r\nclass=\"math inline\">\\(n\\)</span>-dimensional cart space (<span\r\nclass=\"math inline\">\\(n&gt;1\\)</span>) a set always of the first\r\ncategory ( i.e. of first category on each perfect set ) and which is of\r\npositive dimension?</li>\r\n</ol>\r\n<p>(M. W. Hurewicz demonstrated using the continuum hypothesis that\r\nthere exists in Hilbert space an uncountable set <span\r\nclass=\"math inline\">\\(H\\)</span> of which each uncountable subset is of\r\ninfinite dimension<a href=\"#fn5\" class=\"footnote-ref\" id=\"fnref5\"\r\nrole=\"doc-noteref\"><sup>5</sup></a>). M. F. Hausdorff noticed that the\r\nset <span class=\"math inline\">\\(H\\)</span> is always of the first\r\ncategory. This follows easily from the fact that each separable metric\r\nspace <span class=\"math inline\">\\(M\\)</span> is the sum of a set of\r\ndimension <span class=\"math inline\">\\(0\\)</span> and a set of first\r\ncategory in <span class=\"math inline\">\\(M\\)</span>. -- <em>There\r\ntherefore exists, if <span class=\"math inline\">\\(2^{\\aleph} =\r\n\\aleph_{1}\\)</span>, in Hilbert space a set always of first category and\r\nof positive dimension</em>).</p>\r\n<p>Probleme de M. E. Szpilrajn.</p>\r\n<ol start=\"73\" type=\"1\">\r\n<li>Let, in three-dimensional Euclidean space, <span\r\nclass=\"math inline\">\\(E\\)</span> be a homomorphic image of the solid\r\nsphere <span class=\"math inline\">\\(S\\)</span> and <span\r\nclass=\"math inline\">\\(L\\)</span> be a rectilinear segment whose interior\r\nis contained in the interior, and the ends in the border of <span\r\nclass=\"math inline\">\\(E\\)</span> . Does there still exist a\r\nhomeomorphism transforming <span class=\"math inline\">\\(E\\)</span> into\r\n<span class=\"math inline\">\\(S\\)</span> such that <span\r\nclass=\"math inline\">\\(L\\)</span> is transformed into the diameter of\r\n<span class=\"math inline\">\\(S\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. K. Borsuk.</p>\r\n<ol start=\"74\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(\\mathbf {B}(\\mathbf {F})\\)</span> be\r\nthe smallest family of sets containing the given family $ $ and closed\r\nwith respect to the operations <span\r\nclass=\"math inline\">\\(\\sigma\\)</span> and <span\r\nclass=\"math inline\">\\(\\delta\\)</span> (addition and multiplication of\r\ncountable values). Is there a family of enumerable <span\r\nclass=\"math inline\">\\(\\mathbf{D}\\)</span> of sets, such that all linear\r\nanalytic sets belong to <span class=\"math inline\">\\(\\mathbf\r\n{B}(\\mathbf{D})\\)</span> ?</li>\r\n</ol>\r\n<p>Problem of M. S. Ulam.</p>\r\n<ol start=\"75\" type=\"1\">\r\n<li>Is there an infinite set <span class=\"math inline\">\\(E\\)</span> (\r\ne.g. the set of all natural numbers) and a function <span\r\nclass=\"math inline\">\\(f(X)\\)</span> which maps to any subset <span\r\nclass=\"math inline\">\\(X\\)</span> of $E $ a subset <span\r\nclass=\"math inline\">\\(f(X)\\)</span> of <span\r\nclass=\"math inline\">\\(E\\)</span>, so that:</li>\r\n</ol>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(X \\subset f(X)\\)</span> for <span\r\nclass=\"math inline\">\\(X \\subset E\\)</span>,</li>\r\n<li><span class=\"math inline\">\\(f(X+Y) = f(X) + f(Y)\\)</span> for <span\r\nclass=\"math inline\">\\(X \\subset E\\)</span>, <span\r\nclass=\"math inline\">\\(Y \\subset E\\)</span>,</li>\r\n<li>there exists for every set <span class=\"math inline\">\\(Y \\subset\r\nE\\)</span> at least one set <span class=\"math inline\">\\(X \\subset\r\nE\\)</span>, such that <span class=\"math inline\">\\(Y =\r\nf(X)\\)</span>,</li>\r\n<li>there exists at least one set <span class=\"math inline\">\\(X_{0}\r\n\\subset E\\)</span>, such that <span class=\"math inline\">\\(f(X_{0}) \\neq\r\nX_{0}\\)</span>.</li>\r\n</ol>\r\n<p>If we replace the relative condition to <span\r\nclass=\"math inline\">\\(f(X+Y)\\)</span> by the condition weaker than <span\r\nclass=\"math inline\">\\(f(X) \\subset f(Y)\\)</span> pure <span\r\nclass=\"math inline\">\\(X \\subset Y \\subset E\\)</span>, the positive\r\nanswer is obvious.</p>\r\n<p>Problem of M. E . <span\r\nclass=\"math inline\">\\(\\check{\\text{C}}\\)</span>ech.</p>\r\n<h1 id=\"problems-resolved.\">Problems resolved.</h1>\r\n<p>Problem. 1) When a set of points <span\r\nclass=\"math inline\">\\(P\\)</span> is a one-to-one and continuous image\r\n(in a sense) of <span class=\"math inline\">\\(Q\\)</span> and <span\r\nclass=\"math inline\">\\(Q\\)</span> is a one-to-one and continuous image of\r\n<span class=\"math inline\">\\(P\\)</span>, can we affirm that the sets\r\n<span class=\"math inline\">\\(P\\)</span> and <span\r\nclass=\"math inline\">\\(Q\\)</span> are homomorphic?</p>\r\n<p><em>Negative</em> solution from M. Kuratowski, Fund. Math. t. II, pp.\r\n158-160</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>Is there a decomposition of an interval into <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> measurable sets (<span\r\nclass=\"math inline\">\\(B\\)</span>), each non-empty and any two of them\r\nwithout points in common?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from MM. Lusin and Sierpinski,\r\n<em>Comptes Rendus</em>, t. 175, p.357 (note of August 21, 1922).</p>\r\n<p>6, third part) Can it be shown that a product of <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> sets (<span\r\nclass=\"math inline\">\\(A\\)</span>) is not necessarily a set (<span\r\nclass=\"math inline\">\\(A\\)</span>)?</p>\r\n<p><em>Affirmative</em> solution from MM. Lusin and Sierpinski,\r\n<em>Journ, de Math</em>. 1923 (The authors define a set which is\r\ncomplementary to a set (<span class=\"math inline\">\\(A\\)</span>) is not\r\nnecessarily a set (<span class=\"math inline\">\\(A\\)</span>).)</p>\r\n<ol start=\"8\" type=\"1\">\r\n<li>Can we give an effective example of a set of real numbers <span\r\nclass=\"math inline\">\\(E\\)</span>, such as any sum, any difference, any\r\nproduct and any quotient of two numbers of <span\r\nclass=\"math inline\">\\(E\\)</span> (except' e division by 0) belongs to\r\n<span class=\"math inline\">\\(E_{1}\\)</span> and that <span\r\nclass=\"math inline\">\\(E\\)</span> is non-countable, distinct from the set\r\nof all real numbers?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from M. Souslin, <em>Fund. Math.</em>\r\nIV, p.311.</p>\r\n<p>10, first part) Is there a second class function which is not the\r\nlimit of almost everywhere discontinuous functions?</p>\r\n<p><em>Affirmative</em> solution from M. Zalcwasser.</p>\r\n<ol start=\"12\" type=\"1\">\r\n<li>Does an ordered set of which all well-ordered subsets (increasing or\r\ndecreasing) are at most enumerable necessarily have a power no greater\r\nthan that of the continuum?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from M. Urysohn, <em>Fund. Math.</em> V\r\n(to appear).</p>\r\n<ol start=\"15\" type=\"1\">\r\n<li>Is there a continuum of which any subcontinuum is\r\nindecomposable?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from M. Knaster, <em>Fund. Math.</em>\r\nIII pp. 247-286.</p>\r\n<ol start=\"16\" type=\"1\">\r\n<li>Does there exist a continuum which is a sum of its proper disjoint\r\nsaturated subcontinua?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution by M. Knaster and Kuratowski, <em>Fund.\r\nMath.</em> V (to appear).</p>\r\n<aside id=\"footnotes\" class=\"footnotes footnotes-end-of-document\"\r\nrole=\"doc-endnotes\">\r\n<hr />\r\n<ol>\r\n<li id=\"fn1\"><p>Accounts of the Soc. of Varsovic Sciences , t. VII,\r\np.382.<a href=\"#fnref1\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn2\"><p>Sitzungaber d. Bayer. Akad. d. Wiss., math.-phys. K1,\r\n1922, p. 223.<a href=\"#fnref2\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn3\"><p>See p. e. N. Lusin and W. Sierpinski <em>Journ. of\r\nMath.</em> t. II (1923) p. 60; also <em>Bull. Acad. Krakow</em> 1918 p.\r\n40.<a href=\"#fnref3\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn4\"><p>Monatshefte f. Math. u. Phys. 28 (1917), p. 107.<a\r\nhref=\"#fnref4\" class=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn5\"><p>Fund . Math. 19 (1932), p.8.<a href=\"#fnref5\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n</ol>\r\n</aside>\r\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"problems\">Problems</h1>\r\n<ol type=\"1\">\r\n<li>When a set of points <span class=\"math inline\">\\(P\\)</span> is a\r\none-to-one and continuous image (but not necessarily bi-continuous) of a\r\nset <span class=\"math inline\">\\(Q\\)</span> and when <span\r\nclass=\"math inline\">\\(Q\\)</span> is a one-to-one and continuous image of\r\n<span class=\"math inline\">\\(P\\)</span>? Are the sets <span\r\nclass=\"math inline\">\\(P\\)</span> and $Q $ necessarily homomorphic?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Is a (bounded) plane continuum, topologically homogeneous,\r\nnecessarily homomorphic to a circumference?</li>\r\n</ol>\r\n<p>(A set <span class=\"math inline\">\\(E\\)</span> is said to be\r\n<em>topologically homogeneous </em>, when there exists for any pair of\r\npoints <span class=\"math inline\">\\(a, b\\)</span> of <span\r\nclass=\"math inline\">\\(E\\)</span> a one-to-one and bi-continuous\r\ntransformation of <span class=\"math inline\">\\(E\\)</span> into itself\r\nwhich transforms <span class=\"math inline\">\\(a\\)</span> into <span\r\nclass=\"math inline\">\\(b\\)</span>)</p>\r\n<p>Problem of MM . B. Knaster and C. Kuratowski.</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>A set ordered (linearly) without jumps or gaps and such that any set\r\nof its intervals (containing more than one element) does not overlap\r\nwith each other is at most innumerable, is it necessarily a (ordinary)\r\nlinear continuum?</li>\r\n</ol>\r\n<p>Problem of M. M. Souslin.</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>Is there a decomposition of an interval into <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> (non-empty) sets without\r\ncommon points that are <span class=\"math inline\">\\(B\\)</span>\r\nmeasurable?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"5\" type=\"1\">\r\n<li>Does there exist an uncountable linear set <span\r\nclass=\"math inline\">\\(E\\)</span> such that every linear set homeomorphic\r\nto <span class=\"math inline\">\\(E\\)</span> has zero Lebesgue measure? Can\r\nwe prove the existence of such a set, even assuming that <span\r\nclass=\"math inline\">\\(2^{\\aleph_{0}} = \\aleph_{1}\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"6\" type=\"1\">\r\n<li>Can we find without the hypothesis of the continuum (<span\r\nclass=\"math inline\">\\(2^{\\aleph_{0}} = \\aleph_{1}\\)</span>) that a sum\r\nof <span class=\"math inline\">\\(\\aleph_{1}\\)</span> sets of zero Lebesgue\r\nmeasure is not necessarily zero Lebesgue measure? that a sum of $_{1} $\r\nsets of the first category is not necessarily of the first category?\r\nthat a product of <span class=\"math inline\">\\(\\aleph_{1}\\)</span> sets\r\n(<span class=\"math inline\">\\(A\\)</span>) is not necessarily a set <span\r\nclass=\"math inline\">\\(A\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"7\" type=\"1\">\r\n<li>Can we establish without the hypothesis of the continuum the\r\nexistence of a plane set which has zero (Lebesgue) measure on any\r\ndirection parallel to the abscissa axis and whose complement has zero\r\nmeasure on any direction parallel to the ordinate axis ?</li>\r\n</ol>\r\n<p>Problem of M. H. Steinhaus.</p>\r\n<ol start=\"8\" type=\"1\">\r\n<li>Can we give an effective example of a set of real numbers <span\r\nclass=\"math inline\">\\(E\\)</span> such that any sum, any difference, any\r\nproduct and any quotient of two numbers of <span\r\nclass=\"math inline\">\\(E\\)</span> (except division by 0) belongs to <span\r\nclass=\"math inline\">\\(E\\)</span> and that <span\r\nclass=\"math inline\">\\(E\\)</span> is uncountable , but distinct from the\r\nset of all real numbers ?</li>\r\n</ol>\r\n<p>Problem of M. S. Mazurkiewicz.</p>\r\n<ol start=\"9\" type=\"1\">\r\n<li>What is the power of sets complementary to sets (<span\r\nclass=\"math inline\">\\(A\\)</span>)?</li>\r\n</ol>\r\n<p>Problem of M. N. Lusin.</p>\r\n<p><em>Noticed</em>. The linear sets (<span\r\nclass=\"math inline\">\\(A\\)</span>) are orthogonal projections (on a line)\r\nof the measurable plane sets <span class=\"math inline\">\\(B\\)</span>. M.\r\nLusin demonstrated that the power of an uncountable set complementary to\r\na set (<span class=\"math inline\">\\(A\\)</span>) is <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> or <span\r\nclass=\"math inline\">\\(2^{\\aleph_{0}}\\)</span>, but we do not know if it\r\ncan really be <span class=\"math inline\">\\(\\aleph_{1}\\)</span> (in the\r\ncase where <span class=\"math inline\">\\(2^{\\aleph_{0}} &gt;\r\n\\aleph_{1}\\)</span>).</p>\r\n<ol start=\"10\" type=\"1\">\r\n<li>Does there exist a second class function that is not a limit of\r\nalmost everywhere continuous functions? Can we give an effective example\r\nof a function which is not a limit of piecewise continuous\r\nfunctions?</li>\r\n</ol>\r\n<p>Problem of MM . T. Feosztyn and W. Sierpinski.</p>\r\n<ol start=\"11\" type=\"1\">\r\n<li>Does there exist a class (<span\r\nclass=\"math inline\">\\(\\mathcal{L}\\)</span>) of M. Fr' echet (i.e. a\r\nclass in which the limit is defined) of power greater than the\r\ncontinuum, such that any uncountable set of elements of this class\r\ncontains at least one condensation element?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"12\" type=\"1\">\r\n<li>Does a (linearly) ordered set of which all well-ordered subsets\r\n(increasing and decreasing) are at most countable, necessarily have a\r\npower not greater than the continuum?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"13\" type=\"1\">\r\n<li>Does there exist a closed plane set which is not the sum of two\r\nclosed sets without common points, but which is a sum of a countable\r\nclosed sets without points in common.</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"14\" type=\"1\">\r\n<li>Does a continuum in <span\r\nclass=\"math inline\">\\(m\\)</span>-dimensional space which is homomorphic\r\nto any continuum contain necessarily a simple arc (i.e. image of an\r\none-to-one and continuous mapping of the interval <span\r\nclass=\"math inline\">\\((0,1)\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. Mazurkiewicz.</p>\r\n<ol start=\"15\" type=\"1\">\r\n<li>Does there exist a continuum of which every everything under\r\ncontinuous mapping is indecomposable? (A continuum is said to be\r\nindecomposable when it is not a sum of two continua different from\r\nit.)</li>\r\n</ol>\r\n<p>Problem of MM . Knaster and Kuratowski.</p>\r\n<ol start=\"16\" type=\"1\">\r\n<li>Does there exist a continuum (unbounded) which is a sum of its\r\nproper saturated sub-continuums where any two of them do not\r\nintersect?</li>\r\n</ol>\r\n<p>(We say that a real subcontinuum <span\r\nclass=\"math inline\">\\(K\\)</span> of <span\r\nclass=\"math inline\">\\(C\\)</span> is <em>saturated</em>, when there\r\nexists no continuum different from <span\r\nclass=\"math inline\">\\(K\\)</span> and <span\r\nclass=\"math inline\">\\(C\\)</span> which contains <span\r\nclass=\"math inline\">\\(K\\)</span> and which is contained in <span\r\nclass=\"math inline\">\\(C\\)</span>.)</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"17\" type=\"1\">\r\n<li>What is the power of the set of all values that a Baire class 1\r\nfunction does not take?</li>\r\n</ol>\r\n<p>(This problem is equivalent to problem 9 of M. Lusin, t . I. p.224.\r\nIt would be enough to solve this problem for functions admitting\r\nuncountable points of discontinuity.)</p>\r\n<ol start=\"18\" type=\"1\">\r\n<li>Is a (linear) set of power less than the continuum necessarily of\r\nthe first category of M. Baire?</li>\r\n</ol>\r\n<p>Problem of M. Ruziewicz.</p>\r\n<ol start=\"19\" type=\"1\">\r\n<li>Does there exist in each biconnected set <span\r\nclass=\"math inline\">\\(B\\)</span> a point <span\r\nclass=\"math inline\">\\(p\\)</span> such that the set <span\r\nclass=\"math inline\">\\(B - (p)\\)</span> contains no connected set?</li>\r\n</ol>\r\n<p><em>Noticed</em>. According to a theorem of M. Kline (this volume,\r\np.238), there cannot exist in a connected set <span\r\nclass=\"math inline\">\\(B\\)</span> more than one point <span\r\nclass=\"math inline\">\\(p\\)</span> enjoying the property in question. We\r\nknow, on the other hand, that, if such a point exists, the set <span\r\nclass=\"math inline\">\\(B\\)</span> is biconnected, i.e. it is not the sum\r\nof two disjoint connected sets containing more than one point (cf.\r\nKnaster and Kuratowski, * Fund . Math.* II, p, 214.)</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"20\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(f(E)\\)</span> be a function defined\r\nby any measurable (<span class=\"math inline\">\\(L\\)</span>) set <span\r\nclass=\"math inline\">\\(E\\)</span> of a Euclidean space of <span\r\nclass=\"math inline\">\\(m \\geq 3\\)</span> dimensions and satisfying the\r\nfollowing conditions:</li>\r\n</ol>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(f(E) \\geq 0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(f(E_{0}) = 1\\)</span> for a certain set\r\n<span class=\"math inline\">\\(E_{0}\\)</span> of measure 1.</li>\r\n<li><span class=\"math inline\">\\(f(E_{1} +E_{2}) = f(E_{1}) +\r\nf(E_{2})\\)</span>, if <span class=\"math inline\">\\(E_{1} E_{2} =\r\n0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(f(E_{1}) = f(E_{2})\\)</span>, if <span\r\nclass=\"math inline\">\\(E_{1}\\)</span> and <span\r\nclass=\"math inline\">\\(E_{2}\\)</span> are superimposable.</li>\r\n</ol>\r\n<p>Is the function <span class=\"math inline\">\\(f(E)\\)</span> necessarily\r\ncoincide with the Lebesgue measure of the set <span\r\nclass=\"math inline\">\\(E\\)</span>?</p>\r\n<p>(For <span class=\"math inline\">\\(m=1\\)</span> and <span\r\nclass=\"math inline\">\\(m=2\\)</span> the answer is negative, as M. Banach\r\nproved in a memoir which will be published in the volume IV of this\r\njournal.)</p>\r\n<p>Problem of M. Ruziewicz.</p>\r\n<ol start=\"21\" type=\"1\">\r\n<li>Given a set of real numbers which is not of the first category in\r\nany interval, is there a decomposition: <span class=\"math inline\">\\(A =\r\nB + C\\)</span>, <span class=\"math inline\">\\(B \\times C = 0\\)</span> such\r\nthat neither <span class=\"math inline\">\\(B\\)</span> nor <span\r\nclass=\"math inline\">\\(C\\)</span> are of the first category in any\r\ninterval?</li>\r\n</ol>\r\n<p><em>Noticed</em>. We could give the affirmative answer in the\r\nhypothesis additional that <span class=\"math inline\">\\(A\\)</span> has\r\nthe Baire property (in the sense established in this volume), p.319 . M.\r\nSierpinski also pointed out the affirmative answer in the hypothesis of\r\nthe continuum , <span class=\"math inline\">\\(\\aleph_{1} =\r\n2^{\\aleph_{0}}\\)</span>.</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"22\" type=\"1\">\r\n<li>Let us call the (linear) set $ E$ <em>perfectly measurable</em>, if\r\nevery set homomorphic to <span class=\"math inline\">\\(E\\)</span> is\r\nmeasurable in the sense of Lebesgue. What is the power of the class of\r\nperfectly measurable sets? Is a complementary set to a perf. measurable\r\nset always perf. measurable?</li>\r\n</ol>\r\n<p>Problem of M. Urysohn.</p>\r\n<ol start=\"23\" type=\"1\">\r\n<li>Does there exist a function of a real variable $ f(x)$ pantachically\r\ndicontinuous and such that we have for all real <span\r\nclass=\"math inline\">\\(x\\)</span></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\lim_{h \\to 0} \\frac{f( x+h ) -\r\nf(x-h)}{2h} = 0?\\]</span></p>\r\n<p>Problem of M. Steinhaus.</p>\r\n<ol start=\"24\" type=\"1\">\r\n<li>Is a function satisfying Baire's condition necessarily measurable\r\n(<span class=\"math inline\">\\(L\\)</span>)? What is the power of all the\r\nfunctions of a real variable satisfying the Baire condition? (We say\r\nthat a function <span class=\"math inline\">\\(f(x)\\)</span> satisfies the\r\nBaire condition, if it continues on any perfect set when we do not\r\nneglect the sets of the first category with respect to has that perfect\r\nset.)</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"25\" type=\"1\">\r\n<li>Can a plane set, such that any straight line meets it at two (and\r\nonly two) points, be measurable (<span\r\nclass=\"math inline\">\\(B\\)</span>)? (The existence of such a set has been\r\ndemonstrated , using M. Zermelos theorem, by MM. Mazurkiewicz<a\r\nhref=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\"\r\nrole=\"doc-noteref\"><sup>1</sup></a> (in 1914) and Rosenthal<a\r\nhref=\"#fn2\" class=\"footnote-ref\" id=\"fnref2\"\r\nrole=\"doc-noteref\"><sup>2</sup></a> (in 1922))</li>\r\n</ol>\r\n<ol start=\"26\" type=\"1\">\r\n<li>Is a class 3 function of M. Baire always a superposition of three\r\nclass 1 functions, that is to say, does it exist for any function <span\r\nclass=\"math inline\">\\(f(x)\\)</span> of class 3 three class 1 functions\r\n<span class=\"math inline\">\\(\\varphi (x)\\)</span>, <span\r\nclass=\"math inline\">\\(\\psi(x)\\)</span> and <span\r\nclass=\"math inline\">\\(\\vartheta(x)\\)</span>, such that we have for all\r\nreal <span class=\"math inline\">\\(x\\)</span></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[f(x) = \\varphi \\{\\psi[\\vartheta\r\n(x)]\\}\\]</span></p>\r\n<p>Problem of M. Lusin.</p>\r\n<ol start=\"27\" type=\"1\">\r\n<li>Is the set <span class=\"math inline\">\\(D(E)\\)</span> of the\r\ndistances of the points of a linear set <span\r\nclass=\"math inline\">\\(E\\)</span> that is (<span\r\nclass=\"math inline\">\\(B\\)</span>) measurable always (<span\r\nclass=\"math inline\">\\(B\\)</span>) measurable? (<span\r\nclass=\"math inline\">\\(D(E)\\)</span> is therefore the set of all numbers\r\n<span class=\"math inline\">\\(|x - y|\\)</span>, where <span\r\nclass=\"math inline\">\\(x\\)</span> and <span\r\nclass=\"math inline\">\\(y\\)</span> belong to <span\r\nclass=\"math inline\">\\(E\\)</span>. We can prove the existence of set\r\n<span class=\"math inline\">\\(E\\)</span> that are measurable (<span\r\nclass=\"math inline\">\\(L\\)</span>), such that <span\r\nclass=\"math inline\">\\(D(E)\\)</span> is non-measurable (<span\r\nclass=\"math inline\">\\(L\\)</span>).)</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"28\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(E\\)</span> is a (<span\r\nclass=\"math inline\">\\(B\\)</span> measurable) plane set, let us denote by\r\n<span class=\"math inline\">\\(N(E)\\)</span> the set of all real numbers $\r\na$, such that the line <span class=\"math inline\">\\(x = a\\)</span> meets\r\n<span class=\"math inline\">\\(E\\)</span> at a uncountable infinite number\r\nof points. Is the set <span class=\"math inline\">\\(N(E)\\)</span>\r\nnecessarily a set (<span class=\"math inline\">\\(A\\)</span>), or, more\r\nsimply, is it measurable ($ L $)? (It can be shown that the set of all\r\nreal numbers <span class=\"math inline\">\\(a\\)</span>, such that the line\r\n<span class=\"math inline\">\\(x = a\\)</span> meets the (<span\r\nclass=\"math inline\">\\(B\\)</span> measurable) set <span\r\nclass=\"math inline\">\\(E\\)</span> in an infinity number of points is\r\nalways a set <span class=\"math inline\">\\(A\\)</span>.)</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"29\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(F\\)</span> be a plane set, p. ex.\r\nclosed (or, more generally, measurable) - A point <span\r\nclass=\"math inline\">\\(x\\)</span> of <span\r\nclass=\"math inline\">\\(F\\)</span> will be said to be <em>linearly\r\naccessible </em> if there exists a rectilinear segment <span\r\nclass=\"math inline\">\\(\\overline{xp}\\)</span> such that all its points\r\n(except the point <span class=\"math inline\">\\(x\\)</span>) are outside\r\n<span class=\"math inline\">\\(F\\)</span>. Can it be shown that the set\r\n<span class=\"math inline\">\\(A\\)</span> of all linearly accessible points\r\nof <span class=\"math inline\">\\(F\\)</span> is always measurable (<span\r\nclass=\"math inline\">\\(L\\)</span>)?</li>\r\n</ol>\r\n<p>Problem of M. Urysohn.</p>\r\n<ol start=\"30\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(f(x)\\)</span> is an arbitrarily given\r\nfunction (measurable or not), what is the measure of the sum of all\r\npoints <span class=\"math inline\">\\(x\\)</span>, such that</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\lim \\limits_{h\\to 0} \\left |\\frac{f(\r\nx+h ) - f(x)}{h}\\right| = \\infty \\]</span></p>\r\n<p>Problem of M. Ruziewicz.</p>\r\n<ol start=\"31\" type=\"1\">\r\n<li>The theorem : \" <span class=\"math inline\">\\(\\mathsf{m} =\r\n2\\cdot\\mathsf{m}\\)</span> whatever the <em>transfinite</em> cardinal\r\nnumber <span class=\"math inline\">\\(\\mathsf {m}\\)</span>\" is it\r\nequivalent to <em>the axiom of choice</em>?</li>\r\n</ol>\r\n<p>Cf. my Note \"<em>On some themes which are equivalent to the axiom of\r\nchoice</em>\" in this volume, p. 147.</p>\r\n<p>Problem of M. Tajtelbaum-Tarski .</p>\r\n<ol start=\"32\" type=\"1\">\r\n<li>Is a closed plane set, where every point is linearly accessible,\r\nnecessarily of zero surface measure?</li>\r\n</ol>\r\n<p>Problem of M. Banach.</p>\r\n<p>A point <span class=\"math inline\">\\(x\\)</span> of <span\r\nclass=\"math inline\">\\(F\\)</span> is said to be linearly accessible if\r\nthere exists a rectilinear segment <span\r\nclass=\"math inline\">\\(\\overline{xp}\\)</span> such that all its points\r\n(except the point <span class=\"math inline\">\\(x\\)</span>) are outside\r\n<span class=\"math inline\">\\(F\\)</span>. M. Urysohn proved that the set\r\nof all linearly accessible points of a closed plane set is always a set\r\n(<span class=\"math inline\">\\(A\\)</span>) of M. Souslin, but may not be\r\nmeasurable (<span class=\"math inline\">\\(B\\)</span>). But we do not know\r\nif the set of all linearly accessible points of a plane set <span\r\nclass=\"math inline\">\\(G_{\\delta}\\)</span> is measurable (<span\r\nclass=\"math inline\">\\(L\\)</span>) (Cf. Problem 29 , * Fund . Math .* t.\r\nV, p. 337).</p>\r\n<ol start=\"33\" type=\"1\">\r\n<li>Is a one-to-one and continuous map (in one sense) of a set\r\ncomplementary to a set (<span class=\"math inline\">\\(A\\)</span>) of M.\r\nSouslin necessarily a homeomorphism?</li>\r\n</ol>\r\n<p>Problem of Sierpinski.</p>\r\n<ol start=\"34\" type=\"1\">\r\n<li>Let us call a (<span class=\"math inline\">\\(B\\)</span>) measurable\r\n(linear) set of class <span class=\"math inline\">\\(\\alpha\\)</span>\r\n<em>irreducible</em> if it is not of class <span\r\nclass=\"math inline\">\\(&lt;\\alpha\\)</span> in any interval. What is the\r\npower of the set of all topological types of irreducible sets of class\r\n<span class=\"math inline\">\\(\\alpha\\)</span>?</li>\r\n</ol>\r\n<p>Let us call a set (<span class=\"math inline\">\\(A\\)</span>)\r\n<em>irreducible</em>, if it is not (<span\r\nclass=\"math inline\">\\(B\\)</span>) measurable in any interval. What is\r\nthe power of all the topological types of the sets (<span\r\nclass=\"math inline\">\\(A\\)</span>) irreducible?</p>\r\n<p>Problem of MM . Alexandroff and Urysohn.</p>\r\n<ol start=\"35\" type=\"1\">\r\n<li>Let us call the (linear) set <span class=\"math inline\">\\(E\\)</span>\r\n<em>perfectly measurable in the narrow sense</em>, if every unambiguous\r\nand continuous image of <span class=\"math inline\">\\(E\\)</span> is\r\nmeasurable in the sense of Lebesgue. Is a set complementary to a set\r\nperfectly measurable in the narrow sense always a homeomorphic\r\nimage?</li>\r\n</ol>\r\n<p>Cf. Problem 22 of P. Urysohn ( <em>Fund. Math.</em> t. IV, p. 368),\r\nsolved by M. Lavrentieff (<em>Fund. Math.</em> t. VI, p. 159).</p>\r\n<p>Probleme de M. O. Nikodym.</p>\r\n<ol start=\"36\" type=\"1\">\r\n<li>According to M. Souslin, if <span class=\"math inline\">\\(E\\)</span>\r\nis a set (<span class=\"math inline\">\\(A\\)</span>) and <span\r\nclass=\"math inline\">\\(H\\)</span> a complementary set to a set (<span\r\nclass=\"math inline\">\\(A\\)</span>), and if <span class=\"math inline\">\\(E\r\n\\subset H\\)</span>, there exists a set <span\r\nclass=\"math inline\">\\(Q\\)</span>, (<span\r\nclass=\"math inline\">\\(B\\)</span>) measurable, such that <span\r\nclass=\"math inline\">\\(E\\ subset Q \\subset H\\)</span><a href=\"#fn3\"\r\nclass=\"footnote-ref\" id=\"fnref3\" role=\"doc-noteref\"><sup>3</sup></a>.\r\nDoes this proposition admit a reciprocal, that is to say, <em>if <span\r\nclass=\"math inline\">\\(E\\)</span> is a complementary set to a set (<span\r\nclass=\"math inline\">\\(A\\)</span>) and <span\r\nclass=\"math inline\">\\(H\\)</span> ------ does a set (<span\r\nclass=\"math inline\">\\(A\\)</span>), such that <span\r\nclass=\"math inline\">\\(E \\subset H\\)</span>, exist always a (<span\r\nclass=\"math inline\">\\(B\\)</span>) measurable set <span\r\nclass=\"math inline\">\\(Q\\)</span>, such that <span\r\nclass=\"math inline\">\\(E \\subset Q \\subset H\\)</span>?</em></li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"37\" type=\"1\">\r\n<li>Is a Jordan (bounded) continuum which contains only a simple closed\r\ncurve homomorphic to one of its (real) sub-continuums?</li>\r\n</ol>\r\n<p>Problem of M. Zarankiewicz.</p>\r\n<ol start=\"38\" type=\"1\">\r\n<li>Can a square and a circle whose areas are equal be decomposed into a\r\nfinite number of respectively congruent disjoint subsets?</li>\r\n</ol>\r\n<p>Problem of M. Tarski.</p>\r\n<ol start=\"39\" type=\"1\">\r\n<li>Does there exist a closed set <em>plane</em> for which the set of\r\nlinearly accessible points is non-measurable (<span\r\nclass=\"math inline\">\\(B\\)</span>)? (In space the problem is resolved in\r\nthe affirmative sense).</li>\r\n</ol>\r\n<p>Problem of M. O. Nikodym.</p>\r\n<ol start=\"40\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(E\\)</span> is a plane set <span\r\nclass=\"math inline\">\\(G_{\\delta}\\)</span>, is the set of all real\r\nnumbers <span class=\"math inline\">\\(a\\)</span>, such that the line <span\r\nclass=\"math inline\">\\(x =a\\)</span> meets the set <span\r\nclass=\"math inline\">\\(E\\)</span> in one and only one point, not\r\nnecessarily complementary to a set ($A $) of M. Souslin?</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"41\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(E_{1}, E_{2}, E_{3}, \\dots\\)</span>\r\nare a sequence of countable linear sets each of which is a projection of\r\na complete plane set complementary to a set (<span\r\nclass=\"math inline\">\\(A\\)</span>) of M. Souslin, is the set $E_{1}E_{2}\r\nE_{3} $ of the same nature?</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"42\" type=\"1\">\r\n<li>Does there exist in every continuum <span\r\nclass=\"math inline\">\\(A\\)</span> a continuum <span\r\nclass=\"math inline\">\\(B\\)</span> such that the set <span\r\nclass=\"math inline\">\\(AB\\)</span> is connected?</li>\r\n</ol>\r\n<p>Problem of MM . Knaster and Zarankiewicz .</p>\r\n<ol start=\"43\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(D\\)</span> denote a closed\r\nhomomorphic set of a plane set and located in 3-dimensional Euclidean\r\nspace, is every point of <span class=\"math inline\">\\(D\\)</span> is\r\n<em>accessible</em> in this space?</li>\r\n</ol>\r\n<p>(A point <span class=\"math inline\">\\(d\\)</span> of <span\r\nclass=\"math inline\">\\(D\\)</span> is said to be <em>accessible</em> in\r\n<span class=\"math inline\">\\(E\\)</span>, when there exists a continuum\r\n<span class=\"math inline\">\\(C \\subset E\\)</span> such that <span\r\nclass=\"math inline\">\\((d) = CD\\)</span>).</p>\r\n<p>Problem of M. Knaster.</p>\r\n<ol start=\"46\" type=\"1\">\r\n<li>It is asked to set up the logical relations between the various\r\nconcepts of homogeneity, in so far as they refer to small compact sets.\r\nIn particular, even if the sets are considered to be connected and (or)\r\nconnected in the small be assumed.</li>\r\n</ol>\r\n<p>(See D. van Dantzig , \"On topologically homogeneous continua, volume\r\n15, pp. 102, 103).</p>\r\n<p>Problem of M. van Dantzig .</p>\r\n<ol start=\"47\" type=\"1\">\r\n<li>Is every (connected, unbounded) <span\r\nclass=\"math inline\">\\(n\\)</span>-dimensional manifold involutory\r\nhomogeneous?</li>\r\n</ol>\r\n<p>(Cf. D. van Dantzig , le p. 104, ^7.)</p>\r\n<p>Problem of M. van Dantzig.</p>\r\n<ol start=\"48\" type=\"1\">\r\n<li>Let us call a topological group <em>monothetic</em> if an infinite\r\ncyclic group is dense in it (in which case it is commutative and can be\r\nwritten additively), and <em>complete</em> if every sequence $x_{} $,\r\nwhich satisfies the Cauchy's convergence criterion <span\r\nclass=\"math inline\">\\(\\lim (x_{\\nu} - x_{\\mu } = 0\\)</span> has a limit\r\nelement in the group, the question is whether a monothetic group can be\r\ncomplete without being compact.</li>\r\n</ol>\r\n<p>(See lc p. 116 ^{29}a))</p>\r\n<p>Problem of M. van Dantzig .</p>\r\n<ol start=\"49\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(X\\)</span> and <span\r\nclass=\"math inline\">\\(Y\\)</span> be two Peano continua (= continuous\r\nimages of the interval) and <span class=\"math inline\">\\(Z\\)</span> be\r\ntheir topological product (= the space of all pairs $z = (x,y) $ or\r\n<span class=\"math inline\">\\(\\lim z_{n}=z\\)</span> when <span\r\nclass=\"math inline\">\\(\\lim x_{n} = x\\)</span> and <span\r\nclass=\"math inline\">\\(\\lim y_{n} = y\\)</span>).</li>\r\n</ol>\r\n<p>1^0. If the continuum <span class=\"math inline\">\\(X\\)</span>, as well\r\nas <span class=\"math inline\">\\(Y\\)</span>, has the property that in each\r\ncontinuous transformation of this continuum into a subset there exists\r\nan invariant point, is it true that <span\r\nclass=\"math inline\">\\(Z\\)</span> has the same property?</p>\r\n<p>2^0. If the continuum <span class=\"math inline\">\\(X\\)</span>, as well\r\nas <span class=\"math inline\">\\(Y\\)</span>, is uni-consistent (= in each\r\ndecomposition of this continuum into two sub-continuums the common part\r\nof these sub-continuums is connected), is it true that <span\r\nclass=\"math inline\">\\(Z\\)</span> is uni-coherent?</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"50\" type=\"1\">\r\n<li>Is the topological circle the only homogeneous small connected\r\ncurve? (Curve = one-dimensional connected compact space. A space is\r\ncalled homogeneous, if for each of its two points <span\r\nclass=\"math inline\">\\(p\\)</span> and <span\r\nclass=\"math inline\">\\(q\\)</span> there exist a homeomorphism which sends\r\n<span class=\"math inline\">\\(p\\)</span> to <span\r\nclass=\"math inline\">\\(q\\)</span> ). On the plane, the circle is the only\r\nsmall, homogeneous curve.</li>\r\n</ol>\r\n<p>(Cf. Mazurkiewicz, Fund. Math. V, p. 137).</p>\r\n<p>Problem with M. K. Menger.</p>\r\n<ol start=\"51\" type=\"1\">\r\n<li>Are there any or even an infinite number of compact one-dimensional\r\nspaces any two of which are incomparable in one dimension? Two spaces\r\n<span class=\"math inline\">\\(R\\)</span> and <span\r\nclass=\"math inline\">\\(R^{\\prime}\\)</span> may be called\r\none-dimensionally incomparable , if no one-dimensional subset of <span\r\nclass=\"math inline\">\\(R\\)</span>, (or of <span\r\nclass=\"math inline\">\\(R^{\\prime}\\)</span>) is homomorphic with a subset\r\nof <span class=\"math inline\">\\(R^{\\prime}\\)</span> (or of <span\r\nclass=\"math inline\">\\(R^{\\prime}\\)</span>). For example, a line and a\r\ncontinuum without partial arcs are incomparable in one dimension. (If\r\nthere are <span class=\"math inline\">\\(n\\)</span>, or <span\r\nclass=\"math inline\">\\(\\aleph_{0}\\)</span> in pairs of one-dimensionally\r\nincomparable curves, then there exist compact one-dimensional spaces\r\nwhich contains at least <span class=\"math inline\">\\(2^{n} +1\\)</span>,\r\nor <span class=\"math inline\">\\(2^{\\aleph _{0}}\\)</span> monotone, <span\r\nclass=\"math inline\">\\(F_{\\sigma }\\)</span>-additive, topological,\r\ncompactifiable systems of subsets).</li>\r\n</ol>\r\n<p>(See Monthly Issues f. Math. and Phys. 36, p. 207).</p>\r\n<p>Problem of M. K. Menger.</p>\r\n<ol start=\"52\" type=\"1\">\r\n<li>Does there exist a continuum of which every other continuum is a\r\ncontinuous image?</li>\r\n</ol>\r\n<p>Problem of M. H. Hahn.</p>\r\n<ol start=\"53\" type=\"1\">\r\n<li><ol type=\"a\">\r\n<li>Can every absolute retract be decomposed into a finite number of\r\nabsolute retracts with arbitrarily small diameters?</li>\r\n</ol></li>\r\n</ol>\r\n<ol start=\"2\" type=\"a\">\r\n<li>Let every <span class=\"math inline\">\\(R\\)</span> set be decomposed\r\ninto a finite number of absolute retracts?</li>\r\n</ol>\r\n<p>(The definition of absolute retracts and <span\r\nclass=\"math inline\">\\(R\\)</span> sets is given, for example, in Fund.\r\nMath. XIX, p. 222).</p>\r\n<ol start=\"54\" type=\"1\">\r\n<li><p>Is every partial continuum <span class=\"math inline\">\\(C\\)</span>\r\nof the Euclidean <span class=\"math inline\">\\(n\\)</span>-dimensional\r\nspace <span class=\"math inline\">\\(R_{n}\\)</span>, which intersects <span\r\nclass=\"math inline\">\\(R_{n}\\)</span> and which is transferred by\r\narbitrarily small transformations (i.e. by a continuous mapping which\r\nsends every point from <span class=\"math inline\">\\(C\\)</span> to an\r\narbitrarily close point of <span class=\"math inline\">\\(R_{n}\\)</span>)\r\ninto a subset of <span class=\"math inline\">\\(R_{n}\\)</span> that is\r\nforeign to it, a (<span class=\"math inline\">\\(n-1\\)</span>) dimensional\r\nspace?</p></li>\r\n<li><p>Can every route image lying in <span\r\nclass=\"math inline\">\\(R_{3}\\)</span> and intersecting <span\r\nclass=\"math inline\">\\(R_{3}\\)</span> be mapped continuously without\r\nfixed points?</p></li>\r\n</ol>\r\n<p>Problem of M. K. Borsuk.</p>\r\n<ol start=\"56\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(A\\)</span> and <span\r\nclass=\"math inline\">\\(B\\)</span> be two topological spaces and <span\r\nclass=\"math inline\">\\(A^{2}\\)</span> and <span\r\nclass=\"math inline\">\\(B^{2}\\)</span> respectively their squares (a. `ad\r\n<span class=\"math inline\">\\(A^{2}\\)</span> p . ex. consists of all your\r\npairs (<span class=\"math inline\">\\(a_{1}\\)</span>, <span\r\nclass=\"math inline\">\\(a_{2}\\)</span>) extracted from <span\r\nclass=\"math inline\">\\(A\\)</span>).</li>\r\n</ol>\r\n<p>Is it true that if <span class=\"math inline\">\\(A^{2}\\)</span> and\r\n<span class=\"math inline\">\\(B^{2}\\)</span> are homeomorphic, are <span\r\nclass=\"math inline\">\\(A\\)</span> and <span\r\nclass=\"math inline\">\\(B\\)</span> too?</p>\r\n<p>In case of a positive answer , we deduce that, if <span\r\nclass=\"math inline\">\\(C\\)</span> is a set which is not homeomorphic to\r\nnone of <span class=\"math inline\">\\(C^{n}\\)</span>, <span\r\nclass=\"math inline\">\\(n&gt;1\\)</span>, the sets <span\r\nclass=\"math inline\">\\(C^{m}\\)</span> and <span\r\nclass=\"math inline\">\\(C^{n}\\)</span> are neither homeomorphic for <span\r\nclass=\"math inline\">\\(m \\neq n\\)</span>; this provides in the case where\r\n<span class=\"math inline\">\\(C\\)</span> is an interval of the theorem of\r\n\"invariance of the dimension\" of M. Brouwer .</p>\r\n<p>Problem of M. S. Ulam.</p>\r\n<ol start=\"57\" type=\"1\">\r\n<li>Does there exist an infinite-dimensional continuum that does not\r\ncontain any finite-dimensional continuum?</li>\r\n</ol>\r\n<p>Problems of M. S. Mazurkiewicz.</p>\r\n<ol start=\"58\" type=\"1\">\r\n<li>Does there exist in a set <span class=\"math inline\">\\(E\\)</span> of\r\nsize <span class=\"math inline\">\\(\\aleph_{1}\\)</span> a countable system\r\nof subsets <span class=\"math inline\">\\(A_{1}, A_{2},\\dots\\)</span> such\r\nthat one has the form <span class=\"math display\">\\[X = \\overline{\\lim}\r\nA_{p_{n}}\\]</span> where (<span class=\"math inline\">\\(p_{1},\r\np_{2},,\\dots\\)</span> is a subsequence of the natural numbers, <span\r\nclass=\"math inline\">\\(\\overline{\\lim}\\)</span> means the Borel\r\n<em>complete limit set</em>) all subsets <span\r\nclass=\"math inline\">\\(X\\)</span> received from <span\r\nclass=\"math inline\">\\(E\\)</span>?</li>\r\n</ol>\r\n<p>(It is a question of proving the negation without using the continuum\r\nhypothesis).</p>\r\n<p>Problems with M. F. Hausdorff. _</p>\r\n<ol start=\"59\" type=\"1\">\r\n<li>A function with the Baire property (i.e. continuous on any perfect\r\nset, when we neglect a set of <span\r\nclass=\"math inline\">\\(1^{re}\\)</span> category relative to this set) of\r\na function with the Baire property, is it of the same nature?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"60\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(\\rho\\)</span> be the set of all\r\nhomeomorphic transformations of the cartesian plane in itself, of the\r\nform: <span class=\"math display\">\\[x^{\\prime} = x, \\quad y^{\\prime} =f(\r\nx,y )\\]</span> and <span class=\"math display\">\\[x^{\\prime}=g( x,y ),\r\n\\quad    y^{\\prime}=y.\\]</span></li>\r\n</ol>\r\n<p>Let us denote by <span class=\"math inline\">\\(\\sigma\\)</span> the\r\ngroup formed by all the finite superpositions of all the transformations\r\nbelonging to <span class=\"math inline\">\\(\\rho\\)</span>. Can an arbitrary\r\nhomeomorphic transformation of the plane in itself always be approached\r\nby those of the group <span class=\"math inline\">\\(\\sigma\\)</span> ?</p>\r\n<p>An analogous problem remains for <span\r\nclass=\"math inline\">\\(n&gt;2\\)</span> dimensional spaces. Problem of\r\nM.S. Ulam.</p>\r\n<ol start=\"61\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(E\\)</span> be a <span\r\nclass=\"math inline\">\\(G_{\\delta}\\)</span> plane set (more generally: a\r\nBorel set) all of whose intersections with the lines parallel to the\r\n<span class=\"math inline\">\\(y\\)</span> axis are closed sets (more\r\ngenerally: <span class=\"math inline\">\\(F_{\\sigma}\\)</span>). Is the\r\nprojection of <span class=\"math inline\">\\(E\\)</span> on the <span\r\nclass=\"math inline\">\\(x\\)</span> axis always a Borel set?</li>\r\n</ol>\r\n<p>Problem of ME Szpilrajsn.</p>\r\n<ol start=\"62\" type=\"1\">\r\n<li>The (real) function <span class=\"math inline\">\\(f(x)\\)</span> of the\r\nreal variable <span class=\"math inline\">\\(x\\)</span> is called\r\n<em>symmetric-continuous</em> if for every <span\r\nclass=\"math inline\">\\(x\\)</span> <span class=\"math display\">\\[\\lim\r\n\\limits_{h \\to 0} [f( x+h ) - f(x - h)] = 0.\\]</span> Can the set of\r\ndiscontinuities of such a function be uncountable? Can it be an\r\narbitrarily prescribed set <span\r\nclass=\"math inline\">\\(F_{\\sigma}\\)</span>? (That they are an arbitrarily\r\nprescribed countable set is easy to see.)</li>\r\n</ol>\r\n<p>Problem of M. F. Hausdorff.</p>\r\n<ol start=\"63\" type=\"1\">\r\n<li>Two compact spaces <span class=\"math inline\">\\(A\\)</span> and <span\r\nclass=\"math inline\">\\(B\\)</span> have the <em>same homotopy type</em>,\r\nwhen there exists a continuous transformation <span\r\nclass=\"math inline\">\\(f\\)</span> from <span\r\nclass=\"math inline\">\\(A\\)</span> to <span\r\nclass=\"math inline\">\\(B\\)</span> and a continuous transformation <span\r\nclass=\"math inline\">\\(\\varphi\\)</span> from <span\r\nclass=\"math inline\">\\(B\\)</span> to <span\r\nclass=\"math inline\">\\(A\\)</span>, such as the superpositions <span\r\nclass=\"math inline\">\\(\\ varphi f\\)</span> and $f$ (consider respectively\r\nas transformations of <span class=\"math inline\">\\(A\\)</span> into <span\r\nclass=\"math inline\">\\(A\\)</span> and of <span\r\nclass=\"math inline\">\\(B\\)</span> into <span\r\nclass=\"math inline\">\\(B\\)</span>) are homotopic to the identity . Are\r\ntwo closed varieties of the same homotopy type always homomorphic?</li>\r\n</ol>\r\n<p>Problem of M. W. Hurewicz.</p>\r\n<ol start=\"64\" type=\"1\">\r\n<li><p>Do there exist two in <span class=\"math inline\">\\(R^{n}\\)</span>\r\norientable Manifolds <span class=\"math inline\">\\(M_{1}^{k}\\)</span> and\r\n<span class=\"math inline\">\\(M_{2}^{k}\\)</span>, whose Complementary\r\n<span class=\"math inline\">\\(R^{n} - M_{1}^{k}\\)</span> and <span\r\nclass=\"math inline\">\\(R^{n} - M_{2}^{k}\\)</span> are homomorphic and\r\nwhose Homology rings are not isomorphic?</p></li>\r\n<li><p>Let <span class=\"math inline\">\\(B_{0}, B_{1}, B_{2}, \\dots,\r\nB_{\\omega}, \\dots, B_{\\alpha}, \\dots\\)</span> be Borel classes of sets,\r\nformed in starting from any class of abstract sets. We know that <span\r\nclass=\"math inline\">\\(B_{\\alpha} = B_{\\alpha+}\\)</span>. results in\r\n<span class=\"math inline\">\\(B_{\\alpha}= B_{\\beta}\\)</span> for all <span\r\nclass=\"math inline\">\\(\\beta&gt;\\alpha\\)</span>; let <span\r\nclass=\"math inline\">\\(\\alpha_{0}\\)</span> be the first number <span\r\nclass=\"math inline\">\\(\\alpha\\)</span> satisfying this condition. What\r\nare the numbers <span class=\"math inline\">\\(v\\)</span> for which there\r\nexist classes <span class=\"math inline\">\\(B_{0}\\)</span> such that we\r\nhave <span class=\"math inline\">\\(\\alpha_{0} = v\\)</span>? (Cf. Fund.\r\nMath. t. XV, p. 284).</p></li>\r\n</ol>\r\n<p>Problem of M. A. Kolmogoroff.</p>\r\n<ol start=\"66\" type=\"1\">\r\n<li>Does the <em>weak</em> <span class=\"math inline\">\\(LC\\)</span>\r\nproperty entail the strong <span class=\"math inline\">\\(LC\\)</span>\r\nproperty for any compact metric space ? Same question for <span\r\nclass=\"math inline\">\\(HLC\\)</span> properties . (For definitions see\r\nAnnals of Mathematics , vol. 85, p. 119-129 and Duke Mathematical\r\nJournal, vol . 1, p. 1-18).</li>\r\n</ol>\r\n<p>Problem of M. S. Lefschetz.</p>\r\n<ol start=\"67\" type=\"1\">\r\n<li>Is the property (<span class=\"math inline\">\\(C\\)</span>) of linear\r\nsets invariant with respect to homomorphic transformations and, more\r\ngenerally, with respect to continuous transformations? (We say that a\r\nset <span class=\"math inline\">\\(E\\)</span> has the <em>property (<span\r\nclass=\"math inline\">\\(C\\)</span>)</em>, when there exists for each\r\nsequence <span class=\"math inline\">\\(\\{a_{n}\\}\\)</span> of positive\r\nnumbers a decomposition $E=E_{1}+E_{2} + $ such that the diameter of\r\n<span class=\"math inline\">\\(E_{n}\\)</span> does not exceed $ a_{n}$ for\r\n<span class=\"math inline\">\\(n= 1, 2,\\dots\\)</span>. Cf. Fund. Math,\r\nvolume XI, p. 304; volume XV, p. 126; volume XXII, p. 310.)</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"68\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(E_{1}\\)</span> and $ E_{2}$ are two\r\nlinear sets always of first category (i.e. of first category on any\r\nperfect set), the set <span class=\"math inline\">\\(E_{1} \\times\r\nE_{2}\\)</span>. (i.e. the set of all points <span\r\nclass=\"math inline\">\\((x, y)\\)</span> of the plane where <span\r\nclass=\"math inline\">\\(x \\in E_{1}\\)</span> and <span\r\nclass=\"math inline\">\\(y \\in E_{2}\\)</span>) Is it of the same\r\nnature?</li>\r\n</ol>\r\n<p>Problem of M. E. Szpilrajn.</p>\r\n<ol start=\"69\" type=\"1\">\r\n<li>When a Jordan curve (in a three-dimensional space) has a determinate\r\ntangent at each point, does there necessarily exist a parametric\r\nrepresentation of this curve expressing the cartesian coordinates of a\r\npoint of this curve as functions which can be derived from a parameter (\r\nand this without the three derivatives canceling out at the same\r\ntime)?</li>\r\n</ol>\r\n<p>In the event of a negative answer, the question is asked again by\r\nadmitting a set of zero measurement values of the parameter where the\r\nimposed conditions are not both satisfied.</p>\r\n<p>Problem of M. M. Fr'echet.</p>\r\n<ol start=\"70\" type=\"1\">\r\n<li>Does there exist a linear set $ E$ such that each linear analytical\r\nset is a one-to-one and continuous (in one sense) image of <span\r\nclass=\"math inline\">\\(E\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"71\" type=\"1\">\r\n<li>Does there exist an infinite sequence <span\r\nclass=\"math inline\">\\(S\\)</span> of functions of a real variable\r\n(measurable or not), such that any function of a real variable of class\r\n<span class=\"math inline\">\\(2\\)</span> Baire is a limit of some sequence\r\nextracted from <span class=\"math inline\">\\(S\\)</span>?</li>\r\n</ol>\r\n<p>(According to M. C. Burstin such a sequence <span\r\nclass=\"math inline\">\\(S\\)</span> cannot be composed uniquely of\r\nmeasurable functions<a href=\"#fn4\" class=\"footnote-ref\" id=\"fnref4\"\r\nrole=\"doc-noteref\"><sup>4</sup></a>)</p>\r\n<p>Problem M. W. Sierpinski.</p>\r\n<ol start=\"72\" type=\"1\">\r\n<li>Does there exist in the <span\r\nclass=\"math inline\">\\(n\\)</span>-dimensional cart space (<span\r\nclass=\"math inline\">\\(n&gt;1\\)</span>) a set always of the first\r\ncategory ( i.e. of first category on each perfect set ) and which is of\r\npositive dimension?</li>\r\n</ol>\r\n<p>(M. W. Hurewicz demonstrated using the continuum hypothesis that\r\nthere exists in Hilbert space an uncountable set <span\r\nclass=\"math inline\">\\(H\\)</span> of which each uncountable subset is of\r\ninfinite dimension<a href=\"#fn5\" class=\"footnote-ref\" id=\"fnref5\"\r\nrole=\"doc-noteref\"><sup>5</sup></a>). M. F. Hausdorff noticed that the\r\nset <span class=\"math inline\">\\(H\\)</span> is always of the first\r\ncategory. This follows easily from the fact that each separable metric\r\nspace <span class=\"math inline\">\\(M\\)</span> is the sum of a set of\r\ndimension <span class=\"math inline\">\\(0\\)</span> and a set of first\r\ncategory in <span class=\"math inline\">\\(M\\)</span>. -- <em>There\r\ntherefore exists, if <span class=\"math inline\">\\(2^{\\aleph} =\r\n\\aleph_{1}\\)</span>, in Hilbert space a set always of first category and\r\nof positive dimension</em>).</p>\r\n<p>Probleme de M. E. Szpilrajn.</p>\r\n<ol start=\"73\" type=\"1\">\r\n<li>Let, in three-dimensional Euclidean space, <span\r\nclass=\"math inline\">\\(E\\)</span> be a homomorphic image of the solid\r\nsphere <span class=\"math inline\">\\(S\\)</span> and <span\r\nclass=\"math inline\">\\(L\\)</span> be a rectilinear segment whose interior\r\nis contained in the interior, and the ends in the border of <span\r\nclass=\"math inline\">\\(E\\)</span> . Does there still exist a\r\nhomeomorphism transforming <span class=\"math inline\">\\(E\\)</span> into\r\n<span class=\"math inline\">\\(S\\)</span> such that <span\r\nclass=\"math inline\">\\(L\\)</span> is transformed into the diameter of\r\n<span class=\"math inline\">\\(S\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. K. Borsuk.</p>\r\n<ol start=\"74\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(\\mathbf {B}(\\mathbf {F})\\)</span> be\r\nthe smallest family of sets containing the given family $ $ and closed\r\nwith respect to the operations <span\r\nclass=\"math inline\">\\(\\sigma\\)</span> and <span\r\nclass=\"math inline\">\\(\\delta\\)</span> (addition and multiplication of\r\ncountable values). Is there a family of enumerable <span\r\nclass=\"math inline\">\\(\\mathbf{D}\\)</span> of sets, such that all linear\r\nanalytic sets belong to <span class=\"math inline\">\\(\\mathbf\r\n{B}(\\mathbf{D})\\)</span> ?</li>\r\n</ol>\r\n<p>Problem of M. S. Ulam.</p>\r\n<ol start=\"75\" type=\"1\">\r\n<li>Is there an infinite set <span class=\"math inline\">\\(E\\)</span> (\r\ne.g. the set of all natural numbers) and a function <span\r\nclass=\"math inline\">\\(f(X)\\)</span> which maps to any subset <span\r\nclass=\"math inline\">\\(X\\)</span> of $E $ a subset <span\r\nclass=\"math inline\">\\(f(X)\\)</span> of <span\r\nclass=\"math inline\">\\(E\\)</span>, so that:</li>\r\n</ol>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(X \\subset f(X)\\)</span> for <span\r\nclass=\"math inline\">\\(X \\subset E\\)</span>,</li>\r\n<li><span class=\"math inline\">\\(f(X+Y) = f(X) + f(Y)\\)</span> for <span\r\nclass=\"math inline\">\\(X \\subset E\\)</span>, <span\r\nclass=\"math inline\">\\(Y \\subset E\\)</span>,</li>\r\n<li>there exists for every set <span class=\"math inline\">\\(Y \\subset\r\nE\\)</span> at least one set <span class=\"math inline\">\\(X \\subset\r\nE\\)</span>, such that <span class=\"math inline\">\\(Y =\r\nf(X)\\)</span>,</li>\r\n<li>there exists at least one set <span class=\"math inline\">\\(X_{0}\r\n\\subset E\\)</span>, such that <span class=\"math inline\">\\(f(X_{0}) \\neq\r\nX_{0}\\)</span>.</li>\r\n</ol>\r\n<p>If we replace the relative condition to <span\r\nclass=\"math inline\">\\(f(X+Y)\\)</span> by the condition weaker than <span\r\nclass=\"math inline\">\\(f(X) \\subset f(Y)\\)</span> pure <span\r\nclass=\"math inline\">\\(X \\subset Y \\subset E\\)</span>, the positive\r\nanswer is obvious.</p>\r\n<p>Problem of M. E . <span\r\nclass=\"math inline\">\\(\\check{\\text{C}}\\)</span>ech.</p>\r\n<h1 id=\"problems-resolved.\">Problems resolved.</h1>\r\n<p>Problem. 1) When a set of points <span\r\nclass=\"math inline\">\\(P\\)</span> is a one-to-one and continuous image\r\n(in a sense) of <span class=\"math inline\">\\(Q\\)</span> and <span\r\nclass=\"math inline\">\\(Q\\)</span> is a one-to-one and continuous image of\r\n<span class=\"math inline\">\\(P\\)</span>, can we affirm that the sets\r\n<span class=\"math inline\">\\(P\\)</span> and <span\r\nclass=\"math inline\">\\(Q\\)</span> are homomorphic?</p>\r\n<p><em>Negative</em> solution from M. Kuratowski, Fund. Math. t. II, pp.\r\n158-160</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>Is there a decomposition of an interval into <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> measurable sets (<span\r\nclass=\"math inline\">\\(B\\)</span>), each non-empty and any two of them\r\nwithout points in common?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from MM. Lusin and Sierpinski,\r\n<em>Comptes Rendus</em>, t. 175, p.357 (note of August 21, 1922).</p>\r\n<p>6, third part) Can it be shown that a product of <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> sets (<span\r\nclass=\"math inline\">\\(A\\)</span>) is not necessarily a set (<span\r\nclass=\"math inline\">\\(A\\)</span>)?</p>\r\n<p><em>Affirmative</em> solution from MM. Lusin and Sierpinski,\r\n<em>Journ, de Math</em>. 1923 (The authors define a set which is\r\ncomplementary to a set (<span class=\"math inline\">\\(A\\)</span>) is not\r\nnecessarily a set (<span class=\"math inline\">\\(A\\)</span>).)</p>\r\n<ol start=\"8\" type=\"1\">\r\n<li>Can we give an effective example of a set of real numbers <span\r\nclass=\"math inline\">\\(E\\)</span>, such as any sum, any difference, any\r\nproduct and any quotient of two numbers of <span\r\nclass=\"math inline\">\\(E\\)</span> (except' e division by 0) belongs to\r\n<span class=\"math inline\">\\(E_{1}\\)</span> and that <span\r\nclass=\"math inline\">\\(E\\)</span> is non-countable, distinct from the set\r\nof all real numbers?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from M. Souslin, <em>Fund. Math.</em>\r\nIV, p.311.</p>\r\n<p>10, first part) Is there a second class function which is not the\r\nlimit of almost everywhere discontinuous functions?</p>\r\n<p><em>Affirmative</em> solution from M. Zalcwasser.</p>\r\n<ol start=\"12\" type=\"1\">\r\n<li>Does an ordered set of which all well-ordered subsets (increasing or\r\ndecreasing) are at most enumerable necessarily have a power no greater\r\nthan that of the continuum?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from M. Urysohn, <em>Fund. Math.</em> V\r\n(to appear).</p>\r\n<ol start=\"15\" type=\"1\">\r\n<li>Is there a continuum of which any subcontinuum is\r\nindecomposable?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from M. Knaster, <em>Fund. Math.</em>\r\nIII pp. 247-286.</p>\r\n<ol start=\"16\" type=\"1\">\r\n<li>Does there exist a continuum which is a sum of its proper disjoint\r\nsaturated subcontinua?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution by M. Knaster and Kuratowski, <em>Fund.\r\nMath.</em> V (to appear).</p>\r\n<aside id=\"footnotes\" class=\"footnotes footnotes-end-of-document\"\r\nrole=\"doc-endnotes\">\r\n<hr />\r\n<ol>\r\n<li id=\"fn1\"><p>Accounts of the Soc. of Varsovic Sciences , t. VII,\r\np.382.<a href=\"#fnref1\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn2\"><p>Sitzungaber d. Bayer. Akad. d. Wiss., math.-phys. K1,\r\n1922, p. 223.<a href=\"#fnref2\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn3\"><p>See p. e. N. Lusin and W. Sierpinski <em>Journ. of\r\nMath.</em> t. II (1923) p. 60; also <em>Bull. Acad. Krakow</em> 1918 p.\r\n40.<a href=\"#fnref3\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn4\"><p>Monatshefte f. Math. u. Phys. 28 (1917), p. 107.<a\r\nhref=\"#fnref4\" class=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn5\"><p>Fund . Math. 19 (1932), p.8.<a href=\"#fnref5\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n</ol>\r\n</aside>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Dec 31 2023 15:44:40 GMT+0800 ()","title":"75 Problems in the Foundation of Mathematics","path":"2023/09/22/75 Problems/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-09-22T14:10:39.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-09-22T14:10:39.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Set Theory","tags":["Set Theory"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Nowicki Conjecture","date":"2023-04-11T08:28:25.000Z","mathjax":true,"_content":"\n\nLet $A[\\mathbf{x}] = A[x_{1}, \\cdots, x_{n}$] be the polynomial ring in n variables over an integral domain $A$, $D$ an $A$-[derivation](https://en.wikipedia.org/wiki/Derivation_(differential_algebra)) of $A[\\mathbf{x}]$ and denote \n$$L^{D}_{ij} := D(x_{i}) x_{j} - D(x_{j}) x_{i}, \\quad \\text{ for each } i, j \\in \\{1, \\cdots, n\\}.$$\n\n\n## Theorem 1 [Nowicki 1, Conjecture 6.9.10]\nAssume that $k[\\mathbf{y}] = k[y_{1}, \\cdots, y_{n}]$ is the polynomial ring in $n$ variables over a field $k$ of characteristic zero. If $\\Delta_{n}$ is the $k[\\mathbf{y}]$-derivation of $k[\\mathbf{y}][\\mathbf{x}]$ defined by $\\Delta_{n}(x_{i}) = y_{i}$ for $i = 1, \\cdots, n$, then $\\ker \\Delta_{n}$ is generated by $L^{\\Delta_{n}}_{ij}$ for $1  i < j  n$ over $k[\\mathbf{y}]$.\n\n\n## Proof of Theorem 1\n\nWe prove the conjecture by induction on $n$. \n\nStep $1$. The assertion is clear when $n = 1$. \n\nStep $n-1$. By the assumption on induction, $\\ker \\Delta_{n-1}$ is generated by $S_{n-1}$ over $k[\\mathbf{y}^{\\prime}] := k[y_{1}, \\cdots , y_{n-1}]$, since $L^{\\Delta_{n-1}}_{i,j} = L^{\\Delta_{n}}_{i,j}$ for each $i, j$.\n\nStep $n$. Split the theorem into several lemmas.\n\n## Lemma 1 \n\nThe $k[\\mathbf{y}^{\\prime}]$-derivation $\\Delta_{n-1}$ that naturally extends to a $k[\\mathbf{y}]$-derivation $(\\Delta_{n-1})_{k[\\mathbf{y}]}$ of $k[\\mathbf{y}][\\mathbf{x}^{\\prime}] := k[\\mathbf{y}][x_{1}, \\cdots, x_{n-1}]$ satisfies\n\n$$\\begin{equation}\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n} = k[\\mathbf{y}][S_{n-1}].\n\\end{equation}$$\n\n## Proof of Lemma 1\n\nAs discussed in Section 1, then $(\\Delta_{n-1})k[\\mathbf{y}] = \\Delta_{n}|_{k[\\mathbf{y}][\\mathbf{x}^{\\prime}]}$, so we have $\\ker(\\Delta_{n-1})k[\\mathbf{y}] = k[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n}$. Moreover,\n$\\ker(\\Delta_{n-1})k[\\mathbf{y}] = k[\\mathbf{y}] \\otimes_{k[\\mathbf{y}^{\\prime}]} \\ker \\Delta_{n-1}$, since $k[\\mathbf{y}]$ is flat over $k[\\mathbf{y}^{\\prime}]$. $\\square$\n\n\n\nLet $\\mathbf{e}_{1}, \\cdots , \\mathbf{e}_{n}$ be the coordinate unit vectors of $\\mathbb{R}^{n}$, $M$ the $\\mathbb{Z}$-submodule of $(\\mathbb{Z}^{n})^{2}$ generated by $(\\mathbf{e}_{j} - \\mathbf{e}_{i}, \\mathbf{e}_{i} - \\mathbf{e}_{j})$ for $1 \\leq i < j \\leq n$, and $\\Gamma = (\\mathbb{Z}^{n})^{2}/M$.  \n\n\n## Theorem 2\n\nFor each $\\gamma \\in \\Gamma$, we define $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma}$ to be the $k$-vector space generated by $\\mathbf{y}^{a}\\mathbf{x}^{b}:= y^{a_{1}} \\cdots y^{a_{n}} x^{b_{1}} \\cdots x^{b_{n}}$ for $a = (a_{1}, \\cdots , a_{n})$ and $b = (b_{1}, \\cdots , b_{n})$ in $(\\mathbb{Z}_{\\geq 0})^{n}$ such that the image of $(a, b)$ in $\\Gamma$ is equal to $\\gamma$. Then \n\n$$\\ker \\Delta_{n} = \\bigoplus_{\\gamma \\in \\Gamma} k[\\mathbf{y}] [ \\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}$$\n\n## Proof of Theorem 2\n\nNote that $\\Delta_{n}(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma})$ is contained in $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma - \\delta}$ for each $\\gamma \\in \\Gamma$, where $\\delta$ is the image of $(-\\mathbb{e}_{n}, \\mathbb{e}_{n})$ in $\\Gamma$. $\\square$\n\n\n\nHence, we are reduced to showing that each $0 \\neq \\varPhi \\in k[\\mathbf{y}][\\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}$ belongs to $k[\\mathbf{y}][S_{n}]$ for $\\gamma \\in \\Gamma$.\n\nWe may find $a = (a_{1}, \\cdots , a_{n}) \\in \\mathbb{Z}^{n}$ and $l \\in \\mathbb{Z}_{\\geq 0}$ such that the image of $(a, l\\mathbf{e}_{n})$ in $\\Gamma$ is equal to $\\gamma$. Let $m$ be the $x_{n}$-degree of $\\varPhi$, where $0 \\leq m \\leq l$, and $\\phi \\in k[\\mathbf{y}][\\mathbf{x}^{\\prime}]$ the coefficient of $x_{n}^{m}$ in $\\varPhi$. By replacing $\\varPhi$ if necessary, we may assume that $m$ is the minimum among the $x_{n}$-degrees of elements of $\\ker \\Delta_{n}\\backslash k[\\mathbf{y}][S_{n}]$. \n\n## Lemma 2 \n\nWrite $\\phi$ in expression of sum of $y_{1}\\cdots y_{n}$\n\n$$\\phi = y_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}$$\n\nwhere $L^{\\mathbf{u}} = \\prod_{1 \\leq i<j\\leq n-1} L_{i,j}^{u_{i,j}}$ for each $\\mathbf{u}$. There holds the identity\n\n$$\\begin{equation}\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\n\\end{equation}$$\n\n\n## Lemma 3\n\nThere holds the inequality\n\n$$\\begin{equation}\nm \\geq 2l - \\sum_{i=1}^{n-1} a_{i}.\n\\end{equation}$$\n\n\n\n## Proof of Lemma 2\n\n\nthen, $\\phi$ belongs to $k[\\mathbf{y}][\\mathbf{x}]_{\\mu}$, where $\\mu$ is the image of $(a, (l - m)\\mathbf{e}_{n})$ in $\\Gamma$. Furthermore, $0 = \\Delta_{n}(\\varPhi) = \\Delta_{n}(\\varphi)x^{m}_{n} + m\\phi y_{n}x_{n}^{m-1} + \\Delta_{n}(\\varPhi - \\phi x^{m}_{n})$, and the $x_{n}$-degrees of $m\\phi y_{n}x_{n}^{m-1}$ and $\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})$ are at most $m - 1$. Hence, $\\Delta_{n}(\\phi) = 0$. Thus, $\\phi$ belongs to $k[\\mathbf{y}][S_{n-1}]$ by (1). Write $\\phi = \\sum_{b,\\mathbf{u}} r^{\\prime}_{b,\\mathbf{u}}y^{b}\\hat{y}^{-\\mathbf{u}}L^{\\mathbf{u}}$, where the sum is taken over $b \\in (\\mathbb{Z}_{\\geq 0})^{n}$ and $u = (u_{i,j})_{i,j}$ with $u_{i,j} \\in \\mathbb{Z}_{\\geq 0}$ for $1 \\leq i < j \\leq n - 1$, $r^{\\prime}_{b,\\mathbf{u}} \\in k$ for each $b$ and $\\mathbf{u}$, and \n\n$\\hat{y}^{-u} = \\prod_{1\\leq i < j \\leq n-1} (y_{i}y_{j})^{-u_{i,j}}, \\quad L^{\\mathbf{u}} = \\prod_{1 \\leq i<j\\leq n-1} L_{i,j}^{u_{i,j}}$ for each $\\mathbf{u}$.\n\nWe may assume that $r_{b,\\mathbf{u}}^{\\prime} = 0$ if $\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}$ is not in $k[\\mathbf{y}]$. Let $\\eta(b, \\mathbf{u})$ be the image of $(b - |\\mathbf{u}|\\mathbf{e}_{n}, |\\mathbf{u}|\\mathbf{e}_{n})$ in $\\Gamma$, where $|\\mathbf{u}| = \\sum_{i,j} u_{i,j}$. Then, $\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}L^{\\mathbf{u}}$ belongs to $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\eta(b,\\mathbf{u})}$ for each $b$ and $\\mathbf{u}$ where $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}] := k[\\mathbf{y}][\\mathbf{x}][(y_{1} \\cdots y_{n})^{-1}]$, since $(y_{i}y_{j})^{-1} L_{i,j}$ belongs to $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\delta}$ for each $i, j$.  Since $\\phi$ is in $k[\\mathbf{y}][\\mathbf{x}]_{\\mu}$, and $\\mu$ is the image of $(a, (l - m)\\mathbf{e}_{n})$, we may assume that $r_{b,\\mathbf{u}}^{\\prime} = 0$ unless $|u| = l - m$ and $b = a + (l - m)\\mathbf{e}_{n}$. For each $\\mathbf{u}$ with $r_{\\mathbf{u}} := r^{\\prime}_{a + (l-m) \\mathbf{e}_{n},\\mathbf{u}}\\neq 0$, write $\\mathbf{y}^{a} y_{n}^{l-m} \\hat{\\mathbf{y}}^{-\\mathbf{u}} = y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} y_{n}^{s}$, where $\\rho_{i}(u) \\in \\mathbb{Z}_{\\geq 0}$ for $i = 1, \\cdots , n - 1$, and $s = a_{n} + l - m$. Then, we have $\\phi = y_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}$. Since $|u| = l - m$, it follows that\n\n\n$$\\begin{equation}\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\n\\end{equation}$$\n\n## Proof of Lemma 3\n\nTake $\\varPhi$ which does not satisfy (3) so that $m$ would be the minimum among the $x_{n}$-degrees of such polynomials. Then, $t:= 2l - \\sum_{i=1}^{n-1}a_{i} -m$ is positive, and $\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) = m - t$ for each $\\mathbf{u}$ by (2). Hence, the $x_{n}$-degree of\n\n$$\\varPhi_{1}:= \\sum_{\\mathbf{u}} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} L_{n,i}^{\\rho_{i}(\\mathbf{u})} = \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} (y_{i}x_{n} - y_{n}x_{i})^{\\rho_{i}(\\mathbf{u})}$$\n\n\nis $m - t$. The coefficient of $x_{n}^{n-t}$ in $y_{n}^{s}\\varPhi_{1}$ is equal to $\\phi$, so the coefficient of $x_{n}^{m}$ in $y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$ is equal to that in $y_{1}^{t}\\varPhi$. Consequently, the $x_{n}$-degree $m^{\\prime}$ of $\\varPhi_{2}:= y_{1}^{t}\\varPhi - y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$ is less than $m$. We claim that $\\varPhi_{2} = 0$. In fact, if $\\gamma^{\\prime}$ is the image of $(a + t\\mathbf{e}_{1}, l\\mathbf{e}_{n})$ in $\\Gamma$, and $(a^{\\prime}_{1}, \\cdots , a_{n}^{\\prime}\n) := a + t\\mathbf{e}_{1}$, then $\\varPhi_{2}$ belongs to $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma^{\\prime}} \\cap \\ker \\Delta_{n}$, and\n\n\n$$2l - \\sum_{i=1}^{n-1} a^{\\prime}_{i} = 2l - \\sum_{i=1}^{n-1} a_{i} - t = m > m^{\\prime}$$\n\n\nThis implies that $\\varPhi_{2} = 0$ by the minimality of $m$. Hence, $y_{1}^{t} \\varPhi= y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$. Thus, $\\varPhi_{1}$ is divisible by $y_{1}$, since neither are $y_{n}$ and $L_{n,1}$. Recall that the kernel of a locally nilpotent derivation $D$ of an integral domain $R$ containing $Q$ is factorially closed in $R$, that is, $D(f g) =\n0$ implies $D(f ) = D(g) = 0$ for each $f, g \\in R \\ \\{0\\}$ (cf. [2, Proposition 1.3.32 (iii)]). Note\nthat $\\Delta_{n}$ is locally nilpotent, $\\Delta_{n}(\\varPhi_{1}) = 0$, $\\varPhi_{1} \\neq 0$ and $\\Delta_{n}(x_{n}) \\neq 0$. Hence, $\\varPhi_{1}$ is not divisible by $x_{n}$. By substituting zero for $x_{n}$, we obtain from $\\varPhi_{1}$ a nonzero polynomial\n\n$$\\sum_{\\mathbf{u}}r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} (- y_{n} x_{i})^{\\rho_{i}(\\mathbf{u})} = ( - y_{n} )^{m-i} \\varPsi, \\text{ where } \\varPsi = \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} x_{i}^{\\rho_{i}(\\mathbf{u})}.$$\n\nThen, $\\varPhi \\neq 0$, and $\\varPhi$ is divisible by $y_{1}$, since so is $\\phi_{1}$. Define $\\sigma \\in \\text{Aut}_{k} k[\\mathbf{y}][\\mathbf{x}]$ by $\\sigma(x_{i}) =\ny_{i}$ and $\\sigma(y_{i}) = x_{i}$ for $i = 1, \\cdots, n$. Then, $\\sigma(\\varPhi)$ is divisible by $x_{1}$. On the other hand, $\\sigma(L_{i,j}) = L_{j,i}$ and $\\sigma(x_{i}) = y_{i}$ are in $\\ker \\Delta_{n}$ for each $i, j$, so $\\sigma(\\varPsi)$ belongs to $\\ker \\Delta_{n}$. Thus, we have $\\sigma(\\varPsi) = 0$, because $x_{1}$ is not in $\\ker \\Delta_[n]$ and $\\ker \\Delta_{n}$ is factorially closed in $k[\\mathbf{y}][\\mathbf{x}]$. This contradicts that $\\varPsi \\neq 0$. $\\square$\n\n\n## Proof of Theorem 1\n\n\nIn fact, (3) implies that $\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) \\geq m$ by (2), so we have $\\sum_{i=1}^{n-1}\\rho_{i}^{\\prime}(\\mathbf{u})  = m$ for some\nintegers $0 \\leq \\rho^{\\prime}_{i}(\\mathbf{u}) \\leq \\rho_{i}(\\mathbf{u})$ for $i = 1, \\cdots, n - 1$ for each $u$. Then,\n\n$$\\varPhi^{\\prime} := y_{n}^{s} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}) - \\rho_{i}^{\\prime}(\\mathbf{u})} L_{n,i}^{\\rho_{i}^{\\prime}(\\mathbf{u})} = y_{n}^{s} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}) - \\rho_{i}^{\\prime}(\\mathbf{u}) } (y_{i}x_{n} - x_{n}y_{i})^{\\rho_{i}^{\\prime}(\\mathbf{u}) }$$\n\n\nis an element of $k[\\mathbf{y}][S_{n}]$ having $x_{n}$-degree $m$, in which the coefficient of $x_{n}^{m}$ is equal to $\\phi$. Hence, the $x_{n}$-degree of $\\varPhi - \\varPhi^{\\prime}$ is less than $m$. Since $\\varPhi - \\varPhi^{\\prime}$ is an element of $\\ker \\Delta_{n} \\backslash k[\\mathbf{y}][S_{n}]$, this contradicts the minimality of $m$. $\\square$\n\n\n","source":"_posts/Nowicki Conjecture.md","raw":"---\ntitle: Nowicki Conjecture\ndate: 2023-04-11 16:28:25\ntags:\n    - [Notes]\ncategories:\n    - [Notes]\nmathjax: true\n---\n\n\nLet $A[\\mathbf{x}] = A[x_{1}, \\cdots, x_{n}$] be the polynomial ring in n variables over an integral domain $A$, $D$ an $A$-[derivation](https://en.wikipedia.org/wiki/Derivation_(differential_algebra)) of $A[\\mathbf{x}]$ and denote \n$$L^{D}_{ij} := D(x_{i}) x_{j} - D(x_{j}) x_{i}, \\quad \\text{ for each } i, j \\in \\{1, \\cdots, n\\}.$$\n\n\n## Theorem 1 [Nowicki 1, Conjecture 6.9.10]\nAssume that $k[\\mathbf{y}] = k[y_{1}, \\cdots, y_{n}]$ is the polynomial ring in $n$ variables over a field $k$ of characteristic zero. If $\\Delta_{n}$ is the $k[\\mathbf{y}]$-derivation of $k[\\mathbf{y}][\\mathbf{x}]$ defined by $\\Delta_{n}(x_{i}) = y_{i}$ for $i = 1, \\cdots, n$, then $\\ker \\Delta_{n}$ is generated by $L^{\\Delta_{n}}_{ij}$ for $1  i < j  n$ over $k[\\mathbf{y}]$.\n\n\n## Proof of Theorem 1\n\nWe prove the conjecture by induction on $n$. \n\nStep $1$. The assertion is clear when $n = 1$. \n\nStep $n-1$. By the assumption on induction, $\\ker \\Delta_{n-1}$ is generated by $S_{n-1}$ over $k[\\mathbf{y}^{\\prime}] := k[y_{1}, \\cdots , y_{n-1}]$, since $L^{\\Delta_{n-1}}_{i,j} = L^{\\Delta_{n}}_{i,j}$ for each $i, j$.\n\nStep $n$. Split the theorem into several lemmas.\n\n## Lemma 1 \n\nThe $k[\\mathbf{y}^{\\prime}]$-derivation $\\Delta_{n-1}$ that naturally extends to a $k[\\mathbf{y}]$-derivation $(\\Delta_{n-1})_{k[\\mathbf{y}]}$ of $k[\\mathbf{y}][\\mathbf{x}^{\\prime}] := k[\\mathbf{y}][x_{1}, \\cdots, x_{n-1}]$ satisfies\n\n$$\\begin{equation}\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n} = k[\\mathbf{y}][S_{n-1}].\n\\end{equation}$$\n\n## Proof of Lemma 1\n\nAs discussed in Section 1, then $(\\Delta_{n-1})k[\\mathbf{y}] = \\Delta_{n}|_{k[\\mathbf{y}][\\mathbf{x}^{\\prime}]}$, so we have $\\ker(\\Delta_{n-1})k[\\mathbf{y}] = k[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n}$. Moreover,\n$\\ker(\\Delta_{n-1})k[\\mathbf{y}] = k[\\mathbf{y}] \\otimes_{k[\\mathbf{y}^{\\prime}]} \\ker \\Delta_{n-1}$, since $k[\\mathbf{y}]$ is flat over $k[\\mathbf{y}^{\\prime}]$. $\\square$\n\n\n\nLet $\\mathbf{e}_{1}, \\cdots , \\mathbf{e}_{n}$ be the coordinate unit vectors of $\\mathbb{R}^{n}$, $M$ the $\\mathbb{Z}$-submodule of $(\\mathbb{Z}^{n})^{2}$ generated by $(\\mathbf{e}_{j} - \\mathbf{e}_{i}, \\mathbf{e}_{i} - \\mathbf{e}_{j})$ for $1 \\leq i < j \\leq n$, and $\\Gamma = (\\mathbb{Z}^{n})^{2}/M$.  \n\n\n## Theorem 2\n\nFor each $\\gamma \\in \\Gamma$, we define $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma}$ to be the $k$-vector space generated by $\\mathbf{y}^{a}\\mathbf{x}^{b}:= y^{a_{1}} \\cdots y^{a_{n}} x^{b_{1}} \\cdots x^{b_{n}}$ for $a = (a_{1}, \\cdots , a_{n})$ and $b = (b_{1}, \\cdots , b_{n})$ in $(\\mathbb{Z}_{\\geq 0})^{n}$ such that the image of $(a, b)$ in $\\Gamma$ is equal to $\\gamma$. Then \n\n$$\\ker \\Delta_{n} = \\bigoplus_{\\gamma \\in \\Gamma} k[\\mathbf{y}] [ \\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}$$\n\n## Proof of Theorem 2\n\nNote that $\\Delta_{n}(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma})$ is contained in $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma - \\delta}$ for each $\\gamma \\in \\Gamma$, where $\\delta$ is the image of $(-\\mathbb{e}_{n}, \\mathbb{e}_{n})$ in $\\Gamma$. $\\square$\n\n\n\nHence, we are reduced to showing that each $0 \\neq \\varPhi \\in k[\\mathbf{y}][\\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}$ belongs to $k[\\mathbf{y}][S_{n}]$ for $\\gamma \\in \\Gamma$.\n\nWe may find $a = (a_{1}, \\cdots , a_{n}) \\in \\mathbb{Z}^{n}$ and $l \\in \\mathbb{Z}_{\\geq 0}$ such that the image of $(a, l\\mathbf{e}_{n})$ in $\\Gamma$ is equal to $\\gamma$. Let $m$ be the $x_{n}$-degree of $\\varPhi$, where $0 \\leq m \\leq l$, and $\\phi \\in k[\\mathbf{y}][\\mathbf{x}^{\\prime}]$ the coefficient of $x_{n}^{m}$ in $\\varPhi$. By replacing $\\varPhi$ if necessary, we may assume that $m$ is the minimum among the $x_{n}$-degrees of elements of $\\ker \\Delta_{n}\\backslash k[\\mathbf{y}][S_{n}]$. \n\n## Lemma 2 \n\nWrite $\\phi$ in expression of sum of $y_{1}\\cdots y_{n}$\n\n$$\\phi = y_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}$$\n\nwhere $L^{\\mathbf{u}} = \\prod_{1 \\leq i<j\\leq n-1} L_{i,j}^{u_{i,j}}$ for each $\\mathbf{u}$. There holds the identity\n\n$$\\begin{equation}\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\n\\end{equation}$$\n\n\n## Lemma 3\n\nThere holds the inequality\n\n$$\\begin{equation}\nm \\geq 2l - \\sum_{i=1}^{n-1} a_{i}.\n\\end{equation}$$\n\n\n\n## Proof of Lemma 2\n\n\nthen, $\\phi$ belongs to $k[\\mathbf{y}][\\mathbf{x}]_{\\mu}$, where $\\mu$ is the image of $(a, (l - m)\\mathbf{e}_{n})$ in $\\Gamma$. Furthermore, $0 = \\Delta_{n}(\\varPhi) = \\Delta_{n}(\\varphi)x^{m}_{n} + m\\phi y_{n}x_{n}^{m-1} + \\Delta_{n}(\\varPhi - \\phi x^{m}_{n})$, and the $x_{n}$-degrees of $m\\phi y_{n}x_{n}^{m-1}$ and $\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})$ are at most $m - 1$. Hence, $\\Delta_{n}(\\phi) = 0$. Thus, $\\phi$ belongs to $k[\\mathbf{y}][S_{n-1}]$ by (1). Write $\\phi = \\sum_{b,\\mathbf{u}} r^{\\prime}_{b,\\mathbf{u}}y^{b}\\hat{y}^{-\\mathbf{u}}L^{\\mathbf{u}}$, where the sum is taken over $b \\in (\\mathbb{Z}_{\\geq 0})^{n}$ and $u = (u_{i,j})_{i,j}$ with $u_{i,j} \\in \\mathbb{Z}_{\\geq 0}$ for $1 \\leq i < j \\leq n - 1$, $r^{\\prime}_{b,\\mathbf{u}} \\in k$ for each $b$ and $\\mathbf{u}$, and \n\n$\\hat{y}^{-u} = \\prod_{1\\leq i < j \\leq n-1} (y_{i}y_{j})^{-u_{i,j}}, \\quad L^{\\mathbf{u}} = \\prod_{1 \\leq i<j\\leq n-1} L_{i,j}^{u_{i,j}}$ for each $\\mathbf{u}$.\n\nWe may assume that $r_{b,\\mathbf{u}}^{\\prime} = 0$ if $\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}$ is not in $k[\\mathbf{y}]$. Let $\\eta(b, \\mathbf{u})$ be the image of $(b - |\\mathbf{u}|\\mathbf{e}_{n}, |\\mathbf{u}|\\mathbf{e}_{n})$ in $\\Gamma$, where $|\\mathbf{u}| = \\sum_{i,j} u_{i,j}$. Then, $\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}L^{\\mathbf{u}}$ belongs to $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\eta(b,\\mathbf{u})}$ for each $b$ and $\\mathbf{u}$ where $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}] := k[\\mathbf{y}][\\mathbf{x}][(y_{1} \\cdots y_{n})^{-1}]$, since $(y_{i}y_{j})^{-1} L_{i,j}$ belongs to $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\delta}$ for each $i, j$.  Since $\\phi$ is in $k[\\mathbf{y}][\\mathbf{x}]_{\\mu}$, and $\\mu$ is the image of $(a, (l - m)\\mathbf{e}_{n})$, we may assume that $r_{b,\\mathbf{u}}^{\\prime} = 0$ unless $|u| = l - m$ and $b = a + (l - m)\\mathbf{e}_{n}$. For each $\\mathbf{u}$ with $r_{\\mathbf{u}} := r^{\\prime}_{a + (l-m) \\mathbf{e}_{n},\\mathbf{u}}\\neq 0$, write $\\mathbf{y}^{a} y_{n}^{l-m} \\hat{\\mathbf{y}}^{-\\mathbf{u}} = y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} y_{n}^{s}$, where $\\rho_{i}(u) \\in \\mathbb{Z}_{\\geq 0}$ for $i = 1, \\cdots , n - 1$, and $s = a_{n} + l - m$. Then, we have $\\phi = y_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}$. Since $|u| = l - m$, it follows that\n\n\n$$\\begin{equation}\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\n\\end{equation}$$\n\n## Proof of Lemma 3\n\nTake $\\varPhi$ which does not satisfy (3) so that $m$ would be the minimum among the $x_{n}$-degrees of such polynomials. Then, $t:= 2l - \\sum_{i=1}^{n-1}a_{i} -m$ is positive, and $\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) = m - t$ for each $\\mathbf{u}$ by (2). Hence, the $x_{n}$-degree of\n\n$$\\varPhi_{1}:= \\sum_{\\mathbf{u}} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} L_{n,i}^{\\rho_{i}(\\mathbf{u})} = \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} (y_{i}x_{n} - y_{n}x_{i})^{\\rho_{i}(\\mathbf{u})}$$\n\n\nis $m - t$. The coefficient of $x_{n}^{n-t}$ in $y_{n}^{s}\\varPhi_{1}$ is equal to $\\phi$, so the coefficient of $x_{n}^{m}$ in $y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$ is equal to that in $y_{1}^{t}\\varPhi$. Consequently, the $x_{n}$-degree $m^{\\prime}$ of $\\varPhi_{2}:= y_{1}^{t}\\varPhi - y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$ is less than $m$. We claim that $\\varPhi_{2} = 0$. In fact, if $\\gamma^{\\prime}$ is the image of $(a + t\\mathbf{e}_{1}, l\\mathbf{e}_{n})$ in $\\Gamma$, and $(a^{\\prime}_{1}, \\cdots , a_{n}^{\\prime}\n) := a + t\\mathbf{e}_{1}$, then $\\varPhi_{2}$ belongs to $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma^{\\prime}} \\cap \\ker \\Delta_{n}$, and\n\n\n$$2l - \\sum_{i=1}^{n-1} a^{\\prime}_{i} = 2l - \\sum_{i=1}^{n-1} a_{i} - t = m > m^{\\prime}$$\n\n\nThis implies that $\\varPhi_{2} = 0$ by the minimality of $m$. Hence, $y_{1}^{t} \\varPhi= y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$. Thus, $\\varPhi_{1}$ is divisible by $y_{1}$, since neither are $y_{n}$ and $L_{n,1}$. Recall that the kernel of a locally nilpotent derivation $D$ of an integral domain $R$ containing $Q$ is factorially closed in $R$, that is, $D(f g) =\n0$ implies $D(f ) = D(g) = 0$ for each $f, g \\in R \\ \\{0\\}$ (cf. [2, Proposition 1.3.32 (iii)]). Note\nthat $\\Delta_{n}$ is locally nilpotent, $\\Delta_{n}(\\varPhi_{1}) = 0$, $\\varPhi_{1} \\neq 0$ and $\\Delta_{n}(x_{n}) \\neq 0$. Hence, $\\varPhi_{1}$ is not divisible by $x_{n}$. By substituting zero for $x_{n}$, we obtain from $\\varPhi_{1}$ a nonzero polynomial\n\n$$\\sum_{\\mathbf{u}}r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} (- y_{n} x_{i})^{\\rho_{i}(\\mathbf{u})} = ( - y_{n} )^{m-i} \\varPsi, \\text{ where } \\varPsi = \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} x_{i}^{\\rho_{i}(\\mathbf{u})}.$$\n\nThen, $\\varPhi \\neq 0$, and $\\varPhi$ is divisible by $y_{1}$, since so is $\\phi_{1}$. Define $\\sigma \\in \\text{Aut}_{k} k[\\mathbf{y}][\\mathbf{x}]$ by $\\sigma(x_{i}) =\ny_{i}$ and $\\sigma(y_{i}) = x_{i}$ for $i = 1, \\cdots, n$. Then, $\\sigma(\\varPhi)$ is divisible by $x_{1}$. On the other hand, $\\sigma(L_{i,j}) = L_{j,i}$ and $\\sigma(x_{i}) = y_{i}$ are in $\\ker \\Delta_{n}$ for each $i, j$, so $\\sigma(\\varPsi)$ belongs to $\\ker \\Delta_{n}$. Thus, we have $\\sigma(\\varPsi) = 0$, because $x_{1}$ is not in $\\ker \\Delta_[n]$ and $\\ker \\Delta_{n}$ is factorially closed in $k[\\mathbf{y}][\\mathbf{x}]$. This contradicts that $\\varPsi \\neq 0$. $\\square$\n\n\n## Proof of Theorem 1\n\n\nIn fact, (3) implies that $\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) \\geq m$ by (2), so we have $\\sum_{i=1}^{n-1}\\rho_{i}^{\\prime}(\\mathbf{u})  = m$ for some\nintegers $0 \\leq \\rho^{\\prime}_{i}(\\mathbf{u}) \\leq \\rho_{i}(\\mathbf{u})$ for $i = 1, \\cdots, n - 1$ for each $u$. Then,\n\n$$\\varPhi^{\\prime} := y_{n}^{s} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}) - \\rho_{i}^{\\prime}(\\mathbf{u})} L_{n,i}^{\\rho_{i}^{\\prime}(\\mathbf{u})} = y_{n}^{s} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}) - \\rho_{i}^{\\prime}(\\mathbf{u}) } (y_{i}x_{n} - x_{n}y_{i})^{\\rho_{i}^{\\prime}(\\mathbf{u}) }$$\n\n\nis an element of $k[\\mathbf{y}][S_{n}]$ having $x_{n}$-degree $m$, in which the coefficient of $x_{n}^{m}$ is equal to $\\phi$. Hence, the $x_{n}$-degree of $\\varPhi - \\varPhi^{\\prime}$ is less than $m$. Since $\\varPhi - \\varPhi^{\\prime}$ is an element of $\\ker \\Delta_{n} \\backslash k[\\mathbf{y}][S_{n}]$, this contradicts the minimality of $m$. $\\square$\n\n\n","slug":"Nowicki Conjecture","published":1,"updated":"2023-12-31T07:45:36.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisunc0009eslr5s2kaohh","content":"<p>Let <span class=\"math inline\">\\(A[\\mathbf{x}] = A[x_{1}, \\cdots,\r\nx_{n}\\)</span>] be the polynomial ring in n variables over an integral\r\ndomain <span class=\"math inline\">\\(A\\)</span>, <span\r\nclass=\"math inline\">\\(D\\)</span> an <span\r\nclass=\"math inline\">\\(A\\)</span>-<a\r\nhref=\"https://en.wikipedia.org/wiki/Derivation_(differential_algebra)\">derivation</a>\r\nof <span class=\"math inline\">\\(A[\\mathbf{x}]\\)</span> and denote <span\r\nclass=\"math display\">\\[L^{D}_{ij} := D(x_{i}) x_{j} - D(x_{j}) x_{i},\r\n\\quad \\text{ for each } i, j \\in \\{1, \\cdots, n\\}.\\]</span></p>\r\n<h2 id=\"theorem-1-nowicki-1-conjecture-6.9.10\">Theorem 1 [Nowicki 1,\r\nConjecture 6.9.10]</h2>\r\n<p>Assume that <span class=\"math inline\">\\(k[\\mathbf{y}] = k[y_{1},\r\n\\cdots, y_{n}]\\)</span> is the polynomial ring in <span\r\nclass=\"math inline\">\\(n\\)</span> variables over a field <span\r\nclass=\"math inline\">\\(k\\)</span> of characteristic zero. If <span\r\nclass=\"math inline\">\\(\\Delta_{n}\\)</span> is the <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}]\\)</span>-derivation of <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span> defined by\r\n<span class=\"math inline\">\\(\\Delta_{n}(x_{i}) = y_{i}\\)</span> for <span\r\nclass=\"math inline\">\\(i = 1, \\cdots, n\\)</span>, then <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> is generated by <span\r\nclass=\"math inline\">\\(L^{\\Delta_{n}}_{ij}\\)</span> for <span\r\nclass=\"math inline\">\\(1  i &lt; j  n\\)</span> over <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}]\\)</span>.</p>\r\n<h2 id=\"proof-of-theorem-1\">Proof of Theorem 1</h2>\r\n<p>We prove the conjecture by induction on <span\r\nclass=\"math inline\">\\(n\\)</span>.</p>\r\n<p>Step <span class=\"math inline\">\\(1\\)</span>. The assertion is clear\r\nwhen <span class=\"math inline\">\\(n = 1\\)</span>.</p>\r\n<p>Step <span class=\"math inline\">\\(n-1\\)</span>. By the assumption on\r\ninduction, <span class=\"math inline\">\\(\\ker \\Delta_{n-1}\\)</span> is\r\ngenerated by <span class=\"math inline\">\\(S_{n-1}\\)</span> over <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\prime}] := k[y_{1}, \\cdots ,\r\ny_{n-1}]\\)</span>, since <span\r\nclass=\"math inline\">\\(L^{\\Delta_{n-1}}_{i,j} =\r\nL^{\\Delta_{n}}_{i,j}\\)</span> for each <span class=\"math inline\">\\(i,\r\nj\\)</span>.</p>\r\n<p>Step <span class=\"math inline\">\\(n\\)</span>. Split the theorem into\r\nseveral lemmas.</p>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>The <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\prime}]\\)</span>-derivation <span\r\nclass=\"math inline\">\\(\\Delta_{n-1}\\)</span> that naturally extends to a\r\n<span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>-derivation <span\r\nclass=\"math inline\">\\((\\Delta_{n-1})_{k[\\mathbf{y}]}\\)</span> of <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}^{\\prime}] :=\r\nk[\\mathbf{y}][x_{1}, \\cdots, x_{n-1}]\\)</span> satisfies</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n} =\r\nk[\\mathbf{y}][S_{n-1}].\r\n\\end{equation}\\]</span></p>\r\n<h2 id=\"proof-of-lemma-1\">Proof of Lemma 1</h2>\r\n<p>As discussed in Section 1, then <span\r\nclass=\"math inline\">\\((\\Delta_{n-1})k[\\mathbf{y}] =\r\n\\Delta_{n}|_{k[\\mathbf{y}][\\mathbf{x}^{\\prime}]}\\)</span>, so we have\r\n<span class=\"math inline\">\\(\\ker(\\Delta_{n-1})k[\\mathbf{y}] =\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n}\\)</span>.\r\nMoreover, <span class=\"math inline\">\\(\\ker(\\Delta_{n-1})k[\\mathbf{y}] =\r\nk[\\mathbf{y}] \\otimes_{k[\\mathbf{y}^{\\prime}]} \\ker\r\n\\Delta_{n-1}\\)</span>, since <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}]\\)</span> is flat over <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\prime}]\\)</span>. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<p>Let <span class=\"math inline\">\\(\\mathbf{e}_{1}, \\cdots ,\r\n\\mathbf{e}_{n}\\)</span> be the coordinate unit vectors of <span\r\nclass=\"math inline\">\\(\\mathbb{R}^{n}\\)</span>, <span\r\nclass=\"math inline\">\\(M\\)</span> the <span\r\nclass=\"math inline\">\\(\\mathbb{Z}\\)</span>-submodule of <span\r\nclass=\"math inline\">\\((\\mathbb{Z}^{n})^{2}\\)</span> generated by <span\r\nclass=\"math inline\">\\((\\mathbf{e}_{j} - \\mathbf{e}_{i}, \\mathbf{e}_{i} -\r\n\\mathbf{e}_{j})\\)</span> for <span class=\"math inline\">\\(1 \\leq i &lt; j\r\n\\leq n\\)</span>, and <span class=\"math inline\">\\(\\Gamma =\r\n(\\mathbb{Z}^{n})^{2}/M\\)</span>.</p>\r\n<h2 id=\"theorem-2\">Theorem 2</h2>\r\n<p>For each <span class=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span>, we\r\ndefine <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma}\\)</span> to be\r\nthe <span class=\"math inline\">\\(k\\)</span>-vector space generated by\r\n<span class=\"math inline\">\\(\\mathbf{y}^{a}\\mathbf{x}^{b}:= y^{a_{1}}\r\n\\cdots y^{a_{n}} x^{b_{1}} \\cdots x^{b_{n}}\\)</span> for <span\r\nclass=\"math inline\">\\(a = (a_{1}, \\cdots , a_{n})\\)</span> and <span\r\nclass=\"math inline\">\\(b = (b_{1}, \\cdots , b_{n})\\)</span> in <span\r\nclass=\"math inline\">\\((\\mathbb{Z}_{\\geq 0})^{n}\\)</span> such that the\r\nimage of <span class=\"math inline\">\\((a, b)\\)</span> in <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span> is equal to <span\r\nclass=\"math inline\">\\(\\gamma\\)</span>. Then</p>\r\n<p><span class=\"math display\">\\[\\ker \\Delta_{n} = \\bigoplus_{\\gamma \\in\r\n\\Gamma} k[\\mathbf{y}] [ \\mathbf{x}]_{\\gamma} \\cap \\ker\r\n\\Delta_{n}\\]</span></p>\r\n<h2 id=\"proof-of-theorem-2\">Proof of Theorem 2</h2>\r\n<p>Note that <span\r\nclass=\"math inline\">\\(\\Delta_{n}(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma})\\)</span>\r\nis contained in <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma -\r\n\\delta}\\)</span> for each <span class=\"math inline\">\\(\\gamma \\in\r\n\\Gamma\\)</span>, where <span class=\"math inline\">\\(\\delta\\)</span> is\r\nthe image of <span class=\"math inline\">\\((-\\mathbb{e}_{n},\r\n\\mathbb{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span>.\r\n<span class=\"math inline\">\\(\\square\\)</span></p>\r\n<p>Hence, we are reduced to showing that each <span\r\nclass=\"math inline\">\\(0 \\neq \\varPhi \\in\r\nk[\\mathbf{y}][\\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}\\)</span> belongs\r\nto <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> for <span\r\nclass=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span>.</p>\r\n<p>We may find <span class=\"math inline\">\\(a = (a_{1}, \\cdots , a_{n})\r\n\\in \\mathbb{Z}^{n}\\)</span> and <span class=\"math inline\">\\(l \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> such that the image of <span\r\nclass=\"math inline\">\\((a, l\\mathbf{e}_{n})\\)</span> in <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span> is equal to <span\r\nclass=\"math inline\">\\(\\gamma\\)</span>. Let <span\r\nclass=\"math inline\">\\(m\\)</span> be the <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degree of <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span>, where <span\r\nclass=\"math inline\">\\(0 \\leq m \\leq l\\)</span>, and <span\r\nclass=\"math inline\">\\(\\phi \\in\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}]\\)</span> the coefficient of <span\r\nclass=\"math inline\">\\(x_{n}^{m}\\)</span> in <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span>. By replacing <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span> if necessary, we may assume that\r\n<span class=\"math inline\">\\(m\\)</span> is the minimum among the <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degrees of elements of <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\backslash\r\nk[\\mathbf{y}][S_{n}]\\)</span>.</p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>Write <span class=\"math inline\">\\(\\phi\\)</span> in expression of sum\r\nof <span class=\"math inline\">\\(y_{1}\\cdots y_{n}\\)</span></p>\r\n<p><span class=\"math display\">\\[\\phi = y_{n}^{s}\\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})}\r\n\\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(L^{\\mathbf{u}} = \\prod_{1 \\leq\r\ni&lt;j\\leq n-1} L_{i,j}^{u_{i,j}}\\)</span> for each <span\r\nclass=\"math inline\">\\(\\mathbf{u}\\)</span>. There holds the identity</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\r\n\\end{equation}\\]</span></p>\r\n<h2 id=\"lemma-3\">Lemma 3</h2>\r\n<p>There holds the inequality</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm \\geq 2l - \\sum_{i=1}^{n-1} a_{i}.\r\n\\end{equation}\\]</span></p>\r\n<h2 id=\"proof-of-lemma-2\">Proof of Lemma 2</h2>\r\n<p>then, <span class=\"math inline\">\\(\\phi\\)</span> belongs to <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\mu}\\)</span>, where\r\n<span class=\"math inline\">\\(\\mu\\)</span> is the image of <span\r\nclass=\"math inline\">\\((a, (l - m)\\mathbf{e}_{n})\\)</span> in <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span>. Furthermore, <span\r\nclass=\"math inline\">\\(0 = \\Delta_{n}(\\varPhi) =\r\n\\Delta_{n}(\\varphi)x^{m}_{n} + m\\phi y_{n}x_{n}^{m-1} +\r\n\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})\\)</span>, and the <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degrees of <span\r\nclass=\"math inline\">\\(m\\phi y_{n}x_{n}^{m-1}\\)</span> and <span\r\nclass=\"math inline\">\\(\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})\\)</span> are\r\nat most <span class=\"math inline\">\\(m - 1\\)</span>. Hence, <span\r\nclass=\"math inline\">\\(\\Delta_{n}(\\phi) = 0\\)</span>. Thus, <span\r\nclass=\"math inline\">\\(\\phi\\)</span> belongs to <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][S_{n-1}]\\)</span> by (1). Write\r\n<span class=\"math inline\">\\(\\phi = \\sum_{b,\\mathbf{u}}\r\nr^{\\prime}_{b,\\mathbf{u}}y^{b}\\hat{y}^{-\\mathbf{u}}L^{\\mathbf{u}}\\)</span>,\r\nwhere the sum is taken over <span class=\"math inline\">\\(b \\in\r\n(\\mathbb{Z}_{\\geq 0})^{n}\\)</span> and <span class=\"math inline\">\\(u =\r\n(u_{i,j})_{i,j}\\)</span> with <span class=\"math inline\">\\(u_{i,j} \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> for <span class=\"math inline\">\\(1 \\leq i\r\n&lt; j \\leq n - 1\\)</span>, <span\r\nclass=\"math inline\">\\(r^{\\prime}_{b,\\mathbf{u}} \\in k\\)</span> for each\r\n<span class=\"math inline\">\\(b\\)</span> and <span\r\nclass=\"math inline\">\\(\\mathbf{u}\\)</span>, and</p>\r\n<p><span class=\"math inline\">\\(\\hat{y}^{-u} = \\prod_{1\\leq i &lt; j \\leq\r\nn-1} (y_{i}y_{j})^{-u_{i,j}}, \\quad L^{\\mathbf{u}} = \\prod_{1 \\leq\r\ni&lt;j\\leq n-1} L_{i,j}^{u_{i,j}}\\)</span> for each <span\r\nclass=\"math inline\">\\(\\mathbf{u}\\)</span>.</p>\r\n<p>We may assume that <span\r\nclass=\"math inline\">\\(r_{b,\\mathbf{u}}^{\\prime} = 0\\)</span> if <span\r\nclass=\"math inline\">\\(\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}\\)</span>\r\nis not in <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>. Let <span\r\nclass=\"math inline\">\\(\\eta(b, \\mathbf{u})\\)</span> be the image of <span\r\nclass=\"math inline\">\\((b - |\\mathbf{u}|\\mathbf{e}_{n},\r\n|\\mathbf{u}|\\mathbf{e}_{n})\\)</span> in <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span>, where <span\r\nclass=\"math inline\">\\(|\\mathbf{u}| = \\sum_{i,j} u_{i,j}\\)</span>. Then,\r\n<span\r\nclass=\"math inline\">\\(\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}L^{\\mathbf{u}}\\)</span>\r\nbelongs to <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\eta(b,\\mathbf{u})}\\)</span> for each <span\r\nclass=\"math inline\">\\(b\\)</span> and <span\r\nclass=\"math inline\">\\(\\mathbf{u}\\)</span> where <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}] :=\r\nk[\\mathbf{y}][\\mathbf{x}][(y_{1} \\cdots y_{n})^{-1}]\\)</span>, since\r\n<span class=\"math inline\">\\((y_{i}y_{j})^{-1} L_{i,j}\\)</span> belongs\r\nto <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\delta}\\)</span> for each <span\r\nclass=\"math inline\">\\(i, j\\)</span>. Since <span\r\nclass=\"math inline\">\\(\\phi\\)</span> is in <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\mu}\\)</span>, and\r\n<span class=\"math inline\">\\(\\mu\\)</span> is the image of <span\r\nclass=\"math inline\">\\((a, (l - m)\\mathbf{e}_{n})\\)</span>, we may assume\r\nthat <span class=\"math inline\">\\(r_{b,\\mathbf{u}}^{\\prime} = 0\\)</span>\r\nunless <span class=\"math inline\">\\(|u| = l - m\\)</span> and <span\r\nclass=\"math inline\">\\(b = a + (l - m)\\mathbf{e}_{n}\\)</span>. For each\r\n<span class=\"math inline\">\\(\\mathbf{u}\\)</span> with <span\r\nclass=\"math inline\">\\(r_{\\mathbf{u}} := r^{\\prime}_{a + (l-m)\r\n\\mathbf{e}_{n},\\mathbf{u}}\\neq 0\\)</span>, write <span\r\nclass=\"math inline\">\\(\\mathbf{y}^{a} y_{n}^{l-m}\r\n\\hat{\\mathbf{y}}^{-\\mathbf{u}} = y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots\r\ny_{n-1}^{\\rho_{n-1}(\\mathbf{u})} y_{n}^{s}\\)</span>, where <span\r\nclass=\"math inline\">\\(\\rho_{i}(u) \\in \\mathbb{Z}_{\\geq 0}\\)</span> for\r\n<span class=\"math inline\">\\(i = 1, \\cdots , n - 1\\)</span>, and <span\r\nclass=\"math inline\">\\(s = a_{n} + l - m\\)</span>. Then, we have <span\r\nclass=\"math inline\">\\(\\phi = y_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}}\r\ny_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots y_{n-1}^{\\rho_{n-1}(\\mathbf{u})}\r\nL^{\\mathbf{u}}\\)</span>. Since <span class=\"math inline\">\\(|u| = l -\r\nm\\)</span>, it follows that</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\r\n\\end{equation}\\]</span></p>\r\n<h2 id=\"proof-of-lemma-3\">Proof of Lemma 3</h2>\r\n<p>Take <span class=\"math inline\">\\(\\varPhi\\)</span> which does not\r\nsatisfy (3) so that <span class=\"math inline\">\\(m\\)</span> would be the\r\nminimum among the <span class=\"math inline\">\\(x_{n}\\)</span>-degrees of\r\nsuch polynomials. Then, <span class=\"math inline\">\\(t:= 2l -\r\n\\sum_{i=1}^{n-1}a_{i} -m\\)</span> is positive, and <span\r\nclass=\"math inline\">\\(\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) = m -\r\nt\\)</span> for each <span class=\"math inline\">\\(\\mathbf{u}\\)</span> by\r\n(2). Hence, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree of</p>\r\n<p><span class=\"math display\">\\[\\varPhi_{1}:= \\sum_{\\mathbf{u}}\r\n\\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\nL_{n,i}^{\\rho_{i}(\\mathbf{u})} = \\sum_{\\mathbf{u}} r_{\\mathbf{u}}\r\nL^{\\mathbf{u}} \\prod_{i=1}^{n-1} (y_{i}x_{n} -\r\ny_{n}x_{i})^{\\rho_{i}(\\mathbf{u})}\\]</span></p>\r\n<p>is <span class=\"math inline\">\\(m - t\\)</span>. The coefficient of\r\n<span class=\"math inline\">\\(x_{n}^{n-t}\\)</span> in <span\r\nclass=\"math inline\">\\(y_{n}^{s}\\varPhi_{1}\\)</span> is equal to <span\r\nclass=\"math inline\">\\(\\phi\\)</span>, so the coefficient of <span\r\nclass=\"math inline\">\\(x_{n}^{m}\\)</span> in <span\r\nclass=\"math inline\">\\(y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span> is equal\r\nto that in <span class=\"math inline\">\\(y_{1}^{t}\\varPhi\\)</span>.\r\nConsequently, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree\r\n<span class=\"math inline\">\\(m^{\\prime}\\)</span> of <span\r\nclass=\"math inline\">\\(\\varPhi_{2}:= y_{1}^{t}\\varPhi -\r\ny_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span> is less than <span\r\nclass=\"math inline\">\\(m\\)</span>. We claim that <span\r\nclass=\"math inline\">\\(\\varPhi_{2} = 0\\)</span>. In fact, if <span\r\nclass=\"math inline\">\\(\\gamma^{\\prime}\\)</span> is the image of <span\r\nclass=\"math inline\">\\((a + t\\mathbf{e}_{1}, l\\mathbf{e}_{n})\\)</span> in\r\n<span class=\"math inline\">\\(\\Gamma\\)</span>, and <span\r\nclass=\"math inline\">\\((a^{\\prime}_{1}, \\cdots , a_{n}^{\\prime} ) := a +\r\nt\\mathbf{e}_{1}\\)</span>, then <span\r\nclass=\"math inline\">\\(\\varPhi_{2}\\)</span> belongs to <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma^{\\prime}} \\cap\r\n\\ker \\Delta_{n}\\)</span>, and</p>\r\n<p><span class=\"math display\">\\[2l - \\sum_{i=1}^{n-1} a^{\\prime}_{i} =\r\n2l - \\sum_{i=1}^{n-1} a_{i} - t = m &gt; m^{\\prime}\\]</span></p>\r\n<p>This implies that <span class=\"math inline\">\\(\\varPhi_{2} =\r\n0\\)</span> by the minimality of <span class=\"math inline\">\\(m\\)</span>.\r\nHence, <span class=\"math inline\">\\(y_{1}^{t} \\varPhi=\r\ny_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span>. Thus, <span\r\nclass=\"math inline\">\\(\\varPhi_{1}\\)</span> is divisible by <span\r\nclass=\"math inline\">\\(y_{1}\\)</span>, since neither are <span\r\nclass=\"math inline\">\\(y_{n}\\)</span> and <span\r\nclass=\"math inline\">\\(L_{n,1}\\)</span>. Recall that the kernel of a\r\nlocally nilpotent derivation <span class=\"math inline\">\\(D\\)</span> of\r\nan integral domain <span class=\"math inline\">\\(R\\)</span> containing\r\n<span class=\"math inline\">\\(Q\\)</span> is factorially closed in <span\r\nclass=\"math inline\">\\(R\\)</span>, that is, <span\r\nclass=\"math inline\">\\(D(f g) = 0\\)</span> implies <span\r\nclass=\"math inline\">\\(D(f ) = D(g) = 0\\)</span> for each <span\r\nclass=\"math inline\">\\(f, g \\in R \\ \\{0\\}\\)</span> (cf. [2, Proposition\r\n1.3.32 (iii)]). Note that <span\r\nclass=\"math inline\">\\(\\Delta_{n}\\)</span> is locally nilpotent, <span\r\nclass=\"math inline\">\\(\\Delta_{n}(\\varPhi_{1}) = 0\\)</span>, <span\r\nclass=\"math inline\">\\(\\varPhi_{1} \\neq 0\\)</span> and <span\r\nclass=\"math inline\">\\(\\Delta_{n}(x_{n}) \\neq 0\\)</span>. Hence, <span\r\nclass=\"math inline\">\\(\\varPhi_{1}\\)</span> is not divisible by <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>. By substituting zero for <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>, we obtain from <span\r\nclass=\"math inline\">\\(\\varPhi_{1}\\)</span> a nonzero polynomial</p>\r\n<p><span class=\"math display\">\\[\\sum_{\\mathbf{u}}r_{\\mathbf{u}}\r\nL^{\\mathbf{u}} \\prod_{i=1}^{n-1} (- y_{n} x_{i})^{\\rho_{i}(\\mathbf{u})}\r\n= ( - y_{n} )^{m-i} \\varPsi, \\text{ where } \\varPsi = \\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\nx_{i}^{\\rho_{i}(\\mathbf{u})}.\\]</span></p>\r\n<p>Then, <span class=\"math inline\">\\(\\varPhi \\neq 0\\)</span>, and <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span> is divisible by <span\r\nclass=\"math inline\">\\(y_{1}\\)</span>, since so is <span\r\nclass=\"math inline\">\\(\\phi_{1}\\)</span>. Define <span\r\nclass=\"math inline\">\\(\\sigma \\in \\text{Aut}_{k}\r\nk[\\mathbf{y}][\\mathbf{x}]\\)</span> by <span\r\nclass=\"math inline\">\\(\\sigma(x_{i}) = y_{i}\\)</span> and <span\r\nclass=\"math inline\">\\(\\sigma(y_{i}) = x_{i}\\)</span> for <span\r\nclass=\"math inline\">\\(i = 1, \\cdots, n\\)</span>. Then, <span\r\nclass=\"math inline\">\\(\\sigma(\\varPhi)\\)</span> is divisible by <span\r\nclass=\"math inline\">\\(x_{1}\\)</span>. On the other hand, <span\r\nclass=\"math inline\">\\(\\sigma(L_{i,j}) = L_{j,i}\\)</span> and <span\r\nclass=\"math inline\">\\(\\sigma(x_{i}) = y_{i}\\)</span> are in <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> for each <span\r\nclass=\"math inline\">\\(i, j\\)</span>, so <span\r\nclass=\"math inline\">\\(\\sigma(\\varPsi)\\)</span> belongs to <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span>. Thus, we have <span\r\nclass=\"math inline\">\\(\\sigma(\\varPsi) = 0\\)</span>, because <span\r\nclass=\"math inline\">\\(x_{1}\\)</span> is not in <span\r\nclass=\"math inline\">\\(\\ker \\Delta_[n]\\)</span> and <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> is factorially closed in\r\n<span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span>. This\r\ncontradicts that <span class=\"math inline\">\\(\\varPsi \\neq 0\\)</span>.\r\n<span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"proof-of-theorem-1-1\">Proof of Theorem 1</h2>\r\n<p>In fact, (3) implies that <span\r\nclass=\"math inline\">\\(\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) \\geq\r\nm\\)</span> by (2), so we have <span\r\nclass=\"math inline\">\\(\\sum_{i=1}^{n-1}\\rho_{i}^{\\prime}(\\mathbf{u}) =\r\nm\\)</span> for some integers <span class=\"math inline\">\\(0 \\leq\r\n\\rho^{\\prime}_{i}(\\mathbf{u}) \\leq \\rho_{i}(\\mathbf{u})\\)</span> for\r\n<span class=\"math inline\">\\(i = 1, \\cdots, n - 1\\)</span> for each <span\r\nclass=\"math inline\">\\(u\\)</span>. Then,</p>\r\n<p><span class=\"math display\">\\[\\varPhi^{\\prime} := y_{n}^{s}\r\n\\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\ny_{i}^{\\rho_{i}(\\mathbf{u}) - \\rho_{i}^{\\prime}(\\mathbf{u})}\r\nL_{n,i}^{\\rho_{i}^{\\prime}(\\mathbf{u})} = y_{n}^{s} \\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}) -\r\n\\rho_{i}^{\\prime}(\\mathbf{u}) } (y_{i}x_{n} -\r\nx_{n}y_{i})^{\\rho_{i}^{\\prime}(\\mathbf{u}) }\\]</span></p>\r\n<p>is an element of <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> having <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degree <span\r\nclass=\"math inline\">\\(m\\)</span>, in which the coefficient of <span\r\nclass=\"math inline\">\\(x_{n}^{m}\\)</span> is equal to <span\r\nclass=\"math inline\">\\(\\phi\\)</span>. Hence, the <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degree of <span\r\nclass=\"math inline\">\\(\\varPhi - \\varPhi^{\\prime}\\)</span> is less than\r\n<span class=\"math inline\">\\(m\\)</span>. Since <span\r\nclass=\"math inline\">\\(\\varPhi - \\varPhi^{\\prime}\\)</span> is an element\r\nof <span class=\"math inline\">\\(\\ker \\Delta_{n} \\backslash\r\nk[\\mathbf{y}][S_{n}]\\)</span>, this contradicts the minimality of <span\r\nclass=\"math inline\">\\(m\\)</span>. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>Let <span class=\"math inline\">\\(A[\\mathbf{x}] = A[x_{1}, \\cdots,\r\nx_{n}\\)</span>] be the polynomial ring in n variables over an integral\r\ndomain <span class=\"math inline\">\\(A\\)</span>, <span\r\nclass=\"math inline\">\\(D\\)</span> an <span\r\nclass=\"math inline\">\\(A\\)</span>-<a\r\nhref=\"https://en.wikipedia.org/wiki/Derivation_(differential_algebra)\">derivation</a>\r\nof <span class=\"math inline\">\\(A[\\mathbf{x}]\\)</span> and denote <span\r\nclass=\"math display\">\\[L^{D}_{ij} := D(x_{i}) x_{j} - D(x_{j}) x_{i},\r\n\\quad \\text{ for each } i, j \\in \\{1, \\cdots, n\\}.\\]</span></p>\r\n<h2 id=\"theorem-1-nowicki-1-conjecture-6.9.10\">Theorem 1 [Nowicki 1,\r\nConjecture 6.9.10]</h2>\r\n<p>Assume that <span class=\"math inline\">\\(k[\\mathbf{y}] = k[y_{1},\r\n\\cdots, y_{n}]\\)</span> is the polynomial ring in <span\r\nclass=\"math inline\">\\(n\\)</span> variables over a field <span\r\nclass=\"math inline\">\\(k\\)</span> of characteristic zero. If <span\r\nclass=\"math inline\">\\(\\Delta_{n}\\)</span> is the <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}]\\)</span>-derivation of <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span> defined by\r\n<span class=\"math inline\">\\(\\Delta_{n}(x_{i}) = y_{i}\\)</span> for <span\r\nclass=\"math inline\">\\(i = 1, \\cdots, n\\)</span>, then <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> is generated by <span\r\nclass=\"math inline\">\\(L^{\\Delta_{n}}_{ij}\\)</span> for <span\r\nclass=\"math inline\">\\(1  i &lt; j  n\\)</span> over <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}]\\)</span>.</p>\r\n<h2 id=\"proof-of-theorem-1\">Proof of Theorem 1</h2>\r\n<p>We prove the conjecture by induction on <span\r\nclass=\"math inline\">\\(n\\)</span>.</p>\r\n<p>Step <span class=\"math inline\">\\(1\\)</span>. The assertion is clear\r\nwhen <span class=\"math inline\">\\(n = 1\\)</span>.</p>\r\n<p>Step <span class=\"math inline\">\\(n-1\\)</span>. By the assumption on\r\ninduction, <span class=\"math inline\">\\(\\ker \\Delta_{n-1}\\)</span> is\r\ngenerated by <span class=\"math inline\">\\(S_{n-1}\\)</span> over <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\prime}] := k[y_{1}, \\cdots ,\r\ny_{n-1}]\\)</span>, since <span\r\nclass=\"math inline\">\\(L^{\\Delta_{n-1}}_{i,j} =\r\nL^{\\Delta_{n}}_{i,j}\\)</span> for each <span class=\"math inline\">\\(i,\r\nj\\)</span>.</p>\r\n<p>Step <span class=\"math inline\">\\(n\\)</span>. Split the theorem into\r\nseveral lemmas.</p>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>The <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\prime}]\\)</span>-derivation <span\r\nclass=\"math inline\">\\(\\Delta_{n-1}\\)</span> that naturally extends to a\r\n<span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>-derivation <span\r\nclass=\"math inline\">\\((\\Delta_{n-1})_{k[\\mathbf{y}]}\\)</span> of <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}^{\\prime}] :=\r\nk[\\mathbf{y}][x_{1}, \\cdots, x_{n-1}]\\)</span> satisfies</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n} =\r\nk[\\mathbf{y}][S_{n-1}].\r\n\\end{equation}\\]</span></p>\r\n<h2 id=\"proof-of-lemma-1\">Proof of Lemma 1</h2>\r\n<p>As discussed in Section 1, then <span\r\nclass=\"math inline\">\\((\\Delta_{n-1})k[\\mathbf{y}] =\r\n\\Delta_{n}|_{k[\\mathbf{y}][\\mathbf{x}^{\\prime}]}\\)</span>, so we have\r\n<span class=\"math inline\">\\(\\ker(\\Delta_{n-1})k[\\mathbf{y}] =\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n}\\)</span>.\r\nMoreover, <span class=\"math inline\">\\(\\ker(\\Delta_{n-1})k[\\mathbf{y}] =\r\nk[\\mathbf{y}] \\otimes_{k[\\mathbf{y}^{\\prime}]} \\ker\r\n\\Delta_{n-1}\\)</span>, since <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}]\\)</span> is flat over <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\prime}]\\)</span>. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<p>Let <span class=\"math inline\">\\(\\mathbf{e}_{1}, \\cdots ,\r\n\\mathbf{e}_{n}\\)</span> be the coordinate unit vectors of <span\r\nclass=\"math inline\">\\(\\mathbb{R}^{n}\\)</span>, <span\r\nclass=\"math inline\">\\(M\\)</span> the <span\r\nclass=\"math inline\">\\(\\mathbb{Z}\\)</span>-submodule of <span\r\nclass=\"math inline\">\\((\\mathbb{Z}^{n})^{2}\\)</span> generated by <span\r\nclass=\"math inline\">\\((\\mathbf{e}_{j} - \\mathbf{e}_{i}, \\mathbf{e}_{i} -\r\n\\mathbf{e}_{j})\\)</span> for <span class=\"math inline\">\\(1 \\leq i &lt; j\r\n\\leq n\\)</span>, and <span class=\"math inline\">\\(\\Gamma =\r\n(\\mathbb{Z}^{n})^{2}/M\\)</span>.</p>\r\n<h2 id=\"theorem-2\">Theorem 2</h2>\r\n<p>For each <span class=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span>, we\r\ndefine <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma}\\)</span> to be\r\nthe <span class=\"math inline\">\\(k\\)</span>-vector space generated by\r\n<span class=\"math inline\">\\(\\mathbf{y}^{a}\\mathbf{x}^{b}:= y^{a_{1}}\r\n\\cdots y^{a_{n}} x^{b_{1}} \\cdots x^{b_{n}}\\)</span> for <span\r\nclass=\"math inline\">\\(a = (a_{1}, \\cdots , a_{n})\\)</span> and <span\r\nclass=\"math inline\">\\(b = (b_{1}, \\cdots , b_{n})\\)</span> in <span\r\nclass=\"math inline\">\\((\\mathbb{Z}_{\\geq 0})^{n}\\)</span> such that the\r\nimage of <span class=\"math inline\">\\((a, b)\\)</span> in <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span> is equal to <span\r\nclass=\"math inline\">\\(\\gamma\\)</span>. Then</p>\r\n<p><span class=\"math display\">\\[\\ker \\Delta_{n} = \\bigoplus_{\\gamma \\in\r\n\\Gamma} k[\\mathbf{y}] [ \\mathbf{x}]_{\\gamma} \\cap \\ker\r\n\\Delta_{n}\\]</span></p>\r\n<h2 id=\"proof-of-theorem-2\">Proof of Theorem 2</h2>\r\n<p>Note that <span\r\nclass=\"math inline\">\\(\\Delta_{n}(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma})\\)</span>\r\nis contained in <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma -\r\n\\delta}\\)</span> for each <span class=\"math inline\">\\(\\gamma \\in\r\n\\Gamma\\)</span>, where <span class=\"math inline\">\\(\\delta\\)</span> is\r\nthe image of <span class=\"math inline\">\\((-\\mathbb{e}_{n},\r\n\\mathbb{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span>.\r\n<span class=\"math inline\">\\(\\square\\)</span></p>\r\n<p>Hence, we are reduced to showing that each <span\r\nclass=\"math inline\">\\(0 \\neq \\varPhi \\in\r\nk[\\mathbf{y}][\\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}\\)</span> belongs\r\nto <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> for <span\r\nclass=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span>.</p>\r\n<p>We may find <span class=\"math inline\">\\(a = (a_{1}, \\cdots , a_{n})\r\n\\in \\mathbb{Z}^{n}\\)</span> and <span class=\"math inline\">\\(l \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> such that the image of <span\r\nclass=\"math inline\">\\((a, l\\mathbf{e}_{n})\\)</span> in <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span> is equal to <span\r\nclass=\"math inline\">\\(\\gamma\\)</span>. Let <span\r\nclass=\"math inline\">\\(m\\)</span> be the <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degree of <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span>, where <span\r\nclass=\"math inline\">\\(0 \\leq m \\leq l\\)</span>, and <span\r\nclass=\"math inline\">\\(\\phi \\in\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}]\\)</span> the coefficient of <span\r\nclass=\"math inline\">\\(x_{n}^{m}\\)</span> in <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span>. By replacing <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span> if necessary, we may assume that\r\n<span class=\"math inline\">\\(m\\)</span> is the minimum among the <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degrees of elements of <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\backslash\r\nk[\\mathbf{y}][S_{n}]\\)</span>.</p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>Write <span class=\"math inline\">\\(\\phi\\)</span> in expression of sum\r\nof <span class=\"math inline\">\\(y_{1}\\cdots y_{n}\\)</span></p>\r\n<p><span class=\"math display\">\\[\\phi = y_{n}^{s}\\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})}\r\n\\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(L^{\\mathbf{u}} = \\prod_{1 \\leq\r\ni&lt;j\\leq n-1} L_{i,j}^{u_{i,j}}\\)</span> for each <span\r\nclass=\"math inline\">\\(\\mathbf{u}\\)</span>. There holds the identity</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\r\n\\end{equation}\\]</span></p>\r\n<h2 id=\"lemma-3\">Lemma 3</h2>\r\n<p>There holds the inequality</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm \\geq 2l - \\sum_{i=1}^{n-1} a_{i}.\r\n\\end{equation}\\]</span></p>\r\n<h2 id=\"proof-of-lemma-2\">Proof of Lemma 2</h2>\r\n<p>then, <span class=\"math inline\">\\(\\phi\\)</span> belongs to <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\mu}\\)</span>, where\r\n<span class=\"math inline\">\\(\\mu\\)</span> is the image of <span\r\nclass=\"math inline\">\\((a, (l - m)\\mathbf{e}_{n})\\)</span> in <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span>. Furthermore, <span\r\nclass=\"math inline\">\\(0 = \\Delta_{n}(\\varPhi) =\r\n\\Delta_{n}(\\varphi)x^{m}_{n} + m\\phi y_{n}x_{n}^{m-1} +\r\n\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})\\)</span>, and the <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degrees of <span\r\nclass=\"math inline\">\\(m\\phi y_{n}x_{n}^{m-1}\\)</span> and <span\r\nclass=\"math inline\">\\(\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})\\)</span> are\r\nat most <span class=\"math inline\">\\(m - 1\\)</span>. Hence, <span\r\nclass=\"math inline\">\\(\\Delta_{n}(\\phi) = 0\\)</span>. Thus, <span\r\nclass=\"math inline\">\\(\\phi\\)</span> belongs to <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][S_{n-1}]\\)</span> by (1). Write\r\n<span class=\"math inline\">\\(\\phi = \\sum_{b,\\mathbf{u}}\r\nr^{\\prime}_{b,\\mathbf{u}}y^{b}\\hat{y}^{-\\mathbf{u}}L^{\\mathbf{u}}\\)</span>,\r\nwhere the sum is taken over <span class=\"math inline\">\\(b \\in\r\n(\\mathbb{Z}_{\\geq 0})^{n}\\)</span> and <span class=\"math inline\">\\(u =\r\n(u_{i,j})_{i,j}\\)</span> with <span class=\"math inline\">\\(u_{i,j} \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> for <span class=\"math inline\">\\(1 \\leq i\r\n&lt; j \\leq n - 1\\)</span>, <span\r\nclass=\"math inline\">\\(r^{\\prime}_{b,\\mathbf{u}} \\in k\\)</span> for each\r\n<span class=\"math inline\">\\(b\\)</span> and <span\r\nclass=\"math inline\">\\(\\mathbf{u}\\)</span>, and</p>\r\n<p><span class=\"math inline\">\\(\\hat{y}^{-u} = \\prod_{1\\leq i &lt; j \\leq\r\nn-1} (y_{i}y_{j})^{-u_{i,j}}, \\quad L^{\\mathbf{u}} = \\prod_{1 \\leq\r\ni&lt;j\\leq n-1} L_{i,j}^{u_{i,j}}\\)</span> for each <span\r\nclass=\"math inline\">\\(\\mathbf{u}\\)</span>.</p>\r\n<p>We may assume that <span\r\nclass=\"math inline\">\\(r_{b,\\mathbf{u}}^{\\prime} = 0\\)</span> if <span\r\nclass=\"math inline\">\\(\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}\\)</span>\r\nis not in <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>. Let <span\r\nclass=\"math inline\">\\(\\eta(b, \\mathbf{u})\\)</span> be the image of <span\r\nclass=\"math inline\">\\((b - |\\mathbf{u}|\\mathbf{e}_{n},\r\n|\\mathbf{u}|\\mathbf{e}_{n})\\)</span> in <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span>, where <span\r\nclass=\"math inline\">\\(|\\mathbf{u}| = \\sum_{i,j} u_{i,j}\\)</span>. Then,\r\n<span\r\nclass=\"math inline\">\\(\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}L^{\\mathbf{u}}\\)</span>\r\nbelongs to <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\eta(b,\\mathbf{u})}\\)</span> for each <span\r\nclass=\"math inline\">\\(b\\)</span> and <span\r\nclass=\"math inline\">\\(\\mathbf{u}\\)</span> where <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}] :=\r\nk[\\mathbf{y}][\\mathbf{x}][(y_{1} \\cdots y_{n})^{-1}]\\)</span>, since\r\n<span class=\"math inline\">\\((y_{i}y_{j})^{-1} L_{i,j}\\)</span> belongs\r\nto <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\delta}\\)</span> for each <span\r\nclass=\"math inline\">\\(i, j\\)</span>. Since <span\r\nclass=\"math inline\">\\(\\phi\\)</span> is in <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\mu}\\)</span>, and\r\n<span class=\"math inline\">\\(\\mu\\)</span> is the image of <span\r\nclass=\"math inline\">\\((a, (l - m)\\mathbf{e}_{n})\\)</span>, we may assume\r\nthat <span class=\"math inline\">\\(r_{b,\\mathbf{u}}^{\\prime} = 0\\)</span>\r\nunless <span class=\"math inline\">\\(|u| = l - m\\)</span> and <span\r\nclass=\"math inline\">\\(b = a + (l - m)\\mathbf{e}_{n}\\)</span>. For each\r\n<span class=\"math inline\">\\(\\mathbf{u}\\)</span> with <span\r\nclass=\"math inline\">\\(r_{\\mathbf{u}} := r^{\\prime}_{a + (l-m)\r\n\\mathbf{e}_{n},\\mathbf{u}}\\neq 0\\)</span>, write <span\r\nclass=\"math inline\">\\(\\mathbf{y}^{a} y_{n}^{l-m}\r\n\\hat{\\mathbf{y}}^{-\\mathbf{u}} = y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots\r\ny_{n-1}^{\\rho_{n-1}(\\mathbf{u})} y_{n}^{s}\\)</span>, where <span\r\nclass=\"math inline\">\\(\\rho_{i}(u) \\in \\mathbb{Z}_{\\geq 0}\\)</span> for\r\n<span class=\"math inline\">\\(i = 1, \\cdots , n - 1\\)</span>, and <span\r\nclass=\"math inline\">\\(s = a_{n} + l - m\\)</span>. Then, we have <span\r\nclass=\"math inline\">\\(\\phi = y_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}}\r\ny_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots y_{n-1}^{\\rho_{n-1}(\\mathbf{u})}\r\nL^{\\mathbf{u}}\\)</span>. Since <span class=\"math inline\">\\(|u| = l -\r\nm\\)</span>, it follows that</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\r\n\\end{equation}\\]</span></p>\r\n<h2 id=\"proof-of-lemma-3\">Proof of Lemma 3</h2>\r\n<p>Take <span class=\"math inline\">\\(\\varPhi\\)</span> which does not\r\nsatisfy (3) so that <span class=\"math inline\">\\(m\\)</span> would be the\r\nminimum among the <span class=\"math inline\">\\(x_{n}\\)</span>-degrees of\r\nsuch polynomials. Then, <span class=\"math inline\">\\(t:= 2l -\r\n\\sum_{i=1}^{n-1}a_{i} -m\\)</span> is positive, and <span\r\nclass=\"math inline\">\\(\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) = m -\r\nt\\)</span> for each <span class=\"math inline\">\\(\\mathbf{u}\\)</span> by\r\n(2). Hence, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree of</p>\r\n<p><span class=\"math display\">\\[\\varPhi_{1}:= \\sum_{\\mathbf{u}}\r\n\\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\nL_{n,i}^{\\rho_{i}(\\mathbf{u})} = \\sum_{\\mathbf{u}} r_{\\mathbf{u}}\r\nL^{\\mathbf{u}} \\prod_{i=1}^{n-1} (y_{i}x_{n} -\r\ny_{n}x_{i})^{\\rho_{i}(\\mathbf{u})}\\]</span></p>\r\n<p>is <span class=\"math inline\">\\(m - t\\)</span>. The coefficient of\r\n<span class=\"math inline\">\\(x_{n}^{n-t}\\)</span> in <span\r\nclass=\"math inline\">\\(y_{n}^{s}\\varPhi_{1}\\)</span> is equal to <span\r\nclass=\"math inline\">\\(\\phi\\)</span>, so the coefficient of <span\r\nclass=\"math inline\">\\(x_{n}^{m}\\)</span> in <span\r\nclass=\"math inline\">\\(y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span> is equal\r\nto that in <span class=\"math inline\">\\(y_{1}^{t}\\varPhi\\)</span>.\r\nConsequently, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree\r\n<span class=\"math inline\">\\(m^{\\prime}\\)</span> of <span\r\nclass=\"math inline\">\\(\\varPhi_{2}:= y_{1}^{t}\\varPhi -\r\ny_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span> is less than <span\r\nclass=\"math inline\">\\(m\\)</span>. We claim that <span\r\nclass=\"math inline\">\\(\\varPhi_{2} = 0\\)</span>. In fact, if <span\r\nclass=\"math inline\">\\(\\gamma^{\\prime}\\)</span> is the image of <span\r\nclass=\"math inline\">\\((a + t\\mathbf{e}_{1}, l\\mathbf{e}_{n})\\)</span> in\r\n<span class=\"math inline\">\\(\\Gamma\\)</span>, and <span\r\nclass=\"math inline\">\\((a^{\\prime}_{1}, \\cdots , a_{n}^{\\prime} ) := a +\r\nt\\mathbf{e}_{1}\\)</span>, then <span\r\nclass=\"math inline\">\\(\\varPhi_{2}\\)</span> belongs to <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma^{\\prime}} \\cap\r\n\\ker \\Delta_{n}\\)</span>, and</p>\r\n<p><span class=\"math display\">\\[2l - \\sum_{i=1}^{n-1} a^{\\prime}_{i} =\r\n2l - \\sum_{i=1}^{n-1} a_{i} - t = m &gt; m^{\\prime}\\]</span></p>\r\n<p>This implies that <span class=\"math inline\">\\(\\varPhi_{2} =\r\n0\\)</span> by the minimality of <span class=\"math inline\">\\(m\\)</span>.\r\nHence, <span class=\"math inline\">\\(y_{1}^{t} \\varPhi=\r\ny_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span>. Thus, <span\r\nclass=\"math inline\">\\(\\varPhi_{1}\\)</span> is divisible by <span\r\nclass=\"math inline\">\\(y_{1}\\)</span>, since neither are <span\r\nclass=\"math inline\">\\(y_{n}\\)</span> and <span\r\nclass=\"math inline\">\\(L_{n,1}\\)</span>. Recall that the kernel of a\r\nlocally nilpotent derivation <span class=\"math inline\">\\(D\\)</span> of\r\nan integral domain <span class=\"math inline\">\\(R\\)</span> containing\r\n<span class=\"math inline\">\\(Q\\)</span> is factorially closed in <span\r\nclass=\"math inline\">\\(R\\)</span>, that is, <span\r\nclass=\"math inline\">\\(D(f g) = 0\\)</span> implies <span\r\nclass=\"math inline\">\\(D(f ) = D(g) = 0\\)</span> for each <span\r\nclass=\"math inline\">\\(f, g \\in R \\ \\{0\\}\\)</span> (cf. [2, Proposition\r\n1.3.32 (iii)]). Note that <span\r\nclass=\"math inline\">\\(\\Delta_{n}\\)</span> is locally nilpotent, <span\r\nclass=\"math inline\">\\(\\Delta_{n}(\\varPhi_{1}) = 0\\)</span>, <span\r\nclass=\"math inline\">\\(\\varPhi_{1} \\neq 0\\)</span> and <span\r\nclass=\"math inline\">\\(\\Delta_{n}(x_{n}) \\neq 0\\)</span>. Hence, <span\r\nclass=\"math inline\">\\(\\varPhi_{1}\\)</span> is not divisible by <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>. By substituting zero for <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>, we obtain from <span\r\nclass=\"math inline\">\\(\\varPhi_{1}\\)</span> a nonzero polynomial</p>\r\n<p><span class=\"math display\">\\[\\sum_{\\mathbf{u}}r_{\\mathbf{u}}\r\nL^{\\mathbf{u}} \\prod_{i=1}^{n-1} (- y_{n} x_{i})^{\\rho_{i}(\\mathbf{u})}\r\n= ( - y_{n} )^{m-i} \\varPsi, \\text{ where } \\varPsi = \\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\nx_{i}^{\\rho_{i}(\\mathbf{u})}.\\]</span></p>\r\n<p>Then, <span class=\"math inline\">\\(\\varPhi \\neq 0\\)</span>, and <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span> is divisible by <span\r\nclass=\"math inline\">\\(y_{1}\\)</span>, since so is <span\r\nclass=\"math inline\">\\(\\phi_{1}\\)</span>. Define <span\r\nclass=\"math inline\">\\(\\sigma \\in \\text{Aut}_{k}\r\nk[\\mathbf{y}][\\mathbf{x}]\\)</span> by <span\r\nclass=\"math inline\">\\(\\sigma(x_{i}) = y_{i}\\)</span> and <span\r\nclass=\"math inline\">\\(\\sigma(y_{i}) = x_{i}\\)</span> for <span\r\nclass=\"math inline\">\\(i = 1, \\cdots, n\\)</span>. Then, <span\r\nclass=\"math inline\">\\(\\sigma(\\varPhi)\\)</span> is divisible by <span\r\nclass=\"math inline\">\\(x_{1}\\)</span>. On the other hand, <span\r\nclass=\"math inline\">\\(\\sigma(L_{i,j}) = L_{j,i}\\)</span> and <span\r\nclass=\"math inline\">\\(\\sigma(x_{i}) = y_{i}\\)</span> are in <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> for each <span\r\nclass=\"math inline\">\\(i, j\\)</span>, so <span\r\nclass=\"math inline\">\\(\\sigma(\\varPsi)\\)</span> belongs to <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span>. Thus, we have <span\r\nclass=\"math inline\">\\(\\sigma(\\varPsi) = 0\\)</span>, because <span\r\nclass=\"math inline\">\\(x_{1}\\)</span> is not in <span\r\nclass=\"math inline\">\\(\\ker \\Delta_[n]\\)</span> and <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> is factorially closed in\r\n<span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span>. This\r\ncontradicts that <span class=\"math inline\">\\(\\varPsi \\neq 0\\)</span>.\r\n<span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"proof-of-theorem-1-1\">Proof of Theorem 1</h2>\r\n<p>In fact, (3) implies that <span\r\nclass=\"math inline\">\\(\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) \\geq\r\nm\\)</span> by (2), so we have <span\r\nclass=\"math inline\">\\(\\sum_{i=1}^{n-1}\\rho_{i}^{\\prime}(\\mathbf{u}) =\r\nm\\)</span> for some integers <span class=\"math inline\">\\(0 \\leq\r\n\\rho^{\\prime}_{i}(\\mathbf{u}) \\leq \\rho_{i}(\\mathbf{u})\\)</span> for\r\n<span class=\"math inline\">\\(i = 1, \\cdots, n - 1\\)</span> for each <span\r\nclass=\"math inline\">\\(u\\)</span>. Then,</p>\r\n<p><span class=\"math display\">\\[\\varPhi^{\\prime} := y_{n}^{s}\r\n\\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\ny_{i}^{\\rho_{i}(\\mathbf{u}) - \\rho_{i}^{\\prime}(\\mathbf{u})}\r\nL_{n,i}^{\\rho_{i}^{\\prime}(\\mathbf{u})} = y_{n}^{s} \\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}) -\r\n\\rho_{i}^{\\prime}(\\mathbf{u}) } (y_{i}x_{n} -\r\nx_{n}y_{i})^{\\rho_{i}^{\\prime}(\\mathbf{u}) }\\]</span></p>\r\n<p>is an element of <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> having <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degree <span\r\nclass=\"math inline\">\\(m\\)</span>, in which the coefficient of <span\r\nclass=\"math inline\">\\(x_{n}^{m}\\)</span> is equal to <span\r\nclass=\"math inline\">\\(\\phi\\)</span>. Hence, the <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degree of <span\r\nclass=\"math inline\">\\(\\varPhi - \\varPhi^{\\prime}\\)</span> is less than\r\n<span class=\"math inline\">\\(m\\)</span>. Since <span\r\nclass=\"math inline\">\\(\\varPhi - \\varPhi^{\\prime}\\)</span> is an element\r\nof <span class=\"math inline\">\\(\\ker \\Delta_{n} \\backslash\r\nk[\\mathbf{y}][S_{n}]\\)</span>, this contradicts the minimality of <span\r\nclass=\"math inline\">\\(m\\)</span>. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Dec 31 2023 15:45:36 GMT+0800 ()","title":"Nowicki Conjecture","path":"2023/04/11/Nowicki Conjecture/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-04-11T08:28:25.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-04-11T08:28:25.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Notes","tags":["Notes"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Hilbert's 13th Problem","date":"2023-03-23T02:35:56.000Z","mathjax":true,"_content":"\n## Theorem 1\nFor any integer $n\\geq 2$ there are continuous real functions $\\psi^{p,q}(x)$ on the closed unit interval $E^{1} = [0,1]$ such that each continuous real function $f(x_{1},\\cdots,x_{n})$ on the $n$-dimensional unit cube $E^{n}$ is representable as \n\n$$f(x_{1},\\cdots,x_{n}) = \\sum_{q=1}^{2n+1} \\chi^{q} \\left[\\sum_{p=1}^{n} \\psi^{p,q}(x_{p})\\right]$$\n\nwhere $\\chi^{q}(y)$ are continuous real function.\n\n\n<br>\n\n**Step 1**: *Construction of the functions $\\psi^{pq}$*.\n\n\nConsider the closed intervals\n\n$$\\begin{aligned}\n& A_{k,i}^{q} = \\left[\\frac{1}{(9n)^{k}}\\left(i - 1 - \\frac{q}{3n}\\right), \\frac{1}{(9n)^{k}}\\left(i - \\frac{1}{3n} - \\frac{q}{3n}\\right)\\right],\\\\\n&\\qquad \\qquad \\qquad \\qquad 1\\leq i \\leq (9n)^{k} +1, 1\\leq q \\leq 2n +1, k= 1,2,\\cdots\n\\end{aligned}$$\n\nwith lengths $\\frac{1}{9n}^{k} ( 1 - \\frac{1}{3n})$ and \nAccordingly, for fixed $k$ and $q$ by passing $i$ to $i+1$ using a shift to the right over a distance $1/(9n)^{k}$. Accordingly, for fixed $k$ and $q$ the cubes\n\n$$S_{k,i_{1},\\cdots,i_{n}}^{q} = \\prod_{p=1}^{n} A_{k,i_{p}}^{q}$$ \n\nwith edges of lengths $\\frac{1}{(9n)^{k}}$ cover the unit cube $E^{n}$ to within the separating slits of widths $\\frac{1}{3n(9n)^{k}}$. It's easy to verify the following\n\n## Lemma 1\nThe system of all cubes $S_{k,i_{1},\\cdots,i_{n}}^{q}$ with constant $k$ and variable $q$ and $i_{1},\\cdots,i_{n}$ covers the unit cube $E^{n}$ so that each point belonging to $E^{n}$ is covered by at least $n+1$ times. $\\label{lem 1}$\n\n<br>\n\nUsing induction on $k$ we can prove the following \n\n## Lemma 2\nThere exist constants $\\lambda^{pq}_{k,i}$ and $\\epsilon_{k}$ such that \n\n1. $\\lambda^{pq}_{k,i} \\leq \\lambda^{pq}_{k,i+1} \\leq \\lambda^{pq}_{k,i} + 1/2^{k}$;\n\n2. $\\lambda^{pq}_{k,i} \\leq \\lambda^{pq}_{k+1,i^{\\prime}} \\leq \\lambda^{pq}_{k,i} + \\epsilon_{k+1} - \\epsilon_{k}$ if the closed intevals $A_{k,i}^{q}$ and $A_{k+1,i^{\\prime}}^{q}$ do not intersect;\n\n3. the closed interval $\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}} = \\left[\\sum_{p}\\lambda^{pq}_{k,i_{p}}, \\sum_{p}\\lambda^{pq}_{k,i_{p}} + n \\epsilon_{k}\\right]$ are pairwise disjoint for fixed $k$ and $q$.\n\nIt's easy to note that 1. and 3. imply\n\n4. $\\epsilon \\leq 1/2^{k}$.\n\n\n## Lemma 3\n\nFor fixed $p$ and $q$ the condition\n\n5. $\\lambda^{pq}_{k,i} \\leq \\psi^{pq}(x) \\leq \\lambda^{pq}_{k,i} + \\epsilon_{k}$ uniquely determine a continuous function $\\psi^{pq}$ on $E^{1}$.\n\nFrom 5. and 3. it follows that \n\n6. $\\sum_{p} \\psi^{pq} (x_{p}) \\in \\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}$ for $(x_{1}, \\cdots, x_{n}) \\in S_{k,i_{1},\\cdots,i_{n}}^{q}$.\n\n<br> \n\n**Step 2**: *Construction of the functions $\\chi^{q}$*.\n\nLet $\\chi_{0}^{q} \\equiv 0$, while for $r >0$, $\\chi_{r}^{q}$ will be defined by induction on $r$ simultaneously with the natural number $k_{r}$.\n\nDenote as below\n\n$$\\begin{aligned}f_{r}(x_{1},\\cdots,x_{n}) = & \\sum_{q=1}^{2n+1} \\chi_{r}^{q}\\left[\\sum_{p} \\psi^{pq}(x_{p})\\right]\\\\\nM_{r}= & \\sup_{E^{n}} \\left|f -f_{r}\\right|\\end{aligned}$$\n\n**Inductive step:** Assuming $\\chi_{r-1}^{q}$ and $k_{r-1}$ have already been determined. \n\n**Passing to step $r$:**\n\nSince the diameter of the cubes $S_{k,i_{1},\\cdots,i_{n}}^{q}$ tend to zero as $k \\to \\infty$, we can choose $k_{r}$ so large that the oscillation of the difference $f - f_{r-1}$ does not exceed $M_{r}/(2n+2)$ on any $S_{k_{r},i_{1},\\cdots,i_{n}}^{q}$. \n\n\nLet $\\xi_{k,i}^{q}$ be arbitrary points belonging to the corresponding closed intervals $A_{k,i}^{q}$. For the closed interval $\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}$ we put \n\n$$\\begin{aligned}\\chi_{r}^{q}(y) = & \\chi_{r-1}^{q}(y) + \\frac{1}{n+1} \\left[f(\\xi_{k,i_{1}}^{q}, \\cdots, \\xi_{k,i_{n}}^{q}) - f_{r}(\\xi_{k,i_{1}}^{q}, \\cdots, \\xi_{k,i_{n}}^{q})\\right]\\\\\n& \\left|\\chi_{r}^{q} (y) - \\chi_{r-1}(y)\\right| \\leq \\frac{1}{n+1} M_{r-1}\\end{aligned}$$\n\nOutside the closed intervals $\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}$ the function $\\chi_{r}^{q}$ is defined arbitrarily, with the preservation of the inequality above and continuity. \n\n\n$$\\begin{aligned}f(x_{1},\\cdots,x_{n}) - f_{r}(x_{1},\\cdots,x_{n}) = f(x_{1},\\cdots,x_{n}) - f_{r-1}(x_{1},\\cdots,x_{n})\\\\ \n- \\sum_{q=1}^{2n+1} \\left\\{\\chi_{r}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] - \\chi_{r-1}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right]\\right\\}\\end{aligned}$$\n\nWe represent the sum in above equation in the form $\\sum^{\\prime} + \\sum^{\\prime\\prime}$, where the sum $\\sum^{\\prime}$ extends over certain $n+1$ values of $q$ for which the point $(x_{1},\\cdots,x_{n})$ is contained in one of the cubes $S_{k_{r},i_{1},\\cdots,i_{n}}^{q}$ (by Lemma 1$\\ref{lem 1}$, such cubes exist) and the sum $\\sum^{\\prime\\prime}$ extends over the remaining $n$ values of $q$. Hence, for each term in $\\sum^{\\prime}$ we have\n\n$$\\begin{aligned}\n&\\chi_{r}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] - \\chi_{r-1}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] \\\\\n= \\frac{1}{n+1} &\\left[f(\\xi_{k,i_{1}}^{q}, \\cdots, \\xi_{k,i_{n}}^{q}) - f_{r-1}(\\xi_{k,i_{1}}^{q}, \\cdots, \\xi_{k,i_{n}}^{q})\\right] \\\\\n= \\frac{1}{n+1} & \\left[f(x_{1},\\cdots,x_{n}) - f_{r-1}(x_{1},\\cdots,x_{n})\\right] + \\frac{\\omega^{q}}{n+1}\n\\end{aligned}$$\n\nwhere \n\n$$|\\omega^{q}| \\leq \\frac{1}{2n+2}M_{r}$$\n\nwhich implies\n\n$$\\begin{aligned}|f - f_{r}| = \\left|\\frac{1}{n+1} \\sum^{\\prime}\\omega^{q} + \\sum^{\\prime \\prime} (\\chi_{r}^{q} - \\chi_{r-1}^{q})\\right| \\leq \\\\\n\\frac{1}{2n+2} M_{r-1} + \\frac{n}{n+1} M_{r-1} = \\frac{2n +1}{2n +2} M_{r-1} \\end{aligned}$$\n\nSince inequality holds at any point $(x_{1},\\cdots,x_{n}) \\in E^{n}$, it follows that the absolute values of the differences $\\chi^{q} - \\chi_{r}^{q}$ do not exceed the corresponding terms of the absolutely convergent series \n\n$$\\sum_{r} \\frac{1}{n+1} M_{r-1}$$\n\nTherefore the functions $\\chi_{r}^{q}$ converges uniformly to continuous limit functions $\\chi^{q}$ for $r\\to \\infty$.\n\n<br>\n\n# Reference:\n\n\n[1] Kolmogorov, A. N. (1957). On the representation of continuous functions of several variables by superposition of continuous functions of one variable and addition. (in Russian) In Doklady Akademii Nauk (Vol. 114, No. 5, pp. 953-956). Russian Academy of Sciences.\n\n[2] Arnold, V. I. (1957). On functions of three variables. (in Russian) Collected Works: Representations of Functions, Celestial Mechanics and KAM Theory, 19571965, 5-8.\n\n\n","source":"_posts/Hilbert13.md","raw":"---\ntitle: Hilbert's 13th Problem\ndate: 2023-03-23 10:35:56\ntags:\n    - [Notes]\n    - [Hilbert's 23 Problems]\ncategories:\n    - [Notes]\n    - [History of Mathematics, Hilbert's 23 Problems]\nmathjax: true\n---\n\n## Theorem 1\nFor any integer $n\\geq 2$ there are continuous real functions $\\psi^{p,q}(x)$ on the closed unit interval $E^{1} = [0,1]$ such that each continuous real function $f(x_{1},\\cdots,x_{n})$ on the $n$-dimensional unit cube $E^{n}$ is representable as \n\n$$f(x_{1},\\cdots,x_{n}) = \\sum_{q=1}^{2n+1} \\chi^{q} \\left[\\sum_{p=1}^{n} \\psi^{p,q}(x_{p})\\right]$$\n\nwhere $\\chi^{q}(y)$ are continuous real function.\n\n\n<br>\n\n**Step 1**: *Construction of the functions $\\psi^{pq}$*.\n\n\nConsider the closed intervals\n\n$$\\begin{aligned}\n& A_{k,i}^{q} = \\left[\\frac{1}{(9n)^{k}}\\left(i - 1 - \\frac{q}{3n}\\right), \\frac{1}{(9n)^{k}}\\left(i - \\frac{1}{3n} - \\frac{q}{3n}\\right)\\right],\\\\\n&\\qquad \\qquad \\qquad \\qquad 1\\leq i \\leq (9n)^{k} +1, 1\\leq q \\leq 2n +1, k= 1,2,\\cdots\n\\end{aligned}$$\n\nwith lengths $\\frac{1}{9n}^{k} ( 1 - \\frac{1}{3n})$ and \nAccordingly, for fixed $k$ and $q$ by passing $i$ to $i+1$ using a shift to the right over a distance $1/(9n)^{k}$. Accordingly, for fixed $k$ and $q$ the cubes\n\n$$S_{k,i_{1},\\cdots,i_{n}}^{q} = \\prod_{p=1}^{n} A_{k,i_{p}}^{q}$$ \n\nwith edges of lengths $\\frac{1}{(9n)^{k}}$ cover the unit cube $E^{n}$ to within the separating slits of widths $\\frac{1}{3n(9n)^{k}}$. It's easy to verify the following\n\n## Lemma 1\nThe system of all cubes $S_{k,i_{1},\\cdots,i_{n}}^{q}$ with constant $k$ and variable $q$ and $i_{1},\\cdots,i_{n}$ covers the unit cube $E^{n}$ so that each point belonging to $E^{n}$ is covered by at least $n+1$ times. $\\label{lem 1}$\n\n<br>\n\nUsing induction on $k$ we can prove the following \n\n## Lemma 2\nThere exist constants $\\lambda^{pq}_{k,i}$ and $\\epsilon_{k}$ such that \n\n1. $\\lambda^{pq}_{k,i} \\leq \\lambda^{pq}_{k,i+1} \\leq \\lambda^{pq}_{k,i} + 1/2^{k}$;\n\n2. $\\lambda^{pq}_{k,i} \\leq \\lambda^{pq}_{k+1,i^{\\prime}} \\leq \\lambda^{pq}_{k,i} + \\epsilon_{k+1} - \\epsilon_{k}$ if the closed intevals $A_{k,i}^{q}$ and $A_{k+1,i^{\\prime}}^{q}$ do not intersect;\n\n3. the closed interval $\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}} = \\left[\\sum_{p}\\lambda^{pq}_{k,i_{p}}, \\sum_{p}\\lambda^{pq}_{k,i_{p}} + n \\epsilon_{k}\\right]$ are pairwise disjoint for fixed $k$ and $q$.\n\nIt's easy to note that 1. and 3. imply\n\n4. $\\epsilon \\leq 1/2^{k}$.\n\n\n## Lemma 3\n\nFor fixed $p$ and $q$ the condition\n\n5. $\\lambda^{pq}_{k,i} \\leq \\psi^{pq}(x) \\leq \\lambda^{pq}_{k,i} + \\epsilon_{k}$ uniquely determine a continuous function $\\psi^{pq}$ on $E^{1}$.\n\nFrom 5. and 3. it follows that \n\n6. $\\sum_{p} \\psi^{pq} (x_{p}) \\in \\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}$ for $(x_{1}, \\cdots, x_{n}) \\in S_{k,i_{1},\\cdots,i_{n}}^{q}$.\n\n<br> \n\n**Step 2**: *Construction of the functions $\\chi^{q}$*.\n\nLet $\\chi_{0}^{q} \\equiv 0$, while for $r >0$, $\\chi_{r}^{q}$ will be defined by induction on $r$ simultaneously with the natural number $k_{r}$.\n\nDenote as below\n\n$$\\begin{aligned}f_{r}(x_{1},\\cdots,x_{n}) = & \\sum_{q=1}^{2n+1} \\chi_{r}^{q}\\left[\\sum_{p} \\psi^{pq}(x_{p})\\right]\\\\\nM_{r}= & \\sup_{E^{n}} \\left|f -f_{r}\\right|\\end{aligned}$$\n\n**Inductive step:** Assuming $\\chi_{r-1}^{q}$ and $k_{r-1}$ have already been determined. \n\n**Passing to step $r$:**\n\nSince the diameter of the cubes $S_{k,i_{1},\\cdots,i_{n}}^{q}$ tend to zero as $k \\to \\infty$, we can choose $k_{r}$ so large that the oscillation of the difference $f - f_{r-1}$ does not exceed $M_{r}/(2n+2)$ on any $S_{k_{r},i_{1},\\cdots,i_{n}}^{q}$. \n\n\nLet $\\xi_{k,i}^{q}$ be arbitrary points belonging to the corresponding closed intervals $A_{k,i}^{q}$. For the closed interval $\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}$ we put \n\n$$\\begin{aligned}\\chi_{r}^{q}(y) = & \\chi_{r-1}^{q}(y) + \\frac{1}{n+1} \\left[f(\\xi_{k,i_{1}}^{q}, \\cdots, \\xi_{k,i_{n}}^{q}) - f_{r}(\\xi_{k,i_{1}}^{q}, \\cdots, \\xi_{k,i_{n}}^{q})\\right]\\\\\n& \\left|\\chi_{r}^{q} (y) - \\chi_{r-1}(y)\\right| \\leq \\frac{1}{n+1} M_{r-1}\\end{aligned}$$\n\nOutside the closed intervals $\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}$ the function $\\chi_{r}^{q}$ is defined arbitrarily, with the preservation of the inequality above and continuity. \n\n\n$$\\begin{aligned}f(x_{1},\\cdots,x_{n}) - f_{r}(x_{1},\\cdots,x_{n}) = f(x_{1},\\cdots,x_{n}) - f_{r-1}(x_{1},\\cdots,x_{n})\\\\ \n- \\sum_{q=1}^{2n+1} \\left\\{\\chi_{r}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] - \\chi_{r-1}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right]\\right\\}\\end{aligned}$$\n\nWe represent the sum in above equation in the form $\\sum^{\\prime} + \\sum^{\\prime\\prime}$, where the sum $\\sum^{\\prime}$ extends over certain $n+1$ values of $q$ for which the point $(x_{1},\\cdots,x_{n})$ is contained in one of the cubes $S_{k_{r},i_{1},\\cdots,i_{n}}^{q}$ (by Lemma 1$\\ref{lem 1}$, such cubes exist) and the sum $\\sum^{\\prime\\prime}$ extends over the remaining $n$ values of $q$. Hence, for each term in $\\sum^{\\prime}$ we have\n\n$$\\begin{aligned}\n&\\chi_{r}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] - \\chi_{r-1}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] \\\\\n= \\frac{1}{n+1} &\\left[f(\\xi_{k,i_{1}}^{q}, \\cdots, \\xi_{k,i_{n}}^{q}) - f_{r-1}(\\xi_{k,i_{1}}^{q}, \\cdots, \\xi_{k,i_{n}}^{q})\\right] \\\\\n= \\frac{1}{n+1} & \\left[f(x_{1},\\cdots,x_{n}) - f_{r-1}(x_{1},\\cdots,x_{n})\\right] + \\frac{\\omega^{q}}{n+1}\n\\end{aligned}$$\n\nwhere \n\n$$|\\omega^{q}| \\leq \\frac{1}{2n+2}M_{r}$$\n\nwhich implies\n\n$$\\begin{aligned}|f - f_{r}| = \\left|\\frac{1}{n+1} \\sum^{\\prime}\\omega^{q} + \\sum^{\\prime \\prime} (\\chi_{r}^{q} - \\chi_{r-1}^{q})\\right| \\leq \\\\\n\\frac{1}{2n+2} M_{r-1} + \\frac{n}{n+1} M_{r-1} = \\frac{2n +1}{2n +2} M_{r-1} \\end{aligned}$$\n\nSince inequality holds at any point $(x_{1},\\cdots,x_{n}) \\in E^{n}$, it follows that the absolute values of the differences $\\chi^{q} - \\chi_{r}^{q}$ do not exceed the corresponding terms of the absolutely convergent series \n\n$$\\sum_{r} \\frac{1}{n+1} M_{r-1}$$\n\nTherefore the functions $\\chi_{r}^{q}$ converges uniformly to continuous limit functions $\\chi^{q}$ for $r\\to \\infty$.\n\n<br>\n\n# Reference:\n\n\n[1] Kolmogorov, A. N. (1957). On the representation of continuous functions of several variables by superposition of continuous functions of one variable and addition. (in Russian) In Doklady Akademii Nauk (Vol. 114, No. 5, pp. 953-956). Russian Academy of Sciences.\n\n[2] Arnold, V. I. (1957). On functions of three variables. (in Russian) Collected Works: Representations of Functions, Celestial Mechanics and KAM Theory, 19571965, 5-8.\n\n\n","slug":"Hilbert13","published":1,"updated":"2024-01-03T02:56:24.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisune000beslrbdvkb483","content":"<h2 id=\"theorem-1\">Theorem 1</h2>\r\n<p>For any integer <span class=\"math inline\">\\(n\\geq 2\\)</span> there\r\nare continuous real functions <span\r\nclass=\"math inline\">\\(\\psi^{p,q}(x)\\)</span> on the closed unit interval\r\n<span class=\"math inline\">\\(E^{1} = [0,1]\\)</span> such that each\r\ncontinuous real function <span\r\nclass=\"math inline\">\\(f(x_{1},\\cdots,x_{n})\\)</span> on the <span\r\nclass=\"math inline\">\\(n\\)</span>-dimensional unit cube <span\r\nclass=\"math inline\">\\(E^{n}\\)</span> is representable as</p>\r\n<p><span class=\"math display\">\\[f(x_{1},\\cdots,x_{n}) =\r\n\\sum_{q=1}^{2n+1} \\chi^{q} \\left[\\sum_{p=1}^{n}\r\n\\psi^{p,q}(x_{p})\\right]\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(\\chi^{q}(y)\\)</span> are continuous\r\nreal function.</p>\r\n<p><br></p>\r\n<p><strong>Step 1</strong>: <em>Construction of the functions <span\r\nclass=\"math inline\">\\(\\psi^{pq}\\)</span></em>.</p>\r\n<p>Consider the closed intervals</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n&amp; A_{k,i}^{q} = \\left[\\frac{1}{(9n)^{k}}\\left(i - 1 -\r\n\\frac{q}{3n}\\right), \\frac{1}{(9n)^{k}}\\left(i - \\frac{1}{3n} -\r\n\\frac{q}{3n}\\right)\\right],\\\\\r\n&amp;\\qquad \\qquad \\qquad \\qquad 1\\leq i \\leq (9n)^{k} +1, 1\\leq q \\leq\r\n2n +1, k= 1,2,\\cdots\r\n\\end{aligned}\\]</span></p>\r\n<p>with lengths <span class=\"math inline\">\\(\\frac{1}{9n}^{k} ( 1 -\r\n\\frac{1}{3n})\\)</span> and Accordingly, for fixed <span\r\nclass=\"math inline\">\\(k\\)</span> and <span\r\nclass=\"math inline\">\\(q\\)</span> by passing <span\r\nclass=\"math inline\">\\(i\\)</span> to <span\r\nclass=\"math inline\">\\(i+1\\)</span> using a shift to the right over a\r\ndistance <span class=\"math inline\">\\(1/(9n)^{k}\\)</span>. Accordingly,\r\nfor fixed <span class=\"math inline\">\\(k\\)</span> and <span\r\nclass=\"math inline\">\\(q\\)</span> the cubes</p>\r\n<p><span class=\"math display\">\\[S_{k,i_{1},\\cdots,i_{n}}^{q} =\r\n\\prod_{p=1}^{n} A_{k,i_{p}}^{q}\\]</span></p>\r\n<p>with edges of lengths <span\r\nclass=\"math inline\">\\(\\frac{1}{(9n)^{k}}\\)</span> cover the unit cube\r\n<span class=\"math inline\">\\(E^{n}\\)</span> to within the separating\r\nslits of widths <span\r\nclass=\"math inline\">\\(\\frac{1}{3n(9n)^{k}}\\)</span>. It's easy to verify\r\nthe following</p>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>The system of all cubes <span\r\nclass=\"math inline\">\\(S_{k,i_{1},\\cdots,i_{n}}^{q}\\)</span> with\r\nconstant <span class=\"math inline\">\\(k\\)</span> and variable <span\r\nclass=\"math inline\">\\(q\\)</span> and <span\r\nclass=\"math inline\">\\(i_{1},\\cdots,i_{n}\\)</span> covers the unit cube\r\n<span class=\"math inline\">\\(E^{n}\\)</span> so that each point belonging\r\nto <span class=\"math inline\">\\(E^{n}\\)</span> is covered by at least\r\n<span class=\"math inline\">\\(n+1\\)</span> times. <span\r\nclass=\"math inline\">\\(\\label{lem 1}\\)</span></p>\r\n<p><br></p>\r\n<p>Using induction on <span class=\"math inline\">\\(k\\)</span> we can\r\nprove the following</p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>There exist constants <span\r\nclass=\"math inline\">\\(\\lambda^{pq}_{k,i}\\)</span> and <span\r\nclass=\"math inline\">\\(\\epsilon_{k}\\)</span> such that</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(\\lambda^{pq}_{k,i} \\leq\r\n\\lambda^{pq}_{k,i+1} \\leq \\lambda^{pq}_{k,i} +\r\n1/2^{k}\\)</span>;</p></li>\r\n<li><p><span class=\"math inline\">\\(\\lambda^{pq}_{k,i} \\leq\r\n\\lambda^{pq}_{k+1,i^{\\prime}} \\leq \\lambda^{pq}_{k,i} + \\epsilon_{k+1} -\r\n\\epsilon_{k}\\)</span> if the closed intevals <span\r\nclass=\"math inline\">\\(A_{k,i}^{q}\\)</span> and <span\r\nclass=\"math inline\">\\(A_{k+1,i^{\\prime}}^{q}\\)</span> do not\r\nintersect;</p></li>\r\n<li><p>the closed interval <span\r\nclass=\"math inline\">\\(\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}} =\r\n\\left[\\sum_{p}\\lambda^{pq}_{k,i_{p}}, \\sum_{p}\\lambda^{pq}_{k,i_{p}} + n\r\n\\epsilon_{k}\\right]\\)</span> are pairwise disjoint for fixed <span\r\nclass=\"math inline\">\\(k\\)</span> and <span\r\nclass=\"math inline\">\\(q\\)</span>.</p></li>\r\n</ol>\r\n<p>It's easy to note that 1. and 3. imply</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li><span class=\"math inline\">\\(\\epsilon \\leq 1/2^{k}\\)</span>.</li>\r\n</ol>\r\n<h2 id=\"lemma-3\">Lemma 3</h2>\r\n<p>For fixed <span class=\"math inline\">\\(p\\)</span> and <span\r\nclass=\"math inline\">\\(q\\)</span> the condition</p>\r\n<ol start=\"5\" type=\"1\">\r\n<li><span class=\"math inline\">\\(\\lambda^{pq}_{k,i} \\leq \\psi^{pq}(x)\r\n\\leq \\lambda^{pq}_{k,i} + \\epsilon_{k}\\)</span> uniquely determine a\r\ncontinuous function <span class=\"math inline\">\\(\\psi^{pq}\\)</span> on\r\n<span class=\"math inline\">\\(E^{1}\\)</span>.</li>\r\n</ol>\r\n<p>From 5. and 3. it follows that</p>\r\n<ol start=\"6\" type=\"1\">\r\n<li><span class=\"math inline\">\\(\\sum_{p} \\psi^{pq} (x_{p}) \\in\r\n\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}\\)</span> for <span\r\nclass=\"math inline\">\\((x_{1}, \\cdots, x_{n}) \\in\r\nS_{k,i_{1},\\cdots,i_{n}}^{q}\\)</span>.</li>\r\n</ol>\r\n<p><br></p>\r\n<p><strong>Step 2</strong>: <em>Construction of the functions <span\r\nclass=\"math inline\">\\(\\chi^{q}\\)</span></em>.</p>\r\n<p>Let <span class=\"math inline\">\\(\\chi_{0}^{q} \\equiv 0\\)</span>, while\r\nfor <span class=\"math inline\">\\(r &gt;0\\)</span>, <span\r\nclass=\"math inline\">\\(\\chi_{r}^{q}\\)</span> will be defined by induction\r\non <span class=\"math inline\">\\(r\\)</span> simultaneously with the\r\nnatural number <span class=\"math inline\">\\(k_{r}\\)</span>.</p>\r\n<p>Denote as below</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}f_{r}(x_{1},\\cdots,x_{n})\r\n= &amp; \\sum_{q=1}^{2n+1} \\chi_{r}^{q}\\left[\\sum_{p}\r\n\\psi^{pq}(x_{p})\\right]\\\\\r\nM_{r}= &amp; \\sup_{E^{n}} \\left|f\r\n-f_{r}\\right|\\end{aligned}\\]</span></p>\r\n<p><strong>Inductive step:</strong> Assuming <span\r\nclass=\"math inline\">\\(\\chi_{r-1}^{q}\\)</span> and <span\r\nclass=\"math inline\">\\(k_{r-1}\\)</span> have already been determined.</p>\r\n<p><strong>Passing to step <span\r\nclass=\"math inline\">\\(r\\)</span>:</strong></p>\r\n<p>Since the diameter of the cubes <span\r\nclass=\"math inline\">\\(S_{k,i_{1},\\cdots,i_{n}}^{q}\\)</span> tend to zero\r\nas <span class=\"math inline\">\\(k \\to \\infty\\)</span>, we can choose\r\n<span class=\"math inline\">\\(k_{r}\\)</span> so large that the oscillation\r\nof the difference <span class=\"math inline\">\\(f - f_{r-1}\\)</span> does\r\nnot exceed <span class=\"math inline\">\\(M_{r}/(2n+2)\\)</span> on any\r\n<span\r\nclass=\"math inline\">\\(S_{k_{r},i_{1},\\cdots,i_{n}}^{q}\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(\\xi_{k,i}^{q}\\)</span> be arbitrary\r\npoints belonging to the corresponding closed intervals <span\r\nclass=\"math inline\">\\(A_{k,i}^{q}\\)</span>. For the closed interval\r\n<span class=\"math inline\">\\(\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}\\)</span>\r\nwe put</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\\chi_{r}^{q}(y) = &amp;\r\n\\chi_{r-1}^{q}(y) + \\frac{1}{n+1} \\left[f(\\xi_{k,i_{1}}^{q}, \\cdots,\r\n\\xi_{k,i_{n}}^{q}) - f_{r}(\\xi_{k,i_{1}}^{q}, \\cdots,\r\n\\xi_{k,i_{n}}^{q})\\right]\\\\\r\n&amp; \\left|\\chi_{r}^{q} (y) - \\chi_{r-1}(y)\\right| \\leq \\frac{1}{n+1}\r\nM_{r-1}\\end{aligned}\\]</span></p>\r\n<p>Outside the closed intervals <span\r\nclass=\"math inline\">\\(\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}\\)</span> the\r\nfunction <span class=\"math inline\">\\(\\chi_{r}^{q}\\)</span> is defined\r\narbitrarily, with the preservation of the inequality above and\r\ncontinuity.</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}f(x_{1},\\cdots,x_{n}) -\r\nf_{r}(x_{1},\\cdots,x_{n}) = f(x_{1},\\cdots,x_{n}) -\r\nf_{r-1}(x_{1},\\cdots,x_{n})\\\\\r\n- \\sum_{q=1}^{2n+1}\r\n\\left\\{\\chi_{r}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] -\r\n\\chi_{r-1}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right]\\right\\}\\end{aligned}\\]</span></p>\r\n<p>We represent the sum in above equation in the form <span\r\nclass=\"math inline\">\\(\\sum^{\\prime} + \\sum^{\\prime\\prime}\\)</span>,\r\nwhere the sum <span class=\"math inline\">\\(\\sum^{\\prime}\\)</span> extends\r\nover certain <span class=\"math inline\">\\(n+1\\)</span> values of <span\r\nclass=\"math inline\">\\(q\\)</span> for which the point <span\r\nclass=\"math inline\">\\((x_{1},\\cdots,x_{n})\\)</span> is contained in one\r\nof the cubes <span\r\nclass=\"math inline\">\\(S_{k_{r},i_{1},\\cdots,i_{n}}^{q}\\)</span> (by\r\nLemma 1<span class=\"math inline\">\\(\\ref{lem 1}\\)</span>, such cubes\r\nexist) and the sum <span\r\nclass=\"math inline\">\\(\\sum^{\\prime\\prime}\\)</span> extends over the\r\nremaining <span class=\"math inline\">\\(n\\)</span> values of <span\r\nclass=\"math inline\">\\(q\\)</span>. Hence, for each term in <span\r\nclass=\"math inline\">\\(\\sum^{\\prime}\\)</span> we have</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n&amp;\\chi_{r}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] -\r\n\\chi_{r-1}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] \\\\\r\n= \\frac{1}{n+1} &amp;\\left[f(\\xi_{k,i_{1}}^{q}, \\cdots,\r\n\\xi_{k,i_{n}}^{q}) - f_{r-1}(\\xi_{k,i_{1}}^{q}, \\cdots,\r\n\\xi_{k,i_{n}}^{q})\\right] \\\\\r\n= \\frac{1}{n+1} &amp; \\left[f(x_{1},\\cdots,x_{n}) -\r\nf_{r-1}(x_{1},\\cdots,x_{n})\\right] + \\frac{\\omega^{q}}{n+1}\r\n\\end{aligned}\\]</span></p>\r\n<p>where</p>\r\n<p><span class=\"math display\">\\[|\\omega^{q}| \\leq\r\n\\frac{1}{2n+2}M_{r}\\]</span></p>\r\n<p>which implies</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}|f - f_{r}| =\r\n\\left|\\frac{1}{n+1} \\sum^{\\prime}\\omega^{q} + \\sum^{\\prime \\prime}\r\n(\\chi_{r}^{q} - \\chi_{r-1}^{q})\\right| \\leq \\\\\r\n\\frac{1}{2n+2} M_{r-1} + \\frac{n}{n+1} M_{r-1} = \\frac{2n +1}{2n +2}\r\nM_{r-1} \\end{aligned}\\]</span></p>\r\n<p>Since inequality holds at any point <span\r\nclass=\"math inline\">\\((x_{1},\\cdots,x_{n}) \\in E^{n}\\)</span>, it\r\nfollows that the absolute values of the differences <span\r\nclass=\"math inline\">\\(\\chi^{q} - \\chi_{r}^{q}\\)</span> do not exceed the\r\ncorresponding terms of the absolutely convergent series</p>\r\n<p><span class=\"math display\">\\[\\sum_{r} \\frac{1}{n+1}\r\nM_{r-1}\\]</span></p>\r\n<p>Therefore the functions <span\r\nclass=\"math inline\">\\(\\chi_{r}^{q}\\)</span> converges uniformly to\r\ncontinuous limit functions <span class=\"math inline\">\\(\\chi^{q}\\)</span>\r\nfor <span class=\"math inline\">\\(r\\to \\infty\\)</span>.</p>\r\n<p><br></p>\r\n<h1 id=\"reference\">Reference:</h1>\r\n<p>[1] Kolmogorov, A. N. (1957). On the representation of continuous\r\nfunctions of several variables by superposition of continuous functions\r\nof one variable and addition. (in Russian) In Doklady Akademii Nauk\r\n(Vol. 114, No. 5, pp. 953-956). Russian Academy of Sciences.</p>\r\n<p>[2] Arnold, V. I. (1957). On functions of three variables. (in\r\nRussian) Collected Works: Representations of Functions, Celestial\r\nMechanics and KAM Theory, 19571965, 5-8.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"theorem-1\">Theorem 1</h2>\r\n<p>For any integer <span class=\"math inline\">\\(n\\geq 2\\)</span> there\r\nare continuous real functions <span\r\nclass=\"math inline\">\\(\\psi^{p,q}(x)\\)</span> on the closed unit interval\r\n<span class=\"math inline\">\\(E^{1} = [0,1]\\)</span> such that each\r\ncontinuous real function <span\r\nclass=\"math inline\">\\(f(x_{1},\\cdots,x_{n})\\)</span> on the <span\r\nclass=\"math inline\">\\(n\\)</span>-dimensional unit cube <span\r\nclass=\"math inline\">\\(E^{n}\\)</span> is representable as</p>\r\n<p><span class=\"math display\">\\[f(x_{1},\\cdots,x_{n}) =\r\n\\sum_{q=1}^{2n+1} \\chi^{q} \\left[\\sum_{p=1}^{n}\r\n\\psi^{p,q}(x_{p})\\right]\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(\\chi^{q}(y)\\)</span> are continuous\r\nreal function.</p>\r\n<p><br></p>\r\n<p><strong>Step 1</strong>: <em>Construction of the functions <span\r\nclass=\"math inline\">\\(\\psi^{pq}\\)</span></em>.</p>\r\n<p>Consider the closed intervals</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n&amp; A_{k,i}^{q} = \\left[\\frac{1}{(9n)^{k}}\\left(i - 1 -\r\n\\frac{q}{3n}\\right), \\frac{1}{(9n)^{k}}\\left(i - \\frac{1}{3n} -\r\n\\frac{q}{3n}\\right)\\right],\\\\\r\n&amp;\\qquad \\qquad \\qquad \\qquad 1\\leq i \\leq (9n)^{k} +1, 1\\leq q \\leq\r\n2n +1, k= 1,2,\\cdots\r\n\\end{aligned}\\]</span></p>\r\n<p>with lengths <span class=\"math inline\">\\(\\frac{1}{9n}^{k} ( 1 -\r\n\\frac{1}{3n})\\)</span> and Accordingly, for fixed <span\r\nclass=\"math inline\">\\(k\\)</span> and <span\r\nclass=\"math inline\">\\(q\\)</span> by passing <span\r\nclass=\"math inline\">\\(i\\)</span> to <span\r\nclass=\"math inline\">\\(i+1\\)</span> using a shift to the right over a\r\ndistance <span class=\"math inline\">\\(1/(9n)^{k}\\)</span>. Accordingly,\r\nfor fixed <span class=\"math inline\">\\(k\\)</span> and <span\r\nclass=\"math inline\">\\(q\\)</span> the cubes</p>\r\n<p><span class=\"math display\">\\[S_{k,i_{1},\\cdots,i_{n}}^{q} =\r\n\\prod_{p=1}^{n} A_{k,i_{p}}^{q}\\]</span></p>\r\n<p>with edges of lengths <span\r\nclass=\"math inline\">\\(\\frac{1}{(9n)^{k}}\\)</span> cover the unit cube\r\n<span class=\"math inline\">\\(E^{n}\\)</span> to within the separating\r\nslits of widths <span\r\nclass=\"math inline\">\\(\\frac{1}{3n(9n)^{k}}\\)</span>. It's easy to verify\r\nthe following</p>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>The system of all cubes <span\r\nclass=\"math inline\">\\(S_{k,i_{1},\\cdots,i_{n}}^{q}\\)</span> with\r\nconstant <span class=\"math inline\">\\(k\\)</span> and variable <span\r\nclass=\"math inline\">\\(q\\)</span> and <span\r\nclass=\"math inline\">\\(i_{1},\\cdots,i_{n}\\)</span> covers the unit cube\r\n<span class=\"math inline\">\\(E^{n}\\)</span> so that each point belonging\r\nto <span class=\"math inline\">\\(E^{n}\\)</span> is covered by at least\r\n<span class=\"math inline\">\\(n+1\\)</span> times. <span\r\nclass=\"math inline\">\\(\\label{lem 1}\\)</span></p>\r\n<p><br></p>\r\n<p>Using induction on <span class=\"math inline\">\\(k\\)</span> we can\r\nprove the following</p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>There exist constants <span\r\nclass=\"math inline\">\\(\\lambda^{pq}_{k,i}\\)</span> and <span\r\nclass=\"math inline\">\\(\\epsilon_{k}\\)</span> such that</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(\\lambda^{pq}_{k,i} \\leq\r\n\\lambda^{pq}_{k,i+1} \\leq \\lambda^{pq}_{k,i} +\r\n1/2^{k}\\)</span>;</p></li>\r\n<li><p><span class=\"math inline\">\\(\\lambda^{pq}_{k,i} \\leq\r\n\\lambda^{pq}_{k+1,i^{\\prime}} \\leq \\lambda^{pq}_{k,i} + \\epsilon_{k+1} -\r\n\\epsilon_{k}\\)</span> if the closed intevals <span\r\nclass=\"math inline\">\\(A_{k,i}^{q}\\)</span> and <span\r\nclass=\"math inline\">\\(A_{k+1,i^{\\prime}}^{q}\\)</span> do not\r\nintersect;</p></li>\r\n<li><p>the closed interval <span\r\nclass=\"math inline\">\\(\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}} =\r\n\\left[\\sum_{p}\\lambda^{pq}_{k,i_{p}}, \\sum_{p}\\lambda^{pq}_{k,i_{p}} + n\r\n\\epsilon_{k}\\right]\\)</span> are pairwise disjoint for fixed <span\r\nclass=\"math inline\">\\(k\\)</span> and <span\r\nclass=\"math inline\">\\(q\\)</span>.</p></li>\r\n</ol>\r\n<p>It's easy to note that 1. and 3. imply</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li><span class=\"math inline\">\\(\\epsilon \\leq 1/2^{k}\\)</span>.</li>\r\n</ol>\r\n<h2 id=\"lemma-3\">Lemma 3</h2>\r\n<p>For fixed <span class=\"math inline\">\\(p\\)</span> and <span\r\nclass=\"math inline\">\\(q\\)</span> the condition</p>\r\n<ol start=\"5\" type=\"1\">\r\n<li><span class=\"math inline\">\\(\\lambda^{pq}_{k,i} \\leq \\psi^{pq}(x)\r\n\\leq \\lambda^{pq}_{k,i} + \\epsilon_{k}\\)</span> uniquely determine a\r\ncontinuous function <span class=\"math inline\">\\(\\psi^{pq}\\)</span> on\r\n<span class=\"math inline\">\\(E^{1}\\)</span>.</li>\r\n</ol>\r\n<p>From 5. and 3. it follows that</p>\r\n<ol start=\"6\" type=\"1\">\r\n<li><span class=\"math inline\">\\(\\sum_{p} \\psi^{pq} (x_{p}) \\in\r\n\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}\\)</span> for <span\r\nclass=\"math inline\">\\((x_{1}, \\cdots, x_{n}) \\in\r\nS_{k,i_{1},\\cdots,i_{n}}^{q}\\)</span>.</li>\r\n</ol>\r\n<p><br></p>\r\n<p><strong>Step 2</strong>: <em>Construction of the functions <span\r\nclass=\"math inline\">\\(\\chi^{q}\\)</span></em>.</p>\r\n<p>Let <span class=\"math inline\">\\(\\chi_{0}^{q} \\equiv 0\\)</span>, while\r\nfor <span class=\"math inline\">\\(r &gt;0\\)</span>, <span\r\nclass=\"math inline\">\\(\\chi_{r}^{q}\\)</span> will be defined by induction\r\non <span class=\"math inline\">\\(r\\)</span> simultaneously with the\r\nnatural number <span class=\"math inline\">\\(k_{r}\\)</span>.</p>\r\n<p>Denote as below</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}f_{r}(x_{1},\\cdots,x_{n})\r\n= &amp; \\sum_{q=1}^{2n+1} \\chi_{r}^{q}\\left[\\sum_{p}\r\n\\psi^{pq}(x_{p})\\right]\\\\\r\nM_{r}= &amp; \\sup_{E^{n}} \\left|f\r\n-f_{r}\\right|\\end{aligned}\\]</span></p>\r\n<p><strong>Inductive step:</strong> Assuming <span\r\nclass=\"math inline\">\\(\\chi_{r-1}^{q}\\)</span> and <span\r\nclass=\"math inline\">\\(k_{r-1}\\)</span> have already been determined.</p>\r\n<p><strong>Passing to step <span\r\nclass=\"math inline\">\\(r\\)</span>:</strong></p>\r\n<p>Since the diameter of the cubes <span\r\nclass=\"math inline\">\\(S_{k,i_{1},\\cdots,i_{n}}^{q}\\)</span> tend to zero\r\nas <span class=\"math inline\">\\(k \\to \\infty\\)</span>, we can choose\r\n<span class=\"math inline\">\\(k_{r}\\)</span> so large that the oscillation\r\nof the difference <span class=\"math inline\">\\(f - f_{r-1}\\)</span> does\r\nnot exceed <span class=\"math inline\">\\(M_{r}/(2n+2)\\)</span> on any\r\n<span\r\nclass=\"math inline\">\\(S_{k_{r},i_{1},\\cdots,i_{n}}^{q}\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(\\xi_{k,i}^{q}\\)</span> be arbitrary\r\npoints belonging to the corresponding closed intervals <span\r\nclass=\"math inline\">\\(A_{k,i}^{q}\\)</span>. For the closed interval\r\n<span class=\"math inline\">\\(\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}\\)</span>\r\nwe put</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\\chi_{r}^{q}(y) = &amp;\r\n\\chi_{r-1}^{q}(y) + \\frac{1}{n+1} \\left[f(\\xi_{k,i_{1}}^{q}, \\cdots,\r\n\\xi_{k,i_{n}}^{q}) - f_{r}(\\xi_{k,i_{1}}^{q}, \\cdots,\r\n\\xi_{k,i_{n}}^{q})\\right]\\\\\r\n&amp; \\left|\\chi_{r}^{q} (y) - \\chi_{r-1}(y)\\right| \\leq \\frac{1}{n+1}\r\nM_{r-1}\\end{aligned}\\]</span></p>\r\n<p>Outside the closed intervals <span\r\nclass=\"math inline\">\\(\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}\\)</span> the\r\nfunction <span class=\"math inline\">\\(\\chi_{r}^{q}\\)</span> is defined\r\narbitrarily, with the preservation of the inequality above and\r\ncontinuity.</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}f(x_{1},\\cdots,x_{n}) -\r\nf_{r}(x_{1},\\cdots,x_{n}) = f(x_{1},\\cdots,x_{n}) -\r\nf_{r-1}(x_{1},\\cdots,x_{n})\\\\\r\n- \\sum_{q=1}^{2n+1}\r\n\\left\\{\\chi_{r}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] -\r\n\\chi_{r-1}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right]\\right\\}\\end{aligned}\\]</span></p>\r\n<p>We represent the sum in above equation in the form <span\r\nclass=\"math inline\">\\(\\sum^{\\prime} + \\sum^{\\prime\\prime}\\)</span>,\r\nwhere the sum <span class=\"math inline\">\\(\\sum^{\\prime}\\)</span> extends\r\nover certain <span class=\"math inline\">\\(n+1\\)</span> values of <span\r\nclass=\"math inline\">\\(q\\)</span> for which the point <span\r\nclass=\"math inline\">\\((x_{1},\\cdots,x_{n})\\)</span> is contained in one\r\nof the cubes <span\r\nclass=\"math inline\">\\(S_{k_{r},i_{1},\\cdots,i_{n}}^{q}\\)</span> (by\r\nLemma 1<span class=\"math inline\">\\(\\ref{lem 1}\\)</span>, such cubes\r\nexist) and the sum <span\r\nclass=\"math inline\">\\(\\sum^{\\prime\\prime}\\)</span> extends over the\r\nremaining <span class=\"math inline\">\\(n\\)</span> values of <span\r\nclass=\"math inline\">\\(q\\)</span>. Hence, for each term in <span\r\nclass=\"math inline\">\\(\\sum^{\\prime}\\)</span> we have</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n&amp;\\chi_{r}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] -\r\n\\chi_{r-1}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] \\\\\r\n= \\frac{1}{n+1} &amp;\\left[f(\\xi_{k,i_{1}}^{q}, \\cdots,\r\n\\xi_{k,i_{n}}^{q}) - f_{r-1}(\\xi_{k,i_{1}}^{q}, \\cdots,\r\n\\xi_{k,i_{n}}^{q})\\right] \\\\\r\n= \\frac{1}{n+1} &amp; \\left[f(x_{1},\\cdots,x_{n}) -\r\nf_{r-1}(x_{1},\\cdots,x_{n})\\right] + \\frac{\\omega^{q}}{n+1}\r\n\\end{aligned}\\]</span></p>\r\n<p>where</p>\r\n<p><span class=\"math display\">\\[|\\omega^{q}| \\leq\r\n\\frac{1}{2n+2}M_{r}\\]</span></p>\r\n<p>which implies</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}|f - f_{r}| =\r\n\\left|\\frac{1}{n+1} \\sum^{\\prime}\\omega^{q} + \\sum^{\\prime \\prime}\r\n(\\chi_{r}^{q} - \\chi_{r-1}^{q})\\right| \\leq \\\\\r\n\\frac{1}{2n+2} M_{r-1} + \\frac{n}{n+1} M_{r-1} = \\frac{2n +1}{2n +2}\r\nM_{r-1} \\end{aligned}\\]</span></p>\r\n<p>Since inequality holds at any point <span\r\nclass=\"math inline\">\\((x_{1},\\cdots,x_{n}) \\in E^{n}\\)</span>, it\r\nfollows that the absolute values of the differences <span\r\nclass=\"math inline\">\\(\\chi^{q} - \\chi_{r}^{q}\\)</span> do not exceed the\r\ncorresponding terms of the absolutely convergent series</p>\r\n<p><span class=\"math display\">\\[\\sum_{r} \\frac{1}{n+1}\r\nM_{r-1}\\]</span></p>\r\n<p>Therefore the functions <span\r\nclass=\"math inline\">\\(\\chi_{r}^{q}\\)</span> converges uniformly to\r\ncontinuous limit functions <span class=\"math inline\">\\(\\chi^{q}\\)</span>\r\nfor <span class=\"math inline\">\\(r\\to \\infty\\)</span>.</p>\r\n<p><br></p>\r\n<h1 id=\"reference\">Reference:</h1>\r\n<p>[1] Kolmogorov, A. N. (1957). On the representation of continuous\r\nfunctions of several variables by superposition of continuous functions\r\nof one variable and addition. (in Russian) In Doklady Akademii Nauk\r\n(Vol. 114, No. 5, pp. 953-956). Russian Academy of Sciences.</p>\r\n<p>[2] Arnold, V. I. (1957). On functions of three variables. (in\r\nRussian) Collected Works: Representations of Functions, Celestial\r\nMechanics and KAM Theory, 19571965, 5-8.</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Wed Jan 03 2024 10:56:24 GMT+0800 ()","title":"Hilbert's 13th Problem","path":"2023/03/23/Hilbert13/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-03-23T02:35:56.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-03-23T02:35:56.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Notes > History of Mathematics > Hilbert's 23 Problems","tags":["Notes","Hilbert's 23 Problems"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Nevanlinna Theory (I)","date":"2023-03-27T10:40:09.000Z","mathjax":true,"_content":"\n## First Main Theorem\n\nFor any function $w(z)$ meromorphic in the disk\n$|z| < R < \\infty$, a function $T(r, w)$ can be defined for $0 < r < R$ so that \n\n1. $T(r)$ is an increasing function of $r$ and a convex function of $\\log r$.\n\n2. If $a$ denotes any complex number that is independent of $z$, finite or infinite, then is\n$$m(r, a) + N(r, a) = T (r) + O(1). \\tag{I}$$\nwhere the two terms on the left of relation (I) are\nnonnegative.\n\n\n## Lemma 1\nIf $\\alpha$ is a nonnegative number, let $$\\log^{+} \\alpha = \\begin{cases}\\log \\alpha, & \\alpha > 1\\\\\n0, & 0 < \\alpha \\leq 1\\end{cases}$$ be the larger of the numbers $\\log \\alpha$ and $0$; it follows that\n$$\n\\begin{aligned}\n\\log \\alpha = \\log^{+} \\alpha - \\log^{+} \\frac{1}{\\alpha}\\\\\n |\\log \\alpha| = \\log^{+} \\alpha + \\log^{+} \\frac{1}{\\alpha}\n\\end{aligned}\n$$\n\n\n## Lemma 2\nNotation as above lemma 1, and further, as is easily confirmed,\n$$\n\\begin{equation}\n\\begin{aligned}\n\\log^{+} \\alpha_{1}\\cdot \\alpha_{2}\\cdots \\alpha_{p} \\leq \\sum_{i=1}^{p} \\log^{+} {\\alpha_{i}}\\\\\n\\log^{+} \\sum_{i=1}^{p} {\\alpha_{i}} \\leq \\sum_{i=1}^{p} \\log^{+} \\alpha_{i} + \\log p\n\\end{aligned}\n\\end{equation}\n$$\n\n## Proof of Theorem 1\n\nIn [Jensen's formula](https://en.wikipedia.org/wiki/Jensen%27s_formula), we now set $\\log |w| = \\log^{+} |w| - \\log |\\frac{1}{w}|$ and for short write\n\n\n$$\\begin{aligned}N(r,a,w) =& \\int_{0}^{r} \\frac{n(t,a) - n(0,a)}{t} dt + n(0,a) \\log r\\\\\nm(r, a, w) =& \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\log^{+} \\left|\\frac{1}{w(re^{i\\varphi}) -a }\\right|d\\varphi\n\\end{aligned}$$\n\n$$\\begin{aligned}N(r,\\infty,w) =& \\int_{0}^{r} \\frac{n(t,\\infty) - n(0,\\infty)}{t} dt + n(0,\\infty) \\log r\\\\\nm(r, \\infty, w) =& \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\log^{+} \\left|w(re^{i\\varphi})\\right|d\\varphi\n\\end{aligned}$$\n\nwhere $n(r, a)$ is the number of roots of the equation $w- a =  0$ in the disk $|z|<r$ \n\nJensen's formula then becomes\n\n$$m(r, w) + N(r, w) = m (r, \\frac{1}{w}) + N (r,\\frac{1}{w}) +\\log|c_{\\lambda}|$$\n\n\nwhere $c_{\\lambda}$ is the first nonvanishing coefficient in the Laurent expansion of $w-a$ at the origin $z = 0$. \n\nThe result is then\n\n$$m(r, w - a) + N(r, w - a) = m (r, \\frac{1}{w-a}) + N (r, \\frac{1}{w-a}) + \\text{const.}$$\n\nBut\n$N(r, w - a) = N(r, w)$\n\nand by Lemma 2\n\n$$\\left| m(r, w- a)- m(r, w) \\right| < \\log^{+} |a|+ \\log 2$$\n\nso we conclude from (2.3) that\n\n$$m(r, a) + N(r, a) = m(r, \\infty) + N(r,\\infty) + \\varphi(r, a),$$\n\nIn addition we set\n$T(r, w) = T(r) = m(r, \\infty) + N(r, \\infty)$,\nThis is the desired results. $\\square$\n\n## Second Main Theorem\n\n1. For $|z| < R < \\infty$ let $w(z)$ be a nonconstant\nmeromorphic function. If $w_{1}, \\cdots , w_{q} (q \\geq 1)$ are mutually distinct finite or infinite complex numbers, then for $0 \\leq r < R$\n\n$$\\sum m(r, \\omega_{\\nu}) < 2 T(r) - N_{1}(r) + S(r)$$\n\n2. the remainder term satisfies\nthe following conditions:\n\nIf $R = \\infty$, then\n$$S(r) = O \\left\\{\\log \\left[rT(r)\\right]\\right\\}$$\nwith at most the exception of a set of values $\\{r\\}$ of finite total measure\n\nIf $R = 1$, then\n\n$$S(r) = O \\left\\{\\frac{1}{1-r}T(r)\\right\\}$$\n\nwith at most the exception of a set of values $\\{r\\}$ for which the variation of $\\frac{1}{1-r}$ is fintte\n\n\n## Proof \n\nSuppose, therefore, that $w(z) = c_{0} + c_{k}z^{k} + \\cdots (c_{0}\\neq 0, c_{k} \\neq 0)$ is a function that is meromorphic for $|z| < R \\leq \\infty$, and let $a_{1}, \\cdots, a_{p}$ be a system of $p \\geq 2$ different finite complex numbers.\n\nWe first compare the proximity functions $m(r, w)$ and $m(r, w^{\\prime})$ with one another. By means of the elementary inequalities (Lemma 2 in (I)), one finds immediately that\n\n$$\\begin{equation}\nm(r,w) = m (r,w^{\\prime}\\frac{w}{w^{\\prime}}) \\leq m (r,w^{\\prime}) + m (r,\\frac{w}{w^{\\prime}})\n\\end{equation}$$\n\nTo estimate the mean value $m ( r, \\frac{1}{w^{\\prime}})$ , consider the sum\n\n$$f(z) = \\sum_{\\nu=1}^{p} \\frac{1}{w(z) - a_{\\nu}}$$\n\nWe have\n\n\n$$\\begin{equation}\nm(r,f) = m (r,fw^{\\prime}\\frac{1}{w^{\\prime}}) \\leq m (r,\\frac{1}{w^{\\prime}}) + m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}})\n\\end{equation}$$\n\n\nOn the other hand, for a given $\\mu$ ($\\mu = 1, \\cdots , p$)\n\n$$f = \\frac{1}{w - a_{\\mu}}\\left(1 + \\sum_{\\nu\\neq\\mu} \\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right)$$\n\nIf $\\delta = \\min (|a_{h} -\na_{k}|, 1) (h \\neq k)$, then at every point $z$ where\n\n$$\\begin{equation}\n\\left|w(z) - a_{\\mu}\\right| < \\frac{\\delta}{2p} \\left(\\leq \\frac{1}{2p}\\right) \n\\end{equation}$$\n\nfor $\\nu \\neq \\mu$\n$$\\left|w - a_{\\nu}\\right| \\geq \\left|a_{\\mu} - a_{\\nu}\\right| - \\left|w - a_{\\mu}\\right| > \\delta - \\frac{\\delta}{2p} \\geq \\frac{3\\delta}{4}$$\n\nand hence\n$$\\sum_{\\nu\\neq\\mu} \\left|\\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right| < (p-1) \\frac{2}{3p} < \\frac{2}{3}$$\n\nso that\n$$\\left|1 + \\sum_{\\nu\\neq\\mu} \\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right| > \\frac{1}{3}$$\n\nFrom this it follows that\n$$\\log^{+}\\left|f(z)\\right| > \\log^{+}\\left|\\frac{1}{w - a_{\\mu}}\\right| - \\log 3$$\n\nat every point z where condition (4) is satisfied.\n\nThe arcs determined on the circle by (4) are disjoint for different\nvalues of $p$, and therefore one concludes that\n\n$$\\begin{aligned}\nm(r,f) \\geq & \\frac{1}{2\\pi} \\sum_{\\mu =1}^{p} \\int_{|w - a_{\\mu}| < \\frac{\\delta}{2p}} \\log^{+} |f(re^{i\\varphi})| d \\varphi\\\\\n< & \\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| < \\frac{\\delta}{2p}} \\left(\\log^{+} \\left|\\frac{1}{w(re^{i\\varphi})- a_{\\mu}}\\right| - \\log 3\\right) d \\varphi \n\\end{aligned}$$\n\nFurther,\n$$\\begin{aligned}\n\\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| < \\frac{\\delta}{2p}} \\log^{+} \\left|\\frac{1}{w- a_{\\mu}}\\right| = & m(r,a_{\\mu}) - \\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| \\geq \\frac{\\delta}{2p}}\\log^{+} \\left|\\frac{1}{w- a_{\\mu}}\\right|\\\\\n\\geq & m(r,a_{\\mu}) - \\log \\frac{2p}{\\delta}\n\\end{aligned}$$\n\nand finally\n\n$$m(r,f) > \\sum_{1}^{p} m(r,a_{\\mu}) - p \\log\\frac{2p}{\\delta} - \\log 3$$\n\nor in conjunction with (2)\n\n$$\\begin{equation}\nm (r,\\frac{1}{w^{\\prime}}) > \\sum_{1}^{p} m(r,a_{\\mu}) - m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}}) - p \\log\\frac{2p}{\\delta} - \\log 3\n\\end{equation}$$\n\nIf the quantities $N(r, w^{\\prime})$ and $N(r, \\frac{1}{w^{\\prime}})$ are now added to both sides of inequalities (2) and (5), respectively, then using the first main\ntheorem\n\n$$T(r, w^{\\prime}) = T (r, \\frac{1}{w^{\\prime}}) + \\log |kc_{k}|$$\n\none obtains the following result, which is to be stated as a special lemma 1 :\n\nThe characteristic $T(r, w^{\\prime})$ for the derivative of the meromorphic function\nw(z) lies between the bounds\n$$m(r, w) + N(r, w^{\\prime}) + m (r,\\frac{w^{\\prime}}{w})$$\n\nand \n\n$$ \\sum_{1}^{p} m(r,\\frac{1}{w - a_{\\mu}}) + N (r,\\frac{1}{w^{\\prime}})  - m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}}) - p \\log\\frac{2p}{\\delta} - \\log 3$$\n\nIf we leave out T(r, w') and introduce\n\n$$N_{1}(r) = N(r,\\frac{1}{w^{\\prime}}) + \\left(2 N(r,w) - N (r,w^{\\prime})\\right)$$\n\nit becomes a version of this theorem. $\\square$\n\nThe estimation is rather lengthy, readers can refer to Hayman, W.[1, Chapter III] and Nevanlinna, Rolf [3, Chapter IX].\n\n\n**Remark:** The quantity $N_{1}(r)$ measures the number of multiple points of $w(z)$. It can be written in the form\n$$N_{1}(r) = \\int_{0}^{r} \\frac{n_{1}(t) - n_{1}(0)}{t} dt + n_{1}(0) \\log r,\n$$\nwhere $n_{1}(r)$ indicates the number of multiple points of $w(z)$ in the disk $|z| < r$, each $k$-fold point being counted $k -\n1$ times.\n\n**Vojta's conjecture:** Let $F$ be a number field, let $X/F$ be a non-singular algebraic variety, let $D$ be an effective divisor on $X$ with at worst normal crossings, let $H$ be an ample divisor on $X$, and let $K_{X}$ be a canonical divisor on $X$. Choose Weil height functions $h_{H}$ and $h_{K_{X}}$ and, for each absolute value $v$ on $F$, a local height function $\\lambda_{D,v}$. Fix a finite set of absolute values $S$ of $F$, and let $\\epsilon>0$. Then there is a constant $C$ and a non-empty Zariski open set $U\\subseteq X$, depending on all of the above choices, such that\n$$\\sum_{v\\in S}\\lambda_{D,v}(P)+h_{K_{X}}(P)\\leq \\epsilon h_{H}(P)+C \\quad {\\hbox{for all }}P\\in U(F).$$\n\n\n\n## Reference \n\n\n\n[1] Hayman, W. (1964). Meromorphic functions. Oxford University press.\n\n[2] Nevanlinna, Rolf (1925), \"Zur Theorie der Meromorphen Funktionen\", Acta Mathematica, 46 (12): 199, doi:10.1007/BF02543858, ISSN 0001-5962\n\n[3] Nevanlinna, Rolf (1970), Analytic functions, Die Grundlehren der mathematischen Wissenschaften, vol. 162, Berlin, New York: Springer-Verlag, MR 0279280\n\n\n\n\n","source":"_posts/Nevanlinna Theory.md","raw":"---\ntitle: Nevanlinna Theory (I)\ndate: 2023-03-27 18:40:09\ntags:\n    - [Sevaral Complex Variables]\ncategories:\n    - [Sevaral Complex Variables, Nevanlinna Theory]\nmathjax: true\n---\n\n## First Main Theorem\n\nFor any function $w(z)$ meromorphic in the disk\n$|z| < R < \\infty$, a function $T(r, w)$ can be defined for $0 < r < R$ so that \n\n1. $T(r)$ is an increasing function of $r$ and a convex function of $\\log r$.\n\n2. If $a$ denotes any complex number that is independent of $z$, finite or infinite, then is\n$$m(r, a) + N(r, a) = T (r) + O(1). \\tag{I}$$\nwhere the two terms on the left of relation (I) are\nnonnegative.\n\n\n## Lemma 1\nIf $\\alpha$ is a nonnegative number, let $$\\log^{+} \\alpha = \\begin{cases}\\log \\alpha, & \\alpha > 1\\\\\n0, & 0 < \\alpha \\leq 1\\end{cases}$$ be the larger of the numbers $\\log \\alpha$ and $0$; it follows that\n$$\n\\begin{aligned}\n\\log \\alpha = \\log^{+} \\alpha - \\log^{+} \\frac{1}{\\alpha}\\\\\n |\\log \\alpha| = \\log^{+} \\alpha + \\log^{+} \\frac{1}{\\alpha}\n\\end{aligned}\n$$\n\n\n## Lemma 2\nNotation as above lemma 1, and further, as is easily confirmed,\n$$\n\\begin{equation}\n\\begin{aligned}\n\\log^{+} \\alpha_{1}\\cdot \\alpha_{2}\\cdots \\alpha_{p} \\leq \\sum_{i=1}^{p} \\log^{+} {\\alpha_{i}}\\\\\n\\log^{+} \\sum_{i=1}^{p} {\\alpha_{i}} \\leq \\sum_{i=1}^{p} \\log^{+} \\alpha_{i} + \\log p\n\\end{aligned}\n\\end{equation}\n$$\n\n## Proof of Theorem 1\n\nIn [Jensen's formula](https://en.wikipedia.org/wiki/Jensen%27s_formula), we now set $\\log |w| = \\log^{+} |w| - \\log |\\frac{1}{w}|$ and for short write\n\n\n$$\\begin{aligned}N(r,a,w) =& \\int_{0}^{r} \\frac{n(t,a) - n(0,a)}{t} dt + n(0,a) \\log r\\\\\nm(r, a, w) =& \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\log^{+} \\left|\\frac{1}{w(re^{i\\varphi}) -a }\\right|d\\varphi\n\\end{aligned}$$\n\n$$\\begin{aligned}N(r,\\infty,w) =& \\int_{0}^{r} \\frac{n(t,\\infty) - n(0,\\infty)}{t} dt + n(0,\\infty) \\log r\\\\\nm(r, \\infty, w) =& \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\log^{+} \\left|w(re^{i\\varphi})\\right|d\\varphi\n\\end{aligned}$$\n\nwhere $n(r, a)$ is the number of roots of the equation $w- a =  0$ in the disk $|z|<r$ \n\nJensen's formula then becomes\n\n$$m(r, w) + N(r, w) = m (r, \\frac{1}{w}) + N (r,\\frac{1}{w}) +\\log|c_{\\lambda}|$$\n\n\nwhere $c_{\\lambda}$ is the first nonvanishing coefficient in the Laurent expansion of $w-a$ at the origin $z = 0$. \n\nThe result is then\n\n$$m(r, w - a) + N(r, w - a) = m (r, \\frac{1}{w-a}) + N (r, \\frac{1}{w-a}) + \\text{const.}$$\n\nBut\n$N(r, w - a) = N(r, w)$\n\nand by Lemma 2\n\n$$\\left| m(r, w- a)- m(r, w) \\right| < \\log^{+} |a|+ \\log 2$$\n\nso we conclude from (2.3) that\n\n$$m(r, a) + N(r, a) = m(r, \\infty) + N(r,\\infty) + \\varphi(r, a),$$\n\nIn addition we set\n$T(r, w) = T(r) = m(r, \\infty) + N(r, \\infty)$,\nThis is the desired results. $\\square$\n\n## Second Main Theorem\n\n1. For $|z| < R < \\infty$ let $w(z)$ be a nonconstant\nmeromorphic function. If $w_{1}, \\cdots , w_{q} (q \\geq 1)$ are mutually distinct finite or infinite complex numbers, then for $0 \\leq r < R$\n\n$$\\sum m(r, \\omega_{\\nu}) < 2 T(r) - N_{1}(r) + S(r)$$\n\n2. the remainder term satisfies\nthe following conditions:\n\nIf $R = \\infty$, then\n$$S(r) = O \\left\\{\\log \\left[rT(r)\\right]\\right\\}$$\nwith at most the exception of a set of values $\\{r\\}$ of finite total measure\n\nIf $R = 1$, then\n\n$$S(r) = O \\left\\{\\frac{1}{1-r}T(r)\\right\\}$$\n\nwith at most the exception of a set of values $\\{r\\}$ for which the variation of $\\frac{1}{1-r}$ is fintte\n\n\n## Proof \n\nSuppose, therefore, that $w(z) = c_{0} + c_{k}z^{k} + \\cdots (c_{0}\\neq 0, c_{k} \\neq 0)$ is a function that is meromorphic for $|z| < R \\leq \\infty$, and let $a_{1}, \\cdots, a_{p}$ be a system of $p \\geq 2$ different finite complex numbers.\n\nWe first compare the proximity functions $m(r, w)$ and $m(r, w^{\\prime})$ with one another. By means of the elementary inequalities (Lemma 2 in (I)), one finds immediately that\n\n$$\\begin{equation}\nm(r,w) = m (r,w^{\\prime}\\frac{w}{w^{\\prime}}) \\leq m (r,w^{\\prime}) + m (r,\\frac{w}{w^{\\prime}})\n\\end{equation}$$\n\nTo estimate the mean value $m ( r, \\frac{1}{w^{\\prime}})$ , consider the sum\n\n$$f(z) = \\sum_{\\nu=1}^{p} \\frac{1}{w(z) - a_{\\nu}}$$\n\nWe have\n\n\n$$\\begin{equation}\nm(r,f) = m (r,fw^{\\prime}\\frac{1}{w^{\\prime}}) \\leq m (r,\\frac{1}{w^{\\prime}}) + m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}})\n\\end{equation}$$\n\n\nOn the other hand, for a given $\\mu$ ($\\mu = 1, \\cdots , p$)\n\n$$f = \\frac{1}{w - a_{\\mu}}\\left(1 + \\sum_{\\nu\\neq\\mu} \\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right)$$\n\nIf $\\delta = \\min (|a_{h} -\na_{k}|, 1) (h \\neq k)$, then at every point $z$ where\n\n$$\\begin{equation}\n\\left|w(z) - a_{\\mu}\\right| < \\frac{\\delta}{2p} \\left(\\leq \\frac{1}{2p}\\right) \n\\end{equation}$$\n\nfor $\\nu \\neq \\mu$\n$$\\left|w - a_{\\nu}\\right| \\geq \\left|a_{\\mu} - a_{\\nu}\\right| - \\left|w - a_{\\mu}\\right| > \\delta - \\frac{\\delta}{2p} \\geq \\frac{3\\delta}{4}$$\n\nand hence\n$$\\sum_{\\nu\\neq\\mu} \\left|\\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right| < (p-1) \\frac{2}{3p} < \\frac{2}{3}$$\n\nso that\n$$\\left|1 + \\sum_{\\nu\\neq\\mu} \\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right| > \\frac{1}{3}$$\n\nFrom this it follows that\n$$\\log^{+}\\left|f(z)\\right| > \\log^{+}\\left|\\frac{1}{w - a_{\\mu}}\\right| - \\log 3$$\n\nat every point z where condition (4) is satisfied.\n\nThe arcs determined on the circle by (4) are disjoint for different\nvalues of $p$, and therefore one concludes that\n\n$$\\begin{aligned}\nm(r,f) \\geq & \\frac{1}{2\\pi} \\sum_{\\mu =1}^{p} \\int_{|w - a_{\\mu}| < \\frac{\\delta}{2p}} \\log^{+} |f(re^{i\\varphi})| d \\varphi\\\\\n< & \\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| < \\frac{\\delta}{2p}} \\left(\\log^{+} \\left|\\frac{1}{w(re^{i\\varphi})- a_{\\mu}}\\right| - \\log 3\\right) d \\varphi \n\\end{aligned}$$\n\nFurther,\n$$\\begin{aligned}\n\\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| < \\frac{\\delta}{2p}} \\log^{+} \\left|\\frac{1}{w- a_{\\mu}}\\right| = & m(r,a_{\\mu}) - \\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| \\geq \\frac{\\delta}{2p}}\\log^{+} \\left|\\frac{1}{w- a_{\\mu}}\\right|\\\\\n\\geq & m(r,a_{\\mu}) - \\log \\frac{2p}{\\delta}\n\\end{aligned}$$\n\nand finally\n\n$$m(r,f) > \\sum_{1}^{p} m(r,a_{\\mu}) - p \\log\\frac{2p}{\\delta} - \\log 3$$\n\nor in conjunction with (2)\n\n$$\\begin{equation}\nm (r,\\frac{1}{w^{\\prime}}) > \\sum_{1}^{p} m(r,a_{\\mu}) - m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}}) - p \\log\\frac{2p}{\\delta} - \\log 3\n\\end{equation}$$\n\nIf the quantities $N(r, w^{\\prime})$ and $N(r, \\frac{1}{w^{\\prime}})$ are now added to both sides of inequalities (2) and (5), respectively, then using the first main\ntheorem\n\n$$T(r, w^{\\prime}) = T (r, \\frac{1}{w^{\\prime}}) + \\log |kc_{k}|$$\n\none obtains the following result, which is to be stated as a special lemma 1 :\n\nThe characteristic $T(r, w^{\\prime})$ for the derivative of the meromorphic function\nw(z) lies between the bounds\n$$m(r, w) + N(r, w^{\\prime}) + m (r,\\frac{w^{\\prime}}{w})$$\n\nand \n\n$$ \\sum_{1}^{p} m(r,\\frac{1}{w - a_{\\mu}}) + N (r,\\frac{1}{w^{\\prime}})  - m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}}) - p \\log\\frac{2p}{\\delta} - \\log 3$$\n\nIf we leave out T(r, w') and introduce\n\n$$N_{1}(r) = N(r,\\frac{1}{w^{\\prime}}) + \\left(2 N(r,w) - N (r,w^{\\prime})\\right)$$\n\nit becomes a version of this theorem. $\\square$\n\nThe estimation is rather lengthy, readers can refer to Hayman, W.[1, Chapter III] and Nevanlinna, Rolf [3, Chapter IX].\n\n\n**Remark:** The quantity $N_{1}(r)$ measures the number of multiple points of $w(z)$. It can be written in the form\n$$N_{1}(r) = \\int_{0}^{r} \\frac{n_{1}(t) - n_{1}(0)}{t} dt + n_{1}(0) \\log r,\n$$\nwhere $n_{1}(r)$ indicates the number of multiple points of $w(z)$ in the disk $|z| < r$, each $k$-fold point being counted $k -\n1$ times.\n\n**Vojta's conjecture:** Let $F$ be a number field, let $X/F$ be a non-singular algebraic variety, let $D$ be an effective divisor on $X$ with at worst normal crossings, let $H$ be an ample divisor on $X$, and let $K_{X}$ be a canonical divisor on $X$. Choose Weil height functions $h_{H}$ and $h_{K_{X}}$ and, for each absolute value $v$ on $F$, a local height function $\\lambda_{D,v}$. Fix a finite set of absolute values $S$ of $F$, and let $\\epsilon>0$. Then there is a constant $C$ and a non-empty Zariski open set $U\\subseteq X$, depending on all of the above choices, such that\n$$\\sum_{v\\in S}\\lambda_{D,v}(P)+h_{K_{X}}(P)\\leq \\epsilon h_{H}(P)+C \\quad {\\hbox{for all }}P\\in U(F).$$\n\n\n\n## Reference \n\n\n\n[1] Hayman, W. (1964). Meromorphic functions. Oxford University press.\n\n[2] Nevanlinna, Rolf (1925), \"Zur Theorie der Meromorphen Funktionen\", Acta Mathematica, 46 (12): 199, doi:10.1007/BF02543858, ISSN 0001-5962\n\n[3] Nevanlinna, Rolf (1970), Analytic functions, Die Grundlehren der mathematischen Wissenschaften, vol. 162, Berlin, New York: Springer-Verlag, MR 0279280\n\n\n\n\n","slug":"Nevanlinna Theory","published":1,"updated":"2023-12-31T07:45:17.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisung000feslr1ljad569","content":"<h2 id=\"first-main-theorem\">First Main Theorem</h2>\r\n<p>For any function <span class=\"math inline\">\\(w(z)\\)</span>\r\nmeromorphic in the disk <span class=\"math inline\">\\(|z| &lt; R &lt;\r\n\\infty\\)</span>, a function <span class=\"math inline\">\\(T(r, w)\\)</span>\r\ncan be defined for <span class=\"math inline\">\\(0 &lt; r &lt; R\\)</span>\r\nso that</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(T(r)\\)</span> is an increasing\r\nfunction of <span class=\"math inline\">\\(r\\)</span> and a convex function\r\nof <span class=\"math inline\">\\(\\log r\\)</span>.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(a\\)</span> denotes any complex\r\nnumber that is independent of <span class=\"math inline\">\\(z\\)</span>,\r\nfinite or infinite, then is <span class=\"math display\">\\[m(r, a) + N(r,\r\na) = T (r) + O(1). \\tag{I}\\]</span> where the two terms on the left of\r\nrelation (I) are nonnegative.</p></li>\r\n</ol>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>If <span class=\"math inline\">\\(\\alpha\\)</span> is a nonnegative\r\nnumber, let <span class=\"math display\">\\[\\log^{+} \\alpha =\r\n\\begin{cases}\\log \\alpha, &amp; \\alpha &gt; 1\\\\\r\n0, &amp; 0 &lt; \\alpha \\leq 1\\end{cases}\\]</span> be the larger of the\r\nnumbers <span class=\"math inline\">\\(\\log \\alpha\\)</span> and <span\r\nclass=\"math inline\">\\(0\\)</span>; it follows that <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n\\log \\alpha = \\log^{+} \\alpha - \\log^{+} \\frac{1}{\\alpha}\\\\\r\n|\\log \\alpha| = \\log^{+} \\alpha + \\log^{+} \\frac{1}{\\alpha}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>Notation as above lemma 1, and further, as is easily confirmed, <span\r\nclass=\"math display\">\\[\r\n\\begin{equation}\r\n\\begin{aligned}\r\n\\log^{+} \\alpha_{1}\\cdot \\alpha_{2}\\cdots \\alpha_{p} \\leq \\sum_{i=1}^{p}\r\n\\log^{+} {\\alpha_{i}}\\\\\r\n\\log^{+} \\sum_{i=1}^{p} {\\alpha_{i}} \\leq \\sum_{i=1}^{p} \\log^{+}\r\n\\alpha_{i} + \\log p\r\n\\end{aligned}\r\n\\end{equation}\r\n\\]</span></p>\r\n<h2 id=\"proof-of-theorem-1\">Proof of Theorem 1</h2>\r\n<p>In <a\r\nhref=\"https://en.wikipedia.org/wiki/Jensen%27s_formula\">Jensen's\r\nformula</a>, we now set <span class=\"math inline\">\\(\\log |w| = \\log^{+}\r\n|w| - \\log |\\frac{1}{w}|\\)</span> and for short write</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}N(r,a,w) =&amp;\r\n\\int_{0}^{r} \\frac{n(t,a) - n(0,a)}{t} dt + n(0,a) \\log r\\\\\r\nm(r, a, w) =&amp; \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\log^{+}\r\n\\left|\\frac{1}{w(re^{i\\varphi}) -a }\\right|d\\varphi\r\n\\end{aligned}\\]</span></p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}N(r,\\infty,w) =&amp;\r\n\\int_{0}^{r} \\frac{n(t,\\infty) - n(0,\\infty)}{t} dt + n(0,\\infty) \\log\r\nr\\\\\r\nm(r, \\infty, w) =&amp; \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\log^{+}\r\n\\left|w(re^{i\\varphi})\\right|d\\varphi\r\n\\end{aligned}\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(n(r, a)\\)</span> is the number of\r\nroots of the equation <span class=\"math inline\">\\(w- a = 0\\)</span> in\r\nthe disk <span class=\"math inline\">\\(|z|&lt;r\\)</span></p>\r\n<p>Jensen's formula then becomes</p>\r\n<p><span class=\"math display\">\\[m(r, w) + N(r, w) = m (r, \\frac{1}{w}) +\r\nN (r,\\frac{1}{w}) +\\log|c_{\\lambda}|\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(c_{\\lambda}\\)</span> is the first\r\nnonvanishing coefficient in the Laurent expansion of <span\r\nclass=\"math inline\">\\(w-a\\)</span> at the origin <span\r\nclass=\"math inline\">\\(z = 0\\)</span>.</p>\r\n<p>The result is then</p>\r\n<p><span class=\"math display\">\\[m(r, w - a) + N(r, w - a) = m (r,\r\n\\frac{1}{w-a}) + N (r, \\frac{1}{w-a}) + \\text{const.}\\]</span></p>\r\n<p>But <span class=\"math inline\">\\(N(r, w - a) = N(r, w)\\)</span></p>\r\n<p>and by Lemma 2</p>\r\n<p><span class=\"math display\">\\[\\left| m(r, w- a)- m(r, w) \\right| &lt;\r\n\\log^{+} |a|+ \\log 2\\]</span></p>\r\n<p>so we conclude from (2.3) that</p>\r\n<p><span class=\"math display\">\\[m(r, a) + N(r, a) = m(r, \\infty) +\r\nN(r,\\infty) + \\varphi(r, a),\\]</span></p>\r\n<p>In addition we set <span class=\"math inline\">\\(T(r, w) = T(r) = m(r,\r\n\\infty) + N(r, \\infty)\\)</span>, This is the desired results. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"second-main-theorem\">Second Main Theorem</h2>\r\n<ol type=\"1\">\r\n<li>For <span class=\"math inline\">\\(|z| &lt; R &lt; \\infty\\)</span> let\r\n<span class=\"math inline\">\\(w(z)\\)</span> be a nonconstant meromorphic\r\nfunction. If <span class=\"math inline\">\\(w_{1}, \\cdots , w_{q} (q \\geq\r\n1)\\)</span> are mutually distinct finite or infinite complex numbers,\r\nthen for <span class=\"math inline\">\\(0 \\leq r &lt; R\\)</span></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\sum m(r, \\omega_{\\nu}) &lt; 2 T(r) -\r\nN_{1}(r) + S(r)\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>the remainder term satisfies the following conditions:</li>\r\n</ol>\r\n<p>If <span class=\"math inline\">\\(R = \\infty\\)</span>, then <span\r\nclass=\"math display\">\\[S(r) = O \\left\\{\\log\r\n\\left[rT(r)\\right]\\right\\}\\]</span> with at most the exception of a set\r\nof values <span class=\"math inline\">\\(\\{r\\}\\)</span> of finite total\r\nmeasure</p>\r\n<p>If <span class=\"math inline\">\\(R = 1\\)</span>, then</p>\r\n<p><span class=\"math display\">\\[S(r) = O\r\n\\left\\{\\frac{1}{1-r}T(r)\\right\\}\\]</span></p>\r\n<p>with at most the exception of a set of values <span\r\nclass=\"math inline\">\\(\\{r\\}\\)</span> for which the variation of <span\r\nclass=\"math inline\">\\(\\frac{1}{1-r}\\)</span> is fintte</p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<p>Suppose, therefore, that <span class=\"math inline\">\\(w(z) = c_{0} +\r\nc_{k}z^{k} + \\cdots (c_{0}\\neq 0, c_{k} \\neq 0)\\)</span> is a function\r\nthat is meromorphic for <span class=\"math inline\">\\(|z| &lt; R \\leq\r\n\\infty\\)</span>, and let <span class=\"math inline\">\\(a_{1}, \\cdots,\r\na_{p}\\)</span> be a system of <span class=\"math inline\">\\(p \\geq\r\n2\\)</span> different finite complex numbers.</p>\r\n<p>We first compare the proximity functions <span\r\nclass=\"math inline\">\\(m(r, w)\\)</span> and <span\r\nclass=\"math inline\">\\(m(r, w^{\\prime})\\)</span> with one another. By\r\nmeans of the elementary inequalities (Lemma 2 in (I)), one finds\r\nimmediately that</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm(r,w) = m (r,w^{\\prime}\\frac{w}{w^{\\prime}}) \\leq m (r,w^{\\prime}) + m\r\n(r,\\frac{w}{w^{\\prime}})\r\n\\end{equation}\\]</span></p>\r\n<p>To estimate the mean value <span class=\"math inline\">\\(m ( r,\r\n\\frac{1}{w^{\\prime}})\\)</span> , consider the sum</p>\r\n<p><span class=\"math display\">\\[f(z) = \\sum_{\\nu=1}^{p} \\frac{1}{w(z) -\r\na_{\\nu}}\\]</span></p>\r\n<p>We have</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm(r,f) = m (r,fw^{\\prime}\\frac{1}{w^{\\prime}}) \\leq m\r\n(r,\\frac{1}{w^{\\prime}}) + m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}})\r\n\\end{equation}\\]</span></p>\r\n<p>On the other hand, for a given <span\r\nclass=\"math inline\">\\(\\mu\\)</span> (<span class=\"math inline\">\\(\\mu = 1,\r\n\\cdots , p\\)</span>)</p>\r\n<p><span class=\"math display\">\\[f = \\frac{1}{w - a_{\\mu}}\\left(1 +\r\n\\sum_{\\nu\\neq\\mu} \\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right)\\]</span></p>\r\n<p>If <span class=\"math inline\">\\(\\delta = \\min (|a_{h} - a_{k}|, 1) (h\r\n\\neq k)\\)</span>, then at every point <span\r\nclass=\"math inline\">\\(z\\)</span> where</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\left|w(z) - a_{\\mu}\\right| &lt; \\frac{\\delta}{2p} \\left(\\leq\r\n\\frac{1}{2p}\\right)\r\n\\end{equation}\\]</span></p>\r\n<p>for <span class=\"math inline\">\\(\\nu \\neq \\mu\\)</span> <span\r\nclass=\"math display\">\\[\\left|w - a_{\\nu}\\right| \\geq \\left|a_{\\mu} -\r\na_{\\nu}\\right| - \\left|w - a_{\\mu}\\right| &gt; \\delta -\r\n\\frac{\\delta}{2p} \\geq \\frac{3\\delta}{4}\\]</span></p>\r\n<p>and hence <span class=\"math display\">\\[\\sum_{\\nu\\neq\\mu}\r\n\\left|\\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right| &lt; (p-1) \\frac{2}{3p}\r\n&lt; \\frac{2}{3}\\]</span></p>\r\n<p>so that <span class=\"math display\">\\[\\left|1 + \\sum_{\\nu\\neq\\mu}\r\n\\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right| &gt; \\frac{1}{3}\\]</span></p>\r\n<p>From this it follows that <span\r\nclass=\"math display\">\\[\\log^{+}\\left|f(z)\\right| &gt;\r\n\\log^{+}\\left|\\frac{1}{w - a_{\\mu}}\\right| - \\log 3\\]</span></p>\r\n<p>at every point z where condition (4) is satisfied.</p>\r\n<p>The arcs determined on the circle by (4) are disjoint for different\r\nvalues of <span class=\"math inline\">\\(p\\)</span>, and therefore one\r\nconcludes that</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\nm(r,f) \\geq &amp; \\frac{1}{2\\pi} \\sum_{\\mu =1}^{p} \\int_{|w - a_{\\mu}|\r\n&lt; \\frac{\\delta}{2p}} \\log^{+} |f(re^{i\\varphi})| d \\varphi\\\\\r\n&lt; &amp; \\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| &lt;\r\n\\frac{\\delta}{2p}} \\left(\\log^{+} \\left|\\frac{1}{w(re^{i\\varphi})-\r\na_{\\mu}}\\right| - \\log 3\\right) d \\varphi\r\n\\end{aligned}\\]</span></p>\r\n<p>Further, <span class=\"math display\">\\[\\begin{aligned}\r\n\\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| &lt; \\frac{\\delta}{2p}}\r\n\\log^{+} \\left|\\frac{1}{w- a_{\\mu}}\\right| = &amp; m(r,a_{\\mu}) -\r\n\\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| \\geq\r\n\\frac{\\delta}{2p}}\\log^{+} \\left|\\frac{1}{w- a_{\\mu}}\\right|\\\\\r\n\\geq &amp; m(r,a_{\\mu}) - \\log \\frac{2p}{\\delta}\r\n\\end{aligned}\\]</span></p>\r\n<p>and finally</p>\r\n<p><span class=\"math display\">\\[m(r,f) &gt; \\sum_{1}^{p} m(r,a_{\\mu}) -\r\np \\log\\frac{2p}{\\delta} - \\log 3\\]</span></p>\r\n<p>or in conjunction with (2)</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm (r,\\frac{1}{w^{\\prime}}) &gt; \\sum_{1}^{p} m(r,a_{\\mu}) - m\r\n(r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}}) - p \\log\\frac{2p}{\\delta} - \\log 3\r\n\\end{equation}\\]</span></p>\r\n<p>If the quantities <span class=\"math inline\">\\(N(r,\r\nw^{\\prime})\\)</span> and <span class=\"math inline\">\\(N(r,\r\n\\frac{1}{w^{\\prime}})\\)</span> are now added to both sides of\r\ninequalities (2) and (5), respectively, then using the first main\r\ntheorem</p>\r\n<p><span class=\"math display\">\\[T(r, w^{\\prime}) = T (r,\r\n\\frac{1}{w^{\\prime}}) + \\log |kc_{k}|\\]</span></p>\r\n<p>one obtains the following result, which is to be stated as a special\r\nlemma 1 :</p>\r\n<p>The characteristic <span class=\"math inline\">\\(T(r,\r\nw^{\\prime})\\)</span> for the derivative of the meromorphic function w(z)\r\nlies between the bounds <span class=\"math display\">\\[m(r, w) + N(r,\r\nw^{\\prime}) + m (r,\\frac{w^{\\prime}}{w})\\]</span></p>\r\n<p>and</p>\r\n<p><span class=\"math display\">\\[ \\sum_{1}^{p} m(r,\\frac{1}{w - a_{\\mu}})\r\n+ N (r,\\frac{1}{w^{\\prime}})  - m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}})\r\n- p \\log\\frac{2p}{\\delta} - \\log 3\\]</span></p>\r\n<p>If we leave out T(r, w') and introduce</p>\r\n<p><span class=\"math display\">\\[N_{1}(r) = N(r,\\frac{1}{w^{\\prime}}) +\r\n\\left(2 N(r,w) - N (r,w^{\\prime})\\right)\\]</span></p>\r\n<p>it becomes a version of this theorem. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<p>The estimation is rather lengthy, readers can refer to Hayman, W.[1,\r\nChapter III] and Nevanlinna, Rolf [3, Chapter IX].</p>\r\n<p><strong>Remark:</strong> The quantity <span\r\nclass=\"math inline\">\\(N_{1}(r)\\)</span> measures the number of multiple\r\npoints of <span class=\"math inline\">\\(w(z)\\)</span>. It can be written\r\nin the form <span class=\"math display\">\\[N_{1}(r) = \\int_{0}^{r}\r\n\\frac{n_{1}(t) - n_{1}(0)}{t} dt + n_{1}(0) \\log r,\r\n\\]</span> where <span class=\"math inline\">\\(n_{1}(r)\\)</span> indicates\r\nthe number of multiple points of <span\r\nclass=\"math inline\">\\(w(z)\\)</span> in the disk <span\r\nclass=\"math inline\">\\(|z| &lt; r\\)</span>, each <span\r\nclass=\"math inline\">\\(k\\)</span>-fold point being counted <span\r\nclass=\"math inline\">\\(k - 1\\)</span> times.</p>\r\n<p><strong>Vojta's conjecture:</strong> Let <span\r\nclass=\"math inline\">\\(F\\)</span> be a number field, let <span\r\nclass=\"math inline\">\\(X/F\\)</span> be a non-singular algebraic variety,\r\nlet <span class=\"math inline\">\\(D\\)</span> be an effective divisor on\r\n<span class=\"math inline\">\\(X\\)</span> with at worst normal crossings,\r\nlet <span class=\"math inline\">\\(H\\)</span> be an ample divisor on <span\r\nclass=\"math inline\">\\(X\\)</span>, and let <span\r\nclass=\"math inline\">\\(K_{X}\\)</span> be a canonical divisor on <span\r\nclass=\"math inline\">\\(X\\)</span>. Choose Weil height functions <span\r\nclass=\"math inline\">\\(h_{H}\\)</span> and <span\r\nclass=\"math inline\">\\(h_{K_{X}}\\)</span> and, for each absolute value\r\n<span class=\"math inline\">\\(v\\)</span> on <span\r\nclass=\"math inline\">\\(F\\)</span>, a local height function <span\r\nclass=\"math inline\">\\(\\lambda_{D,v}\\)</span>. Fix a finite set of\r\nabsolute values <span class=\"math inline\">\\(S\\)</span> of <span\r\nclass=\"math inline\">\\(F\\)</span>, and let <span\r\nclass=\"math inline\">\\(\\epsilon&gt;0\\)</span>. Then there is a constant\r\n<span class=\"math inline\">\\(C\\)</span> and a non-empty Zariski open set\r\n<span class=\"math inline\">\\(U\\subseteq X\\)</span>, depending on all of\r\nthe above choices, such that <span class=\"math display\">\\[\\sum_{v\\in\r\nS}\\lambda_{D,v}(P)+h_{K_{X}}(P)\\leq \\epsilon h_{H}(P)+C \\quad {\\hbox{for\r\nall }}P\\in U(F).\\]</span></p>\r\n<h2 id=\"reference\">Reference</h2>\r\n<p>[1] Hayman, W. (1964). Meromorphic functions. Oxford University\r\npress.</p>\r\n<p>[2] Nevanlinna, Rolf (1925), \"Zur Theorie der Meromorphen\r\nFunktionen\", Acta Mathematica, 46 (12): 199, doi:10.1007/BF02543858,\r\nISSN 0001-5962</p>\r\n<p>[3] Nevanlinna, Rolf (1970), Analytic functions, Die Grundlehren der\r\nmathematischen Wissenschaften, vol. 162, Berlin, New York:\r\nSpringer-Verlag, MR 0279280</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"first-main-theorem\">First Main Theorem</h2>\r\n<p>For any function <span class=\"math inline\">\\(w(z)\\)</span>\r\nmeromorphic in the disk <span class=\"math inline\">\\(|z| &lt; R &lt;\r\n\\infty\\)</span>, a function <span class=\"math inline\">\\(T(r, w)\\)</span>\r\ncan be defined for <span class=\"math inline\">\\(0 &lt; r &lt; R\\)</span>\r\nso that</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(T(r)\\)</span> is an increasing\r\nfunction of <span class=\"math inline\">\\(r\\)</span> and a convex function\r\nof <span class=\"math inline\">\\(\\log r\\)</span>.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(a\\)</span> denotes any complex\r\nnumber that is independent of <span class=\"math inline\">\\(z\\)</span>,\r\nfinite or infinite, then is <span class=\"math display\">\\[m(r, a) + N(r,\r\na) = T (r) + O(1). \\tag{I}\\]</span> where the two terms on the left of\r\nrelation (I) are nonnegative.</p></li>\r\n</ol>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>If <span class=\"math inline\">\\(\\alpha\\)</span> is a nonnegative\r\nnumber, let <span class=\"math display\">\\[\\log^{+} \\alpha =\r\n\\begin{cases}\\log \\alpha, &amp; \\alpha &gt; 1\\\\\r\n0, &amp; 0 &lt; \\alpha \\leq 1\\end{cases}\\]</span> be the larger of the\r\nnumbers <span class=\"math inline\">\\(\\log \\alpha\\)</span> and <span\r\nclass=\"math inline\">\\(0\\)</span>; it follows that <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n\\log \\alpha = \\log^{+} \\alpha - \\log^{+} \\frac{1}{\\alpha}\\\\\r\n|\\log \\alpha| = \\log^{+} \\alpha + \\log^{+} \\frac{1}{\\alpha}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>Notation as above lemma 1, and further, as is easily confirmed, <span\r\nclass=\"math display\">\\[\r\n\\begin{equation}\r\n\\begin{aligned}\r\n\\log^{+} \\alpha_{1}\\cdot \\alpha_{2}\\cdots \\alpha_{p} \\leq \\sum_{i=1}^{p}\r\n\\log^{+} {\\alpha_{i}}\\\\\r\n\\log^{+} \\sum_{i=1}^{p} {\\alpha_{i}} \\leq \\sum_{i=1}^{p} \\log^{+}\r\n\\alpha_{i} + \\log p\r\n\\end{aligned}\r\n\\end{equation}\r\n\\]</span></p>\r\n<h2 id=\"proof-of-theorem-1\">Proof of Theorem 1</h2>\r\n<p>In <a\r\nhref=\"https://en.wikipedia.org/wiki/Jensen%27s_formula\">Jensen's\r\nformula</a>, we now set <span class=\"math inline\">\\(\\log |w| = \\log^{+}\r\n|w| - \\log |\\frac{1}{w}|\\)</span> and for short write</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}N(r,a,w) =&amp;\r\n\\int_{0}^{r} \\frac{n(t,a) - n(0,a)}{t} dt + n(0,a) \\log r\\\\\r\nm(r, a, w) =&amp; \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\log^{+}\r\n\\left|\\frac{1}{w(re^{i\\varphi}) -a }\\right|d\\varphi\r\n\\end{aligned}\\]</span></p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}N(r,\\infty,w) =&amp;\r\n\\int_{0}^{r} \\frac{n(t,\\infty) - n(0,\\infty)}{t} dt + n(0,\\infty) \\log\r\nr\\\\\r\nm(r, \\infty, w) =&amp; \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\log^{+}\r\n\\left|w(re^{i\\varphi})\\right|d\\varphi\r\n\\end{aligned}\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(n(r, a)\\)</span> is the number of\r\nroots of the equation <span class=\"math inline\">\\(w- a = 0\\)</span> in\r\nthe disk <span class=\"math inline\">\\(|z|&lt;r\\)</span></p>\r\n<p>Jensen's formula then becomes</p>\r\n<p><span class=\"math display\">\\[m(r, w) + N(r, w) = m (r, \\frac{1}{w}) +\r\nN (r,\\frac{1}{w}) +\\log|c_{\\lambda}|\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(c_{\\lambda}\\)</span> is the first\r\nnonvanishing coefficient in the Laurent expansion of <span\r\nclass=\"math inline\">\\(w-a\\)</span> at the origin <span\r\nclass=\"math inline\">\\(z = 0\\)</span>.</p>\r\n<p>The result is then</p>\r\n<p><span class=\"math display\">\\[m(r, w - a) + N(r, w - a) = m (r,\r\n\\frac{1}{w-a}) + N (r, \\frac{1}{w-a}) + \\text{const.}\\]</span></p>\r\n<p>But <span class=\"math inline\">\\(N(r, w - a) = N(r, w)\\)</span></p>\r\n<p>and by Lemma 2</p>\r\n<p><span class=\"math display\">\\[\\left| m(r, w- a)- m(r, w) \\right| &lt;\r\n\\log^{+} |a|+ \\log 2\\]</span></p>\r\n<p>so we conclude from (2.3) that</p>\r\n<p><span class=\"math display\">\\[m(r, a) + N(r, a) = m(r, \\infty) +\r\nN(r,\\infty) + \\varphi(r, a),\\]</span></p>\r\n<p>In addition we set <span class=\"math inline\">\\(T(r, w) = T(r) = m(r,\r\n\\infty) + N(r, \\infty)\\)</span>, This is the desired results. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"second-main-theorem\">Second Main Theorem</h2>\r\n<ol type=\"1\">\r\n<li>For <span class=\"math inline\">\\(|z| &lt; R &lt; \\infty\\)</span> let\r\n<span class=\"math inline\">\\(w(z)\\)</span> be a nonconstant meromorphic\r\nfunction. If <span class=\"math inline\">\\(w_{1}, \\cdots , w_{q} (q \\geq\r\n1)\\)</span> are mutually distinct finite or infinite complex numbers,\r\nthen for <span class=\"math inline\">\\(0 \\leq r &lt; R\\)</span></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\sum m(r, \\omega_{\\nu}) &lt; 2 T(r) -\r\nN_{1}(r) + S(r)\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>the remainder term satisfies the following conditions:</li>\r\n</ol>\r\n<p>If <span class=\"math inline\">\\(R = \\infty\\)</span>, then <span\r\nclass=\"math display\">\\[S(r) = O \\left\\{\\log\r\n\\left[rT(r)\\right]\\right\\}\\]</span> with at most the exception of a set\r\nof values <span class=\"math inline\">\\(\\{r\\}\\)</span> of finite total\r\nmeasure</p>\r\n<p>If <span class=\"math inline\">\\(R = 1\\)</span>, then</p>\r\n<p><span class=\"math display\">\\[S(r) = O\r\n\\left\\{\\frac{1}{1-r}T(r)\\right\\}\\]</span></p>\r\n<p>with at most the exception of a set of values <span\r\nclass=\"math inline\">\\(\\{r\\}\\)</span> for which the variation of <span\r\nclass=\"math inline\">\\(\\frac{1}{1-r}\\)</span> is fintte</p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<p>Suppose, therefore, that <span class=\"math inline\">\\(w(z) = c_{0} +\r\nc_{k}z^{k} + \\cdots (c_{0}\\neq 0, c_{k} \\neq 0)\\)</span> is a function\r\nthat is meromorphic for <span class=\"math inline\">\\(|z| &lt; R \\leq\r\n\\infty\\)</span>, and let <span class=\"math inline\">\\(a_{1}, \\cdots,\r\na_{p}\\)</span> be a system of <span class=\"math inline\">\\(p \\geq\r\n2\\)</span> different finite complex numbers.</p>\r\n<p>We first compare the proximity functions <span\r\nclass=\"math inline\">\\(m(r, w)\\)</span> and <span\r\nclass=\"math inline\">\\(m(r, w^{\\prime})\\)</span> with one another. By\r\nmeans of the elementary inequalities (Lemma 2 in (I)), one finds\r\nimmediately that</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm(r,w) = m (r,w^{\\prime}\\frac{w}{w^{\\prime}}) \\leq m (r,w^{\\prime}) + m\r\n(r,\\frac{w}{w^{\\prime}})\r\n\\end{equation}\\]</span></p>\r\n<p>To estimate the mean value <span class=\"math inline\">\\(m ( r,\r\n\\frac{1}{w^{\\prime}})\\)</span> , consider the sum</p>\r\n<p><span class=\"math display\">\\[f(z) = \\sum_{\\nu=1}^{p} \\frac{1}{w(z) -\r\na_{\\nu}}\\]</span></p>\r\n<p>We have</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm(r,f) = m (r,fw^{\\prime}\\frac{1}{w^{\\prime}}) \\leq m\r\n(r,\\frac{1}{w^{\\prime}}) + m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}})\r\n\\end{equation}\\]</span></p>\r\n<p>On the other hand, for a given <span\r\nclass=\"math inline\">\\(\\mu\\)</span> (<span class=\"math inline\">\\(\\mu = 1,\r\n\\cdots , p\\)</span>)</p>\r\n<p><span class=\"math display\">\\[f = \\frac{1}{w - a_{\\mu}}\\left(1 +\r\n\\sum_{\\nu\\neq\\mu} \\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right)\\]</span></p>\r\n<p>If <span class=\"math inline\">\\(\\delta = \\min (|a_{h} - a_{k}|, 1) (h\r\n\\neq k)\\)</span>, then at every point <span\r\nclass=\"math inline\">\\(z\\)</span> where</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\left|w(z) - a_{\\mu}\\right| &lt; \\frac{\\delta}{2p} \\left(\\leq\r\n\\frac{1}{2p}\\right)\r\n\\end{equation}\\]</span></p>\r\n<p>for <span class=\"math inline\">\\(\\nu \\neq \\mu\\)</span> <span\r\nclass=\"math display\">\\[\\left|w - a_{\\nu}\\right| \\geq \\left|a_{\\mu} -\r\na_{\\nu}\\right| - \\left|w - a_{\\mu}\\right| &gt; \\delta -\r\n\\frac{\\delta}{2p} \\geq \\frac{3\\delta}{4}\\]</span></p>\r\n<p>and hence <span class=\"math display\">\\[\\sum_{\\nu\\neq\\mu}\r\n\\left|\\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right| &lt; (p-1) \\frac{2}{3p}\r\n&lt; \\frac{2}{3}\\]</span></p>\r\n<p>so that <span class=\"math display\">\\[\\left|1 + \\sum_{\\nu\\neq\\mu}\r\n\\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right| &gt; \\frac{1}{3}\\]</span></p>\r\n<p>From this it follows that <span\r\nclass=\"math display\">\\[\\log^{+}\\left|f(z)\\right| &gt;\r\n\\log^{+}\\left|\\frac{1}{w - a_{\\mu}}\\right| - \\log 3\\]</span></p>\r\n<p>at every point z where condition (4) is satisfied.</p>\r\n<p>The arcs determined on the circle by (4) are disjoint for different\r\nvalues of <span class=\"math inline\">\\(p\\)</span>, and therefore one\r\nconcludes that</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\nm(r,f) \\geq &amp; \\frac{1}{2\\pi} \\sum_{\\mu =1}^{p} \\int_{|w - a_{\\mu}|\r\n&lt; \\frac{\\delta}{2p}} \\log^{+} |f(re^{i\\varphi})| d \\varphi\\\\\r\n&lt; &amp; \\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| &lt;\r\n\\frac{\\delta}{2p}} \\left(\\log^{+} \\left|\\frac{1}{w(re^{i\\varphi})-\r\na_{\\mu}}\\right| - \\log 3\\right) d \\varphi\r\n\\end{aligned}\\]</span></p>\r\n<p>Further, <span class=\"math display\">\\[\\begin{aligned}\r\n\\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| &lt; \\frac{\\delta}{2p}}\r\n\\log^{+} \\left|\\frac{1}{w- a_{\\mu}}\\right| = &amp; m(r,a_{\\mu}) -\r\n\\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| \\geq\r\n\\frac{\\delta}{2p}}\\log^{+} \\left|\\frac{1}{w- a_{\\mu}}\\right|\\\\\r\n\\geq &amp; m(r,a_{\\mu}) - \\log \\frac{2p}{\\delta}\r\n\\end{aligned}\\]</span></p>\r\n<p>and finally</p>\r\n<p><span class=\"math display\">\\[m(r,f) &gt; \\sum_{1}^{p} m(r,a_{\\mu}) -\r\np \\log\\frac{2p}{\\delta} - \\log 3\\]</span></p>\r\n<p>or in conjunction with (2)</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm (r,\\frac{1}{w^{\\prime}}) &gt; \\sum_{1}^{p} m(r,a_{\\mu}) - m\r\n(r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}}) - p \\log\\frac{2p}{\\delta} - \\log 3\r\n\\end{equation}\\]</span></p>\r\n<p>If the quantities <span class=\"math inline\">\\(N(r,\r\nw^{\\prime})\\)</span> and <span class=\"math inline\">\\(N(r,\r\n\\frac{1}{w^{\\prime}})\\)</span> are now added to both sides of\r\ninequalities (2) and (5), respectively, then using the first main\r\ntheorem</p>\r\n<p><span class=\"math display\">\\[T(r, w^{\\prime}) = T (r,\r\n\\frac{1}{w^{\\prime}}) + \\log |kc_{k}|\\]</span></p>\r\n<p>one obtains the following result, which is to be stated as a special\r\nlemma 1 :</p>\r\n<p>The characteristic <span class=\"math inline\">\\(T(r,\r\nw^{\\prime})\\)</span> for the derivative of the meromorphic function w(z)\r\nlies between the bounds <span class=\"math display\">\\[m(r, w) + N(r,\r\nw^{\\prime}) + m (r,\\frac{w^{\\prime}}{w})\\]</span></p>\r\n<p>and</p>\r\n<p><span class=\"math display\">\\[ \\sum_{1}^{p} m(r,\\frac{1}{w - a_{\\mu}})\r\n+ N (r,\\frac{1}{w^{\\prime}})  - m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}})\r\n- p \\log\\frac{2p}{\\delta} - \\log 3\\]</span></p>\r\n<p>If we leave out T(r, w') and introduce</p>\r\n<p><span class=\"math display\">\\[N_{1}(r) = N(r,\\frac{1}{w^{\\prime}}) +\r\n\\left(2 N(r,w) - N (r,w^{\\prime})\\right)\\]</span></p>\r\n<p>it becomes a version of this theorem. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<p>The estimation is rather lengthy, readers can refer to Hayman, W.[1,\r\nChapter III] and Nevanlinna, Rolf [3, Chapter IX].</p>\r\n<p><strong>Remark:</strong> The quantity <span\r\nclass=\"math inline\">\\(N_{1}(r)\\)</span> measures the number of multiple\r\npoints of <span class=\"math inline\">\\(w(z)\\)</span>. It can be written\r\nin the form <span class=\"math display\">\\[N_{1}(r) = \\int_{0}^{r}\r\n\\frac{n_{1}(t) - n_{1}(0)}{t} dt + n_{1}(0) \\log r,\r\n\\]</span> where <span class=\"math inline\">\\(n_{1}(r)\\)</span> indicates\r\nthe number of multiple points of <span\r\nclass=\"math inline\">\\(w(z)\\)</span> in the disk <span\r\nclass=\"math inline\">\\(|z| &lt; r\\)</span>, each <span\r\nclass=\"math inline\">\\(k\\)</span>-fold point being counted <span\r\nclass=\"math inline\">\\(k - 1\\)</span> times.</p>\r\n<p><strong>Vojta's conjecture:</strong> Let <span\r\nclass=\"math inline\">\\(F\\)</span> be a number field, let <span\r\nclass=\"math inline\">\\(X/F\\)</span> be a non-singular algebraic variety,\r\nlet <span class=\"math inline\">\\(D\\)</span> be an effective divisor on\r\n<span class=\"math inline\">\\(X\\)</span> with at worst normal crossings,\r\nlet <span class=\"math inline\">\\(H\\)</span> be an ample divisor on <span\r\nclass=\"math inline\">\\(X\\)</span>, and let <span\r\nclass=\"math inline\">\\(K_{X}\\)</span> be a canonical divisor on <span\r\nclass=\"math inline\">\\(X\\)</span>. Choose Weil height functions <span\r\nclass=\"math inline\">\\(h_{H}\\)</span> and <span\r\nclass=\"math inline\">\\(h_{K_{X}}\\)</span> and, for each absolute value\r\n<span class=\"math inline\">\\(v\\)</span> on <span\r\nclass=\"math inline\">\\(F\\)</span>, a local height function <span\r\nclass=\"math inline\">\\(\\lambda_{D,v}\\)</span>. Fix a finite set of\r\nabsolute values <span class=\"math inline\">\\(S\\)</span> of <span\r\nclass=\"math inline\">\\(F\\)</span>, and let <span\r\nclass=\"math inline\">\\(\\epsilon&gt;0\\)</span>. Then there is a constant\r\n<span class=\"math inline\">\\(C\\)</span> and a non-empty Zariski open set\r\n<span class=\"math inline\">\\(U\\subseteq X\\)</span>, depending on all of\r\nthe above choices, such that <span class=\"math display\">\\[\\sum_{v\\in\r\nS}\\lambda_{D,v}(P)+h_{K_{X}}(P)\\leq \\epsilon h_{H}(P)+C \\quad {\\hbox{for\r\nall }}P\\in U(F).\\]</span></p>\r\n<h2 id=\"reference\">Reference</h2>\r\n<p>[1] Hayman, W. (1964). Meromorphic functions. Oxford University\r\npress.</p>\r\n<p>[2] Nevanlinna, Rolf (1925), \"Zur Theorie der Meromorphen\r\nFunktionen\", Acta Mathematica, 46 (12): 199, doi:10.1007/BF02543858,\r\nISSN 0001-5962</p>\r\n<p>[3] Nevanlinna, Rolf (1970), Analytic functions, Die Grundlehren der\r\nmathematischen Wissenschaften, vol. 162, Berlin, New York:\r\nSpringer-Verlag, MR 0279280</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Dec 31 2023 15:45:17 GMT+0800 ()","title":"Nevanlinna Theory (I)","path":"2023/03/27/Nevanlinna Theory/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-03-27T10:40:09.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-03-27T10:40:09.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Sevaral Complex Variables > Nevanlinna Theory","tags":["Sevaral Complex Variables"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Nevanlinna Theory (II)","date":"2023-03-27T10:40:10.000Z","mathjax":true,"_content":"\n\n## Corollary 1 [Picard-Borel]\n\nFor a nonconstant meromorphic function there are at most two values of $a$ for which the counting function $N(r, a)$ [or $n(r, a)$] is of lower order (class, type) than the characteristic $T(r)$.\n\n## Theorem [deficiency sum]\n\nIf the function $w(z)$ is meromorphic for $z \\neq \\infty$, then the deficiency $\\delta(a)$ defined by \n\n$$\\delta(a) = \\varliminf\\limits_{r = \\infty} \\frac{m(r,a)}{T(r)} = 1 - \\varlimsup\\limits_{r = \\infty} \\frac{N(r,a)}{T(r)} $$\n\nvanishes for all but at most a countable set of values $a$. The sum of all deficiencies is at most equal to $2$:\n\n$$\\sum \\delta(a_{i}) \\leq 2$$\n\n\n\n## Corollary 2 [Picard]\nIf the curve $f(x, y) = 0$ is of genus $p > 1$, then there is no pair of meromorphic functions $x(t), y(t)$ such that $f(x(t), y(t)) = 0$.\n\n\n\n\n## Therorem [P\\'olya]\nSuppose that $f(z), g(z)$ are integral functions and that $\\phi() = g\\left(f(z)\\right)$ has finite order. Then either $f(z)$ is a polynomial or $g(z)$ has zero order.\n\n\n\nSuppose that f(z) and g(z) are transcendental, since otherwise there\nis nothing to prove. In this case it follows from (2.13) that\n\n$$T(r,\\phi) \\geq \\frac{1}{3}T(r^{n+1},g)$$\n\nfor all sufficiently large $r$, when $N$ is a fixed positive integer. Since $\\phi(z)$ has finite order $k$, say, we deduce that, for all sufficiently large $r$, we have by (2.13)\n\n$$T(r^{n+1},g) < 3r^{k+1}$$\n\nand setting $\\rho = r^{N+1}$ we deduce for all sufficiently large $\\rho$\n\n$$T(\\rho,g) < 3 \\rho^{(k+1)/(N+1)}$$\n\nSince $k$ is fixed and $N$ can be chosen as large as we please, $g(z)$ must have zero order. This proves Theorem 2.9. $\\square$\n\n# Reference\n\n\n[1] Nevanlinna R. Le thorme de Picard-Borel et la thorie des fonctions mromorphes[M]. Chelsea Publishing Company, Incorporated, 1929.\n\n\n","source":"_posts/Nevanlinna Theory2.md","raw":"---\ntitle: Nevanlinna Theory (II)\ndate: 2023-03-27 18:40:10\ntags:\n    - [Sevaral Complex Variables]\ncategories:\n    - [Sevaral Complex Variables, Nevanlinna Theory]\nmathjax: true\n---\n\n\n## Corollary 1 [Picard-Borel]\n\nFor a nonconstant meromorphic function there are at most two values of $a$ for which the counting function $N(r, a)$ [or $n(r, a)$] is of lower order (class, type) than the characteristic $T(r)$.\n\n## Theorem [deficiency sum]\n\nIf the function $w(z)$ is meromorphic for $z \\neq \\infty$, then the deficiency $\\delta(a)$ defined by \n\n$$\\delta(a) = \\varliminf\\limits_{r = \\infty} \\frac{m(r,a)}{T(r)} = 1 - \\varlimsup\\limits_{r = \\infty} \\frac{N(r,a)}{T(r)} $$\n\nvanishes for all but at most a countable set of values $a$. The sum of all deficiencies is at most equal to $2$:\n\n$$\\sum \\delta(a_{i}) \\leq 2$$\n\n\n\n## Corollary 2 [Picard]\nIf the curve $f(x, y) = 0$ is of genus $p > 1$, then there is no pair of meromorphic functions $x(t), y(t)$ such that $f(x(t), y(t)) = 0$.\n\n\n\n\n## Therorem [P\\'olya]\nSuppose that $f(z), g(z)$ are integral functions and that $\\phi() = g\\left(f(z)\\right)$ has finite order. Then either $f(z)$ is a polynomial or $g(z)$ has zero order.\n\n\n\nSuppose that f(z) and g(z) are transcendental, since otherwise there\nis nothing to prove. In this case it follows from (2.13) that\n\n$$T(r,\\phi) \\geq \\frac{1}{3}T(r^{n+1},g)$$\n\nfor all sufficiently large $r$, when $N$ is a fixed positive integer. Since $\\phi(z)$ has finite order $k$, say, we deduce that, for all sufficiently large $r$, we have by (2.13)\n\n$$T(r^{n+1},g) < 3r^{k+1}$$\n\nand setting $\\rho = r^{N+1}$ we deduce for all sufficiently large $\\rho$\n\n$$T(\\rho,g) < 3 \\rho^{(k+1)/(N+1)}$$\n\nSince $k$ is fixed and $N$ can be chosen as large as we please, $g(z)$ must have zero order. This proves Theorem 2.9. $\\square$\n\n# Reference\n\n\n[1] Nevanlinna R. Le thorme de Picard-Borel et la thorie des fonctions mromorphes[M]. Chelsea Publishing Company, Incorporated, 1929.\n\n\n","slug":"Nevanlinna Theory2","published":1,"updated":"2023-12-31T07:45:26.158Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisung000geslrfc1cal5q","content":"<h2 id=\"corollary-1-picard-borel\">Corollary 1 [Picard-Borel]</h2>\r\n<p>For a nonconstant meromorphic function there are at most two values\r\nof <span class=\"math inline\">\\(a\\)</span> for which the counting\r\nfunction <span class=\"math inline\">\\(N(r, a)\\)</span> [or <span\r\nclass=\"math inline\">\\(n(r, a)\\)</span>] is of lower order (class, type)\r\nthan the characteristic <span class=\"math inline\">\\(T(r)\\)</span>.</p>\r\n<h2 id=\"theorem-deficiency-sum\">Theorem [deficiency sum]</h2>\r\n<p>If the function <span class=\"math inline\">\\(w(z)\\)</span> is\r\nmeromorphic for <span class=\"math inline\">\\(z \\neq \\infty\\)</span>, then\r\nthe deficiency <span class=\"math inline\">\\(\\delta(a)\\)</span> defined\r\nby</p>\r\n<p><span class=\"math display\">\\[\\delta(a) = \\varliminf\\limits_{r =\r\n\\infty} \\frac{m(r,a)}{T(r)} = 1 - \\varlimsup\\limits_{r = \\infty}\r\n\\frac{N(r,a)}{T(r)} \\]</span></p>\r\n<p>vanishes for all but at most a countable set of values <span\r\nclass=\"math inline\">\\(a\\)</span>. The sum of all deficiencies is at most\r\nequal to <span class=\"math inline\">\\(2\\)</span>:</p>\r\n<p><span class=\"math display\">\\[\\sum \\delta(a_{i}) \\leq 2\\]</span></p>\r\n<h2 id=\"corollary-2-picard\">Corollary 2 [Picard]</h2>\r\n<p>If the curve <span class=\"math inline\">\\(f(x, y) = 0\\)</span> is of\r\ngenus <span class=\"math inline\">\\(p &gt; 1\\)</span>, then there is no\r\npair of meromorphic functions <span class=\"math inline\">\\(x(t),\r\ny(t)\\)</span> such that <span class=\"math inline\">\\(f(x(t), y(t)) =\r\n0\\)</span>.</p>\r\n<h2 id=\"therorem-polya\">Therorem [P'olya]</h2>\r\n<p>Suppose that <span class=\"math inline\">\\(f(z), g(z)\\)</span> are\r\nintegral functions and that <span class=\"math inline\">\\(\\phi() =\r\ng\\left(f(z)\\right)\\)</span> has finite order. Then either <span\r\nclass=\"math inline\">\\(f(z)\\)</span> is a polynomial or <span\r\nclass=\"math inline\">\\(g(z)\\)</span> has zero order.</p>\r\n<p>Suppose that f(z) and g(z) are transcendental, since otherwise there\r\nis nothing to prove. In this case it follows from (2.13) that</p>\r\n<p><span class=\"math display\">\\[T(r,\\phi) \\geq\r\n\\frac{1}{3}T(r^{n+1},g)\\]</span></p>\r\n<p>for all sufficiently large <span class=\"math inline\">\\(r\\)</span>,\r\nwhen <span class=\"math inline\">\\(N\\)</span> is a fixed positive integer.\r\nSince <span class=\"math inline\">\\(\\phi(z)\\)</span> has finite order\r\n<span class=\"math inline\">\\(k\\)</span>, say, we deduce that, for all\r\nsufficiently large <span class=\"math inline\">\\(r\\)</span>, we have by\r\n(2.13)</p>\r\n<p><span class=\"math display\">\\[T(r^{n+1},g) &lt; 3r^{k+1}\\]</span></p>\r\n<p>and setting <span class=\"math inline\">\\(\\rho = r^{N+1}\\)</span> we\r\ndeduce for all sufficiently large <span\r\nclass=\"math inline\">\\(\\rho\\)</span></p>\r\n<p><span class=\"math display\">\\[T(\\rho,g) &lt; 3\r\n\\rho^{(k+1)/(N+1)}\\]</span></p>\r\n<p>Since <span class=\"math inline\">\\(k\\)</span> is fixed and <span\r\nclass=\"math inline\">\\(N\\)</span> can be chosen as large as we please,\r\n<span class=\"math inline\">\\(g(z)\\)</span> must have zero order. This\r\nproves Theorem 2.9. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Nevanlinna R. Le thorme de Picard-Borel et la thorie des\r\nfonctions mromorphes[M]. Chelsea Publishing Company, Incorporated,\r\n1929.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"corollary-1-picard-borel\">Corollary 1 [Picard-Borel]</h2>\r\n<p>For a nonconstant meromorphic function there are at most two values\r\nof <span class=\"math inline\">\\(a\\)</span> for which the counting\r\nfunction <span class=\"math inline\">\\(N(r, a)\\)</span> [or <span\r\nclass=\"math inline\">\\(n(r, a)\\)</span>] is of lower order (class, type)\r\nthan the characteristic <span class=\"math inline\">\\(T(r)\\)</span>.</p>\r\n<h2 id=\"theorem-deficiency-sum\">Theorem [deficiency sum]</h2>\r\n<p>If the function <span class=\"math inline\">\\(w(z)\\)</span> is\r\nmeromorphic for <span class=\"math inline\">\\(z \\neq \\infty\\)</span>, then\r\nthe deficiency <span class=\"math inline\">\\(\\delta(a)\\)</span> defined\r\nby</p>\r\n<p><span class=\"math display\">\\[\\delta(a) = \\varliminf\\limits_{r =\r\n\\infty} \\frac{m(r,a)}{T(r)} = 1 - \\varlimsup\\limits_{r = \\infty}\r\n\\frac{N(r,a)}{T(r)} \\]</span></p>\r\n<p>vanishes for all but at most a countable set of values <span\r\nclass=\"math inline\">\\(a\\)</span>. The sum of all deficiencies is at most\r\nequal to <span class=\"math inline\">\\(2\\)</span>:</p>\r\n<p><span class=\"math display\">\\[\\sum \\delta(a_{i}) \\leq 2\\]</span></p>\r\n<h2 id=\"corollary-2-picard\">Corollary 2 [Picard]</h2>\r\n<p>If the curve <span class=\"math inline\">\\(f(x, y) = 0\\)</span> is of\r\ngenus <span class=\"math inline\">\\(p &gt; 1\\)</span>, then there is no\r\npair of meromorphic functions <span class=\"math inline\">\\(x(t),\r\ny(t)\\)</span> such that <span class=\"math inline\">\\(f(x(t), y(t)) =\r\n0\\)</span>.</p>\r\n<h2 id=\"therorem-polya\">Therorem [P'olya]</h2>\r\n<p>Suppose that <span class=\"math inline\">\\(f(z), g(z)\\)</span> are\r\nintegral functions and that <span class=\"math inline\">\\(\\phi() =\r\ng\\left(f(z)\\right)\\)</span> has finite order. Then either <span\r\nclass=\"math inline\">\\(f(z)\\)</span> is a polynomial or <span\r\nclass=\"math inline\">\\(g(z)\\)</span> has zero order.</p>\r\n<p>Suppose that f(z) and g(z) are transcendental, since otherwise there\r\nis nothing to prove. In this case it follows from (2.13) that</p>\r\n<p><span class=\"math display\">\\[T(r,\\phi) \\geq\r\n\\frac{1}{3}T(r^{n+1},g)\\]</span></p>\r\n<p>for all sufficiently large <span class=\"math inline\">\\(r\\)</span>,\r\nwhen <span class=\"math inline\">\\(N\\)</span> is a fixed positive integer.\r\nSince <span class=\"math inline\">\\(\\phi(z)\\)</span> has finite order\r\n<span class=\"math inline\">\\(k\\)</span>, say, we deduce that, for all\r\nsufficiently large <span class=\"math inline\">\\(r\\)</span>, we have by\r\n(2.13)</p>\r\n<p><span class=\"math display\">\\[T(r^{n+1},g) &lt; 3r^{k+1}\\]</span></p>\r\n<p>and setting <span class=\"math inline\">\\(\\rho = r^{N+1}\\)</span> we\r\ndeduce for all sufficiently large <span\r\nclass=\"math inline\">\\(\\rho\\)</span></p>\r\n<p><span class=\"math display\">\\[T(\\rho,g) &lt; 3\r\n\\rho^{(k+1)/(N+1)}\\]</span></p>\r\n<p>Since <span class=\"math inline\">\\(k\\)</span> is fixed and <span\r\nclass=\"math inline\">\\(N\\)</span> can be chosen as large as we please,\r\n<span class=\"math inline\">\\(g(z)\\)</span> must have zero order. This\r\nproves Theorem 2.9. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Nevanlinna R. Le thorme de Picard-Borel et la thorie des\r\nfonctions mromorphes[M]. Chelsea Publishing Company, Incorporated,\r\n1929.</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Dec 31 2023 15:45:26 GMT+0800 ()","title":"Nevanlinna Theory (II)","path":"2023/03/27/Nevanlinna Theory2/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-03-27T10:40:10.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-03-27T10:40:10.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Sevaral Complex Variables > Nevanlinna Theory","tags":["Sevaral Complex Variables"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Quadratic Reciprocity Law","date":"2023-03-27T10:42:10.000Z","mathjax":true,"_content":"\n\n## Quadratic Reciprocity Law\n\nLet $p$ and $q$ be distinct odd prime numbers, and define the Legendre symbol as:\n\n$$\\left({\\frac{q}{p}}\\right)=\n\\begin{cases}1&{\\text{if }}n^{2}\\equiv q{\\mod {p}}{\\text{ for some integer }}n\\\\\n-1&{\\text{otherwise}}\n\\end{cases}$$\nThen:\n\n$$\\left(\\frac {p}{q}\\right)\\left(\\frac{q}{p}\\right)=(-1)^{\\frac{p-1}{2} \\frac{q-1}{2}}$$.\n\n\n## Example\n\nThe law of decomposition of prime numbers $p$ in a quadratic number field $Q(\\sqrt{a})$ is intimately related to Gauss's famous quadratic\nreciprocity law. The latter concerns the problem of integer solutions of the equation\n$$x^{2}+by=a, (a,b \\in \\mathbb{Z}),$$\nthe simplest among the nontrivial diophantine equations. The theory of this equation reduces immediately to the case where $b$ is an odd prime number $p$ and $(a, p) = 1$ (Exercise 1). Let us assume this for the sequel. We are then facing the question as to whether $a$ is a quadratic residue $\\mod p$, i.e., whether the congruence\n\n$$x^{2} \\equiv a \\mod p$$\n\ndoes or does not have a solution. In other words, we want to know if the equation $\\bar{x}^{2} = \\bar{a}$, for a given element $\\bar{a} = a \\mod p \\in \\mathbb{F}^{*}_{p}$, admits a solution in the field $\\mathbb{F}_{p}$ or not. For this one introduces the Legendre symbol $\\left(\\frac{a}{p}\\right)$, which, for every rational number $a$ relatively prime to $p$, is defined $\\left(\\frac{a}{p}\\right) = 1$ or $-1$, according as $x^{2} \\equiv a \\mod p$ has or does not have a solution. This symbol is multiplicative,\n\n$$\\left(\\frac{ab}{p}\\right) = \\left(\\frac{a}{p}\\right) \\left(\\frac{b}{p}\\right)  $$\n\nThis is because the group $\\mathbb{F}^{*}_{p}$ is cyclic of order $p-1$ and the subgroup $\\mathbb{F}^{*2}_{p}$ of squares has index $2$, i.e., $\\mathbb{F}^{*}_{p}/\\mathbb{F}^{*2}_{p} \\cong \\mathbb{Z}/2\\mathbb{Z}$. \n. Since $\\left(\\frac{a}{p}\\right) = 1 \\Longleftrightarrow \\bar{a} \\in \\mathbb{F}_{p}^{*2}$, one also has\n\n\n$$\\left(\\frac{a}{p}\\right)=a^{\\frac{p-1}{2}} \\mod p$$.\n\nIn the case of squarefree $a$, the Legendre symbol $\\left(\\frac{a}{p}\\right)$ bears the following relation with prime factorization.  $\\left(\\frac{a}{p}\\right) = 1$ $signifies that \n\n$$x^{2} -a \\equiv (x - \\alpha) (x + \\alpha) \\mod p $$\n\nfor some $\\alpha \\in \\mathbb{Z}$. The conductor of $Z [\\sqrt{a}]$ in the ring of integers of $Q (\\sqrt{a})$ is $a$ divisor of $2$ (Exercise 2). We may therefore apply Exercise 3 and obtain the\n\n## Proposition 1\n\nFor squarefree $a$ and $(p, 2a) = 1$, we have the equivalence\n\n$$\\left(\\frac{a}{p}\\right) = 1 \\Longleftrightarrow p \\text{ is totally split in } \\mathbb{Q}(\\sqrt{a})$$\n\nFor the Legendre symbol, one has the following remarkable law, which like none other has left its mark on the development of algebraic number theory.\n\n## Theorem\n\nor two distinct odd prime\nnumbers $p$ and $q$, the following identity holds:\n\n\n$$\\left(\\frac {p}{q}\\right)\\left(\\frac{q}{p}\\right)=(-1)^{\\frac{p-1}{2} \\frac{q-1}{2}}$$.\n\nOne also has the two \"supplementary theorems\"\n\n$$\\left(\\frac{-1}{p}\\right) = (-1)^{\\frac{p-1}{2}}, \\quad \\left(\\frac{2}{p}\\right) =  (-1)^{\\frac{p^{2}-1}{8}}$$\n\n## Proof\n\n$\\left(\\frac{-1}{p}\\right) = (-1)^{\\frac{p-1}{2}} \\mod p$ implies $\\left(\\frac{-1}{p}\\right) = (-1)^{\\frac{p-1}{2}}$ since $p \\neq 2$\n\nIn order to determine $\\left(\\frac{2}{p}\\right)$, we work in the ring $\\mathbb{Z}[i]$ of Gaussian integers. Since $(1+i)^{2} = 2i$, we find\n\n$$(1+i)^{p} = (1+ i) \\left((1+i)^{2}\\right)^{\\frac{p-1}{2}} = (1+i) i^{\\frac{p-1}{2}} 2^{\\frac{p-1}{2}}$$\n\nand since $(1 + i)^{p} = 1 + i^{p} \\mod p$ and $\\left(\\frac{2}{p}\\right) =  2^{\\frac{p -1 }{2}} \\mod p$, it follows that\n\n$$\\left(\\frac{2}{p}\\right) (1+i) i^{\\frac{p-1}{2}} \\equiv 1 + i(-1)^{\\frac{p-1}{2}} \\mod p$$\n\nFrom this, an easy computation yields\n\n$$\\left(\\frac{2}{p}\\right) \\equiv (-1)^{\\frac{p-1}{4}} \\mod p, \\text{ resp. } \\left(\\frac{2}{p}\\right) =  \\equiv (-1)^{\\frac{p+1}{4}} \\mod p$$\n\nif $p-1$ is even, resp. odd. Since $\\frac{p^{2}- 1}{8} = \\frac{p-1}{4} \\frac{p+1}{2} = \\frac{p+1}{4} \\frac{p-1}{2}$, we deduce $\\left(\\frac{2}{p}\\right) = (-1)^{\\frac{p^{2}-1}{8}}$.\n\n\nIn order to prove the first formula, we work in the ring $\\mathbb{Z}[\\zeta]$, where $\\zeta$ is a primitive $p$-th root of unity. We consider the Gauss sum\n\n$$g = \\sum_{a \\in \\mathbb{Z}/p\\mathbb{Z}} \\left(\\frac{a}{p}\\right)\\zeta^{a}$$\n\nand show that\n\n$$g^{2} = \\left(\\frac{-1}{p}\\right)p$$\n\nFor this, let $a$ and $b$ vary over the group $(\\mathbb{Z}/p\\mathbb{Z})^{*}$, put $c = ab^{-1}$ and deduce from the identity $\\left(\\frac{b}{p}\\right) = \\left(\\frac{b^{-1}}{p}\\right)$ that\n\n$$\\begin{aligned}\n\\left(\\frac{-1}{p}\\right) g^{2} = &\\sum_{a,b} \\left(\\frac{-ab}{p}\\right) \\zeta^{a+b} = \\sum_{a,b} \\left(\\frac{ab^{-1}}{p}\\right) \\zeta^{a-b} = \\sum_{a,b} \\left(\\frac{c}{p}\\right) \\zeta^{bc -b}\\\\\n= & \\sum_{c\\neq 1}\\left(\\frac{c}{p}\\right) \\sum_{b}\\zeta^{b(c-1)} + \\sum_{b} \\left(\\frac{1}{p}\\right)  \n\\end{aligned}$$\n\n\n\nNow $\\sum_{c} \\left(\\frac{c}{p}\\right) = 0$, as one sees by multiplying the sum with a symbol $ \\left(\\frac{x}{p}\\right) = -1$, and putting\n$\\xi = \\zeta^{c-1}$ gives $\\sum_{b} \\zeta ^{b(c-1)} = \\xi + \\xi^{2} + \\cdots + \\xi^{p-1} = -1$ from which we indeed find that\n\n$$\\left(\\frac{-1}{p}\\right) g^{2} = (-1)(-1) + p -1 = p$$\n\nThis, together with the congruence $\\left(\\frac{p}{q}\\right) = p^{\\frac{q-1}{2}} \\mod q$ and the identity $\\left(\\frac{-1}{p}\\right) = (-1)^{\\frac{p-1}{2}}$, implies\n\n$$g^{q} = g (g^{2})^{\\frac{q-1}{2}} \\equiv g (-1)^{\\frac{p-1}{2}\\frac{q-1}{2}} \\left(\\frac{p}{q}\\right) \\mod q$$\n\nOn the other hand one has\n\n$$g^{q} = \\sum_{a} \\left(\\frac{a}{p}\\right) \\zeta^{aq} = \\left(\\frac{p}{q}\\right) \\sum_{a^{\\prime}} \\left(\\frac{aq}{p}\\right)\\zeta^{aq} \\equiv \\left(\\frac{q}{p}\\right)g \\mod q$$\n\nso that\n\n$$g\\left(\\frac{q}{p}\\right) \\equiv g (-1)^{\\frac{p-1}{2}\\frac{q-1}{2}} \\left(\\frac{p}{q}\\right) \\mod q $$\n\nMultiplying by $g$ and dividing by $\\pm p$ yields the claim. $\\square$\n\n\n\n\n## Exercise 1\nGiven a positive integer $b > 1$, an integer $a$ relatively prime to $b$ is a quadratic residue $\\mod b$ if and only if it is a quadratic residue modulo each prime divisor $p$ of $b$, and if $a - 1 \\mod 4$ when $4|b$, $8{\\small\\not|} b$, resp. $a \\equiv 1 \\mod 8$ when $8|b$.\n\n\n## Exercise 2\n\nLet $D$ be a squarefree rational integer $\\neq 0, 1$ and $d$ the discriminant of the quadratic number field $\\mathbf{K} = \\mathbb{Q}(\\sqrt{D})$. Show that\n$$\n\\begin{aligned}\nd = D, \\quad & \\text{ if } D \\equiv 1 \\mod 4\\\\\nd = 4D, \\quad & \\text{ if } D \\equiv 2 \\text{ or } 3 \\mod 4\\\\\n\\end{aligned}\n$$\nand that an integral basis of $\\mathbf{K}$ is given by $\\{1,\\sqrt{D}\\}$ in the second case, by $\\left\\{l, \\frac{1}{2}(1 +\\sqrt{D})\\right\\}$ in the first case, and by $\\left\\{1,  \\frac{1}{2}(d +\\sqrt{d})\\right\\}$ in both cases.\n\n\n## Exercise 3\n\nDenote $\\mathcal{o}$ an arbitrary\nDedekind domain and the integral closure $\\mathcal{O}$ of $\\mathcal{o}$ in a finite extension of its field of fractions.\n\nLet $\\mathsf{p}$ be a prime ideal of $\\mathcal{o}$ which is relatively prime to the\nconductor $\\mathfrak{F}$ of $\\mathcal{o}[\\theta]$, and let\n$$\\bar{p}(X) = \\bar{p}_{1}(X)^{e_{1}} \\bar{p}_{2}(X)^{e_{2}} \\cdots \\bar{p}_{r}(X)^{e_{r}}$$\nbe the factorization of the polynomial $\\bar{p} (X) = p (X) \\mod p$ into irreducibles $\\bar{p}_{i} (X) = p_{i}(X) \\mod \\mathsf{p}$ over the residue class field $\\mathcal{o}/\\mathsf{p}$, with all $p_{i} (X) \\in \\mathcal{o}[X]$ monic. Then\n$$\\mathfrak{P}_{i} = \\mathsf{p} \\mathcal{O} + p_{i}(\\theta)\\mathcal{O}, i=1,\\cdots,r,$$\n\nare the different prime ideals of $\\mathcal{O}$ above $\\mathsf{p}$. The inertia degree $f_{i}$ of $\\mathfrak{P}_{i}$ is the degree of $\\bar{p}_{i} (X)$, and one has\n$$\\mathsf{p} = \\mathfrak{P}_{1}^{e_{1}} \\cdots \\mathfrak{P}_{r}^{e_{r}}$$\n\n\n# Reference\n\n\n[1] Artin, Emil. \"Quadratische Krper im Gebiete der hheren Kongruenzen. I. Arithmetischer Teil.\" Mathematische Zeitschrift 19.1 (1924): 153-206.\n\n[2] Gauss, Carl Friedrich (1986). Disquisitiones Arithemeticae. Translated by Clarke, Arthur A. (Second, corrected ed.). New York: Springer.\n\n[3] Neukirch J. Algebraic number theory[M]. Springer Science & Business Media, 2013.\n\n[4] Weyl H. Algebraic theory of numbers[M]. Princeton University Press, 1998.\n\n\n\n","source":"_posts/Quadratic Reciprocity Law.md","raw":"---\ntitle: Quadratic Reciprocity Law\ndate: 2023-03-27 18:42:10\ntags: \n    - [Algebraic Number Theory]\ncategories: \n    - [Algebraic Number Theory]\nmathjax: true\n---\n\n\n## Quadratic Reciprocity Law\n\nLet $p$ and $q$ be distinct odd prime numbers, and define the Legendre symbol as:\n\n$$\\left({\\frac{q}{p}}\\right)=\n\\begin{cases}1&{\\text{if }}n^{2}\\equiv q{\\mod {p}}{\\text{ for some integer }}n\\\\\n-1&{\\text{otherwise}}\n\\end{cases}$$\nThen:\n\n$$\\left(\\frac {p}{q}\\right)\\left(\\frac{q}{p}\\right)=(-1)^{\\frac{p-1}{2} \\frac{q-1}{2}}$$.\n\n\n## Example\n\nThe law of decomposition of prime numbers $p$ in a quadratic number field $Q(\\sqrt{a})$ is intimately related to Gauss's famous quadratic\nreciprocity law. The latter concerns the problem of integer solutions of the equation\n$$x^{2}+by=a, (a,b \\in \\mathbb{Z}),$$\nthe simplest among the nontrivial diophantine equations. The theory of this equation reduces immediately to the case where $b$ is an odd prime number $p$ and $(a, p) = 1$ (Exercise 1). Let us assume this for the sequel. We are then facing the question as to whether $a$ is a quadratic residue $\\mod p$, i.e., whether the congruence\n\n$$x^{2} \\equiv a \\mod p$$\n\ndoes or does not have a solution. In other words, we want to know if the equation $\\bar{x}^{2} = \\bar{a}$, for a given element $\\bar{a} = a \\mod p \\in \\mathbb{F}^{*}_{p}$, admits a solution in the field $\\mathbb{F}_{p}$ or not. For this one introduces the Legendre symbol $\\left(\\frac{a}{p}\\right)$, which, for every rational number $a$ relatively prime to $p$, is defined $\\left(\\frac{a}{p}\\right) = 1$ or $-1$, according as $x^{2} \\equiv a \\mod p$ has or does not have a solution. This symbol is multiplicative,\n\n$$\\left(\\frac{ab}{p}\\right) = \\left(\\frac{a}{p}\\right) \\left(\\frac{b}{p}\\right)  $$\n\nThis is because the group $\\mathbb{F}^{*}_{p}$ is cyclic of order $p-1$ and the subgroup $\\mathbb{F}^{*2}_{p}$ of squares has index $2$, i.e., $\\mathbb{F}^{*}_{p}/\\mathbb{F}^{*2}_{p} \\cong \\mathbb{Z}/2\\mathbb{Z}$. \n. Since $\\left(\\frac{a}{p}\\right) = 1 \\Longleftrightarrow \\bar{a} \\in \\mathbb{F}_{p}^{*2}$, one also has\n\n\n$$\\left(\\frac{a}{p}\\right)=a^{\\frac{p-1}{2}} \\mod p$$.\n\nIn the case of squarefree $a$, the Legendre symbol $\\left(\\frac{a}{p}\\right)$ bears the following relation with prime factorization.  $\\left(\\frac{a}{p}\\right) = 1$ $signifies that \n\n$$x^{2} -a \\equiv (x - \\alpha) (x + \\alpha) \\mod p $$\n\nfor some $\\alpha \\in \\mathbb{Z}$. The conductor of $Z [\\sqrt{a}]$ in the ring of integers of $Q (\\sqrt{a})$ is $a$ divisor of $2$ (Exercise 2). We may therefore apply Exercise 3 and obtain the\n\n## Proposition 1\n\nFor squarefree $a$ and $(p, 2a) = 1$, we have the equivalence\n\n$$\\left(\\frac{a}{p}\\right) = 1 \\Longleftrightarrow p \\text{ is totally split in } \\mathbb{Q}(\\sqrt{a})$$\n\nFor the Legendre symbol, one has the following remarkable law, which like none other has left its mark on the development of algebraic number theory.\n\n## Theorem\n\nor two distinct odd prime\nnumbers $p$ and $q$, the following identity holds:\n\n\n$$\\left(\\frac {p}{q}\\right)\\left(\\frac{q}{p}\\right)=(-1)^{\\frac{p-1}{2} \\frac{q-1}{2}}$$.\n\nOne also has the two \"supplementary theorems\"\n\n$$\\left(\\frac{-1}{p}\\right) = (-1)^{\\frac{p-1}{2}}, \\quad \\left(\\frac{2}{p}\\right) =  (-1)^{\\frac{p^{2}-1}{8}}$$\n\n## Proof\n\n$\\left(\\frac{-1}{p}\\right) = (-1)^{\\frac{p-1}{2}} \\mod p$ implies $\\left(\\frac{-1}{p}\\right) = (-1)^{\\frac{p-1}{2}}$ since $p \\neq 2$\n\nIn order to determine $\\left(\\frac{2}{p}\\right)$, we work in the ring $\\mathbb{Z}[i]$ of Gaussian integers. Since $(1+i)^{2} = 2i$, we find\n\n$$(1+i)^{p} = (1+ i) \\left((1+i)^{2}\\right)^{\\frac{p-1}{2}} = (1+i) i^{\\frac{p-1}{2}} 2^{\\frac{p-1}{2}}$$\n\nand since $(1 + i)^{p} = 1 + i^{p} \\mod p$ and $\\left(\\frac{2}{p}\\right) =  2^{\\frac{p -1 }{2}} \\mod p$, it follows that\n\n$$\\left(\\frac{2}{p}\\right) (1+i) i^{\\frac{p-1}{2}} \\equiv 1 + i(-1)^{\\frac{p-1}{2}} \\mod p$$\n\nFrom this, an easy computation yields\n\n$$\\left(\\frac{2}{p}\\right) \\equiv (-1)^{\\frac{p-1}{4}} \\mod p, \\text{ resp. } \\left(\\frac{2}{p}\\right) =  \\equiv (-1)^{\\frac{p+1}{4}} \\mod p$$\n\nif $p-1$ is even, resp. odd. Since $\\frac{p^{2}- 1}{8} = \\frac{p-1}{4} \\frac{p+1}{2} = \\frac{p+1}{4} \\frac{p-1}{2}$, we deduce $\\left(\\frac{2}{p}\\right) = (-1)^{\\frac{p^{2}-1}{8}}$.\n\n\nIn order to prove the first formula, we work in the ring $\\mathbb{Z}[\\zeta]$, where $\\zeta$ is a primitive $p$-th root of unity. We consider the Gauss sum\n\n$$g = \\sum_{a \\in \\mathbb{Z}/p\\mathbb{Z}} \\left(\\frac{a}{p}\\right)\\zeta^{a}$$\n\nand show that\n\n$$g^{2} = \\left(\\frac{-1}{p}\\right)p$$\n\nFor this, let $a$ and $b$ vary over the group $(\\mathbb{Z}/p\\mathbb{Z})^{*}$, put $c = ab^{-1}$ and deduce from the identity $\\left(\\frac{b}{p}\\right) = \\left(\\frac{b^{-1}}{p}\\right)$ that\n\n$$\\begin{aligned}\n\\left(\\frac{-1}{p}\\right) g^{2} = &\\sum_{a,b} \\left(\\frac{-ab}{p}\\right) \\zeta^{a+b} = \\sum_{a,b} \\left(\\frac{ab^{-1}}{p}\\right) \\zeta^{a-b} = \\sum_{a,b} \\left(\\frac{c}{p}\\right) \\zeta^{bc -b}\\\\\n= & \\sum_{c\\neq 1}\\left(\\frac{c}{p}\\right) \\sum_{b}\\zeta^{b(c-1)} + \\sum_{b} \\left(\\frac{1}{p}\\right)  \n\\end{aligned}$$\n\n\n\nNow $\\sum_{c} \\left(\\frac{c}{p}\\right) = 0$, as one sees by multiplying the sum with a symbol $ \\left(\\frac{x}{p}\\right) = -1$, and putting\n$\\xi = \\zeta^{c-1}$ gives $\\sum_{b} \\zeta ^{b(c-1)} = \\xi + \\xi^{2} + \\cdots + \\xi^{p-1} = -1$ from which we indeed find that\n\n$$\\left(\\frac{-1}{p}\\right) g^{2} = (-1)(-1) + p -1 = p$$\n\nThis, together with the congruence $\\left(\\frac{p}{q}\\right) = p^{\\frac{q-1}{2}} \\mod q$ and the identity $\\left(\\frac{-1}{p}\\right) = (-1)^{\\frac{p-1}{2}}$, implies\n\n$$g^{q} = g (g^{2})^{\\frac{q-1}{2}} \\equiv g (-1)^{\\frac{p-1}{2}\\frac{q-1}{2}} \\left(\\frac{p}{q}\\right) \\mod q$$\n\nOn the other hand one has\n\n$$g^{q} = \\sum_{a} \\left(\\frac{a}{p}\\right) \\zeta^{aq} = \\left(\\frac{p}{q}\\right) \\sum_{a^{\\prime}} \\left(\\frac{aq}{p}\\right)\\zeta^{aq} \\equiv \\left(\\frac{q}{p}\\right)g \\mod q$$\n\nso that\n\n$$g\\left(\\frac{q}{p}\\right) \\equiv g (-1)^{\\frac{p-1}{2}\\frac{q-1}{2}} \\left(\\frac{p}{q}\\right) \\mod q $$\n\nMultiplying by $g$ and dividing by $\\pm p$ yields the claim. $\\square$\n\n\n\n\n## Exercise 1\nGiven a positive integer $b > 1$, an integer $a$ relatively prime to $b$ is a quadratic residue $\\mod b$ if and only if it is a quadratic residue modulo each prime divisor $p$ of $b$, and if $a - 1 \\mod 4$ when $4|b$, $8{\\small\\not|} b$, resp. $a \\equiv 1 \\mod 8$ when $8|b$.\n\n\n## Exercise 2\n\nLet $D$ be a squarefree rational integer $\\neq 0, 1$ and $d$ the discriminant of the quadratic number field $\\mathbf{K} = \\mathbb{Q}(\\sqrt{D})$. Show that\n$$\n\\begin{aligned}\nd = D, \\quad & \\text{ if } D \\equiv 1 \\mod 4\\\\\nd = 4D, \\quad & \\text{ if } D \\equiv 2 \\text{ or } 3 \\mod 4\\\\\n\\end{aligned}\n$$\nand that an integral basis of $\\mathbf{K}$ is given by $\\{1,\\sqrt{D}\\}$ in the second case, by $\\left\\{l, \\frac{1}{2}(1 +\\sqrt{D})\\right\\}$ in the first case, and by $\\left\\{1,  \\frac{1}{2}(d +\\sqrt{d})\\right\\}$ in both cases.\n\n\n## Exercise 3\n\nDenote $\\mathcal{o}$ an arbitrary\nDedekind domain and the integral closure $\\mathcal{O}$ of $\\mathcal{o}$ in a finite extension of its field of fractions.\n\nLet $\\mathsf{p}$ be a prime ideal of $\\mathcal{o}$ which is relatively prime to the\nconductor $\\mathfrak{F}$ of $\\mathcal{o}[\\theta]$, and let\n$$\\bar{p}(X) = \\bar{p}_{1}(X)^{e_{1}} \\bar{p}_{2}(X)^{e_{2}} \\cdots \\bar{p}_{r}(X)^{e_{r}}$$\nbe the factorization of the polynomial $\\bar{p} (X) = p (X) \\mod p$ into irreducibles $\\bar{p}_{i} (X) = p_{i}(X) \\mod \\mathsf{p}$ over the residue class field $\\mathcal{o}/\\mathsf{p}$, with all $p_{i} (X) \\in \\mathcal{o}[X]$ monic. Then\n$$\\mathfrak{P}_{i} = \\mathsf{p} \\mathcal{O} + p_{i}(\\theta)\\mathcal{O}, i=1,\\cdots,r,$$\n\nare the different prime ideals of $\\mathcal{O}$ above $\\mathsf{p}$. The inertia degree $f_{i}$ of $\\mathfrak{P}_{i}$ is the degree of $\\bar{p}_{i} (X)$, and one has\n$$\\mathsf{p} = \\mathfrak{P}_{1}^{e_{1}} \\cdots \\mathfrak{P}_{r}^{e_{r}}$$\n\n\n# Reference\n\n\n[1] Artin, Emil. \"Quadratische Krper im Gebiete der hheren Kongruenzen. I. Arithmetischer Teil.\" Mathematische Zeitschrift 19.1 (1924): 153-206.\n\n[2] Gauss, Carl Friedrich (1986). Disquisitiones Arithemeticae. Translated by Clarke, Arthur A. (Second, corrected ed.). New York: Springer.\n\n[3] Neukirch J. Algebraic number theory[M]. Springer Science & Business Media, 2013.\n\n[4] Weyl H. Algebraic theory of numbers[M]. Princeton University Press, 1998.\n\n\n\n","slug":"Quadratic Reciprocity Law","published":1,"updated":"2023-12-31T07:45:54.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisuni000keslrgz1rbv5i","content":"<h2 id=\"quadratic-reciprocity-law\">Quadratic Reciprocity Law</h2>\r\n<p>Let <span class=\"math inline\">\\(p\\)</span> and <span\r\nclass=\"math inline\">\\(q\\)</span> be distinct odd prime numbers, and\r\ndefine the Legendre symbol as:</p>\r\n<p><span class=\"math display\">\\[\\left({\\frac{q}{p}}\\right)=\r\n\\begin{cases}1&amp;{\\text{if }}n^{2}\\equiv q{\\mod {p}}{\\text{ for some\r\ninteger }}n\\\\\r\n-1&amp;{\\text{otherwise}}\r\n\\end{cases}\\]</span> Then:</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac\r\n{p}{q}\\right)\\left(\\frac{q}{p}\\right)=(-1)^{\\frac{p-1}{2}\r\n\\frac{q-1}{2}}\\]</span>.</p>\r\n<h2 id=\"example\">Example</h2>\r\n<p>The law of decomposition of prime numbers <span\r\nclass=\"math inline\">\\(p\\)</span> in a quadratic number field <span\r\nclass=\"math inline\">\\(Q(\\sqrt{a})\\)</span> is intimately related to\r\nGauss's famous quadratic reciprocity law. The latter concerns the\r\nproblem of integer solutions of the equation <span\r\nclass=\"math display\">\\[x^{2}+by=a, (a,b \\in \\mathbb{Z}),\\]</span> the\r\nsimplest among the nontrivial diophantine equations. The theory of this\r\nequation reduces immediately to the case where <span\r\nclass=\"math inline\">\\(b\\)</span> is an odd prime number <span\r\nclass=\"math inline\">\\(p\\)</span> and <span class=\"math inline\">\\((a, p)\r\n= 1\\)</span> (Exercise 1). Let us assume this for the sequel. We are\r\nthen facing the question as to whether <span\r\nclass=\"math inline\">\\(a\\)</span> is a quadratic residue <span\r\nclass=\"math inline\">\\(\\mod p\\)</span>, i.e., whether the congruence</p>\r\n<p><span class=\"math display\">\\[x^{2} \\equiv a \\mod p\\]</span></p>\r\n<p>does or does not have a solution. In other words, we want to know if\r\nthe equation <span class=\"math inline\">\\(\\bar{x}^{2} = \\bar{a}\\)</span>,\r\nfor a given element <span class=\"math inline\">\\(\\bar{a} = a \\mod p \\in\r\n\\mathbb{F}^{*}_{p}\\)</span>, admits a solution in the field <span\r\nclass=\"math inline\">\\(\\mathbb{F}_{p}\\)</span> or not. For this one\r\nintroduces the Legendre symbol <span\r\nclass=\"math inline\">\\(\\left(\\frac{a}{p}\\right)\\)</span>, which, for\r\nevery rational number <span class=\"math inline\">\\(a\\)</span> relatively\r\nprime to <span class=\"math inline\">\\(p\\)</span>, is defined <span\r\nclass=\"math inline\">\\(\\left(\\frac{a}{p}\\right) = 1\\)</span> or <span\r\nclass=\"math inline\">\\(-1\\)</span>, according as <span\r\nclass=\"math inline\">\\(x^{2} \\equiv a \\mod p\\)</span> has or does not\r\nhave a solution. This symbol is multiplicative,</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac{ab}{p}\\right) =\r\n\\left(\\frac{a}{p}\\right) \\left(\\frac{b}{p}\\right)  \\]</span></p>\r\n<p>This is because the group <span\r\nclass=\"math inline\">\\(\\mathbb{F}^{*}_{p}\\)</span> is cyclic of order\r\n<span class=\"math inline\">\\(p-1\\)</span> and the subgroup <span\r\nclass=\"math inline\">\\(\\mathbb{F}^{*2}_{p}\\)</span> of squares has index\r\n<span class=\"math inline\">\\(2\\)</span>, i.e., <span\r\nclass=\"math inline\">\\(\\mathbb{F}^{*}_{p}/\\mathbb{F}^{*2}_{p} \\cong\r\n\\mathbb{Z}/2\\mathbb{Z}\\)</span>. . Since <span\r\nclass=\"math inline\">\\(\\left(\\frac{a}{p}\\right) = 1 \\Longleftrightarrow\r\n\\bar{a} \\in \\mathbb{F}_{p}^{*2}\\)</span>, one also has</p>\r\n<p><span\r\nclass=\"math display\">\\[\\left(\\frac{a}{p}\\right)=a^{\\frac{p-1}{2}} \\mod\r\np\\]</span>.</p>\r\n<p>In the case of squarefree <span class=\"math inline\">\\(a\\)</span>, the\r\nLegendre symbol <span\r\nclass=\"math inline\">\\(\\left(\\frac{a}{p}\\right)\\)</span> bears the\r\nfollowing relation with prime factorization. <span\r\nclass=\"math inline\">\\(\\left(\\frac{a}{p}\\right) = 1\\)</span> $signifies\r\nthat</p>\r\n<p><span class=\"math display\">\\[x^{2} -a \\equiv (x - \\alpha) (x +\r\n\\alpha) \\mod p \\]</span></p>\r\n<p>for some <span class=\"math inline\">\\(\\alpha \\in \\mathbb{Z}\\)</span>.\r\nThe conductor of <span class=\"math inline\">\\(Z [\\sqrt{a}]\\)</span> in\r\nthe ring of integers of <span class=\"math inline\">\\(Q\r\n(\\sqrt{a})\\)</span> is <span class=\"math inline\">\\(a\\)</span> divisor of\r\n<span class=\"math inline\">\\(2\\)</span> (Exercise 2). We may therefore\r\napply Exercise 3 and obtain the</p>\r\n<h2 id=\"proposition-1\">Proposition 1</h2>\r\n<p>For squarefree <span class=\"math inline\">\\(a\\)</span> and <span\r\nclass=\"math inline\">\\((p, 2a) = 1\\)</span>, we have the equivalence</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac{a}{p}\\right) = 1\r\n\\Longleftrightarrow p \\text{ is totally split in }\r\n\\mathbb{Q}(\\sqrt{a})\\]</span></p>\r\n<p>For the Legendre symbol, one has the following remarkable law, which\r\nlike none other has left its mark on the development of algebraic number\r\ntheory.</p>\r\n<h2 id=\"theorem\">Theorem</h2>\r\n<p>or two distinct odd prime numbers <span\r\nclass=\"math inline\">\\(p\\)</span> and <span\r\nclass=\"math inline\">\\(q\\)</span>, the following identity holds:</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac\r\n{p}{q}\\right)\\left(\\frac{q}{p}\\right)=(-1)^{\\frac{p-1}{2}\r\n\\frac{q-1}{2}}\\]</span>.</p>\r\n<p>One also has the two \"supplementary theorems\"</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac{-1}{p}\\right) =\r\n(-1)^{\\frac{p-1}{2}}, \\quad \\left(\\frac{2}{p}\\right)\r\n=  (-1)^{\\frac{p^{2}-1}{8}}\\]</span></p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<p><span class=\"math inline\">\\(\\left(\\frac{-1}{p}\\right) =\r\n(-1)^{\\frac{p-1}{2}} \\mod p\\)</span> implies <span\r\nclass=\"math inline\">\\(\\left(\\frac{-1}{p}\\right) =\r\n(-1)^{\\frac{p-1}{2}}\\)</span> since <span class=\"math inline\">\\(p \\neq\r\n2\\)</span></p>\r\n<p>In order to determine <span\r\nclass=\"math inline\">\\(\\left(\\frac{2}{p}\\right)\\)</span>, we work in the\r\nring <span class=\"math inline\">\\(\\mathbb{Z}[i]\\)</span> of Gaussian\r\nintegers. Since <span class=\"math inline\">\\((1+i)^{2} = 2i\\)</span>, we\r\nfind</p>\r\n<p><span class=\"math display\">\\[(1+i)^{p} = (1+ i)\r\n\\left((1+i)^{2}\\right)^{\\frac{p-1}{2}} = (1+i) i^{\\frac{p-1}{2}}\r\n2^{\\frac{p-1}{2}}\\]</span></p>\r\n<p>and since <span class=\"math inline\">\\((1 + i)^{p} = 1 + i^{p} \\mod\r\np\\)</span> and <span class=\"math inline\">\\(\\left(\\frac{2}{p}\\right) =\r\n2^{\\frac{p -1 }{2}} \\mod p\\)</span>, it follows that</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac{2}{p}\\right) (1+i)\r\ni^{\\frac{p-1}{2}} \\equiv 1 + i(-1)^{\\frac{p-1}{2}} \\mod p\\]</span></p>\r\n<p>From this, an easy computation yields</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac{2}{p}\\right) \\equiv\r\n(-1)^{\\frac{p-1}{4}} \\mod p, \\text{ resp. } \\left(\\frac{2}{p}\\right)\r\n=  \\equiv (-1)^{\\frac{p+1}{4}} \\mod p\\]</span></p>\r\n<p>if <span class=\"math inline\">\\(p-1\\)</span> is even, resp. odd. Since\r\n<span class=\"math inline\">\\(\\frac{p^{2}- 1}{8} = \\frac{p-1}{4}\r\n\\frac{p+1}{2} = \\frac{p+1}{4} \\frac{p-1}{2}\\)</span>, we deduce <span\r\nclass=\"math inline\">\\(\\left(\\frac{2}{p}\\right) =\r\n(-1)^{\\frac{p^{2}-1}{8}}\\)</span>.</p>\r\n<p>In order to prove the first formula, we work in the ring <span\r\nclass=\"math inline\">\\(\\mathbb{Z}[\\zeta]\\)</span>, where <span\r\nclass=\"math inline\">\\(\\zeta\\)</span> is a primitive <span\r\nclass=\"math inline\">\\(p\\)</span>-th root of unity. We consider the Gauss\r\nsum</p>\r\n<p><span class=\"math display\">\\[g = \\sum_{a \\in \\mathbb{Z}/p\\mathbb{Z}}\r\n\\left(\\frac{a}{p}\\right)\\zeta^{a}\\]</span></p>\r\n<p>and show that</p>\r\n<p><span class=\"math display\">\\[g^{2} =\r\n\\left(\\frac{-1}{p}\\right)p\\]</span></p>\r\n<p>For this, let <span class=\"math inline\">\\(a\\)</span> and <span\r\nclass=\"math inline\">\\(b\\)</span> vary over the group <span\r\nclass=\"math inline\">\\((\\mathbb{Z}/p\\mathbb{Z})^{*}\\)</span>, put <span\r\nclass=\"math inline\">\\(c = ab^{-1}\\)</span> and deduce from the identity\r\n<span class=\"math inline\">\\(\\left(\\frac{b}{p}\\right) =\r\n\\left(\\frac{b^{-1}}{p}\\right)\\)</span> that</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n\\left(\\frac{-1}{p}\\right) g^{2} = &amp;\\sum_{a,b}\r\n\\left(\\frac{-ab}{p}\\right) \\zeta^{a+b} = \\sum_{a,b}\r\n\\left(\\frac{ab^{-1}}{p}\\right) \\zeta^{a-b} = \\sum_{a,b}\r\n\\left(\\frac{c}{p}\\right) \\zeta^{bc -b}\\\\\r\n= &amp; \\sum_{c\\neq 1}\\left(\\frac{c}{p}\\right) \\sum_{b}\\zeta^{b(c-1)} +\r\n\\sum_{b} \\left(\\frac{1}{p}\\right)  \r\n\\end{aligned}\\]</span></p>\r\n<p>Now <span class=\"math inline\">\\(\\sum_{c} \\left(\\frac{c}{p}\\right) =\r\n0\\)</span>, as one sees by multiplying the sum with a symbol $ () = -1$,\r\nand putting <span class=\"math inline\">\\(\\xi = \\zeta^{c-1}\\)</span> gives\r\n<span class=\"math inline\">\\(\\sum_{b} \\zeta ^{b(c-1)} = \\xi + \\xi^{2} +\r\n\\cdots + \\xi^{p-1} = -1\\)</span> from which we indeed find that</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac{-1}{p}\\right) g^{2} =\r\n(-1)(-1) + p -1 = p\\]</span></p>\r\n<p>This, together with the congruence <span\r\nclass=\"math inline\">\\(\\left(\\frac{p}{q}\\right) = p^{\\frac{q-1}{2}} \\mod\r\nq\\)</span> and the identity <span\r\nclass=\"math inline\">\\(\\left(\\frac{-1}{p}\\right) =\r\n(-1)^{\\frac{p-1}{2}}\\)</span>, implies</p>\r\n<p><span class=\"math display\">\\[g^{q} = g (g^{2})^{\\frac{q-1}{2}} \\equiv\r\ng (-1)^{\\frac{p-1}{2}\\frac{q-1}{2}} \\left(\\frac{p}{q}\\right) \\mod\r\nq\\]</span></p>\r\n<p>On the other hand one has</p>\r\n<p><span class=\"math display\">\\[g^{q} = \\sum_{a}\r\n\\left(\\frac{a}{p}\\right) \\zeta^{aq} = \\left(\\frac{p}{q}\\right)\r\n\\sum_{a^{\\prime}} \\left(\\frac{aq}{p}\\right)\\zeta^{aq} \\equiv\r\n\\left(\\frac{q}{p}\\right)g \\mod q\\]</span></p>\r\n<p>so that</p>\r\n<p><span class=\"math display\">\\[g\\left(\\frac{q}{p}\\right) \\equiv g\r\n(-1)^{\\frac{p-1}{2}\\frac{q-1}{2}} \\left(\\frac{p}{q}\\right) \\mod q\r\n\\]</span></p>\r\n<p>Multiplying by <span class=\"math inline\">\\(g\\)</span> and dividing by\r\n<span class=\"math inline\">\\(\\pm p\\)</span> yields the claim. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"exercise-1\">Exercise 1</h2>\r\n<p>Given a positive integer <span class=\"math inline\">\\(b &gt;\r\n1\\)</span>, an integer <span class=\"math inline\">\\(a\\)</span> relatively\r\nprime to <span class=\"math inline\">\\(b\\)</span> is a quadratic residue\r\n<span class=\"math inline\">\\(\\mod b\\)</span> if and only if it is a\r\nquadratic residue modulo each prime divisor <span\r\nclass=\"math inline\">\\(p\\)</span> of <span\r\nclass=\"math inline\">\\(b\\)</span>, and if <span class=\"math inline\">\\(a -\r\n1 \\mod 4\\)</span> when <span class=\"math inline\">\\(4|b\\)</span>, <span\r\nclass=\"math inline\">\\(8{\\small\\not|} b\\)</span>, resp. <span\r\nclass=\"math inline\">\\(a \\equiv 1 \\mod 8\\)</span> when <span\r\nclass=\"math inline\">\\(8|b\\)</span>.</p>\r\n<h2 id=\"exercise-2\">Exercise 2</h2>\r\n<p>Let <span class=\"math inline\">\\(D\\)</span> be a squarefree rational\r\ninteger <span class=\"math inline\">\\(\\neq 0, 1\\)</span> and <span\r\nclass=\"math inline\">\\(d\\)</span> the discriminant of the quadratic\r\nnumber field <span class=\"math inline\">\\(\\mathbf{K} =\r\n\\mathbb{Q}(\\sqrt{D})\\)</span>. Show that <span class=\"math display\">\\[\r\n\\begin{aligned}\r\nd = D, \\quad &amp; \\text{ if } D \\equiv 1 \\mod 4\\\\\r\nd = 4D, \\quad &amp; \\text{ if } D \\equiv 2 \\text{ or } 3 \\mod 4\\\\\r\n\\end{aligned}\r\n\\]</span> and that an integral basis of <span\r\nclass=\"math inline\">\\(\\mathbf{K}\\)</span> is given by <span\r\nclass=\"math inline\">\\(\\{1,\\sqrt{D}\\}\\)</span> in the second case, by\r\n<span class=\"math inline\">\\(\\left\\{l, \\frac{1}{2}(1\r\n+\\sqrt{D})\\right\\}\\)</span> in the first case, and by <span\r\nclass=\"math inline\">\\(\\left\\{1, \\frac{1}{2}(d\r\n+\\sqrt{d})\\right\\}\\)</span> in both cases.</p>\r\n<h2 id=\"exercise-3\">Exercise 3</h2>\r\n<p>Denote <span class=\"math inline\">\\(\\mathcal{o}\\)</span> an arbitrary\r\nDedekind domain and the integral closure <span\r\nclass=\"math inline\">\\(\\mathcal{O}\\)</span> of <span\r\nclass=\"math inline\">\\(\\mathcal{o}\\)</span> in a finite extension of its\r\nfield of fractions.</p>\r\n<p>Let <span class=\"math inline\">\\(\\mathsf{p}\\)</span> be a prime ideal\r\nof <span class=\"math inline\">\\(\\mathcal{o}\\)</span> which is relatively\r\nprime to the conductor <span class=\"math inline\">\\(\\mathfrak{F}\\)</span>\r\nof <span class=\"math inline\">\\(\\mathcal{o}[\\theta]\\)</span>, and let\r\n<span class=\"math display\">\\[\\bar{p}(X) = \\bar{p}_{1}(X)^{e_{1}}\r\n\\bar{p}_{2}(X)^{e_{2}} \\cdots \\bar{p}_{r}(X)^{e_{r}}\\]</span> be the\r\nfactorization of the polynomial <span class=\"math inline\">\\(\\bar{p} (X)\r\n= p (X) \\mod p\\)</span> into irreducibles <span\r\nclass=\"math inline\">\\(\\bar{p}_{i} (X) = p_{i}(X) \\mod\r\n\\mathsf{p}\\)</span> over the residue class field <span\r\nclass=\"math inline\">\\(\\mathcal{o}/\\mathsf{p}\\)</span>, with all <span\r\nclass=\"math inline\">\\(p_{i} (X) \\in \\mathcal{o}[X]\\)</span> monic. Then\r\n<span class=\"math display\">\\[\\mathfrak{P}_{i} = \\mathsf{p} \\mathcal{O} +\r\np_{i}(\\theta)\\mathcal{O}, i=1,\\cdots,r,\\]</span></p>\r\n<p>are the different prime ideals of <span\r\nclass=\"math inline\">\\(\\mathcal{O}\\)</span> above <span\r\nclass=\"math inline\">\\(\\mathsf{p}\\)</span>. The inertia degree <span\r\nclass=\"math inline\">\\(f_{i}\\)</span> of <span\r\nclass=\"math inline\">\\(\\mathfrak{P}_{i}\\)</span> is the degree of <span\r\nclass=\"math inline\">\\(\\bar{p}_{i} (X)\\)</span>, and one has <span\r\nclass=\"math display\">\\[\\mathsf{p} = \\mathfrak{P}_{1}^{e_{1}} \\cdots\r\n\\mathfrak{P}_{r}^{e_{r}}\\]</span></p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Artin, Emil. \"Quadratische Krper im Gebiete der hheren\r\nKongruenzen. I. Arithmetischer Teil.\" Mathematische Zeitschrift 19.1\r\n(1924): 153-206.</p>\r\n<p>[2] Gauss, Carl Friedrich (1986). Disquisitiones Arithemeticae.\r\nTranslated by Clarke, Arthur A. (Second, corrected ed.). New York:\r\nSpringer.</p>\r\n<p>[3] Neukirch J. Algebraic number theory[M]. Springer Science &amp;\r\nBusiness Media, 2013.</p>\r\n<p>[4] Weyl H. Algebraic theory of numbers[M]. Princeton University\r\nPress, 1998.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"quadratic-reciprocity-law\">Quadratic Reciprocity Law</h2>\r\n<p>Let <span class=\"math inline\">\\(p\\)</span> and <span\r\nclass=\"math inline\">\\(q\\)</span> be distinct odd prime numbers, and\r\ndefine the Legendre symbol as:</p>\r\n<p><span class=\"math display\">\\[\\left({\\frac{q}{p}}\\right)=\r\n\\begin{cases}1&amp;{\\text{if }}n^{2}\\equiv q{\\mod {p}}{\\text{ for some\r\ninteger }}n\\\\\r\n-1&amp;{\\text{otherwise}}\r\n\\end{cases}\\]</span> Then:</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac\r\n{p}{q}\\right)\\left(\\frac{q}{p}\\right)=(-1)^{\\frac{p-1}{2}\r\n\\frac{q-1}{2}}\\]</span>.</p>\r\n<h2 id=\"example\">Example</h2>\r\n<p>The law of decomposition of prime numbers <span\r\nclass=\"math inline\">\\(p\\)</span> in a quadratic number field <span\r\nclass=\"math inline\">\\(Q(\\sqrt{a})\\)</span> is intimately related to\r\nGauss's famous quadratic reciprocity law. The latter concerns the\r\nproblem of integer solutions of the equation <span\r\nclass=\"math display\">\\[x^{2}+by=a, (a,b \\in \\mathbb{Z}),\\]</span> the\r\nsimplest among the nontrivial diophantine equations. The theory of this\r\nequation reduces immediately to the case where <span\r\nclass=\"math inline\">\\(b\\)</span> is an odd prime number <span\r\nclass=\"math inline\">\\(p\\)</span> and <span class=\"math inline\">\\((a, p)\r\n= 1\\)</span> (Exercise 1). Let us assume this for the sequel. We are\r\nthen facing the question as to whether <span\r\nclass=\"math inline\">\\(a\\)</span> is a quadratic residue <span\r\nclass=\"math inline\">\\(\\mod p\\)</span>, i.e., whether the congruence</p>\r\n<p><span class=\"math display\">\\[x^{2} \\equiv a \\mod p\\]</span></p>\r\n<p>does or does not have a solution. In other words, we want to know if\r\nthe equation <span class=\"math inline\">\\(\\bar{x}^{2} = \\bar{a}\\)</span>,\r\nfor a given element <span class=\"math inline\">\\(\\bar{a} = a \\mod p \\in\r\n\\mathbb{F}^{*}_{p}\\)</span>, admits a solution in the field <span\r\nclass=\"math inline\">\\(\\mathbb{F}_{p}\\)</span> or not. For this one\r\nintroduces the Legendre symbol <span\r\nclass=\"math inline\">\\(\\left(\\frac{a}{p}\\right)\\)</span>, which, for\r\nevery rational number <span class=\"math inline\">\\(a\\)</span> relatively\r\nprime to <span class=\"math inline\">\\(p\\)</span>, is defined <span\r\nclass=\"math inline\">\\(\\left(\\frac{a}{p}\\right) = 1\\)</span> or <span\r\nclass=\"math inline\">\\(-1\\)</span>, according as <span\r\nclass=\"math inline\">\\(x^{2} \\equiv a \\mod p\\)</span> has or does not\r\nhave a solution. This symbol is multiplicative,</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac{ab}{p}\\right) =\r\n\\left(\\frac{a}{p}\\right) \\left(\\frac{b}{p}\\right)  \\]</span></p>\r\n<p>This is because the group <span\r\nclass=\"math inline\">\\(\\mathbb{F}^{*}_{p}\\)</span> is cyclic of order\r\n<span class=\"math inline\">\\(p-1\\)</span> and the subgroup <span\r\nclass=\"math inline\">\\(\\mathbb{F}^{*2}_{p}\\)</span> of squares has index\r\n<span class=\"math inline\">\\(2\\)</span>, i.e., <span\r\nclass=\"math inline\">\\(\\mathbb{F}^{*}_{p}/\\mathbb{F}^{*2}_{p} \\cong\r\n\\mathbb{Z}/2\\mathbb{Z}\\)</span>. . Since <span\r\nclass=\"math inline\">\\(\\left(\\frac{a}{p}\\right) = 1 \\Longleftrightarrow\r\n\\bar{a} \\in \\mathbb{F}_{p}^{*2}\\)</span>, one also has</p>\r\n<p><span\r\nclass=\"math display\">\\[\\left(\\frac{a}{p}\\right)=a^{\\frac{p-1}{2}} \\mod\r\np\\]</span>.</p>\r\n<p>In the case of squarefree <span class=\"math inline\">\\(a\\)</span>, the\r\nLegendre symbol <span\r\nclass=\"math inline\">\\(\\left(\\frac{a}{p}\\right)\\)</span> bears the\r\nfollowing relation with prime factorization. <span\r\nclass=\"math inline\">\\(\\left(\\frac{a}{p}\\right) = 1\\)</span> $signifies\r\nthat</p>\r\n<p><span class=\"math display\">\\[x^{2} -a \\equiv (x - \\alpha) (x +\r\n\\alpha) \\mod p \\]</span></p>\r\n<p>for some <span class=\"math inline\">\\(\\alpha \\in \\mathbb{Z}\\)</span>.\r\nThe conductor of <span class=\"math inline\">\\(Z [\\sqrt{a}]\\)</span> in\r\nthe ring of integers of <span class=\"math inline\">\\(Q\r\n(\\sqrt{a})\\)</span> is <span class=\"math inline\">\\(a\\)</span> divisor of\r\n<span class=\"math inline\">\\(2\\)</span> (Exercise 2). We may therefore\r\napply Exercise 3 and obtain the</p>\r\n<h2 id=\"proposition-1\">Proposition 1</h2>\r\n<p>For squarefree <span class=\"math inline\">\\(a\\)</span> and <span\r\nclass=\"math inline\">\\((p, 2a) = 1\\)</span>, we have the equivalence</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac{a}{p}\\right) = 1\r\n\\Longleftrightarrow p \\text{ is totally split in }\r\n\\mathbb{Q}(\\sqrt{a})\\]</span></p>\r\n<p>For the Legendre symbol, one has the following remarkable law, which\r\nlike none other has left its mark on the development of algebraic number\r\ntheory.</p>\r\n<h2 id=\"theorem\">Theorem</h2>\r\n<p>or two distinct odd prime numbers <span\r\nclass=\"math inline\">\\(p\\)</span> and <span\r\nclass=\"math inline\">\\(q\\)</span>, the following identity holds:</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac\r\n{p}{q}\\right)\\left(\\frac{q}{p}\\right)=(-1)^{\\frac{p-1}{2}\r\n\\frac{q-1}{2}}\\]</span>.</p>\r\n<p>One also has the two \"supplementary theorems\"</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac{-1}{p}\\right) =\r\n(-1)^{\\frac{p-1}{2}}, \\quad \\left(\\frac{2}{p}\\right)\r\n=  (-1)^{\\frac{p^{2}-1}{8}}\\]</span></p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<p><span class=\"math inline\">\\(\\left(\\frac{-1}{p}\\right) =\r\n(-1)^{\\frac{p-1}{2}} \\mod p\\)</span> implies <span\r\nclass=\"math inline\">\\(\\left(\\frac{-1}{p}\\right) =\r\n(-1)^{\\frac{p-1}{2}}\\)</span> since <span class=\"math inline\">\\(p \\neq\r\n2\\)</span></p>\r\n<p>In order to determine <span\r\nclass=\"math inline\">\\(\\left(\\frac{2}{p}\\right)\\)</span>, we work in the\r\nring <span class=\"math inline\">\\(\\mathbb{Z}[i]\\)</span> of Gaussian\r\nintegers. Since <span class=\"math inline\">\\((1+i)^{2} = 2i\\)</span>, we\r\nfind</p>\r\n<p><span class=\"math display\">\\[(1+i)^{p} = (1+ i)\r\n\\left((1+i)^{2}\\right)^{\\frac{p-1}{2}} = (1+i) i^{\\frac{p-1}{2}}\r\n2^{\\frac{p-1}{2}}\\]</span></p>\r\n<p>and since <span class=\"math inline\">\\((1 + i)^{p} = 1 + i^{p} \\mod\r\np\\)</span> and <span class=\"math inline\">\\(\\left(\\frac{2}{p}\\right) =\r\n2^{\\frac{p -1 }{2}} \\mod p\\)</span>, it follows that</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac{2}{p}\\right) (1+i)\r\ni^{\\frac{p-1}{2}} \\equiv 1 + i(-1)^{\\frac{p-1}{2}} \\mod p\\]</span></p>\r\n<p>From this, an easy computation yields</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac{2}{p}\\right) \\equiv\r\n(-1)^{\\frac{p-1}{4}} \\mod p, \\text{ resp. } \\left(\\frac{2}{p}\\right)\r\n=  \\equiv (-1)^{\\frac{p+1}{4}} \\mod p\\]</span></p>\r\n<p>if <span class=\"math inline\">\\(p-1\\)</span> is even, resp. odd. Since\r\n<span class=\"math inline\">\\(\\frac{p^{2}- 1}{8} = \\frac{p-1}{4}\r\n\\frac{p+1}{2} = \\frac{p+1}{4} \\frac{p-1}{2}\\)</span>, we deduce <span\r\nclass=\"math inline\">\\(\\left(\\frac{2}{p}\\right) =\r\n(-1)^{\\frac{p^{2}-1}{8}}\\)</span>.</p>\r\n<p>In order to prove the first formula, we work in the ring <span\r\nclass=\"math inline\">\\(\\mathbb{Z}[\\zeta]\\)</span>, where <span\r\nclass=\"math inline\">\\(\\zeta\\)</span> is a primitive <span\r\nclass=\"math inline\">\\(p\\)</span>-th root of unity. We consider the Gauss\r\nsum</p>\r\n<p><span class=\"math display\">\\[g = \\sum_{a \\in \\mathbb{Z}/p\\mathbb{Z}}\r\n\\left(\\frac{a}{p}\\right)\\zeta^{a}\\]</span></p>\r\n<p>and show that</p>\r\n<p><span class=\"math display\">\\[g^{2} =\r\n\\left(\\frac{-1}{p}\\right)p\\]</span></p>\r\n<p>For this, let <span class=\"math inline\">\\(a\\)</span> and <span\r\nclass=\"math inline\">\\(b\\)</span> vary over the group <span\r\nclass=\"math inline\">\\((\\mathbb{Z}/p\\mathbb{Z})^{*}\\)</span>, put <span\r\nclass=\"math inline\">\\(c = ab^{-1}\\)</span> and deduce from the identity\r\n<span class=\"math inline\">\\(\\left(\\frac{b}{p}\\right) =\r\n\\left(\\frac{b^{-1}}{p}\\right)\\)</span> that</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n\\left(\\frac{-1}{p}\\right) g^{2} = &amp;\\sum_{a,b}\r\n\\left(\\frac{-ab}{p}\\right) \\zeta^{a+b} = \\sum_{a,b}\r\n\\left(\\frac{ab^{-1}}{p}\\right) \\zeta^{a-b} = \\sum_{a,b}\r\n\\left(\\frac{c}{p}\\right) \\zeta^{bc -b}\\\\\r\n= &amp; \\sum_{c\\neq 1}\\left(\\frac{c}{p}\\right) \\sum_{b}\\zeta^{b(c-1)} +\r\n\\sum_{b} \\left(\\frac{1}{p}\\right)  \r\n\\end{aligned}\\]</span></p>\r\n<p>Now <span class=\"math inline\">\\(\\sum_{c} \\left(\\frac{c}{p}\\right) =\r\n0\\)</span>, as one sees by multiplying the sum with a symbol $ () = -1$,\r\nand putting <span class=\"math inline\">\\(\\xi = \\zeta^{c-1}\\)</span> gives\r\n<span class=\"math inline\">\\(\\sum_{b} \\zeta ^{b(c-1)} = \\xi + \\xi^{2} +\r\n\\cdots + \\xi^{p-1} = -1\\)</span> from which we indeed find that</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac{-1}{p}\\right) g^{2} =\r\n(-1)(-1) + p -1 = p\\]</span></p>\r\n<p>This, together with the congruence <span\r\nclass=\"math inline\">\\(\\left(\\frac{p}{q}\\right) = p^{\\frac{q-1}{2}} \\mod\r\nq\\)</span> and the identity <span\r\nclass=\"math inline\">\\(\\left(\\frac{-1}{p}\\right) =\r\n(-1)^{\\frac{p-1}{2}}\\)</span>, implies</p>\r\n<p><span class=\"math display\">\\[g^{q} = g (g^{2})^{\\frac{q-1}{2}} \\equiv\r\ng (-1)^{\\frac{p-1}{2}\\frac{q-1}{2}} \\left(\\frac{p}{q}\\right) \\mod\r\nq\\]</span></p>\r\n<p>On the other hand one has</p>\r\n<p><span class=\"math display\">\\[g^{q} = \\sum_{a}\r\n\\left(\\frac{a}{p}\\right) \\zeta^{aq} = \\left(\\frac{p}{q}\\right)\r\n\\sum_{a^{\\prime}} \\left(\\frac{aq}{p}\\right)\\zeta^{aq} \\equiv\r\n\\left(\\frac{q}{p}\\right)g \\mod q\\]</span></p>\r\n<p>so that</p>\r\n<p><span class=\"math display\">\\[g\\left(\\frac{q}{p}\\right) \\equiv g\r\n(-1)^{\\frac{p-1}{2}\\frac{q-1}{2}} \\left(\\frac{p}{q}\\right) \\mod q\r\n\\]</span></p>\r\n<p>Multiplying by <span class=\"math inline\">\\(g\\)</span> and dividing by\r\n<span class=\"math inline\">\\(\\pm p\\)</span> yields the claim. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"exercise-1\">Exercise 1</h2>\r\n<p>Given a positive integer <span class=\"math inline\">\\(b &gt;\r\n1\\)</span>, an integer <span class=\"math inline\">\\(a\\)</span> relatively\r\nprime to <span class=\"math inline\">\\(b\\)</span> is a quadratic residue\r\n<span class=\"math inline\">\\(\\mod b\\)</span> if and only if it is a\r\nquadratic residue modulo each prime divisor <span\r\nclass=\"math inline\">\\(p\\)</span> of <span\r\nclass=\"math inline\">\\(b\\)</span>, and if <span class=\"math inline\">\\(a -\r\n1 \\mod 4\\)</span> when <span class=\"math inline\">\\(4|b\\)</span>, <span\r\nclass=\"math inline\">\\(8{\\small\\not|} b\\)</span>, resp. <span\r\nclass=\"math inline\">\\(a \\equiv 1 \\mod 8\\)</span> when <span\r\nclass=\"math inline\">\\(8|b\\)</span>.</p>\r\n<h2 id=\"exercise-2\">Exercise 2</h2>\r\n<p>Let <span class=\"math inline\">\\(D\\)</span> be a squarefree rational\r\ninteger <span class=\"math inline\">\\(\\neq 0, 1\\)</span> and <span\r\nclass=\"math inline\">\\(d\\)</span> the discriminant of the quadratic\r\nnumber field <span class=\"math inline\">\\(\\mathbf{K} =\r\n\\mathbb{Q}(\\sqrt{D})\\)</span>. Show that <span class=\"math display\">\\[\r\n\\begin{aligned}\r\nd = D, \\quad &amp; \\text{ if } D \\equiv 1 \\mod 4\\\\\r\nd = 4D, \\quad &amp; \\text{ if } D \\equiv 2 \\text{ or } 3 \\mod 4\\\\\r\n\\end{aligned}\r\n\\]</span> and that an integral basis of <span\r\nclass=\"math inline\">\\(\\mathbf{K}\\)</span> is given by <span\r\nclass=\"math inline\">\\(\\{1,\\sqrt{D}\\}\\)</span> in the second case, by\r\n<span class=\"math inline\">\\(\\left\\{l, \\frac{1}{2}(1\r\n+\\sqrt{D})\\right\\}\\)</span> in the first case, and by <span\r\nclass=\"math inline\">\\(\\left\\{1, \\frac{1}{2}(d\r\n+\\sqrt{d})\\right\\}\\)</span> in both cases.</p>\r\n<h2 id=\"exercise-3\">Exercise 3</h2>\r\n<p>Denote <span class=\"math inline\">\\(\\mathcal{o}\\)</span> an arbitrary\r\nDedekind domain and the integral closure <span\r\nclass=\"math inline\">\\(\\mathcal{O}\\)</span> of <span\r\nclass=\"math inline\">\\(\\mathcal{o}\\)</span> in a finite extension of its\r\nfield of fractions.</p>\r\n<p>Let <span class=\"math inline\">\\(\\mathsf{p}\\)</span> be a prime ideal\r\nof <span class=\"math inline\">\\(\\mathcal{o}\\)</span> which is relatively\r\nprime to the conductor <span class=\"math inline\">\\(\\mathfrak{F}\\)</span>\r\nof <span class=\"math inline\">\\(\\mathcal{o}[\\theta]\\)</span>, and let\r\n<span class=\"math display\">\\[\\bar{p}(X) = \\bar{p}_{1}(X)^{e_{1}}\r\n\\bar{p}_{2}(X)^{e_{2}} \\cdots \\bar{p}_{r}(X)^{e_{r}}\\]</span> be the\r\nfactorization of the polynomial <span class=\"math inline\">\\(\\bar{p} (X)\r\n= p (X) \\mod p\\)</span> into irreducibles <span\r\nclass=\"math inline\">\\(\\bar{p}_{i} (X) = p_{i}(X) \\mod\r\n\\mathsf{p}\\)</span> over the residue class field <span\r\nclass=\"math inline\">\\(\\mathcal{o}/\\mathsf{p}\\)</span>, with all <span\r\nclass=\"math inline\">\\(p_{i} (X) \\in \\mathcal{o}[X]\\)</span> monic. Then\r\n<span class=\"math display\">\\[\\mathfrak{P}_{i} = \\mathsf{p} \\mathcal{O} +\r\np_{i}(\\theta)\\mathcal{O}, i=1,\\cdots,r,\\]</span></p>\r\n<p>are the different prime ideals of <span\r\nclass=\"math inline\">\\(\\mathcal{O}\\)</span> above <span\r\nclass=\"math inline\">\\(\\mathsf{p}\\)</span>. The inertia degree <span\r\nclass=\"math inline\">\\(f_{i}\\)</span> of <span\r\nclass=\"math inline\">\\(\\mathfrak{P}_{i}\\)</span> is the degree of <span\r\nclass=\"math inline\">\\(\\bar{p}_{i} (X)\\)</span>, and one has <span\r\nclass=\"math display\">\\[\\mathsf{p} = \\mathfrak{P}_{1}^{e_{1}} \\cdots\r\n\\mathfrak{P}_{r}^{e_{r}}\\]</span></p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Artin, Emil. \"Quadratische Krper im Gebiete der hheren\r\nKongruenzen. I. Arithmetischer Teil.\" Mathematische Zeitschrift 19.1\r\n(1924): 153-206.</p>\r\n<p>[2] Gauss, Carl Friedrich (1986). Disquisitiones Arithemeticae.\r\nTranslated by Clarke, Arthur A. (Second, corrected ed.). New York:\r\nSpringer.</p>\r\n<p>[3] Neukirch J. Algebraic number theory[M]. Springer Science &amp;\r\nBusiness Media, 2013.</p>\r\n<p>[4] Weyl H. Algebraic theory of numbers[M]. Princeton University\r\nPress, 1998.</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Dec 31 2023 15:45:54 GMT+0800 ()","title":"Quadratic Reciprocity Law","path":"2023/03/27/Quadratic Reciprocity Law/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-03-27T10:42:10.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-03-27T10:42:10.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Algebraic Number Theory","tags":["Algebraic Number Theory"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"P = NP","date":"2023-04-10T12:38:46.000Z","mathjax":true,"_content":"\n\n\nWe give the formal statement of \"P=NP\", which plays an important role  in computer science and complexity theory.\n\n\n\n## Definition 1\n\nA function $f:\\mathbb{N}^{k}\\rightarrow \\mathbb{N}$ is ***computable*** if and only if there is an effective procedure that, given any $k$-tuple $\\mathbf{x}$  of natural numbers, will produce the value $f(\\mathbf{x})$\n\n\n## Definition 2\n\nLet $\\Sigma$ be a finite alphabet (that is, a finite nonempty set) with at least two elements, and let $\\Sigma^{*}$ be the set of finite strings over $\\Sigma$. Then a ***language over $\\Sigma$*** is a subset $L$ of $\\Sigma^{*}$.\n\n\n## Definition 3\n\n\nA ***Turing machine $M$*** is a tuple $\\Sigma, \\Gamma, Q, \\delta$, where $\\Sigma, \\Gamma, Q$ are finite nonempty sets with $\\Sigma \\subseteq \\Gamma$ and $b \\in \\Gamma - \\Sigma$. The state set $Q$ contains three special states $q_{0}, q_{accept}, q_{reject}$. The transition function $\\delta$ satisfies \n$$\\delta: (Q  \\{q_{accept}, q_{reject}\\}) \\times \\Gamma \\to  Q \\times \\Gamma  \\{-1, 1\\}.$$\nIf $\\delta(q, s) = (q^{\\prime}, s^{\\prime}, h)$, the interpretation is that, if $M$ is in state $q$ scanning the symbol $s$, then $q^{\\prime}$ is the new state, $s^{\\prime}$ is the symbol printed, and the tape head moves left or right one square depending on whether h is -1 or 1.\n\n\nWe assume that the sets $Q$ and $\\Gamma$ are disjoint.\n\n\n## Definition 4\n\nA ***configuration*** of $M$ is a string $xqy$ with $x, y \\in \\Gamma^{*}$, $y$ not the empty string, and $q \\in Q$. If $C$ and $C^{\\prime}$ are configurations, then $C \\overset{M}{\\to} C^{\\prime}$ if $C = xqsy$ and $\\delta(q, s) = (q^{\\prime}, s^{\\prime}, h)$ and one of the following holds:\n\n- $C^{\\prime} = xs^{\\prime}q^{\\prime}y$ and $h = 1$ and $y$ is nonempty.\n\n- $C^{\\prime} = xs^{\\prime}q^{\\prime}b$ and $h = 1$ and $y$ is empty.\n\n- $C^{\\prime} = x^{\\prime}q^{\\prime}as^{\\prime}y$ and $h = -1$ and $x = x^{\\prime}a$ for some $a \\in \\Gamma$.\n\n- $C^{\\prime} = q^{\\prime}bs^{\\prime}y$ and $h = -1$ and $x$ is empty.\n\nA configuration $xqy$ is ***halting*** if $q \\in \\{q_{accept}, q_{reject}\\}$. Note that for each non-halting configuration $C$ there is a unique configuration $C^{\\prime}$ such that $C \\overset{M}{\\to} C^{\\prime}$. \n\n## Definition 5\n\nThe ***computation*** of $M$ on input $w \\in \\Sigma^{*}$ is the unique sequence $C_{0}, C_{1}, \\cdots$ of configurations such that $C_{0} = q_{0}w$ (or $C_{0} = q_{0}b$ if $w$ is empty) and $C_{i} \\overset{M}{\\to} C_{i+1}^{\\prime}$ for each $i$ with $C_{i+1}$ in the computation, and either the sequence is infinite or it ends in a halting configuration. If the computation is finite, then the number of steps is one less than the number of configurations; otherwise the number of steps is infinite. We say that $M$ ***accepts*** $w$ iff the computation is finite and the final configuration contains the state qaccept\n\n## Theorem 1 [Turing 1936]\nThere is no TM $M$ such that for all TMs $N$, if $M$ is run\nwith a code of $N$ on its tape, then the following hold:\n\n1. If $N$ eventually halts when run on the empty tape, then $M$ eventually halts with $1$ on the tape and the reading head on the square with the $1$.\n\n2. If $N$ does not eventually halt when run on the empty tape, then $M$ eventually halts with the tape completely empty.\n\n\n## Theorem 2\nThe set $HALT$ is not decidable, where\n$$HALT = \\left\\{M : M \\text{ is a Turing machine which halts on the empty tape }\\right\\}$$\n\n## Definition\n\nThe halting function is a function $h$ of two arguments\n\n$$h(m,n) = \\begin{cases}0, & \\text{ machine $m$, started\nwith input $n$, eventually halts }\\\\\n1, & \\text{  machine $m$, started\nwith input $n$, never halts }\n\\end{cases}$$\n\n\nBy definition of Turing computability, Halting problem is not decidable if and only if halting function $h$ is not Turing computable.\n\n## Lemma 1\n\nThe halting function h is not Turing computable.\n\n## Proof of Lemma 1\n\nBy way of background we need two special Turing machines.\n\n1. A copying machine $C$. Given a tape containing a block of $n$ strokes, and otherwise blank, if the machine is started scanning the leftmost stroke on the tape, it will eventually halt with the tape containing two blocks of $n$ strokes separated by a blank, and otherwise blank, with the machine scanning the leftmost stroke on the tape.\n\n2. A dithering machine $D$. Started on the leftmost of a block of $n$ strokes on an otherwise blank tape, $D$ eventually halts if $n > 1$, but never halts if $n = 1$.\n\nNow suppose we had a machine $H$ that computed the function $h$. We could combine the machines $C$ and $H$ as follows: if the states of $C$ are numbered $1$ through $p$, and the states of $H$ are numbered $1$ through $q$, renumber the latter states $p + 1$ through $r = p + q$, and write these renumbered instructions after the instructions\nfor $C$. Originally, $C$ tells us to halt by telling us to go into state $p + 1$, but in the new combined instructions, going into state $p + 1$ means not halting, but beginning the operations of machine $H$. So the new combined instructions will have us first go through the operations of $C$, and then, when $C$ would have halted, go through\nthe operations of $H$. The result is thus a machine $G$ that computes the function $g(n) = h(n, n)$.\n\nWe now combine this machine $G$ with the dithering machine $D$, renumbering the states of the latter as $r + 1$ and $r + 2$, and writing its instructions after those for $G$. The result will be a machine $M$ that goes through the operations of $G$ and then the operations of $D$. Thus if machine number $n$ halts when started on its own number, that is, if $h(n, n) = g(n) = 1$, then the machine $M$ does not halt when started on that number $n$, whereas if machine number $n$ does not halt when started on its own number, that is, if $h(n, n) = g(n) = 2$, then machine $M$ does halt when started on $n$.\nBut of course there can be no such machine as $M$. For what would it do if started with input its own number $m$? It would halt if and only if machine number $m$, which is to say itself, does not halt when started with input the number $m$. This contradiction shows there can be no such machine as $H$.\n\n\n## Lemma 2\n\nThere exist TMs $C$ and $D$ satisfying conditions in Lemma 1.\n\n## Proof of Lemma 2\n\nThe instruction set of $$ consists of:\n\n(1) The reading and writing head of the Turing machine moves to the right until it stops at the square where the second letter is $0$, and the letter in the square is changed to $1$. Thus, two strings composed of $1$ separated by one or some in the middle appear on the paper tape, which will continue to exist in the operation of the Turing machine after that. We call the left as input string and the right as carbon string. The corresponding instruction is\n\n$$(q_{1},s_{1},R,q_{1}), (q_{1},s_{0},R,q_{2}), (q_{2},s_{0},1,q_{2}).$$\n\n(2) Move Turing's read/write head left to the first square on the right of the input string:\n$$(q_{2},s_{1},L,q_{3}), (q_{3},s_{0},L,q_{3}).$$\n\n(3) Then determine whether the input string has more than one square. And\n\n(i). If there is more than one square in the input string, the read/write head returns to the first square to the right of the input string, rewrites the letter as $0$, then continues to the right until the first square to the right of the carbon string, rewrites the letter as $1$, then return to step (2). The corresponding instruction is:\n\n$$\\begin{aligned}\n(q_{3},s_{1},L,q_{4}), (q_{4},s_{1},R,q_{5}), (q_{5},s_{1},s_{0},q_{6}), (q_{5},s_{0},s_{0},q_{0}),\\\\\n(q_{6},s_{0},R,q_{6}), (q_{6},s_{1},s_{1},q_{7}), (q_{7},s_{1},R,q_{7}), (q_{7},s_{0},s_{1},q_{2}).\n\\end{aligned}$$\n\n(ii). If there is only one square in the input string, then the read/write head changes the letter in the $n-1$ square to the right as $1$, then returns to square $0$ and stops. The corresponding instruction is:\n\n$$\\begin{aligned}\n(q_{4},s_{0},R,q_{8}), (q_{8},s_{1},R,q_{9}), (q_{9},s_{0},s_{1},q_{9}), (q_{9},s_{1},L,q_{10}),\\\\\n(q_{10},s_{1},s_{0},q_{16}), (q_{10},s_{0},L,q_{11}), (q_{11},s_{1},L,q_{11}), (q_{11},s_{0},L,q_{0}).\n\\end{aligned}$$\n\nIt is easy to verify that a Turing machine composed of instructions (1), (2), and (3) is the replicating machine in question. As for Turing machine $D$, we simply set its instruction set to $(q_{1},s_{0},s_{0},q_{0}),(q_{1},s_{1},R,q_{1})$.$\\square$\n\n## Formal Statement P = NP\n\nWe say that $M$ accepts $w$ if this computation terminates in the accepting state. The language accepted by $M$, denoted $L(M)$, has associated alphabet $\\Sigma$ and is defined by\n\n\n$$ L(M) = \\{w \\in \\Sigma^{*} | M \\text{ accepts } w\\}.$$\n\nWe denote by $t_{M}(w)$ the number of steps in the computation of $M$ on input $w$. If this computation never halts, then $t_{M}(w) = \\infty$. For $n \\in \\mathbb{N}$ we denote by $T_{M}(n)$ the worst case run time of $M$; that is\n\n$$T_{M}(n) = \\max \\{ t_{M}(w) | w \\in \\Sigma^{n} \\},$$\n\nwhere $\\Sigma^{n}$ is the set of all strings over $\\Sigma$ of length $n$. We say that $M$ runs in polynomial time if there exists $k$ such that for all $n$, $T_{M}(n) \\leq n^{k} + k$. Now we define the class $\\mathbf{P}$ of languages by\n\n$$\\mathbf{P} = \\left\\{L | L = L(M) \\text{ for some Turing machine $M$ that runs\nin polynomial time}\\right\\}$$\n\nThe notation $\\mathbf{NP}$ stands for nondeterministic polynomial time.\n\n## Definition 6\n\nA ***checking relation*** is a binary relation $R \\subseteq \\Sigma^{*} \\times \\Sigma^{*}_{1}$ for some finite alphabets $\\Sigma$ and $\\Sigma_{1}$. We associate with each such relation $R$ a language $L_{R}$ over $\\Sigma \\cup \\Sigma_{1} \\cup \\{ \\# \\}$ defined by\n$$L_{R} = \\left\\{w \\# y | R(w, y)\\right\\}$$\nwhere the symbol $\\#$ is not in $\\Sigma$.\n\nWe say that $R$ is polynomial-time iff $L_{R} \\in \\mathbf{P}$. Now we define the class NP of languages by the condition that a language $L$ over $\\Sigma$ is in $\\mathbf{NP}$ iff there is $k \\in \\mathbb{N}$ and a polynomial-time checking relation $R$ such that for all $w \\in \\Sigma^{}$,\n$$w \\in L \\Longleftrightarrow \\exists y\\left(|y| \\leq |w|^{k} \\land R(w, y)\\right).$$\nwhere $|w|$ and $|y|$ denote the lengths of $w$ and $y$, respectively.\n\n\n<h2> Problem Statement: Dose P = NP? </h2>\n\nJudgements are left to the reader...\n\n\n\n# Reference \n\n[1] Turing, A. M. (1938). On Computable Numbers, with an Application to the Entscheidungsproblem. Proceedings of the London Mathematical Society. Wiley. s2-42 (1): 230265.\n\n\n\n","source":"_posts/P=NP.md","raw":"---\ntitle: \"P = NP\"\ndate: 2023-04-10 20:38:46\ntags:\n    - [Notes]\n    - [Mathematical Logic]\ncategories:\n    - [Notes]\n    - [Mathematical Logic]\nmathjax: true\n---\n\n\n\nWe give the formal statement of \"P=NP\", which plays an important role  in computer science and complexity theory.\n\n\n\n## Definition 1\n\nA function $f:\\mathbb{N}^{k}\\rightarrow \\mathbb{N}$ is ***computable*** if and only if there is an effective procedure that, given any $k$-tuple $\\mathbf{x}$  of natural numbers, will produce the value $f(\\mathbf{x})$\n\n\n## Definition 2\n\nLet $\\Sigma$ be a finite alphabet (that is, a finite nonempty set) with at least two elements, and let $\\Sigma^{*}$ be the set of finite strings over $\\Sigma$. Then a ***language over $\\Sigma$*** is a subset $L$ of $\\Sigma^{*}$.\n\n\n## Definition 3\n\n\nA ***Turing machine $M$*** is a tuple $\\Sigma, \\Gamma, Q, \\delta$, where $\\Sigma, \\Gamma, Q$ are finite nonempty sets with $\\Sigma \\subseteq \\Gamma$ and $b \\in \\Gamma - \\Sigma$. The state set $Q$ contains three special states $q_{0}, q_{accept}, q_{reject}$. The transition function $\\delta$ satisfies \n$$\\delta: (Q  \\{q_{accept}, q_{reject}\\}) \\times \\Gamma \\to  Q \\times \\Gamma  \\{-1, 1\\}.$$\nIf $\\delta(q, s) = (q^{\\prime}, s^{\\prime}, h)$, the interpretation is that, if $M$ is in state $q$ scanning the symbol $s$, then $q^{\\prime}$ is the new state, $s^{\\prime}$ is the symbol printed, and the tape head moves left or right one square depending on whether h is -1 or 1.\n\n\nWe assume that the sets $Q$ and $\\Gamma$ are disjoint.\n\n\n## Definition 4\n\nA ***configuration*** of $M$ is a string $xqy$ with $x, y \\in \\Gamma^{*}$, $y$ not the empty string, and $q \\in Q$. If $C$ and $C^{\\prime}$ are configurations, then $C \\overset{M}{\\to} C^{\\prime}$ if $C = xqsy$ and $\\delta(q, s) = (q^{\\prime}, s^{\\prime}, h)$ and one of the following holds:\n\n- $C^{\\prime} = xs^{\\prime}q^{\\prime}y$ and $h = 1$ and $y$ is nonempty.\n\n- $C^{\\prime} = xs^{\\prime}q^{\\prime}b$ and $h = 1$ and $y$ is empty.\n\n- $C^{\\prime} = x^{\\prime}q^{\\prime}as^{\\prime}y$ and $h = -1$ and $x = x^{\\prime}a$ for some $a \\in \\Gamma$.\n\n- $C^{\\prime} = q^{\\prime}bs^{\\prime}y$ and $h = -1$ and $x$ is empty.\n\nA configuration $xqy$ is ***halting*** if $q \\in \\{q_{accept}, q_{reject}\\}$. Note that for each non-halting configuration $C$ there is a unique configuration $C^{\\prime}$ such that $C \\overset{M}{\\to} C^{\\prime}$. \n\n## Definition 5\n\nThe ***computation*** of $M$ on input $w \\in \\Sigma^{*}$ is the unique sequence $C_{0}, C_{1}, \\cdots$ of configurations such that $C_{0} = q_{0}w$ (or $C_{0} = q_{0}b$ if $w$ is empty) and $C_{i} \\overset{M}{\\to} C_{i+1}^{\\prime}$ for each $i$ with $C_{i+1}$ in the computation, and either the sequence is infinite or it ends in a halting configuration. If the computation is finite, then the number of steps is one less than the number of configurations; otherwise the number of steps is infinite. We say that $M$ ***accepts*** $w$ iff the computation is finite and the final configuration contains the state qaccept\n\n## Theorem 1 [Turing 1936]\nThere is no TM $M$ such that for all TMs $N$, if $M$ is run\nwith a code of $N$ on its tape, then the following hold:\n\n1. If $N$ eventually halts when run on the empty tape, then $M$ eventually halts with $1$ on the tape and the reading head on the square with the $1$.\n\n2. If $N$ does not eventually halt when run on the empty tape, then $M$ eventually halts with the tape completely empty.\n\n\n## Theorem 2\nThe set $HALT$ is not decidable, where\n$$HALT = \\left\\{M : M \\text{ is a Turing machine which halts on the empty tape }\\right\\}$$\n\n## Definition\n\nThe halting function is a function $h$ of two arguments\n\n$$h(m,n) = \\begin{cases}0, & \\text{ machine $m$, started\nwith input $n$, eventually halts }\\\\\n1, & \\text{  machine $m$, started\nwith input $n$, never halts }\n\\end{cases}$$\n\n\nBy definition of Turing computability, Halting problem is not decidable if and only if halting function $h$ is not Turing computable.\n\n## Lemma 1\n\nThe halting function h is not Turing computable.\n\n## Proof of Lemma 1\n\nBy way of background we need two special Turing machines.\n\n1. A copying machine $C$. Given a tape containing a block of $n$ strokes, and otherwise blank, if the machine is started scanning the leftmost stroke on the tape, it will eventually halt with the tape containing two blocks of $n$ strokes separated by a blank, and otherwise blank, with the machine scanning the leftmost stroke on the tape.\n\n2. A dithering machine $D$. Started on the leftmost of a block of $n$ strokes on an otherwise blank tape, $D$ eventually halts if $n > 1$, but never halts if $n = 1$.\n\nNow suppose we had a machine $H$ that computed the function $h$. We could combine the machines $C$ and $H$ as follows: if the states of $C$ are numbered $1$ through $p$, and the states of $H$ are numbered $1$ through $q$, renumber the latter states $p + 1$ through $r = p + q$, and write these renumbered instructions after the instructions\nfor $C$. Originally, $C$ tells us to halt by telling us to go into state $p + 1$, but in the new combined instructions, going into state $p + 1$ means not halting, but beginning the operations of machine $H$. So the new combined instructions will have us first go through the operations of $C$, and then, when $C$ would have halted, go through\nthe operations of $H$. The result is thus a machine $G$ that computes the function $g(n) = h(n, n)$.\n\nWe now combine this machine $G$ with the dithering machine $D$, renumbering the states of the latter as $r + 1$ and $r + 2$, and writing its instructions after those for $G$. The result will be a machine $M$ that goes through the operations of $G$ and then the operations of $D$. Thus if machine number $n$ halts when started on its own number, that is, if $h(n, n) = g(n) = 1$, then the machine $M$ does not halt when started on that number $n$, whereas if machine number $n$ does not halt when started on its own number, that is, if $h(n, n) = g(n) = 2$, then machine $M$ does halt when started on $n$.\nBut of course there can be no such machine as $M$. For what would it do if started with input its own number $m$? It would halt if and only if machine number $m$, which is to say itself, does not halt when started with input the number $m$. This contradiction shows there can be no such machine as $H$.\n\n\n## Lemma 2\n\nThere exist TMs $C$ and $D$ satisfying conditions in Lemma 1.\n\n## Proof of Lemma 2\n\nThe instruction set of $$ consists of:\n\n(1) The reading and writing head of the Turing machine moves to the right until it stops at the square where the second letter is $0$, and the letter in the square is changed to $1$. Thus, two strings composed of $1$ separated by one or some in the middle appear on the paper tape, which will continue to exist in the operation of the Turing machine after that. We call the left as input string and the right as carbon string. The corresponding instruction is\n\n$$(q_{1},s_{1},R,q_{1}), (q_{1},s_{0},R,q_{2}), (q_{2},s_{0},1,q_{2}).$$\n\n(2) Move Turing's read/write head left to the first square on the right of the input string:\n$$(q_{2},s_{1},L,q_{3}), (q_{3},s_{0},L,q_{3}).$$\n\n(3) Then determine whether the input string has more than one square. And\n\n(i). If there is more than one square in the input string, the read/write head returns to the first square to the right of the input string, rewrites the letter as $0$, then continues to the right until the first square to the right of the carbon string, rewrites the letter as $1$, then return to step (2). The corresponding instruction is:\n\n$$\\begin{aligned}\n(q_{3},s_{1},L,q_{4}), (q_{4},s_{1},R,q_{5}), (q_{5},s_{1},s_{0},q_{6}), (q_{5},s_{0},s_{0},q_{0}),\\\\\n(q_{6},s_{0},R,q_{6}), (q_{6},s_{1},s_{1},q_{7}), (q_{7},s_{1},R,q_{7}), (q_{7},s_{0},s_{1},q_{2}).\n\\end{aligned}$$\n\n(ii). If there is only one square in the input string, then the read/write head changes the letter in the $n-1$ square to the right as $1$, then returns to square $0$ and stops. The corresponding instruction is:\n\n$$\\begin{aligned}\n(q_{4},s_{0},R,q_{8}), (q_{8},s_{1},R,q_{9}), (q_{9},s_{0},s_{1},q_{9}), (q_{9},s_{1},L,q_{10}),\\\\\n(q_{10},s_{1},s_{0},q_{16}), (q_{10},s_{0},L,q_{11}), (q_{11},s_{1},L,q_{11}), (q_{11},s_{0},L,q_{0}).\n\\end{aligned}$$\n\nIt is easy to verify that a Turing machine composed of instructions (1), (2), and (3) is the replicating machine in question. As for Turing machine $D$, we simply set its instruction set to $(q_{1},s_{0},s_{0},q_{0}),(q_{1},s_{1},R,q_{1})$.$\\square$\n\n## Formal Statement P = NP\n\nWe say that $M$ accepts $w$ if this computation terminates in the accepting state. The language accepted by $M$, denoted $L(M)$, has associated alphabet $\\Sigma$ and is defined by\n\n\n$$ L(M) = \\{w \\in \\Sigma^{*} | M \\text{ accepts } w\\}.$$\n\nWe denote by $t_{M}(w)$ the number of steps in the computation of $M$ on input $w$. If this computation never halts, then $t_{M}(w) = \\infty$. For $n \\in \\mathbb{N}$ we denote by $T_{M}(n)$ the worst case run time of $M$; that is\n\n$$T_{M}(n) = \\max \\{ t_{M}(w) | w \\in \\Sigma^{n} \\},$$\n\nwhere $\\Sigma^{n}$ is the set of all strings over $\\Sigma$ of length $n$. We say that $M$ runs in polynomial time if there exists $k$ such that for all $n$, $T_{M}(n) \\leq n^{k} + k$. Now we define the class $\\mathbf{P}$ of languages by\n\n$$\\mathbf{P} = \\left\\{L | L = L(M) \\text{ for some Turing machine $M$ that runs\nin polynomial time}\\right\\}$$\n\nThe notation $\\mathbf{NP}$ stands for nondeterministic polynomial time.\n\n## Definition 6\n\nA ***checking relation*** is a binary relation $R \\subseteq \\Sigma^{*} \\times \\Sigma^{*}_{1}$ for some finite alphabets $\\Sigma$ and $\\Sigma_{1}$. We associate with each such relation $R$ a language $L_{R}$ over $\\Sigma \\cup \\Sigma_{1} \\cup \\{ \\# \\}$ defined by\n$$L_{R} = \\left\\{w \\# y | R(w, y)\\right\\}$$\nwhere the symbol $\\#$ is not in $\\Sigma$.\n\nWe say that $R$ is polynomial-time iff $L_{R} \\in \\mathbf{P}$. Now we define the class NP of languages by the condition that a language $L$ over $\\Sigma$ is in $\\mathbf{NP}$ iff there is $k \\in \\mathbb{N}$ and a polynomial-time checking relation $R$ such that for all $w \\in \\Sigma^{}$,\n$$w \\in L \\Longleftrightarrow \\exists y\\left(|y| \\leq |w|^{k} \\land R(w, y)\\right).$$\nwhere $|w|$ and $|y|$ denote the lengths of $w$ and $y$, respectively.\n\n\n<h2> Problem Statement: Dose P = NP? </h2>\n\nJudgements are left to the reader...\n\n\n\n# Reference \n\n[1] Turing, A. M. (1938). On Computable Numbers, with an Application to the Entscheidungsproblem. Proceedings of the London Mathematical Society. Wiley. s2-42 (1): 230265.\n\n\n\n","slug":"P=NP","published":1,"updated":"2023-12-31T07:45:45.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisunj000meslr1cuy8ey9","content":"<p>We give the formal statement of \"P=NP\", which plays an important role\r\nin computer science and complexity theory.</p>\r\n<h2 id=\"definition-1\">Definition 1</h2>\r\n<p>A function <span class=\"math inline\">\\(f:\\mathbb{N}^{k}\\rightarrow\r\n\\mathbb{N}\\)</span> is <strong><em>computable</em></strong> if and only\r\nif there is an effective procedure that, given any <span\r\nclass=\"math inline\">\\(k\\)</span>-tuple <span\r\nclass=\"math inline\">\\(\\mathbf{x}\\)</span> of natural numbers, will\r\nproduce the value <span class=\"math inline\">\\(f(\\mathbf{x})\\)</span></p>\r\n<h2 id=\"definition-2\">Definition 2</h2>\r\n<p>Let <span class=\"math inline\">\\(\\Sigma\\)</span> be a finite alphabet\r\n(that is, a finite nonempty set) with at least two elements, and let\r\n<span class=\"math inline\">\\(\\Sigma^{*}\\)</span> be the set of finite\r\nstrings over <span class=\"math inline\">\\(\\Sigma\\)</span>. Then a\r\n<strong><em>language over <span\r\nclass=\"math inline\">\\(\\Sigma\\)</span></em></strong> is a subset <span\r\nclass=\"math inline\">\\(L\\)</span> of <span\r\nclass=\"math inline\">\\(\\Sigma^{*}\\)</span>.</p>\r\n<h2 id=\"definition-3\">Definition 3</h2>\r\n<p>A <strong><em>Turing machine <span\r\nclass=\"math inline\">\\(M\\)</span></em></strong> is a tuple <span\r\nclass=\"math inline\">\\(\\Sigma, \\Gamma, Q, \\delta\\)</span>, where <span\r\nclass=\"math inline\">\\(\\Sigma, \\Gamma, Q\\)</span> are finite nonempty\r\nsets with <span class=\"math inline\">\\(\\Sigma \\subseteq \\Gamma\\)</span>\r\nand <span class=\"math inline\">\\(b \\in \\Gamma - \\Sigma\\)</span>. The\r\nstate set <span class=\"math inline\">\\(Q\\)</span> contains three special\r\nstates <span class=\"math inline\">\\(q_{0}, q_{accept},\r\nq_{reject}\\)</span>. The transition function <span\r\nclass=\"math inline\">\\(\\delta\\)</span> satisfies <span\r\nclass=\"math display\">\\[\\delta: (Q  \\{q_{accept}, q_{reject}\\}) \\times\r\n\\Gamma \\to  Q \\times \\Gamma  \\{-1, 1\\}.\\]</span> If <span\r\nclass=\"math inline\">\\(\\delta(q, s) = (q^{\\prime}, s^{\\prime},\r\nh)\\)</span>, the interpretation is that, if <span\r\nclass=\"math inline\">\\(M\\)</span> is in state <span\r\nclass=\"math inline\">\\(q\\)</span> scanning the symbol <span\r\nclass=\"math inline\">\\(s\\)</span>, then <span\r\nclass=\"math inline\">\\(q^{\\prime}\\)</span> is the new state, <span\r\nclass=\"math inline\">\\(s^{\\prime}\\)</span> is the symbol printed, and the\r\ntape head moves left or right one square depending on whether h is -1 or\r\n1.</p>\r\n<p>We assume that the sets <span class=\"math inline\">\\(Q\\)</span> and\r\n<span class=\"math inline\">\\(\\Gamma\\)</span> are disjoint.</p>\r\n<h2 id=\"definition-4\">Definition 4</h2>\r\n<p>A <strong><em>configuration</em></strong> of <span\r\nclass=\"math inline\">\\(M\\)</span> is a string <span\r\nclass=\"math inline\">\\(xqy\\)</span> with <span class=\"math inline\">\\(x, y\r\n\\in \\Gamma^{*}\\)</span>, <span class=\"math inline\">\\(y\\)</span> not the\r\nempty string, and <span class=\"math inline\">\\(q \\in Q\\)</span>. If <span\r\nclass=\"math inline\">\\(C\\)</span> and <span\r\nclass=\"math inline\">\\(C^{\\prime}\\)</span> are configurations, then <span\r\nclass=\"math inline\">\\(C \\overset{M}{\\to} C^{\\prime}\\)</span> if <span\r\nclass=\"math inline\">\\(C = xqsy\\)</span> and <span\r\nclass=\"math inline\">\\(\\delta(q, s) = (q^{\\prime}, s^{\\prime},\r\nh)\\)</span> and one of the following holds:</p>\r\n<ul>\r\n<li><p><span class=\"math inline\">\\(C^{\\prime} =\r\nxs^{\\prime}q^{\\prime}y\\)</span> and <span class=\"math inline\">\\(h =\r\n1\\)</span> and <span class=\"math inline\">\\(y\\)</span> is\r\nnonempty.</p></li>\r\n<li><p><span class=\"math inline\">\\(C^{\\prime} =\r\nxs^{\\prime}q^{\\prime}b\\)</span> and <span class=\"math inline\">\\(h =\r\n1\\)</span> and <span class=\"math inline\">\\(y\\)</span> is empty.</p></li>\r\n<li><p><span class=\"math inline\">\\(C^{\\prime} =\r\nx^{\\prime}q^{\\prime}as^{\\prime}y\\)</span> and <span\r\nclass=\"math inline\">\\(h = -1\\)</span> and <span class=\"math inline\">\\(x\r\n= x^{\\prime}a\\)</span> for some <span class=\"math inline\">\\(a \\in\r\n\\Gamma\\)</span>.</p></li>\r\n<li><p><span class=\"math inline\">\\(C^{\\prime} =\r\nq^{\\prime}bs^{\\prime}y\\)</span> and <span class=\"math inline\">\\(h =\r\n-1\\)</span> and <span class=\"math inline\">\\(x\\)</span> is\r\nempty.</p></li>\r\n</ul>\r\n<p>A configuration <span class=\"math inline\">\\(xqy\\)</span> is\r\n<strong><em>halting</em></strong> if <span class=\"math inline\">\\(q \\in\r\n\\{q_{accept}, q_{reject}\\}\\)</span>. Note that for each non-halting\r\nconfiguration <span class=\"math inline\">\\(C\\)</span> there is a unique\r\nconfiguration <span class=\"math inline\">\\(C^{\\prime}\\)</span> such that\r\n<span class=\"math inline\">\\(C \\overset{M}{\\to} C^{\\prime}\\)</span>.</p>\r\n<h2 id=\"definition-5\">Definition 5</h2>\r\n<p>The <strong><em>computation</em></strong> of <span\r\nclass=\"math inline\">\\(M\\)</span> on input <span class=\"math inline\">\\(w\r\n\\in \\Sigma^{*}\\)</span> is the unique sequence <span\r\nclass=\"math inline\">\\(C_{0}, C_{1}, \\cdots\\)</span> of configurations\r\nsuch that <span class=\"math inline\">\\(C_{0} = q_{0}w\\)</span> (or <span\r\nclass=\"math inline\">\\(C_{0} = q_{0}b\\)</span> if <span\r\nclass=\"math inline\">\\(w\\)</span> is empty) and <span\r\nclass=\"math inline\">\\(C_{i} \\overset{M}{\\to} C_{i+1}^{\\prime}\\)</span>\r\nfor each <span class=\"math inline\">\\(i\\)</span> with <span\r\nclass=\"math inline\">\\(C_{i+1}\\)</span> in the computation, and either\r\nthe sequence is infinite or it ends in a halting configuration. If the\r\ncomputation is finite, then the number of steps is one less than the\r\nnumber of configurations; otherwise the number of steps is infinite. We\r\nsay that <span class=\"math inline\">\\(M\\)</span>\r\n<strong><em>accepts</em></strong> <span class=\"math inline\">\\(w\\)</span>\r\niff the computation is finite and the final configuration contains the\r\nstate qaccept</p>\r\n<h2 id=\"theorem-1-turing-1936\">Theorem 1 [Turing 1936]</h2>\r\n<p>There is no TM <span class=\"math inline\">\\(M\\)</span> such that for\r\nall TMs <span class=\"math inline\">\\(N\\)</span>, if <span\r\nclass=\"math inline\">\\(M\\)</span> is run with a code of <span\r\nclass=\"math inline\">\\(N\\)</span> on its tape, then the following\r\nhold:</p>\r\n<ol type=\"1\">\r\n<li><p>If <span class=\"math inline\">\\(N\\)</span> eventually halts when\r\nrun on the empty tape, then <span class=\"math inline\">\\(M\\)</span>\r\neventually halts with <span class=\"math inline\">\\(1\\)</span> on the tape\r\nand the reading head on the square with the <span\r\nclass=\"math inline\">\\(1\\)</span>.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(N\\)</span> does not eventually\r\nhalt when run on the empty tape, then <span\r\nclass=\"math inline\">\\(M\\)</span> eventually halts with the tape\r\ncompletely empty.</p></li>\r\n</ol>\r\n<h2 id=\"theorem-2\">Theorem 2</h2>\r\n<p>The set <span class=\"math inline\">\\(HALT\\)</span> is not decidable,\r\nwhere <span class=\"math display\">\\[HALT = \\left\\{M : M \\text{ is a\r\nTuring machine which halts on the empty tape }\\right\\}\\]</span></p>\r\n<h2 id=\"definition\">Definition</h2>\r\n<p>The halting function is a function <span\r\nclass=\"math inline\">\\(h\\)</span> of two arguments</p>\r\n<p><span class=\"math display\">\\[h(m,n) = \\begin{cases}0, &amp; \\text{\r\nmachine $m$, started\r\nwith input $n$, eventually halts }\\\\\r\n1, &amp; \\text{  machine $m$, started\r\nwith input $n$, never halts }\r\n\\end{cases}\\]</span></p>\r\n<p>By definition of Turing computability, Halting problem is not\r\ndecidable if and only if halting function <span\r\nclass=\"math inline\">\\(h\\)</span> is not Turing computable.</p>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>The halting function h is not Turing computable.</p>\r\n<h2 id=\"proof-of-lemma-1\">Proof of Lemma 1</h2>\r\n<p>By way of background we need two special Turing machines.</p>\r\n<ol type=\"1\">\r\n<li><p>A copying machine <span class=\"math inline\">\\(C\\)</span>. Given a\r\ntape containing a block of <span class=\"math inline\">\\(n\\)</span>\r\nstrokes, and otherwise blank, if the machine is started scanning the\r\nleftmost stroke on the tape, it will eventually halt with the tape\r\ncontaining two blocks of <span class=\"math inline\">\\(n\\)</span> strokes\r\nseparated by a blank, and otherwise blank, with the machine scanning the\r\nleftmost stroke on the tape.</p></li>\r\n<li><p>A dithering machine <span class=\"math inline\">\\(D\\)</span>.\r\nStarted on the leftmost of a block of <span\r\nclass=\"math inline\">\\(n\\)</span> strokes on an otherwise blank tape,\r\n<span class=\"math inline\">\\(D\\)</span> eventually halts if <span\r\nclass=\"math inline\">\\(n &gt; 1\\)</span>, but never halts if <span\r\nclass=\"math inline\">\\(n = 1\\)</span>.</p></li>\r\n</ol>\r\n<p>Now suppose we had a machine <span class=\"math inline\">\\(H\\)</span>\r\nthat computed the function <span class=\"math inline\">\\(h\\)</span>. We\r\ncould combine the machines <span class=\"math inline\">\\(C\\)</span> and\r\n<span class=\"math inline\">\\(H\\)</span> as follows: if the states of\r\n<span class=\"math inline\">\\(C\\)</span> are numbered <span\r\nclass=\"math inline\">\\(1\\)</span> through <span\r\nclass=\"math inline\">\\(p\\)</span>, and the states of <span\r\nclass=\"math inline\">\\(H\\)</span> are numbered <span\r\nclass=\"math inline\">\\(1\\)</span> through <span\r\nclass=\"math inline\">\\(q\\)</span>, renumber the latter states <span\r\nclass=\"math inline\">\\(p + 1\\)</span> through <span\r\nclass=\"math inline\">\\(r = p + q\\)</span>, and write these renumbered\r\ninstructions after the instructions for <span\r\nclass=\"math inline\">\\(C\\)</span>. Originally, <span\r\nclass=\"math inline\">\\(C\\)</span> tells us to halt by telling us to go\r\ninto state <span class=\"math inline\">\\(p + 1\\)</span>, but in the new\r\ncombined instructions, going into state <span class=\"math inline\">\\(p +\r\n1\\)</span> means not halting, but beginning the operations of machine\r\n<span class=\"math inline\">\\(H\\)</span>. So the new combined instructions\r\nwill have us first go through the operations of <span\r\nclass=\"math inline\">\\(C\\)</span>, and then, when <span\r\nclass=\"math inline\">\\(C\\)</span> would have halted, go through the\r\noperations of <span class=\"math inline\">\\(H\\)</span>. The result is thus\r\na machine <span class=\"math inline\">\\(G\\)</span> that computes the\r\nfunction <span class=\"math inline\">\\(g(n) = h(n, n)\\)</span>.</p>\r\n<p>We now combine this machine <span class=\"math inline\">\\(G\\)</span>\r\nwith the dithering machine <span class=\"math inline\">\\(D\\)</span>,\r\nrenumbering the states of the latter as <span class=\"math inline\">\\(r +\r\n1\\)</span> and <span class=\"math inline\">\\(r + 2\\)</span>, and writing\r\nits instructions after those for <span class=\"math inline\">\\(G\\)</span>.\r\nThe result will be a machine <span class=\"math inline\">\\(M\\)</span> that\r\ngoes through the operations of <span class=\"math inline\">\\(G\\)</span>\r\nand then the operations of <span class=\"math inline\">\\(D\\)</span>. Thus\r\nif machine number <span class=\"math inline\">\\(n\\)</span> halts when\r\nstarted on its own number, that is, if <span class=\"math inline\">\\(h(n,\r\nn) = g(n) = 1\\)</span>, then the machine <span\r\nclass=\"math inline\">\\(M\\)</span> does not halt when started on that\r\nnumber <span class=\"math inline\">\\(n\\)</span>, whereas if machine number\r\n<span class=\"math inline\">\\(n\\)</span> does not halt when started on its\r\nown number, that is, if <span class=\"math inline\">\\(h(n, n) = g(n) =\r\n2\\)</span>, then machine <span class=\"math inline\">\\(M\\)</span> does\r\nhalt when started on <span class=\"math inline\">\\(n\\)</span>. But of\r\ncourse there can be no such machine as <span\r\nclass=\"math inline\">\\(M\\)</span>. For what would it do if started with\r\ninput its own number <span class=\"math inline\">\\(m\\)</span>? It would\r\nhalt if and only if machine number <span\r\nclass=\"math inline\">\\(m\\)</span>, which is to say itself, does not halt\r\nwhen started with input the number <span\r\nclass=\"math inline\">\\(m\\)</span>. This contradiction shows there can be\r\nno such machine as <span class=\"math inline\">\\(H\\)</span>.</p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>There exist TMs <span class=\"math inline\">\\(C\\)</span> and <span\r\nclass=\"math inline\">\\(D\\)</span> satisfying conditions in Lemma 1.</p>\r\n<h2 id=\"proof-of-lemma-2\">Proof of Lemma 2</h2>\r\n<p>The instruction set of $$ consists of:</p>\r\n<ol type=\"1\">\r\n<li>The reading and writing head of the Turing machine moves to the\r\nright until it stops at the square where the second letter is <span\r\nclass=\"math inline\">\\(0\\)</span>, and the letter in the square is\r\nchanged to <span class=\"math inline\">\\(1\\)</span>. Thus, two strings\r\ncomposed of <span class=\"math inline\">\\(1\\)</span> separated by one or\r\nsome in the middle appear on the paper tape, which will continue to\r\nexist in the operation of the Turing machine after that. We call the\r\nleft as input string and the right as carbon string. The corresponding\r\ninstruction is</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[(q_{1},s_{1},R,q_{1}),\r\n(q_{1},s_{0},R,q_{2}), (q_{2},s_{0},1,q_{2}).\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li><p>Move Turing's read/write head left to the first square on the\r\nright of the input string: <span\r\nclass=\"math display\">\\[(q_{2},s_{1},L,q_{3}),\r\n(q_{3},s_{0},L,q_{3}).\\]</span></p></li>\r\n<li><p>Then determine whether the input string has more than one square.\r\nAnd</p></li>\r\n</ol>\r\n<p>(i). If there is more than one square in the input string, the\r\nread/write head returns to the first square to the right of the input\r\nstring, rewrites the letter as <span class=\"math inline\">\\(0\\)</span>,\r\nthen continues to the right until the first square to the right of the\r\ncarbon string, rewrites the letter as <span\r\nclass=\"math inline\">\\(1\\)</span>, then return to step (2). The\r\ncorresponding instruction is:</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n(q_{3},s_{1},L,q_{4}), (q_{4},s_{1},R,q_{5}), (q_{5},s_{1},s_{0},q_{6}),\r\n(q_{5},s_{0},s_{0},q_{0}),\\\\\r\n(q_{6},s_{0},R,q_{6}), (q_{6},s_{1},s_{1},q_{7}), (q_{7},s_{1},R,q_{7}),\r\n(q_{7},s_{0},s_{1},q_{2}).\r\n\\end{aligned}\\]</span></p>\r\n<p>(ii). If there is only one square in the input string, then the\r\nread/write head changes the letter in the <span\r\nclass=\"math inline\">\\(n-1\\)</span> square to the right as <span\r\nclass=\"math inline\">\\(1\\)</span>, then returns to square <span\r\nclass=\"math inline\">\\(0\\)</span> and stops. The corresponding\r\ninstruction is:</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n(q_{4},s_{0},R,q_{8}), (q_{8},s_{1},R,q_{9}), (q_{9},s_{0},s_{1},q_{9}),\r\n(q_{9},s_{1},L,q_{10}),\\\\\r\n(q_{10},s_{1},s_{0},q_{16}), (q_{10},s_{0},L,q_{11}),\r\n(q_{11},s_{1},L,q_{11}), (q_{11},s_{0},L,q_{0}).\r\n\\end{aligned}\\]</span></p>\r\n<p>It is easy to verify that a Turing machine composed of instructions\r\n(1), (2), and (3) is the replicating machine in question. As for Turing\r\nmachine <span class=\"math inline\">\\(D\\)</span>, we simply set its\r\ninstruction set to <span\r\nclass=\"math inline\">\\((q_{1},s_{0},s_{0},q_{0}),(q_{1},s_{1},R,q_{1})\\)</span>.<span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"formal-statement-p-np\">Formal Statement P = NP</h2>\r\n<p>We say that <span class=\"math inline\">\\(M\\)</span> accepts <span\r\nclass=\"math inline\">\\(w\\)</span> if this computation terminates in the\r\naccepting state. The language accepted by <span\r\nclass=\"math inline\">\\(M\\)</span>, denoted <span\r\nclass=\"math inline\">\\(L(M)\\)</span>, has associated alphabet <span\r\nclass=\"math inline\">\\(\\Sigma\\)</span> and is defined by</p>\r\n<p><span class=\"math display\">\\[ L(M) = \\{w \\in \\Sigma^{*} | M \\text{\r\naccepts } w\\}.\\]</span></p>\r\n<p>We denote by <span class=\"math inline\">\\(t_{M}(w)\\)</span> the number\r\nof steps in the computation of <span class=\"math inline\">\\(M\\)</span> on\r\ninput <span class=\"math inline\">\\(w\\)</span>. If this computation never\r\nhalts, then <span class=\"math inline\">\\(t_{M}(w) = \\infty\\)</span>. For\r\n<span class=\"math inline\">\\(n \\in \\mathbb{N}\\)</span> we denote by <span\r\nclass=\"math inline\">\\(T_{M}(n)\\)</span> the worst case run time of <span\r\nclass=\"math inline\">\\(M\\)</span>; that is</p>\r\n<p><span class=\"math display\">\\[T_{M}(n) = \\max \\{ t_{M}(w) | w \\in\r\n\\Sigma^{n} \\},\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(\\Sigma^{n}\\)</span> is the set of\r\nall strings over <span class=\"math inline\">\\(\\Sigma\\)</span> of length\r\n<span class=\"math inline\">\\(n\\)</span>. We say that <span\r\nclass=\"math inline\">\\(M\\)</span> runs in polynomial time if there exists\r\n<span class=\"math inline\">\\(k\\)</span> such that for all <span\r\nclass=\"math inline\">\\(n\\)</span>, <span class=\"math inline\">\\(T_{M}(n)\r\n\\leq n^{k} + k\\)</span>. Now we define the class <span\r\nclass=\"math inline\">\\(\\mathbf{P}\\)</span> of languages by</p>\r\n<p><span class=\"math display\">\\[\\mathbf{P} = \\left\\{L | L = L(M) \\text{\r\nfor some Turing machine $M$ that runs\r\nin polynomial time}\\right\\}\\]</span></p>\r\n<p>The notation <span class=\"math inline\">\\(\\mathbf{NP}\\)</span> stands\r\nfor nondeterministic polynomial time.</p>\r\n<h2 id=\"definition-6\">Definition 6</h2>\r\n<p>A <strong><em>checking relation</em></strong> is a binary relation\r\n<span class=\"math inline\">\\(R \\subseteq \\Sigma^{*} \\times\r\n\\Sigma^{*}_{1}\\)</span> for some finite alphabets <span\r\nclass=\"math inline\">\\(\\Sigma\\)</span> and <span\r\nclass=\"math inline\">\\(\\Sigma_{1}\\)</span>. We associate with each such\r\nrelation <span class=\"math inline\">\\(R\\)</span> a language <span\r\nclass=\"math inline\">\\(L_{R}\\)</span> over <span\r\nclass=\"math inline\">\\(\\Sigma \\cup \\Sigma_{1} \\cup \\{ \\# \\}\\)</span>\r\ndefined by <span class=\"math display\">\\[L_{R} = \\left\\{w \\# y | R(w,\r\ny)\\right\\}\\]</span> where the symbol <span\r\nclass=\"math inline\">\\(\\#\\)</span> is not in <span\r\nclass=\"math inline\">\\(\\Sigma\\)</span>.</p>\r\n<p>We say that <span class=\"math inline\">\\(R\\)</span> is polynomial-time\r\niff <span class=\"math inline\">\\(L_{R} \\in \\mathbf{P}\\)</span>. Now we\r\ndefine the class NP of languages by the condition that a language <span\r\nclass=\"math inline\">\\(L\\)</span> over <span\r\nclass=\"math inline\">\\(\\Sigma\\)</span> is in <span\r\nclass=\"math inline\">\\(\\mathbf{NP}\\)</span> iff there is <span\r\nclass=\"math inline\">\\(k \\in \\mathbb{N}\\)</span> and a polynomial-time\r\nchecking relation <span class=\"math inline\">\\(R\\)</span> such that for\r\nall <span class=\"math inline\">\\(w \\in \\Sigma^{}\\)</span>, <span\r\nclass=\"math display\">\\[w \\in L \\Longleftrightarrow \\exists y\\left(|y|\r\n\\leq |w|^{k} \\land R(w, y)\\right).\\]</span> where <span\r\nclass=\"math inline\">\\(|w|\\)</span> and <span\r\nclass=\"math inline\">\\(|y|\\)</span> denote the lengths of <span\r\nclass=\"math inline\">\\(w\\)</span> and <span\r\nclass=\"math inline\">\\(y\\)</span>, respectively.</p>\r\n<h2>\r\nProblem Statement: Dose P = NP?\r\n</h2>\r\n<p>Judgements are left to the reader...</p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Turing, A. M. (1938). On Computable Numbers, with an Application\r\nto the Entscheidungsproblem. Proceedings of the London Mathematical\r\nSociety. Wiley. s2-42 (1): 230265.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>We give the formal statement of \"P=NP\", which plays an important role\r\nin computer science and complexity theory.</p>\r\n<h2 id=\"definition-1\">Definition 1</h2>\r\n<p>A function <span class=\"math inline\">\\(f:\\mathbb{N}^{k}\\rightarrow\r\n\\mathbb{N}\\)</span> is <strong><em>computable</em></strong> if and only\r\nif there is an effective procedure that, given any <span\r\nclass=\"math inline\">\\(k\\)</span>-tuple <span\r\nclass=\"math inline\">\\(\\mathbf{x}\\)</span> of natural numbers, will\r\nproduce the value <span class=\"math inline\">\\(f(\\mathbf{x})\\)</span></p>\r\n<h2 id=\"definition-2\">Definition 2</h2>\r\n<p>Let <span class=\"math inline\">\\(\\Sigma\\)</span> be a finite alphabet\r\n(that is, a finite nonempty set) with at least two elements, and let\r\n<span class=\"math inline\">\\(\\Sigma^{*}\\)</span> be the set of finite\r\nstrings over <span class=\"math inline\">\\(\\Sigma\\)</span>. Then a\r\n<strong><em>language over <span\r\nclass=\"math inline\">\\(\\Sigma\\)</span></em></strong> is a subset <span\r\nclass=\"math inline\">\\(L\\)</span> of <span\r\nclass=\"math inline\">\\(\\Sigma^{*}\\)</span>.</p>\r\n<h2 id=\"definition-3\">Definition 3</h2>\r\n<p>A <strong><em>Turing machine <span\r\nclass=\"math inline\">\\(M\\)</span></em></strong> is a tuple <span\r\nclass=\"math inline\">\\(\\Sigma, \\Gamma, Q, \\delta\\)</span>, where <span\r\nclass=\"math inline\">\\(\\Sigma, \\Gamma, Q\\)</span> are finite nonempty\r\nsets with <span class=\"math inline\">\\(\\Sigma \\subseteq \\Gamma\\)</span>\r\nand <span class=\"math inline\">\\(b \\in \\Gamma - \\Sigma\\)</span>. The\r\nstate set <span class=\"math inline\">\\(Q\\)</span> contains three special\r\nstates <span class=\"math inline\">\\(q_{0}, q_{accept},\r\nq_{reject}\\)</span>. The transition function <span\r\nclass=\"math inline\">\\(\\delta\\)</span> satisfies <span\r\nclass=\"math display\">\\[\\delta: (Q  \\{q_{accept}, q_{reject}\\}) \\times\r\n\\Gamma \\to  Q \\times \\Gamma  \\{-1, 1\\}.\\]</span> If <span\r\nclass=\"math inline\">\\(\\delta(q, s) = (q^{\\prime}, s^{\\prime},\r\nh)\\)</span>, the interpretation is that, if <span\r\nclass=\"math inline\">\\(M\\)</span> is in state <span\r\nclass=\"math inline\">\\(q\\)</span> scanning the symbol <span\r\nclass=\"math inline\">\\(s\\)</span>, then <span\r\nclass=\"math inline\">\\(q^{\\prime}\\)</span> is the new state, <span\r\nclass=\"math inline\">\\(s^{\\prime}\\)</span> is the symbol printed, and the\r\ntape head moves left or right one square depending on whether h is -1 or\r\n1.</p>\r\n<p>We assume that the sets <span class=\"math inline\">\\(Q\\)</span> and\r\n<span class=\"math inline\">\\(\\Gamma\\)</span> are disjoint.</p>\r\n<h2 id=\"definition-4\">Definition 4</h2>\r\n<p>A <strong><em>configuration</em></strong> of <span\r\nclass=\"math inline\">\\(M\\)</span> is a string <span\r\nclass=\"math inline\">\\(xqy\\)</span> with <span class=\"math inline\">\\(x, y\r\n\\in \\Gamma^{*}\\)</span>, <span class=\"math inline\">\\(y\\)</span> not the\r\nempty string, and <span class=\"math inline\">\\(q \\in Q\\)</span>. If <span\r\nclass=\"math inline\">\\(C\\)</span> and <span\r\nclass=\"math inline\">\\(C^{\\prime}\\)</span> are configurations, then <span\r\nclass=\"math inline\">\\(C \\overset{M}{\\to} C^{\\prime}\\)</span> if <span\r\nclass=\"math inline\">\\(C = xqsy\\)</span> and <span\r\nclass=\"math inline\">\\(\\delta(q, s) = (q^{\\prime}, s^{\\prime},\r\nh)\\)</span> and one of the following holds:</p>\r\n<ul>\r\n<li><p><span class=\"math inline\">\\(C^{\\prime} =\r\nxs^{\\prime}q^{\\prime}y\\)</span> and <span class=\"math inline\">\\(h =\r\n1\\)</span> and <span class=\"math inline\">\\(y\\)</span> is\r\nnonempty.</p></li>\r\n<li><p><span class=\"math inline\">\\(C^{\\prime} =\r\nxs^{\\prime}q^{\\prime}b\\)</span> and <span class=\"math inline\">\\(h =\r\n1\\)</span> and <span class=\"math inline\">\\(y\\)</span> is empty.</p></li>\r\n<li><p><span class=\"math inline\">\\(C^{\\prime} =\r\nx^{\\prime}q^{\\prime}as^{\\prime}y\\)</span> and <span\r\nclass=\"math inline\">\\(h = -1\\)</span> and <span class=\"math inline\">\\(x\r\n= x^{\\prime}a\\)</span> for some <span class=\"math inline\">\\(a \\in\r\n\\Gamma\\)</span>.</p></li>\r\n<li><p><span class=\"math inline\">\\(C^{\\prime} =\r\nq^{\\prime}bs^{\\prime}y\\)</span> and <span class=\"math inline\">\\(h =\r\n-1\\)</span> and <span class=\"math inline\">\\(x\\)</span> is\r\nempty.</p></li>\r\n</ul>\r\n<p>A configuration <span class=\"math inline\">\\(xqy\\)</span> is\r\n<strong><em>halting</em></strong> if <span class=\"math inline\">\\(q \\in\r\n\\{q_{accept}, q_{reject}\\}\\)</span>. Note that for each non-halting\r\nconfiguration <span class=\"math inline\">\\(C\\)</span> there is a unique\r\nconfiguration <span class=\"math inline\">\\(C^{\\prime}\\)</span> such that\r\n<span class=\"math inline\">\\(C \\overset{M}{\\to} C^{\\prime}\\)</span>.</p>\r\n<h2 id=\"definition-5\">Definition 5</h2>\r\n<p>The <strong><em>computation</em></strong> of <span\r\nclass=\"math inline\">\\(M\\)</span> on input <span class=\"math inline\">\\(w\r\n\\in \\Sigma^{*}\\)</span> is the unique sequence <span\r\nclass=\"math inline\">\\(C_{0}, C_{1}, \\cdots\\)</span> of configurations\r\nsuch that <span class=\"math inline\">\\(C_{0} = q_{0}w\\)</span> (or <span\r\nclass=\"math inline\">\\(C_{0} = q_{0}b\\)</span> if <span\r\nclass=\"math inline\">\\(w\\)</span> is empty) and <span\r\nclass=\"math inline\">\\(C_{i} \\overset{M}{\\to} C_{i+1}^{\\prime}\\)</span>\r\nfor each <span class=\"math inline\">\\(i\\)</span> with <span\r\nclass=\"math inline\">\\(C_{i+1}\\)</span> in the computation, and either\r\nthe sequence is infinite or it ends in a halting configuration. If the\r\ncomputation is finite, then the number of steps is one less than the\r\nnumber of configurations; otherwise the number of steps is infinite. We\r\nsay that <span class=\"math inline\">\\(M\\)</span>\r\n<strong><em>accepts</em></strong> <span class=\"math inline\">\\(w\\)</span>\r\niff the computation is finite and the final configuration contains the\r\nstate qaccept</p>\r\n<h2 id=\"theorem-1-turing-1936\">Theorem 1 [Turing 1936]</h2>\r\n<p>There is no TM <span class=\"math inline\">\\(M\\)</span> such that for\r\nall TMs <span class=\"math inline\">\\(N\\)</span>, if <span\r\nclass=\"math inline\">\\(M\\)</span> is run with a code of <span\r\nclass=\"math inline\">\\(N\\)</span> on its tape, then the following\r\nhold:</p>\r\n<ol type=\"1\">\r\n<li><p>If <span class=\"math inline\">\\(N\\)</span> eventually halts when\r\nrun on the empty tape, then <span class=\"math inline\">\\(M\\)</span>\r\neventually halts with <span class=\"math inline\">\\(1\\)</span> on the tape\r\nand the reading head on the square with the <span\r\nclass=\"math inline\">\\(1\\)</span>.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(N\\)</span> does not eventually\r\nhalt when run on the empty tape, then <span\r\nclass=\"math inline\">\\(M\\)</span> eventually halts with the tape\r\ncompletely empty.</p></li>\r\n</ol>\r\n<h2 id=\"theorem-2\">Theorem 2</h2>\r\n<p>The set <span class=\"math inline\">\\(HALT\\)</span> is not decidable,\r\nwhere <span class=\"math display\">\\[HALT = \\left\\{M : M \\text{ is a\r\nTuring machine which halts on the empty tape }\\right\\}\\]</span></p>\r\n<h2 id=\"definition\">Definition</h2>\r\n<p>The halting function is a function <span\r\nclass=\"math inline\">\\(h\\)</span> of two arguments</p>\r\n<p><span class=\"math display\">\\[h(m,n) = \\begin{cases}0, &amp; \\text{\r\nmachine $m$, started\r\nwith input $n$, eventually halts }\\\\\r\n1, &amp; \\text{  machine $m$, started\r\nwith input $n$, never halts }\r\n\\end{cases}\\]</span></p>\r\n<p>By definition of Turing computability, Halting problem is not\r\ndecidable if and only if halting function <span\r\nclass=\"math inline\">\\(h\\)</span> is not Turing computable.</p>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>The halting function h is not Turing computable.</p>\r\n<h2 id=\"proof-of-lemma-1\">Proof of Lemma 1</h2>\r\n<p>By way of background we need two special Turing machines.</p>\r\n<ol type=\"1\">\r\n<li><p>A copying machine <span class=\"math inline\">\\(C\\)</span>. Given a\r\ntape containing a block of <span class=\"math inline\">\\(n\\)</span>\r\nstrokes, and otherwise blank, if the machine is started scanning the\r\nleftmost stroke on the tape, it will eventually halt with the tape\r\ncontaining two blocks of <span class=\"math inline\">\\(n\\)</span> strokes\r\nseparated by a blank, and otherwise blank, with the machine scanning the\r\nleftmost stroke on the tape.</p></li>\r\n<li><p>A dithering machine <span class=\"math inline\">\\(D\\)</span>.\r\nStarted on the leftmost of a block of <span\r\nclass=\"math inline\">\\(n\\)</span> strokes on an otherwise blank tape,\r\n<span class=\"math inline\">\\(D\\)</span> eventually halts if <span\r\nclass=\"math inline\">\\(n &gt; 1\\)</span>, but never halts if <span\r\nclass=\"math inline\">\\(n = 1\\)</span>.</p></li>\r\n</ol>\r\n<p>Now suppose we had a machine <span class=\"math inline\">\\(H\\)</span>\r\nthat computed the function <span class=\"math inline\">\\(h\\)</span>. We\r\ncould combine the machines <span class=\"math inline\">\\(C\\)</span> and\r\n<span class=\"math inline\">\\(H\\)</span> as follows: if the states of\r\n<span class=\"math inline\">\\(C\\)</span> are numbered <span\r\nclass=\"math inline\">\\(1\\)</span> through <span\r\nclass=\"math inline\">\\(p\\)</span>, and the states of <span\r\nclass=\"math inline\">\\(H\\)</span> are numbered <span\r\nclass=\"math inline\">\\(1\\)</span> through <span\r\nclass=\"math inline\">\\(q\\)</span>, renumber the latter states <span\r\nclass=\"math inline\">\\(p + 1\\)</span> through <span\r\nclass=\"math inline\">\\(r = p + q\\)</span>, and write these renumbered\r\ninstructions after the instructions for <span\r\nclass=\"math inline\">\\(C\\)</span>. Originally, <span\r\nclass=\"math inline\">\\(C\\)</span> tells us to halt by telling us to go\r\ninto state <span class=\"math inline\">\\(p + 1\\)</span>, but in the new\r\ncombined instructions, going into state <span class=\"math inline\">\\(p +\r\n1\\)</span> means not halting, but beginning the operations of machine\r\n<span class=\"math inline\">\\(H\\)</span>. So the new combined instructions\r\nwill have us first go through the operations of <span\r\nclass=\"math inline\">\\(C\\)</span>, and then, when <span\r\nclass=\"math inline\">\\(C\\)</span> would have halted, go through the\r\noperations of <span class=\"math inline\">\\(H\\)</span>. The result is thus\r\na machine <span class=\"math inline\">\\(G\\)</span> that computes the\r\nfunction <span class=\"math inline\">\\(g(n) = h(n, n)\\)</span>.</p>\r\n<p>We now combine this machine <span class=\"math inline\">\\(G\\)</span>\r\nwith the dithering machine <span class=\"math inline\">\\(D\\)</span>,\r\nrenumbering the states of the latter as <span class=\"math inline\">\\(r +\r\n1\\)</span> and <span class=\"math inline\">\\(r + 2\\)</span>, and writing\r\nits instructions after those for <span class=\"math inline\">\\(G\\)</span>.\r\nThe result will be a machine <span class=\"math inline\">\\(M\\)</span> that\r\ngoes through the operations of <span class=\"math inline\">\\(G\\)</span>\r\nand then the operations of <span class=\"math inline\">\\(D\\)</span>. Thus\r\nif machine number <span class=\"math inline\">\\(n\\)</span> halts when\r\nstarted on its own number, that is, if <span class=\"math inline\">\\(h(n,\r\nn) = g(n) = 1\\)</span>, then the machine <span\r\nclass=\"math inline\">\\(M\\)</span> does not halt when started on that\r\nnumber <span class=\"math inline\">\\(n\\)</span>, whereas if machine number\r\n<span class=\"math inline\">\\(n\\)</span> does not halt when started on its\r\nown number, that is, if <span class=\"math inline\">\\(h(n, n) = g(n) =\r\n2\\)</span>, then machine <span class=\"math inline\">\\(M\\)</span> does\r\nhalt when started on <span class=\"math inline\">\\(n\\)</span>. But of\r\ncourse there can be no such machine as <span\r\nclass=\"math inline\">\\(M\\)</span>. For what would it do if started with\r\ninput its own number <span class=\"math inline\">\\(m\\)</span>? It would\r\nhalt if and only if machine number <span\r\nclass=\"math inline\">\\(m\\)</span>, which is to say itself, does not halt\r\nwhen started with input the number <span\r\nclass=\"math inline\">\\(m\\)</span>. This contradiction shows there can be\r\nno such machine as <span class=\"math inline\">\\(H\\)</span>.</p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>There exist TMs <span class=\"math inline\">\\(C\\)</span> and <span\r\nclass=\"math inline\">\\(D\\)</span> satisfying conditions in Lemma 1.</p>\r\n<h2 id=\"proof-of-lemma-2\">Proof of Lemma 2</h2>\r\n<p>The instruction set of $$ consists of:</p>\r\n<ol type=\"1\">\r\n<li>The reading and writing head of the Turing machine moves to the\r\nright until it stops at the square where the second letter is <span\r\nclass=\"math inline\">\\(0\\)</span>, and the letter in the square is\r\nchanged to <span class=\"math inline\">\\(1\\)</span>. Thus, two strings\r\ncomposed of <span class=\"math inline\">\\(1\\)</span> separated by one or\r\nsome in the middle appear on the paper tape, which will continue to\r\nexist in the operation of the Turing machine after that. We call the\r\nleft as input string and the right as carbon string. The corresponding\r\ninstruction is</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[(q_{1},s_{1},R,q_{1}),\r\n(q_{1},s_{0},R,q_{2}), (q_{2},s_{0},1,q_{2}).\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li><p>Move Turing's read/write head left to the first square on the\r\nright of the input string: <span\r\nclass=\"math display\">\\[(q_{2},s_{1},L,q_{3}),\r\n(q_{3},s_{0},L,q_{3}).\\]</span></p></li>\r\n<li><p>Then determine whether the input string has more than one square.\r\nAnd</p></li>\r\n</ol>\r\n<p>(i). If there is more than one square in the input string, the\r\nread/write head returns to the first square to the right of the input\r\nstring, rewrites the letter as <span class=\"math inline\">\\(0\\)</span>,\r\nthen continues to the right until the first square to the right of the\r\ncarbon string, rewrites the letter as <span\r\nclass=\"math inline\">\\(1\\)</span>, then return to step (2). The\r\ncorresponding instruction is:</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n(q_{3},s_{1},L,q_{4}), (q_{4},s_{1},R,q_{5}), (q_{5},s_{1},s_{0},q_{6}),\r\n(q_{5},s_{0},s_{0},q_{0}),\\\\\r\n(q_{6},s_{0},R,q_{6}), (q_{6},s_{1},s_{1},q_{7}), (q_{7},s_{1},R,q_{7}),\r\n(q_{7},s_{0},s_{1},q_{2}).\r\n\\end{aligned}\\]</span></p>\r\n<p>(ii). If there is only one square in the input string, then the\r\nread/write head changes the letter in the <span\r\nclass=\"math inline\">\\(n-1\\)</span> square to the right as <span\r\nclass=\"math inline\">\\(1\\)</span>, then returns to square <span\r\nclass=\"math inline\">\\(0\\)</span> and stops. The corresponding\r\ninstruction is:</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n(q_{4},s_{0},R,q_{8}), (q_{8},s_{1},R,q_{9}), (q_{9},s_{0},s_{1},q_{9}),\r\n(q_{9},s_{1},L,q_{10}),\\\\\r\n(q_{10},s_{1},s_{0},q_{16}), (q_{10},s_{0},L,q_{11}),\r\n(q_{11},s_{1},L,q_{11}), (q_{11},s_{0},L,q_{0}).\r\n\\end{aligned}\\]</span></p>\r\n<p>It is easy to verify that a Turing machine composed of instructions\r\n(1), (2), and (3) is the replicating machine in question. As for Turing\r\nmachine <span class=\"math inline\">\\(D\\)</span>, we simply set its\r\ninstruction set to <span\r\nclass=\"math inline\">\\((q_{1},s_{0},s_{0},q_{0}),(q_{1},s_{1},R,q_{1})\\)</span>.<span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"formal-statement-p-np\">Formal Statement P = NP</h2>\r\n<p>We say that <span class=\"math inline\">\\(M\\)</span> accepts <span\r\nclass=\"math inline\">\\(w\\)</span> if this computation terminates in the\r\naccepting state. The language accepted by <span\r\nclass=\"math inline\">\\(M\\)</span>, denoted <span\r\nclass=\"math inline\">\\(L(M)\\)</span>, has associated alphabet <span\r\nclass=\"math inline\">\\(\\Sigma\\)</span> and is defined by</p>\r\n<p><span class=\"math display\">\\[ L(M) = \\{w \\in \\Sigma^{*} | M \\text{\r\naccepts } w\\}.\\]</span></p>\r\n<p>We denote by <span class=\"math inline\">\\(t_{M}(w)\\)</span> the number\r\nof steps in the computation of <span class=\"math inline\">\\(M\\)</span> on\r\ninput <span class=\"math inline\">\\(w\\)</span>. If this computation never\r\nhalts, then <span class=\"math inline\">\\(t_{M}(w) = \\infty\\)</span>. For\r\n<span class=\"math inline\">\\(n \\in \\mathbb{N}\\)</span> we denote by <span\r\nclass=\"math inline\">\\(T_{M}(n)\\)</span> the worst case run time of <span\r\nclass=\"math inline\">\\(M\\)</span>; that is</p>\r\n<p><span class=\"math display\">\\[T_{M}(n) = \\max \\{ t_{M}(w) | w \\in\r\n\\Sigma^{n} \\},\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(\\Sigma^{n}\\)</span> is the set of\r\nall strings over <span class=\"math inline\">\\(\\Sigma\\)</span> of length\r\n<span class=\"math inline\">\\(n\\)</span>. We say that <span\r\nclass=\"math inline\">\\(M\\)</span> runs in polynomial time if there exists\r\n<span class=\"math inline\">\\(k\\)</span> such that for all <span\r\nclass=\"math inline\">\\(n\\)</span>, <span class=\"math inline\">\\(T_{M}(n)\r\n\\leq n^{k} + k\\)</span>. Now we define the class <span\r\nclass=\"math inline\">\\(\\mathbf{P}\\)</span> of languages by</p>\r\n<p><span class=\"math display\">\\[\\mathbf{P} = \\left\\{L | L = L(M) \\text{\r\nfor some Turing machine $M$ that runs\r\nin polynomial time}\\right\\}\\]</span></p>\r\n<p>The notation <span class=\"math inline\">\\(\\mathbf{NP}\\)</span> stands\r\nfor nondeterministic polynomial time.</p>\r\n<h2 id=\"definition-6\">Definition 6</h2>\r\n<p>A <strong><em>checking relation</em></strong> is a binary relation\r\n<span class=\"math inline\">\\(R \\subseteq \\Sigma^{*} \\times\r\n\\Sigma^{*}_{1}\\)</span> for some finite alphabets <span\r\nclass=\"math inline\">\\(\\Sigma\\)</span> and <span\r\nclass=\"math inline\">\\(\\Sigma_{1}\\)</span>. We associate with each such\r\nrelation <span class=\"math inline\">\\(R\\)</span> a language <span\r\nclass=\"math inline\">\\(L_{R}\\)</span> over <span\r\nclass=\"math inline\">\\(\\Sigma \\cup \\Sigma_{1} \\cup \\{ \\# \\}\\)</span>\r\ndefined by <span class=\"math display\">\\[L_{R} = \\left\\{w \\# y | R(w,\r\ny)\\right\\}\\]</span> where the symbol <span\r\nclass=\"math inline\">\\(\\#\\)</span> is not in <span\r\nclass=\"math inline\">\\(\\Sigma\\)</span>.</p>\r\n<p>We say that <span class=\"math inline\">\\(R\\)</span> is polynomial-time\r\niff <span class=\"math inline\">\\(L_{R} \\in \\mathbf{P}\\)</span>. Now we\r\ndefine the class NP of languages by the condition that a language <span\r\nclass=\"math inline\">\\(L\\)</span> over <span\r\nclass=\"math inline\">\\(\\Sigma\\)</span> is in <span\r\nclass=\"math inline\">\\(\\mathbf{NP}\\)</span> iff there is <span\r\nclass=\"math inline\">\\(k \\in \\mathbb{N}\\)</span> and a polynomial-time\r\nchecking relation <span class=\"math inline\">\\(R\\)</span> such that for\r\nall <span class=\"math inline\">\\(w \\in \\Sigma^{}\\)</span>, <span\r\nclass=\"math display\">\\[w \\in L \\Longleftrightarrow \\exists y\\left(|y|\r\n\\leq |w|^{k} \\land R(w, y)\\right).\\]</span> where <span\r\nclass=\"math inline\">\\(|w|\\)</span> and <span\r\nclass=\"math inline\">\\(|y|\\)</span> denote the lengths of <span\r\nclass=\"math inline\">\\(w\\)</span> and <span\r\nclass=\"math inline\">\\(y\\)</span>, respectively.</p>\r\n<h2>\r\nProblem Statement: Dose P = NP?\r\n</h2>\r\n<p>Judgements are left to the reader...</p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Turing, A. M. (1938). On Computable Numbers, with an Application\r\nto the Entscheidungsproblem. Proceedings of the London Mathematical\r\nSociety. Wiley. s2-42 (1): 230265.</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Dec 31 2023 15:45:45 GMT+0800 ()","title":"P = NP","path":"2023/04/10/P=NP/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-04-10T12:38:46.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-04-10T12:38:46.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Notes > Mathematical Logic","tags":["Notes","Mathematical Logic"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Naimark's Problem","date":"2023-04-10T00:21:52.000Z","mathjax":true,"_content":"\nWe list some open problems in C$^{*}$-algebra:\n\n## Question 1 (Naimark's Problem):  \nEvery C$^{*}$-algebra that has only one irreducible $*$-representation up to unitary equivalence is isomorphic to the $*$-algebra of compact operators on some (not necessarily separable) Hilbert space.\n\nWhether Naimark problem is  independent of $\\mathsf{ZFC}$?\n\nAkemann & Weaver (2004)[^1] used the $\\diamondsuit$-Principle to construct a C$^{*}$-algebra with $\\aleph _{1}$ generators that serves as a counterexample to Naimark's Problem. But in general its consistency remains unknown. \n\n[^1]: Akemann, Charles; Weaver, Nik (2004), \"Consistency of a counterexample to Naimark's problem\", Proceedings of the National Academy of Sciences of the United States of America, 101 (20): 75227525\n\n\n\n## Question 2:  \n\n\nEvery C$^{*}$-algebras of density of continuum $\\aleph_{1} = 2^{\\aleph_{0}}$ has no nonseparable commutative subalgebra.[^2]\n\nAkemann & Donner (1979) constructs example with a C$^{*}$-algebra with $\\aleph _{1}$ generators with only separable abelian C$^{*}$-subalgebras. Bice and Koszmider (2017)[^3] remove their assumption of the continuum hypothesis. Whether \n\n\n[^2]: C. Akemann and J. Doner, A nonseparable C$^{*}$-algebra with only separable abelian C$^{*}$-subalgebras. Bull. London Math. Soc. 11 (1979), no. 3, 279284.\n\n[^3]: Bice, T., & Koszmider, P. (2017). A note on the Akemann-Doner and Farah-Wofsey constructions. Proceedings of the American Mathematical Society, 145(2), 681-687.\n\n\n\n## Question 3:  \n\nEvery amenable operator algebra is isomorphic to a (necessarily nuclear) C$^{*}$-algebra.\n\n\nResolved. Choi, Farah, & Ozawa (2013) [^4] construct a counterexample to this problem in non-separable case, whereas separable case remains open.\n\n\n[^4]: Choi, Y., Farah, I., & Ozawa, N. (2014, February). A NONSEPARABLE AMENABLE OPERATOR ALGEBRA WHICH IS NOT ISOMORPHIC TO A-ALGEBRA. In Forum of Mathematics, Sigma (Vol. 2, p. e2). Cambridge University Press.\n\n\n## Question 4:  \n\nDo there exist non-discrete second countable locally compact groups which are C$^{*}$-simple?[^5]\n\n[^5]: Pierre de la Harpe, On simplicity of reduced C$^{*}$-algebras of groups, Bull. Lond. Math. Soc.\n\nResolved. Suzuki (2017).[^6] \n\n\n[^6]: Suzuki, Y. (2017). Elementary constructions of non-discrete *-simple groups. Proceedings of the American Mathematical Society, 145(3), 1369-1371.\n\n\n# Reference\n\n[1] Naimark, M. A. (1948), \"Rings with involutions\", Uspekhi Mat. Nauk, 3: 52-145\n\n[2] Naimark, M. A. (1951), \"On a problem in the theory of rings with involution\", Uspekhi Mat. Nauk, 6: 160-164\n\n\n\n","source":"_posts/The Naimark Problem.md","raw":"---\ntitle: Naimark's Problem\ndate: 2023-04-10 08:21:52\ntags:\n    - [Notes]\ncategories:\n    - [Notes]\nmathjax: true\n---\n\nWe list some open problems in C$^{*}$-algebra:\n\n## Question 1 (Naimark's Problem):  \nEvery C$^{*}$-algebra that has only one irreducible $*$-representation up to unitary equivalence is isomorphic to the $*$-algebra of compact operators on some (not necessarily separable) Hilbert space.\n\nWhether Naimark problem is  independent of $\\mathsf{ZFC}$?\n\nAkemann & Weaver (2004)[^1] used the $\\diamondsuit$-Principle to construct a C$^{*}$-algebra with $\\aleph _{1}$ generators that serves as a counterexample to Naimark's Problem. But in general its consistency remains unknown. \n\n[^1]: Akemann, Charles; Weaver, Nik (2004), \"Consistency of a counterexample to Naimark's problem\", Proceedings of the National Academy of Sciences of the United States of America, 101 (20): 75227525\n\n\n\n## Question 2:  \n\n\nEvery C$^{*}$-algebras of density of continuum $\\aleph_{1} = 2^{\\aleph_{0}}$ has no nonseparable commutative subalgebra.[^2]\n\nAkemann & Donner (1979) constructs example with a C$^{*}$-algebra with $\\aleph _{1}$ generators with only separable abelian C$^{*}$-subalgebras. Bice and Koszmider (2017)[^3] remove their assumption of the continuum hypothesis. Whether \n\n\n[^2]: C. Akemann and J. Doner, A nonseparable C$^{*}$-algebra with only separable abelian C$^{*}$-subalgebras. Bull. London Math. Soc. 11 (1979), no. 3, 279284.\n\n[^3]: Bice, T., & Koszmider, P. (2017). A note on the Akemann-Doner and Farah-Wofsey constructions. Proceedings of the American Mathematical Society, 145(2), 681-687.\n\n\n\n## Question 3:  \n\nEvery amenable operator algebra is isomorphic to a (necessarily nuclear) C$^{*}$-algebra.\n\n\nResolved. Choi, Farah, & Ozawa (2013) [^4] construct a counterexample to this problem in non-separable case, whereas separable case remains open.\n\n\n[^4]: Choi, Y., Farah, I., & Ozawa, N. (2014, February). A NONSEPARABLE AMENABLE OPERATOR ALGEBRA WHICH IS NOT ISOMORPHIC TO A-ALGEBRA. In Forum of Mathematics, Sigma (Vol. 2, p. e2). Cambridge University Press.\n\n\n## Question 4:  \n\nDo there exist non-discrete second countable locally compact groups which are C$^{*}$-simple?[^5]\n\n[^5]: Pierre de la Harpe, On simplicity of reduced C$^{*}$-algebras of groups, Bull. Lond. Math. Soc.\n\nResolved. Suzuki (2017).[^6] \n\n\n[^6]: Suzuki, Y. (2017). Elementary constructions of non-discrete *-simple groups. Proceedings of the American Mathematical Society, 145(3), 1369-1371.\n\n\n# Reference\n\n[1] Naimark, M. A. (1948), \"Rings with involutions\", Uspekhi Mat. Nauk, 3: 52-145\n\n[2] Naimark, M. A. (1951), \"On a problem in the theory of rings with involution\", Uspekhi Mat. Nauk, 6: 160-164\n\n\n\n","slug":"The Naimark Problem","published":1,"updated":"2024-01-01T04:53:02.181Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisunk000peslr00vhh8qp","content":"<p>We list some open problems in C<span\r\nclass=\"math inline\">\\(^{*}\\)</span>-algebra:</p>\r\n<h2 id=\"question-1-naimarks-problem\">Question 1 (Naimark's\r\nProblem):</h2>\r\n<p>Every C<span class=\"math inline\">\\(^{*}\\)</span>-algebra that has\r\nonly one irreducible <span\r\nclass=\"math inline\">\\(*\\)</span>-representation up to unitary\r\nequivalence is isomorphic to the <span\r\nclass=\"math inline\">\\(*\\)</span>-algebra of compact operators on some\r\n(not necessarily separable) Hilbert space.</p>\r\n<p>Whether Naimark problem is independent of <span\r\nclass=\"math inline\">\\(\\mathsf{ZFC}\\)</span>?</p>\r\n<p>Akemann &amp; Weaver (2004)<a href=\"#fn1\" class=\"footnote-ref\"\r\nid=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a> used the <span\r\nclass=\"math inline\">\\(\\diamondsuit\\)</span>-Principle to construct a\r\nC<span class=\"math inline\">\\(^{*}\\)</span>-algebra with <span\r\nclass=\"math inline\">\\(\\aleph _{1}\\)</span> generators that serves as a\r\ncounterexample to Naimark's Problem. But in general its consistency\r\nremains unknown.</p>\r\n<h2 id=\"question-2\">Question 2:</h2>\r\n<p>Every C<span class=\"math inline\">\\(^{*}\\)</span>-algebras of density\r\nof continuum <span class=\"math inline\">\\(\\aleph_{1} =\r\n2^{\\aleph_{0}}\\)</span> has no nonseparable commutative subalgebra.<a\r\nhref=\"#fn2\" class=\"footnote-ref\" id=\"fnref2\"\r\nrole=\"doc-noteref\"><sup>2</sup></a></p>\r\n<p>Akemann &amp; Donner (1979) constructs example with a C<span\r\nclass=\"math inline\">\\(^{*}\\)</span>-algebra with <span\r\nclass=\"math inline\">\\(\\aleph _{1}\\)</span> generators with only\r\nseparable abelian C<span\r\nclass=\"math inline\">\\(^{*}\\)</span>-subalgebras. Bice and Koszmider\r\n(2017)<a href=\"#fn3\" class=\"footnote-ref\" id=\"fnref3\"\r\nrole=\"doc-noteref\"><sup>3</sup></a> remove their assumption of the\r\ncontinuum hypothesis. Whether</p>\r\n<h2 id=\"question-3\">Question 3:</h2>\r\n<p>Every amenable operator algebra is isomorphic to a (necessarily\r\nnuclear) C<span class=\"math inline\">\\(^{*}\\)</span>-algebra.</p>\r\n<p>Resolved. Choi, Farah, &amp; Ozawa (2013) <a href=\"#fn4\"\r\nclass=\"footnote-ref\" id=\"fnref4\" role=\"doc-noteref\"><sup>4</sup></a>\r\nconstruct a counterexample to this problem in non-separable case,\r\nwhereas separable case remains open.</p>\r\n<h2 id=\"question-4\">Question 4:</h2>\r\n<p>Do there exist non-discrete second countable locally compact groups\r\nwhich are C<span class=\"math inline\">\\(^{*}\\)</span>-simple?<a\r\nhref=\"#fn5\" class=\"footnote-ref\" id=\"fnref5\"\r\nrole=\"doc-noteref\"><sup>5</sup></a></p>\r\n<p>Resolved. Suzuki (2017).<a href=\"#fn6\" class=\"footnote-ref\"\r\nid=\"fnref6\" role=\"doc-noteref\"><sup>6</sup></a></p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Naimark, M. A. (1948), \"Rings with involutions\", Uspekhi Mat.\r\nNauk, 3: 52-145</p>\r\n<p>[2] Naimark, M. A. (1951), \"On a problem in the theory of rings with\r\ninvolution\", Uspekhi Mat. Nauk, 6: 160-164</p>\r\n<aside id=\"footnotes\" class=\"footnotes footnotes-end-of-document\"\r\nrole=\"doc-endnotes\">\r\n<hr />\r\n<ol>\r\n<li id=\"fn1\"><p>Akemann, Charles; Weaver, Nik (2004), \"Consistency of a\r\ncounterexample to Naimark's problem\", Proceedings of the National\r\nAcademy of Sciences of the United States of America, 101 (20):\r\n75227525<a href=\"#fnref1\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn2\"><p>C. Akemann and J. Doner, A nonseparable C<span\r\nclass=\"math inline\">\\(^{*}\\)</span>-algebra with only separable abelian\r\nC<span class=\"math inline\">\\(^{*}\\)</span>-subalgebras. Bull. London\r\nMath. Soc. 11 (1979), no. 3, 279284.<a href=\"#fnref2\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn3\"><p>Bice, T., &amp; Koszmider, P. (2017). A note on the\r\nAkemann-Doner and Farah-Wofsey constructions. Proceedings of the\r\nAmerican Mathematical Society, 145(2), 681-687.<a href=\"#fnref3\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn4\"><p>Choi, Y., Farah, I., &amp; Ozawa, N. (2014, February). A\r\nNONSEPARABLE AMENABLE OPERATOR ALGEBRA WHICH IS NOT ISOMORPHIC TO\r\nA-ALGEBRA. In Forum of Mathematics, Sigma (Vol. 2, p. e2). Cambridge\r\nUniversity Press.<a href=\"#fnref4\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn5\"><p>Pierre de la Harpe, On simplicity of reduced C<span\r\nclass=\"math inline\">\\(^{*}\\)</span>-algebras of groups, Bull. Lond.\r\nMath. Soc.<a href=\"#fnref5\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn6\"><p>Suzuki, Y. (2017). Elementary constructions of\r\nnon-discrete *-simple groups. Proceedings of the American Mathematical\r\nSociety, 145(3), 1369-1371.<a href=\"#fnref6\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n</ol>\r\n</aside>\r\n","site":{"data":{}},"excerpt":"","more":"<p>We list some open problems in C<span\r\nclass=\"math inline\">\\(^{*}\\)</span>-algebra:</p>\r\n<h2 id=\"question-1-naimarks-problem\">Question 1 (Naimark's\r\nProblem):</h2>\r\n<p>Every C<span class=\"math inline\">\\(^{*}\\)</span>-algebra that has\r\nonly one irreducible <span\r\nclass=\"math inline\">\\(*\\)</span>-representation up to unitary\r\nequivalence is isomorphic to the <span\r\nclass=\"math inline\">\\(*\\)</span>-algebra of compact operators on some\r\n(not necessarily separable) Hilbert space.</p>\r\n<p>Whether Naimark problem is independent of <span\r\nclass=\"math inline\">\\(\\mathsf{ZFC}\\)</span>?</p>\r\n<p>Akemann &amp; Weaver (2004)<a href=\"#fn1\" class=\"footnote-ref\"\r\nid=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a> used the <span\r\nclass=\"math inline\">\\(\\diamondsuit\\)</span>-Principle to construct a\r\nC<span class=\"math inline\">\\(^{*}\\)</span>-algebra with <span\r\nclass=\"math inline\">\\(\\aleph _{1}\\)</span> generators that serves as a\r\ncounterexample to Naimark's Problem. But in general its consistency\r\nremains unknown.</p>\r\n<h2 id=\"question-2\">Question 2:</h2>\r\n<p>Every C<span class=\"math inline\">\\(^{*}\\)</span>-algebras of density\r\nof continuum <span class=\"math inline\">\\(\\aleph_{1} =\r\n2^{\\aleph_{0}}\\)</span> has no nonseparable commutative subalgebra.<a\r\nhref=\"#fn2\" class=\"footnote-ref\" id=\"fnref2\"\r\nrole=\"doc-noteref\"><sup>2</sup></a></p>\r\n<p>Akemann &amp; Donner (1979) constructs example with a C<span\r\nclass=\"math inline\">\\(^{*}\\)</span>-algebra with <span\r\nclass=\"math inline\">\\(\\aleph _{1}\\)</span> generators with only\r\nseparable abelian C<span\r\nclass=\"math inline\">\\(^{*}\\)</span>-subalgebras. Bice and Koszmider\r\n(2017)<a href=\"#fn3\" class=\"footnote-ref\" id=\"fnref3\"\r\nrole=\"doc-noteref\"><sup>3</sup></a> remove their assumption of the\r\ncontinuum hypothesis. Whether</p>\r\n<h2 id=\"question-3\">Question 3:</h2>\r\n<p>Every amenable operator algebra is isomorphic to a (necessarily\r\nnuclear) C<span class=\"math inline\">\\(^{*}\\)</span>-algebra.</p>\r\n<p>Resolved. Choi, Farah, &amp; Ozawa (2013) <a href=\"#fn4\"\r\nclass=\"footnote-ref\" id=\"fnref4\" role=\"doc-noteref\"><sup>4</sup></a>\r\nconstruct a counterexample to this problem in non-separable case,\r\nwhereas separable case remains open.</p>\r\n<h2 id=\"question-4\">Question 4:</h2>\r\n<p>Do there exist non-discrete second countable locally compact groups\r\nwhich are C<span class=\"math inline\">\\(^{*}\\)</span>-simple?<a\r\nhref=\"#fn5\" class=\"footnote-ref\" id=\"fnref5\"\r\nrole=\"doc-noteref\"><sup>5</sup></a></p>\r\n<p>Resolved. Suzuki (2017).<a href=\"#fn6\" class=\"footnote-ref\"\r\nid=\"fnref6\" role=\"doc-noteref\"><sup>6</sup></a></p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Naimark, M. A. (1948), \"Rings with involutions\", Uspekhi Mat.\r\nNauk, 3: 52-145</p>\r\n<p>[2] Naimark, M. A. (1951), \"On a problem in the theory of rings with\r\ninvolution\", Uspekhi Mat. Nauk, 6: 160-164</p>\r\n<aside id=\"footnotes\" class=\"footnotes footnotes-end-of-document\"\r\nrole=\"doc-endnotes\">\r\n<hr />\r\n<ol>\r\n<li id=\"fn1\"><p>Akemann, Charles; Weaver, Nik (2004), \"Consistency of a\r\ncounterexample to Naimark's problem\", Proceedings of the National\r\nAcademy of Sciences of the United States of America, 101 (20):\r\n75227525<a href=\"#fnref1\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn2\"><p>C. Akemann and J. Doner, A nonseparable C<span\r\nclass=\"math inline\">\\(^{*}\\)</span>-algebra with only separable abelian\r\nC<span class=\"math inline\">\\(^{*}\\)</span>-subalgebras. Bull. London\r\nMath. Soc. 11 (1979), no. 3, 279284.<a href=\"#fnref2\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn3\"><p>Bice, T., &amp; Koszmider, P. (2017). A note on the\r\nAkemann-Doner and Farah-Wofsey constructions. Proceedings of the\r\nAmerican Mathematical Society, 145(2), 681-687.<a href=\"#fnref3\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn4\"><p>Choi, Y., Farah, I., &amp; Ozawa, N. (2014, February). A\r\nNONSEPARABLE AMENABLE OPERATOR ALGEBRA WHICH IS NOT ISOMORPHIC TO\r\nA-ALGEBRA. In Forum of Mathematics, Sigma (Vol. 2, p. e2). Cambridge\r\nUniversity Press.<a href=\"#fnref4\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn5\"><p>Pierre de la Harpe, On simplicity of reduced C<span\r\nclass=\"math inline\">\\(^{*}\\)</span>-algebras of groups, Bull. Lond.\r\nMath. Soc.<a href=\"#fnref5\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn6\"><p>Suzuki, Y. (2017). Elementary constructions of\r\nnon-discrete *-simple groups. Proceedings of the American Mathematical\r\nSociety, 145(3), 1369-1371.<a href=\"#fnref6\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n</ol>\r\n</aside>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Mon Jan 01 2024 12:53:02 GMT+0800 ()","title":"Naimark's Problem","path":"2023/04/10/The Naimark Problem/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-04-10T00:21:52.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-04-10T00:21:52.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Notes","tags":["Notes"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Zariski Topology","date":"2023-03-22T23:13:04.000Z","mathjax":true,"_content":"\n## Definition\n\nLet $A$ be commutative ring with unit. $\\text{Spec}(A)$ is the collection of prime ideals of $A$. \n\n\n$V(E)$ is the collection of prime ideals containing $E \\subseteq A$. $\\{V(E); E \\subseteq A\\}$ is a collection of closed subsets of $\\text{Spec} (A)$, since\n\n1. $V(1)=\\emptyset, V(0) =X$. Hence [Axiom of Closed Set I](https://en.wikipedia.org/wiki/Closed_set) is satisfied.\n\t \n2.  $\\cap_{i \\in I} V(E_{i}) =V(\\cup_{i \\in I} E_{i})$. Hence [Axiom of Closed Set II](https://en.wikipedia.org/wiki/Closed_set) is satisfied.\n\t \n3. To verify axiom III, Consider the ideal $\\mathsf{a}_{1}$ generated by $E_{1}$ and the ideal $\\mathsf{a}_{2}$ generated by $E_{2}$. Note that $V(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2}) \\subseteq V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2})$. Then, for any prime ideal $\\mathsf{p}$ containing $\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}$, we have $\\mathsf{a}_{1} \\subseteq \\mathsf{p}$ or $\\mathsf{a}_{2} \\subseteq \\mathsf{p}$, since\n\n$$ x_{1},x_{2} \\notin \\mathsf{p} \\Rightarrow x_{1}x_{2} \\notin \\mathsf{p} \\text{ while }\\,\\, x_{1}\\in \\mathsf{a}_{1}, x_{2}\\in \\mathsf{a}_{2} \\Rightarrow x_{1}x_{2} \\in \n\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}$$\n\nThis proves $V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}) \\subseteq V(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2})$. Therefore, these sets equal to each other $V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}) = V(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2})$, which verifies [Axiom of Closed Set III](https://en.wikipedia.org/wiki/Closed_set). $\\square$\n\n\n## Proporsition 1 [Topological basis]\n\nGiven an element $f$ in $A$, we define $X_{f}$ to be the complement of $V(f)$ in $X=\\text{Spec}(A)$, so\n$$ \\mathscr{U}^{\\prime} = \\{X_{f}; f\\in A\\}$$\n\nis a [topological basis](https://en.wikipedia.org/wiki/Base_(topology)) for\n$$\\mathscr{U} = \\{ X\\backslash V(E); E \\subseteq A\\}$$\n\nTo see more clearly, Choose an open set $O \\in \\mathscr{U}$, it must be the complement of a closed set $V(E)$ generated by some subset $E$ of ring $A$, that is, $O = X\\backslash V(E)$. Decompose $E$ into the union of its components $\\left\\{f\\right\\}$ we have $E = \\cup_{f\\in E}\\{f\\}$, by utilize axiom of closed set III\n\n$$\n    O =X\\backslash \\left(\\cap_{f \\in E} V(f)\\right) = \\cup_{f\\in E} \\left(X \\backslash V(f)\\right) =\\cup_{f\\in E} X_{f}\n$$\n\nThat is to say $\\mathscr{U}^{\\prime}$ is a topological basis for $\\mathscr{U}$. $\\square$\n\n<br> \n\n## Proporsition 1 [Countability Axiom, not $C_{1}$]\n\n## Example \nLet $A$ be [UFD](https://en.wikipedia.org/wiki/Unique_factorization_domain). $I$ is an index set, $|I| \\geq \\aleph_{1}$. For each index $i\\in I$ associate with a variable $x_{i}$, Consider polynomial ring with coeffiecients in $A$\n$$ A[I] := \\{\\sum a_{i_{1},i_{2},\\cdots,i_{k}} x_{i_{i}}^{n_{1}}x_{i_{2}}^{n_{2}} \\cdots x_{i_{k}}^{n_{k}} :\na_{i_{1},i_{2},\\cdots,i_{k}}\\in A \\}$$\n\\text{ where sum is over finite term}. Since $A[I]$ in integral domain, $(0)$ is a prime ideal. The Zariski topological basis $\\{X_{f}; {f \\in A(I)}\\}$ for ring $A(I)$ with emptyset exception, that is $f\\neq 0$, is a neighborhood basis at $(0)$ for $\\text{Spec}(A[I])$ . Since $A[I]$ is either UFD, $A[I]$ contains uncoutable many prime idels $(x_{i}), {i \\in I}$, which implies $A[I]$ dose not satisfies [first-countable axiom $C_{1}$](https://en.wikipedia.org/wiki/First-countable_space).\n\nFor topological space, we are also interested in its separation, compactness and connectedness etc.\n\n## Proporsition 2 [Separation Axiom $T_{0}$]\n\n\nA topological space $(X,\\mathscr{U})$ satisfies [separtion axiom $T_{0}$](https://en.wikipedia.org/wiki/Kolmogorov_space) separation, if for any $x,y \\in X$, $x\\neq y$, there exists open set $U \\in \\mathscr{U}$, such that $x\\in U, y \\notin U$ of if $y \\in U, x \\notin U$. \n\nLet $x,y$ be distinct two points in $X=\\text{Spec}(A)$, i.e. two distinct prime ideals $\\mathsf{p}_{x},\\mathsf{p}_{y}$ of ring $A$:\n\t\n1. If $\\mathsf{p}_{x} \\subseteq \\mathsf{p}_{y}$, then $V(\\mathsf{p}_{y}) \\subseteq V(\\mathsf{p}_{x})$. Taking $U= X \\backslash V(\\mathsf{p}_{y})$ we have $x\\in U, y \\notin U$.\n\t\n2. If $\\mathsf{p}_{x} \\subsetneq \\mathsf{p}_{y}$, thereby $\\mathsf{p}_{y} \\notin V(\\mathsf{p}_{x})$. Taking $U = X \\backslash V(\\mathsf{p}_{x})$ we have $y \\in U, x \\notin U$.\n\t\nThis together impies that $X=\\text{Spec}(A)$ satisfies separation axiom $T_{0}$. $\\square$\n\n## Propersition 3 [Compactness]\n\nWe next prove $X = \\text{Spec} (A)$ is (compact)[]. It only suffices to consider covering from topological basis $\\{X_{f}; {f\\in E}\\}$, where $E\\neq \\emptyset$ is a subset of ring $A$. Accrording to (De Morgan law)[] and axiom of closed set III, nota that\n$$\nX \\backslash \\left(\\cup_{f\\in E} X_{f}\\right) = \\cap_{f\\in E} \\left(X \\backslash X_{f} \\right) = V (\\cup_{f\\in E}  \\{f\\})\n$$\nhence $\\cup_{f\\in E} X_{f} = X \\Leftrightarrow  V(E) =\\emptyset$. Let the ideal generated by $E$ be $\\mathsf{a}$, we show that $\\mathsf{a}= (1) $: \n\t\n> Let $\\Sigma$ consist of non-trivial ideals of $A$. Since the non-decreasing chain of ideals are also an ideal, by Zorn lemma, if $\\Sigma \\neq \\emptyset$, $\\Sigma$ contains a maximal element $\\mathsf{a}_{0}$ with respect to $\\subseteq$-partial ordering; it is indeed an maximal ideal. (Otherwise, if there exist another $\\mathsf{a}_{0}^{\\prime}$ such that $\\mathsf{a}_{0} \\subseteq \\mathsf{a}_{0}^{\\prime}$, $\\mathsf{a}_{0}^{\\prime} = \\mathsf{a}_{0} \\cup \\mathsf{a}_{0}^{\\prime}$ is maximal with respect to inclusion relation.) It also can be proved that if $\\mathsf{a} \\neq (1)$, $\\mathsf{a}$ is contained in a maximal ideal. Hence if $\\mathsf{a} \\neq (1)$, $V(\\mathsf{a})$ contains at least an element. Contradiction. $\\square$ [[See Zorn lemma]](https://en.wikipedia.org/wiki/Zorn%27s_lemma)\n\nTherefore $1$ can be represented by a finite sum of products of elements from $E$ and $A$:\n$$1 = g_{1}f_{1} + \\cdots + g_{n}f_{n}, \\quad g_{i}\\in A, f_{i} \\in E, 1 \\leq i \\leq n$$\nTake $F= \\{f_{1}, \\cdots, f_{n}\\}$, thereby $V(F) = \\emptyset$, which implies $\\{X_{f}; {f \\in F}\\}$ covers $X$. $\\square$\n\n## Definition [Nilradical and Radical]\nThe ideal $\\mathfrak{R}$ of all nipotents in a commutative ring $A$ with unit $1$ is the insection of all prime ideals of $A$, that is,\n$$\n\\mathfrak{R} = \\bigcap_{\\mathsf{p} \\text{ is a prime ideal of $A$}} \\mathsf{p}\n$$\n\nOf course $\\mathfrak{R}$ is an ideal closed under addition and multiplicatio. We split the proof in two steps:\n\n1. If $\\mathsf{p}$ is a prime ideal, then $\\mathfrak{R}\\subseteq \\mathsf{p}$. Since $0 \\in \\mathsf{p}$, and we know for any $f \\in \\mathfrak{R}$, there exist an integer $n>0$ such that \n$$f^{n} \\in \\mathsf{p} \\Rightarrow \\cdots \\Rightarrow  f \\in \\mathsf{p}$$\n\n2. If $f$ in not nilpotent, then there is a prime ideal $\\mathsf{p} \\cap \\{f\\} = \\emptyset$. Let \n$$\\Sigma = \\left\\{ \\mathsf{a} \\text{ is an ideal of $A$}: \\text{for any $n \\in \\mathbb{N}_{*}$, }f^{n} \\notin \\mathsf{a} \\right\\}$$\n\n> Since $(0) \\in \\Sigma$. By Zorn lemma, $\\Sigma$ contains maximal element $\\mathsf{p}$ with respect to $\\subseteq$-inclusion partial ordering. This $\\mathsf{p}$ is indeed a prime ideal, because: \n> For any $x,y \\notin \\mathsf{p}$, thanks to the maximal proporty of $\\mathsf{p}$ we have $\\mathsf{p} +  (x)$, $\\mathsf{p} + (y)$ $\\notin \\Sigma$; however,\n> $$\\begin{aligned}\t\n    f^{m} \\in\\mathsf{p} + (x) &, f^{n} \\in \\mathsf{p} +(y) \\Rightarrow f^{m+n} \\in \\mathsf{p} + (xy) \n\\end{aligned}$$\n> implies $\\mathsf{p} + (xy)  \\notin \\Sigma$; therefore $xy \\notin \\mathsf{p}$. $\\square$\n\nDenote\n$$r(\\mathsf{a}): = \\{f\\in A: \\text{there exist integer } n >0 \\text{ such that } f^{n} \\in \\mathsf{a}\\}$$\nwhich is the intersection of all prime ideals containing $\\mathsf{a}$ by [correspondence theorem](https://en.wikipedia.org/wiki/Isomorphism_theorems).\n\n## Definition [Irreducibility]\nA topological space $(X,\\mathscr{U})$ is said to be [irreducible]() if $X\\neq \\emptyset$ and $X$ can't be union of any two non-empty open sets $X = X_{1} \\cup X_{2}$, or equivalently, if $U_{1}, U_{2} \\neq \\emptyset$ are any two non-empty open sets, then $U_{1} \\cap U_{2} \\neq \\emptyset$. \n\n\n**Remark:** According to the definition, irreducibility if finer than connectness, because two open sets $X_{1},X_{2}$ can be intersected.\n\n\n## Theorem 1[Irreducibility]\n\n$\\text{Spec}(A)$ is irreducible if and only if its nilradical $\\mathfrak{R}$ of $A$ is a prime ideal. \n\t\nFor any two non-empty open sets $\\cup_{f \\in F} X_{f}$ and $\\cup_{g \\in G} X_{g}$ in $X=\\text{Spec}(A)$. \n$$\n\\begin{aligned}\n\t\t\\cup_{f \\in F} X_{f} \\neq \\emptyset &\\Leftrightarrow \\cap_{f \\in E} V(f) \\neq X \\Leftrightarrow \\exists f_{0} \\notin \\mathfrak{R}\\\\\n\t\t\\left(\\cup_{f \\in F} X_{f}\\right) \\cap \\left(\\cup_{g \\in G} X_{g}\\right) \\neq \\emptyset &\\Leftrightarrow \\cup_{f \\in F, g\\in G} \\left(X_{fg}\\right) \\neq \\emptyset \\Leftrightarrow \\exists f_{0}\\in F, g_{0} \\in G, f_{0}g_{0} \\notin \\mathfrak{R} \n\\end{aligned}\n$$\n\n**Remark 1:** Singletons $\\{x\\}, x\\in X$ are irreducible subspaces; the closure of irreducible subspaces in $X$ are irreducible subspaces. \n\n**Remark 2:** Each singleton $\\{x\\}, x\\in X$ contained in a maximal irreducible subspace of $X$, which is called [irreducible component](https://en.wikipedia.org/wiki/Irreducible_component). The irrducible components cover $X$.  \n\n**Remark 3:**\nIn an irreducible Hausdorff space $X$, the irrducible components of $X$ are singletons. However, the conected components, for instance, Euclidean space, are itself. \n\n\n\nBy taking quotient $A/\\mathsf{p}$ and noting that there is a one-to-one correspondence $h:\\mathsf{a} \\mapsto \\mathsf{a}/ \\mathsf{p}$ between $V(\\mathsf{p})$ and $\\text{Spec}(A/\\mathsf{p})$ that preserves prime ideals, there is a one-to-one correspondence between $r(\\mathsf{p}) = \\cap_{\\mathsf{p}_{x} \\in V(\\mathsf{p})} \\mathsf{p}_{x}$ and $\\mathfrak{R} (A/\\mathsf{p}) =  \\cap_{x\\in \\text{Spec}(A/\\mathsf{p})} x$, as is shown in the diagram\n\n$$\\begin{align}\n    \\require{AMScd} \n    \\begin{CD} \n\t\tV(\\mathsf{p}) @>>h> \\text{Spec} (A/\\mathsf{p})\\\\\n\t\t@VV{\\tiny \\text{cap}}V @VV{\\tiny \\text{cap}}V\\\\\n\t\tr(\\mathsf{p}) @>>h> \\mathfrak{R} (A/\\mathsf{p})\n\t\\end{CD}\n\\end{align}$$\n\nAccording to above theorem and\n\n> Non-zero ring $A$ has minimal prime ideals with respect to set inclusion.\nBy Zorn's lemma, it only suffices to prove that the intersection $\\cap_{n}\\mathsf{p}_{n}$ of a non-increasing sequence of prime ideals $\\cdots \\supseteq \\mathsf{p}_{n} \\supseteq \\mathsf{p}_{n+1}\\supseteq \\cdots$ is also a prime ideal. \nBy considering $x,y \\in A, xy \\in \\cap_{n}\\mathsf{p}_{n}$, we have for each $n$, either $x$ or $y$ belongs to $\\mathsf{p}_{n}$. Then one of $x$ and $y$ occurs in $\\mathsf{p}_{n}$ for infinitely many times, say, for example, $x  \\in \\cap_{n}\\mathsf{p}_{n}$. $\\square$\n\n\n\nwe only need to show that $h$ is a homeomorphism, which is indeed true since $h$ maps $V(\\mathsf{a}) \\cap V(\\mathsf{p}) = V(\\mathsf{a} + \\mathsf{p})$ to $V((\\mathsf{a} + \\mathsf{p})/ \\mathsf{p})$ and vice versa, where $\\mathsf{a}$ is an ideal of $A$. Similarily, the closed subspace $V(\\mathsf{p})$ of $\\text{Spec}(A)$ is irreducible if and only if $r(\\mathsf{p})$ is a prime ideal, where $\\mathsf{p}$ is an ideal of $A$. $\\square$ \n\n\n\t\n## Property 4 [Homomorphism]\n\nLet $\\phi: A \\to B$ be homomorphism that preserves unit. $X=\\text{Spec}(A) , Y=\\text{Spec}(B)$. Since $\\phi^{-1}$ draws back prime ideals in $Y$ into prime ideals in $X$, $\\phi$ introduces naturally a mapping\n$\\phi^{*}:  \\text{Spec}(B) \\to \\text{Spec}(A)$ by $\\mathsf{q} \\mapsto \\phi^{-1} (\\mathsf{q})$\n\n\n1. It is easy to verify that $(\\phi^{*})^{-1}(X_{f}) =Y_{\\phi(f)}$, which implies $\\phi^{*}$ is continuous. \n\t\n2. If $\\phi$ is surjective, then $\\phi^{*}$ is injective. By [Fundamental theorem on homomorphisms](https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms), $A/\\ker(\\phi) \\cong B$. Note in above we mention that $\\phi$ is a homeomorphism mappping, thereby $\\phi^{*}$ establish a homeomorphism between $Y=\\text{Spec}(B)$ and $V\\left(\\ker(\\phi)\\right)$.\n\n3. $\\overline{\\phi^{*}(V(\\mathsf{b}))} = V(\\phi^{*}(\\mathsf{b}))$. Hence if $\\phi$ is injective, then $\\phi^{*}(Y)$ is dense in $X$. Let $\\mathsf{q} \\in V(\\mathsf{b})$ and note that $\\phi^{*}(\\mathsf{b}) = \\phi^{-1}(\\mathsf{b}) \\subseteq \\phi^{-1}(\\mathsf{q}) $, so $\\phi^{-1}(\\mathsf{q}) \\in V(\\phi^{*}(\\mathsf{b}))$ and $\\mathsf{q} \\in \\phi(V(\\phi^{*}(\\mathsf{b})))$. Thus $V(\\mathsf{b}) \\subseteq \\phi(V(\\phi^{*}(\\mathsf{b})))$. Then note that\n$$y \\in \\overline{\\{x\\}} \\Leftrightarrow \\overline{\\{y\\}} \\subseteq \\overline{\\{x\\}} \\Leftrightarrow V(\\mathsf{p}_{y}) \\subseteq V(\\mathsf{p}_{x}) \\Leftrightarrow \\mathsf{p}_{x} \\subseteq \\mathsf{p}_{y}$$\nwhich says $\\overline{\\{x\\}} = V\\left(\\mathsf{p}(={x})\\right)$; $V(\\mathsf{b})$ is obviously the minimal closed set in $X$ which contains $\\phi^{*}(V(\\mathsf{b}))$ since $\\phi^{*}(\\mathsf{b}) \\in \\phi^{*}(V(\\mathsf{b}))$.\n\n\n\n$$\\begin{align}\n    \\require{AMScd} \n    \\begin{CD} \n\t\tX @<<{\\phi^*}< Y\\\\\n\t\t@AA{\\tiny \\text{$\\cup$}}A  @AA{\\tiny \\text{$\\cup$}}A\\\\\n\t\tV_A(\\phi^* (\\mathsf{b})) @<<{\\phi^*}< V_B(\\mathsf{b})\\\\\n\t\t@AA{\\text{$*$}}A  @AA{\\text{$*$}}A\\\\\n\t\t\\text{Spec}(A/\\phi^* (\\mathsf{b})) @<<{\\tilde\\phi^*}< \\text{Spec} (B/\\mathsf{b})\n\t\\end{CD} \n\\end{align}$$\n\n\n**Example:** Let $A$ be an integral domain with just one non-zero prime ideal $\\mathsf{p}$. and let $K$ be the field of fractions of $A$. Let $B=(A/\\mathsf{p}) \\times K$. Define $\\phi: A \\to B$ by $\\phi(x) = (\\bar{x}, x)$, where $\\bar{x}$ is the image of $x$ in $A/\\mathsf{p}$. $\\phi^{*}$ is bijective but not a homeomorphism: Since $A/\\mathsf{p}$ is also a field, hence $B = (A/\\mathsf{p}) \\times K$ has only two prime ideals\n$$\\left\\{(1)\\times(0), (0) \\times(1)\\right\\}$$\nDirect computation yields $\\phi^{*}$ is a bijection. However, $\\{(1) \\times (0)\\}$ is a closed set of $\\text{Spec}(B)$ whereas $\\{(0)\\}$ is not closed in $\\text{Spec}(A)$.\n\n\n## More on Separation Axiom [$T_{1}$, $T_{2}$]\nWe define \n$$\\mathscr{V}^{\\prime} = \\left\\{ \\phi^{*}\\left(\\text{Spec}(B)\\right): \\text{ where $\\phi:A \\to B$ is ring homomorphism} \\right\\}$$\nIt can be verified that $\\mathscr{V}^{\\prime}$ satisfies axiom of closed set. The topology in $\\text{Spec}(A)$ is called [constructable topology](https://en.wikipedia.org/wiki/Constructible_topology). which is finer than Zariski topology.\n\n\n1. $A/\\mathfrak{R}$ is [absolutely flat]() ($\\mathfrak{R}$ being the nilradical of $A$).\n2. Every prime ideal of $A$ is maximal.\n3. $\\text{Spec} (A)$ is a $T_{1}$-space (i.e., every subset consisting of a single point is closed).\n4. $\\text{Spec} (A)$ is Hausdorff.\n5. The Zariski topology and the constructible topology on $\\text{Spec} (A)$ coincide\n\n\n\n## Proporsition 5 [Connectedness]\n\t\nIf a commutative ring $A$ with unit can be represented as direct product of non-zero ring, $A_{i}, i=1, 2, \\cdots, n$, By a standard result in commutative ring, the ideals $A=\\prod_{i=1}^{n}A_{i}$ has the form\n\n$$\\mathsf{a}_{1} \\times \\cdots \\times \\mathsf{a}_{i} \\times \\cdots \\times \\mathsf{a}_{n}, \\text{ where $\\mathsf{a}_{i}$ are ideals of $A_{i}$} $$\t\nEspecially, prime ideals in $A$ has the form\n\n$$(1) \\times \\cdots \\times \\mathsf{p}_{i} \\times \\cdots \\times (1), \\text{ where $\\mathsf{p}_{i}$ are prime ideals of $A_{i}$}$$\n\nFor ring $A=\\prod_{i=1}^{n}A_{i}$, the spectrum $X = \\text{Spec}(A)$ is the disjoint union of $X_{i}, i =1,2,\\cdots,n$, where $X_{i}$ consists of prime ideals containing $(1) \\times \\cdots \\times \\underset{i}{(0)} \\times \\cdots \\times (1)$, homeomorphic to $\\text{Spec}(A_{i})$. Hence $X=\\text{Spec}(A)$ is not connected. $\\square$\n\nConversly, if the subsets $X_{1}, X_{2} \\neq \\emptyset, X_{1} \\cap X_{2} = \\emptyset$ of $X=\\text{Spec}(A)$ satisfies $X_{1} \\cup X_{2} = X$. According to the definition of spectrum, we have $X_{1} =V(\\mathsf{a}_{1}), X_{2} =V(\\mathsf{a}_{2}),$ where $\\mathsf{a}_{1},\\mathsf{a}_{2}$ are ideals of ring $A$, and\n$$\n\\begin{aligned}\nV(\\mathsf{a}_{1}) \\cap V(\\mathsf{a}_{2}) = V(\\mathsf{a}_{1} +\\mathsf{a}_{2}) =\\emptyset &\\Rightarrow \n\\mathsf{a}_{1} +\\mathsf{a}_{2} = (1)\\\\\nV(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2}) = V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}) = X &\\Rightarrow \n\\mathsf{a}_{1} \\cap \\mathsf{a}_{2} \\subseteq \\mathfrak{R}\n\\end{aligned}\n$$\nthere exist $x_{1} \\in \\mathsf{a}_{1}, x_{2} \\in \\mathsf{a}_{2}$, and integer $n>0$ such that \n$$\n\\begin{aligned}\nx_{1} + x_{2} &=1\\\\\n(x_{1} x_{2})^{n} &=0\n\\end{aligned}\n$$\nDue to elementary arithmetic it finds that \n$$r(x_{1}^{n}) + r(x_{2}^{n}) =1 \\Rightarrow (x_{1}^{n}) + (x_{2}^{n}) =1 $$.\nTherefore we can find an idempotent $e\\neq 0,1 \\in (x_{1}^{n})$ such that $1 - e \\in (x_{2}^{n})$, and $e(1 - e) = 0$, because the non-empty assumption of $X_{i}, i=1,2$. Thereby $A$ can be decomposed as the direct product of $eA$ and $(1-e) A$. $ \\square$\n\t\nWe summarize the result below:\n\nLet $A$ be any commutative ring with unit. The following statements are equivalent:\n\n1. $X = \\text{Spec} (A)$ is disconnected.\n\n2. $A \\cong A_{1} \\times A_{2}$ where neither of the rings $A_{1}$ or $A_{2}$ is the zero ring.\n\n3. $A$ contains an idempotent $\\neq 0,1$.\n\n\n**Remark:**  Local ring, that is, ring with only one maximal ideal, is always connected.\n\n# Reference \n\n[1] Michael Atiyah. Introduction to commutative algebra. CRC Press, 2018.\n\n[2] Suzanne C Dieudonne. History Algebraic Geometry. CRC Press, 1985.\n\n[3] Bartel L Van der Waerden. A history of algebra: From al-Khwrizm to Emmy Noether.\nSpringer Science & Business Media, 2013.\n\n\n","source":"_posts/Zariski topology.md","raw":"---\ntitle: Zariski Topology\ndate: 2023-03-23 07:13:04\ntag: \n    - [Algebraic Geometry]\ncategories:\n    - [Commutative Algebra, Algebraic Geometry]\nmathjax: true\n---\n\n## Definition\n\nLet $A$ be commutative ring with unit. $\\text{Spec}(A)$ is the collection of prime ideals of $A$. \n\n\n$V(E)$ is the collection of prime ideals containing $E \\subseteq A$. $\\{V(E); E \\subseteq A\\}$ is a collection of closed subsets of $\\text{Spec} (A)$, since\n\n1. $V(1)=\\emptyset, V(0) =X$. Hence [Axiom of Closed Set I](https://en.wikipedia.org/wiki/Closed_set) is satisfied.\n\t \n2.  $\\cap_{i \\in I} V(E_{i}) =V(\\cup_{i \\in I} E_{i})$. Hence [Axiom of Closed Set II](https://en.wikipedia.org/wiki/Closed_set) is satisfied.\n\t \n3. To verify axiom III, Consider the ideal $\\mathsf{a}_{1}$ generated by $E_{1}$ and the ideal $\\mathsf{a}_{2}$ generated by $E_{2}$. Note that $V(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2}) \\subseteq V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2})$. Then, for any prime ideal $\\mathsf{p}$ containing $\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}$, we have $\\mathsf{a}_{1} \\subseteq \\mathsf{p}$ or $\\mathsf{a}_{2} \\subseteq \\mathsf{p}$, since\n\n$$ x_{1},x_{2} \\notin \\mathsf{p} \\Rightarrow x_{1}x_{2} \\notin \\mathsf{p} \\text{ while }\\,\\, x_{1}\\in \\mathsf{a}_{1}, x_{2}\\in \\mathsf{a}_{2} \\Rightarrow x_{1}x_{2} \\in \n\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}$$\n\nThis proves $V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}) \\subseteq V(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2})$. Therefore, these sets equal to each other $V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}) = V(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2})$, which verifies [Axiom of Closed Set III](https://en.wikipedia.org/wiki/Closed_set). $\\square$\n\n\n## Proporsition 1 [Topological basis]\n\nGiven an element $f$ in $A$, we define $X_{f}$ to be the complement of $V(f)$ in $X=\\text{Spec}(A)$, so\n$$ \\mathscr{U}^{\\prime} = \\{X_{f}; f\\in A\\}$$\n\nis a [topological basis](https://en.wikipedia.org/wiki/Base_(topology)) for\n$$\\mathscr{U} = \\{ X\\backslash V(E); E \\subseteq A\\}$$\n\nTo see more clearly, Choose an open set $O \\in \\mathscr{U}$, it must be the complement of a closed set $V(E)$ generated by some subset $E$ of ring $A$, that is, $O = X\\backslash V(E)$. Decompose $E$ into the union of its components $\\left\\{f\\right\\}$ we have $E = \\cup_{f\\in E}\\{f\\}$, by utilize axiom of closed set III\n\n$$\n    O =X\\backslash \\left(\\cap_{f \\in E} V(f)\\right) = \\cup_{f\\in E} \\left(X \\backslash V(f)\\right) =\\cup_{f\\in E} X_{f}\n$$\n\nThat is to say $\\mathscr{U}^{\\prime}$ is a topological basis for $\\mathscr{U}$. $\\square$\n\n<br> \n\n## Proporsition 1 [Countability Axiom, not $C_{1}$]\n\n## Example \nLet $A$ be [UFD](https://en.wikipedia.org/wiki/Unique_factorization_domain). $I$ is an index set, $|I| \\geq \\aleph_{1}$. For each index $i\\in I$ associate with a variable $x_{i}$, Consider polynomial ring with coeffiecients in $A$\n$$ A[I] := \\{\\sum a_{i_{1},i_{2},\\cdots,i_{k}} x_{i_{i}}^{n_{1}}x_{i_{2}}^{n_{2}} \\cdots x_{i_{k}}^{n_{k}} :\na_{i_{1},i_{2},\\cdots,i_{k}}\\in A \\}$$\n\\text{ where sum is over finite term}. Since $A[I]$ in integral domain, $(0)$ is a prime ideal. The Zariski topological basis $\\{X_{f}; {f \\in A(I)}\\}$ for ring $A(I)$ with emptyset exception, that is $f\\neq 0$, is a neighborhood basis at $(0)$ for $\\text{Spec}(A[I])$ . Since $A[I]$ is either UFD, $A[I]$ contains uncoutable many prime idels $(x_{i}), {i \\in I}$, which implies $A[I]$ dose not satisfies [first-countable axiom $C_{1}$](https://en.wikipedia.org/wiki/First-countable_space).\n\nFor topological space, we are also interested in its separation, compactness and connectedness etc.\n\n## Proporsition 2 [Separation Axiom $T_{0}$]\n\n\nA topological space $(X,\\mathscr{U})$ satisfies [separtion axiom $T_{0}$](https://en.wikipedia.org/wiki/Kolmogorov_space) separation, if for any $x,y \\in X$, $x\\neq y$, there exists open set $U \\in \\mathscr{U}$, such that $x\\in U, y \\notin U$ of if $y \\in U, x \\notin U$. \n\nLet $x,y$ be distinct two points in $X=\\text{Spec}(A)$, i.e. two distinct prime ideals $\\mathsf{p}_{x},\\mathsf{p}_{y}$ of ring $A$:\n\t\n1. If $\\mathsf{p}_{x} \\subseteq \\mathsf{p}_{y}$, then $V(\\mathsf{p}_{y}) \\subseteq V(\\mathsf{p}_{x})$. Taking $U= X \\backslash V(\\mathsf{p}_{y})$ we have $x\\in U, y \\notin U$.\n\t\n2. If $\\mathsf{p}_{x} \\subsetneq \\mathsf{p}_{y}$, thereby $\\mathsf{p}_{y} \\notin V(\\mathsf{p}_{x})$. Taking $U = X \\backslash V(\\mathsf{p}_{x})$ we have $y \\in U, x \\notin U$.\n\t\nThis together impies that $X=\\text{Spec}(A)$ satisfies separation axiom $T_{0}$. $\\square$\n\n## Propersition 3 [Compactness]\n\nWe next prove $X = \\text{Spec} (A)$ is (compact)[]. It only suffices to consider covering from topological basis $\\{X_{f}; {f\\in E}\\}$, where $E\\neq \\emptyset$ is a subset of ring $A$. Accrording to (De Morgan law)[] and axiom of closed set III, nota that\n$$\nX \\backslash \\left(\\cup_{f\\in E} X_{f}\\right) = \\cap_{f\\in E} \\left(X \\backslash X_{f} \\right) = V (\\cup_{f\\in E}  \\{f\\})\n$$\nhence $\\cup_{f\\in E} X_{f} = X \\Leftrightarrow  V(E) =\\emptyset$. Let the ideal generated by $E$ be $\\mathsf{a}$, we show that $\\mathsf{a}= (1) $: \n\t\n> Let $\\Sigma$ consist of non-trivial ideals of $A$. Since the non-decreasing chain of ideals are also an ideal, by Zorn lemma, if $\\Sigma \\neq \\emptyset$, $\\Sigma$ contains a maximal element $\\mathsf{a}_{0}$ with respect to $\\subseteq$-partial ordering; it is indeed an maximal ideal. (Otherwise, if there exist another $\\mathsf{a}_{0}^{\\prime}$ such that $\\mathsf{a}_{0} \\subseteq \\mathsf{a}_{0}^{\\prime}$, $\\mathsf{a}_{0}^{\\prime} = \\mathsf{a}_{0} \\cup \\mathsf{a}_{0}^{\\prime}$ is maximal with respect to inclusion relation.) It also can be proved that if $\\mathsf{a} \\neq (1)$, $\\mathsf{a}$ is contained in a maximal ideal. Hence if $\\mathsf{a} \\neq (1)$, $V(\\mathsf{a})$ contains at least an element. Contradiction. $\\square$ [[See Zorn lemma]](https://en.wikipedia.org/wiki/Zorn%27s_lemma)\n\nTherefore $1$ can be represented by a finite sum of products of elements from $E$ and $A$:\n$$1 = g_{1}f_{1} + \\cdots + g_{n}f_{n}, \\quad g_{i}\\in A, f_{i} \\in E, 1 \\leq i \\leq n$$\nTake $F= \\{f_{1}, \\cdots, f_{n}\\}$, thereby $V(F) = \\emptyset$, which implies $\\{X_{f}; {f \\in F}\\}$ covers $X$. $\\square$\n\n## Definition [Nilradical and Radical]\nThe ideal $\\mathfrak{R}$ of all nipotents in a commutative ring $A$ with unit $1$ is the insection of all prime ideals of $A$, that is,\n$$\n\\mathfrak{R} = \\bigcap_{\\mathsf{p} \\text{ is a prime ideal of $A$}} \\mathsf{p}\n$$\n\nOf course $\\mathfrak{R}$ is an ideal closed under addition and multiplicatio. We split the proof in two steps:\n\n1. If $\\mathsf{p}$ is a prime ideal, then $\\mathfrak{R}\\subseteq \\mathsf{p}$. Since $0 \\in \\mathsf{p}$, and we know for any $f \\in \\mathfrak{R}$, there exist an integer $n>0$ such that \n$$f^{n} \\in \\mathsf{p} \\Rightarrow \\cdots \\Rightarrow  f \\in \\mathsf{p}$$\n\n2. If $f$ in not nilpotent, then there is a prime ideal $\\mathsf{p} \\cap \\{f\\} = \\emptyset$. Let \n$$\\Sigma = \\left\\{ \\mathsf{a} \\text{ is an ideal of $A$}: \\text{for any $n \\in \\mathbb{N}_{*}$, }f^{n} \\notin \\mathsf{a} \\right\\}$$\n\n> Since $(0) \\in \\Sigma$. By Zorn lemma, $\\Sigma$ contains maximal element $\\mathsf{p}$ with respect to $\\subseteq$-inclusion partial ordering. This $\\mathsf{p}$ is indeed a prime ideal, because: \n> For any $x,y \\notin \\mathsf{p}$, thanks to the maximal proporty of $\\mathsf{p}$ we have $\\mathsf{p} +  (x)$, $\\mathsf{p} + (y)$ $\\notin \\Sigma$; however,\n> $$\\begin{aligned}\t\n    f^{m} \\in\\mathsf{p} + (x) &, f^{n} \\in \\mathsf{p} +(y) \\Rightarrow f^{m+n} \\in \\mathsf{p} + (xy) \n\\end{aligned}$$\n> implies $\\mathsf{p} + (xy)  \\notin \\Sigma$; therefore $xy \\notin \\mathsf{p}$. $\\square$\n\nDenote\n$$r(\\mathsf{a}): = \\{f\\in A: \\text{there exist integer } n >0 \\text{ such that } f^{n} \\in \\mathsf{a}\\}$$\nwhich is the intersection of all prime ideals containing $\\mathsf{a}$ by [correspondence theorem](https://en.wikipedia.org/wiki/Isomorphism_theorems).\n\n## Definition [Irreducibility]\nA topological space $(X,\\mathscr{U})$ is said to be [irreducible]() if $X\\neq \\emptyset$ and $X$ can't be union of any two non-empty open sets $X = X_{1} \\cup X_{2}$, or equivalently, if $U_{1}, U_{2} \\neq \\emptyset$ are any two non-empty open sets, then $U_{1} \\cap U_{2} \\neq \\emptyset$. \n\n\n**Remark:** According to the definition, irreducibility if finer than connectness, because two open sets $X_{1},X_{2}$ can be intersected.\n\n\n## Theorem 1[Irreducibility]\n\n$\\text{Spec}(A)$ is irreducible if and only if its nilradical $\\mathfrak{R}$ of $A$ is a prime ideal. \n\t\nFor any two non-empty open sets $\\cup_{f \\in F} X_{f}$ and $\\cup_{g \\in G} X_{g}$ in $X=\\text{Spec}(A)$. \n$$\n\\begin{aligned}\n\t\t\\cup_{f \\in F} X_{f} \\neq \\emptyset &\\Leftrightarrow \\cap_{f \\in E} V(f) \\neq X \\Leftrightarrow \\exists f_{0} \\notin \\mathfrak{R}\\\\\n\t\t\\left(\\cup_{f \\in F} X_{f}\\right) \\cap \\left(\\cup_{g \\in G} X_{g}\\right) \\neq \\emptyset &\\Leftrightarrow \\cup_{f \\in F, g\\in G} \\left(X_{fg}\\right) \\neq \\emptyset \\Leftrightarrow \\exists f_{0}\\in F, g_{0} \\in G, f_{0}g_{0} \\notin \\mathfrak{R} \n\\end{aligned}\n$$\n\n**Remark 1:** Singletons $\\{x\\}, x\\in X$ are irreducible subspaces; the closure of irreducible subspaces in $X$ are irreducible subspaces. \n\n**Remark 2:** Each singleton $\\{x\\}, x\\in X$ contained in a maximal irreducible subspace of $X$, which is called [irreducible component](https://en.wikipedia.org/wiki/Irreducible_component). The irrducible components cover $X$.  \n\n**Remark 3:**\nIn an irreducible Hausdorff space $X$, the irrducible components of $X$ are singletons. However, the conected components, for instance, Euclidean space, are itself. \n\n\n\nBy taking quotient $A/\\mathsf{p}$ and noting that there is a one-to-one correspondence $h:\\mathsf{a} \\mapsto \\mathsf{a}/ \\mathsf{p}$ between $V(\\mathsf{p})$ and $\\text{Spec}(A/\\mathsf{p})$ that preserves prime ideals, there is a one-to-one correspondence between $r(\\mathsf{p}) = \\cap_{\\mathsf{p}_{x} \\in V(\\mathsf{p})} \\mathsf{p}_{x}$ and $\\mathfrak{R} (A/\\mathsf{p}) =  \\cap_{x\\in \\text{Spec}(A/\\mathsf{p})} x$, as is shown in the diagram\n\n$$\\begin{align}\n    \\require{AMScd} \n    \\begin{CD} \n\t\tV(\\mathsf{p}) @>>h> \\text{Spec} (A/\\mathsf{p})\\\\\n\t\t@VV{\\tiny \\text{cap}}V @VV{\\tiny \\text{cap}}V\\\\\n\t\tr(\\mathsf{p}) @>>h> \\mathfrak{R} (A/\\mathsf{p})\n\t\\end{CD}\n\\end{align}$$\n\nAccording to above theorem and\n\n> Non-zero ring $A$ has minimal prime ideals with respect to set inclusion.\nBy Zorn's lemma, it only suffices to prove that the intersection $\\cap_{n}\\mathsf{p}_{n}$ of a non-increasing sequence of prime ideals $\\cdots \\supseteq \\mathsf{p}_{n} \\supseteq \\mathsf{p}_{n+1}\\supseteq \\cdots$ is also a prime ideal. \nBy considering $x,y \\in A, xy \\in \\cap_{n}\\mathsf{p}_{n}$, we have for each $n$, either $x$ or $y$ belongs to $\\mathsf{p}_{n}$. Then one of $x$ and $y$ occurs in $\\mathsf{p}_{n}$ for infinitely many times, say, for example, $x  \\in \\cap_{n}\\mathsf{p}_{n}$. $\\square$\n\n\n\nwe only need to show that $h$ is a homeomorphism, which is indeed true since $h$ maps $V(\\mathsf{a}) \\cap V(\\mathsf{p}) = V(\\mathsf{a} + \\mathsf{p})$ to $V((\\mathsf{a} + \\mathsf{p})/ \\mathsf{p})$ and vice versa, where $\\mathsf{a}$ is an ideal of $A$. Similarily, the closed subspace $V(\\mathsf{p})$ of $\\text{Spec}(A)$ is irreducible if and only if $r(\\mathsf{p})$ is a prime ideal, where $\\mathsf{p}$ is an ideal of $A$. $\\square$ \n\n\n\t\n## Property 4 [Homomorphism]\n\nLet $\\phi: A \\to B$ be homomorphism that preserves unit. $X=\\text{Spec}(A) , Y=\\text{Spec}(B)$. Since $\\phi^{-1}$ draws back prime ideals in $Y$ into prime ideals in $X$, $\\phi$ introduces naturally a mapping\n$\\phi^{*}:  \\text{Spec}(B) \\to \\text{Spec}(A)$ by $\\mathsf{q} \\mapsto \\phi^{-1} (\\mathsf{q})$\n\n\n1. It is easy to verify that $(\\phi^{*})^{-1}(X_{f}) =Y_{\\phi(f)}$, which implies $\\phi^{*}$ is continuous. \n\t\n2. If $\\phi$ is surjective, then $\\phi^{*}$ is injective. By [Fundamental theorem on homomorphisms](https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms), $A/\\ker(\\phi) \\cong B$. Note in above we mention that $\\phi$ is a homeomorphism mappping, thereby $\\phi^{*}$ establish a homeomorphism between $Y=\\text{Spec}(B)$ and $V\\left(\\ker(\\phi)\\right)$.\n\n3. $\\overline{\\phi^{*}(V(\\mathsf{b}))} = V(\\phi^{*}(\\mathsf{b}))$. Hence if $\\phi$ is injective, then $\\phi^{*}(Y)$ is dense in $X$. Let $\\mathsf{q} \\in V(\\mathsf{b})$ and note that $\\phi^{*}(\\mathsf{b}) = \\phi^{-1}(\\mathsf{b}) \\subseteq \\phi^{-1}(\\mathsf{q}) $, so $\\phi^{-1}(\\mathsf{q}) \\in V(\\phi^{*}(\\mathsf{b}))$ and $\\mathsf{q} \\in \\phi(V(\\phi^{*}(\\mathsf{b})))$. Thus $V(\\mathsf{b}) \\subseteq \\phi(V(\\phi^{*}(\\mathsf{b})))$. Then note that\n$$y \\in \\overline{\\{x\\}} \\Leftrightarrow \\overline{\\{y\\}} \\subseteq \\overline{\\{x\\}} \\Leftrightarrow V(\\mathsf{p}_{y}) \\subseteq V(\\mathsf{p}_{x}) \\Leftrightarrow \\mathsf{p}_{x} \\subseteq \\mathsf{p}_{y}$$\nwhich says $\\overline{\\{x\\}} = V\\left(\\mathsf{p}(={x})\\right)$; $V(\\mathsf{b})$ is obviously the minimal closed set in $X$ which contains $\\phi^{*}(V(\\mathsf{b}))$ since $\\phi^{*}(\\mathsf{b}) \\in \\phi^{*}(V(\\mathsf{b}))$.\n\n\n\n$$\\begin{align}\n    \\require{AMScd} \n    \\begin{CD} \n\t\tX @<<{\\phi^*}< Y\\\\\n\t\t@AA{\\tiny \\text{$\\cup$}}A  @AA{\\tiny \\text{$\\cup$}}A\\\\\n\t\tV_A(\\phi^* (\\mathsf{b})) @<<{\\phi^*}< V_B(\\mathsf{b})\\\\\n\t\t@AA{\\text{$*$}}A  @AA{\\text{$*$}}A\\\\\n\t\t\\text{Spec}(A/\\phi^* (\\mathsf{b})) @<<{\\tilde\\phi^*}< \\text{Spec} (B/\\mathsf{b})\n\t\\end{CD} \n\\end{align}$$\n\n\n**Example:** Let $A$ be an integral domain with just one non-zero prime ideal $\\mathsf{p}$. and let $K$ be the field of fractions of $A$. Let $B=(A/\\mathsf{p}) \\times K$. Define $\\phi: A \\to B$ by $\\phi(x) = (\\bar{x}, x)$, where $\\bar{x}$ is the image of $x$ in $A/\\mathsf{p}$. $\\phi^{*}$ is bijective but not a homeomorphism: Since $A/\\mathsf{p}$ is also a field, hence $B = (A/\\mathsf{p}) \\times K$ has only two prime ideals\n$$\\left\\{(1)\\times(0), (0) \\times(1)\\right\\}$$\nDirect computation yields $\\phi^{*}$ is a bijection. However, $\\{(1) \\times (0)\\}$ is a closed set of $\\text{Spec}(B)$ whereas $\\{(0)\\}$ is not closed in $\\text{Spec}(A)$.\n\n\n## More on Separation Axiom [$T_{1}$, $T_{2}$]\nWe define \n$$\\mathscr{V}^{\\prime} = \\left\\{ \\phi^{*}\\left(\\text{Spec}(B)\\right): \\text{ where $\\phi:A \\to B$ is ring homomorphism} \\right\\}$$\nIt can be verified that $\\mathscr{V}^{\\prime}$ satisfies axiom of closed set. The topology in $\\text{Spec}(A)$ is called [constructable topology](https://en.wikipedia.org/wiki/Constructible_topology). which is finer than Zariski topology.\n\n\n1. $A/\\mathfrak{R}$ is [absolutely flat]() ($\\mathfrak{R}$ being the nilradical of $A$).\n2. Every prime ideal of $A$ is maximal.\n3. $\\text{Spec} (A)$ is a $T_{1}$-space (i.e., every subset consisting of a single point is closed).\n4. $\\text{Spec} (A)$ is Hausdorff.\n5. The Zariski topology and the constructible topology on $\\text{Spec} (A)$ coincide\n\n\n\n## Proporsition 5 [Connectedness]\n\t\nIf a commutative ring $A$ with unit can be represented as direct product of non-zero ring, $A_{i}, i=1, 2, \\cdots, n$, By a standard result in commutative ring, the ideals $A=\\prod_{i=1}^{n}A_{i}$ has the form\n\n$$\\mathsf{a}_{1} \\times \\cdots \\times \\mathsf{a}_{i} \\times \\cdots \\times \\mathsf{a}_{n}, \\text{ where $\\mathsf{a}_{i}$ are ideals of $A_{i}$} $$\t\nEspecially, prime ideals in $A$ has the form\n\n$$(1) \\times \\cdots \\times \\mathsf{p}_{i} \\times \\cdots \\times (1), \\text{ where $\\mathsf{p}_{i}$ are prime ideals of $A_{i}$}$$\n\nFor ring $A=\\prod_{i=1}^{n}A_{i}$, the spectrum $X = \\text{Spec}(A)$ is the disjoint union of $X_{i}, i =1,2,\\cdots,n$, where $X_{i}$ consists of prime ideals containing $(1) \\times \\cdots \\times \\underset{i}{(0)} \\times \\cdots \\times (1)$, homeomorphic to $\\text{Spec}(A_{i})$. Hence $X=\\text{Spec}(A)$ is not connected. $\\square$\n\nConversly, if the subsets $X_{1}, X_{2} \\neq \\emptyset, X_{1} \\cap X_{2} = \\emptyset$ of $X=\\text{Spec}(A)$ satisfies $X_{1} \\cup X_{2} = X$. According to the definition of spectrum, we have $X_{1} =V(\\mathsf{a}_{1}), X_{2} =V(\\mathsf{a}_{2}),$ where $\\mathsf{a}_{1},\\mathsf{a}_{2}$ are ideals of ring $A$, and\n$$\n\\begin{aligned}\nV(\\mathsf{a}_{1}) \\cap V(\\mathsf{a}_{2}) = V(\\mathsf{a}_{1} +\\mathsf{a}_{2}) =\\emptyset &\\Rightarrow \n\\mathsf{a}_{1} +\\mathsf{a}_{2} = (1)\\\\\nV(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2}) = V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}) = X &\\Rightarrow \n\\mathsf{a}_{1} \\cap \\mathsf{a}_{2} \\subseteq \\mathfrak{R}\n\\end{aligned}\n$$\nthere exist $x_{1} \\in \\mathsf{a}_{1}, x_{2} \\in \\mathsf{a}_{2}$, and integer $n>0$ such that \n$$\n\\begin{aligned}\nx_{1} + x_{2} &=1\\\\\n(x_{1} x_{2})^{n} &=0\n\\end{aligned}\n$$\nDue to elementary arithmetic it finds that \n$$r(x_{1}^{n}) + r(x_{2}^{n}) =1 \\Rightarrow (x_{1}^{n}) + (x_{2}^{n}) =1 $$.\nTherefore we can find an idempotent $e\\neq 0,1 \\in (x_{1}^{n})$ such that $1 - e \\in (x_{2}^{n})$, and $e(1 - e) = 0$, because the non-empty assumption of $X_{i}, i=1,2$. Thereby $A$ can be decomposed as the direct product of $eA$ and $(1-e) A$. $ \\square$\n\t\nWe summarize the result below:\n\nLet $A$ be any commutative ring with unit. The following statements are equivalent:\n\n1. $X = \\text{Spec} (A)$ is disconnected.\n\n2. $A \\cong A_{1} \\times A_{2}$ where neither of the rings $A_{1}$ or $A_{2}$ is the zero ring.\n\n3. $A$ contains an idempotent $\\neq 0,1$.\n\n\n**Remark:**  Local ring, that is, ring with only one maximal ideal, is always connected.\n\n# Reference \n\n[1] Michael Atiyah. Introduction to commutative algebra. CRC Press, 2018.\n\n[2] Suzanne C Dieudonne. History Algebraic Geometry. CRC Press, 1985.\n\n[3] Bartel L Van der Waerden. A history of algebra: From al-Khwrizm to Emmy Noether.\nSpringer Science & Business Media, 2013.\n\n\n","slug":"Zariski topology","published":1,"updated":"2023-12-31T07:46:31.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisunl000reslr4u5x2qli","content":"<h2 id=\"definition\">Definition</h2>\r\n<p>Let <span class=\"math inline\">\\(A\\)</span> be commutative ring with\r\nunit. <span class=\"math inline\">\\(\\text{Spec}(A)\\)</span> is the\r\ncollection of prime ideals of <span\r\nclass=\"math inline\">\\(A\\)</span>.</p>\r\n<p><span class=\"math inline\">\\(V(E)\\)</span> is the collection of prime\r\nideals containing <span class=\"math inline\">\\(E \\subseteq A\\)</span>.\r\n<span class=\"math inline\">\\(\\{V(E); E \\subseteq A\\}\\)</span> is a\r\ncollection of closed subsets of <span class=\"math inline\">\\(\\text{Spec}\r\n(A)\\)</span>, since</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(V(1)=\\emptyset, V(0) =X\\)</span>.\r\nHence <a href=\"https://en.wikipedia.org/wiki/Closed_set\">Axiom of Closed\r\nSet I</a> is satisfied.</p></li>\r\n<li><p><span class=\"math inline\">\\(\\cap_{i \\in I} V(E_{i}) =V(\\cup_{i\r\n\\in I} E_{i})\\)</span>. Hence <a\r\nhref=\"https://en.wikipedia.org/wiki/Closed_set\">Axiom of Closed Set\r\nII</a> is satisfied.</p></li>\r\n<li><p>To verify axiom III, Consider the ideal <span\r\nclass=\"math inline\">\\(\\mathsf{a}_{1}\\)</span> generated by <span\r\nclass=\"math inline\">\\(E_{1}\\)</span> and the ideal <span\r\nclass=\"math inline\">\\(\\mathsf{a}_{2}\\)</span> generated by <span\r\nclass=\"math inline\">\\(E_{2}\\)</span>. Note that <span\r\nclass=\"math inline\">\\(V(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2}) \\subseteq\r\nV(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2})\\)</span>. Then, for any prime\r\nideal <span class=\"math inline\">\\(\\mathsf{p}\\)</span> containing <span\r\nclass=\"math inline\">\\(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}\\)</span>, we\r\nhave <span class=\"math inline\">\\(\\mathsf{a}_{1} \\subseteq\r\n\\mathsf{p}\\)</span> or <span class=\"math inline\">\\(\\mathsf{a}_{2}\r\n\\subseteq \\mathsf{p}\\)</span>, since</p></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[ x_{1},x_{2} \\notin \\mathsf{p}\r\n\\Rightarrow x_{1}x_{2} \\notin \\mathsf{p} \\text{ while }\\,\\, x_{1}\\in\r\n\\mathsf{a}_{1}, x_{2}\\in \\mathsf{a}_{2} \\Rightarrow x_{1}x_{2} \\in\r\n\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}\\]</span></p>\r\n<p>This proves <span class=\"math inline\">\\(V(\\mathsf{a}_{1} \\cap\r\n\\mathsf{a}_{2}) \\subseteq V(\\mathsf{a}_{1}) \\cup\r\nV(\\mathsf{a}_{2})\\)</span>. Therefore, these sets equal to each other\r\n<span class=\"math inline\">\\(V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}) =\r\nV(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2})\\)</span>, which verifies <a\r\nhref=\"https://en.wikipedia.org/wiki/Closed_set\">Axiom of Closed Set\r\nIII</a>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"proporsition-1-topological-basis\">Proporsition 1 [Topological\r\nbasis]</h2>\r\n<p>Given an element <span class=\"math inline\">\\(f\\)</span> in <span\r\nclass=\"math inline\">\\(A\\)</span>, we define <span\r\nclass=\"math inline\">\\(X_{f}\\)</span> to be the complement of <span\r\nclass=\"math inline\">\\(V(f)\\)</span> in <span\r\nclass=\"math inline\">\\(X=\\text{Spec}(A)\\)</span>, so <span\r\nclass=\"math display\">\\[ \\mathscr{U}^{\\prime} = \\{X_{f}; f\\in\r\nA\\}\\]</span></p>\r\n<p>is a <a\r\nhref=\"https://en.wikipedia.org/wiki/Base_(topology)\">topological\r\nbasis</a> for <span class=\"math display\">\\[\\mathscr{U} = \\{ X\\backslash\r\nV(E); E \\subseteq A\\}\\]</span></p>\r\n<p>To see more clearly, Choose an open set <span class=\"math inline\">\\(O\r\n\\in \\mathscr{U}\\)</span>, it must be the complement of a closed set\r\n<span class=\"math inline\">\\(V(E)\\)</span> generated by some subset <span\r\nclass=\"math inline\">\\(E\\)</span> of ring <span\r\nclass=\"math inline\">\\(A\\)</span>, that is, <span class=\"math inline\">\\(O\r\n= X\\backslash V(E)\\)</span>. Decompose <span\r\nclass=\"math inline\">\\(E\\)</span> into the union of its components <span\r\nclass=\"math inline\">\\(\\left\\{f\\right\\}\\)</span> we have <span\r\nclass=\"math inline\">\\(E = \\cup_{f\\in E}\\{f\\}\\)</span>, by utilize axiom\r\nof closed set III</p>\r\n<p><span class=\"math display\">\\[\r\n    O =X\\backslash \\left(\\cap_{f \\in E} V(f)\\right) = \\cup_{f\\in E}\r\n\\left(X \\backslash V(f)\\right) =\\cup_{f\\in E} X_{f}\r\n\\]</span></p>\r\n<p>That is to say <span\r\nclass=\"math inline\">\\(\\mathscr{U}^{\\prime}\\)</span> is a topological\r\nbasis for <span class=\"math inline\">\\(\\mathscr{U}\\)</span>. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<p><br></p>\r\n<h2 id=\"proporsition-1-countability-axiom-not-c_1\">Proporsition 1\r\n[Countability Axiom, not <span\r\nclass=\"math inline\">\\(C_{1}\\)</span>]</h2>\r\n<h2 id=\"example\">Example</h2>\r\n<p>Let <span class=\"math inline\">\\(A\\)</span> be <a\r\nhref=\"https://en.wikipedia.org/wiki/Unique_factorization_domain\">UFD</a>.\r\n<span class=\"math inline\">\\(I\\)</span> is an index set, <span\r\nclass=\"math inline\">\\(|I| \\geq \\aleph_{1}\\)</span>. For each index <span\r\nclass=\"math inline\">\\(i\\in I\\)</span> associate with a variable <span\r\nclass=\"math inline\">\\(x_{i}\\)</span>, Consider polynomial ring with\r\ncoeffiecients in <span class=\"math inline\">\\(A\\)</span> <span\r\nclass=\"math display\">\\[ A[I] := \\{\\sum a_{i_{1},i_{2},\\cdots,i_{k}}\r\nx_{i_{i}}^{n_{1}}x_{i_{2}}^{n_{2}} \\cdots x_{i_{k}}^{n_{k}} :\r\na_{i_{1},i_{2},\\cdots,i_{k}}\\in A \\}\\]</span> . Since <span\r\nclass=\"math inline\">\\(A[I]\\)</span> in integral domain, <span\r\nclass=\"math inline\">\\((0)\\)</span> is a prime ideal. The Zariski\r\ntopological basis <span class=\"math inline\">\\(\\{X_{f}; {f \\in\r\nA(I)}\\}\\)</span> for ring <span class=\"math inline\">\\(A(I)\\)</span> with\r\nemptyset exception, that is <span class=\"math inline\">\\(f\\neq\r\n0\\)</span>, is a neighborhood basis at <span\r\nclass=\"math inline\">\\((0)\\)</span> for <span\r\nclass=\"math inline\">\\(\\text{Spec}(A[I])\\)</span> . Since <span\r\nclass=\"math inline\">\\(A[I]\\)</span> is either UFD, <span\r\nclass=\"math inline\">\\(A[I]\\)</span> contains uncoutable many prime idels\r\n<span class=\"math inline\">\\((x_{i}), {i \\in I}\\)</span>, which implies\r\n<span class=\"math inline\">\\(A[I]\\)</span> dose not satisfies <a\r\nhref=\"https://en.wikipedia.org/wiki/First-countable_space\">first-countable\r\naxiom <span class=\"math inline\">\\(C_{1}\\)</span></a>.</p>\r\n<p>For topological space, we are also interested in its separation,\r\ncompactness and connectedness etc.</p>\r\n<h2 id=\"proporsition-2-separation-axiom-t_0\">Proporsition 2 [Separation\r\nAxiom <span class=\"math inline\">\\(T_{0}\\)</span>]</h2>\r\n<p>A topological space <span\r\nclass=\"math inline\">\\((X,\\mathscr{U})\\)</span> satisfies <a\r\nhref=\"https://en.wikipedia.org/wiki/Kolmogorov_space\">separtion axiom\r\n<span class=\"math inline\">\\(T_{0}\\)</span></a> separation, if for any\r\n<span class=\"math inline\">\\(x,y \\in X\\)</span>, <span\r\nclass=\"math inline\">\\(x\\neq y\\)</span>, there exists open set <span\r\nclass=\"math inline\">\\(U \\in \\mathscr{U}\\)</span>, such that <span\r\nclass=\"math inline\">\\(x\\in U, y \\notin U\\)</span> of if <span\r\nclass=\"math inline\">\\(y \\in U, x \\notin U\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(x,y\\)</span> be distinct two points\r\nin <span class=\"math inline\">\\(X=\\text{Spec}(A)\\)</span>, i.e. two\r\ndistinct prime ideals <span\r\nclass=\"math inline\">\\(\\mathsf{p}_{x},\\mathsf{p}_{y}\\)</span> of ring\r\n<span class=\"math inline\">\\(A\\)</span>:</p>\r\n<ol type=\"1\">\r\n<li><p>If <span class=\"math inline\">\\(\\mathsf{p}_{x} \\subseteq\r\n\\mathsf{p}_{y}\\)</span>, then <span\r\nclass=\"math inline\">\\(V(\\mathsf{p}_{y}) \\subseteq\r\nV(\\mathsf{p}_{x})\\)</span>. Taking <span class=\"math inline\">\\(U= X\r\n\\backslash V(\\mathsf{p}_{y})\\)</span> we have <span\r\nclass=\"math inline\">\\(x\\in U, y \\notin U\\)</span>.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(\\mathsf{p}_{x} \\subsetneq\r\n\\mathsf{p}_{y}\\)</span>, thereby <span\r\nclass=\"math inline\">\\(\\mathsf{p}_{y} \\notin V(\\mathsf{p}_{x})\\)</span>.\r\nTaking <span class=\"math inline\">\\(U = X \\backslash\r\nV(\\mathsf{p}_{x})\\)</span> we have <span class=\"math inline\">\\(y \\in U,\r\nx \\notin U\\)</span>.</p></li>\r\n</ol>\r\n<p>This together impies that <span\r\nclass=\"math inline\">\\(X=\\text{Spec}(A)\\)</span> satisfies separation\r\naxiom <span class=\"math inline\">\\(T_{0}\\)</span>. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"propersition-3-compactness\">Propersition 3 [Compactness]</h2>\r\n<p>We next prove <span class=\"math inline\">\\(X = \\text{Spec}\r\n(A)\\)</span> is (compact)[]. It only suffices to consider covering from\r\ntopological basis <span class=\"math inline\">\\(\\{X_{f}; {f\\in\r\nE}\\}\\)</span>, where <span class=\"math inline\">\\(E\\neq\r\n\\emptyset\\)</span> is a subset of ring <span\r\nclass=\"math inline\">\\(A\\)</span>. Accrording to (De Morgan law)[] and\r\naxiom of closed set III, nota that <span class=\"math display\">\\[\r\nX \\backslash \\left(\\cup_{f\\in E} X_{f}\\right) = \\cap_{f\\in E} \\left(X\r\n\\backslash X_{f} \\right) = V (\\cup_{f\\in E}  \\{f\\})\r\n\\]</span> hence <span class=\"math inline\">\\(\\cup_{f\\in E} X_{f} = X\r\n\\Leftrightarrow V(E) =\\emptyset\\)</span>. Let the ideal generated by\r\n<span class=\"math inline\">\\(E\\)</span> be <span\r\nclass=\"math inline\">\\(\\mathsf{a}\\)</span>, we show that $= (1) $:</p>\r\n<blockquote>\r\n<p>Let <span class=\"math inline\">\\(\\Sigma\\)</span> consist of\r\nnon-trivial ideals of <span class=\"math inline\">\\(A\\)</span>. Since the\r\nnon-decreasing chain of ideals are also an ideal, by Zorn lemma, if\r\n<span class=\"math inline\">\\(\\Sigma \\neq \\emptyset\\)</span>, <span\r\nclass=\"math inline\">\\(\\Sigma\\)</span> contains a maximal element <span\r\nclass=\"math inline\">\\(\\mathsf{a}_{0}\\)</span> with respect to <span\r\nclass=\"math inline\">\\(\\subseteq\\)</span>-partial ordering; it is indeed\r\nan maximal ideal. (Otherwise, if there exist another <span\r\nclass=\"math inline\">\\(\\mathsf{a}_{0}^{\\prime}\\)</span> such that <span\r\nclass=\"math inline\">\\(\\mathsf{a}_{0} \\subseteq\r\n\\mathsf{a}_{0}^{\\prime}\\)</span>, <span\r\nclass=\"math inline\">\\(\\mathsf{a}_{0}^{\\prime} = \\mathsf{a}_{0} \\cup\r\n\\mathsf{a}_{0}^{\\prime}\\)</span> is maximal with respect to inclusion\r\nrelation.) It also can be proved that if <span\r\nclass=\"math inline\">\\(\\mathsf{a} \\neq (1)\\)</span>, <span\r\nclass=\"math inline\">\\(\\mathsf{a}\\)</span> is contained in a maximal\r\nideal. Hence if <span class=\"math inline\">\\(\\mathsf{a} \\neq\r\n(1)\\)</span>, <span class=\"math inline\">\\(V(\\mathsf{a})\\)</span>\r\ncontains at least an element. Contradiction. <span\r\nclass=\"math inline\">\\(\\square\\)</span> <a\r\nhref=\"https://en.wikipedia.org/wiki/Zorn%27s_lemma\">[See Zorn\r\nlemma]</a></p>\r\n</blockquote>\r\n<p>Therefore <span class=\"math inline\">\\(1\\)</span> can be represented\r\nby a finite sum of products of elements from <span\r\nclass=\"math inline\">\\(E\\)</span> and <span\r\nclass=\"math inline\">\\(A\\)</span>: <span class=\"math display\">\\[1 =\r\ng_{1}f_{1} + \\cdots + g_{n}f_{n}, \\quad g_{i}\\in A, f_{i} \\in E, 1 \\leq\r\ni \\leq n\\]</span> Take <span class=\"math inline\">\\(F= \\{f_{1}, \\cdots,\r\nf_{n}\\}\\)</span>, thereby <span class=\"math inline\">\\(V(F) =\r\n\\emptyset\\)</span>, which implies <span class=\"math inline\">\\(\\{X_{f};\r\n{f \\in F}\\}\\)</span> covers <span class=\"math inline\">\\(X\\)</span>.\r\n<span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"definition-nilradical-and-radical\">Definition [Nilradical and\r\nRadical]</h2>\r\n<p>The ideal <span class=\"math inline\">\\(\\mathfrak{R}\\)</span> of all\r\nnipotents in a commutative ring <span class=\"math inline\">\\(A\\)</span>\r\nwith unit <span class=\"math inline\">\\(1\\)</span> is the insection of all\r\nprime ideals of <span class=\"math inline\">\\(A\\)</span>, that is, <span\r\nclass=\"math display\">\\[\r\n\\mathfrak{R} = \\bigcap_{\\mathsf{p} \\text{ is a prime ideal of $A$}}\r\n\\mathsf{p}\r\n\\]</span></p>\r\n<p>Of course <span class=\"math inline\">\\(\\mathfrak{R}\\)</span> is an\r\nideal closed under addition and multiplicatio. We split the proof in two\r\nsteps:</p>\r\n<ol type=\"1\">\r\n<li><p>If <span class=\"math inline\">\\(\\mathsf{p}\\)</span> is a prime\r\nideal, then <span class=\"math inline\">\\(\\mathfrak{R}\\subseteq\r\n\\mathsf{p}\\)</span>. Since <span class=\"math inline\">\\(0 \\in\r\n\\mathsf{p}\\)</span>, and we know for any <span class=\"math inline\">\\(f\r\n\\in \\mathfrak{R}\\)</span>, there exist an integer <span\r\nclass=\"math inline\">\\(n&gt;0\\)</span> such that <span\r\nclass=\"math display\">\\[f^{n} \\in \\mathsf{p} \\Rightarrow \\cdots\r\n\\Rightarrow  f \\in \\mathsf{p}\\]</span></p></li>\r\n<li><p>If <span class=\"math inline\">\\(f\\)</span> in not nilpotent, then\r\nthere is a prime ideal <span class=\"math inline\">\\(\\mathsf{p} \\cap \\{f\\}\r\n= \\emptyset\\)</span>. Let <span class=\"math display\">\\[\\Sigma = \\left\\{\r\n\\mathsf{a} \\text{ is an ideal of $A$}: \\text{for any $n \\in\r\n\\mathbb{N}_{*}$, }f^{n} \\notin \\mathsf{a} \\right\\}\\]</span></p></li>\r\n</ol>\r\n<blockquote>\r\n<p>Since <span class=\"math inline\">\\((0) \\in \\Sigma\\)</span>. By Zorn\r\nlemma, <span class=\"math inline\">\\(\\Sigma\\)</span> contains maximal\r\nelement <span class=\"math inline\">\\(\\mathsf{p}\\)</span> with respect to\r\n<span class=\"math inline\">\\(\\subseteq\\)</span>-inclusion partial\r\nordering. This <span class=\"math inline\">\\(\\mathsf{p}\\)</span> is indeed\r\na prime ideal, because: For any <span class=\"math inline\">\\(x,y \\notin\r\n\\mathsf{p}\\)</span>, thanks to the maximal proporty of <span\r\nclass=\"math inline\">\\(\\mathsf{p}\\)</span> we have <span\r\nclass=\"math inline\">\\(\\mathsf{p} + (x)\\)</span>, <span\r\nclass=\"math inline\">\\(\\mathsf{p} + (y)\\)</span> <span\r\nclass=\"math inline\">\\(\\notin \\Sigma\\)</span>; however, <span\r\nclass=\"math display\">\\[\\begin{aligned}\r\nf^{m} \\in\\mathsf{p} + (x) &amp;, f^{n} \\in \\mathsf{p} +(y) \\Rightarrow\r\nf^{m+n} \\in \\mathsf{p} + (xy)\r\n\\end{aligned}\\]</span> implies <span class=\"math inline\">\\(\\mathsf{p} +\r\n(xy) \\notin \\Sigma\\)</span>; therefore <span class=\"math inline\">\\(xy\r\n\\notin \\mathsf{p}\\)</span>. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n</blockquote>\r\n<p>Denote <span class=\"math display\">\\[r(\\mathsf{a}): = \\{f\\in A:\r\n\\text{there exist integer } n &gt;0 \\text{ such that } f^{n} \\in\r\n\\mathsf{a}\\}\\]</span> which is the intersection of all prime ideals\r\ncontaining <span class=\"math inline\">\\(\\mathsf{a}\\)</span> by <a\r\nhref=\"https://en.wikipedia.org/wiki/Isomorphism_theorems\">correspondence\r\ntheorem</a>.</p>\r\n<h2 id=\"definition-irreducibility\">Definition [Irreducibility]</h2>\r\n<p>A topological space <span\r\nclass=\"math inline\">\\((X,\\mathscr{U})\\)</span> is said to be <a\r\nhref=\"\">irreducible</a> if <span class=\"math inline\">\\(X\\neq\r\n\\emptyset\\)</span> and <span class=\"math inline\">\\(X\\)</span> can't be\r\nunion of any two non-empty open sets <span class=\"math inline\">\\(X =\r\nX_{1} \\cup X_{2}\\)</span>, or equivalently, if <span\r\nclass=\"math inline\">\\(U_{1}, U_{2} \\neq \\emptyset\\)</span> are any two\r\nnon-empty open sets, then <span class=\"math inline\">\\(U_{1} \\cap U_{2}\r\n\\neq \\emptyset\\)</span>.</p>\r\n<p><strong>Remark:</strong> According to the definition, irreducibility\r\nif finer than connectness, because two open sets <span\r\nclass=\"math inline\">\\(X_{1},X_{2}\\)</span> can be intersected.</p>\r\n<h2 id=\"theorem-1irreducibility\">Theorem 1[Irreducibility]</h2>\r\n<p><span class=\"math inline\">\\(\\text{Spec}(A)\\)</span> is irreducible if\r\nand only if its nilradical <span\r\nclass=\"math inline\">\\(\\mathfrak{R}\\)</span> of <span\r\nclass=\"math inline\">\\(A\\)</span> is a prime ideal.</p>\r\n<p>For any two non-empty open sets <span class=\"math inline\">\\(\\cup_{f\r\n\\in F} X_{f}\\)</span> and <span class=\"math inline\">\\(\\cup_{g \\in G}\r\nX_{g}\\)</span> in <span class=\"math inline\">\\(X=\\text{Spec}(A)\\)</span>.\r\n<span class=\"math display\">\\[\r\n\\begin{aligned}\r\n        \\cup_{f \\in F} X_{f} \\neq \\emptyset &amp;\\Leftrightarrow \\cap_{f\r\n\\in E} V(f) \\neq X \\Leftrightarrow \\exists f_{0} \\notin \\mathfrak{R}\\\\\r\n        \\left(\\cup_{f \\in F} X_{f}\\right) \\cap \\left(\\cup_{g \\in G}\r\nX_{g}\\right) \\neq \\emptyset &amp;\\Leftrightarrow \\cup_{f \\in F, g\\in G}\r\n\\left(X_{fg}\\right) \\neq \\emptyset \\Leftrightarrow \\exists f_{0}\\in F,\r\ng_{0} \\in G, f_{0}g_{0} \\notin \\mathfrak{R}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><strong>Remark 1:</strong> Singletons <span\r\nclass=\"math inline\">\\(\\{x\\}, x\\in X\\)</span> are irreducible subspaces;\r\nthe closure of irreducible subspaces in <span\r\nclass=\"math inline\">\\(X\\)</span> are irreducible subspaces.</p>\r\n<p><strong>Remark 2:</strong> Each singleton <span\r\nclass=\"math inline\">\\(\\{x\\}, x\\in X\\)</span> contained in a maximal\r\nirreducible subspace of <span class=\"math inline\">\\(X\\)</span>, which is\r\ncalled <a\r\nhref=\"https://en.wikipedia.org/wiki/Irreducible_component\">irreducible\r\ncomponent</a>. The irrducible components cover <span\r\nclass=\"math inline\">\\(X\\)</span>.</p>\r\n<p><strong>Remark 3:</strong> In an irreducible Hausdorff space <span\r\nclass=\"math inline\">\\(X\\)</span>, the irrducible components of <span\r\nclass=\"math inline\">\\(X\\)</span> are singletons. However, the conected\r\ncomponents, for instance, Euclidean space, are itself.</p>\r\n<p>By taking quotient <span class=\"math inline\">\\(A/\\mathsf{p}\\)</span>\r\nand noting that there is a one-to-one correspondence <span\r\nclass=\"math inline\">\\(h:\\mathsf{a} \\mapsto \\mathsf{a}/\r\n\\mathsf{p}\\)</span> between <span\r\nclass=\"math inline\">\\(V(\\mathsf{p})\\)</span> and <span\r\nclass=\"math inline\">\\(\\text{Spec}(A/\\mathsf{p})\\)</span> that preserves\r\nprime ideals, there is a one-to-one correspondence between <span\r\nclass=\"math inline\">\\(r(\\mathsf{p}) = \\cap_{\\mathsf{p}_{x} \\in\r\nV(\\mathsf{p})} \\mathsf{p}_{x}\\)</span> and <span\r\nclass=\"math inline\">\\(\\mathfrak{R} (A/\\mathsf{p}) = \\cap_{x\\in\r\n\\text{Spec}(A/\\mathsf{p})} x\\)</span>, as is shown in the diagram</p>\r\n<p><span class=\"math display\">\\[\\begin{align}\r\n    \\require{AMScd}\r\n    \\begin{CD}\r\n        V(\\mathsf{p}) @&gt;&gt;h&gt; \\text{Spec} (A/\\mathsf{p})\\\\\r\n        @VV{\\tiny \\text{cap}}V @VV{\\tiny \\text{cap}}V\\\\\r\n        r(\\mathsf{p}) @&gt;&gt;h&gt; \\mathfrak{R} (A/\\mathsf{p})\r\n    \\end{CD}\r\n\\end{align}\\]</span></p>\r\n<p>According to above theorem and</p>\r\n<blockquote>\r\n<p>Non-zero ring <span class=\"math inline\">\\(A\\)</span> has minimal\r\nprime ideals with respect to set inclusion. By Zorn's lemma, it only\r\nsuffices to prove that the intersection <span\r\nclass=\"math inline\">\\(\\cap_{n}\\mathsf{p}_{n}\\)</span> of a\r\nnon-increasing sequence of prime ideals <span\r\nclass=\"math inline\">\\(\\cdots \\supseteq \\mathsf{p}_{n} \\supseteq\r\n\\mathsf{p}_{n+1}\\supseteq \\cdots\\)</span> is also a prime ideal. By\r\nconsidering <span class=\"math inline\">\\(x,y \\in A, xy \\in\r\n\\cap_{n}\\mathsf{p}_{n}\\)</span>, we have for each <span\r\nclass=\"math inline\">\\(n\\)</span>, either <span\r\nclass=\"math inline\">\\(x\\)</span> or <span\r\nclass=\"math inline\">\\(y\\)</span> belongs to <span\r\nclass=\"math inline\">\\(\\mathsf{p}_{n}\\)</span>. Then one of <span\r\nclass=\"math inline\">\\(x\\)</span> and <span\r\nclass=\"math inline\">\\(y\\)</span> occurs in <span\r\nclass=\"math inline\">\\(\\mathsf{p}_{n}\\)</span> for infinitely many times,\r\nsay, for example, <span class=\"math inline\">\\(x \\in\r\n\\cap_{n}\\mathsf{p}_{n}\\)</span>. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n</blockquote>\r\n<p>we only need to show that <span class=\"math inline\">\\(h\\)</span> is a\r\nhomeomorphism, which is indeed true since <span\r\nclass=\"math inline\">\\(h\\)</span> maps <span\r\nclass=\"math inline\">\\(V(\\mathsf{a}) \\cap V(\\mathsf{p}) = V(\\mathsf{a} +\r\n\\mathsf{p})\\)</span> to <span class=\"math inline\">\\(V((\\mathsf{a} +\r\n\\mathsf{p})/ \\mathsf{p})\\)</span> and vice versa, where <span\r\nclass=\"math inline\">\\(\\mathsf{a}\\)</span> is an ideal of <span\r\nclass=\"math inline\">\\(A\\)</span>. Similarily, the closed subspace <span\r\nclass=\"math inline\">\\(V(\\mathsf{p})\\)</span> of <span\r\nclass=\"math inline\">\\(\\text{Spec}(A)\\)</span> is irreducible if and only\r\nif <span class=\"math inline\">\\(r(\\mathsf{p})\\)</span> is a prime ideal,\r\nwhere <span class=\"math inline\">\\(\\mathsf{p}\\)</span> is an ideal of\r\n<span class=\"math inline\">\\(A\\)</span>. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"property-4-homomorphism\">Property 4 [Homomorphism]</h2>\r\n<p>Let <span class=\"math inline\">\\(\\phi: A \\to B\\)</span> be\r\nhomomorphism that preserves unit. <span\r\nclass=\"math inline\">\\(X=\\text{Spec}(A) , Y=\\text{Spec}(B)\\)</span>.\r\nSince <span class=\"math inline\">\\(\\phi^{-1}\\)</span> draws back prime\r\nideals in <span class=\"math inline\">\\(Y\\)</span> into prime ideals in\r\n<span class=\"math inline\">\\(X\\)</span>, <span\r\nclass=\"math inline\">\\(\\phi\\)</span> introduces naturally a mapping <span\r\nclass=\"math inline\">\\(\\phi^{*}: \\text{Spec}(B) \\to\r\n\\text{Spec}(A)\\)</span> by <span class=\"math inline\">\\(\\mathsf{q}\r\n\\mapsto \\phi^{-1} (\\mathsf{q})\\)</span></p>\r\n<ol type=\"1\">\r\n<li><p>It is easy to verify that <span\r\nclass=\"math inline\">\\((\\phi^{*})^{-1}(X_{f}) =Y_{\\phi(f)}\\)</span>,\r\nwhich implies <span class=\"math inline\">\\(\\phi^{*}\\)</span> is\r\ncontinuous.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(\\phi\\)</span> is surjective, then\r\n<span class=\"math inline\">\\(\\phi^{*}\\)</span> is injective. By <a\r\nhref=\"https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms\">Fundamental\r\ntheorem on homomorphisms</a>, <span class=\"math inline\">\\(A/\\ker(\\phi)\r\n\\cong B\\)</span>. Note in above we mention that <span\r\nclass=\"math inline\">\\(\\phi\\)</span> is a homeomorphism mappping, thereby\r\n<span class=\"math inline\">\\(\\phi^{*}\\)</span> establish a homeomorphism\r\nbetween <span class=\"math inline\">\\(Y=\\text{Spec}(B)\\)</span> and <span\r\nclass=\"math inline\">\\(V\\left(\\ker(\\phi)\\right)\\)</span>.</p></li>\r\n<li><p><span class=\"math inline\">\\(\\overline{\\phi^{*}(V(\\mathsf{b}))} =\r\nV(\\phi^{*}(\\mathsf{b}))\\)</span>. Hence if <span\r\nclass=\"math inline\">\\(\\phi\\)</span> is injective, then <span\r\nclass=\"math inline\">\\(\\phi^{*}(Y)\\)</span> is dense in <span\r\nclass=\"math inline\">\\(X\\)</span>. Let <span\r\nclass=\"math inline\">\\(\\mathsf{q} \\in V(\\mathsf{b})\\)</span> and note\r\nthat $^{*}() = ^{-1}() ^{-1}() $, so <span\r\nclass=\"math inline\">\\(\\phi^{-1}(\\mathsf{q}) \\in\r\nV(\\phi^{*}(\\mathsf{b}))\\)</span> and <span\r\nclass=\"math inline\">\\(\\mathsf{q} \\in\r\n\\phi(V(\\phi^{*}(\\mathsf{b})))\\)</span>. Thus <span\r\nclass=\"math inline\">\\(V(\\mathsf{b}) \\subseteq\r\n\\phi(V(\\phi^{*}(\\mathsf{b})))\\)</span>. Then note that <span\r\nclass=\"math display\">\\[y \\in \\overline{\\{x\\}} \\Leftrightarrow\r\n\\overline{\\{y\\}} \\subseteq \\overline{\\{x\\}} \\Leftrightarrow\r\nV(\\mathsf{p}_{y}) \\subseteq V(\\mathsf{p}_{x}) \\Leftrightarrow\r\n\\mathsf{p}_{x} \\subseteq \\mathsf{p}_{y}\\]</span> which says <span\r\nclass=\"math inline\">\\(\\overline{\\{x\\}} =\r\nV\\left(\\mathsf{p}(={x})\\right)\\)</span>; <span\r\nclass=\"math inline\">\\(V(\\mathsf{b})\\)</span> is obviously the minimal\r\nclosed set in <span class=\"math inline\">\\(X\\)</span> which contains\r\n<span class=\"math inline\">\\(\\phi^{*}(V(\\mathsf{b}))\\)</span> since <span\r\nclass=\"math inline\">\\(\\phi^{*}(\\mathsf{b}) \\in\r\n\\phi^{*}(V(\\mathsf{b}))\\)</span>.</p></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\begin{align}\r\n    \\require{AMScd}\r\n    \\begin{CD}\r\n        X @&lt;&lt;{\\phi^*}&lt; Y\\\\\r\n        @AA{\\tiny \\text{$\\cup$}}A  @AA{\\tiny \\text{$\\cup$}}A\\\\\r\n        V_A(\\phi^* (\\mathsf{b})) @&lt;&lt;{\\phi^*}&lt; V_B(\\mathsf{b})\\\\\r\n        @AA{\\text{$*$}}A  @AA{\\text{$*$}}A\\\\\r\n        \\text{Spec}(A/\\phi^* (\\mathsf{b})) @&lt;&lt;{\\tilde\\phi^*}&lt;\r\n\\text{Spec} (B/\\mathsf{b})\r\n    \\end{CD}\r\n\\end{align}\\]</span></p>\r\n<p><strong>Example:</strong> Let <span class=\"math inline\">\\(A\\)</span>\r\nbe an integral domain with just one non-zero prime ideal <span\r\nclass=\"math inline\">\\(\\mathsf{p}\\)</span>. and let <span\r\nclass=\"math inline\">\\(K\\)</span> be the field of fractions of <span\r\nclass=\"math inline\">\\(A\\)</span>. Let <span\r\nclass=\"math inline\">\\(B=(A/\\mathsf{p}) \\times K\\)</span>. Define <span\r\nclass=\"math inline\">\\(\\phi: A \\to B\\)</span> by <span\r\nclass=\"math inline\">\\(\\phi(x) = (\\bar{x}, x)\\)</span>, where <span\r\nclass=\"math inline\">\\(\\bar{x}\\)</span> is the image of <span\r\nclass=\"math inline\">\\(x\\)</span> in <span\r\nclass=\"math inline\">\\(A/\\mathsf{p}\\)</span>. <span\r\nclass=\"math inline\">\\(\\phi^{*}\\)</span> is bijective but not a\r\nhomeomorphism: Since <span class=\"math inline\">\\(A/\\mathsf{p}\\)</span>\r\nis also a field, hence <span class=\"math inline\">\\(B = (A/\\mathsf{p})\r\n\\times K\\)</span> has only two prime ideals <span\r\nclass=\"math display\">\\[\\left\\{(1)\\times(0), (0)\r\n\\times(1)\\right\\}\\]</span> Direct computation yields <span\r\nclass=\"math inline\">\\(\\phi^{*}\\)</span> is a bijection. However, <span\r\nclass=\"math inline\">\\(\\{(1) \\times (0)\\}\\)</span> is a closed set of\r\n<span class=\"math inline\">\\(\\text{Spec}(B)\\)</span> whereas <span\r\nclass=\"math inline\">\\(\\{(0)\\}\\)</span> is not closed in <span\r\nclass=\"math inline\">\\(\\text{Spec}(A)\\)</span>.</p>\r\n<h2 id=\"more-on-separation-axiom-t_1-t_2\">More on Separation Axiom\r\n[<span class=\"math inline\">\\(T_{1}\\)</span>, <span\r\nclass=\"math inline\">\\(T_{2}\\)</span>]</h2>\r\n<p>We define <span class=\"math display\">\\[\\mathscr{V}^{\\prime} = \\left\\{\r\n\\phi^{*}\\left(\\text{Spec}(B)\\right): \\text{ where $\\phi:A \\to B$ is ring\r\nhomomorphism} \\right\\}\\]</span> It can be verified that <span\r\nclass=\"math inline\">\\(\\mathscr{V}^{\\prime}\\)</span> satisfies axiom of\r\nclosed set. The topology in <span\r\nclass=\"math inline\">\\(\\text{Spec}(A)\\)</span> is called <a\r\nhref=\"https://en.wikipedia.org/wiki/Constructible_topology\">constructable\r\ntopology</a>. which is finer than Zariski topology.</p>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(A/\\mathfrak{R}\\)</span> is <a\r\nhref=\"\">absolutely flat</a> (<span\r\nclass=\"math inline\">\\(\\mathfrak{R}\\)</span> being the nilradical of\r\n<span class=\"math inline\">\\(A\\)</span>).</li>\r\n<li>Every prime ideal of <span class=\"math inline\">\\(A\\)</span> is\r\nmaximal.</li>\r\n<li><span class=\"math inline\">\\(\\text{Spec} (A)\\)</span> is a <span\r\nclass=\"math inline\">\\(T_{1}\\)</span>-space (i.e., every subset\r\nconsisting of a single point is closed).</li>\r\n<li><span class=\"math inline\">\\(\\text{Spec} (A)\\)</span> is\r\nHausdorff.</li>\r\n<li>The Zariski topology and the constructible topology on <span\r\nclass=\"math inline\">\\(\\text{Spec} (A)\\)</span> coincide</li>\r\n</ol>\r\n<h2 id=\"proporsition-5-connectedness\">Proporsition 5\r\n[Connectedness]</h2>\r\n<p>If a commutative ring <span class=\"math inline\">\\(A\\)</span> with\r\nunit can be represented as direct product of non-zero ring, <span\r\nclass=\"math inline\">\\(A_{i}, i=1, 2, \\cdots, n\\)</span>, By a standard\r\nresult in commutative ring, the ideals <span\r\nclass=\"math inline\">\\(A=\\prod_{i=1}^{n}A_{i}\\)</span> has the form</p>\r\n<p><span class=\"math display\">\\[\\mathsf{a}_{1} \\times \\cdots \\times\r\n\\mathsf{a}_{i} \\times \\cdots \\times \\mathsf{a}_{n}, \\text{ where\r\n$\\mathsf{a}_{i}$ are ideals of $A_{i}$} \\]</span><br />\r\nEspecially, prime ideals in <span class=\"math inline\">\\(A\\)</span> has\r\nthe form</p>\r\n<p><span class=\"math display\">\\[(1) \\times \\cdots \\times \\mathsf{p}_{i}\r\n\\times \\cdots \\times (1), \\text{ where $\\mathsf{p}_{i}$ are prime ideals\r\nof $A_{i}$}\\]</span></p>\r\n<p>For ring <span class=\"math inline\">\\(A=\\prod_{i=1}^{n}A_{i}\\)</span>,\r\nthe spectrum <span class=\"math inline\">\\(X = \\text{Spec}(A)\\)</span> is\r\nthe disjoint union of <span class=\"math inline\">\\(X_{i}, i\r\n=1,2,\\cdots,n\\)</span>, where <span class=\"math inline\">\\(X_{i}\\)</span>\r\nconsists of prime ideals containing <span class=\"math inline\">\\((1)\r\n\\times \\cdots \\times \\underset{i}{(0)} \\times \\cdots \\times\r\n(1)\\)</span>, homeomorphic to <span\r\nclass=\"math inline\">\\(\\text{Spec}(A_{i})\\)</span>. Hence <span\r\nclass=\"math inline\">\\(X=\\text{Spec}(A)\\)</span> is not connected. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<p>Conversly, if the subsets <span class=\"math inline\">\\(X_{1}, X_{2}\r\n\\neq \\emptyset, X_{1} \\cap X_{2} = \\emptyset\\)</span> of <span\r\nclass=\"math inline\">\\(X=\\text{Spec}(A)\\)</span> satisfies <span\r\nclass=\"math inline\">\\(X_{1} \\cup X_{2} = X\\)</span>. According to the\r\ndefinition of spectrum, we have <span class=\"math inline\">\\(X_{1}\r\n=V(\\mathsf{a}_{1}), X_{2} =V(\\mathsf{a}_{2}),\\)</span> where <span\r\nclass=\"math inline\">\\(\\mathsf{a}_{1},\\mathsf{a}_{2}\\)</span> are ideals\r\nof ring <span class=\"math inline\">\\(A\\)</span>, and <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\nV(\\mathsf{a}_{1}) \\cap V(\\mathsf{a}_{2}) = V(\\mathsf{a}_{1}\r\n+\\mathsf{a}_{2}) =\\emptyset &amp;\\Rightarrow\r\n\\mathsf{a}_{1} +\\mathsf{a}_{2} = (1)\\\\\r\nV(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2}) = V(\\mathsf{a}_{1} \\cap\r\n\\mathsf{a}_{2}) = X &amp;\\Rightarrow\r\n\\mathsf{a}_{1} \\cap \\mathsf{a}_{2} \\subseteq \\mathfrak{R}\r\n\\end{aligned}\r\n\\]</span> there exist <span class=\"math inline\">\\(x_{1} \\in\r\n\\mathsf{a}_{1}, x_{2} \\in \\mathsf{a}_{2}\\)</span>, and integer <span\r\nclass=\"math inline\">\\(n&gt;0\\)</span> such that <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\nx_{1} + x_{2} &amp;=1\\\\\r\n(x_{1} x_{2})^{n} &amp;=0\r\n\\end{aligned}\r\n\\]</span> Due to elementary arithmetic it finds that <span\r\nclass=\"math display\">\\[r(x_{1}^{n}) + r(x_{2}^{n}) =1 \\Rightarrow\r\n(x_{1}^{n}) + (x_{2}^{n}) =1 \\]</span>. Therefore we can find an\r\nidempotent <span class=\"math inline\">\\(e\\neq 0,1 \\in\r\n(x_{1}^{n})\\)</span> such that <span class=\"math inline\">\\(1 - e \\in\r\n(x_{2}^{n})\\)</span>, and <span class=\"math inline\">\\(e(1 - e) =\r\n0\\)</span>, because the non-empty assumption of <span\r\nclass=\"math inline\">\\(X_{i}, i=1,2\\)</span>. Thereby <span\r\nclass=\"math inline\">\\(A\\)</span> can be decomposed as the direct product\r\nof <span class=\"math inline\">\\(eA\\)</span> and <span\r\nclass=\"math inline\">\\((1-e) A\\)</span>. $ $</p>\r\n<p>We summarize the result below:</p>\r\n<p>Let <span class=\"math inline\">\\(A\\)</span> be any commutative ring\r\nwith unit. The following statements are equivalent:</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(X = \\text{Spec} (A)\\)</span> is\r\ndisconnected.</p></li>\r\n<li><p><span class=\"math inline\">\\(A \\cong A_{1} \\times A_{2}\\)</span>\r\nwhere neither of the rings <span class=\"math inline\">\\(A_{1}\\)</span> or\r\n<span class=\"math inline\">\\(A_{2}\\)</span> is the zero ring.</p></li>\r\n<li><p><span class=\"math inline\">\\(A\\)</span> contains an idempotent\r\n<span class=\"math inline\">\\(\\neq 0,1\\)</span>.</p></li>\r\n</ol>\r\n<p><strong>Remark:</strong> Local ring, that is, ring with only one\r\nmaximal ideal, is always connected.</p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Michael Atiyah. Introduction to commutative algebra. CRC Press,\r\n2018.</p>\r\n<p>[2] Suzanne C Dieudonne. History Algebraic Geometry. CRC Press,\r\n1985.</p>\r\n<p>[3] Bartel L Van der Waerden. A history of algebra: From al-Khwrizm\r\nto Emmy Noether. Springer Science &amp; Business Media, 2013.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"definition\">Definition</h2>\r\n<p>Let <span class=\"math inline\">\\(A\\)</span> be commutative ring with\r\nunit. <span class=\"math inline\">\\(\\text{Spec}(A)\\)</span> is the\r\ncollection of prime ideals of <span\r\nclass=\"math inline\">\\(A\\)</span>.</p>\r\n<p><span class=\"math inline\">\\(V(E)\\)</span> is the collection of prime\r\nideals containing <span class=\"math inline\">\\(E \\subseteq A\\)</span>.\r\n<span class=\"math inline\">\\(\\{V(E); E \\subseteq A\\}\\)</span> is a\r\ncollection of closed subsets of <span class=\"math inline\">\\(\\text{Spec}\r\n(A)\\)</span>, since</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(V(1)=\\emptyset, V(0) =X\\)</span>.\r\nHence <a href=\"https://en.wikipedia.org/wiki/Closed_set\">Axiom of Closed\r\nSet I</a> is satisfied.</p></li>\r\n<li><p><span class=\"math inline\">\\(\\cap_{i \\in I} V(E_{i}) =V(\\cup_{i\r\n\\in I} E_{i})\\)</span>. Hence <a\r\nhref=\"https://en.wikipedia.org/wiki/Closed_set\">Axiom of Closed Set\r\nII</a> is satisfied.</p></li>\r\n<li><p>To verify axiom III, Consider the ideal <span\r\nclass=\"math inline\">\\(\\mathsf{a}_{1}\\)</span> generated by <span\r\nclass=\"math inline\">\\(E_{1}\\)</span> and the ideal <span\r\nclass=\"math inline\">\\(\\mathsf{a}_{2}\\)</span> generated by <span\r\nclass=\"math inline\">\\(E_{2}\\)</span>. Note that <span\r\nclass=\"math inline\">\\(V(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2}) \\subseteq\r\nV(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2})\\)</span>. Then, for any prime\r\nideal <span class=\"math inline\">\\(\\mathsf{p}\\)</span> containing <span\r\nclass=\"math inline\">\\(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}\\)</span>, we\r\nhave <span class=\"math inline\">\\(\\mathsf{a}_{1} \\subseteq\r\n\\mathsf{p}\\)</span> or <span class=\"math inline\">\\(\\mathsf{a}_{2}\r\n\\subseteq \\mathsf{p}\\)</span>, since</p></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[ x_{1},x_{2} \\notin \\mathsf{p}\r\n\\Rightarrow x_{1}x_{2} \\notin \\mathsf{p} \\text{ while }\\,\\, x_{1}\\in\r\n\\mathsf{a}_{1}, x_{2}\\in \\mathsf{a}_{2} \\Rightarrow x_{1}x_{2} \\in\r\n\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}\\]</span></p>\r\n<p>This proves <span class=\"math inline\">\\(V(\\mathsf{a}_{1} \\cap\r\n\\mathsf{a}_{2}) \\subseteq V(\\mathsf{a}_{1}) \\cup\r\nV(\\mathsf{a}_{2})\\)</span>. Therefore, these sets equal to each other\r\n<span class=\"math inline\">\\(V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}) =\r\nV(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2})\\)</span>, which verifies <a\r\nhref=\"https://en.wikipedia.org/wiki/Closed_set\">Axiom of Closed Set\r\nIII</a>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"proporsition-1-topological-basis\">Proporsition 1 [Topological\r\nbasis]</h2>\r\n<p>Given an element <span class=\"math inline\">\\(f\\)</span> in <span\r\nclass=\"math inline\">\\(A\\)</span>, we define <span\r\nclass=\"math inline\">\\(X_{f}\\)</span> to be the complement of <span\r\nclass=\"math inline\">\\(V(f)\\)</span> in <span\r\nclass=\"math inline\">\\(X=\\text{Spec}(A)\\)</span>, so <span\r\nclass=\"math display\">\\[ \\mathscr{U}^{\\prime} = \\{X_{f}; f\\in\r\nA\\}\\]</span></p>\r\n<p>is a <a\r\nhref=\"https://en.wikipedia.org/wiki/Base_(topology)\">topological\r\nbasis</a> for <span class=\"math display\">\\[\\mathscr{U} = \\{ X\\backslash\r\nV(E); E \\subseteq A\\}\\]</span></p>\r\n<p>To see more clearly, Choose an open set <span class=\"math inline\">\\(O\r\n\\in \\mathscr{U}\\)</span>, it must be the complement of a closed set\r\n<span class=\"math inline\">\\(V(E)\\)</span> generated by some subset <span\r\nclass=\"math inline\">\\(E\\)</span> of ring <span\r\nclass=\"math inline\">\\(A\\)</span>, that is, <span class=\"math inline\">\\(O\r\n= X\\backslash V(E)\\)</span>. Decompose <span\r\nclass=\"math inline\">\\(E\\)</span> into the union of its components <span\r\nclass=\"math inline\">\\(\\left\\{f\\right\\}\\)</span> we have <span\r\nclass=\"math inline\">\\(E = \\cup_{f\\in E}\\{f\\}\\)</span>, by utilize axiom\r\nof closed set III</p>\r\n<p><span class=\"math display\">\\[\r\n    O =X\\backslash \\left(\\cap_{f \\in E} V(f)\\right) = \\cup_{f\\in E}\r\n\\left(X \\backslash V(f)\\right) =\\cup_{f\\in E} X_{f}\r\n\\]</span></p>\r\n<p>That is to say <span\r\nclass=\"math inline\">\\(\\mathscr{U}^{\\prime}\\)</span> is a topological\r\nbasis for <span class=\"math inline\">\\(\\mathscr{U}\\)</span>. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<p><br></p>\r\n<h2 id=\"proporsition-1-countability-axiom-not-c_1\">Proporsition 1\r\n[Countability Axiom, not <span\r\nclass=\"math inline\">\\(C_{1}\\)</span>]</h2>\r\n<h2 id=\"example\">Example</h2>\r\n<p>Let <span class=\"math inline\">\\(A\\)</span> be <a\r\nhref=\"https://en.wikipedia.org/wiki/Unique_factorization_domain\">UFD</a>.\r\n<span class=\"math inline\">\\(I\\)</span> is an index set, <span\r\nclass=\"math inline\">\\(|I| \\geq \\aleph_{1}\\)</span>. For each index <span\r\nclass=\"math inline\">\\(i\\in I\\)</span> associate with a variable <span\r\nclass=\"math inline\">\\(x_{i}\\)</span>, Consider polynomial ring with\r\ncoeffiecients in <span class=\"math inline\">\\(A\\)</span> <span\r\nclass=\"math display\">\\[ A[I] := \\{\\sum a_{i_{1},i_{2},\\cdots,i_{k}}\r\nx_{i_{i}}^{n_{1}}x_{i_{2}}^{n_{2}} \\cdots x_{i_{k}}^{n_{k}} :\r\na_{i_{1},i_{2},\\cdots,i_{k}}\\in A \\}\\]</span> . Since <span\r\nclass=\"math inline\">\\(A[I]\\)</span> in integral domain, <span\r\nclass=\"math inline\">\\((0)\\)</span> is a prime ideal. The Zariski\r\ntopological basis <span class=\"math inline\">\\(\\{X_{f}; {f \\in\r\nA(I)}\\}\\)</span> for ring <span class=\"math inline\">\\(A(I)\\)</span> with\r\nemptyset exception, that is <span class=\"math inline\">\\(f\\neq\r\n0\\)</span>, is a neighborhood basis at <span\r\nclass=\"math inline\">\\((0)\\)</span> for <span\r\nclass=\"math inline\">\\(\\text{Spec}(A[I])\\)</span> . Since <span\r\nclass=\"math inline\">\\(A[I]\\)</span> is either UFD, <span\r\nclass=\"math inline\">\\(A[I]\\)</span> contains uncoutable many prime idels\r\n<span class=\"math inline\">\\((x_{i}), {i \\in I}\\)</span>, which implies\r\n<span class=\"math inline\">\\(A[I]\\)</span> dose not satisfies <a\r\nhref=\"https://en.wikipedia.org/wiki/First-countable_space\">first-countable\r\naxiom <span class=\"math inline\">\\(C_{1}\\)</span></a>.</p>\r\n<p>For topological space, we are also interested in its separation,\r\ncompactness and connectedness etc.</p>\r\n<h2 id=\"proporsition-2-separation-axiom-t_0\">Proporsition 2 [Separation\r\nAxiom <span class=\"math inline\">\\(T_{0}\\)</span>]</h2>\r\n<p>A topological space <span\r\nclass=\"math inline\">\\((X,\\mathscr{U})\\)</span> satisfies <a\r\nhref=\"https://en.wikipedia.org/wiki/Kolmogorov_space\">separtion axiom\r\n<span class=\"math inline\">\\(T_{0}\\)</span></a> separation, if for any\r\n<span class=\"math inline\">\\(x,y \\in X\\)</span>, <span\r\nclass=\"math inline\">\\(x\\neq y\\)</span>, there exists open set <span\r\nclass=\"math inline\">\\(U \\in \\mathscr{U}\\)</span>, such that <span\r\nclass=\"math inline\">\\(x\\in U, y \\notin U\\)</span> of if <span\r\nclass=\"math inline\">\\(y \\in U, x \\notin U\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(x,y\\)</span> be distinct two points\r\nin <span class=\"math inline\">\\(X=\\text{Spec}(A)\\)</span>, i.e. two\r\ndistinct prime ideals <span\r\nclass=\"math inline\">\\(\\mathsf{p}_{x},\\mathsf{p}_{y}\\)</span> of ring\r\n<span class=\"math inline\">\\(A\\)</span>:</p>\r\n<ol type=\"1\">\r\n<li><p>If <span class=\"math inline\">\\(\\mathsf{p}_{x} \\subseteq\r\n\\mathsf{p}_{y}\\)</span>, then <span\r\nclass=\"math inline\">\\(V(\\mathsf{p}_{y}) \\subseteq\r\nV(\\mathsf{p}_{x})\\)</span>. Taking <span class=\"math inline\">\\(U= X\r\n\\backslash V(\\mathsf{p}_{y})\\)</span> we have <span\r\nclass=\"math inline\">\\(x\\in U, y \\notin U\\)</span>.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(\\mathsf{p}_{x} \\subsetneq\r\n\\mathsf{p}_{y}\\)</span>, thereby <span\r\nclass=\"math inline\">\\(\\mathsf{p}_{y} \\notin V(\\mathsf{p}_{x})\\)</span>.\r\nTaking <span class=\"math inline\">\\(U = X \\backslash\r\nV(\\mathsf{p}_{x})\\)</span> we have <span class=\"math inline\">\\(y \\in U,\r\nx \\notin U\\)</span>.</p></li>\r\n</ol>\r\n<p>This together impies that <span\r\nclass=\"math inline\">\\(X=\\text{Spec}(A)\\)</span> satisfies separation\r\naxiom <span class=\"math inline\">\\(T_{0}\\)</span>. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"propersition-3-compactness\">Propersition 3 [Compactness]</h2>\r\n<p>We next prove <span class=\"math inline\">\\(X = \\text{Spec}\r\n(A)\\)</span> is (compact)[]. It only suffices to consider covering from\r\ntopological basis <span class=\"math inline\">\\(\\{X_{f}; {f\\in\r\nE}\\}\\)</span>, where <span class=\"math inline\">\\(E\\neq\r\n\\emptyset\\)</span> is a subset of ring <span\r\nclass=\"math inline\">\\(A\\)</span>. Accrording to (De Morgan law)[] and\r\naxiom of closed set III, nota that <span class=\"math display\">\\[\r\nX \\backslash \\left(\\cup_{f\\in E} X_{f}\\right) = \\cap_{f\\in E} \\left(X\r\n\\backslash X_{f} \\right) = V (\\cup_{f\\in E}  \\{f\\})\r\n\\]</span> hence <span class=\"math inline\">\\(\\cup_{f\\in E} X_{f} = X\r\n\\Leftrightarrow V(E) =\\emptyset\\)</span>. Let the ideal generated by\r\n<span class=\"math inline\">\\(E\\)</span> be <span\r\nclass=\"math inline\">\\(\\mathsf{a}\\)</span>, we show that $= (1) $:</p>\r\n<blockquote>\r\n<p>Let <span class=\"math inline\">\\(\\Sigma\\)</span> consist of\r\nnon-trivial ideals of <span class=\"math inline\">\\(A\\)</span>. Since the\r\nnon-decreasing chain of ideals are also an ideal, by Zorn lemma, if\r\n<span class=\"math inline\">\\(\\Sigma \\neq \\emptyset\\)</span>, <span\r\nclass=\"math inline\">\\(\\Sigma\\)</span> contains a maximal element <span\r\nclass=\"math inline\">\\(\\mathsf{a}_{0}\\)</span> with respect to <span\r\nclass=\"math inline\">\\(\\subseteq\\)</span>-partial ordering; it is indeed\r\nan maximal ideal. (Otherwise, if there exist another <span\r\nclass=\"math inline\">\\(\\mathsf{a}_{0}^{\\prime}\\)</span> such that <span\r\nclass=\"math inline\">\\(\\mathsf{a}_{0} \\subseteq\r\n\\mathsf{a}_{0}^{\\prime}\\)</span>, <span\r\nclass=\"math inline\">\\(\\mathsf{a}_{0}^{\\prime} = \\mathsf{a}_{0} \\cup\r\n\\mathsf{a}_{0}^{\\prime}\\)</span> is maximal with respect to inclusion\r\nrelation.) It also can be proved that if <span\r\nclass=\"math inline\">\\(\\mathsf{a} \\neq (1)\\)</span>, <span\r\nclass=\"math inline\">\\(\\mathsf{a}\\)</span> is contained in a maximal\r\nideal. Hence if <span class=\"math inline\">\\(\\mathsf{a} \\neq\r\n(1)\\)</span>, <span class=\"math inline\">\\(V(\\mathsf{a})\\)</span>\r\ncontains at least an element. Contradiction. <span\r\nclass=\"math inline\">\\(\\square\\)</span> <a\r\nhref=\"https://en.wikipedia.org/wiki/Zorn%27s_lemma\">[See Zorn\r\nlemma]</a></p>\r\n</blockquote>\r\n<p>Therefore <span class=\"math inline\">\\(1\\)</span> can be represented\r\nby a finite sum of products of elements from <span\r\nclass=\"math inline\">\\(E\\)</span> and <span\r\nclass=\"math inline\">\\(A\\)</span>: <span class=\"math display\">\\[1 =\r\ng_{1}f_{1} + \\cdots + g_{n}f_{n}, \\quad g_{i}\\in A, f_{i} \\in E, 1 \\leq\r\ni \\leq n\\]</span> Take <span class=\"math inline\">\\(F= \\{f_{1}, \\cdots,\r\nf_{n}\\}\\)</span>, thereby <span class=\"math inline\">\\(V(F) =\r\n\\emptyset\\)</span>, which implies <span class=\"math inline\">\\(\\{X_{f};\r\n{f \\in F}\\}\\)</span> covers <span class=\"math inline\">\\(X\\)</span>.\r\n<span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"definition-nilradical-and-radical\">Definition [Nilradical and\r\nRadical]</h2>\r\n<p>The ideal <span class=\"math inline\">\\(\\mathfrak{R}\\)</span> of all\r\nnipotents in a commutative ring <span class=\"math inline\">\\(A\\)</span>\r\nwith unit <span class=\"math inline\">\\(1\\)</span> is the insection of all\r\nprime ideals of <span class=\"math inline\">\\(A\\)</span>, that is, <span\r\nclass=\"math display\">\\[\r\n\\mathfrak{R} = \\bigcap_{\\mathsf{p} \\text{ is a prime ideal of $A$}}\r\n\\mathsf{p}\r\n\\]</span></p>\r\n<p>Of course <span class=\"math inline\">\\(\\mathfrak{R}\\)</span> is an\r\nideal closed under addition and multiplicatio. We split the proof in two\r\nsteps:</p>\r\n<ol type=\"1\">\r\n<li><p>If <span class=\"math inline\">\\(\\mathsf{p}\\)</span> is a prime\r\nideal, then <span class=\"math inline\">\\(\\mathfrak{R}\\subseteq\r\n\\mathsf{p}\\)</span>. Since <span class=\"math inline\">\\(0 \\in\r\n\\mathsf{p}\\)</span>, and we know for any <span class=\"math inline\">\\(f\r\n\\in \\mathfrak{R}\\)</span>, there exist an integer <span\r\nclass=\"math inline\">\\(n&gt;0\\)</span> such that <span\r\nclass=\"math display\">\\[f^{n} \\in \\mathsf{p} \\Rightarrow \\cdots\r\n\\Rightarrow  f \\in \\mathsf{p}\\]</span></p></li>\r\n<li><p>If <span class=\"math inline\">\\(f\\)</span> in not nilpotent, then\r\nthere is a prime ideal <span class=\"math inline\">\\(\\mathsf{p} \\cap \\{f\\}\r\n= \\emptyset\\)</span>. Let <span class=\"math display\">\\[\\Sigma = \\left\\{\r\n\\mathsf{a} \\text{ is an ideal of $A$}: \\text{for any $n \\in\r\n\\mathbb{N}_{*}$, }f^{n} \\notin \\mathsf{a} \\right\\}\\]</span></p></li>\r\n</ol>\r\n<blockquote>\r\n<p>Since <span class=\"math inline\">\\((0) \\in \\Sigma\\)</span>. By Zorn\r\nlemma, <span class=\"math inline\">\\(\\Sigma\\)</span> contains maximal\r\nelement <span class=\"math inline\">\\(\\mathsf{p}\\)</span> with respect to\r\n<span class=\"math inline\">\\(\\subseteq\\)</span>-inclusion partial\r\nordering. This <span class=\"math inline\">\\(\\mathsf{p}\\)</span> is indeed\r\na prime ideal, because: For any <span class=\"math inline\">\\(x,y \\notin\r\n\\mathsf{p}\\)</span>, thanks to the maximal proporty of <span\r\nclass=\"math inline\">\\(\\mathsf{p}\\)</span> we have <span\r\nclass=\"math inline\">\\(\\mathsf{p} + (x)\\)</span>, <span\r\nclass=\"math inline\">\\(\\mathsf{p} + (y)\\)</span> <span\r\nclass=\"math inline\">\\(\\notin \\Sigma\\)</span>; however, <span\r\nclass=\"math display\">\\[\\begin{aligned}\r\nf^{m} \\in\\mathsf{p} + (x) &amp;, f^{n} \\in \\mathsf{p} +(y) \\Rightarrow\r\nf^{m+n} \\in \\mathsf{p} + (xy)\r\n\\end{aligned}\\]</span> implies <span class=\"math inline\">\\(\\mathsf{p} +\r\n(xy) \\notin \\Sigma\\)</span>; therefore <span class=\"math inline\">\\(xy\r\n\\notin \\mathsf{p}\\)</span>. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n</blockquote>\r\n<p>Denote <span class=\"math display\">\\[r(\\mathsf{a}): = \\{f\\in A:\r\n\\text{there exist integer } n &gt;0 \\text{ such that } f^{n} \\in\r\n\\mathsf{a}\\}\\]</span> which is the intersection of all prime ideals\r\ncontaining <span class=\"math inline\">\\(\\mathsf{a}\\)</span> by <a\r\nhref=\"https://en.wikipedia.org/wiki/Isomorphism_theorems\">correspondence\r\ntheorem</a>.</p>\r\n<h2 id=\"definition-irreducibility\">Definition [Irreducibility]</h2>\r\n<p>A topological space <span\r\nclass=\"math inline\">\\((X,\\mathscr{U})\\)</span> is said to be <a\r\nhref=\"\">irreducible</a> if <span class=\"math inline\">\\(X\\neq\r\n\\emptyset\\)</span> and <span class=\"math inline\">\\(X\\)</span> can't be\r\nunion of any two non-empty open sets <span class=\"math inline\">\\(X =\r\nX_{1} \\cup X_{2}\\)</span>, or equivalently, if <span\r\nclass=\"math inline\">\\(U_{1}, U_{2} \\neq \\emptyset\\)</span> are any two\r\nnon-empty open sets, then <span class=\"math inline\">\\(U_{1} \\cap U_{2}\r\n\\neq \\emptyset\\)</span>.</p>\r\n<p><strong>Remark:</strong> According to the definition, irreducibility\r\nif finer than connectness, because two open sets <span\r\nclass=\"math inline\">\\(X_{1},X_{2}\\)</span> can be intersected.</p>\r\n<h2 id=\"theorem-1irreducibility\">Theorem 1[Irreducibility]</h2>\r\n<p><span class=\"math inline\">\\(\\text{Spec}(A)\\)</span> is irreducible if\r\nand only if its nilradical <span\r\nclass=\"math inline\">\\(\\mathfrak{R}\\)</span> of <span\r\nclass=\"math inline\">\\(A\\)</span> is a prime ideal.</p>\r\n<p>For any two non-empty open sets <span class=\"math inline\">\\(\\cup_{f\r\n\\in F} X_{f}\\)</span> and <span class=\"math inline\">\\(\\cup_{g \\in G}\r\nX_{g}\\)</span> in <span class=\"math inline\">\\(X=\\text{Spec}(A)\\)</span>.\r\n<span class=\"math display\">\\[\r\n\\begin{aligned}\r\n        \\cup_{f \\in F} X_{f} \\neq \\emptyset &amp;\\Leftrightarrow \\cap_{f\r\n\\in E} V(f) \\neq X \\Leftrightarrow \\exists f_{0} \\notin \\mathfrak{R}\\\\\r\n        \\left(\\cup_{f \\in F} X_{f}\\right) \\cap \\left(\\cup_{g \\in G}\r\nX_{g}\\right) \\neq \\emptyset &amp;\\Leftrightarrow \\cup_{f \\in F, g\\in G}\r\n\\left(X_{fg}\\right) \\neq \\emptyset \\Leftrightarrow \\exists f_{0}\\in F,\r\ng_{0} \\in G, f_{0}g_{0} \\notin \\mathfrak{R}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><strong>Remark 1:</strong> Singletons <span\r\nclass=\"math inline\">\\(\\{x\\}, x\\in X\\)</span> are irreducible subspaces;\r\nthe closure of irreducible subspaces in <span\r\nclass=\"math inline\">\\(X\\)</span> are irreducible subspaces.</p>\r\n<p><strong>Remark 2:</strong> Each singleton <span\r\nclass=\"math inline\">\\(\\{x\\}, x\\in X\\)</span> contained in a maximal\r\nirreducible subspace of <span class=\"math inline\">\\(X\\)</span>, which is\r\ncalled <a\r\nhref=\"https://en.wikipedia.org/wiki/Irreducible_component\">irreducible\r\ncomponent</a>. The irrducible components cover <span\r\nclass=\"math inline\">\\(X\\)</span>.</p>\r\n<p><strong>Remark 3:</strong> In an irreducible Hausdorff space <span\r\nclass=\"math inline\">\\(X\\)</span>, the irrducible components of <span\r\nclass=\"math inline\">\\(X\\)</span> are singletons. However, the conected\r\ncomponents, for instance, Euclidean space, are itself.</p>\r\n<p>By taking quotient <span class=\"math inline\">\\(A/\\mathsf{p}\\)</span>\r\nand noting that there is a one-to-one correspondence <span\r\nclass=\"math inline\">\\(h:\\mathsf{a} \\mapsto \\mathsf{a}/\r\n\\mathsf{p}\\)</span> between <span\r\nclass=\"math inline\">\\(V(\\mathsf{p})\\)</span> and <span\r\nclass=\"math inline\">\\(\\text{Spec}(A/\\mathsf{p})\\)</span> that preserves\r\nprime ideals, there is a one-to-one correspondence between <span\r\nclass=\"math inline\">\\(r(\\mathsf{p}) = \\cap_{\\mathsf{p}_{x} \\in\r\nV(\\mathsf{p})} \\mathsf{p}_{x}\\)</span> and <span\r\nclass=\"math inline\">\\(\\mathfrak{R} (A/\\mathsf{p}) = \\cap_{x\\in\r\n\\text{Spec}(A/\\mathsf{p})} x\\)</span>, as is shown in the diagram</p>\r\n<p><span class=\"math display\">\\[\\begin{align}\r\n    \\require{AMScd}\r\n    \\begin{CD}\r\n        V(\\mathsf{p}) @&gt;&gt;h&gt; \\text{Spec} (A/\\mathsf{p})\\\\\r\n        @VV{\\tiny \\text{cap}}V @VV{\\tiny \\text{cap}}V\\\\\r\n        r(\\mathsf{p}) @&gt;&gt;h&gt; \\mathfrak{R} (A/\\mathsf{p})\r\n    \\end{CD}\r\n\\end{align}\\]</span></p>\r\n<p>According to above theorem and</p>\r\n<blockquote>\r\n<p>Non-zero ring <span class=\"math inline\">\\(A\\)</span> has minimal\r\nprime ideals with respect to set inclusion. By Zorn's lemma, it only\r\nsuffices to prove that the intersection <span\r\nclass=\"math inline\">\\(\\cap_{n}\\mathsf{p}_{n}\\)</span> of a\r\nnon-increasing sequence of prime ideals <span\r\nclass=\"math inline\">\\(\\cdots \\supseteq \\mathsf{p}_{n} \\supseteq\r\n\\mathsf{p}_{n+1}\\supseteq \\cdots\\)</span> is also a prime ideal. By\r\nconsidering <span class=\"math inline\">\\(x,y \\in A, xy \\in\r\n\\cap_{n}\\mathsf{p}_{n}\\)</span>, we have for each <span\r\nclass=\"math inline\">\\(n\\)</span>, either <span\r\nclass=\"math inline\">\\(x\\)</span> or <span\r\nclass=\"math inline\">\\(y\\)</span> belongs to <span\r\nclass=\"math inline\">\\(\\mathsf{p}_{n}\\)</span>. Then one of <span\r\nclass=\"math inline\">\\(x\\)</span> and <span\r\nclass=\"math inline\">\\(y\\)</span> occurs in <span\r\nclass=\"math inline\">\\(\\mathsf{p}_{n}\\)</span> for infinitely many times,\r\nsay, for example, <span class=\"math inline\">\\(x \\in\r\n\\cap_{n}\\mathsf{p}_{n}\\)</span>. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n</blockquote>\r\n<p>we only need to show that <span class=\"math inline\">\\(h\\)</span> is a\r\nhomeomorphism, which is indeed true since <span\r\nclass=\"math inline\">\\(h\\)</span> maps <span\r\nclass=\"math inline\">\\(V(\\mathsf{a}) \\cap V(\\mathsf{p}) = V(\\mathsf{a} +\r\n\\mathsf{p})\\)</span> to <span class=\"math inline\">\\(V((\\mathsf{a} +\r\n\\mathsf{p})/ \\mathsf{p})\\)</span> and vice versa, where <span\r\nclass=\"math inline\">\\(\\mathsf{a}\\)</span> is an ideal of <span\r\nclass=\"math inline\">\\(A\\)</span>. Similarily, the closed subspace <span\r\nclass=\"math inline\">\\(V(\\mathsf{p})\\)</span> of <span\r\nclass=\"math inline\">\\(\\text{Spec}(A)\\)</span> is irreducible if and only\r\nif <span class=\"math inline\">\\(r(\\mathsf{p})\\)</span> is a prime ideal,\r\nwhere <span class=\"math inline\">\\(\\mathsf{p}\\)</span> is an ideal of\r\n<span class=\"math inline\">\\(A\\)</span>. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"property-4-homomorphism\">Property 4 [Homomorphism]</h2>\r\n<p>Let <span class=\"math inline\">\\(\\phi: A \\to B\\)</span> be\r\nhomomorphism that preserves unit. <span\r\nclass=\"math inline\">\\(X=\\text{Spec}(A) , Y=\\text{Spec}(B)\\)</span>.\r\nSince <span class=\"math inline\">\\(\\phi^{-1}\\)</span> draws back prime\r\nideals in <span class=\"math inline\">\\(Y\\)</span> into prime ideals in\r\n<span class=\"math inline\">\\(X\\)</span>, <span\r\nclass=\"math inline\">\\(\\phi\\)</span> introduces naturally a mapping <span\r\nclass=\"math inline\">\\(\\phi^{*}: \\text{Spec}(B) \\to\r\n\\text{Spec}(A)\\)</span> by <span class=\"math inline\">\\(\\mathsf{q}\r\n\\mapsto \\phi^{-1} (\\mathsf{q})\\)</span></p>\r\n<ol type=\"1\">\r\n<li><p>It is easy to verify that <span\r\nclass=\"math inline\">\\((\\phi^{*})^{-1}(X_{f}) =Y_{\\phi(f)}\\)</span>,\r\nwhich implies <span class=\"math inline\">\\(\\phi^{*}\\)</span> is\r\ncontinuous.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(\\phi\\)</span> is surjective, then\r\n<span class=\"math inline\">\\(\\phi^{*}\\)</span> is injective. By <a\r\nhref=\"https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms\">Fundamental\r\ntheorem on homomorphisms</a>, <span class=\"math inline\">\\(A/\\ker(\\phi)\r\n\\cong B\\)</span>. Note in above we mention that <span\r\nclass=\"math inline\">\\(\\phi\\)</span> is a homeomorphism mappping, thereby\r\n<span class=\"math inline\">\\(\\phi^{*}\\)</span> establish a homeomorphism\r\nbetween <span class=\"math inline\">\\(Y=\\text{Spec}(B)\\)</span> and <span\r\nclass=\"math inline\">\\(V\\left(\\ker(\\phi)\\right)\\)</span>.</p></li>\r\n<li><p><span class=\"math inline\">\\(\\overline{\\phi^{*}(V(\\mathsf{b}))} =\r\nV(\\phi^{*}(\\mathsf{b}))\\)</span>. Hence if <span\r\nclass=\"math inline\">\\(\\phi\\)</span> is injective, then <span\r\nclass=\"math inline\">\\(\\phi^{*}(Y)\\)</span> is dense in <span\r\nclass=\"math inline\">\\(X\\)</span>. Let <span\r\nclass=\"math inline\">\\(\\mathsf{q} \\in V(\\mathsf{b})\\)</span> and note\r\nthat $^{*}() = ^{-1}() ^{-1}() $, so <span\r\nclass=\"math inline\">\\(\\phi^{-1}(\\mathsf{q}) \\in\r\nV(\\phi^{*}(\\mathsf{b}))\\)</span> and <span\r\nclass=\"math inline\">\\(\\mathsf{q} \\in\r\n\\phi(V(\\phi^{*}(\\mathsf{b})))\\)</span>. Thus <span\r\nclass=\"math inline\">\\(V(\\mathsf{b}) \\subseteq\r\n\\phi(V(\\phi^{*}(\\mathsf{b})))\\)</span>. Then note that <span\r\nclass=\"math display\">\\[y \\in \\overline{\\{x\\}} \\Leftrightarrow\r\n\\overline{\\{y\\}} \\subseteq \\overline{\\{x\\}} \\Leftrightarrow\r\nV(\\mathsf{p}_{y}) \\subseteq V(\\mathsf{p}_{x}) \\Leftrightarrow\r\n\\mathsf{p}_{x} \\subseteq \\mathsf{p}_{y}\\]</span> which says <span\r\nclass=\"math inline\">\\(\\overline{\\{x\\}} =\r\nV\\left(\\mathsf{p}(={x})\\right)\\)</span>; <span\r\nclass=\"math inline\">\\(V(\\mathsf{b})\\)</span> is obviously the minimal\r\nclosed set in <span class=\"math inline\">\\(X\\)</span> which contains\r\n<span class=\"math inline\">\\(\\phi^{*}(V(\\mathsf{b}))\\)</span> since <span\r\nclass=\"math inline\">\\(\\phi^{*}(\\mathsf{b}) \\in\r\n\\phi^{*}(V(\\mathsf{b}))\\)</span>.</p></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\begin{align}\r\n    \\require{AMScd}\r\n    \\begin{CD}\r\n        X @&lt;&lt;{\\phi^*}&lt; Y\\\\\r\n        @AA{\\tiny \\text{$\\cup$}}A  @AA{\\tiny \\text{$\\cup$}}A\\\\\r\n        V_A(\\phi^* (\\mathsf{b})) @&lt;&lt;{\\phi^*}&lt; V_B(\\mathsf{b})\\\\\r\n        @AA{\\text{$*$}}A  @AA{\\text{$*$}}A\\\\\r\n        \\text{Spec}(A/\\phi^* (\\mathsf{b})) @&lt;&lt;{\\tilde\\phi^*}&lt;\r\n\\text{Spec} (B/\\mathsf{b})\r\n    \\end{CD}\r\n\\end{align}\\]</span></p>\r\n<p><strong>Example:</strong> Let <span class=\"math inline\">\\(A\\)</span>\r\nbe an integral domain with just one non-zero prime ideal <span\r\nclass=\"math inline\">\\(\\mathsf{p}\\)</span>. and let <span\r\nclass=\"math inline\">\\(K\\)</span> be the field of fractions of <span\r\nclass=\"math inline\">\\(A\\)</span>. Let <span\r\nclass=\"math inline\">\\(B=(A/\\mathsf{p}) \\times K\\)</span>. Define <span\r\nclass=\"math inline\">\\(\\phi: A \\to B\\)</span> by <span\r\nclass=\"math inline\">\\(\\phi(x) = (\\bar{x}, x)\\)</span>, where <span\r\nclass=\"math inline\">\\(\\bar{x}\\)</span> is the image of <span\r\nclass=\"math inline\">\\(x\\)</span> in <span\r\nclass=\"math inline\">\\(A/\\mathsf{p}\\)</span>. <span\r\nclass=\"math inline\">\\(\\phi^{*}\\)</span> is bijective but not a\r\nhomeomorphism: Since <span class=\"math inline\">\\(A/\\mathsf{p}\\)</span>\r\nis also a field, hence <span class=\"math inline\">\\(B = (A/\\mathsf{p})\r\n\\times K\\)</span> has only two prime ideals <span\r\nclass=\"math display\">\\[\\left\\{(1)\\times(0), (0)\r\n\\times(1)\\right\\}\\]</span> Direct computation yields <span\r\nclass=\"math inline\">\\(\\phi^{*}\\)</span> is a bijection. However, <span\r\nclass=\"math inline\">\\(\\{(1) \\times (0)\\}\\)</span> is a closed set of\r\n<span class=\"math inline\">\\(\\text{Spec}(B)\\)</span> whereas <span\r\nclass=\"math inline\">\\(\\{(0)\\}\\)</span> is not closed in <span\r\nclass=\"math inline\">\\(\\text{Spec}(A)\\)</span>.</p>\r\n<h2 id=\"more-on-separation-axiom-t_1-t_2\">More on Separation Axiom\r\n[<span class=\"math inline\">\\(T_{1}\\)</span>, <span\r\nclass=\"math inline\">\\(T_{2}\\)</span>]</h2>\r\n<p>We define <span class=\"math display\">\\[\\mathscr{V}^{\\prime} = \\left\\{\r\n\\phi^{*}\\left(\\text{Spec}(B)\\right): \\text{ where $\\phi:A \\to B$ is ring\r\nhomomorphism} \\right\\}\\]</span> It can be verified that <span\r\nclass=\"math inline\">\\(\\mathscr{V}^{\\prime}\\)</span> satisfies axiom of\r\nclosed set. The topology in <span\r\nclass=\"math inline\">\\(\\text{Spec}(A)\\)</span> is called <a\r\nhref=\"https://en.wikipedia.org/wiki/Constructible_topology\">constructable\r\ntopology</a>. which is finer than Zariski topology.</p>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(A/\\mathfrak{R}\\)</span> is <a\r\nhref=\"\">absolutely flat</a> (<span\r\nclass=\"math inline\">\\(\\mathfrak{R}\\)</span> being the nilradical of\r\n<span class=\"math inline\">\\(A\\)</span>).</li>\r\n<li>Every prime ideal of <span class=\"math inline\">\\(A\\)</span> is\r\nmaximal.</li>\r\n<li><span class=\"math inline\">\\(\\text{Spec} (A)\\)</span> is a <span\r\nclass=\"math inline\">\\(T_{1}\\)</span>-space (i.e., every subset\r\nconsisting of a single point is closed).</li>\r\n<li><span class=\"math inline\">\\(\\text{Spec} (A)\\)</span> is\r\nHausdorff.</li>\r\n<li>The Zariski topology and the constructible topology on <span\r\nclass=\"math inline\">\\(\\text{Spec} (A)\\)</span> coincide</li>\r\n</ol>\r\n<h2 id=\"proporsition-5-connectedness\">Proporsition 5\r\n[Connectedness]</h2>\r\n<p>If a commutative ring <span class=\"math inline\">\\(A\\)</span> with\r\nunit can be represented as direct product of non-zero ring, <span\r\nclass=\"math inline\">\\(A_{i}, i=1, 2, \\cdots, n\\)</span>, By a standard\r\nresult in commutative ring, the ideals <span\r\nclass=\"math inline\">\\(A=\\prod_{i=1}^{n}A_{i}\\)</span> has the form</p>\r\n<p><span class=\"math display\">\\[\\mathsf{a}_{1} \\times \\cdots \\times\r\n\\mathsf{a}_{i} \\times \\cdots \\times \\mathsf{a}_{n}, \\text{ where\r\n$\\mathsf{a}_{i}$ are ideals of $A_{i}$} \\]</span><br />\r\nEspecially, prime ideals in <span class=\"math inline\">\\(A\\)</span> has\r\nthe form</p>\r\n<p><span class=\"math display\">\\[(1) \\times \\cdots \\times \\mathsf{p}_{i}\r\n\\times \\cdots \\times (1), \\text{ where $\\mathsf{p}_{i}$ are prime ideals\r\nof $A_{i}$}\\]</span></p>\r\n<p>For ring <span class=\"math inline\">\\(A=\\prod_{i=1}^{n}A_{i}\\)</span>,\r\nthe spectrum <span class=\"math inline\">\\(X = \\text{Spec}(A)\\)</span> is\r\nthe disjoint union of <span class=\"math inline\">\\(X_{i}, i\r\n=1,2,\\cdots,n\\)</span>, where <span class=\"math inline\">\\(X_{i}\\)</span>\r\nconsists of prime ideals containing <span class=\"math inline\">\\((1)\r\n\\times \\cdots \\times \\underset{i}{(0)} \\times \\cdots \\times\r\n(1)\\)</span>, homeomorphic to <span\r\nclass=\"math inline\">\\(\\text{Spec}(A_{i})\\)</span>. Hence <span\r\nclass=\"math inline\">\\(X=\\text{Spec}(A)\\)</span> is not connected. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p>\r\n<p>Conversly, if the subsets <span class=\"math inline\">\\(X_{1}, X_{2}\r\n\\neq \\emptyset, X_{1} \\cap X_{2} = \\emptyset\\)</span> of <span\r\nclass=\"math inline\">\\(X=\\text{Spec}(A)\\)</span> satisfies <span\r\nclass=\"math inline\">\\(X_{1} \\cup X_{2} = X\\)</span>. According to the\r\ndefinition of spectrum, we have <span class=\"math inline\">\\(X_{1}\r\n=V(\\mathsf{a}_{1}), X_{2} =V(\\mathsf{a}_{2}),\\)</span> where <span\r\nclass=\"math inline\">\\(\\mathsf{a}_{1},\\mathsf{a}_{2}\\)</span> are ideals\r\nof ring <span class=\"math inline\">\\(A\\)</span>, and <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\nV(\\mathsf{a}_{1}) \\cap V(\\mathsf{a}_{2}) = V(\\mathsf{a}_{1}\r\n+\\mathsf{a}_{2}) =\\emptyset &amp;\\Rightarrow\r\n\\mathsf{a}_{1} +\\mathsf{a}_{2} = (1)\\\\\r\nV(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2}) = V(\\mathsf{a}_{1} \\cap\r\n\\mathsf{a}_{2}) = X &amp;\\Rightarrow\r\n\\mathsf{a}_{1} \\cap \\mathsf{a}_{2} \\subseteq \\mathfrak{R}\r\n\\end{aligned}\r\n\\]</span> there exist <span class=\"math inline\">\\(x_{1} \\in\r\n\\mathsf{a}_{1}, x_{2} \\in \\mathsf{a}_{2}\\)</span>, and integer <span\r\nclass=\"math inline\">\\(n&gt;0\\)</span> such that <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\nx_{1} + x_{2} &amp;=1\\\\\r\n(x_{1} x_{2})^{n} &amp;=0\r\n\\end{aligned}\r\n\\]</span> Due to elementary arithmetic it finds that <span\r\nclass=\"math display\">\\[r(x_{1}^{n}) + r(x_{2}^{n}) =1 \\Rightarrow\r\n(x_{1}^{n}) + (x_{2}^{n}) =1 \\]</span>. Therefore we can find an\r\nidempotent <span class=\"math inline\">\\(e\\neq 0,1 \\in\r\n(x_{1}^{n})\\)</span> such that <span class=\"math inline\">\\(1 - e \\in\r\n(x_{2}^{n})\\)</span>, and <span class=\"math inline\">\\(e(1 - e) =\r\n0\\)</span>, because the non-empty assumption of <span\r\nclass=\"math inline\">\\(X_{i}, i=1,2\\)</span>. Thereby <span\r\nclass=\"math inline\">\\(A\\)</span> can be decomposed as the direct product\r\nof <span class=\"math inline\">\\(eA\\)</span> and <span\r\nclass=\"math inline\">\\((1-e) A\\)</span>. $ $</p>\r\n<p>We summarize the result below:</p>\r\n<p>Let <span class=\"math inline\">\\(A\\)</span> be any commutative ring\r\nwith unit. The following statements are equivalent:</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(X = \\text{Spec} (A)\\)</span> is\r\ndisconnected.</p></li>\r\n<li><p><span class=\"math inline\">\\(A \\cong A_{1} \\times A_{2}\\)</span>\r\nwhere neither of the rings <span class=\"math inline\">\\(A_{1}\\)</span> or\r\n<span class=\"math inline\">\\(A_{2}\\)</span> is the zero ring.</p></li>\r\n<li><p><span class=\"math inline\">\\(A\\)</span> contains an idempotent\r\n<span class=\"math inline\">\\(\\neq 0,1\\)</span>.</p></li>\r\n</ol>\r\n<p><strong>Remark:</strong> Local ring, that is, ring with only one\r\nmaximal ideal, is always connected.</p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Michael Atiyah. Introduction to commutative algebra. CRC Press,\r\n2018.</p>\r\n<p>[2] Suzanne C Dieudonne. History Algebraic Geometry. CRC Press,\r\n1985.</p>\r\n<p>[3] Bartel L Van der Waerden. A history of algebra: From al-Khwrizm\r\nto Emmy Noether. Springer Science &amp; Business Media, 2013.</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Dec 31 2023 15:46:31 GMT+0800 ()","title":"Zariski Topology","path":"2023/03/23/Zariski topology/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-03-22T23:13:04.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-03-22T23:13:04.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Commutative Algebra > Algebraic Geometry","tags":["Algebraic Geometry"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"The Discovery of Neptune (By J.E. Littlewood)","date":"2023-04-04T12:02:28.000Z","mathjax":true,"_content":"\nNeptune was discovered in 1846 as a result of mathematical calculation, done independently and practically simultaneously by Adams and le Verrier. The full story abounds in unexpected twists, and is complicated by personal matters, some of them rather painful. There is a fascinating account in Professor W. M. Smart's ***John Couch Adams and the Discovery of Neptune***, published by the Royal Astronomical Society, 1947. I am concerned only with limited parts of the field.\n\nTo refresh the reader's memory of what has been said from time to time about the discovery I will begin with some representative quotations. In ***The Story of the Heavens*** (1886) Sir Robert Ball has passages:' the name of le Verrier rose to a pinnacle hardly surpassed in any age or country' ... 'profound meditations for many months' ... 'long tand arduous labour guided by consummate mathematical artifice'. The author is not above a bit of popular appeal in this book  'if the ellipse has not the perfect simplicity of the circle, it has at least the charm of variety ... an outline of perfect grace, and an association with ennobling conceptions'  but on Neptune he is speaking as a professional. An excellent modern book on the history of astronomy has, so late as 1938:' probably the most daring mathematical enterprise of the century ... this amazing task, like which nothing had ever been attempted before'.\n\nThe immediate reaction was natural enough. Celestial Mechanics in general, and the theory of perturbations in particular, had developed into a very elaborate and high-brow subject; the problem of explaining the misbehaviour of Uranus by a new planet was one of 'inverse' theory, and the common feeling was that the problem was difficult up to or beyond the point of impossibility. One might speculate\nat some length on reasons for this opinion (one, perhaps was confusion between different meanings of the technica term 'insoluble'[^1]). When Adams and le Verrier provec the opinion wrong (and after all ***any*** mathematical proof is\na debunking of sorts) there was still something to be said for the principle that difficulties are what they seem before the event, not after. Certainly no one would grudge them their resounding fame. (Nor grudge, at a lower level, the luck of a discovery which makes a more sensational impact than its actual difficulty strictly merits; in point of fact this luck never does happen to the second-rate.)\nIf the discovery has had a very long run one must remember that there is a time-lag\n; people cannot be always reconsidering opinions, and having said something once even the most intelligent tend to go on repeating it. The phrase was still in vogue that 'only 3 people understand Relativity' at a time when Eddington was complaining that the trouble about Relativity as an examination subject in 'Part III' was that it was such a soft option.\n\nIn what I am going to say I am far from imputing stupidity to people certainly less stupid than myself. My little ***jeuz d'esprit*** are not going to hurt anyone, and I refuse to be deterred by the fear of being thought disrespectful to\ngreat men. I have not been alone in a lurking suspicion that a much simpler approach might succeed. On the one hand, aim at the minimum needed to make observational discovery practicable; specifically at the time $t_{0}$ of conjunction.[^2] On the other, forget the high-brow and laborious perturbation\ntheory, and try 'school mathematics'. (I admit to the human weakness of being spurred on by the mild piquancy success would have.) To begin with I found things oddly elusive (and incidentally committed some gross stupidities). In the end an absurdly simple line emerged: I can imagine its being called a dirty trick, nor would I deny that there is some truth in the accusation. The only way to make my\ncase is to carry out the actual 'prediction' of $t_{0}$ from the observational data, with all the cards on the table (so that anyone can check against unconscious\nor conscious faking). I will also write so as to take as many amateurs as\npossible with me on the little adventure.\n\n[^1]: Its attachment to the '3-body problem' misleads people to-day.\n\n[^2]: The time at which NUS is a straight line (I shall use the abbreviations S, U, N).\n\n\nA planetary 'orbit' is an ellipse with the Sun $S$ at a focus, and the radius vector $SP$ sweeps out area at a constant rate (Kepler's second law). An orbit, given its plane, is defined by 4 elements, $a$, $e$, $\\alpha$, $\\epsilon$.\nThe first 3 define the geometrical ellipse: $a$ is the semi-major axis; $e$ the eccentricity; $\\alpha$ the longitude of perihelion, i.e. with the obvious polar coordinates $r, \\theta$, $\\theta$ is the 'longitude' and $\\theta=a$ when $P$ is\nnearest $S$ (at an end of the major axis). When we know $a$ we know the 'mean angular velocity' $n$ and the associated period $p= 2 \\pi/n$; $n$ is in fact proportional to $a^{-\\frac{1}{2}}$ (Kepler's third law)[^1(2)]; further the constant rate of area sweeping is $\\frac{1}{2}abn$[^2(2)] and twice this rate is identical with the angular momentum'[^3(2)] (a.m. for short); this has the differential\ncalculus formula $r^{2}\\theta$, and it also is of course constant. The 4th element, the 'epoch' $e$, is needed to identify the origin of $t$; the exact definition is that $\\theta= \\alpha$ (perihelion) occurs at the $t$ for which $nt+ \\epsilon = \\alpha$.\n\n\n[^1(2)]: It does not depend on $e$.\n\n[^2(2)]: The total area of the ellipse is $\\pi ab$, and it is swept out in time $p$.\n\n[^3(2)]: Strictly speaking the a.m. should have the planet's mass as a factor: but $U$'s mass is irrelevant and I omit it throughout.\n\n$U$'s orbit has a period of 84 years, and an eccentricity $e$ of about $\\frac{1}{20}$. The effects of bodies other than $S$ and $N$ can be allowed for, after which we may suppose that $U$, $S$, and the eventual $N$ are the only bodies in the system; we may also suppose (all this is common form) that the movements are all in one plane. The values of $\\theta$ (for $U$) at the various times $t$ (we sometimes write $\\theta(t)$ to emphasize that $\\theta$ is 'at time $t$') may be regarded as the observational raw material (though of course the actual raw observations are made from the Earth). The $r$'s for the various $t$ are indirect and are much less well determined.\n\n\n\nThe position in 1845 was that no exact elliptic orbit would fit the observed 6 over the whole stretch 1780 to 1840.[^1(3)] The discrepancies are very small, mostly a few seconds of arc (with a sudden swoop of about 90\",see Tablel). The ratio $m$ of $N$'s mass to that of $S$ (taken as 1) is actually about 1/19000\n(the Orders of magnitude fit since m radians is about 11\").\n\n[^1(3)]: Observations after 1840 were not immediately available, and anyhow\nwere not used. Uranus was discovered in 1781. Lest the reader should be worried by small inconsistencies in my dates I mention that 1780 is 'used', the extrapolation being a safe one.\n\nIn the absence of $N$ the a.m. $A$ is constant (as stated above alias of Kepler's second law); ***the actual $N$ accelerates $A$ at times earlier than $t_{0}$ and decelerates it at later times***. The graph of $A$ against $t$ therefore rises to a maximum at $t=t_{0}$, and my first idea was that this would identify. So it would if all observations were without error (and the method would have the theoretical advantage of being unaffected by the eccentricities). But the value of $A$ at time $t$ depends on the $r$ at time $t$, and the determinations of the $A$'s are consequently too uncertain. Though the method fails it rises from the ashes in another form. For this a few more preliminaries are needed.\n\n\nThe numerical data Adams and le Verrier had to work on were not the observed\n$\\theta$'s themselves, but the differences between the observed $\\theta(t)$ and the $\\theta_{B}(t)$ of an elliptic orbit calculated by Bouvard; the 'discrepancy' $\\delta(t)$ ($\\delta$ for short) is $\\delta(t)=\\theta(t)-\\theta_{B}(t)$. [$\\theta_{B} (t)$ depends on the 'elements' of $E_{B}$, and these are subject to 'errors'. These errors are among the unknowns that the perturbation theory has to determine: our method does not mind what they are, as we shall see.] Table I gives the raw $S$'s (given in Adams's paper[^2(3)]), together with the values got by running\na smooth curve. The treatment of the start of the sudden swoop down after the long flat stretch is a bit uncertain: I drew my curve and stuck to it (but faking would make no ultimate difference). The differences show up the order of the observational errors (which naturally improve with the years something seems to have gone badly wrong in 1789); these are absolute, not relative (thus the probable\nabsolute error in $\\delta_{1} - \\delta_{2}$ is the same whether $\\delta_{1} - \\delta_{2}$ is 0.5\" or 90\"). It is worth while to work to 0.1\" and to the number\nof decimal places used in what follows, even though the last place is doubtful.\n\n[^2(3)]: ***Collected Works, I***, p. 11. These (and not the modifications he\nintroduces, which are what appear in Smart) are what is relevant for us.\n\n\n\n| Year | Observed $\\delta$ | Smooth Curve | Year | Observed $\\delta$ | Smooth Curve |\n| :---: | :-------------: | :------------: | :---: | :------------: | :--------------: |\n| 1780 | 3.5 | 3.5 | 1813 | 22.0 | 22.8 |\n| 1783 | 8.5 | 8.5 | 1816 | 22.9 | 22.5 |\n| 1786 | 12.4 | 12.5 | 1819 | 20.7 | 22.0 |\n| 1789 | 19.0 | 15.8 | 1822 | 21.0 | 21.0 |\n| 1792 | 18.7 | 18.3 | 1825 | 18.2 | 18.1 |\n| 1795 | 21.4 | 20.3 | 1828 | 10.8 | 10.3 |\n| 1798 | 21.0 | 21.6 | 1831 | -4.0 | -4.0 |\n| 1801 | 22.2 | 22.4 | 1834 | -20.8 | -20.8 |\n| 1804 | 24.2 | 22.8 | 1837 | -42.7 | -42.5 |\n| 1807 | 22.1 | 23.0 | 1840 | -66.6 | -66.6 |\n| 1810 | 23.2 | 23.0 | 1843(e) | $-$ | -94.0 |\n\nTable 1\n\nThe value for 1843 is an extrapolation; results derived from it are labelled '(e)'.\n\nAn 'effect' due to $N$ is of 'order $m$ in mathematical notation $O(m)$; if, for a particular quantity $X$, \\Delta X$ denotes (calculated $X$)  (observed $X$), then any $\\Delta X$ is $O(m)$. The square of this (2nd order of infinitesimals) is\nextremely minute and everyone neglects it instinctively (if $a$ watch loses 10 seconds a day you don't try to correct for the further loss over the lost 10 seconds the cases are comparable). Next, an effect of $N$ is what it would be if $U$, and also $N$, moved in circles, ***plus*** a 'correction' for the actual eccentricities of the orbits. $U$'s eccentricity $e(\\frac{1}{20})$ is unusually large and it would be reasonable to expect $N$'s to be no larger (it is actually less than $\\frac{1}{100}$). The $e$'s distort the 'circular' value of the effect by 5 per cent, (or say a maximum of 10 per cent.); the 'distortion' of the effect\nis $O(em)$, the effect itself being $O(m)$. I propose to ignore things of order $O(em)$[^1(4)]: this is the first step in my argument. In particular, when we have something which is either some $\\Delta$, or $m$ itself, multiplied by a factor, we can substitute first approximations (i.e. with $e=0$), or make convenient changes that are $O(e)$, in the factor.\n\n\n[^1(4)]: I should stress that there is no question of ignoring even high powers\nof $e$ ***unaccompanied by a factor $m$*** ($e^{4}$ radians is about 1\"). The distortion in the value found for $t$ is, however, a sort of exception to\nthis. But the effect of $e$'s in distorting $t_{0}$ is unlikely to be worse than the separation they create between time of conjunction and time of closest approach. An easy calculation shows that this last time difference\nis at worst 0-8 years.\n\n\nSuppose now that $E_{l}, E_{2}$ are two (exact) elliptic orbits, yielding\n$\\theta(t)$'s that differ by amounts of the kind we are concerned with, differing, that is, by $O(m)$.[^2(4)] It is now the case that the differences satisfy the equation\n\n$$\\begin{equation}\n\\theta_{1} - \\theta_{2} = m( a + bt + c \\cos nt + d \\sin nt) + O(em)\n\\end{equation}$$\n\nwhere $a, b, c, d$ are constants depending on the two sets of elements of $E_{1}, E_{2}$, and (following our agreement about ***factors*** of $m$) $n$ is any common approximation to the mean angular velocity. I will postpone the school mathentatics\nproof of this.\n\n\n[^2(4)]: The orbits may have 'Suns' of masses differing by $O(m)$.\n\nNext, (i) let $E^{*}$ be the 'instantaneous orbit at time $t_{0}$', that is to say the orbit that $U$ would describe if $N$ were annihilated at time $t_{0}$: note that $E^{*}$ shares with $t_{0}$ the property of being 'unknown'. (ii) Let $\\vartheta$ be the perturbation of the $\\theta$ of $U$ produced by $N$ since time\n$t_{0}$.[^3(4)] Then if, at any time $t$, $\\theta$ is (as usual) $U$'s longitude, $\\theta_{B}$ is the longitude in the orbit $E_{B}$, and $\\theta^{*}$ the longitude in the orbit $E^{*}$, we have $\\vartheta = \\theta - \\theta^{*}$, and so\n\n$$\\begin{equation}\n\\delta(t) = \\theta - \\theta_{B} = (\\theta^{*} - \\theta_{B}) + \\vartheta\n\\end{equation}$$\n\nNow everything in this has a factor $m$, and we may omit any stray $O(em)$'s.\nIn particular, we may in calculating $\\vartheta$ drop any $e$ terms. But this means that ***we can calculate $\\vartheta$ as if both $U$'s and $N$'s orbits were circles***. When, however, the orbits are circles, ***$\\vartheta$ has equal and opposite values at $t$'s on equal and opposite sides of $t_{0}$***; in other words, ***if we write $t=t_{0} + \\tau$, then***\n\n$$\\begin{equation}\n\\vartheta(t) = \\Omega (\\tau)\n\\end{equation}$$\n\n***where $\\Omega (\\tau)$ is an odd[^1(5)] function of $\\tau$; i.e. $\\Omega(-\\tau)= -\\Omega(\\tau)$.***\n\n\n\n[^3(4)]: We allow, of course, ***negative*** values of $t - t_{0}$ both in $E^{*}$ and in $\\vartheta$.\n\n[^1(5)]: '$\\Omega$' is a deputy for '$O$' (initial of 'odd'), which is otherwise engaged. The italicized statement in the text is true 'by symmetry': alternatively, ***reverse*** the motions from time $t_{0}$. (The argument covers also the 'perturbation of 'the Sun' which is not so completely negligible as\nmight be supposed.)\n\n\nThis, used in combination with (1) and (2), is the essential (and very simple) point of the argument. The difference $\\theta^{*} - \\theta_{B}$ is a special case of $\\theta_{1} - \\theta_{2}$ in (1). Write $t=t_{0} + \\tau$ in (1) and combine this with (2) and (3); this gives, ignoring $O(em)$'s,\n\n$$\\delta(t_{0} + \\tau) = m \\left\\{a + b t_{0} + b \\tau + c \\cos (nt_{0} + n \\tau) + d \\sin (nt_{0} + n \\tau) \\right\\} + \\Omega(\\tau)$$\n\nExpanding the $\\cos$ and $\\sin$ of sums and rearranging we have (with new constants, whose values vary with but do not concern us)\n\n$$\\delta(t_{0} + \\tau) = A - B(1 - \\cos n\\tau) + \\left\\{C \\tau + D \\sin n\\tau + \\Omega(\\tau)\\right\\}$$\n\n***The curly bracket is an odd function of $\\tau$***. Hence if we combine\nequal and opposite $\\tau$ and construct $\\delta^{*}(\\tau)$ and $\\rho(\\tau)$ to satisfy\n\n$$\\delta^{*}(\\tau) = - \\frac{1}{2} \\left\\{\\delta(t_{0}+\\tau) + \\delta(t_{0}- \\tau) - 2 \\delta(t_{0}) \\right\\}, \\rho(\\tau) = \\delta^{*}(\\tau)/(1-\\cos n\\tau)$$\n\nwe have $\\delta^{*}(\\tau)=B( 1 - \\cos n\\tau)$, and so $\\rho(\\tau)=B $ for all $\\tau$. ***If, then, we are using the right $t_{0}$ the ratio p(r) must come out constant***: this is our method for identifying $t_{0}$. The actual value of $t_{0}$ to the nearest year is 1822.\n\nTable II, in which the unit of time is 1 year (and the $n$ of $\\cos n\\tau$ is $2\\pi/84$), shows the results of trying various (the century is omitted from the dates). The last place of decimals for the $\\rho(\\tau)$ is not reliable, but of course gets better as the size of the entry $2\\delta^{*}(\\tau)$ increases: I give the numbers as they came, and they speak for themselves. $\\tau=6$ is included, though the proportionate error in $\\delta^{*}$ is then considerable.[^1(6)] For\n$t_{0}=13$ $\\rho$ goes on to 34.8 at $\\tau=27$; for $t_{0}=16$ it goes to 38.2 at $\\tau= 24$. Once the data the smooth curve values were assembled the calculations took a mere hour or so with a slide-rule. The date 1822-4 seems about the 'best' $t_{0}$.\n\n[^1(6)]: And the, values for $\\tau=6$ at $t_{0}=22, 22.4$ are more uncertain than usual because of a crisis in the smooth curve.\n\n<style>\n    body {text-align: center;} table{margin: auto;}\n</style>\n\n<table>\n    <tr>\n        <td> </td>\n        <td colspan=\"2\"> $t_{0} = 13$ </td>\n        <td colspan=\"2\"> $t_{0} = 16$ </td>\n        <td colspan=\"2\"> $t_{0} = 19$ </td>\n        <td colspan=\"2\"> $t_{0} = 22$ </td>\n        <td colspan=\"2\"> $t_{0} = 22.4$ </td>\n        <td colspan=\"2\"> $t_{0} = 25$ </td>\n        <td colspan=\"2\"> $t_{0} = 28$ </td>\n    </tr>\n    <tr>\n        <td> $\\tau$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n    </tr>\n    <tr>\n        <td> 6 </td>\n        <td> 0.6 </td>\n        <td> 3.0 </td>\n        <td> 1.0 </td>\n        <td> 5.1 </td>\n        <td> 3.6 </td>\n        <td> 18.3 </td>\n        <td> 9.2 </td>\n        <td> 47.0 </td>\n        <td> 10.6 </td>\n        <td> 53.8 </td>\n        <td> 18.2 </td>\n        <td> 92.5 </td>\n        <td> 20.4 </td>\n        <td> 103 </td>\n    </tr>\n    <tr>\n        <td> 9 </td>\n        <td> 1.8 </td>\n        <td> 4.1 </td>\n        <td> 3.9 </td>\n        <td> 9.0 </td>\n        <td> 10.7 </td>\n        <td> 24.6 </td>\n        <td> 23.2 </td>\n        <td> 53.3 </td>\n        <td> 25.0 </td>\n        <td> 57.6 </td>\n        <td> 34.5 </td>\n        <td> 79.3 </td>\n        <td> 41.1 </td>\n        <td> 94 </td>\n    </tr>\n    <tr>\n        <td> 12 </td>\n        <td> 5.3 </td>\n        <td> 7.6 </td>\n        <td> 11.9 </td>\n        <td> 15.8 </td>\n        <td> 25.0 </td>\n        <td> 33.2 </td>\n        <td> 39.8 </td>\n        <td> 53.0 </td>\n        <td> 42.2 </td>\n        <td> 56.1 </td>\n        <td> 55.9 </td>\n        <td> 74.4 </td>\n        <td> 64.7 </td>\n        <td> 86 </td>\n    </tr>\n    <tr>\n        <td> 15 </td>\n        <td> 13.7 </td>\n        <td> 12.1 </td>\n        <td> 26.6 </td>\n        <td> 23.5 </td>\n        <td> 42.0 </td>\n        <td> 37.1 </td>\n        <td> 61.5 </td>\n        <td> 54.4 </td>\n        <td> 64.0 </td>\n        <td> 56.5 </td>\n        <td> 79.8 </td>\n        <td> 70.5 </td>\n        <td> 91(e) </td>\n        <td> 80.6(e) </td>\n    </tr>\n    <tr>\n        <td> 18 </td>\n        <td> 29.3 </td>\n        <td> 18.8 </td>\n        <td> 44.2 </td>\n        <td> 28.4 </td>\n        <td> 64.1 </td>\n        <td> 41.2 </td>\n        <td> 85.8 </td>\n        <td> 55.2 </td>\n        <td> 88.6 </td>\n        <td> 57.0 </td>\n        <td> 106(e) </td>\n        <td> 86.3(e) </td>\n        <td> $-$ </td>\n        <td> $-$ </td>\n    </tr>\n    <tr>\n        <td> 21 </td>\n        <td> 48.3 </td>\n        <td> 24.1 </td>\n        <td> 67.2 </td>\n        <td> 36.6 </td>\n        <td> 89.0 </td>\n        <td> 45.5 </td>\n        <td> 113(e) </td>\n        <td> 56.5(e) </td>\n        <td> 116(e) </td>\n        <td> 58.0(e) </td>\n        <td> $-$ </td>\n        <td> $-$ </td>\n        <td> $-$ </td>\n        <td> $-$ </td>\n    </tr>\n    <caption> Table II </caption>\n</table>\n\nWe need fairly large $\\tau$ for $\\delta^{*}(\\tau)$ to have enough ignificant figures, and further to provide a range showing up whether\n$\\rho(\\tau)$ is constant or not. And we need room to manoeuvre round the final. So the method depends on the 'luck' that 1822 falls comfortably inside the period of observation 1780-1840. But some luck was needed in any case.\n\n\nIt is an important point that the method is quite indifferent to how well $E_{B}$ does its originally intended job, and ***we do not need to know (and I don't knoiv) its elements***; it is enough to know the 'discrepancy' with ***some***, 'unknown', orbit (not too bad of course). On the other hand the method ostentatiously says nothing at all about the mass or distance of $N$. I will add something on this. With $e$-terms ignored $\\vartheta(\\tau)/m$ can be calculated ***exactly*** for any given value of $\\lambda=a/a_{1}$ (ratio of the $a$'s of $U$ and $N$)[^2(6)] The idea would be to try different $A$'s, each $A$ to give a best fitting $m$, and to take the best fitting ***pair*** $\\lambda, m$. This fails, because the greater part of $\\vartheta$ is of the form $b^{\\prime}(n\\tau - \\sin n\\tau)$, and $b^{\\prime}$ is smothered by the $a, b, c, d$ of $\\theta^{*} - \\theta_{B}$, which depend on the unknown elements of $E_{B}$ ($\\vartheta$ is smothered by the 'unknown' $\\theta^{*} - \\theta_{B}$). If we knew these elements (or equivalently the raw $\\theta$) we might be able to go on. They could be recovered from the Paris Observatory archives; but\nthis article is a last moment addition to the book, I do not feel that I am on full professional duty, and in any case we should be losing the\nlight-hearted note of our adventure.\n\n\n\n[^2(6)]: From two second order differential equations. The formula involves 'quadratures', but in numerical calculation integration\nis quicker than multiplication. It would be comparatively easy to make a double entry table for $\\vartheta(\\tau, \\lambda)/m$\n\n\n\n\nThe time $t$ once known, it would be necessary to guess a value for $N$'s distance $a_{1}$; $N$'s period is then $84(a_{1}/a)^{\\frac{3}{2}}$ years, and we could 'predict' $N$'s place in 1846. The obvious first guess in 1846 was $a_{l}/a=2$, following Bode's empirical law, to which N is maliciously the first exception, the true value being\n1.58. Adams and le Verrier started with 2 (Adams coming down to 1.942 for a second round). Since from our standpoint[^1(7)] too large an\n$a_{1}$ has disproportionately bad results as against one too small,\nit would be reasonable to try 1.8. This would give a prediction (for 1846) about 10$^{\\circ}$ out, but the sweep needed would be wholly practicable.\n\n\n[^1(7)]: Perturbation theory calculations have necessarily to ***begin*** by guessing $a_{1}$; our guess need only be at the end.\n\n\nLe Verrier was less than 1$^{\\circ}$ out (Adams between 2$^{\\circ}$ and 3$^{\\circ}$); 'they pointed the telescope and saw the planet'.\nThis very close, and double, prediction is a curiosity. All the observations from 1780 to 1840 were used, and on an equal footing, and the theory purported to say where $N$ was over this whole stretch.\nWith a wrong $a_{1}$ they could be right at 1840 only by being wrong at 1780. With Adams's $a_{1}=1.94a$ $N$'s period (which depends on $a_{1}$ only) would be 227 years; he would have been wrong by 30$^{\\circ}$\nfor 1780 if the orbit were circular, and so the angular velocity uniform. But faced with a wrong $a_{1}$ the method responded gallantly\nby putting up a large eccentricity ($\\frac{1}{8}$), and assigning perihelion to the place of conjunction. The combination makes the effective distance from $S$ over the critical stretch more like\n$1.7 a_{l}$, and the resulting error at 1780 (the worst one) was only 18. (A mass 2.8 times too large was a more obvious adjustment.)\n\n\nIn much more recent times small discrepancies for $N$ and $U$ ($U$'s being in fact the more manageable ones) were analysed for a trans-Neptunian planet, and the planet Pluto was found in 1930 near the predicted place. This was a complete fluke: Pluto has a mass probably no more than $\\frac{1}{10}$ of the Earth's; any effects\nit could have on $N$ and $U$ would be hopelessly swamped by the observational errors.\n\nIt remains for me to give the (school mathematics) proof of (1) above.\nCall $e_{1} - e_{2}$ $\\Delta e$, and so on. I said above that all $\\Delta$'s were $O(m)$: this is not quite true, though my deception has been in the reader's best interests, and will not have led him astray.[^1(8)] It is true, and common sense, for $\\Delta a$, $\\Delta e$, $\\Delta n$, and $\\Delta \\epsilon$. But the 'effect' of a given Aa vanishes when $e=0$, and is proportional to $e$. So it is $e\\Delta \\alpha$, not $\\Delta \\alpha$, that is comparable with the other $\\Delta$'s and so $O(m)$.[^2(8)]\n\n\n\n[^1(8)]: 'Wen Gott betrugt is wohl betrogon.'\n\n[^2(8)]: This twist makes the 'obvious' approach of using the\nweil known expansion\n$$\\theta = nt +\\epsilon + 2e \\sin (nt + \\epsilon -a) + \\frac{5}{4}e^{2} \\sin 2 (nt + \\epsilon -a ) + \\cdots$$\nslightly tricky; we should have to keep the term in $e^{2}$. The line taken in the text side-steps this.\n\n\n\n\n\nWe start from two well-known formulae. The first is geometrical; the polar equation of the ellipse of the orbit is\n\n$$\\begin{equation}\nr = a(1- e^{2}) ( 1 +e \\cos (\\theta -a))^{-1}\n\\end{equation}$$\n\n\n\nThe second is dynamical; the equation of angular momentum (Kepler's second law) is\n\n$$\\begin{equation}r^{2} \\frac{d\\theta}{dt} = na^{2} (1-e^{2})^{\\frac{1}{2}}\\end{equation}$$\n\n\n\nSo, using dots for time differentiations,\n\n\n$$\\begin{equation}\n\\theta = n(1-e^{2})^{-\\frac{3}{2}} [1 - 2\\cos (\\theta -a) + 3e^{2} \\cos^{2} (\\theta -a ) + \\cdots]\n\\end{equation}$$\n\n\nThe first approximation (with $e=0$) is $\\theta=nt + \\epsilon$. We take\nsuffixes 1 and 2 in (6) and operate with $\\Delta$, remembering that we may take first approximations in any ***factor*** of an $m$.\n\n\nIn estimating $\\Delta\\theta$ we may, with error $O(em)$, ignore the\nfactor $(1-e^{2})^{-\\frac{3}{2}}$ in (6), since it is itself $\\left(1+O(e^{2})\\right)$, and its $\\Delta$ is $O(e\\Delta e)=O(em)$. We have, therefore, with error $O(em)$,\n\n$$\\Delta \\theta = \\Delta \\left\\{n[\\quad ]\\right\\} = [\\quad ] \\Delta n + n \\Delta [\\quad ]$$\n\nThe 1st term is $\\Delta n+O(em)$. The 2nd is\n\n$$n\\left[\\Delta e \\left\\{- 2 \\cos(\\theta -a ) + O(e)\\right\\} + \\Delta (\\theta -a ) \\left\\{2e \\sin (\\theta -a ) + O(e^{2}\\right\\}\\right]$$\n\nand we may drop the $\\theta$ in $\\Delta (\\theta - a)$ on account of the factor $O(\\epsilon)$. Summing up, we obtain\n\n$$\\Delta \\theta = m (A+B \\cos (\\theta -a ) + C \\sin (\\theta -a ) ) + O(em)$$\n\nwhere $mA=\\Delta n$, $mB = -2n\\Delta e$, $mC = -2n(e\\Delta a)$. Substituting the first approximation $\\theta=nt + \\epsilon$ in the right hand side, we have\n\n$$\\Delta \\theta = m (A+B \\cos (nt + \\epsilon -a ) + C \\sin (nt + \\epsilon -a ) ) + O(em)$$\n\n\nand integration then gives\n\n\n\n$$\\Delta \\theta = m (A+B/n \\sin (nt + \\epsilon -a ) - C/n \\cos (nt + \\epsilon -a ) ) + O(em)$$\n\n\n\nwhich, after expanding the sin and cos and rearranging, is of the desired form (I).[^1(9)]\n\n\n\n[^1(9)]: We have treated $\\Delta n$ and $\\Delta a$ as independent (the latter happens not to occur in the final formula for $\\Delta \\theta$): this amounts to allowing different masses to the two 'Suns'. The point is relevant to certain subtleties, into which I will not enter.\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/The Discovery of Neptune.md","raw":"---\ntitle: The Discovery of Neptune (By J.E. Littlewood)\ndate: 2023-04-04 20:02:28\ntags:\n    - [Notes]\ncategories: \n    - [Notes]\nmathjax: true\n---\n\nNeptune was discovered in 1846 as a result of mathematical calculation, done independently and practically simultaneously by Adams and le Verrier. The full story abounds in unexpected twists, and is complicated by personal matters, some of them rather painful. There is a fascinating account in Professor W. M. Smart's ***John Couch Adams and the Discovery of Neptune***, published by the Royal Astronomical Society, 1947. I am concerned only with limited parts of the field.\n\nTo refresh the reader's memory of what has been said from time to time about the discovery I will begin with some representative quotations. In ***The Story of the Heavens*** (1886) Sir Robert Ball has passages:' the name of le Verrier rose to a pinnacle hardly surpassed in any age or country' ... 'profound meditations for many months' ... 'long tand arduous labour guided by consummate mathematical artifice'. The author is not above a bit of popular appeal in this book  'if the ellipse has not the perfect simplicity of the circle, it has at least the charm of variety ... an outline of perfect grace, and an association with ennobling conceptions'  but on Neptune he is speaking as a professional. An excellent modern book on the history of astronomy has, so late as 1938:' probably the most daring mathematical enterprise of the century ... this amazing task, like which nothing had ever been attempted before'.\n\nThe immediate reaction was natural enough. Celestial Mechanics in general, and the theory of perturbations in particular, had developed into a very elaborate and high-brow subject; the problem of explaining the misbehaviour of Uranus by a new planet was one of 'inverse' theory, and the common feeling was that the problem was difficult up to or beyond the point of impossibility. One might speculate\nat some length on reasons for this opinion (one, perhaps was confusion between different meanings of the technica term 'insoluble'[^1]). When Adams and le Verrier provec the opinion wrong (and after all ***any*** mathematical proof is\na debunking of sorts) there was still something to be said for the principle that difficulties are what they seem before the event, not after. Certainly no one would grudge them their resounding fame. (Nor grudge, at a lower level, the luck of a discovery which makes a more sensational impact than its actual difficulty strictly merits; in point of fact this luck never does happen to the second-rate.)\nIf the discovery has had a very long run one must remember that there is a time-lag\n; people cannot be always reconsidering opinions, and having said something once even the most intelligent tend to go on repeating it. The phrase was still in vogue that 'only 3 people understand Relativity' at a time when Eddington was complaining that the trouble about Relativity as an examination subject in 'Part III' was that it was such a soft option.\n\nIn what I am going to say I am far from imputing stupidity to people certainly less stupid than myself. My little ***jeuz d'esprit*** are not going to hurt anyone, and I refuse to be deterred by the fear of being thought disrespectful to\ngreat men. I have not been alone in a lurking suspicion that a much simpler approach might succeed. On the one hand, aim at the minimum needed to make observational discovery practicable; specifically at the time $t_{0}$ of conjunction.[^2] On the other, forget the high-brow and laborious perturbation\ntheory, and try 'school mathematics'. (I admit to the human weakness of being spurred on by the mild piquancy success would have.) To begin with I found things oddly elusive (and incidentally committed some gross stupidities). In the end an absurdly simple line emerged: I can imagine its being called a dirty trick, nor would I deny that there is some truth in the accusation. The only way to make my\ncase is to carry out the actual 'prediction' of $t_{0}$ from the observational data, with all the cards on the table (so that anyone can check against unconscious\nor conscious faking). I will also write so as to take as many amateurs as\npossible with me on the little adventure.\n\n[^1]: Its attachment to the '3-body problem' misleads people to-day.\n\n[^2]: The time at which NUS is a straight line (I shall use the abbreviations S, U, N).\n\n\nA planetary 'orbit' is an ellipse with the Sun $S$ at a focus, and the radius vector $SP$ sweeps out area at a constant rate (Kepler's second law). An orbit, given its plane, is defined by 4 elements, $a$, $e$, $\\alpha$, $\\epsilon$.\nThe first 3 define the geometrical ellipse: $a$ is the semi-major axis; $e$ the eccentricity; $\\alpha$ the longitude of perihelion, i.e. with the obvious polar coordinates $r, \\theta$, $\\theta$ is the 'longitude' and $\\theta=a$ when $P$ is\nnearest $S$ (at an end of the major axis). When we know $a$ we know the 'mean angular velocity' $n$ and the associated period $p= 2 \\pi/n$; $n$ is in fact proportional to $a^{-\\frac{1}{2}}$ (Kepler's third law)[^1(2)]; further the constant rate of area sweeping is $\\frac{1}{2}abn$[^2(2)] and twice this rate is identical with the angular momentum'[^3(2)] (a.m. for short); this has the differential\ncalculus formula $r^{2}\\theta$, and it also is of course constant. The 4th element, the 'epoch' $e$, is needed to identify the origin of $t$; the exact definition is that $\\theta= \\alpha$ (perihelion) occurs at the $t$ for which $nt+ \\epsilon = \\alpha$.\n\n\n[^1(2)]: It does not depend on $e$.\n\n[^2(2)]: The total area of the ellipse is $\\pi ab$, and it is swept out in time $p$.\n\n[^3(2)]: Strictly speaking the a.m. should have the planet's mass as a factor: but $U$'s mass is irrelevant and I omit it throughout.\n\n$U$'s orbit has a period of 84 years, and an eccentricity $e$ of about $\\frac{1}{20}$. The effects of bodies other than $S$ and $N$ can be allowed for, after which we may suppose that $U$, $S$, and the eventual $N$ are the only bodies in the system; we may also suppose (all this is common form) that the movements are all in one plane. The values of $\\theta$ (for $U$) at the various times $t$ (we sometimes write $\\theta(t)$ to emphasize that $\\theta$ is 'at time $t$') may be regarded as the observational raw material (though of course the actual raw observations are made from the Earth). The $r$'s for the various $t$ are indirect and are much less well determined.\n\n\n\nThe position in 1845 was that no exact elliptic orbit would fit the observed 6 over the whole stretch 1780 to 1840.[^1(3)] The discrepancies are very small, mostly a few seconds of arc (with a sudden swoop of about 90\",see Tablel). The ratio $m$ of $N$'s mass to that of $S$ (taken as 1) is actually about 1/19000\n(the Orders of magnitude fit since m radians is about 11\").\n\n[^1(3)]: Observations after 1840 were not immediately available, and anyhow\nwere not used. Uranus was discovered in 1781. Lest the reader should be worried by small inconsistencies in my dates I mention that 1780 is 'used', the extrapolation being a safe one.\n\nIn the absence of $N$ the a.m. $A$ is constant (as stated above alias of Kepler's second law); ***the actual $N$ accelerates $A$ at times earlier than $t_{0}$ and decelerates it at later times***. The graph of $A$ against $t$ therefore rises to a maximum at $t=t_{0}$, and my first idea was that this would identify. So it would if all observations were without error (and the method would have the theoretical advantage of being unaffected by the eccentricities). But the value of $A$ at time $t$ depends on the $r$ at time $t$, and the determinations of the $A$'s are consequently too uncertain. Though the method fails it rises from the ashes in another form. For this a few more preliminaries are needed.\n\n\nThe numerical data Adams and le Verrier had to work on were not the observed\n$\\theta$'s themselves, but the differences between the observed $\\theta(t)$ and the $\\theta_{B}(t)$ of an elliptic orbit calculated by Bouvard; the 'discrepancy' $\\delta(t)$ ($\\delta$ for short) is $\\delta(t)=\\theta(t)-\\theta_{B}(t)$. [$\\theta_{B} (t)$ depends on the 'elements' of $E_{B}$, and these are subject to 'errors'. These errors are among the unknowns that the perturbation theory has to determine: our method does not mind what they are, as we shall see.] Table I gives the raw $S$'s (given in Adams's paper[^2(3)]), together with the values got by running\na smooth curve. The treatment of the start of the sudden swoop down after the long flat stretch is a bit uncertain: I drew my curve and stuck to it (but faking would make no ultimate difference). The differences show up the order of the observational errors (which naturally improve with the years something seems to have gone badly wrong in 1789); these are absolute, not relative (thus the probable\nabsolute error in $\\delta_{1} - \\delta_{2}$ is the same whether $\\delta_{1} - \\delta_{2}$ is 0.5\" or 90\"). It is worth while to work to 0.1\" and to the number\nof decimal places used in what follows, even though the last place is doubtful.\n\n[^2(3)]: ***Collected Works, I***, p. 11. These (and not the modifications he\nintroduces, which are what appear in Smart) are what is relevant for us.\n\n\n\n| Year | Observed $\\delta$ | Smooth Curve | Year | Observed $\\delta$ | Smooth Curve |\n| :---: | :-------------: | :------------: | :---: | :------------: | :--------------: |\n| 1780 | 3.5 | 3.5 | 1813 | 22.0 | 22.8 |\n| 1783 | 8.5 | 8.5 | 1816 | 22.9 | 22.5 |\n| 1786 | 12.4 | 12.5 | 1819 | 20.7 | 22.0 |\n| 1789 | 19.0 | 15.8 | 1822 | 21.0 | 21.0 |\n| 1792 | 18.7 | 18.3 | 1825 | 18.2 | 18.1 |\n| 1795 | 21.4 | 20.3 | 1828 | 10.8 | 10.3 |\n| 1798 | 21.0 | 21.6 | 1831 | -4.0 | -4.0 |\n| 1801 | 22.2 | 22.4 | 1834 | -20.8 | -20.8 |\n| 1804 | 24.2 | 22.8 | 1837 | -42.7 | -42.5 |\n| 1807 | 22.1 | 23.0 | 1840 | -66.6 | -66.6 |\n| 1810 | 23.2 | 23.0 | 1843(e) | $-$ | -94.0 |\n\nTable 1\n\nThe value for 1843 is an extrapolation; results derived from it are labelled '(e)'.\n\nAn 'effect' due to $N$ is of 'order $m$ in mathematical notation $O(m)$; if, for a particular quantity $X$, \\Delta X$ denotes (calculated $X$)  (observed $X$), then any $\\Delta X$ is $O(m)$. The square of this (2nd order of infinitesimals) is\nextremely minute and everyone neglects it instinctively (if $a$ watch loses 10 seconds a day you don't try to correct for the further loss over the lost 10 seconds the cases are comparable). Next, an effect of $N$ is what it would be if $U$, and also $N$, moved in circles, ***plus*** a 'correction' for the actual eccentricities of the orbits. $U$'s eccentricity $e(\\frac{1}{20})$ is unusually large and it would be reasonable to expect $N$'s to be no larger (it is actually less than $\\frac{1}{100}$). The $e$'s distort the 'circular' value of the effect by 5 per cent, (or say a maximum of 10 per cent.); the 'distortion' of the effect\nis $O(em)$, the effect itself being $O(m)$. I propose to ignore things of order $O(em)$[^1(4)]: this is the first step in my argument. In particular, when we have something which is either some $\\Delta$, or $m$ itself, multiplied by a factor, we can substitute first approximations (i.e. with $e=0$), or make convenient changes that are $O(e)$, in the factor.\n\n\n[^1(4)]: I should stress that there is no question of ignoring even high powers\nof $e$ ***unaccompanied by a factor $m$*** ($e^{4}$ radians is about 1\"). The distortion in the value found for $t$ is, however, a sort of exception to\nthis. But the effect of $e$'s in distorting $t_{0}$ is unlikely to be worse than the separation they create between time of conjunction and time of closest approach. An easy calculation shows that this last time difference\nis at worst 0-8 years.\n\n\nSuppose now that $E_{l}, E_{2}$ are two (exact) elliptic orbits, yielding\n$\\theta(t)$'s that differ by amounts of the kind we are concerned with, differing, that is, by $O(m)$.[^2(4)] It is now the case that the differences satisfy the equation\n\n$$\\begin{equation}\n\\theta_{1} - \\theta_{2} = m( a + bt + c \\cos nt + d \\sin nt) + O(em)\n\\end{equation}$$\n\nwhere $a, b, c, d$ are constants depending on the two sets of elements of $E_{1}, E_{2}$, and (following our agreement about ***factors*** of $m$) $n$ is any common approximation to the mean angular velocity. I will postpone the school mathentatics\nproof of this.\n\n\n[^2(4)]: The orbits may have 'Suns' of masses differing by $O(m)$.\n\nNext, (i) let $E^{*}$ be the 'instantaneous orbit at time $t_{0}$', that is to say the orbit that $U$ would describe if $N$ were annihilated at time $t_{0}$: note that $E^{*}$ shares with $t_{0}$ the property of being 'unknown'. (ii) Let $\\vartheta$ be the perturbation of the $\\theta$ of $U$ produced by $N$ since time\n$t_{0}$.[^3(4)] Then if, at any time $t$, $\\theta$ is (as usual) $U$'s longitude, $\\theta_{B}$ is the longitude in the orbit $E_{B}$, and $\\theta^{*}$ the longitude in the orbit $E^{*}$, we have $\\vartheta = \\theta - \\theta^{*}$, and so\n\n$$\\begin{equation}\n\\delta(t) = \\theta - \\theta_{B} = (\\theta^{*} - \\theta_{B}) + \\vartheta\n\\end{equation}$$\n\nNow everything in this has a factor $m$, and we may omit any stray $O(em)$'s.\nIn particular, we may in calculating $\\vartheta$ drop any $e$ terms. But this means that ***we can calculate $\\vartheta$ as if both $U$'s and $N$'s orbits were circles***. When, however, the orbits are circles, ***$\\vartheta$ has equal and opposite values at $t$'s on equal and opposite sides of $t_{0}$***; in other words, ***if we write $t=t_{0} + \\tau$, then***\n\n$$\\begin{equation}\n\\vartheta(t) = \\Omega (\\tau)\n\\end{equation}$$\n\n***where $\\Omega (\\tau)$ is an odd[^1(5)] function of $\\tau$; i.e. $\\Omega(-\\tau)= -\\Omega(\\tau)$.***\n\n\n\n[^3(4)]: We allow, of course, ***negative*** values of $t - t_{0}$ both in $E^{*}$ and in $\\vartheta$.\n\n[^1(5)]: '$\\Omega$' is a deputy for '$O$' (initial of 'odd'), which is otherwise engaged. The italicized statement in the text is true 'by symmetry': alternatively, ***reverse*** the motions from time $t_{0}$. (The argument covers also the 'perturbation of 'the Sun' which is not so completely negligible as\nmight be supposed.)\n\n\nThis, used in combination with (1) and (2), is the essential (and very simple) point of the argument. The difference $\\theta^{*} - \\theta_{B}$ is a special case of $\\theta_{1} - \\theta_{2}$ in (1). Write $t=t_{0} + \\tau$ in (1) and combine this with (2) and (3); this gives, ignoring $O(em)$'s,\n\n$$\\delta(t_{0} + \\tau) = m \\left\\{a + b t_{0} + b \\tau + c \\cos (nt_{0} + n \\tau) + d \\sin (nt_{0} + n \\tau) \\right\\} + \\Omega(\\tau)$$\n\nExpanding the $\\cos$ and $\\sin$ of sums and rearranging we have (with new constants, whose values vary with but do not concern us)\n\n$$\\delta(t_{0} + \\tau) = A - B(1 - \\cos n\\tau) + \\left\\{C \\tau + D \\sin n\\tau + \\Omega(\\tau)\\right\\}$$\n\n***The curly bracket is an odd function of $\\tau$***. Hence if we combine\nequal and opposite $\\tau$ and construct $\\delta^{*}(\\tau)$ and $\\rho(\\tau)$ to satisfy\n\n$$\\delta^{*}(\\tau) = - \\frac{1}{2} \\left\\{\\delta(t_{0}+\\tau) + \\delta(t_{0}- \\tau) - 2 \\delta(t_{0}) \\right\\}, \\rho(\\tau) = \\delta^{*}(\\tau)/(1-\\cos n\\tau)$$\n\nwe have $\\delta^{*}(\\tau)=B( 1 - \\cos n\\tau)$, and so $\\rho(\\tau)=B $ for all $\\tau$. ***If, then, we are using the right $t_{0}$ the ratio p(r) must come out constant***: this is our method for identifying $t_{0}$. The actual value of $t_{0}$ to the nearest year is 1822.\n\nTable II, in which the unit of time is 1 year (and the $n$ of $\\cos n\\tau$ is $2\\pi/84$), shows the results of trying various (the century is omitted from the dates). The last place of decimals for the $\\rho(\\tau)$ is not reliable, but of course gets better as the size of the entry $2\\delta^{*}(\\tau)$ increases: I give the numbers as they came, and they speak for themselves. $\\tau=6$ is included, though the proportionate error in $\\delta^{*}$ is then considerable.[^1(6)] For\n$t_{0}=13$ $\\rho$ goes on to 34.8 at $\\tau=27$; for $t_{0}=16$ it goes to 38.2 at $\\tau= 24$. Once the data the smooth curve values were assembled the calculations took a mere hour or so with a slide-rule. The date 1822-4 seems about the 'best' $t_{0}$.\n\n[^1(6)]: And the, values for $\\tau=6$ at $t_{0}=22, 22.4$ are more uncertain than usual because of a crisis in the smooth curve.\n\n<style>\n    body {text-align: center;} table{margin: auto;}\n</style>\n\n<table>\n    <tr>\n        <td> </td>\n        <td colspan=\"2\"> $t_{0} = 13$ </td>\n        <td colspan=\"2\"> $t_{0} = 16$ </td>\n        <td colspan=\"2\"> $t_{0} = 19$ </td>\n        <td colspan=\"2\"> $t_{0} = 22$ </td>\n        <td colspan=\"2\"> $t_{0} = 22.4$ </td>\n        <td colspan=\"2\"> $t_{0} = 25$ </td>\n        <td colspan=\"2\"> $t_{0} = 28$ </td>\n    </tr>\n    <tr>\n        <td> $\\tau$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n    </tr>\n    <tr>\n        <td> 6 </td>\n        <td> 0.6 </td>\n        <td> 3.0 </td>\n        <td> 1.0 </td>\n        <td> 5.1 </td>\n        <td> 3.6 </td>\n        <td> 18.3 </td>\n        <td> 9.2 </td>\n        <td> 47.0 </td>\n        <td> 10.6 </td>\n        <td> 53.8 </td>\n        <td> 18.2 </td>\n        <td> 92.5 </td>\n        <td> 20.4 </td>\n        <td> 103 </td>\n    </tr>\n    <tr>\n        <td> 9 </td>\n        <td> 1.8 </td>\n        <td> 4.1 </td>\n        <td> 3.9 </td>\n        <td> 9.0 </td>\n        <td> 10.7 </td>\n        <td> 24.6 </td>\n        <td> 23.2 </td>\n        <td> 53.3 </td>\n        <td> 25.0 </td>\n        <td> 57.6 </td>\n        <td> 34.5 </td>\n        <td> 79.3 </td>\n        <td> 41.1 </td>\n        <td> 94 </td>\n    </tr>\n    <tr>\n        <td> 12 </td>\n        <td> 5.3 </td>\n        <td> 7.6 </td>\n        <td> 11.9 </td>\n        <td> 15.8 </td>\n        <td> 25.0 </td>\n        <td> 33.2 </td>\n        <td> 39.8 </td>\n        <td> 53.0 </td>\n        <td> 42.2 </td>\n        <td> 56.1 </td>\n        <td> 55.9 </td>\n        <td> 74.4 </td>\n        <td> 64.7 </td>\n        <td> 86 </td>\n    </tr>\n    <tr>\n        <td> 15 </td>\n        <td> 13.7 </td>\n        <td> 12.1 </td>\n        <td> 26.6 </td>\n        <td> 23.5 </td>\n        <td> 42.0 </td>\n        <td> 37.1 </td>\n        <td> 61.5 </td>\n        <td> 54.4 </td>\n        <td> 64.0 </td>\n        <td> 56.5 </td>\n        <td> 79.8 </td>\n        <td> 70.5 </td>\n        <td> 91(e) </td>\n        <td> 80.6(e) </td>\n    </tr>\n    <tr>\n        <td> 18 </td>\n        <td> 29.3 </td>\n        <td> 18.8 </td>\n        <td> 44.2 </td>\n        <td> 28.4 </td>\n        <td> 64.1 </td>\n        <td> 41.2 </td>\n        <td> 85.8 </td>\n        <td> 55.2 </td>\n        <td> 88.6 </td>\n        <td> 57.0 </td>\n        <td> 106(e) </td>\n        <td> 86.3(e) </td>\n        <td> $-$ </td>\n        <td> $-$ </td>\n    </tr>\n    <tr>\n        <td> 21 </td>\n        <td> 48.3 </td>\n        <td> 24.1 </td>\n        <td> 67.2 </td>\n        <td> 36.6 </td>\n        <td> 89.0 </td>\n        <td> 45.5 </td>\n        <td> 113(e) </td>\n        <td> 56.5(e) </td>\n        <td> 116(e) </td>\n        <td> 58.0(e) </td>\n        <td> $-$ </td>\n        <td> $-$ </td>\n        <td> $-$ </td>\n        <td> $-$ </td>\n    </tr>\n    <caption> Table II </caption>\n</table>\n\nWe need fairly large $\\tau$ for $\\delta^{*}(\\tau)$ to have enough ignificant figures, and further to provide a range showing up whether\n$\\rho(\\tau)$ is constant or not. And we need room to manoeuvre round the final. So the method depends on the 'luck' that 1822 falls comfortably inside the period of observation 1780-1840. But some luck was needed in any case.\n\n\nIt is an important point that the method is quite indifferent to how well $E_{B}$ does its originally intended job, and ***we do not need to know (and I don't knoiv) its elements***; it is enough to know the 'discrepancy' with ***some***, 'unknown', orbit (not too bad of course). On the other hand the method ostentatiously says nothing at all about the mass or distance of $N$. I will add something on this. With $e$-terms ignored $\\vartheta(\\tau)/m$ can be calculated ***exactly*** for any given value of $\\lambda=a/a_{1}$ (ratio of the $a$'s of $U$ and $N$)[^2(6)] The idea would be to try different $A$'s, each $A$ to give a best fitting $m$, and to take the best fitting ***pair*** $\\lambda, m$. This fails, because the greater part of $\\vartheta$ is of the form $b^{\\prime}(n\\tau - \\sin n\\tau)$, and $b^{\\prime}$ is smothered by the $a, b, c, d$ of $\\theta^{*} - \\theta_{B}$, which depend on the unknown elements of $E_{B}$ ($\\vartheta$ is smothered by the 'unknown' $\\theta^{*} - \\theta_{B}$). If we knew these elements (or equivalently the raw $\\theta$) we might be able to go on. They could be recovered from the Paris Observatory archives; but\nthis article is a last moment addition to the book, I do not feel that I am on full professional duty, and in any case we should be losing the\nlight-hearted note of our adventure.\n\n\n\n[^2(6)]: From two second order differential equations. The formula involves 'quadratures', but in numerical calculation integration\nis quicker than multiplication. It would be comparatively easy to make a double entry table for $\\vartheta(\\tau, \\lambda)/m$\n\n\n\n\nThe time $t$ once known, it would be necessary to guess a value for $N$'s distance $a_{1}$; $N$'s period is then $84(a_{1}/a)^{\\frac{3}{2}}$ years, and we could 'predict' $N$'s place in 1846. The obvious first guess in 1846 was $a_{l}/a=2$, following Bode's empirical law, to which N is maliciously the first exception, the true value being\n1.58. Adams and le Verrier started with 2 (Adams coming down to 1.942 for a second round). Since from our standpoint[^1(7)] too large an\n$a_{1}$ has disproportionately bad results as against one too small,\nit would be reasonable to try 1.8. This would give a prediction (for 1846) about 10$^{\\circ}$ out, but the sweep needed would be wholly practicable.\n\n\n[^1(7)]: Perturbation theory calculations have necessarily to ***begin*** by guessing $a_{1}$; our guess need only be at the end.\n\n\nLe Verrier was less than 1$^{\\circ}$ out (Adams between 2$^{\\circ}$ and 3$^{\\circ}$); 'they pointed the telescope and saw the planet'.\nThis very close, and double, prediction is a curiosity. All the observations from 1780 to 1840 were used, and on an equal footing, and the theory purported to say where $N$ was over this whole stretch.\nWith a wrong $a_{1}$ they could be right at 1840 only by being wrong at 1780. With Adams's $a_{1}=1.94a$ $N$'s period (which depends on $a_{1}$ only) would be 227 years; he would have been wrong by 30$^{\\circ}$\nfor 1780 if the orbit were circular, and so the angular velocity uniform. But faced with a wrong $a_{1}$ the method responded gallantly\nby putting up a large eccentricity ($\\frac{1}{8}$), and assigning perihelion to the place of conjunction. The combination makes the effective distance from $S$ over the critical stretch more like\n$1.7 a_{l}$, and the resulting error at 1780 (the worst one) was only 18. (A mass 2.8 times too large was a more obvious adjustment.)\n\n\nIn much more recent times small discrepancies for $N$ and $U$ ($U$'s being in fact the more manageable ones) were analysed for a trans-Neptunian planet, and the planet Pluto was found in 1930 near the predicted place. This was a complete fluke: Pluto has a mass probably no more than $\\frac{1}{10}$ of the Earth's; any effects\nit could have on $N$ and $U$ would be hopelessly swamped by the observational errors.\n\nIt remains for me to give the (school mathematics) proof of (1) above.\nCall $e_{1} - e_{2}$ $\\Delta e$, and so on. I said above that all $\\Delta$'s were $O(m)$: this is not quite true, though my deception has been in the reader's best interests, and will not have led him astray.[^1(8)] It is true, and common sense, for $\\Delta a$, $\\Delta e$, $\\Delta n$, and $\\Delta \\epsilon$. But the 'effect' of a given Aa vanishes when $e=0$, and is proportional to $e$. So it is $e\\Delta \\alpha$, not $\\Delta \\alpha$, that is comparable with the other $\\Delta$'s and so $O(m)$.[^2(8)]\n\n\n\n[^1(8)]: 'Wen Gott betrugt is wohl betrogon.'\n\n[^2(8)]: This twist makes the 'obvious' approach of using the\nweil known expansion\n$$\\theta = nt +\\epsilon + 2e \\sin (nt + \\epsilon -a) + \\frac{5}{4}e^{2} \\sin 2 (nt + \\epsilon -a ) + \\cdots$$\nslightly tricky; we should have to keep the term in $e^{2}$. The line taken in the text side-steps this.\n\n\n\n\n\nWe start from two well-known formulae. The first is geometrical; the polar equation of the ellipse of the orbit is\n\n$$\\begin{equation}\nr = a(1- e^{2}) ( 1 +e \\cos (\\theta -a))^{-1}\n\\end{equation}$$\n\n\n\nThe second is dynamical; the equation of angular momentum (Kepler's second law) is\n\n$$\\begin{equation}r^{2} \\frac{d\\theta}{dt} = na^{2} (1-e^{2})^{\\frac{1}{2}}\\end{equation}$$\n\n\n\nSo, using dots for time differentiations,\n\n\n$$\\begin{equation}\n\\theta = n(1-e^{2})^{-\\frac{3}{2}} [1 - 2\\cos (\\theta -a) + 3e^{2} \\cos^{2} (\\theta -a ) + \\cdots]\n\\end{equation}$$\n\n\nThe first approximation (with $e=0$) is $\\theta=nt + \\epsilon$. We take\nsuffixes 1 and 2 in (6) and operate with $\\Delta$, remembering that we may take first approximations in any ***factor*** of an $m$.\n\n\nIn estimating $\\Delta\\theta$ we may, with error $O(em)$, ignore the\nfactor $(1-e^{2})^{-\\frac{3}{2}}$ in (6), since it is itself $\\left(1+O(e^{2})\\right)$, and its $\\Delta$ is $O(e\\Delta e)=O(em)$. We have, therefore, with error $O(em)$,\n\n$$\\Delta \\theta = \\Delta \\left\\{n[\\quad ]\\right\\} = [\\quad ] \\Delta n + n \\Delta [\\quad ]$$\n\nThe 1st term is $\\Delta n+O(em)$. The 2nd is\n\n$$n\\left[\\Delta e \\left\\{- 2 \\cos(\\theta -a ) + O(e)\\right\\} + \\Delta (\\theta -a ) \\left\\{2e \\sin (\\theta -a ) + O(e^{2}\\right\\}\\right]$$\n\nand we may drop the $\\theta$ in $\\Delta (\\theta - a)$ on account of the factor $O(\\epsilon)$. Summing up, we obtain\n\n$$\\Delta \\theta = m (A+B \\cos (\\theta -a ) + C \\sin (\\theta -a ) ) + O(em)$$\n\nwhere $mA=\\Delta n$, $mB = -2n\\Delta e$, $mC = -2n(e\\Delta a)$. Substituting the first approximation $\\theta=nt + \\epsilon$ in the right hand side, we have\n\n$$\\Delta \\theta = m (A+B \\cos (nt + \\epsilon -a ) + C \\sin (nt + \\epsilon -a ) ) + O(em)$$\n\n\nand integration then gives\n\n\n\n$$\\Delta \\theta = m (A+B/n \\sin (nt + \\epsilon -a ) - C/n \\cos (nt + \\epsilon -a ) ) + O(em)$$\n\n\n\nwhich, after expanding the sin and cos and rearranging, is of the desired form (I).[^1(9)]\n\n\n\n[^1(9)]: We have treated $\\Delta n$ and $\\Delta a$ as independent (the latter happens not to occur in the final formula for $\\Delta \\theta$): this amounts to allowing different masses to the two 'Suns'. The point is relevant to certain subtleties, into which I will not enter.\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"The Discovery of Neptune","published":1,"updated":"2023-12-31T07:46:06.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisunm000veslrhi4y162t","content":"<p>Neptune was discovered in 1846 as a result of mathematical\r\ncalculation, done independently and practically simultaneously by Adams\r\nand le Verrier. The full story abounds in unexpected twists, and is\r\ncomplicated by personal matters, some of them rather painful. There is a\r\nfascinating account in Professor W. M. Smart's <strong><em>John Couch\r\nAdams and the Discovery of Neptune</em></strong>, published by the Royal\r\nAstronomical Society, 1947. I am concerned only with limited parts of\r\nthe field.</p>\r\n<p>To refresh the reader's memory of what has been said from time to\r\ntime about the discovery I will begin with some representative\r\nquotations. In <strong><em>The Story of the Heavens</em></strong> (1886)\r\nSir Robert Ball has passages:' the name of le Verrier rose to a pinnacle\r\nhardly surpassed in any age or country' ... 'profound meditations for\r\nmany months' ... 'long tand arduous labour guided by consummate\r\nmathematical artifice'. The author is not above a bit of popular appeal\r\nin this book  'if the ellipse has not the perfect simplicity of the\r\ncircle, it has at least the charm of variety ... an outline of perfect\r\ngrace, and an association with ennobling conceptions'  but on Neptune\r\nhe is speaking as a professional. An excellent modern book on the\r\nhistory of astronomy has, so late as 1938:' probably the most daring\r\nmathematical enterprise of the century ... this amazing task, like which\r\nnothing had ever been attempted before'.</p>\r\n<p>The immediate reaction was natural enough. Celestial Mechanics in\r\ngeneral, and the theory of perturbations in particular, had developed\r\ninto a very elaborate and high-brow subject; the problem of explaining\r\nthe misbehaviour of Uranus by a new planet was one of 'inverse' theory,\r\nand the common feeling was that the problem was difficult up to or\r\nbeyond the point of impossibility. One might speculate at some length on\r\nreasons for this opinion (one, perhaps was confusion between different\r\nmeanings of the technica term 'insoluble'<a href=\"#fn1\"\r\nclass=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a>).\r\nWhen Adams and le Verrier provec the opinion wrong (and after all\r\n<strong><em>any</em></strong> mathematical proof is a debunking of\r\nsorts) there was still something to be said for the principle that\r\ndifficulties are what they seem before the event, not after. Certainly\r\nno one would grudge them their resounding fame. (Nor grudge, at a lower\r\nlevel, the luck of a discovery which makes a more sensational impact\r\nthan its actual difficulty strictly merits; in point of fact this luck\r\nnever does happen to the second-rate.) If the discovery has had a very\r\nlong run one must remember that there is a time-lag ; people cannot be\r\nalways reconsidering opinions, and having said something once even the\r\nmost intelligent tend to go on repeating it. The phrase was still in\r\nvogue that 'only 3 people understand Relativity' at a time when\r\nEddington was complaining that the trouble about Relativity as an\r\nexamination subject in 'Part III' was that it was such a soft\r\noption.</p>\r\n<p>In what I am going to say I am far from imputing stupidity to people\r\ncertainly less stupid than myself. My little <strong><em>jeuz\r\nd'esprit</em></strong> are not going to hurt anyone, and I refuse to be\r\ndeterred by the fear of being thought disrespectful to great men. I have\r\nnot been alone in a lurking suspicion that a much simpler approach might\r\nsucceed. On the one hand, aim at the minimum needed to make\r\nobservational discovery practicable; specifically at the time <span\r\nclass=\"math inline\">\\(t_{0}\\)</span> of conjunction.<a href=\"#fn2\"\r\nclass=\"footnote-ref\" id=\"fnref2\" role=\"doc-noteref\"><sup>2</sup></a> On\r\nthe other, forget the high-brow and laborious perturbation theory, and\r\ntry 'school mathematics'. (I admit to the human weakness of being\r\nspurred on by the mild piquancy success would have.) To begin with I\r\nfound things oddly elusive (and incidentally committed some gross\r\nstupidities). In the end an absurdly simple line emerged: I can imagine\r\nits being called a dirty trick, nor would I deny that there is some\r\ntruth in the accusation. The only way to make my case is to carry out\r\nthe actual 'prediction' of <span class=\"math inline\">\\(t_{0}\\)</span>\r\nfrom the observational data, with all the cards on the table (so that\r\nanyone can check against unconscious or conscious faking). I will also\r\nwrite so as to take as many amateurs as possible with me on the little\r\nadventure.</p>\r\n<p>A planetary 'orbit' is an ellipse with the Sun <span\r\nclass=\"math inline\">\\(S\\)</span> at a focus, and the radius vector <span\r\nclass=\"math inline\">\\(SP\\)</span> sweeps out area at a constant rate\r\n(Kepler's second law). An orbit, given its plane, is defined by 4\r\nelements, <span class=\"math inline\">\\(a\\)</span>, <span\r\nclass=\"math inline\">\\(e\\)</span>, <span\r\nclass=\"math inline\">\\(\\alpha\\)</span>, <span\r\nclass=\"math inline\">\\(\\epsilon\\)</span>. The first 3 define the\r\ngeometrical ellipse: <span class=\"math inline\">\\(a\\)</span> is the\r\nsemi-major axis; <span class=\"math inline\">\\(e\\)</span> the\r\neccentricity; <span class=\"math inline\">\\(\\alpha\\)</span> the longitude\r\nof perihelion, i.e. with the obvious polar coordinates <span\r\nclass=\"math inline\">\\(r, \\theta\\)</span>, <span\r\nclass=\"math inline\">\\(\\theta\\)</span> is the 'longitude' and <span\r\nclass=\"math inline\">\\(\\theta=a\\)</span> when <span\r\nclass=\"math inline\">\\(P\\)</span> is nearest <span\r\nclass=\"math inline\">\\(S\\)</span> (at an end of the major axis). When we\r\nknow <span class=\"math inline\">\\(a\\)</span> we know the 'mean angular\r\nvelocity' <span class=\"math inline\">\\(n\\)</span> and the associated\r\nperiod <span class=\"math inline\">\\(p= 2 \\pi/n\\)</span>; <span\r\nclass=\"math inline\">\\(n\\)</span> is in fact proportional to <span\r\nclass=\"math inline\">\\(a^{-\\frac{1}{2}}\\)</span> (Kepler's third law)<a\r\nhref=\"#fn3\" class=\"footnote-ref\" id=\"fnref3\"\r\nrole=\"doc-noteref\"><sup>3</sup></a>; further the constant rate of area\r\nsweeping is <span class=\"math inline\">\\(\\frac{1}{2}abn\\)</span><a\r\nhref=\"#fn4\" class=\"footnote-ref\" id=\"fnref4\"\r\nrole=\"doc-noteref\"><sup>4</sup></a> and twice this rate is identical\r\nwith the angular momentum'<a href=\"#fn5\" class=\"footnote-ref\"\r\nid=\"fnref5\" role=\"doc-noteref\"><sup>5</sup></a> (a.m. for short); this\r\nhas the differential calculus formula <span\r\nclass=\"math inline\">\\(r^{2}\\theta\\)</span>, and it also is of course\r\nconstant. The 4th element, the 'epoch' <span\r\nclass=\"math inline\">\\(e\\)</span>, is needed to identify the origin of\r\n<span class=\"math inline\">\\(t\\)</span>; the exact definition is that\r\n<span class=\"math inline\">\\(\\theta= \\alpha\\)</span> (perihelion) occurs\r\nat the <span class=\"math inline\">\\(t\\)</span> for which <span\r\nclass=\"math inline\">\\(nt+ \\epsilon = \\alpha\\)</span>.</p>\r\n<p><span class=\"math inline\">\\(U\\)</span>'s orbit has a period of 84\r\nyears, and an eccentricity <span class=\"math inline\">\\(e\\)</span> of\r\nabout <span class=\"math inline\">\\(\\frac{1}{20}\\)</span>. The effects of\r\nbodies other than <span class=\"math inline\">\\(S\\)</span> and <span\r\nclass=\"math inline\">\\(N\\)</span> can be allowed for, after which we may\r\nsuppose that <span class=\"math inline\">\\(U\\)</span>, <span\r\nclass=\"math inline\">\\(S\\)</span>, and the eventual <span\r\nclass=\"math inline\">\\(N\\)</span> are the only bodies in the system; we\r\nmay also suppose (all this is common form) that the movements are all in\r\none plane. The values of <span class=\"math inline\">\\(\\theta\\)</span>\r\n(for <span class=\"math inline\">\\(U\\)</span>) at the various times <span\r\nclass=\"math inline\">\\(t\\)</span> (we sometimes write <span\r\nclass=\"math inline\">\\(\\theta(t)\\)</span> to emphasize that <span\r\nclass=\"math inline\">\\(\\theta\\)</span> is 'at time <span\r\nclass=\"math inline\">\\(t\\)</span>') may be regarded as the observational\r\nraw material (though of course the actual raw observations are made from\r\nthe Earth). The <span class=\"math inline\">\\(r\\)</span>'s for the various\r\n<span class=\"math inline\">\\(t\\)</span> are indirect and are much less\r\nwell determined.</p>\r\n<p>The position in 1845 was that no exact elliptic orbit would fit the\r\nobserved 6 over the whole stretch 1780 to 1840.<a href=\"#fn6\"\r\nclass=\"footnote-ref\" id=\"fnref6\" role=\"doc-noteref\"><sup>6</sup></a> The\r\ndiscrepancies are very small, mostly a few seconds of arc (with a sudden\r\nswoop of about 90\",see Tablel). The ratio <span\r\nclass=\"math inline\">\\(m\\)</span> of <span\r\nclass=\"math inline\">\\(N\\)</span>'s mass to that of <span\r\nclass=\"math inline\">\\(S\\)</span> (taken as 1) is actually about 1/19000\r\n(the Orders of magnitude fit since m radians is about 11\").</p>\r\n<p>In the absence of <span class=\"math inline\">\\(N\\)</span> the a.m.\r\n<span class=\"math inline\">\\(A\\)</span> is constant (as stated above\r\nalias of Kepler's second law); <strong><em>the actual <span\r\nclass=\"math inline\">\\(N\\)</span> accelerates <span\r\nclass=\"math inline\">\\(A\\)</span> at times earlier than <span\r\nclass=\"math inline\">\\(t_{0}\\)</span> and decelerates it at later\r\ntimes</em></strong>. The graph of <span class=\"math inline\">\\(A\\)</span>\r\nagainst <span class=\"math inline\">\\(t\\)</span> therefore rises to a\r\nmaximum at <span class=\"math inline\">\\(t=t_{0}\\)</span>, and my first\r\nidea was that this would identify. So it would if all observations were\r\nwithout error (and the method would have the theoretical advantage of\r\nbeing unaffected by the eccentricities). But the value of <span\r\nclass=\"math inline\">\\(A\\)</span> at time <span\r\nclass=\"math inline\">\\(t\\)</span> depends on the <span\r\nclass=\"math inline\">\\(r\\)</span> at time <span\r\nclass=\"math inline\">\\(t\\)</span>, and the determinations of the <span\r\nclass=\"math inline\">\\(A\\)</span>'s are consequently too uncertain.\r\nThough the method fails it rises from the ashes in another form. For\r\nthis a few more preliminaries are needed.</p>\r\n<p>The numerical data Adams and le Verrier had to work on were not the\r\nobserved <span class=\"math inline\">\\(\\theta\\)</span>'s themselves, but\r\nthe differences between the observed <span\r\nclass=\"math inline\">\\(\\theta(t)\\)</span> and the <span\r\nclass=\"math inline\">\\(\\theta_{B}(t)\\)</span> of an elliptic orbit\r\ncalculated by Bouvard; the 'discrepancy' <span\r\nclass=\"math inline\">\\(\\delta(t)\\)</span> (<span\r\nclass=\"math inline\">\\(\\delta\\)</span> for short) is <span\r\nclass=\"math inline\">\\(\\delta(t)=\\theta(t)-\\theta_{B}(t)\\)</span>. [<span\r\nclass=\"math inline\">\\(\\theta_{B} (t)\\)</span> depends on the 'elements'\r\nof <span class=\"math inline\">\\(E_{B}\\)</span>, and these are subject to\r\n'errors'. These errors are among the unknowns that the perturbation\r\ntheory has to determine: our method does not mind what they are, as we\r\nshall see.] Table I gives the raw <span\r\nclass=\"math inline\">\\(S\\)</span>'s (given in Adams's paper<a href=\"#fn7\"\r\nclass=\"footnote-ref\" id=\"fnref7\" role=\"doc-noteref\"><sup>7</sup></a>),\r\ntogether with the values got by running a smooth curve. The treatment of\r\nthe start of the sudden swoop down after the long flat stretch is a bit\r\nuncertain: I drew my curve and stuck to it (but faking would make no\r\nultimate difference). The differences show up the order of the\r\nobservational errors (which naturally improve with the years something\r\nseems to have gone badly wrong in 1789); these are absolute, not\r\nrelative (thus the probable absolute error in <span\r\nclass=\"math inline\">\\(\\delta_{1} - \\delta_{2}\\)</span> is the same\r\nwhether <span class=\"math inline\">\\(\\delta_{1} - \\delta_{2}\\)</span> is\r\n0.5\" or 90\"). It is worth while to work to 0.1\" and to the number of\r\ndecimal places used in what follows, even though the last place is\r\ndoubtful.</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 7%\" />\r\n<col style=\"width: 21%\" />\r\n<col style=\"width: 20%\" />\r\n<col style=\"width: 7%\" />\r\n<col style=\"width: 20%\" />\r\n<col style=\"width: 23%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">Year</th>\r\n<th style=\"text-align: center;\">Observed <span\r\nclass=\"math inline\">\\(\\delta\\)</span></th>\r\n<th style=\"text-align: center;\">Smooth Curve</th>\r\n<th style=\"text-align: center;\">Year</th>\r\n<th style=\"text-align: center;\">Observed <span\r\nclass=\"math inline\">\\(\\delta\\)</span></th>\r\n<th style=\"text-align: center;\">Smooth Curve</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1780</td>\r\n<td style=\"text-align: center;\">3.5</td>\r\n<td style=\"text-align: center;\">3.5</td>\r\n<td style=\"text-align: center;\">1813</td>\r\n<td style=\"text-align: center;\">22.0</td>\r\n<td style=\"text-align: center;\">22.8</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1783</td>\r\n<td style=\"text-align: center;\">8.5</td>\r\n<td style=\"text-align: center;\">8.5</td>\r\n<td style=\"text-align: center;\">1816</td>\r\n<td style=\"text-align: center;\">22.9</td>\r\n<td style=\"text-align: center;\">22.5</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1786</td>\r\n<td style=\"text-align: center;\">12.4</td>\r\n<td style=\"text-align: center;\">12.5</td>\r\n<td style=\"text-align: center;\">1819</td>\r\n<td style=\"text-align: center;\">20.7</td>\r\n<td style=\"text-align: center;\">22.0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1789</td>\r\n<td style=\"text-align: center;\">19.0</td>\r\n<td style=\"text-align: center;\">15.8</td>\r\n<td style=\"text-align: center;\">1822</td>\r\n<td style=\"text-align: center;\">21.0</td>\r\n<td style=\"text-align: center;\">21.0</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1792</td>\r\n<td style=\"text-align: center;\">18.7</td>\r\n<td style=\"text-align: center;\">18.3</td>\r\n<td style=\"text-align: center;\">1825</td>\r\n<td style=\"text-align: center;\">18.2</td>\r\n<td style=\"text-align: center;\">18.1</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1795</td>\r\n<td style=\"text-align: center;\">21.4</td>\r\n<td style=\"text-align: center;\">20.3</td>\r\n<td style=\"text-align: center;\">1828</td>\r\n<td style=\"text-align: center;\">10.8</td>\r\n<td style=\"text-align: center;\">10.3</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1798</td>\r\n<td style=\"text-align: center;\">21.0</td>\r\n<td style=\"text-align: center;\">21.6</td>\r\n<td style=\"text-align: center;\">1831</td>\r\n<td style=\"text-align: center;\">-4.0</td>\r\n<td style=\"text-align: center;\">-4.0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1801</td>\r\n<td style=\"text-align: center;\">22.2</td>\r\n<td style=\"text-align: center;\">22.4</td>\r\n<td style=\"text-align: center;\">1834</td>\r\n<td style=\"text-align: center;\">-20.8</td>\r\n<td style=\"text-align: center;\">-20.8</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1804</td>\r\n<td style=\"text-align: center;\">24.2</td>\r\n<td style=\"text-align: center;\">22.8</td>\r\n<td style=\"text-align: center;\">1837</td>\r\n<td style=\"text-align: center;\">-42.7</td>\r\n<td style=\"text-align: center;\">-42.5</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1807</td>\r\n<td style=\"text-align: center;\">22.1</td>\r\n<td style=\"text-align: center;\">23.0</td>\r\n<td style=\"text-align: center;\">1840</td>\r\n<td style=\"text-align: center;\">-66.6</td>\r\n<td style=\"text-align: center;\">-66.6</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1810</td>\r\n<td style=\"text-align: center;\">23.2</td>\r\n<td style=\"text-align: center;\">23.0</td>\r\n<td style=\"text-align: center;\">1843(e)</td>\r\n<td style=\"text-align: center;\"><span\r\nclass=\"math inline\">\\(-\\)</span></td>\r\n<td style=\"text-align: center;\">-94.0</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>Table 1</p>\r\n<p>The value for 1843 is an extrapolation; results derived from it are\r\nlabelled '(e)'.</p>\r\n<p>An 'effect' due to <span class=\"math inline\">\\(N\\)</span> is of\r\n'order <span class=\"math inline\">\\(m\\)</span> in mathematical notation\r\n<span class=\"math inline\">\\(O(m)\\)</span>; if, for a particular quantity\r\n<span class=\"math inline\">\\(X\\)</span>, X$ denotes (calculated <span\r\nclass=\"math inline\">\\(X\\)</span>)  (observed <span\r\nclass=\"math inline\">\\(X\\)</span>), then any <span\r\nclass=\"math inline\">\\(\\Delta X\\)</span> is <span\r\nclass=\"math inline\">\\(O(m)\\)</span>. The square of this (2nd order of\r\ninfinitesimals) is extremely minute and everyone neglects it\r\ninstinctively (if <span class=\"math inline\">\\(a\\)</span> watch loses 10\r\nseconds a day you don't try to correct for the further loss over the\r\nlost 10 seconds the cases are comparable). Next, an effect of <span\r\nclass=\"math inline\">\\(N\\)</span> is what it would be if <span\r\nclass=\"math inline\">\\(U\\)</span>, and also <span\r\nclass=\"math inline\">\\(N\\)</span>, moved in circles,\r\n<strong><em>plus</em></strong> a 'correction' for the actual\r\neccentricities of the orbits. <span class=\"math inline\">\\(U\\)</span>'s\r\neccentricity <span class=\"math inline\">\\(e(\\frac{1}{20})\\)</span> is\r\nunusually large and it would be reasonable to expect <span\r\nclass=\"math inline\">\\(N\\)</span>'s to be no larger (it is actually less\r\nthan <span class=\"math inline\">\\(\\frac{1}{100}\\)</span>). The <span\r\nclass=\"math inline\">\\(e\\)</span>'s distort the 'circular' value of the\r\neffect by 5 per cent, (or say a maximum of 10 per cent.); the\r\n'distortion' of the effect is <span\r\nclass=\"math inline\">\\(O(em)\\)</span>, the effect itself being <span\r\nclass=\"math inline\">\\(O(m)\\)</span>. I propose to ignore things of order\r\n<span class=\"math inline\">\\(O(em)\\)</span><a href=\"#fn8\"\r\nclass=\"footnote-ref\" id=\"fnref8\" role=\"doc-noteref\"><sup>8</sup></a>:\r\nthis is the first step in my argument. In particular, when we have\r\nsomething which is either some <span\r\nclass=\"math inline\">\\(\\Delta\\)</span>, or <span\r\nclass=\"math inline\">\\(m\\)</span> itself, multiplied by a factor, we can\r\nsubstitute first approximations (i.e. with <span\r\nclass=\"math inline\">\\(e=0\\)</span>), or make convenient changes that are\r\n<span class=\"math inline\">\\(O(e)\\)</span>, in the factor.</p>\r\n<p>Suppose now that <span class=\"math inline\">\\(E_{l}, E_{2}\\)</span>\r\nare two (exact) elliptic orbits, yielding <span\r\nclass=\"math inline\">\\(\\theta(t)\\)</span>'s that differ by amounts of the\r\nkind we are concerned with, differing, that is, by <span\r\nclass=\"math inline\">\\(O(m)\\)</span>.<a href=\"#fn9\" class=\"footnote-ref\"\r\nid=\"fnref9\" role=\"doc-noteref\"><sup>9</sup></a> It is now the case that\r\nthe differences satisfy the equation</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\theta_{1} - \\theta_{2} = m( a + bt + c \\cos nt + d \\sin nt) + O(em)\r\n\\end{equation}\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(a, b, c, d\\)</span> are constants\r\ndepending on the two sets of elements of <span\r\nclass=\"math inline\">\\(E_{1}, E_{2}\\)</span>, and (following our\r\nagreement about <strong><em>factors</em></strong> of <span\r\nclass=\"math inline\">\\(m\\)</span>) <span class=\"math inline\">\\(n\\)</span>\r\nis any common approximation to the mean angular velocity. I will\r\npostpone the school mathentatics proof of this.</p>\r\n<p>Next, (i) let <span class=\"math inline\">\\(E^{*}\\)</span> be the\r\n'instantaneous orbit at time <span\r\nclass=\"math inline\">\\(t_{0}\\)</span>', that is to say the orbit that\r\n<span class=\"math inline\">\\(U\\)</span> would describe if <span\r\nclass=\"math inline\">\\(N\\)</span> were annihilated at time <span\r\nclass=\"math inline\">\\(t_{0}\\)</span>: note that <span\r\nclass=\"math inline\">\\(E^{*}\\)</span> shares with <span\r\nclass=\"math inline\">\\(t_{0}\\)</span> the property of being 'unknown'.\r\n(ii) Let <span class=\"math inline\">\\(\\vartheta\\)</span> be the\r\nperturbation of the <span class=\"math inline\">\\(\\theta\\)</span> of <span\r\nclass=\"math inline\">\\(U\\)</span> produced by <span\r\nclass=\"math inline\">\\(N\\)</span> since time <span\r\nclass=\"math inline\">\\(t_{0}\\)</span>.<a href=\"#fn10\"\r\nclass=\"footnote-ref\" id=\"fnref10\" role=\"doc-noteref\"><sup>10</sup></a>\r\nThen if, at any time <span class=\"math inline\">\\(t\\)</span>, <span\r\nclass=\"math inline\">\\(\\theta\\)</span> is (as usual) <span\r\nclass=\"math inline\">\\(U\\)</span>'s longitude, <span\r\nclass=\"math inline\">\\(\\theta_{B}\\)</span> is the longitude in the orbit\r\n<span class=\"math inline\">\\(E_{B}\\)</span>, and <span\r\nclass=\"math inline\">\\(\\theta^{*}\\)</span> the longitude in the orbit\r\n<span class=\"math inline\">\\(E^{*}\\)</span>, we have <span\r\nclass=\"math inline\">\\(\\vartheta = \\theta - \\theta^{*}\\)</span>, and\r\nso</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\delta(t) = \\theta - \\theta_{B} = (\\theta^{*} - \\theta_{B}) + \\vartheta\r\n\\end{equation}\\]</span></p>\r\n<p>Now everything in this has a factor <span\r\nclass=\"math inline\">\\(m\\)</span>, and we may omit any stray <span\r\nclass=\"math inline\">\\(O(em)\\)</span>'s. In particular, we may in\r\ncalculating <span class=\"math inline\">\\(\\vartheta\\)</span> drop any\r\n<span class=\"math inline\">\\(e\\)</span> terms. But this means that\r\n<strong><em>we can calculate <span\r\nclass=\"math inline\">\\(\\vartheta\\)</span> as if both <span\r\nclass=\"math inline\">\\(U\\)</span>'s and <span\r\nclass=\"math inline\">\\(N\\)</span>'s orbits were circles</em></strong>.\r\nWhen, however, the orbits are circles, <strong><em><span\r\nclass=\"math inline\">\\(\\vartheta\\)</span> has equal and opposite values\r\nat <span class=\"math inline\">\\(t\\)</span>'s on equal and opposite sides\r\nof <span class=\"math inline\">\\(t_{0}\\)</span></em></strong>; in other\r\nwords, <strong><em>if we write <span class=\"math inline\">\\(t=t_{0} +\r\n\\tau\\)</span>, then</em></strong></p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\vartheta(t) = \\Omega (\\tau)\r\n\\end{equation}\\]</span></p>\r\n<p><strong><em>where <span class=\"math inline\">\\(\\Omega (\\tau)\\)</span>\r\nis an odd<a href=\"#fn11\" class=\"footnote-ref\" id=\"fnref11\"\r\nrole=\"doc-noteref\"><sup>11</sup></a> function of <span\r\nclass=\"math inline\">\\(\\tau\\)</span>; i.e. <span\r\nclass=\"math inline\">\\(\\Omega(-\\tau)=\r\n-\\Omega(\\tau)\\)</span>.</em></strong></p>\r\n<p>This, used in combination with (1) and (2), is the essential (and\r\nvery simple) point of the argument. The difference <span\r\nclass=\"math inline\">\\(\\theta^{*} - \\theta_{B}\\)</span> is a special case\r\nof <span class=\"math inline\">\\(\\theta_{1} - \\theta_{2}\\)</span> in (1).\r\nWrite <span class=\"math inline\">\\(t=t_{0} + \\tau\\)</span> in (1) and\r\ncombine this with (2) and (3); this gives, ignoring <span\r\nclass=\"math inline\">\\(O(em)\\)</span>'s,</p>\r\n<p><span class=\"math display\">\\[\\delta(t_{0} + \\tau) = m \\left\\{a + b\r\nt_{0} + b \\tau + c \\cos (nt_{0} + n \\tau) + d \\sin (nt_{0} + n \\tau)\r\n\\right\\} + \\Omega(\\tau)\\]</span></p>\r\n<p>Expanding the <span class=\"math inline\">\\(\\cos\\)</span> and <span\r\nclass=\"math inline\">\\(\\sin\\)</span> of sums and rearranging we have\r\n(with new constants, whose values vary with but do not concern us)</p>\r\n<p><span class=\"math display\">\\[\\delta(t_{0} + \\tau) = A - B(1 - \\cos\r\nn\\tau) + \\left\\{C \\tau + D \\sin n\\tau +\r\n\\Omega(\\tau)\\right\\}\\]</span></p>\r\n<p><strong><em>The curly bracket is an odd function of <span\r\nclass=\"math inline\">\\(\\tau\\)</span></em></strong>. Hence if we combine\r\nequal and opposite <span class=\"math inline\">\\(\\tau\\)</span> and\r\nconstruct <span class=\"math inline\">\\(\\delta^{*}(\\tau)\\)</span> and\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span> to satisfy</p>\r\n<p><span class=\"math display\">\\[\\delta^{*}(\\tau) = - \\frac{1}{2}\r\n\\left\\{\\delta(t_{0}+\\tau) + \\delta(t_{0}- \\tau) - 2 \\delta(t_{0})\r\n\\right\\}, \\rho(\\tau) = \\delta^{*}(\\tau)/(1-\\cos n\\tau)\\]</span></p>\r\n<p>we have <span class=\"math inline\">\\(\\delta^{*}(\\tau)=B( 1 - \\cos\r\nn\\tau)\\)</span>, and so $()=B $ for all <span\r\nclass=\"math inline\">\\(\\tau\\)</span>. <strong><em>If, then, we are using\r\nthe right <span class=\"math inline\">\\(t_{0}\\)</span> the ratio p(r) must\r\ncome out constant</em></strong>: this is our method for identifying\r\n<span class=\"math inline\">\\(t_{0}\\)</span>. The actual value of <span\r\nclass=\"math inline\">\\(t_{0}\\)</span> to the nearest year is 1822.</p>\r\n<p>Table II, in which the unit of time is 1 year (and the <span\r\nclass=\"math inline\">\\(n\\)</span> of <span class=\"math inline\">\\(\\cos\r\nn\\tau\\)</span> is <span class=\"math inline\">\\(2\\pi/84\\)</span>), shows\r\nthe results of trying various (the century is omitted from the dates).\r\nThe last place of decimals for the <span\r\nclass=\"math inline\">\\(\\rho(\\tau)\\)</span> is not reliable, but of course\r\ngets better as the size of the entry <span\r\nclass=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span> increases: I give the\r\nnumbers as they came, and they speak for themselves. <span\r\nclass=\"math inline\">\\(\\tau=6\\)</span> is included, though the\r\nproportionate error in <span class=\"math inline\">\\(\\delta^{*}\\)</span>\r\nis then considerable.<a href=\"#fn12\" class=\"footnote-ref\" id=\"fnref12\"\r\nrole=\"doc-noteref\"><sup>12</sup></a> For <span\r\nclass=\"math inline\">\\(t_{0}=13\\)</span> <span\r\nclass=\"math inline\">\\(\\rho\\)</span> goes on to 34.8 at <span\r\nclass=\"math inline\">\\(\\tau=27\\)</span>; for <span\r\nclass=\"math inline\">\\(t_{0}=16\\)</span> it goes to 38.2 at <span\r\nclass=\"math inline\">\\(\\tau= 24\\)</span>. Once the data the smooth curve\r\nvalues were assembled the calculations took a mere hour or so with a\r\nslide-rule. The date 1822-4 seems about the 'best' <span\r\nclass=\"math inline\">\\(t_{0}\\)</span>.</p>\r\n<style>\r\n    body {text-align: center;} table{margin: auto;}\r\n</style>\r\n<table>\r\n<tr>\r\n<td>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 13\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 16\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 19\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 22\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 22.4\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 25\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 28\\)</span>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n<span class=\"math inline\">\\(\\tau\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n6\r\n</td>\r\n<td>\r\n0.6\r\n</td>\r\n<td>\r\n3.0\r\n</td>\r\n<td>\r\n1.0\r\n</td>\r\n<td>\r\n5.1\r\n</td>\r\n<td>\r\n3.6\r\n</td>\r\n<td>\r\n18.3\r\n</td>\r\n<td>\r\n9.2\r\n</td>\r\n<td>\r\n47.0\r\n</td>\r\n<td>\r\n10.6\r\n</td>\r\n<td>\r\n53.8\r\n</td>\r\n<td>\r\n18.2\r\n</td>\r\n<td>\r\n92.5\r\n</td>\r\n<td>\r\n20.4\r\n</td>\r\n<td>\r\n103\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n9\r\n</td>\r\n<td>\r\n1.8\r\n</td>\r\n<td>\r\n4.1\r\n</td>\r\n<td>\r\n3.9\r\n</td>\r\n<td>\r\n9.0\r\n</td>\r\n<td>\r\n10.7\r\n</td>\r\n<td>\r\n24.6\r\n</td>\r\n<td>\r\n23.2\r\n</td>\r\n<td>\r\n53.3\r\n</td>\r\n<td>\r\n25.0\r\n</td>\r\n<td>\r\n57.6\r\n</td>\r\n<td>\r\n34.5\r\n</td>\r\n<td>\r\n79.3\r\n</td>\r\n<td>\r\n41.1\r\n</td>\r\n<td>\r\n94\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n12\r\n</td>\r\n<td>\r\n5.3\r\n</td>\r\n<td>\r\n7.6\r\n</td>\r\n<td>\r\n11.9\r\n</td>\r\n<td>\r\n15.8\r\n</td>\r\n<td>\r\n25.0\r\n</td>\r\n<td>\r\n33.2\r\n</td>\r\n<td>\r\n39.8\r\n</td>\r\n<td>\r\n53.0\r\n</td>\r\n<td>\r\n42.2\r\n</td>\r\n<td>\r\n56.1\r\n</td>\r\n<td>\r\n55.9\r\n</td>\r\n<td>\r\n74.4\r\n</td>\r\n<td>\r\n64.7\r\n</td>\r\n<td>\r\n86\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n15\r\n</td>\r\n<td>\r\n13.7\r\n</td>\r\n<td>\r\n12.1\r\n</td>\r\n<td>\r\n26.6\r\n</td>\r\n<td>\r\n23.5\r\n</td>\r\n<td>\r\n42.0\r\n</td>\r\n<td>\r\n37.1\r\n</td>\r\n<td>\r\n61.5\r\n</td>\r\n<td>\r\n54.4\r\n</td>\r\n<td>\r\n64.0\r\n</td>\r\n<td>\r\n56.5\r\n</td>\r\n<td>\r\n79.8\r\n</td>\r\n<td>\r\n70.5\r\n</td>\r\n<td>\r\n91(e)\r\n</td>\r\n<td>\r\n80.6(e)\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n18\r\n</td>\r\n<td>\r\n29.3\r\n</td>\r\n<td>\r\n18.8\r\n</td>\r\n<td>\r\n44.2\r\n</td>\r\n<td>\r\n28.4\r\n</td>\r\n<td>\r\n64.1\r\n</td>\r\n<td>\r\n41.2\r\n</td>\r\n<td>\r\n85.8\r\n</td>\r\n<td>\r\n55.2\r\n</td>\r\n<td>\r\n88.6\r\n</td>\r\n<td>\r\n57.0\r\n</td>\r\n<td>\r\n106(e)\r\n</td>\r\n<td>\r\n86.3(e)\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n21\r\n</td>\r\n<td>\r\n48.3\r\n</td>\r\n<td>\r\n24.1\r\n</td>\r\n<td>\r\n67.2\r\n</td>\r\n<td>\r\n36.6\r\n</td>\r\n<td>\r\n89.0\r\n</td>\r\n<td>\r\n45.5\r\n</td>\r\n<td>\r\n113(e)\r\n</td>\r\n<td>\r\n56.5(e)\r\n</td>\r\n<td>\r\n116(e)\r\n</td>\r\n<td>\r\n58.0(e)\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n</tr>\r\n<caption>\r\nTable II\r\n</caption>\r\n</table>\r\n<p>We need fairly large <span class=\"math inline\">\\(\\tau\\)</span> for\r\n<span class=\"math inline\">\\(\\delta^{*}(\\tau)\\)</span> to have enough\r\nignificant figures, and further to provide a range showing up whether\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span> is constant or not. And\r\nwe need room to manoeuvre round the final. So the method depends on the\r\n'luck' that 1822 falls comfortably inside the period of observation\r\n1780-1840. But some luck was needed in any case.</p>\r\n<p>It is an important point that the method is quite indifferent to how\r\nwell <span class=\"math inline\">\\(E_{B}\\)</span> does its originally\r\nintended job, and <strong><em>we do not need to know (and I don't knoiv)\r\nits elements</em></strong>; it is enough to know the 'discrepancy' with\r\n<strong><em>some</em></strong>, 'unknown', orbit (not too bad of\r\ncourse). On the other hand the method ostentatiously says nothing at all\r\nabout the mass or distance of <span class=\"math inline\">\\(N\\)</span>. I\r\nwill add something on this. With <span\r\nclass=\"math inline\">\\(e\\)</span>-terms ignored <span\r\nclass=\"math inline\">\\(\\vartheta(\\tau)/m\\)</span> can be calculated\r\n<strong><em>exactly</em></strong> for any given value of <span\r\nclass=\"math inline\">\\(\\lambda=a/a_{1}\\)</span> (ratio of the <span\r\nclass=\"math inline\">\\(a\\)</span>'s of <span\r\nclass=\"math inline\">\\(U\\)</span> and <span\r\nclass=\"math inline\">\\(N\\)</span>)<a href=\"#fn13\" class=\"footnote-ref\"\r\nid=\"fnref13\" role=\"doc-noteref\"><sup>13</sup></a> The idea would be to\r\ntry different <span class=\"math inline\">\\(A\\)</span>'s, each <span\r\nclass=\"math inline\">\\(A\\)</span> to give a best fitting <span\r\nclass=\"math inline\">\\(m\\)</span>, and to take the best fitting\r\n<strong><em>pair</em></strong> <span class=\"math inline\">\\(\\lambda,\r\nm\\)</span>. This fails, because the greater part of <span\r\nclass=\"math inline\">\\(\\vartheta\\)</span> is of the form <span\r\nclass=\"math inline\">\\(b^{\\prime}(n\\tau - \\sin n\\tau)\\)</span>, and <span\r\nclass=\"math inline\">\\(b^{\\prime}\\)</span> is smothered by the <span\r\nclass=\"math inline\">\\(a, b, c, d\\)</span> of <span\r\nclass=\"math inline\">\\(\\theta^{*} - \\theta_{B}\\)</span>, which depend on\r\nthe unknown elements of <span class=\"math inline\">\\(E_{B}\\)</span>\r\n(<span class=\"math inline\">\\(\\vartheta\\)</span> is smothered by the\r\n'unknown' <span class=\"math inline\">\\(\\theta^{*} - \\theta_{B}\\)</span>).\r\nIf we knew these elements (or equivalently the raw <span\r\nclass=\"math inline\">\\(\\theta\\)</span>) we might be able to go on. They\r\ncould be recovered from the Paris Observatory archives; but this article\r\nis a last moment addition to the book, I do not feel that I am on full\r\nprofessional duty, and in any case we should be losing the light-hearted\r\nnote of our adventure.</p>\r\n<p>The time <span class=\"math inline\">\\(t\\)</span> once known, it would\r\nbe necessary to guess a value for <span\r\nclass=\"math inline\">\\(N\\)</span>'s distance <span\r\nclass=\"math inline\">\\(a_{1}\\)</span>; <span\r\nclass=\"math inline\">\\(N\\)</span>'s period is then <span\r\nclass=\"math inline\">\\(84(a_{1}/a)^{\\frac{3}{2}}\\)</span> years, and we\r\ncould 'predict' <span class=\"math inline\">\\(N\\)</span>'s place in 1846.\r\nThe obvious first guess in 1846 was <span\r\nclass=\"math inline\">\\(a_{l}/a=2\\)</span>, following Bode's empirical\r\nlaw, to which N is maliciously the first exception, the true value being\r\n1.58. Adams and le Verrier started with 2 (Adams coming down to 1.942\r\nfor a second round). Since from our standpoint<a href=\"#fn14\"\r\nclass=\"footnote-ref\" id=\"fnref14\" role=\"doc-noteref\"><sup>14</sup></a>\r\ntoo large an <span class=\"math inline\">\\(a_{1}\\)</span> has\r\ndisproportionately bad results as against one too small, it would be\r\nreasonable to try 1.8. This would give a prediction (for 1846) about\r\n10<span class=\"math inline\">\\(^{\\circ}\\)</span> out, but the sweep\r\nneeded would be wholly practicable.</p>\r\n<p>Le Verrier was less than 1<span\r\nclass=\"math inline\">\\(^{\\circ}\\)</span> out (Adams between 2<span\r\nclass=\"math inline\">\\(^{\\circ}\\)</span> and 3<span\r\nclass=\"math inline\">\\(^{\\circ}\\)</span>); 'they pointed the telescope\r\nand saw the planet'. This very close, and double, prediction is a\r\ncuriosity. All the observations from 1780 to 1840 were used, and on an\r\nequal footing, and the theory purported to say where <span\r\nclass=\"math inline\">\\(N\\)</span> was over this whole stretch. With a\r\nwrong <span class=\"math inline\">\\(a_{1}\\)</span> they could be right at\r\n1840 only by being wrong at 1780. With Adams's <span\r\nclass=\"math inline\">\\(a_{1}=1.94a\\)</span> <span\r\nclass=\"math inline\">\\(N\\)</span>'s period (which depends on <span\r\nclass=\"math inline\">\\(a_{1}\\)</span> only) would be 227 years; he would\r\nhave been wrong by 30<span class=\"math inline\">\\(^{\\circ}\\)</span> for\r\n1780 if the orbit were circular, and so the angular velocity uniform.\r\nBut faced with a wrong <span class=\"math inline\">\\(a_{1}\\)</span> the\r\nmethod responded gallantly by putting up a large eccentricity (<span\r\nclass=\"math inline\">\\(\\frac{1}{8}\\)</span>), and assigning perihelion to\r\nthe place of conjunction. The combination makes the effective distance\r\nfrom <span class=\"math inline\">\\(S\\)</span> over the critical stretch\r\nmore like <span class=\"math inline\">\\(1.7 a_{l}\\)</span>, and the\r\nresulting error at 1780 (the worst one) was only 18. (A mass 2.8 times\r\ntoo large was a more obvious adjustment.)</p>\r\n<p>In much more recent times small discrepancies for <span\r\nclass=\"math inline\">\\(N\\)</span> and <span\r\nclass=\"math inline\">\\(U\\)</span> (<span\r\nclass=\"math inline\">\\(U\\)</span>'s being in fact the more manageable\r\nones) were analysed for a trans-Neptunian planet, and the planet Pluto\r\nwas found in 1930 near the predicted place. This was a complete fluke:\r\nPluto has a mass probably no more than <span\r\nclass=\"math inline\">\\(\\frac{1}{10}\\)</span> of the Earth's; any effects\r\nit could have on <span class=\"math inline\">\\(N\\)</span> and <span\r\nclass=\"math inline\">\\(U\\)</span> would be hopelessly swamped by the\r\nobservational errors.</p>\r\n<p>It remains for me to give the (school mathematics) proof of (1)\r\nabove. Call <span class=\"math inline\">\\(e_{1} - e_{2}\\)</span> <span\r\nclass=\"math inline\">\\(\\Delta e\\)</span>, and so on. I said above that\r\nall <span class=\"math inline\">\\(\\Delta\\)</span>'s were <span\r\nclass=\"math inline\">\\(O(m)\\)</span>: this is not quite true, though my\r\ndeception has been in the reader's best interests, and will not have led\r\nhim astray.<a href=\"#fn15\" class=\"footnote-ref\" id=\"fnref15\"\r\nrole=\"doc-noteref\"><sup>15</sup></a> It is true, and common sense, for\r\n<span class=\"math inline\">\\(\\Delta a\\)</span>, <span\r\nclass=\"math inline\">\\(\\Delta e\\)</span>, <span\r\nclass=\"math inline\">\\(\\Delta n\\)</span>, and <span\r\nclass=\"math inline\">\\(\\Delta \\epsilon\\)</span>. But the 'effect' of a\r\ngiven Aa vanishes when <span class=\"math inline\">\\(e=0\\)</span>, and is\r\nproportional to <span class=\"math inline\">\\(e\\)</span>. So it is <span\r\nclass=\"math inline\">\\(e\\Delta \\alpha\\)</span>, not <span\r\nclass=\"math inline\">\\(\\Delta \\alpha\\)</span>, that is comparable with\r\nthe other <span class=\"math inline\">\\(\\Delta\\)</span>'s and so <span\r\nclass=\"math inline\">\\(O(m)\\)</span>.<a href=\"#fn16\" class=\"footnote-ref\"\r\nid=\"fnref16\" role=\"doc-noteref\"><sup>16</sup></a></p>\r\n<p>We start from two well-known formulae. The first is geometrical; the\r\npolar equation of the ellipse of the orbit is</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nr = a(1- e^{2}) ( 1 +e \\cos (\\theta -a))^{-1}\r\n\\end{equation}\\]</span></p>\r\n<p>The second is dynamical; the equation of angular momentum (Kepler's\r\nsecond law) is</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}r^{2} \\frac{d\\theta}{dt}\r\n= na^{2} (1-e^{2})^{\\frac{1}{2}}\\end{equation}\\]</span></p>\r\n<p>So, using dots for time differentiations,</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\theta = n(1-e^{2})^{-\\frac{3}{2}} [1 - 2\\cos (\\theta -a) + 3e^{2}\r\n\\cos^{2} (\\theta -a ) + \\cdots]\r\n\\end{equation}\\]</span></p>\r\n<p>The first approximation (with <span\r\nclass=\"math inline\">\\(e=0\\)</span>) is <span\r\nclass=\"math inline\">\\(\\theta=nt + \\epsilon\\)</span>. We take suffixes 1\r\nand 2 in (6) and operate with <span\r\nclass=\"math inline\">\\(\\Delta\\)</span>, remembering that we may take\r\nfirst approximations in any <strong><em>factor</em></strong> of an <span\r\nclass=\"math inline\">\\(m\\)</span>.</p>\r\n<p>In estimating <span class=\"math inline\">\\(\\Delta\\theta\\)</span> we\r\nmay, with error <span class=\"math inline\">\\(O(em)\\)</span>, ignore the\r\nfactor <span class=\"math inline\">\\((1-e^{2})^{-\\frac{3}{2}}\\)</span> in\r\n(6), since it is itself <span\r\nclass=\"math inline\">\\(\\left(1+O(e^{2})\\right)\\)</span>, and its <span\r\nclass=\"math inline\">\\(\\Delta\\)</span> is <span\r\nclass=\"math inline\">\\(O(e\\Delta e)=O(em)\\)</span>. We have, therefore,\r\nwith error <span class=\"math inline\">\\(O(em)\\)</span>,</p>\r\n<p><span class=\"math display\">\\[\\Delta \\theta = \\Delta \\left\\{n[\\quad\r\n]\\right\\} = [\\quad ] \\Delta n + n \\Delta [\\quad ]\\]</span></p>\r\n<p>The 1st term is <span class=\"math inline\">\\(\\Delta n+O(em)\\)</span>.\r\nThe 2nd is</p>\r\n<p><span class=\"math display\">\\[n\\left[\\Delta e \\left\\{- 2 \\cos(\\theta\r\n-a ) + O(e)\\right\\} + \\Delta (\\theta -a ) \\left\\{2e \\sin (\\theta -a ) +\r\nO(e^{2}\\right\\}\\right]\\]</span></p>\r\n<p>and we may drop the <span class=\"math inline\">\\(\\theta\\)</span> in\r\n<span class=\"math inline\">\\(\\Delta (\\theta - a)\\)</span> on account of\r\nthe factor <span class=\"math inline\">\\(O(\\epsilon)\\)</span>. Summing up,\r\nwe obtain</p>\r\n<p><span class=\"math display\">\\[\\Delta \\theta = m (A+B \\cos (\\theta -a )\r\n+ C \\sin (\\theta -a ) ) + O(em)\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(mA=\\Delta n\\)</span>, <span\r\nclass=\"math inline\">\\(mB = -2n\\Delta e\\)</span>, <span\r\nclass=\"math inline\">\\(mC = -2n(e\\Delta a)\\)</span>. Substituting the\r\nfirst approximation <span class=\"math inline\">\\(\\theta=nt +\r\n\\epsilon\\)</span> in the right hand side, we have</p>\r\n<p><span class=\"math display\">\\[\\Delta \\theta = m (A+B \\cos (nt +\r\n\\epsilon -a ) + C \\sin (nt + \\epsilon -a ) ) + O(em)\\]</span></p>\r\n<p>and integration then gives</p>\r\n<p><span class=\"math display\">\\[\\Delta \\theta = m (A+B/n \\sin (nt +\r\n\\epsilon -a ) - C/n \\cos (nt + \\epsilon -a ) ) + O(em)\\]</span></p>\r\n<p>which, after expanding the sin and cos and rearranging, is of the\r\ndesired form (I).<a href=\"#fn17\" class=\"footnote-ref\" id=\"fnref17\"\r\nrole=\"doc-noteref\"><sup>17</sup></a></p>\r\n<aside id=\"footnotes\" class=\"footnotes footnotes-end-of-document\"\r\nrole=\"doc-endnotes\">\r\n<hr />\r\n<ol>\r\n<li id=\"fn1\"><p>Its attachment to the '3-body problem' misleads people\r\nto-day.<a href=\"#fnref1\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn2\"><p>The time at which NUS is a straight line (I shall use\r\nthe abbreviations S, U, N).<a href=\"#fnref2\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn3\"><p>It does not depend on <span\r\nclass=\"math inline\">\\(e\\)</span>.<a href=\"#fnref3\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn4\"><p>The total area of the ellipse is <span\r\nclass=\"math inline\">\\(\\pi ab\\)</span>, and it is swept out in time <span\r\nclass=\"math inline\">\\(p\\)</span>.<a href=\"#fnref4\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn5\"><p>Strictly speaking the a.m. should have the planet's mass\r\nas a factor: but <span class=\"math inline\">\\(U\\)</span>'s mass is\r\nirrelevant and I omit it throughout.<a href=\"#fnref5\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn6\"><p>Observations after 1840 were not immediately available,\r\nand anyhow were not used. Uranus was discovered in 1781. Lest the reader\r\nshould be worried by small inconsistencies in my dates I mention that\r\n1780 is 'used', the extrapolation being a safe one.<a href=\"#fnref6\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn7\"><p><strong><em>Collected Works, I</em></strong>, p. 11.\r\nThese (and not the modifications he introduces, which are what appear in\r\nSmart) are what is relevant for us.<a href=\"#fnref7\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn8\"><p>I should stress that there is no question of ignoring\r\neven high powers of <span class=\"math inline\">\\(e\\)</span>\r\n<strong><em>unaccompanied by a factor <span\r\nclass=\"math inline\">\\(m\\)</span></em></strong> (<span\r\nclass=\"math inline\">\\(e^{4}\\)</span> radians is about 1\"). The\r\ndistortion in the value found for <span class=\"math inline\">\\(t\\)</span>\r\nis, however, a sort of exception to this. But the effect of <span\r\nclass=\"math inline\">\\(e\\)</span>'s in distorting <span\r\nclass=\"math inline\">\\(t_{0}\\)</span> is unlikely to be worse than the\r\nseparation they create between time of conjunction and time of closest\r\napproach. An easy calculation shows that this last time difference is at\r\nworst 0-8 years.<a href=\"#fnref8\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn9\"><p>The orbits may have 'Suns' of masses differing by <span\r\nclass=\"math inline\">\\(O(m)\\)</span>.<a href=\"#fnref9\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn10\"><p>We allow, of course, <strong><em>negative</em></strong>\r\nvalues of <span class=\"math inline\">\\(t - t_{0}\\)</span> both in <span\r\nclass=\"math inline\">\\(E^{*}\\)</span> and in <span\r\nclass=\"math inline\">\\(\\vartheta\\)</span>.<a href=\"#fnref10\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn11\"><p>'<span class=\"math inline\">\\(\\Omega\\)</span>' is a\r\ndeputy for '<span class=\"math inline\">\\(O\\)</span>' (initial of 'odd'),\r\nwhich is otherwise engaged. The italicized statement in the text is true\r\n'by symmetry': alternatively, <strong><em>reverse</em></strong> the\r\nmotions from time <span class=\"math inline\">\\(t_{0}\\)</span>. (The\r\nargument covers also the 'perturbation of 'the Sun' which is not so\r\ncompletely negligible as might be supposed.)<a href=\"#fnref11\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn12\"><p>And the, values for <span\r\nclass=\"math inline\">\\(\\tau=6\\)</span> at <span\r\nclass=\"math inline\">\\(t_{0}=22, 22.4\\)</span> are more uncertain than\r\nusual because of a crisis in the smooth curve.<a href=\"#fnref12\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn13\"><p>From two second order differential equations. The\r\nformula involves 'quadratures', but in numerical calculation integration\r\nis quicker than multiplication. It would be comparatively easy to make a\r\ndouble entry table for <span class=\"math inline\">\\(\\vartheta(\\tau,\r\n\\lambda)/m\\)</span><a href=\"#fnref13\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn14\"><p>Perturbation theory calculations have necessarily to\r\n<strong><em>begin</em></strong> by guessing <span\r\nclass=\"math inline\">\\(a_{1}\\)</span>; our guess need only be at the\r\nend.<a href=\"#fnref14\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn15\"><p>'Wen Gott betrugt is wohl betrogon.'<a href=\"#fnref15\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn16\"><p>This twist makes the 'obvious' approach of using the\r\nweil known expansion <span class=\"math display\">\\[\\theta = nt +\\epsilon\r\n+ 2e \\sin (nt + \\epsilon -a) + \\frac{5}{4}e^{2} \\sin 2 (nt + \\epsilon -a\r\n) + \\cdots\\]</span> slightly tricky; we should have to keep the term in\r\n<span class=\"math inline\">\\(e^{2}\\)</span>. The line taken in the text\r\nside-steps this.<a href=\"#fnref16\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn17\"><p>We have treated <span class=\"math inline\">\\(\\Delta\r\nn\\)</span> and <span class=\"math inline\">\\(\\Delta a\\)</span> as\r\nindependent (the latter happens not to occur in the final formula for\r\n<span class=\"math inline\">\\(\\Delta \\theta\\)</span>): this amounts to\r\nallowing different masses to the two 'Suns'. The point is relevant to\r\ncertain subtleties, into which I will not enter.<a href=\"#fnref17\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n</ol>\r\n</aside>\r\n","site":{"data":{}},"excerpt":"","more":"<p>Neptune was discovered in 1846 as a result of mathematical\r\ncalculation, done independently and practically simultaneously by Adams\r\nand le Verrier. The full story abounds in unexpected twists, and is\r\ncomplicated by personal matters, some of them rather painful. There is a\r\nfascinating account in Professor W. M. Smart's <strong><em>John Couch\r\nAdams and the Discovery of Neptune</em></strong>, published by the Royal\r\nAstronomical Society, 1947. I am concerned only with limited parts of\r\nthe field.</p>\r\n<p>To refresh the reader's memory of what has been said from time to\r\ntime about the discovery I will begin with some representative\r\nquotations. In <strong><em>The Story of the Heavens</em></strong> (1886)\r\nSir Robert Ball has passages:' the name of le Verrier rose to a pinnacle\r\nhardly surpassed in any age or country' ... 'profound meditations for\r\nmany months' ... 'long tand arduous labour guided by consummate\r\nmathematical artifice'. The author is not above a bit of popular appeal\r\nin this book  'if the ellipse has not the perfect simplicity of the\r\ncircle, it has at least the charm of variety ... an outline of perfect\r\ngrace, and an association with ennobling conceptions'  but on Neptune\r\nhe is speaking as a professional. An excellent modern book on the\r\nhistory of astronomy has, so late as 1938:' probably the most daring\r\nmathematical enterprise of the century ... this amazing task, like which\r\nnothing had ever been attempted before'.</p>\r\n<p>The immediate reaction was natural enough. Celestial Mechanics in\r\ngeneral, and the theory of perturbations in particular, had developed\r\ninto a very elaborate and high-brow subject; the problem of explaining\r\nthe misbehaviour of Uranus by a new planet was one of 'inverse' theory,\r\nand the common feeling was that the problem was difficult up to or\r\nbeyond the point of impossibility. One might speculate at some length on\r\nreasons for this opinion (one, perhaps was confusion between different\r\nmeanings of the technica term 'insoluble'<a href=\"#fn1\"\r\nclass=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a>).\r\nWhen Adams and le Verrier provec the opinion wrong (and after all\r\n<strong><em>any</em></strong> mathematical proof is a debunking of\r\nsorts) there was still something to be said for the principle that\r\ndifficulties are what they seem before the event, not after. Certainly\r\nno one would grudge them their resounding fame. (Nor grudge, at a lower\r\nlevel, the luck of a discovery which makes a more sensational impact\r\nthan its actual difficulty strictly merits; in point of fact this luck\r\nnever does happen to the second-rate.) If the discovery has had a very\r\nlong run one must remember that there is a time-lag ; people cannot be\r\nalways reconsidering opinions, and having said something once even the\r\nmost intelligent tend to go on repeating it. The phrase was still in\r\nvogue that 'only 3 people understand Relativity' at a time when\r\nEddington was complaining that the trouble about Relativity as an\r\nexamination subject in 'Part III' was that it was such a soft\r\noption.</p>\r\n<p>In what I am going to say I am far from imputing stupidity to people\r\ncertainly less stupid than myself. My little <strong><em>jeuz\r\nd'esprit</em></strong> are not going to hurt anyone, and I refuse to be\r\ndeterred by the fear of being thought disrespectful to great men. I have\r\nnot been alone in a lurking suspicion that a much simpler approach might\r\nsucceed. On the one hand, aim at the minimum needed to make\r\nobservational discovery practicable; specifically at the time <span\r\nclass=\"math inline\">\\(t_{0}\\)</span> of conjunction.<a href=\"#fn2\"\r\nclass=\"footnote-ref\" id=\"fnref2\" role=\"doc-noteref\"><sup>2</sup></a> On\r\nthe other, forget the high-brow and laborious perturbation theory, and\r\ntry 'school mathematics'. (I admit to the human weakness of being\r\nspurred on by the mild piquancy success would have.) To begin with I\r\nfound things oddly elusive (and incidentally committed some gross\r\nstupidities). In the end an absurdly simple line emerged: I can imagine\r\nits being called a dirty trick, nor would I deny that there is some\r\ntruth in the accusation. The only way to make my case is to carry out\r\nthe actual 'prediction' of <span class=\"math inline\">\\(t_{0}\\)</span>\r\nfrom the observational data, with all the cards on the table (so that\r\nanyone can check against unconscious or conscious faking). I will also\r\nwrite so as to take as many amateurs as possible with me on the little\r\nadventure.</p>\r\n<p>A planetary 'orbit' is an ellipse with the Sun <span\r\nclass=\"math inline\">\\(S\\)</span> at a focus, and the radius vector <span\r\nclass=\"math inline\">\\(SP\\)</span> sweeps out area at a constant rate\r\n(Kepler's second law). An orbit, given its plane, is defined by 4\r\nelements, <span class=\"math inline\">\\(a\\)</span>, <span\r\nclass=\"math inline\">\\(e\\)</span>, <span\r\nclass=\"math inline\">\\(\\alpha\\)</span>, <span\r\nclass=\"math inline\">\\(\\epsilon\\)</span>. The first 3 define the\r\ngeometrical ellipse: <span class=\"math inline\">\\(a\\)</span> is the\r\nsemi-major axis; <span class=\"math inline\">\\(e\\)</span> the\r\neccentricity; <span class=\"math inline\">\\(\\alpha\\)</span> the longitude\r\nof perihelion, i.e. with the obvious polar coordinates <span\r\nclass=\"math inline\">\\(r, \\theta\\)</span>, <span\r\nclass=\"math inline\">\\(\\theta\\)</span> is the 'longitude' and <span\r\nclass=\"math inline\">\\(\\theta=a\\)</span> when <span\r\nclass=\"math inline\">\\(P\\)</span> is nearest <span\r\nclass=\"math inline\">\\(S\\)</span> (at an end of the major axis). When we\r\nknow <span class=\"math inline\">\\(a\\)</span> we know the 'mean angular\r\nvelocity' <span class=\"math inline\">\\(n\\)</span> and the associated\r\nperiod <span class=\"math inline\">\\(p= 2 \\pi/n\\)</span>; <span\r\nclass=\"math inline\">\\(n\\)</span> is in fact proportional to <span\r\nclass=\"math inline\">\\(a^{-\\frac{1}{2}}\\)</span> (Kepler's third law)<a\r\nhref=\"#fn3\" class=\"footnote-ref\" id=\"fnref3\"\r\nrole=\"doc-noteref\"><sup>3</sup></a>; further the constant rate of area\r\nsweeping is <span class=\"math inline\">\\(\\frac{1}{2}abn\\)</span><a\r\nhref=\"#fn4\" class=\"footnote-ref\" id=\"fnref4\"\r\nrole=\"doc-noteref\"><sup>4</sup></a> and twice this rate is identical\r\nwith the angular momentum'<a href=\"#fn5\" class=\"footnote-ref\"\r\nid=\"fnref5\" role=\"doc-noteref\"><sup>5</sup></a> (a.m. for short); this\r\nhas the differential calculus formula <span\r\nclass=\"math inline\">\\(r^{2}\\theta\\)</span>, and it also is of course\r\nconstant. The 4th element, the 'epoch' <span\r\nclass=\"math inline\">\\(e\\)</span>, is needed to identify the origin of\r\n<span class=\"math inline\">\\(t\\)</span>; the exact definition is that\r\n<span class=\"math inline\">\\(\\theta= \\alpha\\)</span> (perihelion) occurs\r\nat the <span class=\"math inline\">\\(t\\)</span> for which <span\r\nclass=\"math inline\">\\(nt+ \\epsilon = \\alpha\\)</span>.</p>\r\n<p><span class=\"math inline\">\\(U\\)</span>'s orbit has a period of 84\r\nyears, and an eccentricity <span class=\"math inline\">\\(e\\)</span> of\r\nabout <span class=\"math inline\">\\(\\frac{1}{20}\\)</span>. The effects of\r\nbodies other than <span class=\"math inline\">\\(S\\)</span> and <span\r\nclass=\"math inline\">\\(N\\)</span> can be allowed for, after which we may\r\nsuppose that <span class=\"math inline\">\\(U\\)</span>, <span\r\nclass=\"math inline\">\\(S\\)</span>, and the eventual <span\r\nclass=\"math inline\">\\(N\\)</span> are the only bodies in the system; we\r\nmay also suppose (all this is common form) that the movements are all in\r\none plane. The values of <span class=\"math inline\">\\(\\theta\\)</span>\r\n(for <span class=\"math inline\">\\(U\\)</span>) at the various times <span\r\nclass=\"math inline\">\\(t\\)</span> (we sometimes write <span\r\nclass=\"math inline\">\\(\\theta(t)\\)</span> to emphasize that <span\r\nclass=\"math inline\">\\(\\theta\\)</span> is 'at time <span\r\nclass=\"math inline\">\\(t\\)</span>') may be regarded as the observational\r\nraw material (though of course the actual raw observations are made from\r\nthe Earth). The <span class=\"math inline\">\\(r\\)</span>'s for the various\r\n<span class=\"math inline\">\\(t\\)</span> are indirect and are much less\r\nwell determined.</p>\r\n<p>The position in 1845 was that no exact elliptic orbit would fit the\r\nobserved 6 over the whole stretch 1780 to 1840.<a href=\"#fn6\"\r\nclass=\"footnote-ref\" id=\"fnref6\" role=\"doc-noteref\"><sup>6</sup></a> The\r\ndiscrepancies are very small, mostly a few seconds of arc (with a sudden\r\nswoop of about 90\",see Tablel). The ratio <span\r\nclass=\"math inline\">\\(m\\)</span> of <span\r\nclass=\"math inline\">\\(N\\)</span>'s mass to that of <span\r\nclass=\"math inline\">\\(S\\)</span> (taken as 1) is actually about 1/19000\r\n(the Orders of magnitude fit since m radians is about 11\").</p>\r\n<p>In the absence of <span class=\"math inline\">\\(N\\)</span> the a.m.\r\n<span class=\"math inline\">\\(A\\)</span> is constant (as stated above\r\nalias of Kepler's second law); <strong><em>the actual <span\r\nclass=\"math inline\">\\(N\\)</span> accelerates <span\r\nclass=\"math inline\">\\(A\\)</span> at times earlier than <span\r\nclass=\"math inline\">\\(t_{0}\\)</span> and decelerates it at later\r\ntimes</em></strong>. The graph of <span class=\"math inline\">\\(A\\)</span>\r\nagainst <span class=\"math inline\">\\(t\\)</span> therefore rises to a\r\nmaximum at <span class=\"math inline\">\\(t=t_{0}\\)</span>, and my first\r\nidea was that this would identify. So it would if all observations were\r\nwithout error (and the method would have the theoretical advantage of\r\nbeing unaffected by the eccentricities). But the value of <span\r\nclass=\"math inline\">\\(A\\)</span> at time <span\r\nclass=\"math inline\">\\(t\\)</span> depends on the <span\r\nclass=\"math inline\">\\(r\\)</span> at time <span\r\nclass=\"math inline\">\\(t\\)</span>, and the determinations of the <span\r\nclass=\"math inline\">\\(A\\)</span>'s are consequently too uncertain.\r\nThough the method fails it rises from the ashes in another form. For\r\nthis a few more preliminaries are needed.</p>\r\n<p>The numerical data Adams and le Verrier had to work on were not the\r\nobserved <span class=\"math inline\">\\(\\theta\\)</span>'s themselves, but\r\nthe differences between the observed <span\r\nclass=\"math inline\">\\(\\theta(t)\\)</span> and the <span\r\nclass=\"math inline\">\\(\\theta_{B}(t)\\)</span> of an elliptic orbit\r\ncalculated by Bouvard; the 'discrepancy' <span\r\nclass=\"math inline\">\\(\\delta(t)\\)</span> (<span\r\nclass=\"math inline\">\\(\\delta\\)</span> for short) is <span\r\nclass=\"math inline\">\\(\\delta(t)=\\theta(t)-\\theta_{B}(t)\\)</span>. [<span\r\nclass=\"math inline\">\\(\\theta_{B} (t)\\)</span> depends on the 'elements'\r\nof <span class=\"math inline\">\\(E_{B}\\)</span>, and these are subject to\r\n'errors'. These errors are among the unknowns that the perturbation\r\ntheory has to determine: our method does not mind what they are, as we\r\nshall see.] Table I gives the raw <span\r\nclass=\"math inline\">\\(S\\)</span>'s (given in Adams's paper<a href=\"#fn7\"\r\nclass=\"footnote-ref\" id=\"fnref7\" role=\"doc-noteref\"><sup>7</sup></a>),\r\ntogether with the values got by running a smooth curve. The treatment of\r\nthe start of the sudden swoop down after the long flat stretch is a bit\r\nuncertain: I drew my curve and stuck to it (but faking would make no\r\nultimate difference). The differences show up the order of the\r\nobservational errors (which naturally improve with the years something\r\nseems to have gone badly wrong in 1789); these are absolute, not\r\nrelative (thus the probable absolute error in <span\r\nclass=\"math inline\">\\(\\delta_{1} - \\delta_{2}\\)</span> is the same\r\nwhether <span class=\"math inline\">\\(\\delta_{1} - \\delta_{2}\\)</span> is\r\n0.5\" or 90\"). It is worth while to work to 0.1\" and to the number of\r\ndecimal places used in what follows, even though the last place is\r\ndoubtful.</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 7%\" />\r\n<col style=\"width: 21%\" />\r\n<col style=\"width: 20%\" />\r\n<col style=\"width: 7%\" />\r\n<col style=\"width: 20%\" />\r\n<col style=\"width: 23%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">Year</th>\r\n<th style=\"text-align: center;\">Observed <span\r\nclass=\"math inline\">\\(\\delta\\)</span></th>\r\n<th style=\"text-align: center;\">Smooth Curve</th>\r\n<th style=\"text-align: center;\">Year</th>\r\n<th style=\"text-align: center;\">Observed <span\r\nclass=\"math inline\">\\(\\delta\\)</span></th>\r\n<th style=\"text-align: center;\">Smooth Curve</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1780</td>\r\n<td style=\"text-align: center;\">3.5</td>\r\n<td style=\"text-align: center;\">3.5</td>\r\n<td style=\"text-align: center;\">1813</td>\r\n<td style=\"text-align: center;\">22.0</td>\r\n<td style=\"text-align: center;\">22.8</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1783</td>\r\n<td style=\"text-align: center;\">8.5</td>\r\n<td style=\"text-align: center;\">8.5</td>\r\n<td style=\"text-align: center;\">1816</td>\r\n<td style=\"text-align: center;\">22.9</td>\r\n<td style=\"text-align: center;\">22.5</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1786</td>\r\n<td style=\"text-align: center;\">12.4</td>\r\n<td style=\"text-align: center;\">12.5</td>\r\n<td style=\"text-align: center;\">1819</td>\r\n<td style=\"text-align: center;\">20.7</td>\r\n<td style=\"text-align: center;\">22.0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1789</td>\r\n<td style=\"text-align: center;\">19.0</td>\r\n<td style=\"text-align: center;\">15.8</td>\r\n<td style=\"text-align: center;\">1822</td>\r\n<td style=\"text-align: center;\">21.0</td>\r\n<td style=\"text-align: center;\">21.0</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1792</td>\r\n<td style=\"text-align: center;\">18.7</td>\r\n<td style=\"text-align: center;\">18.3</td>\r\n<td style=\"text-align: center;\">1825</td>\r\n<td style=\"text-align: center;\">18.2</td>\r\n<td style=\"text-align: center;\">18.1</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1795</td>\r\n<td style=\"text-align: center;\">21.4</td>\r\n<td style=\"text-align: center;\">20.3</td>\r\n<td style=\"text-align: center;\">1828</td>\r\n<td style=\"text-align: center;\">10.8</td>\r\n<td style=\"text-align: center;\">10.3</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1798</td>\r\n<td style=\"text-align: center;\">21.0</td>\r\n<td style=\"text-align: center;\">21.6</td>\r\n<td style=\"text-align: center;\">1831</td>\r\n<td style=\"text-align: center;\">-4.0</td>\r\n<td style=\"text-align: center;\">-4.0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1801</td>\r\n<td style=\"text-align: center;\">22.2</td>\r\n<td style=\"text-align: center;\">22.4</td>\r\n<td style=\"text-align: center;\">1834</td>\r\n<td style=\"text-align: center;\">-20.8</td>\r\n<td style=\"text-align: center;\">-20.8</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1804</td>\r\n<td style=\"text-align: center;\">24.2</td>\r\n<td style=\"text-align: center;\">22.8</td>\r\n<td style=\"text-align: center;\">1837</td>\r\n<td style=\"text-align: center;\">-42.7</td>\r\n<td style=\"text-align: center;\">-42.5</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1807</td>\r\n<td style=\"text-align: center;\">22.1</td>\r\n<td style=\"text-align: center;\">23.0</td>\r\n<td style=\"text-align: center;\">1840</td>\r\n<td style=\"text-align: center;\">-66.6</td>\r\n<td style=\"text-align: center;\">-66.6</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1810</td>\r\n<td style=\"text-align: center;\">23.2</td>\r\n<td style=\"text-align: center;\">23.0</td>\r\n<td style=\"text-align: center;\">1843(e)</td>\r\n<td style=\"text-align: center;\"><span\r\nclass=\"math inline\">\\(-\\)</span></td>\r\n<td style=\"text-align: center;\">-94.0</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>Table 1</p>\r\n<p>The value for 1843 is an extrapolation; results derived from it are\r\nlabelled '(e)'.</p>\r\n<p>An 'effect' due to <span class=\"math inline\">\\(N\\)</span> is of\r\n'order <span class=\"math inline\">\\(m\\)</span> in mathematical notation\r\n<span class=\"math inline\">\\(O(m)\\)</span>; if, for a particular quantity\r\n<span class=\"math inline\">\\(X\\)</span>, X$ denotes (calculated <span\r\nclass=\"math inline\">\\(X\\)</span>)  (observed <span\r\nclass=\"math inline\">\\(X\\)</span>), then any <span\r\nclass=\"math inline\">\\(\\Delta X\\)</span> is <span\r\nclass=\"math inline\">\\(O(m)\\)</span>. The square of this (2nd order of\r\ninfinitesimals) is extremely minute and everyone neglects it\r\ninstinctively (if <span class=\"math inline\">\\(a\\)</span> watch loses 10\r\nseconds a day you don't try to correct for the further loss over the\r\nlost 10 seconds the cases are comparable). Next, an effect of <span\r\nclass=\"math inline\">\\(N\\)</span> is what it would be if <span\r\nclass=\"math inline\">\\(U\\)</span>, and also <span\r\nclass=\"math inline\">\\(N\\)</span>, moved in circles,\r\n<strong><em>plus</em></strong> a 'correction' for the actual\r\neccentricities of the orbits. <span class=\"math inline\">\\(U\\)</span>'s\r\neccentricity <span class=\"math inline\">\\(e(\\frac{1}{20})\\)</span> is\r\nunusually large and it would be reasonable to expect <span\r\nclass=\"math inline\">\\(N\\)</span>'s to be no larger (it is actually less\r\nthan <span class=\"math inline\">\\(\\frac{1}{100}\\)</span>). The <span\r\nclass=\"math inline\">\\(e\\)</span>'s distort the 'circular' value of the\r\neffect by 5 per cent, (or say a maximum of 10 per cent.); the\r\n'distortion' of the effect is <span\r\nclass=\"math inline\">\\(O(em)\\)</span>, the effect itself being <span\r\nclass=\"math inline\">\\(O(m)\\)</span>. I propose to ignore things of order\r\n<span class=\"math inline\">\\(O(em)\\)</span><a href=\"#fn8\"\r\nclass=\"footnote-ref\" id=\"fnref8\" role=\"doc-noteref\"><sup>8</sup></a>:\r\nthis is the first step in my argument. In particular, when we have\r\nsomething which is either some <span\r\nclass=\"math inline\">\\(\\Delta\\)</span>, or <span\r\nclass=\"math inline\">\\(m\\)</span> itself, multiplied by a factor, we can\r\nsubstitute first approximations (i.e. with <span\r\nclass=\"math inline\">\\(e=0\\)</span>), or make convenient changes that are\r\n<span class=\"math inline\">\\(O(e)\\)</span>, in the factor.</p>\r\n<p>Suppose now that <span class=\"math inline\">\\(E_{l}, E_{2}\\)</span>\r\nare two (exact) elliptic orbits, yielding <span\r\nclass=\"math inline\">\\(\\theta(t)\\)</span>'s that differ by amounts of the\r\nkind we are concerned with, differing, that is, by <span\r\nclass=\"math inline\">\\(O(m)\\)</span>.<a href=\"#fn9\" class=\"footnote-ref\"\r\nid=\"fnref9\" role=\"doc-noteref\"><sup>9</sup></a> It is now the case that\r\nthe differences satisfy the equation</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\theta_{1} - \\theta_{2} = m( a + bt + c \\cos nt + d \\sin nt) + O(em)\r\n\\end{equation}\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(a, b, c, d\\)</span> are constants\r\ndepending on the two sets of elements of <span\r\nclass=\"math inline\">\\(E_{1}, E_{2}\\)</span>, and (following our\r\nagreement about <strong><em>factors</em></strong> of <span\r\nclass=\"math inline\">\\(m\\)</span>) <span class=\"math inline\">\\(n\\)</span>\r\nis any common approximation to the mean angular velocity. I will\r\npostpone the school mathentatics proof of this.</p>\r\n<p>Next, (i) let <span class=\"math inline\">\\(E^{*}\\)</span> be the\r\n'instantaneous orbit at time <span\r\nclass=\"math inline\">\\(t_{0}\\)</span>', that is to say the orbit that\r\n<span class=\"math inline\">\\(U\\)</span> would describe if <span\r\nclass=\"math inline\">\\(N\\)</span> were annihilated at time <span\r\nclass=\"math inline\">\\(t_{0}\\)</span>: note that <span\r\nclass=\"math inline\">\\(E^{*}\\)</span> shares with <span\r\nclass=\"math inline\">\\(t_{0}\\)</span> the property of being 'unknown'.\r\n(ii) Let <span class=\"math inline\">\\(\\vartheta\\)</span> be the\r\nperturbation of the <span class=\"math inline\">\\(\\theta\\)</span> of <span\r\nclass=\"math inline\">\\(U\\)</span> produced by <span\r\nclass=\"math inline\">\\(N\\)</span> since time <span\r\nclass=\"math inline\">\\(t_{0}\\)</span>.<a href=\"#fn10\"\r\nclass=\"footnote-ref\" id=\"fnref10\" role=\"doc-noteref\"><sup>10</sup></a>\r\nThen if, at any time <span class=\"math inline\">\\(t\\)</span>, <span\r\nclass=\"math inline\">\\(\\theta\\)</span> is (as usual) <span\r\nclass=\"math inline\">\\(U\\)</span>'s longitude, <span\r\nclass=\"math inline\">\\(\\theta_{B}\\)</span> is the longitude in the orbit\r\n<span class=\"math inline\">\\(E_{B}\\)</span>, and <span\r\nclass=\"math inline\">\\(\\theta^{*}\\)</span> the longitude in the orbit\r\n<span class=\"math inline\">\\(E^{*}\\)</span>, we have <span\r\nclass=\"math inline\">\\(\\vartheta = \\theta - \\theta^{*}\\)</span>, and\r\nso</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\delta(t) = \\theta - \\theta_{B} = (\\theta^{*} - \\theta_{B}) + \\vartheta\r\n\\end{equation}\\]</span></p>\r\n<p>Now everything in this has a factor <span\r\nclass=\"math inline\">\\(m\\)</span>, and we may omit any stray <span\r\nclass=\"math inline\">\\(O(em)\\)</span>'s. In particular, we may in\r\ncalculating <span class=\"math inline\">\\(\\vartheta\\)</span> drop any\r\n<span class=\"math inline\">\\(e\\)</span> terms. But this means that\r\n<strong><em>we can calculate <span\r\nclass=\"math inline\">\\(\\vartheta\\)</span> as if both <span\r\nclass=\"math inline\">\\(U\\)</span>'s and <span\r\nclass=\"math inline\">\\(N\\)</span>'s orbits were circles</em></strong>.\r\nWhen, however, the orbits are circles, <strong><em><span\r\nclass=\"math inline\">\\(\\vartheta\\)</span> has equal and opposite values\r\nat <span class=\"math inline\">\\(t\\)</span>'s on equal and opposite sides\r\nof <span class=\"math inline\">\\(t_{0}\\)</span></em></strong>; in other\r\nwords, <strong><em>if we write <span class=\"math inline\">\\(t=t_{0} +\r\n\\tau\\)</span>, then</em></strong></p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\vartheta(t) = \\Omega (\\tau)\r\n\\end{equation}\\]</span></p>\r\n<p><strong><em>where <span class=\"math inline\">\\(\\Omega (\\tau)\\)</span>\r\nis an odd<a href=\"#fn11\" class=\"footnote-ref\" id=\"fnref11\"\r\nrole=\"doc-noteref\"><sup>11</sup></a> function of <span\r\nclass=\"math inline\">\\(\\tau\\)</span>; i.e. <span\r\nclass=\"math inline\">\\(\\Omega(-\\tau)=\r\n-\\Omega(\\tau)\\)</span>.</em></strong></p>\r\n<p>This, used in combination with (1) and (2), is the essential (and\r\nvery simple) point of the argument. The difference <span\r\nclass=\"math inline\">\\(\\theta^{*} - \\theta_{B}\\)</span> is a special case\r\nof <span class=\"math inline\">\\(\\theta_{1} - \\theta_{2}\\)</span> in (1).\r\nWrite <span class=\"math inline\">\\(t=t_{0} + \\tau\\)</span> in (1) and\r\ncombine this with (2) and (3); this gives, ignoring <span\r\nclass=\"math inline\">\\(O(em)\\)</span>'s,</p>\r\n<p><span class=\"math display\">\\[\\delta(t_{0} + \\tau) = m \\left\\{a + b\r\nt_{0} + b \\tau + c \\cos (nt_{0} + n \\tau) + d \\sin (nt_{0} + n \\tau)\r\n\\right\\} + \\Omega(\\tau)\\]</span></p>\r\n<p>Expanding the <span class=\"math inline\">\\(\\cos\\)</span> and <span\r\nclass=\"math inline\">\\(\\sin\\)</span> of sums and rearranging we have\r\n(with new constants, whose values vary with but do not concern us)</p>\r\n<p><span class=\"math display\">\\[\\delta(t_{0} + \\tau) = A - B(1 - \\cos\r\nn\\tau) + \\left\\{C \\tau + D \\sin n\\tau +\r\n\\Omega(\\tau)\\right\\}\\]</span></p>\r\n<p><strong><em>The curly bracket is an odd function of <span\r\nclass=\"math inline\">\\(\\tau\\)</span></em></strong>. Hence if we combine\r\nequal and opposite <span class=\"math inline\">\\(\\tau\\)</span> and\r\nconstruct <span class=\"math inline\">\\(\\delta^{*}(\\tau)\\)</span> and\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span> to satisfy</p>\r\n<p><span class=\"math display\">\\[\\delta^{*}(\\tau) = - \\frac{1}{2}\r\n\\left\\{\\delta(t_{0}+\\tau) + \\delta(t_{0}- \\tau) - 2 \\delta(t_{0})\r\n\\right\\}, \\rho(\\tau) = \\delta^{*}(\\tau)/(1-\\cos n\\tau)\\]</span></p>\r\n<p>we have <span class=\"math inline\">\\(\\delta^{*}(\\tau)=B( 1 - \\cos\r\nn\\tau)\\)</span>, and so $()=B $ for all <span\r\nclass=\"math inline\">\\(\\tau\\)</span>. <strong><em>If, then, we are using\r\nthe right <span class=\"math inline\">\\(t_{0}\\)</span> the ratio p(r) must\r\ncome out constant</em></strong>: this is our method for identifying\r\n<span class=\"math inline\">\\(t_{0}\\)</span>. The actual value of <span\r\nclass=\"math inline\">\\(t_{0}\\)</span> to the nearest year is 1822.</p>\r\n<p>Table II, in which the unit of time is 1 year (and the <span\r\nclass=\"math inline\">\\(n\\)</span> of <span class=\"math inline\">\\(\\cos\r\nn\\tau\\)</span> is <span class=\"math inline\">\\(2\\pi/84\\)</span>), shows\r\nthe results of trying various (the century is omitted from the dates).\r\nThe last place of decimals for the <span\r\nclass=\"math inline\">\\(\\rho(\\tau)\\)</span> is not reliable, but of course\r\ngets better as the size of the entry <span\r\nclass=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span> increases: I give the\r\nnumbers as they came, and they speak for themselves. <span\r\nclass=\"math inline\">\\(\\tau=6\\)</span> is included, though the\r\nproportionate error in <span class=\"math inline\">\\(\\delta^{*}\\)</span>\r\nis then considerable.<a href=\"#fn12\" class=\"footnote-ref\" id=\"fnref12\"\r\nrole=\"doc-noteref\"><sup>12</sup></a> For <span\r\nclass=\"math inline\">\\(t_{0}=13\\)</span> <span\r\nclass=\"math inline\">\\(\\rho\\)</span> goes on to 34.8 at <span\r\nclass=\"math inline\">\\(\\tau=27\\)</span>; for <span\r\nclass=\"math inline\">\\(t_{0}=16\\)</span> it goes to 38.2 at <span\r\nclass=\"math inline\">\\(\\tau= 24\\)</span>. Once the data the smooth curve\r\nvalues were assembled the calculations took a mere hour or so with a\r\nslide-rule. The date 1822-4 seems about the 'best' <span\r\nclass=\"math inline\">\\(t_{0}\\)</span>.</p>\r\n<style>\r\n    body {text-align: center;} table{margin: auto;}\r\n</style>\r\n<table>\r\n<tr>\r\n<td>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 13\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 16\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 19\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 22\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 22.4\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 25\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 28\\)</span>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n<span class=\"math inline\">\\(\\tau\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n6\r\n</td>\r\n<td>\r\n0.6\r\n</td>\r\n<td>\r\n3.0\r\n</td>\r\n<td>\r\n1.0\r\n</td>\r\n<td>\r\n5.1\r\n</td>\r\n<td>\r\n3.6\r\n</td>\r\n<td>\r\n18.3\r\n</td>\r\n<td>\r\n9.2\r\n</td>\r\n<td>\r\n47.0\r\n</td>\r\n<td>\r\n10.6\r\n</td>\r\n<td>\r\n53.8\r\n</td>\r\n<td>\r\n18.2\r\n</td>\r\n<td>\r\n92.5\r\n</td>\r\n<td>\r\n20.4\r\n</td>\r\n<td>\r\n103\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n9\r\n</td>\r\n<td>\r\n1.8\r\n</td>\r\n<td>\r\n4.1\r\n</td>\r\n<td>\r\n3.9\r\n</td>\r\n<td>\r\n9.0\r\n</td>\r\n<td>\r\n10.7\r\n</td>\r\n<td>\r\n24.6\r\n</td>\r\n<td>\r\n23.2\r\n</td>\r\n<td>\r\n53.3\r\n</td>\r\n<td>\r\n25.0\r\n</td>\r\n<td>\r\n57.6\r\n</td>\r\n<td>\r\n34.5\r\n</td>\r\n<td>\r\n79.3\r\n</td>\r\n<td>\r\n41.1\r\n</td>\r\n<td>\r\n94\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n12\r\n</td>\r\n<td>\r\n5.3\r\n</td>\r\n<td>\r\n7.6\r\n</td>\r\n<td>\r\n11.9\r\n</td>\r\n<td>\r\n15.8\r\n</td>\r\n<td>\r\n25.0\r\n</td>\r\n<td>\r\n33.2\r\n</td>\r\n<td>\r\n39.8\r\n</td>\r\n<td>\r\n53.0\r\n</td>\r\n<td>\r\n42.2\r\n</td>\r\n<td>\r\n56.1\r\n</td>\r\n<td>\r\n55.9\r\n</td>\r\n<td>\r\n74.4\r\n</td>\r\n<td>\r\n64.7\r\n</td>\r\n<td>\r\n86\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n15\r\n</td>\r\n<td>\r\n13.7\r\n</td>\r\n<td>\r\n12.1\r\n</td>\r\n<td>\r\n26.6\r\n</td>\r\n<td>\r\n23.5\r\n</td>\r\n<td>\r\n42.0\r\n</td>\r\n<td>\r\n37.1\r\n</td>\r\n<td>\r\n61.5\r\n</td>\r\n<td>\r\n54.4\r\n</td>\r\n<td>\r\n64.0\r\n</td>\r\n<td>\r\n56.5\r\n</td>\r\n<td>\r\n79.8\r\n</td>\r\n<td>\r\n70.5\r\n</td>\r\n<td>\r\n91(e)\r\n</td>\r\n<td>\r\n80.6(e)\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n18\r\n</td>\r\n<td>\r\n29.3\r\n</td>\r\n<td>\r\n18.8\r\n</td>\r\n<td>\r\n44.2\r\n</td>\r\n<td>\r\n28.4\r\n</td>\r\n<td>\r\n64.1\r\n</td>\r\n<td>\r\n41.2\r\n</td>\r\n<td>\r\n85.8\r\n</td>\r\n<td>\r\n55.2\r\n</td>\r\n<td>\r\n88.6\r\n</td>\r\n<td>\r\n57.0\r\n</td>\r\n<td>\r\n106(e)\r\n</td>\r\n<td>\r\n86.3(e)\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n21\r\n</td>\r\n<td>\r\n48.3\r\n</td>\r\n<td>\r\n24.1\r\n</td>\r\n<td>\r\n67.2\r\n</td>\r\n<td>\r\n36.6\r\n</td>\r\n<td>\r\n89.0\r\n</td>\r\n<td>\r\n45.5\r\n</td>\r\n<td>\r\n113(e)\r\n</td>\r\n<td>\r\n56.5(e)\r\n</td>\r\n<td>\r\n116(e)\r\n</td>\r\n<td>\r\n58.0(e)\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n</tr>\r\n<caption>\r\nTable II\r\n</caption>\r\n</table>\r\n<p>We need fairly large <span class=\"math inline\">\\(\\tau\\)</span> for\r\n<span class=\"math inline\">\\(\\delta^{*}(\\tau)\\)</span> to have enough\r\nignificant figures, and further to provide a range showing up whether\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span> is constant or not. And\r\nwe need room to manoeuvre round the final. So the method depends on the\r\n'luck' that 1822 falls comfortably inside the period of observation\r\n1780-1840. But some luck was needed in any case.</p>\r\n<p>It is an important point that the method is quite indifferent to how\r\nwell <span class=\"math inline\">\\(E_{B}\\)</span> does its originally\r\nintended job, and <strong><em>we do not need to know (and I don't knoiv)\r\nits elements</em></strong>; it is enough to know the 'discrepancy' with\r\n<strong><em>some</em></strong>, 'unknown', orbit (not too bad of\r\ncourse). On the other hand the method ostentatiously says nothing at all\r\nabout the mass or distance of <span class=\"math inline\">\\(N\\)</span>. I\r\nwill add something on this. With <span\r\nclass=\"math inline\">\\(e\\)</span>-terms ignored <span\r\nclass=\"math inline\">\\(\\vartheta(\\tau)/m\\)</span> can be calculated\r\n<strong><em>exactly</em></strong> for any given value of <span\r\nclass=\"math inline\">\\(\\lambda=a/a_{1}\\)</span> (ratio of the <span\r\nclass=\"math inline\">\\(a\\)</span>'s of <span\r\nclass=\"math inline\">\\(U\\)</span> and <span\r\nclass=\"math inline\">\\(N\\)</span>)<a href=\"#fn13\" class=\"footnote-ref\"\r\nid=\"fnref13\" role=\"doc-noteref\"><sup>13</sup></a> The idea would be to\r\ntry different <span class=\"math inline\">\\(A\\)</span>'s, each <span\r\nclass=\"math inline\">\\(A\\)</span> to give a best fitting <span\r\nclass=\"math inline\">\\(m\\)</span>, and to take the best fitting\r\n<strong><em>pair</em></strong> <span class=\"math inline\">\\(\\lambda,\r\nm\\)</span>. This fails, because the greater part of <span\r\nclass=\"math inline\">\\(\\vartheta\\)</span> is of the form <span\r\nclass=\"math inline\">\\(b^{\\prime}(n\\tau - \\sin n\\tau)\\)</span>, and <span\r\nclass=\"math inline\">\\(b^{\\prime}\\)</span> is smothered by the <span\r\nclass=\"math inline\">\\(a, b, c, d\\)</span> of <span\r\nclass=\"math inline\">\\(\\theta^{*} - \\theta_{B}\\)</span>, which depend on\r\nthe unknown elements of <span class=\"math inline\">\\(E_{B}\\)</span>\r\n(<span class=\"math inline\">\\(\\vartheta\\)</span> is smothered by the\r\n'unknown' <span class=\"math inline\">\\(\\theta^{*} - \\theta_{B}\\)</span>).\r\nIf we knew these elements (or equivalently the raw <span\r\nclass=\"math inline\">\\(\\theta\\)</span>) we might be able to go on. They\r\ncould be recovered from the Paris Observatory archives; but this article\r\nis a last moment addition to the book, I do not feel that I am on full\r\nprofessional duty, and in any case we should be losing the light-hearted\r\nnote of our adventure.</p>\r\n<p>The time <span class=\"math inline\">\\(t\\)</span> once known, it would\r\nbe necessary to guess a value for <span\r\nclass=\"math inline\">\\(N\\)</span>'s distance <span\r\nclass=\"math inline\">\\(a_{1}\\)</span>; <span\r\nclass=\"math inline\">\\(N\\)</span>'s period is then <span\r\nclass=\"math inline\">\\(84(a_{1}/a)^{\\frac{3}{2}}\\)</span> years, and we\r\ncould 'predict' <span class=\"math inline\">\\(N\\)</span>'s place in 1846.\r\nThe obvious first guess in 1846 was <span\r\nclass=\"math inline\">\\(a_{l}/a=2\\)</span>, following Bode's empirical\r\nlaw, to which N is maliciously the first exception, the true value being\r\n1.58. Adams and le Verrier started with 2 (Adams coming down to 1.942\r\nfor a second round). Since from our standpoint<a href=\"#fn14\"\r\nclass=\"footnote-ref\" id=\"fnref14\" role=\"doc-noteref\"><sup>14</sup></a>\r\ntoo large an <span class=\"math inline\">\\(a_{1}\\)</span> has\r\ndisproportionately bad results as against one too small, it would be\r\nreasonable to try 1.8. This would give a prediction (for 1846) about\r\n10<span class=\"math inline\">\\(^{\\circ}\\)</span> out, but the sweep\r\nneeded would be wholly practicable.</p>\r\n<p>Le Verrier was less than 1<span\r\nclass=\"math inline\">\\(^{\\circ}\\)</span> out (Adams between 2<span\r\nclass=\"math inline\">\\(^{\\circ}\\)</span> and 3<span\r\nclass=\"math inline\">\\(^{\\circ}\\)</span>); 'they pointed the telescope\r\nand saw the planet'. This very close, and double, prediction is a\r\ncuriosity. All the observations from 1780 to 1840 were used, and on an\r\nequal footing, and the theory purported to say where <span\r\nclass=\"math inline\">\\(N\\)</span> was over this whole stretch. With a\r\nwrong <span class=\"math inline\">\\(a_{1}\\)</span> they could be right at\r\n1840 only by being wrong at 1780. With Adams's <span\r\nclass=\"math inline\">\\(a_{1}=1.94a\\)</span> <span\r\nclass=\"math inline\">\\(N\\)</span>'s period (which depends on <span\r\nclass=\"math inline\">\\(a_{1}\\)</span> only) would be 227 years; he would\r\nhave been wrong by 30<span class=\"math inline\">\\(^{\\circ}\\)</span> for\r\n1780 if the orbit were circular, and so the angular velocity uniform.\r\nBut faced with a wrong <span class=\"math inline\">\\(a_{1}\\)</span> the\r\nmethod responded gallantly by putting up a large eccentricity (<span\r\nclass=\"math inline\">\\(\\frac{1}{8}\\)</span>), and assigning perihelion to\r\nthe place of conjunction. The combination makes the effective distance\r\nfrom <span class=\"math inline\">\\(S\\)</span> over the critical stretch\r\nmore like <span class=\"math inline\">\\(1.7 a_{l}\\)</span>, and the\r\nresulting error at 1780 (the worst one) was only 18. (A mass 2.8 times\r\ntoo large was a more obvious adjustment.)</p>\r\n<p>In much more recent times small discrepancies for <span\r\nclass=\"math inline\">\\(N\\)</span> and <span\r\nclass=\"math inline\">\\(U\\)</span> (<span\r\nclass=\"math inline\">\\(U\\)</span>'s being in fact the more manageable\r\nones) were analysed for a trans-Neptunian planet, and the planet Pluto\r\nwas found in 1930 near the predicted place. This was a complete fluke:\r\nPluto has a mass probably no more than <span\r\nclass=\"math inline\">\\(\\frac{1}{10}\\)</span> of the Earth's; any effects\r\nit could have on <span class=\"math inline\">\\(N\\)</span> and <span\r\nclass=\"math inline\">\\(U\\)</span> would be hopelessly swamped by the\r\nobservational errors.</p>\r\n<p>It remains for me to give the (school mathematics) proof of (1)\r\nabove. Call <span class=\"math inline\">\\(e_{1} - e_{2}\\)</span> <span\r\nclass=\"math inline\">\\(\\Delta e\\)</span>, and so on. I said above that\r\nall <span class=\"math inline\">\\(\\Delta\\)</span>'s were <span\r\nclass=\"math inline\">\\(O(m)\\)</span>: this is not quite true, though my\r\ndeception has been in the reader's best interests, and will not have led\r\nhim astray.<a href=\"#fn15\" class=\"footnote-ref\" id=\"fnref15\"\r\nrole=\"doc-noteref\"><sup>15</sup></a> It is true, and common sense, for\r\n<span class=\"math inline\">\\(\\Delta a\\)</span>, <span\r\nclass=\"math inline\">\\(\\Delta e\\)</span>, <span\r\nclass=\"math inline\">\\(\\Delta n\\)</span>, and <span\r\nclass=\"math inline\">\\(\\Delta \\epsilon\\)</span>. But the 'effect' of a\r\ngiven Aa vanishes when <span class=\"math inline\">\\(e=0\\)</span>, and is\r\nproportional to <span class=\"math inline\">\\(e\\)</span>. So it is <span\r\nclass=\"math inline\">\\(e\\Delta \\alpha\\)</span>, not <span\r\nclass=\"math inline\">\\(\\Delta \\alpha\\)</span>, that is comparable with\r\nthe other <span class=\"math inline\">\\(\\Delta\\)</span>'s and so <span\r\nclass=\"math inline\">\\(O(m)\\)</span>.<a href=\"#fn16\" class=\"footnote-ref\"\r\nid=\"fnref16\" role=\"doc-noteref\"><sup>16</sup></a></p>\r\n<p>We start from two well-known formulae. The first is geometrical; the\r\npolar equation of the ellipse of the orbit is</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nr = a(1- e^{2}) ( 1 +e \\cos (\\theta -a))^{-1}\r\n\\end{equation}\\]</span></p>\r\n<p>The second is dynamical; the equation of angular momentum (Kepler's\r\nsecond law) is</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}r^{2} \\frac{d\\theta}{dt}\r\n= na^{2} (1-e^{2})^{\\frac{1}{2}}\\end{equation}\\]</span></p>\r\n<p>So, using dots for time differentiations,</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\theta = n(1-e^{2})^{-\\frac{3}{2}} [1 - 2\\cos (\\theta -a) + 3e^{2}\r\n\\cos^{2} (\\theta -a ) + \\cdots]\r\n\\end{equation}\\]</span></p>\r\n<p>The first approximation (with <span\r\nclass=\"math inline\">\\(e=0\\)</span>) is <span\r\nclass=\"math inline\">\\(\\theta=nt + \\epsilon\\)</span>. We take suffixes 1\r\nand 2 in (6) and operate with <span\r\nclass=\"math inline\">\\(\\Delta\\)</span>, remembering that we may take\r\nfirst approximations in any <strong><em>factor</em></strong> of an <span\r\nclass=\"math inline\">\\(m\\)</span>.</p>\r\n<p>In estimating <span class=\"math inline\">\\(\\Delta\\theta\\)</span> we\r\nmay, with error <span class=\"math inline\">\\(O(em)\\)</span>, ignore the\r\nfactor <span class=\"math inline\">\\((1-e^{2})^{-\\frac{3}{2}}\\)</span> in\r\n(6), since it is itself <span\r\nclass=\"math inline\">\\(\\left(1+O(e^{2})\\right)\\)</span>, and its <span\r\nclass=\"math inline\">\\(\\Delta\\)</span> is <span\r\nclass=\"math inline\">\\(O(e\\Delta e)=O(em)\\)</span>. We have, therefore,\r\nwith error <span class=\"math inline\">\\(O(em)\\)</span>,</p>\r\n<p><span class=\"math display\">\\[\\Delta \\theta = \\Delta \\left\\{n[\\quad\r\n]\\right\\} = [\\quad ] \\Delta n + n \\Delta [\\quad ]\\]</span></p>\r\n<p>The 1st term is <span class=\"math inline\">\\(\\Delta n+O(em)\\)</span>.\r\nThe 2nd is</p>\r\n<p><span class=\"math display\">\\[n\\left[\\Delta e \\left\\{- 2 \\cos(\\theta\r\n-a ) + O(e)\\right\\} + \\Delta (\\theta -a ) \\left\\{2e \\sin (\\theta -a ) +\r\nO(e^{2}\\right\\}\\right]\\]</span></p>\r\n<p>and we may drop the <span class=\"math inline\">\\(\\theta\\)</span> in\r\n<span class=\"math inline\">\\(\\Delta (\\theta - a)\\)</span> on account of\r\nthe factor <span class=\"math inline\">\\(O(\\epsilon)\\)</span>. Summing up,\r\nwe obtain</p>\r\n<p><span class=\"math display\">\\[\\Delta \\theta = m (A+B \\cos (\\theta -a )\r\n+ C \\sin (\\theta -a ) ) + O(em)\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(mA=\\Delta n\\)</span>, <span\r\nclass=\"math inline\">\\(mB = -2n\\Delta e\\)</span>, <span\r\nclass=\"math inline\">\\(mC = -2n(e\\Delta a)\\)</span>. Substituting the\r\nfirst approximation <span class=\"math inline\">\\(\\theta=nt +\r\n\\epsilon\\)</span> in the right hand side, we have</p>\r\n<p><span class=\"math display\">\\[\\Delta \\theta = m (A+B \\cos (nt +\r\n\\epsilon -a ) + C \\sin (nt + \\epsilon -a ) ) + O(em)\\]</span></p>\r\n<p>and integration then gives</p>\r\n<p><span class=\"math display\">\\[\\Delta \\theta = m (A+B/n \\sin (nt +\r\n\\epsilon -a ) - C/n \\cos (nt + \\epsilon -a ) ) + O(em)\\]</span></p>\r\n<p>which, after expanding the sin and cos and rearranging, is of the\r\ndesired form (I).<a href=\"#fn17\" class=\"footnote-ref\" id=\"fnref17\"\r\nrole=\"doc-noteref\"><sup>17</sup></a></p>\r\n<aside id=\"footnotes\" class=\"footnotes footnotes-end-of-document\"\r\nrole=\"doc-endnotes\">\r\n<hr />\r\n<ol>\r\n<li id=\"fn1\"><p>Its attachment to the '3-body problem' misleads people\r\nto-day.<a href=\"#fnref1\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn2\"><p>The time at which NUS is a straight line (I shall use\r\nthe abbreviations S, U, N).<a href=\"#fnref2\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn3\"><p>It does not depend on <span\r\nclass=\"math inline\">\\(e\\)</span>.<a href=\"#fnref3\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn4\"><p>The total area of the ellipse is <span\r\nclass=\"math inline\">\\(\\pi ab\\)</span>, and it is swept out in time <span\r\nclass=\"math inline\">\\(p\\)</span>.<a href=\"#fnref4\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn5\"><p>Strictly speaking the a.m. should have the planet's mass\r\nas a factor: but <span class=\"math inline\">\\(U\\)</span>'s mass is\r\nirrelevant and I omit it throughout.<a href=\"#fnref5\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn6\"><p>Observations after 1840 were not immediately available,\r\nand anyhow were not used. Uranus was discovered in 1781. Lest the reader\r\nshould be worried by small inconsistencies in my dates I mention that\r\n1780 is 'used', the extrapolation being a safe one.<a href=\"#fnref6\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn7\"><p><strong><em>Collected Works, I</em></strong>, p. 11.\r\nThese (and not the modifications he introduces, which are what appear in\r\nSmart) are what is relevant for us.<a href=\"#fnref7\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn8\"><p>I should stress that there is no question of ignoring\r\neven high powers of <span class=\"math inline\">\\(e\\)</span>\r\n<strong><em>unaccompanied by a factor <span\r\nclass=\"math inline\">\\(m\\)</span></em></strong> (<span\r\nclass=\"math inline\">\\(e^{4}\\)</span> radians is about 1\"). The\r\ndistortion in the value found for <span class=\"math inline\">\\(t\\)</span>\r\nis, however, a sort of exception to this. But the effect of <span\r\nclass=\"math inline\">\\(e\\)</span>'s in distorting <span\r\nclass=\"math inline\">\\(t_{0}\\)</span> is unlikely to be worse than the\r\nseparation they create between time of conjunction and time of closest\r\napproach. An easy calculation shows that this last time difference is at\r\nworst 0-8 years.<a href=\"#fnref8\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn9\"><p>The orbits may have 'Suns' of masses differing by <span\r\nclass=\"math inline\">\\(O(m)\\)</span>.<a href=\"#fnref9\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn10\"><p>We allow, of course, <strong><em>negative</em></strong>\r\nvalues of <span class=\"math inline\">\\(t - t_{0}\\)</span> both in <span\r\nclass=\"math inline\">\\(E^{*}\\)</span> and in <span\r\nclass=\"math inline\">\\(\\vartheta\\)</span>.<a href=\"#fnref10\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn11\"><p>'<span class=\"math inline\">\\(\\Omega\\)</span>' is a\r\ndeputy for '<span class=\"math inline\">\\(O\\)</span>' (initial of 'odd'),\r\nwhich is otherwise engaged. The italicized statement in the text is true\r\n'by symmetry': alternatively, <strong><em>reverse</em></strong> the\r\nmotions from time <span class=\"math inline\">\\(t_{0}\\)</span>. (The\r\nargument covers also the 'perturbation of 'the Sun' which is not so\r\ncompletely negligible as might be supposed.)<a href=\"#fnref11\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn12\"><p>And the, values for <span\r\nclass=\"math inline\">\\(\\tau=6\\)</span> at <span\r\nclass=\"math inline\">\\(t_{0}=22, 22.4\\)</span> are more uncertain than\r\nusual because of a crisis in the smooth curve.<a href=\"#fnref12\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn13\"><p>From two second order differential equations. The\r\nformula involves 'quadratures', but in numerical calculation integration\r\nis quicker than multiplication. It would be comparatively easy to make a\r\ndouble entry table for <span class=\"math inline\">\\(\\vartheta(\\tau,\r\n\\lambda)/m\\)</span><a href=\"#fnref13\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn14\"><p>Perturbation theory calculations have necessarily to\r\n<strong><em>begin</em></strong> by guessing <span\r\nclass=\"math inline\">\\(a_{1}\\)</span>; our guess need only be at the\r\nend.<a href=\"#fnref14\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn15\"><p>'Wen Gott betrugt is wohl betrogon.'<a href=\"#fnref15\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn16\"><p>This twist makes the 'obvious' approach of using the\r\nweil known expansion <span class=\"math display\">\\[\\theta = nt +\\epsilon\r\n+ 2e \\sin (nt + \\epsilon -a) + \\frac{5}{4}e^{2} \\sin 2 (nt + \\epsilon -a\r\n) + \\cdots\\]</span> slightly tricky; we should have to keep the term in\r\n<span class=\"math inline\">\\(e^{2}\\)</span>. The line taken in the text\r\nside-steps this.<a href=\"#fnref16\" class=\"footnote-back\"\r\nrole=\"doc-backlink\"></a></p></li>\r\n<li id=\"fn17\"><p>We have treated <span class=\"math inline\">\\(\\Delta\r\nn\\)</span> and <span class=\"math inline\">\\(\\Delta a\\)</span> as\r\nindependent (the latter happens not to occur in the final formula for\r\n<span class=\"math inline\">\\(\\Delta \\theta\\)</span>): this amounts to\r\nallowing different masses to the two 'Suns'. The point is relevant to\r\ncertain subtleties, into which I will not enter.<a href=\"#fnref17\"\r\nclass=\"footnote-back\" role=\"doc-backlink\"></a></p></li>\r\n</ol>\r\n</aside>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Dec 31 2023 15:46:06 GMT+0800 ()","title":"The Discovery of Neptune (By J.E. Littlewood)","path":"2023/04/04/The Discovery of Neptune/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-04-04T12:02:28.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-04-04T12:02:28.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Notes","tags":["Notes"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Cyclotomic Fields","date":"2023-03-27T10:42:15.000Z","mathjax":true,"_content":"\n\n- Fermat's Little Theorem\n\n- Wilson's Theorem\n\n- Fermat's theorem on sums of two squares\n\n\n## Gaussian integers\n\nLet the ring of gaussian integers be \n\n$$\\mathbb{Z}[i]=\\left\\{a+bi|\\  a,b \\in \\mathbb{Z}\\right\\}, i= \\sqrt{-1}.$$\n\nwhich is a [UFD](https://en.wikipedia.org/wiki/Unique_factorization_domain)\n\n\n## Theorem 1\nThe prime elements $\\pi$ of $\\mathbb{Z}[i]$, up to associated elements,\nare given as follows.\n1. $\\pi = 1 +i$,\n2. $\\pi=a+b i$ with $a^{2} + b^{2} = p, p \\equiv 1 \\pmod 4, a>|b| >0$\n3. $\\pi =p$, $p=3 \\pmod 4$.\nHere, $p$ denotes a prime number of $\\mathbb{Z}$\n\n\n## Proof\n\n1. Numbers as in (1) or (2) are prime because a decomposition $\\pi = \\alpha \\cdot \\beta$ in $\\mathbb{Z}[i]$ implies an equation\n$$p = N(\\pi) = N(\\alpha) N(\\beta)$$,\nwith some prime number $p$. Hence either $N(\\alpha) = 1$ or $N(\\beta) = 1$, so that either $\\alpha$ or $\\beta$ is a unit. \n\n2. Numbers $\\pi = p$, where $p \\equiv 3 \\pmod 4$, are prime in $\\mathbb{Z} [i]$, because a decomposition $p = \\alpha \\cdot \\beta$ into non-units $\\alpha$, $\\beta$ would imply that $p^{2} = N(\\alpha) N(\\beta)$, so that $p = N(\\alpha) = N(a + bi) = a^{2} + b^{2}$. By [Wilson's theorem](https://en.wikipedia.org/wiki/Wilson%27s_theorem), for all prime numbers $p \\neq 2$. \n$$\\begin{equation}\np=a^{2}+b^{2} \\quad (a,b \\in \\mathbb{Z}) \\Longleftrightarrow p \\equiv 1 \\pmod 4\n\\end{equation}$$\nwhich according to the above Fermat's theorem on sums of two squares would yield $p = 1 \\pmod 4$.\n\n3. This being said, we have to check that an arbitrary prime element rr\nof $\\mathbb{Z}[i]$ is associated to one of those listed. First of all, the decomposition\n$$N(\\pi) = \\pi \\cdot \\bar{\\pi} = p_{1} \\cdots p_{r}$$\nwith rational primes $p_{i}$, shows that $\\pi | p$ for some $p = p_{i}$ This gives $N(\\pi) | N(p) = p^{2}$, so that either $N(\\pi) = p$ or $N\\pi = p^{2}$. In the case $N(\\pi) = p$ we get $\\pi = a + bi$ with $a^{2} + b^{2} = p$, so $\\pi$ is of type (2) or, if $p = 2$, it is associated to $1 + i$. On the other hand, if $N(\\pi) = p^{2}$, then $\\pi$ is associated to $p$ since $p/\\pi$ is an integer with norm one and thus a unit. Moreover, $p = 3 \\pmod 4$ has to hold in this case because otherwise we would have $p = 2$ or $p = 1 \\pmod 4$ and because of (1) $p = a^{2} + b^{2} = (a + bi) (a - bi)$ could not be prime. This completes the proof. $\\square$\n\n\n\n","source":"_drafts/Cyclotomic Fields.md","raw":"---\ntitle: Cyclotomic Fields\ndate: 2023-03-27 18:42:15\ntags:\n    - [Algebraic Number Theory]\ncategories:\n    - [Algebraic Number Theory]\nmathjax: true\n---\n\n\n- Fermat's Little Theorem\n\n- Wilson's Theorem\n\n- Fermat's theorem on sums of two squares\n\n\n## Gaussian integers\n\nLet the ring of gaussian integers be \n\n$$\\mathbb{Z}[i]=\\left\\{a+bi|\\  a,b \\in \\mathbb{Z}\\right\\}, i= \\sqrt{-1}.$$\n\nwhich is a [UFD](https://en.wikipedia.org/wiki/Unique_factorization_domain)\n\n\n## Theorem 1\nThe prime elements $\\pi$ of $\\mathbb{Z}[i]$, up to associated elements,\nare given as follows.\n1. $\\pi = 1 +i$,\n2. $\\pi=a+b i$ with $a^{2} + b^{2} = p, p \\equiv 1 \\pmod 4, a>|b| >0$\n3. $\\pi =p$, $p=3 \\pmod 4$.\nHere, $p$ denotes a prime number of $\\mathbb{Z}$\n\n\n## Proof\n\n1. Numbers as in (1) or (2) are prime because a decomposition $\\pi = \\alpha \\cdot \\beta$ in $\\mathbb{Z}[i]$ implies an equation\n$$p = N(\\pi) = N(\\alpha) N(\\beta)$$,\nwith some prime number $p$. Hence either $N(\\alpha) = 1$ or $N(\\beta) = 1$, so that either $\\alpha$ or $\\beta$ is a unit. \n\n2. Numbers $\\pi = p$, where $p \\equiv 3 \\pmod 4$, are prime in $\\mathbb{Z} [i]$, because a decomposition $p = \\alpha \\cdot \\beta$ into non-units $\\alpha$, $\\beta$ would imply that $p^{2} = N(\\alpha) N(\\beta)$, so that $p = N(\\alpha) = N(a + bi) = a^{2} + b^{2}$. By [Wilson's theorem](https://en.wikipedia.org/wiki/Wilson%27s_theorem), for all prime numbers $p \\neq 2$. \n$$\\begin{equation}\np=a^{2}+b^{2} \\quad (a,b \\in \\mathbb{Z}) \\Longleftrightarrow p \\equiv 1 \\pmod 4\n\\end{equation}$$\nwhich according to the above Fermat's theorem on sums of two squares would yield $p = 1 \\pmod 4$.\n\n3. This being said, we have to check that an arbitrary prime element rr\nof $\\mathbb{Z}[i]$ is associated to one of those listed. First of all, the decomposition\n$$N(\\pi) = \\pi \\cdot \\bar{\\pi} = p_{1} \\cdots p_{r}$$\nwith rational primes $p_{i}$, shows that $\\pi | p$ for some $p = p_{i}$ This gives $N(\\pi) | N(p) = p^{2}$, so that either $N(\\pi) = p$ or $N\\pi = p^{2}$. In the case $N(\\pi) = p$ we get $\\pi = a + bi$ with $a^{2} + b^{2} = p$, so $\\pi$ is of type (2) or, if $p = 2$, it is associated to $1 + i$. On the other hand, if $N(\\pi) = p^{2}$, then $\\pi$ is associated to $p$ since $p/\\pi$ is an integer with norm one and thus a unit. Moreover, $p = 3 \\pmod 4$ has to hold in this case because otherwise we would have $p = 2$ or $p = 1 \\pmod 4$ and because of (1) $p = a^{2} + b^{2} = (a + bi) (a - bi)$ could not be prime. This completes the proof. $\\square$\n\n\n\n","slug":"Cyclotomic Fields","published":0,"updated":"2023-04-06T11:17:47.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisunn000xeslr7o8q84gp","content":"<ul>\r\n<li><p>Fermat's Little Theorem</p></li>\r\n<li><p>Wilson's Theorem</p></li>\r\n<li><p>Fermat's theorem on sums of two squares</p></li>\r\n</ul>\r\n<h2 id=\"gaussian-integers\">Gaussian integers</h2>\r\n<p>Let the ring of gaussian integers be</p>\r\n<p><span class=\"math display\">\\[\\mathbb{Z}[i]=\\left\\{a+bi|\\  a,b \\in\r\n\\mathbb{Z}\\right\\}, i= \\sqrt{-1}.\\]</span></p>\r\n<p>which is a <a\r\nhref=\"https://en.wikipedia.org/wiki/Unique_factorization_domain\">UFD</a></p>\r\n<h2 id=\"theorem-1\">Theorem 1</h2>\r\n<p>The prime elements <span class=\"math inline\">\\(\\pi\\)</span> of <span\r\nclass=\"math inline\">\\(\\mathbb{Z}[i]\\)</span>, up to associated elements,\r\nare given as follows. 1. <span class=\"math inline\">\\(\\pi = 1\r\n+i\\)</span>, 2. <span class=\"math inline\">\\(\\pi=a+b i\\)</span> with\r\n<span class=\"math inline\">\\(a^{2} + b^{2} = p, p \\equiv 1 \\pmod 4,\r\na&gt;|b| &gt;0\\)</span> 3. <span class=\"math inline\">\\(\\pi =p\\)</span>,\r\n<span class=\"math inline\">\\(p=3 \\pmod 4\\)</span>. Here, <span\r\nclass=\"math inline\">\\(p\\)</span> denotes a prime number of <span\r\nclass=\"math inline\">\\(\\mathbb{Z}\\)</span></p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<ol type=\"1\">\r\n<li><p>Numbers as in (1) or (2) are prime because a decomposition <span\r\nclass=\"math inline\">\\(\\pi = \\alpha \\cdot \\beta\\)</span> in <span\r\nclass=\"math inline\">\\(\\mathbb{Z}[i]\\)</span> implies an equation <span\r\nclass=\"math display\">\\[p = N(\\pi) = N(\\alpha) N(\\beta)\\]</span>, with\r\nsome prime number <span class=\"math inline\">\\(p\\)</span>. Hence either\r\n<span class=\"math inline\">\\(N(\\alpha) = 1\\)</span> or <span\r\nclass=\"math inline\">\\(N(\\beta) = 1\\)</span>, so that either <span\r\nclass=\"math inline\">\\(\\alpha\\)</span> or <span\r\nclass=\"math inline\">\\(\\beta\\)</span> is a unit.</p></li>\r\n<li><p>Numbers <span class=\"math inline\">\\(\\pi = p\\)</span>, where <span\r\nclass=\"math inline\">\\(p \\equiv 3 \\pmod 4\\)</span>, are prime in <span\r\nclass=\"math inline\">\\(\\mathbb{Z} [i]\\)</span>, because a decomposition\r\n<span class=\"math inline\">\\(p = \\alpha \\cdot \\beta\\)</span> into\r\nnon-units <span class=\"math inline\">\\(\\alpha\\)</span>, <span\r\nclass=\"math inline\">\\(\\beta\\)</span> would imply that <span\r\nclass=\"math inline\">\\(p^{2} = N(\\alpha) N(\\beta)\\)</span>, so that <span\r\nclass=\"math inline\">\\(p = N(\\alpha) = N(a + bi) = a^{2} +\r\nb^{2}\\)</span>. By <a\r\nhref=\"https://en.wikipedia.org/wiki/Wilson%27s_theorem\">Wilson's\r\ntheorem</a>, for all prime numbers <span class=\"math inline\">\\(p \\neq\r\n2\\)</span>. <span class=\"math display\">\\[\\begin{equation}\r\np=a^{2}+b^{2} \\quad (a,b \\in \\mathbb{Z}) \\Longleftrightarrow p \\equiv 1\r\n\\pmod 4\r\n\\end{equation}\\]</span> which according to the above Fermat's theorem on\r\nsums of two squares would yield <span class=\"math inline\">\\(p = 1 \\pmod\r\n4\\)</span>.</p></li>\r\n<li><p>This being said, we have to check that an arbitrary prime element\r\nrr of <span class=\"math inline\">\\(\\mathbb{Z}[i]\\)</span> is associated\r\nto one of those listed. First of all, the decomposition <span\r\nclass=\"math display\">\\[N(\\pi) = \\pi \\cdot \\bar{\\pi} = p_{1} \\cdots\r\np_{r}\\]</span> with rational primes <span\r\nclass=\"math inline\">\\(p_{i}\\)</span>, shows that <span\r\nclass=\"math inline\">\\(\\pi | p\\)</span> for some <span\r\nclass=\"math inline\">\\(p = p_{i}\\)</span> This gives <span\r\nclass=\"math inline\">\\(N(\\pi) | N(p) = p^{2}\\)</span>, so that either\r\n<span class=\"math inline\">\\(N(\\pi) = p\\)</span> or <span\r\nclass=\"math inline\">\\(N\\pi = p^{2}\\)</span>. In the case <span\r\nclass=\"math inline\">\\(N(\\pi) = p\\)</span> we get <span\r\nclass=\"math inline\">\\(\\pi = a + bi\\)</span> with <span\r\nclass=\"math inline\">\\(a^{2} + b^{2} = p\\)</span>, so <span\r\nclass=\"math inline\">\\(\\pi\\)</span> is of type (2) or, if <span\r\nclass=\"math inline\">\\(p = 2\\)</span>, it is associated to <span\r\nclass=\"math inline\">\\(1 + i\\)</span>. On the other hand, if <span\r\nclass=\"math inline\">\\(N(\\pi) = p^{2}\\)</span>, then <span\r\nclass=\"math inline\">\\(\\pi\\)</span> is associated to <span\r\nclass=\"math inline\">\\(p\\)</span> since <span\r\nclass=\"math inline\">\\(p/\\pi\\)</span> is an integer with norm one and\r\nthus a unit. Moreover, <span class=\"math inline\">\\(p = 3 \\pmod\r\n4\\)</span> has to hold in this case because otherwise we would have\r\n<span class=\"math inline\">\\(p = 2\\)</span> or <span\r\nclass=\"math inline\">\\(p = 1 \\pmod 4\\)</span> and because of (1) <span\r\nclass=\"math inline\">\\(p = a^{2} + b^{2} = (a + bi) (a - bi)\\)</span>\r\ncould not be prime. This completes the proof. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p></li>\r\n</ol>\r\n","site":{"data":{}},"excerpt":"","more":"<ul>\r\n<li><p>Fermat's Little Theorem</p></li>\r\n<li><p>Wilson's Theorem</p></li>\r\n<li><p>Fermat's theorem on sums of two squares</p></li>\r\n</ul>\r\n<h2 id=\"gaussian-integers\">Gaussian integers</h2>\r\n<p>Let the ring of gaussian integers be</p>\r\n<p><span class=\"math display\">\\[\\mathbb{Z}[i]=\\left\\{a+bi|\\  a,b \\in\r\n\\mathbb{Z}\\right\\}, i= \\sqrt{-1}.\\]</span></p>\r\n<p>which is a <a\r\nhref=\"https://en.wikipedia.org/wiki/Unique_factorization_domain\">UFD</a></p>\r\n<h2 id=\"theorem-1\">Theorem 1</h2>\r\n<p>The prime elements <span class=\"math inline\">\\(\\pi\\)</span> of <span\r\nclass=\"math inline\">\\(\\mathbb{Z}[i]\\)</span>, up to associated elements,\r\nare given as follows. 1. <span class=\"math inline\">\\(\\pi = 1\r\n+i\\)</span>, 2. <span class=\"math inline\">\\(\\pi=a+b i\\)</span> with\r\n<span class=\"math inline\">\\(a^{2} + b^{2} = p, p \\equiv 1 \\pmod 4,\r\na&gt;|b| &gt;0\\)</span> 3. <span class=\"math inline\">\\(\\pi =p\\)</span>,\r\n<span class=\"math inline\">\\(p=3 \\pmod 4\\)</span>. Here, <span\r\nclass=\"math inline\">\\(p\\)</span> denotes a prime number of <span\r\nclass=\"math inline\">\\(\\mathbb{Z}\\)</span></p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<ol type=\"1\">\r\n<li><p>Numbers as in (1) or (2) are prime because a decomposition <span\r\nclass=\"math inline\">\\(\\pi = \\alpha \\cdot \\beta\\)</span> in <span\r\nclass=\"math inline\">\\(\\mathbb{Z}[i]\\)</span> implies an equation <span\r\nclass=\"math display\">\\[p = N(\\pi) = N(\\alpha) N(\\beta)\\]</span>, with\r\nsome prime number <span class=\"math inline\">\\(p\\)</span>. Hence either\r\n<span class=\"math inline\">\\(N(\\alpha) = 1\\)</span> or <span\r\nclass=\"math inline\">\\(N(\\beta) = 1\\)</span>, so that either <span\r\nclass=\"math inline\">\\(\\alpha\\)</span> or <span\r\nclass=\"math inline\">\\(\\beta\\)</span> is a unit.</p></li>\r\n<li><p>Numbers <span class=\"math inline\">\\(\\pi = p\\)</span>, where <span\r\nclass=\"math inline\">\\(p \\equiv 3 \\pmod 4\\)</span>, are prime in <span\r\nclass=\"math inline\">\\(\\mathbb{Z} [i]\\)</span>, because a decomposition\r\n<span class=\"math inline\">\\(p = \\alpha \\cdot \\beta\\)</span> into\r\nnon-units <span class=\"math inline\">\\(\\alpha\\)</span>, <span\r\nclass=\"math inline\">\\(\\beta\\)</span> would imply that <span\r\nclass=\"math inline\">\\(p^{2} = N(\\alpha) N(\\beta)\\)</span>, so that <span\r\nclass=\"math inline\">\\(p = N(\\alpha) = N(a + bi) = a^{2} +\r\nb^{2}\\)</span>. By <a\r\nhref=\"https://en.wikipedia.org/wiki/Wilson%27s_theorem\">Wilson's\r\ntheorem</a>, for all prime numbers <span class=\"math inline\">\\(p \\neq\r\n2\\)</span>. <span class=\"math display\">\\[\\begin{equation}\r\np=a^{2}+b^{2} \\quad (a,b \\in \\mathbb{Z}) \\Longleftrightarrow p \\equiv 1\r\n\\pmod 4\r\n\\end{equation}\\]</span> which according to the above Fermat's theorem on\r\nsums of two squares would yield <span class=\"math inline\">\\(p = 1 \\pmod\r\n4\\)</span>.</p></li>\r\n<li><p>This being said, we have to check that an arbitrary prime element\r\nrr of <span class=\"math inline\">\\(\\mathbb{Z}[i]\\)</span> is associated\r\nto one of those listed. First of all, the decomposition <span\r\nclass=\"math display\">\\[N(\\pi) = \\pi \\cdot \\bar{\\pi} = p_{1} \\cdots\r\np_{r}\\]</span> with rational primes <span\r\nclass=\"math inline\">\\(p_{i}\\)</span>, shows that <span\r\nclass=\"math inline\">\\(\\pi | p\\)</span> for some <span\r\nclass=\"math inline\">\\(p = p_{i}\\)</span> This gives <span\r\nclass=\"math inline\">\\(N(\\pi) | N(p) = p^{2}\\)</span>, so that either\r\n<span class=\"math inline\">\\(N(\\pi) = p\\)</span> or <span\r\nclass=\"math inline\">\\(N\\pi = p^{2}\\)</span>. In the case <span\r\nclass=\"math inline\">\\(N(\\pi) = p\\)</span> we get <span\r\nclass=\"math inline\">\\(\\pi = a + bi\\)</span> with <span\r\nclass=\"math inline\">\\(a^{2} + b^{2} = p\\)</span>, so <span\r\nclass=\"math inline\">\\(\\pi\\)</span> is of type (2) or, if <span\r\nclass=\"math inline\">\\(p = 2\\)</span>, it is associated to <span\r\nclass=\"math inline\">\\(1 + i\\)</span>. On the other hand, if <span\r\nclass=\"math inline\">\\(N(\\pi) = p^{2}\\)</span>, then <span\r\nclass=\"math inline\">\\(\\pi\\)</span> is associated to <span\r\nclass=\"math inline\">\\(p\\)</span> since <span\r\nclass=\"math inline\">\\(p/\\pi\\)</span> is an integer with norm one and\r\nthus a unit. Moreover, <span class=\"math inline\">\\(p = 3 \\pmod\r\n4\\)</span> has to hold in this case because otherwise we would have\r\n<span class=\"math inline\">\\(p = 2\\)</span> or <span\r\nclass=\"math inline\">\\(p = 1 \\pmod 4\\)</span> and because of (1) <span\r\nclass=\"math inline\">\\(p = a^{2} + b^{2} = (a + bi) (a - bi)\\)</span>\r\ncould not be prime. This completes the proof. <span\r\nclass=\"math inline\">\\(\\square\\)</span></p></li>\r\n</ol>\r\n"},{"title":"75 Problems in the Foundation of Mathematics","date":"2023-09-22T14:10:39.000Z","mathjax":true,"_content":"\n\n1) Lorsqu'un ensemble de points $P$ est une image biunivoque et continue (mais pas n\\'ecessairement bicontinue) d'un ensemble $Q$ et lorsque $Q$ est une image biunivoque et continue de $P$, lest ensembles $P$ et $Q$ sont-ils n\\'ecessairement homeomorphes?\n\nProbl\\'eme de M. W. Sierpinski.\n\n2) Un continu (born\\'e) plan, topologiquement homog\\`ene, est-il n\\'ecessairement hom\\'eomorphe \\`a une circonf\\'erence?\n\n(Un ensemble $E$ est dit *topologiquement homog\\'ene*, lorsqu'il existe pour tout couple de points $a,b$ de $E$ une transformation biunivoque et bicontinue de $E$ en lui-m\\'eme qui transforme $a$ en $b$)\n\nProbl\\'eme de MM. B. Knaster et C. Kuratowski.\n\n3) Un ensemble ordonn\\'e (lin\\'eairement) sans sauts ni lacunes et tel que tout ensemble de ses intervalles (contenant plus qu'un \\'el\\'ement) n'empi\\'etant pas les uns sur les autres est au plus d\\'enombrable, est-il n\\'ecessairement un continu lin\\'eaire (ordinaire)?\n\nProbl\\'eme de M. M. Souslin.\n\n4) Existe-t-il une d\\'ecomposition d'un intervalle en $\\aleph_{1}$ ensembles (non vides) mesurables $B$ et sans point commun deux \\`a deux?\n\nProbl\\'eme de M. W. Sierpinski.\n\n5) Existe-t-il un ensemble lin\\'eaire ind\\'enombrable $E$ tel que tout ensemble lin\\'eaire hom\\'eomorphe \\`a $E$ soit de mesure lebesguienne nulle? Peut-on d\\'emontrer l'existence d'un tel ensemble, m\\'eme en admettant que $2^{\\aleph_{0}} = \\aleph_{1}$?\n\nProbl\\'eme de M. W. Sierpinski.\n\n6) Peut-on d\\'emoutrer sans l'hypoth\\'ese du continu ($2^{\\aleph_{0}} = \\aleph_{1}$) qu'une somme de $\\aleph_{1}$ ensembles de mesure lebesguienne nulle n'est pas n\\'ecessairement de mesure lebesquienne nulle? qu'une somme de $\\aleph_{1}$ ensembles de premi\\'ere cat\\'egorie n'est pas n\\'ecessairement de premi\\'ere cat\\'egorie? qu'un produit de $\\aleph_{1}$ ensembles ($A$) n'est pas n\\'ecessairement un ensemble $A$?\n\nProbl\\'eme de M. W. Sierpinski.\n\n7) Peut-on \\'etablir sans l'hypoth\\'ese du continu l'esistence d'un ensemble plan qui est de mesure (lebesguienne) nulle sur toute parall\\'ele \\`a l'axe d'abscisses et dont le compl\\'ementaire est de mesure nulle sur toute parall\\'ele \\`a l'axe d'ordonn\\'ees?\n\nProbl\\'eme de M. H. Steinhaus.\n\n8) Peut-on donner un exemple effectif d'un ensemble de nombres r\\'eels $E$ tel que toute somme, toute diff\\'erence, tout produit et tout quotient de deux nombres de $E$ (la division par 0 except\\'ee) appartienne \\`a $E$ et que $E$ soit ind\\'enombrable, mais distinct de l'ensemble de tous les nombres r\\'eels?\n\nProbl\\'eme de M. S. Mazurkiewicz.\n\n9) Quelle est la puissance des ensembles compl\\'ementaires aux ensembles ($A$)?\n\nProbl\\'eme de M. N. Lusin.\n\n\n*Remarque*. Les ensembles ($A$) lin\\'eaires sont des projections orthogonales (sur une froite) des ensembles plans mesurables $B$. M. Lusin a d\\'emontr\\'e que la puissance d'un ensemble ind\\'enombrable compl\\'ementaire \\`a un ensemble ($A$) est $\\aleph_{1}$ ou $2^{\\aleph_{0}}$, mais on ne sait pas si elle peut \\^etre en r\\'ealit\\'e $\\aleph_{1}$ (dans le cas o\\'u $2^{\\aleph_{0}} > \\aleph_{1}$)\n\n10) Existe-t-il une fonction de deuxi\\'eme classe qui n'est pas une limite de fonctions presque partout continues? Peut-on donner un exemple effectif d'une fonction qui n'est pas une limite de fonctions ponctuellement discontinues?\n\nProbl\\'eme de MM. T. Feosztyn et W. Sierpinski.\n\n11) Existe il une classe ($\\mathcal{L}$) de M. Fr\\'echet (c'est-\\`a dire une classe dans laquelle la limite est d\\'efinie) de puissance sup\\'erieure \\`a celle du continu, telle que tout ensemble non d\\'enombrable d'\\'el\\'ements de cette classe contient au moins un \\'el\\'ement de condensation?\n\nProbl\\'eme de M. W. Sierpinski.\n\n12) Un ensemble ordonn\\'e (lin\\'eairement) dont tous les sousensembles bien ordonn\\'es (croissants et d\\'croissants) sont au plus d\\'enombrables, a-t-il n\\'ecessairement une puissance non sup\\'erieure \\`a celle du continu?\n\nProbl\\'eme de M. W. Sierpinski.\n\n13) Existe-il un ensemble plan ferm\\'e qui ne soit pas somme de deux ensembles ferm\\'es sans points communs, mais qui est une somme d'une infinit\\'e d\\'enombrable d'ensembles ferm\\'es sans points communs deux \\`a deux.\n\nProbl\\'eme de M. W. Sierpinski.\n\n14) Un continu dans l'espace \\`a $m$ dimensions qui est hom\\'eomorphe de tout continu qu'il contient, est il n\\'ecessairement un arc simple (c'est-\\`a-dire une image biunivoque et continu de l'intervalle 0-1)?\n\nProbl\\'eme de M. Mazurkiewicz.\n\n15) Existe-il un continu dont tout sous continu est ind\\'ecomposable? (Un continu est dit ind\\'ecomposable lorsqu'il n'est pas une somme de deux continus diff\\'erents de lui.)\n\nProbl\\'eme de MM. Knaster et Kuratowski.\n\n16) Existe il un continu (non born\\'e) qui est une somme de ses vrais sous continus satur\\'es n'ayant deux \\`a deux aucun point commun?\n\n(On dit qu'un vrai sous-continu $K$ de $C$ est *satur\\'e*, lorsqu'il n'existe aucun continu diff\\'erent de $K$ et de $C$ qui contienne $K$ et qui soit contenu dans $C$.)\n\nProbl\\'eme de M. Kuratowski.\n\n17) Quelle est la puissance de l'ensemble de toutes les valeurs que ne prend pas une fonction de classe 1 de M. Baire?\n\n(Ce probl\\'eme est \\'equivalent au probl\\'eme 9 de M. Lusin, t. I. p.224. Il suffirait de r\\'esoudre ce probl\\'eme pour les fonctions admettant une infinit\\'e d'enombrable de points de discontinuit\\'e.)\n\n18) Un ensemble (lin\\'eaire) de puissance inf\\'erieure \\`a celle du continu, est-il n\\'ecessairement d\\'e la premi\\'ere cath\\'egorie de M. Baire?\n\nProbl\\'eme de M. Ruziewicz.\n\n19) Existe-t-il dans chaque ensemble biconnexe $B$ un point $p$ tel que l'ensemble $B - (p)$ ne contient aucun ensemble connexe?\n\n*Remarque*. D'apre\\'es un th\\'eor\\'eme de M. Kline (ce volume, p.238), il ne peut exister dans un ensemble connexe $B$ plus d'un point $p$ jouissant de la propri\\'et\\'e en question. On sait, d'autre part, que, si un tel point existe, l'ensemble $B$ est biconnexe, c.-\\`a-d. il n'est pas somme de duex ensembles connexes disjoints cont\\'enant plus d'un point (cf. Knaster et Kuratowski, *Fund. Math.* II, p,214.)\n\nProbl\\'eme de M. Kuratowski.\n\n20) Soit $f(E)$ une fonction d\\'efinie por tout ensemble $E$ mesurable ($L$) d'un espace euclidien \\`a $m \\geq 3$ dimensions et satisfaisant aux conditions suivantes:\n\n1. $f(E)\\geq 0$.\n2. $f(E_{0}) = 1$ pur un certain ensemble $E_{0}$ de mesure 1.\n3. $f(E_{1} +E_{2}) = f(E_{1}) + f(E_{2})$, si $E_{1} E_{2} = 0$.\n4. $f(E_{1}) = f(E_{2})$, si $E_{1}$ et $E_{2}$ sont superposables.\n\nLa fonction $f(E)$ coincide-t-elle n\\'ecessairement avec la mesure lebesguienne de l'ensemble $E$?\n\n(Pour $m=1$ et $m=2$ la r\\'eponse est n\\'egative, comme l'a prouv\\'e M. Banach dans un m\\'emoire qui sera publi\\'e dans le tome IV de ce jounal.)\n\nProbl\\'eme de M. Ruziewicz.\n\n21) A \\'etant un ensemble de nombres r\\'eels qui n'est de I cat\\'egorie dans aucun intervalle, existe-il une d\\'ecomposition: $A = B + C$, $B \\times C = 0$ telle que ni $B$ ni $C$ ne soient de I cat\\'egorie dans aucun intervalle?\n\n*Remarque*. On en pourrait donner la solution affirmative dans l'hypoth\\'ese suppl\\'ementaire que $A$ poss\\'ede la propri\\'et\\'e de Baire (au sens etabli dans ce volume), p.319. M. Sierpinski en a signal\\'e d'autre part, la solution affirmative dans l'hypoth\\'ese du continu, $\\aleph_{1} = 2^{\\aleph_{0}}$.\n\nProblem of M. Kuratowski.\n\n22) Appellons l'ensemle (lin\\'eaire) $E$ *parfaitement mesurable*, si tout ensemble hom\\'eomorphe \\`a $E$ est mesurable au sens de Lebesgue. Quelle est la puissance de la classe des ensembles parfaitement mesurables? Un ensemble compl'ementaire \\`a un ensemble parf. mesurable est-il toujours parf. mesurable?\n\nProblem of M. Urysohn.\n\n23) Esiste-t-il une fonction d'une variable r\\'eelle $f(x)$ pantachiquement dicontinue et telle qu'on ait pour tout $x$ r\\'eel\n\n$$\\lim \\frac{f(x+h) - f(x-h)}{2h} = 0?$$\n\nProblem of M. Steinhaus.\n\n24) Une fonction satisfaisan \\`a la condition de Baire, est-elle n\\'ecessairement mesurable ($L$)? Quelle est la puissance de toutes les fonctions d'une variable r'eelle satisfaisant \\`a la condition de Baire? (On dit qu'une fonction $f(x)$ satisfait \\`a la condition de Baire, si elle continue sur tout ensemble parfait quand on n\\'eglige les ensembles de premi\\'ere cat\\'egorie par rapport \\`a cet ensemble parfait.)\n\nProblem of M. Sierpinski.\n\n25) Un ensemble plan, tel que toute droite le rencontre en deux (et seulement deux) points, peut-il \\^etre mesurable ($B$)? (L'existence d'un tel ensemble a \\'et\\'e d\\'emontr\\'e, \\`a l'aide du th\\'eor\\'eme de M. Zermelo, par MM. Mazurkiewicz[^1] (en 1914) et Rosenthal[^2] (en 1922))\n\n\n[^1] Comptes Rendus de lu Soc. des Sciences de Varsovic, t. VII, p.382.\n\n[^2] Sitzungaber d. Bayer. Akad. d. Wiss., math-phys. K1, 1922, p. 223.\n\n26) Une fonction de classe 3 de M. Baire, est-elle toujours une superposition de trois fonctions de classe 1, c'est-\\`a-dire existe-t-il pour toute fonction $f(x)$ de classe 3 trois fonctions $\\varphi(x)$, $\\psi(x)$ et $\\vartheta(x)$ de classe, telles qu'on a pour tout $x$ r\\'eel\n\n$$f(x) = \\varphi\\{\\psi[\\vartheta(x)]\\}$$\n\nProbl\\'eme de M. Lusin.\n\n27) L'ensemble $D(E)$ des distances des points d'un ensemble lin\\'eaire $E$ mesurable $(B)$, est-il toujours mesurable ($B$)? ( $D(E)$ est done l'ensemble de tous les nombres $|x-y|$, o\\'u $x$ et $y$ appartiennent \\`a $E$. On peut d\\'emontrer l'existence des ensembles $E$ mesurables ($L$), tels que $D(E)$ est non mesurable ($L$).) \n\nProbl\\'eme de M. Sierpinski.\n\n28) $E$ \\'etant un ensemble plan mesurable ($B$), d\\'esignons par $N(E)$ l'ensemble de tous les nombres r\\'eels $a$, tels que la droite $x = a$ rencontre $E$ en une infinit\\'e non-d\\'enombrable de points. L'ensemble $N(E)$, est il n\\'ecessairement un ensemble ($A$), ou, plus simplement, est-il mesurable ($L$)? (On peut d\\'emontrer que l'ensemble de tous les nombres r\\'eels $a$, tels que la droite $x = a$ rencontre l'ensemble $E$ (mesurable $B$) en une infinit\\'e de points est toujouts un ensemble $A$.)\n\nProbl\\'eme de M. Sierpinski.\n\n29) Soit $F$ un ensemble plan, p. ex. ferm\\'e (ou, plus g\\'en\\'eralement, mesurable)- Un point $x$ de $F$ sera dit *lin\\'eairment accessible* s'il sxiste un segment rectiligne $\\overline{xp}$ tel que tous ses points (le point $x$ except\\'e) soient \\'etrangers \\`a $F$. Peut-on d\\'emontrer que l'ensemble $A$ de tous les points lin\\'eairement accessibles de $F$ est toujours mesurable ($L$)?\n\nProbl\\'eme de M. Urysohn.\n\n30) $f(x)$ \\'etant une fonction donn\\'ee quelconque (mesurable ou non), quelle est la mesure de l'ensomble de tous les points $x$, tels que\n\n$$\\lim\\limits_{h\\to 0} \\left|\\frac{f(x+h) - f(x)}{h}\\right| = \\infty$$\n\nProbl\\'eme de M. Ruziewicz.\n\n31) Le th\\'eor\\'eme: \"$\\mathsf{m} = 2\\cdot \\mathsf{m}$ quel soit le nombre cardinal *transfini* $\\mathsf{m}$\" est il \\'equivalent \\`a *l'axiome du choix*?\n\nCf. ma Note \"*Sur quelques th\\'eor\\'emes qui \\'equivalent \\`a l'axiome du choix*\" dans ce volume, p. 147.\n\nProbl\\'eme de M. Tajtelbaum-Tarski.\n\n32) Un ensemble plan ferm\\'e, don tout point est lin\\'eairement accessible, est-il n\\'ecessairement de mesure superficielle nulle?\n\nProbl\\'eme de M. Banach.\n\nUn point $x$ de $F$ est dit lin\\'eairement accessible s'il existe un segment rectiligne $\\overline{xp}$ tel que tous ses points (le point $x$ excepr\\'e) soient \\'etrangers \\`a $F$. M. Urysohn a d\\'emontr\\'e que l'ensemble de tous les points lin\\'eairement accessibles d'un ensemble plan ferm\\'e est toujouts un ensemble ($A$) de M. Souslin, mais peut ne pas \\^etre mesurable ($B$). Or on ne sait pas si l'ensemble de tous les points lin\\'eairement accessibles d'un ensemble plan $G_{\\delta}$ est mesurable ($L$) (Cf. Probl\\'eme 29, *Fund. Math.* t. V, p. 337).\n\n33) Une image biunivoque et continue (dans un sens) d'un ensemble compl\\'emeutaire \\`a un ensemble ($A$) de M. Souslin, est elle de m\\^eme nature?\n\nProbl\\'eme de Sierpi\\'nski.\n\n34) Appelons un ensemble (lin\\`eaire) mesurable ($B$) de classe a *irr\\'eductible* s'il n'est de classe $<\\alpha$ dans aucun intervalle. Quelle est la puissance de l'ensemble de tous les types topologiques d'ensumbles irr\\'eductibles de classe $\\alpha$?\n\nAppelons un ensemble ($A$) irr\\'eductible, s'il n'est mesurable ($B$) dans aucun intervalle. Quelle est la puissance de tous les types topologiques des ensembles ($A$) irr\\'eductibles?\n\nProbl\\'eme de MM. Alexandroff et Urysohn.\n\n35) Appelons l'ensemble (lin\\'eaire) $E$ *parfaitement mesurable au sens \\'etroit*, si toute image univoque et continue de $E$ est mesurable au sens de Lebsgue. Un ensemble compl\\'ementaire \\`a un ensemble parfaitement mesurable au sens \\'etroit, est-il toujours de m\\^eme nature?\n\nCf. Probl\\'eme 22 de P. Urysohn (*Fund. Math.* t. IV, p. 368), r\\'esolu par M. Lavrentieff (*Fund. Math.* t. VI, p. 159).\n\nProbl\\'eme de M. O. Nikodym.\n\n36) D'apr\\'es M. Souslin, si $E$ est un ensemble ($A$) et $H$ un ensemble compl\\'ementaire \\`a un ensemble ($A$), et si $E \\subset H$, il existe un ensemble $Q$, mesurable ($B$), tel que $E\\subset Q \\subset H$[^3]. Cette proposition, admet-elle une r\\'eciproque, c'est-\\`a-dire, *$E$ \\'etant un ensemble compl\\'ementaire \\`a un ensemble ($A$) et $H$ ------ un ensemble ($A$), tel que $E \\subset H$, existe-til tujours un ensemble $Q$ mesurable ($B$), tel que $E \\subset Q \\subset H$?*\n\nProbl\\'eme de M. Sierpi\\'nski.\n\n[^3] Voir p. e. N. Lusin et W. Sierpi\\'nski *Journ. de Math.* t. II (1923) p. 60; aussi *Bull. Acad. Cracovie* 1918 p. 40.\n\n37) Un continu de Jordan (born\\'e) qui ne renferme qucune courbe simple ferm\\'ee est-il hom\\'eomorphe \\`a un de ses (vrais) sous-continus?\n\nProbl\\'eme de M. Zarankiewicz.\n\n38) Un carr\\'e et un cercle dont les aires sont \\'egales peuvent-ils \\^etre d\\'ecompos\\'es en un nombre fini de sous-ensembles disjoints repectivement congruents?\n\nProbl\\'eme de M. Tarski.\n\n39) Existe-il un ensemble ferm\\'e *plan* pour lequel l'ensemble des points lin\\'eairement accessibles soit non-mesurable ($B$)? (Dans l'espace le probl\\'eme est r\\'esolu par affirmative).\n\nProbl\\'eme de M. O. Nikodym.\n\n40) $E$ \\'etant un ensemble plan $G_{\\delta}$, l'ensemble de tous les nombres r\\'eels $a$, tels que la droite $x =a$ rencontre l'ensemble $E$ dans un et un seul point, est-il n\\'ecessairement compl\\'ementaire d'un ensemble ($A$) de M. Souslin?\n\nProbl\\'eme de M. Sierpi\\'nski.\n\n41) $E_{1}, E_{2}, E_{3}, \\dots$ \\'etant une suite d\\'enombrable d'ensembles lin\\'eaires dont chacun est une projection d;un ensemble plan compl\\'ementaire \\`a un ensemble ($A$) de M. Souslin, l'ensemble $E_{1}E_{2} E_{3} \\dots $ est il de m\\^eme nature?\n\nProbl\\'eme de M. Sierpi\\'nski.\n\n42) Existe-t-il dans tout continu $A$ un continu $B$ tel que l'ensemble $A-B$ soit connexe?\n\nProbl\\'eme de MM. Knaster et Zarankiewicz.\n\n\n43) $D$ d\\'esignant un ensemble ferm\\'e hom\\'eomorphe d'un ensemble plan et situ\\'e dans l'espace euclidien \\`a 3 dimensions, est-ce que tout point de $D$ est *accessible* dans cet espace?\n\n(Un point $d$ de $D$ est dit *accessible* dans $E$, lorsqu'il existe un continu $C \\subset E$ tel que $(d) = CD$).\n\nProbl\\'eme de M. Knaster.\n\n\n46) Es wird gefragt die logischen Relationen zwischen den verschiedenen Homogenit\\\"atsbegriffen aufzutellen, insoweit sie sich beziehen auf im kleinen kompakten Mengen. Insbesondere auch wenn die Mengen als ausammenh\\\"angend und (oder) im kleinen zusammenh\\\"angend vorausgesetzt werden.\n\n(Vgl. D. van Dantzig, \\\"ber topologisch homogene Kontinua, dieser Band, S. 102, 103).\n\nProbl\\'eme de M. van Dantzig.\n\n47) Ist eine jed (zusammenh\\\"angende, unberandete) $n$-dimensionale Mannigfaltigkeit involutorisch homogen?\n\n(Vgl. D. van Dantzig, l. e. S. 104, ^7.)\n\nProbl\\'eme de M. van Dantzig.\n\n48) Nennen wir eine topologische Gruppe *monothetisch*, falls eine unendliche zyklische Gruppe in ihr dicht liegt (in welchem Falle sie kommutativ ist und additiv geschrieben weden kann), und *komplett*, falls eine jede Folge $x_{\\nu}$, die dem Konvergenzkriterium Cauchy's $\\lim (x_{\\nu} - x_{\\mu} = 0$ gen\\\"ugt, ein Limeselement in der Gruppe besitzt, so wird gefragt, ob eine monothetische Gruppe komplett sein kann ohne kompakt zu sein.\n\n(Vgl. l. c. S. 116 ^{29}a)) \n\nProbl\\'eme de M. van Dantzig.\n\n49) Soient $X$ et $Y$ deux continus P\\'eaniens (= images continues de l'intervalle) et $Z$ leur produit topologique (= l'espace de tous les couples $z = (x,y)$ o\\'u $\\lim z_{n}=z$ lorsque $\\lim x_{n} = x$ et $\\lim y_{n} = y$).\n\n1^0. Si le continu $X$, ainsi que $Y$, poss\\'ede la propri\\'et\\'e que dans chaque transformation continue de ce continu en un sous-ensemble il existe un point invariant, est-il vrai que $Z$ poss\\'ede la m\\^eme propri\\'et\\'e?\n\n2^0. Si le continu $X$, ainsi que $Y$, est uni-coh\\'erent (= dans chaque d\\'ecomposition de ce continu en deus sous-continus la partie commune de ces sous-continus est connexe), est-il vrai que $Z$ est unicoh\\'erent?\n\nProbl\\'eme de M. Kuratowski.\n\n50) Ist der topologische Kreis die einzige homogene im kleinen zusammenh\\\"angende Kurve? (Kurve = eindimensionaler zusammen-h\\\"angender kompakter Raum. Homogen hei$\\beta$t ein Raum, der zu je zwei seiner Punkte $p$ und $q$ eine topologische Selbstabbildung besitzt die $p$ in $q$ \\\"uberf\\\"uhrt). In der Ebene ist der Kreis die einzige homogene im kleinen zusammenh\\\"angende Kurve.\n\n(Vgl. Mazurkiewicz, Fund. Math. V, S. 137).\n\nProbl\\'eme de M. K. Menger.\n\n51) Gibt es beliebig oder gar unendlich viele kompakte eindimensionale R\\\"aume, die zu je zweien eindimentional unvergleichbar sind? Dabei m\\\"ogen zwei R\\\"aume $R$ und $R^{\\prime}$ eindimentional unvergleichbar hei$\\beta$en, wenn keine eindimensionale Teilmenge von $R$, (bzw. von $R^{\\prime}$) hom\\\"oomorph ist mit einer Teilmenge von $R^{\\prime}$ (bzw. von $R^{\\prime}$). Beispielsweise sind eindimensional unvergleichbar eine Strecke und ein Kontinuum ohne Teilbogen. (Wenn es $n$, bzw. $\\aleph_{0}$ paarweise eindimensional unvergleichbare Kurven gibt, so existieren kompakte eindimensionale R\\\"aume, welche mindestens $2^{n} +1$, bze. $2^{\\aleph_{0}}$ monotone, $F_{\\sigma}$-additive, toppologische, kompaktifizierbare Systeme von Teilmengen enthalten).\n\n\n(Vgl. Monatshefte f. Math. u. Phys. 36, S. 207).\n\nProbl\\'eme de M. K. Menger.\n\n52) Existe-il un continu dont tout autre continu soit une image continue?\n\nProbl\\'eme de M. H. Hahn.\n\n\n53)\ta) Ist jeder absolute Retrakt in endlich viele absolute Retrakte mit beliebig kleinen Durchmessern zerlegbar?\n\nb) Lasst sieh jede $R$-Menge in endlich viele absolu#e Retrakte zerlegen?\n\n(Die Definition von absoluten Retrakten und von $R$-Mengen ist z. B. in meiner Note aus Fund. Math. XIX, S. 222 angegeben).\n\n54)\tIst jedes Teilkontinuum $C$ des eaklidieelien $n$-dimensionalen Raumes $R_{n}$, welches $R_{n}$ zerschneidet und welches eich durch beliebig kleine Transformationen (d. h. durch eine stetige Abbildung, welehe jeden Punkt von $C$ in einen beliebig nahe liegenden Punkt von $R_{n}$ tiberfiibrt) in eine mit ihm punktfremde Teilmenge von R. \\\"uberf\\\"uhren lasst, eine ($n-1$)-dimensionale Mannigfaltigkeit?\n\n55)\tL\\\"asst sich jedes in $R_{3}$ liegende und $R_{3}$ zerschneidende Streckenbild in eich stetig und fixpunktfrei abbilden?\n\nProbl\\'emes de M. K. Borsuk.\n\n58) Soient $A$ et $B$ deux espaces topologiques et $A^{2}$ et $B^{2}$ respectivement leur carr\\'es (a. \\`a. d. $A^{2}$ p. ex. se compose de tous tes couples ($a_{1}$, $a_{2}$) extraite de $A$).\n\nEst-il vrai que si $A^{2}$ et $B^{2}$ sont hom'eomorphes. $A$ et $B$ le sont aussi?\n\nEn ess de relronae positire, on en d\\'eduit que, $C$ \\'etant un ensemble qui n'est\nhom\\'eomorphe \\`a aucun, $C^{n}$, $n>1$, les ensembles $C^{m}$ et $C^{n}$ ne sont non plus hom\\'eomorphes pour $m\\neq n$; cela fournit dans le eas o\\`u $C$ est un intervalle 1e th\\'eor\\'eme de \"l'invariance de la dimension\" de M. Brouwer.\n\nProbl\\'eme de M. S. Ulam.\n\n57) Existe-il un continu de dimension infinie qui n'en contient aucun de dimension finie?\n\nProbl'eme de M. S. Mazurkiewicz.\n \n58)\tGibt es in einer Menge $E$ von der M\\\"achtigkeit $\\aleph_{1}$ ein abz\\\"ahlbares System von Teilmengen $A_{1}, A_{2},\\dots$ derart, dass man in der Gestalt\n$$X = \\overline{\\lim} A_{p_{n}}$$\n($p_{1}, p_{2},,\\dots$ Teilfolge der nat\\\"urlichen Zahlen, $\\overline{\\lim}$ bedeutet dag Barel-sche *ensemble limite complet*) alle Teilmengen $X$ von $E$ erh\\\"alt?\n\n(Es handelt sich, die Verneinung ohne Benutzung der Kontinuumhypethese zu beweisen).\n\nProbl\\'me de M. F. Hausdorff.\n\n59)\tUne fonction jouissant de la propri\\'et\\'e de Baire (c'est-\\`a-dire continue sur tout ensemble parfait, lorsqu'on n\\'eglige un ensemble de\t$1^{re}$ cat\\'egorie relativement \\`a cet ensemble) d'une fonction jouiseant de la propri\\'et\\'e de Baire, est-elle de la m\\^eme nature?\n\nProbl\\'eme de M. W. Sierpi\\'nski.\n\n60)\tSoit $\\rho$ l'ensemble de toutes les transformations hom\\'eomorphes du plan cart\\'esien en lui-m\\^eme, de la forme:\n$$x^{\\prime} = x, \\quad y^{\\prime} =f(x,y)$$\net\n$$x^{\\prime}=g(x,y), \\quad\ty^{\\prime}=y.$$\n\nD\\'esignons par $\\sigma$ le groupe form\\'e par toutes les superpositions finies de toutes les transformations appartenant \\`a $\\rho$. Une transformation hom\\'eomorphe arbitraire du plan en lui-m\\^eme se laisse-telle toujours approcher par celles du groupe $\\sigma$?\n\nUn probl\\'eme analogue subsiste pour les espaces \\`a $n>2$ dimensions.\nProbl\\'eme de M. S. Ulam.\n\n61)\tSoit $E$ un ensemble plan $G_{\\delta}$ (plus g\\'en\\'eralement: un ensemble borelien) dont tontes les intersections avec les droites parall\\'eles \\`a l'axe des $y$ sont des ensembles ferm\\'es (plus g\\'en\\'eralement: des $F_{\\sigma}$). La projection de $E$ sur l'axe des $x$ est-elle toujours un ensemble\nborelien?\t\n\nProbl\\'eme de M. E. Szpilrajsn.\n\n62)\tDie (reelle) Funktion $f(x)$ der reellen Variablen $x$ heisse *symmetrisch-stetig* wenn f\\\"ur jedes $x$\n$$\\lim\\limits_{h \\to 0} [f(x+h) - f(x - h)] = O.$$\nKann die Menge der Unstetigkeitsstellen einer solchen Funktion unabz\\\"ahlbar sein? Kann sie eine beliebig vorgeschriebene Menge $F_{\\sigma}$ sei? (Dass sie eine beliebig vorgeschriebene abz\\\"ahlbare Menge sein\nkann, ist leicht einzusehen.)\n\nProbl\\'eme de M. F. Hausdorff.\n\n63)\tDeux espaces compacts $A$ et $B$ ont le *m\\^eme type d'homotopie*, lorsqu'il existe une transformation continue $f$ de $A$ en $B$ et une transformation continue $f$ de $A$ en $B$ et une transformation continue $\\varphi$ de $B$ en $A$, telles que les transformations superpos\\'ees $\\varphi f$ et $f\\varphi$ (consid\\'er\\'ees respectivement comme des trans-formations de $A$ en $A$ et de $B$ en $B$) soient homotopes \\`a l'identit\\'e. Deux vari\\'et\\'es ferm\\'ees de m\\^eme type d'homotopie sont-elles toujours hom\\'eomorphes?\n\nProbl\\'eme de M. W. Hurewicz.\n\n64)\tGibt es im $R^{n}$ zwei orientierbare Mannigfaltigkeiten $M_{1}^{k}$ und $M_{2}^{k}$, deren Komplement\\\"arr\\\"aume $R^{n} - M_{1}^{k}$ und $R^{n} - M_{2}^{k}$ hom\\\"oomorph und deren Homologieringe nicht isomorph sind?\n\n65)\tSoient $B_{0}, B_{1}, B_{2}, \\dots, B_{\\omega}, \\dots, B_{\\alpha}, \\dots$ des classes boreliennes d'ensembles, form\\'ees en partant d'une classe quelconque d'ensembles abstraits. On sait que $B_{\\alpha} = B_{\\alpha+}$. entra\\^ine $B_{\\alpha}= B_{\\beta}$ pour tout $\\beta>\\alpha$; soit $\\alpha_{0}$ le premier nombre $\\alpha$ satisfaisant \\`a cette condition. Quels sont les nombres $v$ pour lesquels il existe des classes $B_{0}$ telles que l'on ait $\\alpha_{0} = v$? (Cf. Fund. Math. t. XV, p. 284).\n\nProbl\\'emes de M. A. Ko1mogoroff.\n\n66) La propri\\'et\\'e $LC$ *faible* entra\\^ine-t-elle la propri\\'et\\'e $LC$ forte pour tout espace m\\'etrique compact? M\\^eme question pour les pro-pri\\'et\\'es $HLC$. (Pour les d\\'efinitions voir Anaals of Mathematics, vol. 85, p. 119-129 et Duke Mathematical Journal, vol. 1, p. 1-18).\n\nProbl\\'eme de M. S. Lefschetz.\n\n67)\tLa propri\\'et\\'e ($C$) des ensembles lin\\'eaires est elle invariante par rapport aux transformations hom\\'eomorphes et, plus g\\'en\\'erale-ment, par rapport aux transformations continues? (On dit qu'un ensemble $E$ poss\\'ede la *propri\\'et\\'e* ($C$), lorsqu'il existe pour chaque suite $\\{a_{n}\\}$ de nombres positifs une d\\'ecomposition $E=E_{1}+E_{2} + \\dots $ telle que le diam\\'etre de $E_{n}$ ne d'epasse pas $a_{n}$ pour $n=1, 2,\\dots$. Cf. Fund. Math, t. XI, p. 304; t. XV, p. 126; t. XXII, p. 310.)\n\nProbl\\'eme de M. W. Sierpi\\'nski.\n\n68)\tTai et $E_{1}$ \\'etant deux ensembles lin\\'eaires toujours de premi\\'ere cat\\'egorie (c. \\`a d. de premi\\'ere cat\\'egorie sur tout ensemble parfait), l'ensemble $E_{1} \\times E_{2}$. (c. \\`a\td. l'ensemble de tous les points $(x, y)$ du plan o\\'u $x \\in E_{1}$ et $y \\in E_{2}$) est-il de m\\^eme nature?\n\nProbl\\'eme de M. E. Szpilrajn.\n\n69) Lorsqu'une conrbe de Jordan (dans un espace \\`a trois dimensions) poss\\'ede en  chaque point une tangente d\\'etermin\\'ee, existe-t-il n\\'ecessairement une repr\\esentation param\\'etrique de cette courbe exprimant les coordonn\\'ees cart\\'esiennes d'un point de cette courbe comme fonctions d\\'erivables d'un param\\'etre (et cela sans que les trois d\\'erive\\'ees s'annulent en m\\^eme temps)?\n\nEn cas de r\\'epinse n\\'egative, la question est repos\\'ee en admenttant un ensemble de mesure nulle de valeues du param\\'etre o\\'u les conditions impos\\'ees ne sont pas toutes deux v\\'erifi\\'ees.\n\nProbl\\'eme de M. M. Fr\\'echet.\n\n70) Existe-t-il un ensemble lin\\'eaire $E$ tel que chaque ensemmble analytique lin\\'eaire est une image biunivoque et continue (dans un sens) de $E$?\n\nProbl\\'eme de M. W. Sierpi\\'nski.\n\n71) Existe-t-il une suite infinie $S$ de fonctions d'une variable r\\'eelle (mesurables ou non), telle que toute fonction d'une variable r\\'eelle dde classe $2$ Baire soit limite d'une suit extraite de $S$?\n\n(D'apr\\'es M. C. Burstin une telle suite $S$ ne peut \\^etre compos\\'ee uniquement de fonctions mesurables[^4])\n\nProbl\\'eme de M. W. Sierpi\\'nski.\n\n[^4] Monatshefte f. Math. u. Phys. 28 (1917), p. 107.\n\n72) Existe-t-il dans l'espace cart\\'esien \\`a $n$ dimensions ($n>1$) un ensemble toujours de premi\\'ere cat\\'egorie (c. \\`a d. de premi\\'ere cat\\'egorie sur chaque ensemble parfait) et qui soit de dimension positive?\n\n(M. W. Hurewicz a d\\'emontr\\'e \\`a l'aide de l'hypoth\\'ese du continu qu'il existe dans l'espace de Hilbert un ensemble ind\\'enombrable $H$ dont chaque sous-ensemble ind\\'enombrable est de dimension infinie[^5]). M. F. Hausdorff a remarqu\\'e l'ensemble $H$ est toujours de premi\\'ere cat\\'egorie. Cela r\\'esulte ais\\'ement du fait que chaque espace m\\'etrique s\\'eparable $M$ est somme d'un ensemble de dimension $0$ et d'un ensemble de premi\\'ere cat\\'egorie dans $M$. -- *Il existe donc, so $2^{\\aleph} = \\aleph_{1}$, dons l'espace de Hilbert un ensemble toujours de premi\\'erie cat\\'egorie et de dimension positive*).\n\nProbl\\'eme de M. E. Szpilrajn.\n\n[^5] Fund. Math. 19 (1932), p.8.\n\n\n73) Soient, dans l'espace euclidien \\`a trois dimensions, $E$ une image hom\\'eomorphe de la sph'ere solide $S$ et $L$ un segment rectiligne dont l'int'erieur est contenu dans l'int'erieur, et les extr'emeit'es dans la fronti'ere de $E$. Existe-t-il toujours une hom\\'eomorphie transformant $E$ en $S$ de facon que $L$ soit transorm\\'e en diam\\'etre de $S$?\n\nProbl\\'eme de M. K. Borsuk.\n\n74) Soit $\\mathbf{B}(\\mathbf{F})$ la plus petite famille d'ensembles contenant la famille donn\\'ee $\\mathbf{F}$ et close par rapoort aux op\\'erations $\\sigma$ et $\\delta$ (addition et multiplication d\\'enombrables). Existe-t-il une famille d\\'enombrable $\\mathbf{D}$ d'ensembles, telle que tous les ensembles analytiques lin\\'eaires appartiennent \\`a $\\mathbf{B}(\\mathbf{D})$?\n\nProbl\\'eme de M. S. Ulam.\n\n\n75) Existe-t-il un ensemble infini $E$ (p.e. l'ensemble de tous les nombres naturels) et une fonction $f(X)$ qui fait correspondre \\`a tout sous-ensemble $X$ de $E$ un sous-ensemble $f(X)$ de $E$, de sorte que:\n\n1$^\\circ$ $X \\subset f(X)$ pour $X \\subset E$,\n2$^\\circ$ $f(X+Y) = f(X) + f(Y)$ pour $X \\subset E$, $Y \\subset E$,\n3$^\\circ$ il existe pour tout ensemble $Y \\subset E$ au moins un ensemble $X \\subset E$, tel que $Y = f(X)$,\n4$^\\circ$ il existe au moins un ensemble $X_{0} \\subset E$, tel que $f(X_{0}) \\neq X_{0}$.\n\nSi l'on remplace la condition relative \\`a $f(X+Y)$ par la condition plus faible que $f(X) \\subset f(Y)$ pur $X \\subset Y \\subset E$, la r\\'eponse positive est \\'evidente. \n\nProbl\\'eme de M. E. \\v{C}ech.\n\n\n\n\n\n## Probl\\'emes r\\e'solus.\n\nProbl. 1) Lorsque un ensemble de points $P$ est une image biunvoque et continue (dans un sens) de $Q$ et $Q$ est une image biunivoque et continue de $P$, peut-on affirmer que les ensembles $P$ et $Q$ sont hom\\'eomorphes?\n\nSolution *n\\'egative* de M. Kuratowski, *Fund. Math.* t. II, pp. 158-160\n\n4) Existe-il une d\\'ecomposition d'un intervalle en $\\aleph_{1}$ ensembles mesurables ($B$), non-vides et sans points communs deux \\`a deux?\n\nSolution *affirmative* de MM. Lusin et Sierpinski, *Comptes Rendus*, t. 175, p.357 (note du 21 ao\\^ut 1922).\n\n6, troisi\\'eme partie) Peut-on d\\'emontrer qu'un produit de $\\aleph_{1}$ ensembles ($A$) n'est pas n\\'ecessairement un ensemble ($A$)?\n\nSolution *affirmative* de MM. Lusin et Sierpinski, *Journ, de Math*. 1923 (Les auteurs d\\'efinissent un ensemble qui est compl\\'ementaire d'un ensemble ($A$) n'est pas n\\'ecessairement un ensemble ($A$))\n\n8) Peut-on donner un exemple effectif d'un ensemble de nombres r\\'eels $E$, tel que toute somme, toute diff\\'erence, tout produit et tout quotient de deux nombres de $E$ (except\\'e la division par 0) appartienne \\`a $E_{1}$ et que $E$ soit non-d\\'enombrable, distinct de l'ensemble de tous les nombres r\\'eels?\n\nSolution *affirmative* de M. Souslin, *Fund. Math.* IV, p.311.\n\n10, premi\\'ere partie) Existe-il une fonction de deuxi\\'eme classe qui ne soit pas la limite de fonctions preque partout discontinues?\n\nSolution *affirmative* de M. Zalcwasser.\n\n12) Un ensemble ordonn\\'e dont tous les sous-ensembles bien ordonn\\'es (croissants on d\\'ecroissants) sont au plus d\\'enombraibles, a-t-il n\\'ecessairement une puissance non sup\\'erieure \\`a celle du continu?\n\nSolution *affirmative* de M. Urysohn, *Fund. Math.* V (h paraitre).\n\n15) Existe-il un continu dont tout sous-continu est ind\\'ecomposable?\n\nSolution *affirmative* de M. Knaster, *Fund. Math.* III pp. 247-286.\n\n16) Existe-il continu qui est une somme de ses vrais sous-continues satur\\'es disjoints?\n\nSolution *affirmative* de M. Knaster et Kuratowski, *Fund. Math.* V (\\`a paraitre).\n\n\n\n\n","source":"_drafts/75 Probelms (French).md","raw":"---\ntitle: 75 Problems in the Foundation of Mathematics\ndate: 2023-09-22 22:10:39\ntags:\n    - [Set Theory]\ncategories:\n    - [Set Theory]\nmathjax: true\n---\n\n\n1) Lorsqu'un ensemble de points $P$ est une image biunivoque et continue (mais pas n\\'ecessairement bicontinue) d'un ensemble $Q$ et lorsque $Q$ est une image biunivoque et continue de $P$, lest ensembles $P$ et $Q$ sont-ils n\\'ecessairement homeomorphes?\n\nProbl\\'eme de M. W. Sierpinski.\n\n2) Un continu (born\\'e) plan, topologiquement homog\\`ene, est-il n\\'ecessairement hom\\'eomorphe \\`a une circonf\\'erence?\n\n(Un ensemble $E$ est dit *topologiquement homog\\'ene*, lorsqu'il existe pour tout couple de points $a,b$ de $E$ une transformation biunivoque et bicontinue de $E$ en lui-m\\'eme qui transforme $a$ en $b$)\n\nProbl\\'eme de MM. B. Knaster et C. Kuratowski.\n\n3) Un ensemble ordonn\\'e (lin\\'eairement) sans sauts ni lacunes et tel que tout ensemble de ses intervalles (contenant plus qu'un \\'el\\'ement) n'empi\\'etant pas les uns sur les autres est au plus d\\'enombrable, est-il n\\'ecessairement un continu lin\\'eaire (ordinaire)?\n\nProbl\\'eme de M. M. Souslin.\n\n4) Existe-t-il une d\\'ecomposition d'un intervalle en $\\aleph_{1}$ ensembles (non vides) mesurables $B$ et sans point commun deux \\`a deux?\n\nProbl\\'eme de M. W. Sierpinski.\n\n5) Existe-t-il un ensemble lin\\'eaire ind\\'enombrable $E$ tel que tout ensemble lin\\'eaire hom\\'eomorphe \\`a $E$ soit de mesure lebesguienne nulle? Peut-on d\\'emontrer l'existence d'un tel ensemble, m\\'eme en admettant que $2^{\\aleph_{0}} = \\aleph_{1}$?\n\nProbl\\'eme de M. W. Sierpinski.\n\n6) Peut-on d\\'emoutrer sans l'hypoth\\'ese du continu ($2^{\\aleph_{0}} = \\aleph_{1}$) qu'une somme de $\\aleph_{1}$ ensembles de mesure lebesguienne nulle n'est pas n\\'ecessairement de mesure lebesquienne nulle? qu'une somme de $\\aleph_{1}$ ensembles de premi\\'ere cat\\'egorie n'est pas n\\'ecessairement de premi\\'ere cat\\'egorie? qu'un produit de $\\aleph_{1}$ ensembles ($A$) n'est pas n\\'ecessairement un ensemble $A$?\n\nProbl\\'eme de M. W. Sierpinski.\n\n7) Peut-on \\'etablir sans l'hypoth\\'ese du continu l'esistence d'un ensemble plan qui est de mesure (lebesguienne) nulle sur toute parall\\'ele \\`a l'axe d'abscisses et dont le compl\\'ementaire est de mesure nulle sur toute parall\\'ele \\`a l'axe d'ordonn\\'ees?\n\nProbl\\'eme de M. H. Steinhaus.\n\n8) Peut-on donner un exemple effectif d'un ensemble de nombres r\\'eels $E$ tel que toute somme, toute diff\\'erence, tout produit et tout quotient de deux nombres de $E$ (la division par 0 except\\'ee) appartienne \\`a $E$ et que $E$ soit ind\\'enombrable, mais distinct de l'ensemble de tous les nombres r\\'eels?\n\nProbl\\'eme de M. S. Mazurkiewicz.\n\n9) Quelle est la puissance des ensembles compl\\'ementaires aux ensembles ($A$)?\n\nProbl\\'eme de M. N. Lusin.\n\n\n*Remarque*. Les ensembles ($A$) lin\\'eaires sont des projections orthogonales (sur une froite) des ensembles plans mesurables $B$. M. Lusin a d\\'emontr\\'e que la puissance d'un ensemble ind\\'enombrable compl\\'ementaire \\`a un ensemble ($A$) est $\\aleph_{1}$ ou $2^{\\aleph_{0}}$, mais on ne sait pas si elle peut \\^etre en r\\'ealit\\'e $\\aleph_{1}$ (dans le cas o\\'u $2^{\\aleph_{0}} > \\aleph_{1}$)\n\n10) Existe-t-il une fonction de deuxi\\'eme classe qui n'est pas une limite de fonctions presque partout continues? Peut-on donner un exemple effectif d'une fonction qui n'est pas une limite de fonctions ponctuellement discontinues?\n\nProbl\\'eme de MM. T. Feosztyn et W. Sierpinski.\n\n11) Existe il une classe ($\\mathcal{L}$) de M. Fr\\'echet (c'est-\\`a dire une classe dans laquelle la limite est d\\'efinie) de puissance sup\\'erieure \\`a celle du continu, telle que tout ensemble non d\\'enombrable d'\\'el\\'ements de cette classe contient au moins un \\'el\\'ement de condensation?\n\nProbl\\'eme de M. W. Sierpinski.\n\n12) Un ensemble ordonn\\'e (lin\\'eairement) dont tous les sousensembles bien ordonn\\'es (croissants et d\\'croissants) sont au plus d\\'enombrables, a-t-il n\\'ecessairement une puissance non sup\\'erieure \\`a celle du continu?\n\nProbl\\'eme de M. W. Sierpinski.\n\n13) Existe-il un ensemble plan ferm\\'e qui ne soit pas somme de deux ensembles ferm\\'es sans points communs, mais qui est une somme d'une infinit\\'e d\\'enombrable d'ensembles ferm\\'es sans points communs deux \\`a deux.\n\nProbl\\'eme de M. W. Sierpinski.\n\n14) Un continu dans l'espace \\`a $m$ dimensions qui est hom\\'eomorphe de tout continu qu'il contient, est il n\\'ecessairement un arc simple (c'est-\\`a-dire une image biunivoque et continu de l'intervalle 0-1)?\n\nProbl\\'eme de M. Mazurkiewicz.\n\n15) Existe-il un continu dont tout sous continu est ind\\'ecomposable? (Un continu est dit ind\\'ecomposable lorsqu'il n'est pas une somme de deux continus diff\\'erents de lui.)\n\nProbl\\'eme de MM. Knaster et Kuratowski.\n\n16) Existe il un continu (non born\\'e) qui est une somme de ses vrais sous continus satur\\'es n'ayant deux \\`a deux aucun point commun?\n\n(On dit qu'un vrai sous-continu $K$ de $C$ est *satur\\'e*, lorsqu'il n'existe aucun continu diff\\'erent de $K$ et de $C$ qui contienne $K$ et qui soit contenu dans $C$.)\n\nProbl\\'eme de M. Kuratowski.\n\n17) Quelle est la puissance de l'ensemble de toutes les valeurs que ne prend pas une fonction de classe 1 de M. Baire?\n\n(Ce probl\\'eme est \\'equivalent au probl\\'eme 9 de M. Lusin, t. I. p.224. Il suffirait de r\\'esoudre ce probl\\'eme pour les fonctions admettant une infinit\\'e d'enombrable de points de discontinuit\\'e.)\n\n18) Un ensemble (lin\\'eaire) de puissance inf\\'erieure \\`a celle du continu, est-il n\\'ecessairement d\\'e la premi\\'ere cath\\'egorie de M. Baire?\n\nProbl\\'eme de M. Ruziewicz.\n\n19) Existe-t-il dans chaque ensemble biconnexe $B$ un point $p$ tel que l'ensemble $B - (p)$ ne contient aucun ensemble connexe?\n\n*Remarque*. D'apre\\'es un th\\'eor\\'eme de M. Kline (ce volume, p.238), il ne peut exister dans un ensemble connexe $B$ plus d'un point $p$ jouissant de la propri\\'et\\'e en question. On sait, d'autre part, que, si un tel point existe, l'ensemble $B$ est biconnexe, c.-\\`a-d. il n'est pas somme de duex ensembles connexes disjoints cont\\'enant plus d'un point (cf. Knaster et Kuratowski, *Fund. Math.* II, p,214.)\n\nProbl\\'eme de M. Kuratowski.\n\n20) Soit $f(E)$ une fonction d\\'efinie por tout ensemble $E$ mesurable ($L$) d'un espace euclidien \\`a $m \\geq 3$ dimensions et satisfaisant aux conditions suivantes:\n\n1. $f(E)\\geq 0$.\n2. $f(E_{0}) = 1$ pur un certain ensemble $E_{0}$ de mesure 1.\n3. $f(E_{1} +E_{2}) = f(E_{1}) + f(E_{2})$, si $E_{1} E_{2} = 0$.\n4. $f(E_{1}) = f(E_{2})$, si $E_{1}$ et $E_{2}$ sont superposables.\n\nLa fonction $f(E)$ coincide-t-elle n\\'ecessairement avec la mesure lebesguienne de l'ensemble $E$?\n\n(Pour $m=1$ et $m=2$ la r\\'eponse est n\\'egative, comme l'a prouv\\'e M. Banach dans un m\\'emoire qui sera publi\\'e dans le tome IV de ce jounal.)\n\nProbl\\'eme de M. Ruziewicz.\n\n21) A \\'etant un ensemble de nombres r\\'eels qui n'est de I cat\\'egorie dans aucun intervalle, existe-il une d\\'ecomposition: $A = B + C$, $B \\times C = 0$ telle que ni $B$ ni $C$ ne soient de I cat\\'egorie dans aucun intervalle?\n\n*Remarque*. On en pourrait donner la solution affirmative dans l'hypoth\\'ese suppl\\'ementaire que $A$ poss\\'ede la propri\\'et\\'e de Baire (au sens etabli dans ce volume), p.319. M. Sierpinski en a signal\\'e d'autre part, la solution affirmative dans l'hypoth\\'ese du continu, $\\aleph_{1} = 2^{\\aleph_{0}}$.\n\nProblem of M. Kuratowski.\n\n22) Appellons l'ensemle (lin\\'eaire) $E$ *parfaitement mesurable*, si tout ensemble hom\\'eomorphe \\`a $E$ est mesurable au sens de Lebesgue. Quelle est la puissance de la classe des ensembles parfaitement mesurables? Un ensemble compl'ementaire \\`a un ensemble parf. mesurable est-il toujours parf. mesurable?\n\nProblem of M. Urysohn.\n\n23) Esiste-t-il une fonction d'une variable r\\'eelle $f(x)$ pantachiquement dicontinue et telle qu'on ait pour tout $x$ r\\'eel\n\n$$\\lim \\frac{f(x+h) - f(x-h)}{2h} = 0?$$\n\nProblem of M. Steinhaus.\n\n24) Une fonction satisfaisan \\`a la condition de Baire, est-elle n\\'ecessairement mesurable ($L$)? Quelle est la puissance de toutes les fonctions d'une variable r'eelle satisfaisant \\`a la condition de Baire? (On dit qu'une fonction $f(x)$ satisfait \\`a la condition de Baire, si elle continue sur tout ensemble parfait quand on n\\'eglige les ensembles de premi\\'ere cat\\'egorie par rapport \\`a cet ensemble parfait.)\n\nProblem of M. Sierpinski.\n\n25) Un ensemble plan, tel que toute droite le rencontre en deux (et seulement deux) points, peut-il \\^etre mesurable ($B$)? (L'existence d'un tel ensemble a \\'et\\'e d\\'emontr\\'e, \\`a l'aide du th\\'eor\\'eme de M. Zermelo, par MM. Mazurkiewicz[^1] (en 1914) et Rosenthal[^2] (en 1922))\n\n\n[^1] Comptes Rendus de lu Soc. des Sciences de Varsovic, t. VII, p.382.\n\n[^2] Sitzungaber d. Bayer. Akad. d. Wiss., math-phys. K1, 1922, p. 223.\n\n26) Une fonction de classe 3 de M. Baire, est-elle toujours une superposition de trois fonctions de classe 1, c'est-\\`a-dire existe-t-il pour toute fonction $f(x)$ de classe 3 trois fonctions $\\varphi(x)$, $\\psi(x)$ et $\\vartheta(x)$ de classe, telles qu'on a pour tout $x$ r\\'eel\n\n$$f(x) = \\varphi\\{\\psi[\\vartheta(x)]\\}$$\n\nProbl\\'eme de M. Lusin.\n\n27) L'ensemble $D(E)$ des distances des points d'un ensemble lin\\'eaire $E$ mesurable $(B)$, est-il toujours mesurable ($B$)? ( $D(E)$ est done l'ensemble de tous les nombres $|x-y|$, o\\'u $x$ et $y$ appartiennent \\`a $E$. On peut d\\'emontrer l'existence des ensembles $E$ mesurables ($L$), tels que $D(E)$ est non mesurable ($L$).) \n\nProbl\\'eme de M. Sierpinski.\n\n28) $E$ \\'etant un ensemble plan mesurable ($B$), d\\'esignons par $N(E)$ l'ensemble de tous les nombres r\\'eels $a$, tels que la droite $x = a$ rencontre $E$ en une infinit\\'e non-d\\'enombrable de points. L'ensemble $N(E)$, est il n\\'ecessairement un ensemble ($A$), ou, plus simplement, est-il mesurable ($L$)? (On peut d\\'emontrer que l'ensemble de tous les nombres r\\'eels $a$, tels que la droite $x = a$ rencontre l'ensemble $E$ (mesurable $B$) en une infinit\\'e de points est toujouts un ensemble $A$.)\n\nProbl\\'eme de M. Sierpinski.\n\n29) Soit $F$ un ensemble plan, p. ex. ferm\\'e (ou, plus g\\'en\\'eralement, mesurable)- Un point $x$ de $F$ sera dit *lin\\'eairment accessible* s'il sxiste un segment rectiligne $\\overline{xp}$ tel que tous ses points (le point $x$ except\\'e) soient \\'etrangers \\`a $F$. Peut-on d\\'emontrer que l'ensemble $A$ de tous les points lin\\'eairement accessibles de $F$ est toujours mesurable ($L$)?\n\nProbl\\'eme de M. Urysohn.\n\n30) $f(x)$ \\'etant une fonction donn\\'ee quelconque (mesurable ou non), quelle est la mesure de l'ensomble de tous les points $x$, tels que\n\n$$\\lim\\limits_{h\\to 0} \\left|\\frac{f(x+h) - f(x)}{h}\\right| = \\infty$$\n\nProbl\\'eme de M. Ruziewicz.\n\n31) Le th\\'eor\\'eme: \"$\\mathsf{m} = 2\\cdot \\mathsf{m}$ quel soit le nombre cardinal *transfini* $\\mathsf{m}$\" est il \\'equivalent \\`a *l'axiome du choix*?\n\nCf. ma Note \"*Sur quelques th\\'eor\\'emes qui \\'equivalent \\`a l'axiome du choix*\" dans ce volume, p. 147.\n\nProbl\\'eme de M. Tajtelbaum-Tarski.\n\n32) Un ensemble plan ferm\\'e, don tout point est lin\\'eairement accessible, est-il n\\'ecessairement de mesure superficielle nulle?\n\nProbl\\'eme de M. Banach.\n\nUn point $x$ de $F$ est dit lin\\'eairement accessible s'il existe un segment rectiligne $\\overline{xp}$ tel que tous ses points (le point $x$ excepr\\'e) soient \\'etrangers \\`a $F$. M. Urysohn a d\\'emontr\\'e que l'ensemble de tous les points lin\\'eairement accessibles d'un ensemble plan ferm\\'e est toujouts un ensemble ($A$) de M. Souslin, mais peut ne pas \\^etre mesurable ($B$). Or on ne sait pas si l'ensemble de tous les points lin\\'eairement accessibles d'un ensemble plan $G_{\\delta}$ est mesurable ($L$) (Cf. Probl\\'eme 29, *Fund. Math.* t. V, p. 337).\n\n33) Une image biunivoque et continue (dans un sens) d'un ensemble compl\\'emeutaire \\`a un ensemble ($A$) de M. Souslin, est elle de m\\^eme nature?\n\nProbl\\'eme de Sierpi\\'nski.\n\n34) Appelons un ensemble (lin\\`eaire) mesurable ($B$) de classe a *irr\\'eductible* s'il n'est de classe $<\\alpha$ dans aucun intervalle. Quelle est la puissance de l'ensemble de tous les types topologiques d'ensumbles irr\\'eductibles de classe $\\alpha$?\n\nAppelons un ensemble ($A$) irr\\'eductible, s'il n'est mesurable ($B$) dans aucun intervalle. Quelle est la puissance de tous les types topologiques des ensembles ($A$) irr\\'eductibles?\n\nProbl\\'eme de MM. Alexandroff et Urysohn.\n\n35) Appelons l'ensemble (lin\\'eaire) $E$ *parfaitement mesurable au sens \\'etroit*, si toute image univoque et continue de $E$ est mesurable au sens de Lebsgue. Un ensemble compl\\'ementaire \\`a un ensemble parfaitement mesurable au sens \\'etroit, est-il toujours de m\\^eme nature?\n\nCf. Probl\\'eme 22 de P. Urysohn (*Fund. Math.* t. IV, p. 368), r\\'esolu par M. Lavrentieff (*Fund. Math.* t. VI, p. 159).\n\nProbl\\'eme de M. O. Nikodym.\n\n36) D'apr\\'es M. Souslin, si $E$ est un ensemble ($A$) et $H$ un ensemble compl\\'ementaire \\`a un ensemble ($A$), et si $E \\subset H$, il existe un ensemble $Q$, mesurable ($B$), tel que $E\\subset Q \\subset H$[^3]. Cette proposition, admet-elle une r\\'eciproque, c'est-\\`a-dire, *$E$ \\'etant un ensemble compl\\'ementaire \\`a un ensemble ($A$) et $H$ ------ un ensemble ($A$), tel que $E \\subset H$, existe-til tujours un ensemble $Q$ mesurable ($B$), tel que $E \\subset Q \\subset H$?*\n\nProbl\\'eme de M. Sierpi\\'nski.\n\n[^3] Voir p. e. N. Lusin et W. Sierpi\\'nski *Journ. de Math.* t. II (1923) p. 60; aussi *Bull. Acad. Cracovie* 1918 p. 40.\n\n37) Un continu de Jordan (born\\'e) qui ne renferme qucune courbe simple ferm\\'ee est-il hom\\'eomorphe \\`a un de ses (vrais) sous-continus?\n\nProbl\\'eme de M. Zarankiewicz.\n\n38) Un carr\\'e et un cercle dont les aires sont \\'egales peuvent-ils \\^etre d\\'ecompos\\'es en un nombre fini de sous-ensembles disjoints repectivement congruents?\n\nProbl\\'eme de M. Tarski.\n\n39) Existe-il un ensemble ferm\\'e *plan* pour lequel l'ensemble des points lin\\'eairement accessibles soit non-mesurable ($B$)? (Dans l'espace le probl\\'eme est r\\'esolu par affirmative).\n\nProbl\\'eme de M. O. Nikodym.\n\n40) $E$ \\'etant un ensemble plan $G_{\\delta}$, l'ensemble de tous les nombres r\\'eels $a$, tels que la droite $x =a$ rencontre l'ensemble $E$ dans un et un seul point, est-il n\\'ecessairement compl\\'ementaire d'un ensemble ($A$) de M. Souslin?\n\nProbl\\'eme de M. Sierpi\\'nski.\n\n41) $E_{1}, E_{2}, E_{3}, \\dots$ \\'etant une suite d\\'enombrable d'ensembles lin\\'eaires dont chacun est une projection d;un ensemble plan compl\\'ementaire \\`a un ensemble ($A$) de M. Souslin, l'ensemble $E_{1}E_{2} E_{3} \\dots $ est il de m\\^eme nature?\n\nProbl\\'eme de M. Sierpi\\'nski.\n\n42) Existe-t-il dans tout continu $A$ un continu $B$ tel que l'ensemble $A-B$ soit connexe?\n\nProbl\\'eme de MM. Knaster et Zarankiewicz.\n\n\n43) $D$ d\\'esignant un ensemble ferm\\'e hom\\'eomorphe d'un ensemble plan et situ\\'e dans l'espace euclidien \\`a 3 dimensions, est-ce que tout point de $D$ est *accessible* dans cet espace?\n\n(Un point $d$ de $D$ est dit *accessible* dans $E$, lorsqu'il existe un continu $C \\subset E$ tel que $(d) = CD$).\n\nProbl\\'eme de M. Knaster.\n\n\n46) Es wird gefragt die logischen Relationen zwischen den verschiedenen Homogenit\\\"atsbegriffen aufzutellen, insoweit sie sich beziehen auf im kleinen kompakten Mengen. Insbesondere auch wenn die Mengen als ausammenh\\\"angend und (oder) im kleinen zusammenh\\\"angend vorausgesetzt werden.\n\n(Vgl. D. van Dantzig, \\\"ber topologisch homogene Kontinua, dieser Band, S. 102, 103).\n\nProbl\\'eme de M. van Dantzig.\n\n47) Ist eine jed (zusammenh\\\"angende, unberandete) $n$-dimensionale Mannigfaltigkeit involutorisch homogen?\n\n(Vgl. D. van Dantzig, l. e. S. 104, ^7.)\n\nProbl\\'eme de M. van Dantzig.\n\n48) Nennen wir eine topologische Gruppe *monothetisch*, falls eine unendliche zyklische Gruppe in ihr dicht liegt (in welchem Falle sie kommutativ ist und additiv geschrieben weden kann), und *komplett*, falls eine jede Folge $x_{\\nu}$, die dem Konvergenzkriterium Cauchy's $\\lim (x_{\\nu} - x_{\\mu} = 0$ gen\\\"ugt, ein Limeselement in der Gruppe besitzt, so wird gefragt, ob eine monothetische Gruppe komplett sein kann ohne kompakt zu sein.\n\n(Vgl. l. c. S. 116 ^{29}a)) \n\nProbl\\'eme de M. van Dantzig.\n\n49) Soient $X$ et $Y$ deux continus P\\'eaniens (= images continues de l'intervalle) et $Z$ leur produit topologique (= l'espace de tous les couples $z = (x,y)$ o\\'u $\\lim z_{n}=z$ lorsque $\\lim x_{n} = x$ et $\\lim y_{n} = y$).\n\n1^0. Si le continu $X$, ainsi que $Y$, poss\\'ede la propri\\'et\\'e que dans chaque transformation continue de ce continu en un sous-ensemble il existe un point invariant, est-il vrai que $Z$ poss\\'ede la m\\^eme propri\\'et\\'e?\n\n2^0. Si le continu $X$, ainsi que $Y$, est uni-coh\\'erent (= dans chaque d\\'ecomposition de ce continu en deus sous-continus la partie commune de ces sous-continus est connexe), est-il vrai que $Z$ est unicoh\\'erent?\n\nProbl\\'eme de M. Kuratowski.\n\n50) Ist der topologische Kreis die einzige homogene im kleinen zusammenh\\\"angende Kurve? (Kurve = eindimensionaler zusammen-h\\\"angender kompakter Raum. Homogen hei$\\beta$t ein Raum, der zu je zwei seiner Punkte $p$ und $q$ eine topologische Selbstabbildung besitzt die $p$ in $q$ \\\"uberf\\\"uhrt). In der Ebene ist der Kreis die einzige homogene im kleinen zusammenh\\\"angende Kurve.\n\n(Vgl. Mazurkiewicz, Fund. Math. V, S. 137).\n\nProbl\\'eme de M. K. Menger.\n\n51) Gibt es beliebig oder gar unendlich viele kompakte eindimensionale R\\\"aume, die zu je zweien eindimentional unvergleichbar sind? Dabei m\\\"ogen zwei R\\\"aume $R$ und $R^{\\prime}$ eindimentional unvergleichbar hei$\\beta$en, wenn keine eindimensionale Teilmenge von $R$, (bzw. von $R^{\\prime}$) hom\\\"oomorph ist mit einer Teilmenge von $R^{\\prime}$ (bzw. von $R^{\\prime}$). Beispielsweise sind eindimensional unvergleichbar eine Strecke und ein Kontinuum ohne Teilbogen. (Wenn es $n$, bzw. $\\aleph_{0}$ paarweise eindimensional unvergleichbare Kurven gibt, so existieren kompakte eindimensionale R\\\"aume, welche mindestens $2^{n} +1$, bze. $2^{\\aleph_{0}}$ monotone, $F_{\\sigma}$-additive, toppologische, kompaktifizierbare Systeme von Teilmengen enthalten).\n\n\n(Vgl. Monatshefte f. Math. u. Phys. 36, S. 207).\n\nProbl\\'eme de M. K. Menger.\n\n52) Existe-il un continu dont tout autre continu soit une image continue?\n\nProbl\\'eme de M. H. Hahn.\n\n\n53)\ta) Ist jeder absolute Retrakt in endlich viele absolute Retrakte mit beliebig kleinen Durchmessern zerlegbar?\n\nb) Lasst sieh jede $R$-Menge in endlich viele absolu#e Retrakte zerlegen?\n\n(Die Definition von absoluten Retrakten und von $R$-Mengen ist z. B. in meiner Note aus Fund. Math. XIX, S. 222 angegeben).\n\n54)\tIst jedes Teilkontinuum $C$ des eaklidieelien $n$-dimensionalen Raumes $R_{n}$, welches $R_{n}$ zerschneidet und welches eich durch beliebig kleine Transformationen (d. h. durch eine stetige Abbildung, welehe jeden Punkt von $C$ in einen beliebig nahe liegenden Punkt von $R_{n}$ tiberfiibrt) in eine mit ihm punktfremde Teilmenge von R. \\\"uberf\\\"uhren lasst, eine ($n-1$)-dimensionale Mannigfaltigkeit?\n\n55)\tL\\\"asst sich jedes in $R_{3}$ liegende und $R_{3}$ zerschneidende Streckenbild in eich stetig und fixpunktfrei abbilden?\n\nProbl\\'emes de M. K. Borsuk.\n\n58) Soient $A$ et $B$ deux espaces topologiques et $A^{2}$ et $B^{2}$ respectivement leur carr\\'es (a. \\`a. d. $A^{2}$ p. ex. se compose de tous tes couples ($a_{1}$, $a_{2}$) extraite de $A$).\n\nEst-il vrai que si $A^{2}$ et $B^{2}$ sont hom'eomorphes. $A$ et $B$ le sont aussi?\n\nEn ess de relronae positire, on en d\\'eduit que, $C$ \\'etant un ensemble qui n'est\nhom\\'eomorphe \\`a aucun, $C^{n}$, $n>1$, les ensembles $C^{m}$ et $C^{n}$ ne sont non plus hom\\'eomorphes pour $m\\neq n$; cela fournit dans le eas o\\`u $C$ est un intervalle 1e th\\'eor\\'eme de \"l'invariance de la dimension\" de M. Brouwer.\n\nProbl\\'eme de M. S. Ulam.\n\n57) Existe-il un continu de dimension infinie qui n'en contient aucun de dimension finie?\n\nProbl'eme de M. S. Mazurkiewicz.\n \n58)\tGibt es in einer Menge $E$ von der M\\\"achtigkeit $\\aleph_{1}$ ein abz\\\"ahlbares System von Teilmengen $A_{1}, A_{2},\\dots$ derart, dass man in der Gestalt\n$$X = \\overline{\\lim} A_{p_{n}}$$\n($p_{1}, p_{2},,\\dots$ Teilfolge der nat\\\"urlichen Zahlen, $\\overline{\\lim}$ bedeutet dag Barel-sche *ensemble limite complet*) alle Teilmengen $X$ von $E$ erh\\\"alt?\n\n(Es handelt sich, die Verneinung ohne Benutzung der Kontinuumhypethese zu beweisen).\n\nProbl\\'me de M. F. Hausdorff.\n\n59)\tUne fonction jouissant de la propri\\'et\\'e de Baire (c'est-\\`a-dire continue sur tout ensemble parfait, lorsqu'on n\\'eglige un ensemble de\t$1^{re}$ cat\\'egorie relativement \\`a cet ensemble) d'une fonction jouiseant de la propri\\'et\\'e de Baire, est-elle de la m\\^eme nature?\n\nProbl\\'eme de M. W. Sierpi\\'nski.\n\n60)\tSoit $\\rho$ l'ensemble de toutes les transformations hom\\'eomorphes du plan cart\\'esien en lui-m\\^eme, de la forme:\n$$x^{\\prime} = x, \\quad y^{\\prime} =f(x,y)$$\net\n$$x^{\\prime}=g(x,y), \\quad\ty^{\\prime}=y.$$\n\nD\\'esignons par $\\sigma$ le groupe form\\'e par toutes les superpositions finies de toutes les transformations appartenant \\`a $\\rho$. Une transformation hom\\'eomorphe arbitraire du plan en lui-m\\^eme se laisse-telle toujours approcher par celles du groupe $\\sigma$?\n\nUn probl\\'eme analogue subsiste pour les espaces \\`a $n>2$ dimensions.\nProbl\\'eme de M. S. Ulam.\n\n61)\tSoit $E$ un ensemble plan $G_{\\delta}$ (plus g\\'en\\'eralement: un ensemble borelien) dont tontes les intersections avec les droites parall\\'eles \\`a l'axe des $y$ sont des ensembles ferm\\'es (plus g\\'en\\'eralement: des $F_{\\sigma}$). La projection de $E$ sur l'axe des $x$ est-elle toujours un ensemble\nborelien?\t\n\nProbl\\'eme de M. E. Szpilrajsn.\n\n62)\tDie (reelle) Funktion $f(x)$ der reellen Variablen $x$ heisse *symmetrisch-stetig* wenn f\\\"ur jedes $x$\n$$\\lim\\limits_{h \\to 0} [f(x+h) - f(x - h)] = O.$$\nKann die Menge der Unstetigkeitsstellen einer solchen Funktion unabz\\\"ahlbar sein? Kann sie eine beliebig vorgeschriebene Menge $F_{\\sigma}$ sei? (Dass sie eine beliebig vorgeschriebene abz\\\"ahlbare Menge sein\nkann, ist leicht einzusehen.)\n\nProbl\\'eme de M. F. Hausdorff.\n\n63)\tDeux espaces compacts $A$ et $B$ ont le *m\\^eme type d'homotopie*, lorsqu'il existe une transformation continue $f$ de $A$ en $B$ et une transformation continue $f$ de $A$ en $B$ et une transformation continue $\\varphi$ de $B$ en $A$, telles que les transformations superpos\\'ees $\\varphi f$ et $f\\varphi$ (consid\\'er\\'ees respectivement comme des trans-formations de $A$ en $A$ et de $B$ en $B$) soient homotopes \\`a l'identit\\'e. Deux vari\\'et\\'es ferm\\'ees de m\\^eme type d'homotopie sont-elles toujours hom\\'eomorphes?\n\nProbl\\'eme de M. W. Hurewicz.\n\n64)\tGibt es im $R^{n}$ zwei orientierbare Mannigfaltigkeiten $M_{1}^{k}$ und $M_{2}^{k}$, deren Komplement\\\"arr\\\"aume $R^{n} - M_{1}^{k}$ und $R^{n} - M_{2}^{k}$ hom\\\"oomorph und deren Homologieringe nicht isomorph sind?\n\n65)\tSoient $B_{0}, B_{1}, B_{2}, \\dots, B_{\\omega}, \\dots, B_{\\alpha}, \\dots$ des classes boreliennes d'ensembles, form\\'ees en partant d'une classe quelconque d'ensembles abstraits. On sait que $B_{\\alpha} = B_{\\alpha+}$. entra\\^ine $B_{\\alpha}= B_{\\beta}$ pour tout $\\beta>\\alpha$; soit $\\alpha_{0}$ le premier nombre $\\alpha$ satisfaisant \\`a cette condition. Quels sont les nombres $v$ pour lesquels il existe des classes $B_{0}$ telles que l'on ait $\\alpha_{0} = v$? (Cf. Fund. Math. t. XV, p. 284).\n\nProbl\\'emes de M. A. Ko1mogoroff.\n\n66) La propri\\'et\\'e $LC$ *faible* entra\\^ine-t-elle la propri\\'et\\'e $LC$ forte pour tout espace m\\'etrique compact? M\\^eme question pour les pro-pri\\'et\\'es $HLC$. (Pour les d\\'efinitions voir Anaals of Mathematics, vol. 85, p. 119-129 et Duke Mathematical Journal, vol. 1, p. 1-18).\n\nProbl\\'eme de M. S. Lefschetz.\n\n67)\tLa propri\\'et\\'e ($C$) des ensembles lin\\'eaires est elle invariante par rapport aux transformations hom\\'eomorphes et, plus g\\'en\\'erale-ment, par rapport aux transformations continues? (On dit qu'un ensemble $E$ poss\\'ede la *propri\\'et\\'e* ($C$), lorsqu'il existe pour chaque suite $\\{a_{n}\\}$ de nombres positifs une d\\'ecomposition $E=E_{1}+E_{2} + \\dots $ telle que le diam\\'etre de $E_{n}$ ne d'epasse pas $a_{n}$ pour $n=1, 2,\\dots$. Cf. Fund. Math, t. XI, p. 304; t. XV, p. 126; t. XXII, p. 310.)\n\nProbl\\'eme de M. W. Sierpi\\'nski.\n\n68)\tTai et $E_{1}$ \\'etant deux ensembles lin\\'eaires toujours de premi\\'ere cat\\'egorie (c. \\`a d. de premi\\'ere cat\\'egorie sur tout ensemble parfait), l'ensemble $E_{1} \\times E_{2}$. (c. \\`a\td. l'ensemble de tous les points $(x, y)$ du plan o\\'u $x \\in E_{1}$ et $y \\in E_{2}$) est-il de m\\^eme nature?\n\nProbl\\'eme de M. E. Szpilrajn.\n\n69) Lorsqu'une conrbe de Jordan (dans un espace \\`a trois dimensions) poss\\'ede en  chaque point une tangente d\\'etermin\\'ee, existe-t-il n\\'ecessairement une repr\\esentation param\\'etrique de cette courbe exprimant les coordonn\\'ees cart\\'esiennes d'un point de cette courbe comme fonctions d\\'erivables d'un param\\'etre (et cela sans que les trois d\\'erive\\'ees s'annulent en m\\^eme temps)?\n\nEn cas de r\\'epinse n\\'egative, la question est repos\\'ee en admenttant un ensemble de mesure nulle de valeues du param\\'etre o\\'u les conditions impos\\'ees ne sont pas toutes deux v\\'erifi\\'ees.\n\nProbl\\'eme de M. M. Fr\\'echet.\n\n70) Existe-t-il un ensemble lin\\'eaire $E$ tel que chaque ensemmble analytique lin\\'eaire est une image biunivoque et continue (dans un sens) de $E$?\n\nProbl\\'eme de M. W. Sierpi\\'nski.\n\n71) Existe-t-il une suite infinie $S$ de fonctions d'une variable r\\'eelle (mesurables ou non), telle que toute fonction d'une variable r\\'eelle dde classe $2$ Baire soit limite d'une suit extraite de $S$?\n\n(D'apr\\'es M. C. Burstin une telle suite $S$ ne peut \\^etre compos\\'ee uniquement de fonctions mesurables[^4])\n\nProbl\\'eme de M. W. Sierpi\\'nski.\n\n[^4] Monatshefte f. Math. u. Phys. 28 (1917), p. 107.\n\n72) Existe-t-il dans l'espace cart\\'esien \\`a $n$ dimensions ($n>1$) un ensemble toujours de premi\\'ere cat\\'egorie (c. \\`a d. de premi\\'ere cat\\'egorie sur chaque ensemble parfait) et qui soit de dimension positive?\n\n(M. W. Hurewicz a d\\'emontr\\'e \\`a l'aide de l'hypoth\\'ese du continu qu'il existe dans l'espace de Hilbert un ensemble ind\\'enombrable $H$ dont chaque sous-ensemble ind\\'enombrable est de dimension infinie[^5]). M. F. Hausdorff a remarqu\\'e l'ensemble $H$ est toujours de premi\\'ere cat\\'egorie. Cela r\\'esulte ais\\'ement du fait que chaque espace m\\'etrique s\\'eparable $M$ est somme d'un ensemble de dimension $0$ et d'un ensemble de premi\\'ere cat\\'egorie dans $M$. -- *Il existe donc, so $2^{\\aleph} = \\aleph_{1}$, dons l'espace de Hilbert un ensemble toujours de premi\\'erie cat\\'egorie et de dimension positive*).\n\nProbl\\'eme de M. E. Szpilrajn.\n\n[^5] Fund. Math. 19 (1932), p.8.\n\n\n73) Soient, dans l'espace euclidien \\`a trois dimensions, $E$ une image hom\\'eomorphe de la sph'ere solide $S$ et $L$ un segment rectiligne dont l'int'erieur est contenu dans l'int'erieur, et les extr'emeit'es dans la fronti'ere de $E$. Existe-t-il toujours une hom\\'eomorphie transformant $E$ en $S$ de facon que $L$ soit transorm\\'e en diam\\'etre de $S$?\n\nProbl\\'eme de M. K. Borsuk.\n\n74) Soit $\\mathbf{B}(\\mathbf{F})$ la plus petite famille d'ensembles contenant la famille donn\\'ee $\\mathbf{F}$ et close par rapoort aux op\\'erations $\\sigma$ et $\\delta$ (addition et multiplication d\\'enombrables). Existe-t-il une famille d\\'enombrable $\\mathbf{D}$ d'ensembles, telle que tous les ensembles analytiques lin\\'eaires appartiennent \\`a $\\mathbf{B}(\\mathbf{D})$?\n\nProbl\\'eme de M. S. Ulam.\n\n\n75) Existe-t-il un ensemble infini $E$ (p.e. l'ensemble de tous les nombres naturels) et une fonction $f(X)$ qui fait correspondre \\`a tout sous-ensemble $X$ de $E$ un sous-ensemble $f(X)$ de $E$, de sorte que:\n\n1$^\\circ$ $X \\subset f(X)$ pour $X \\subset E$,\n2$^\\circ$ $f(X+Y) = f(X) + f(Y)$ pour $X \\subset E$, $Y \\subset E$,\n3$^\\circ$ il existe pour tout ensemble $Y \\subset E$ au moins un ensemble $X \\subset E$, tel que $Y = f(X)$,\n4$^\\circ$ il existe au moins un ensemble $X_{0} \\subset E$, tel que $f(X_{0}) \\neq X_{0}$.\n\nSi l'on remplace la condition relative \\`a $f(X+Y)$ par la condition plus faible que $f(X) \\subset f(Y)$ pur $X \\subset Y \\subset E$, la r\\'eponse positive est \\'evidente. \n\nProbl\\'eme de M. E. \\v{C}ech.\n\n\n\n\n\n## Probl\\'emes r\\e'solus.\n\nProbl. 1) Lorsque un ensemble de points $P$ est une image biunvoque et continue (dans un sens) de $Q$ et $Q$ est une image biunivoque et continue de $P$, peut-on affirmer que les ensembles $P$ et $Q$ sont hom\\'eomorphes?\n\nSolution *n\\'egative* de M. Kuratowski, *Fund. Math.* t. II, pp. 158-160\n\n4) Existe-il une d\\'ecomposition d'un intervalle en $\\aleph_{1}$ ensembles mesurables ($B$), non-vides et sans points communs deux \\`a deux?\n\nSolution *affirmative* de MM. Lusin et Sierpinski, *Comptes Rendus*, t. 175, p.357 (note du 21 ao\\^ut 1922).\n\n6, troisi\\'eme partie) Peut-on d\\'emontrer qu'un produit de $\\aleph_{1}$ ensembles ($A$) n'est pas n\\'ecessairement un ensemble ($A$)?\n\nSolution *affirmative* de MM. Lusin et Sierpinski, *Journ, de Math*. 1923 (Les auteurs d\\'efinissent un ensemble qui est compl\\'ementaire d'un ensemble ($A$) n'est pas n\\'ecessairement un ensemble ($A$))\n\n8) Peut-on donner un exemple effectif d'un ensemble de nombres r\\'eels $E$, tel que toute somme, toute diff\\'erence, tout produit et tout quotient de deux nombres de $E$ (except\\'e la division par 0) appartienne \\`a $E_{1}$ et que $E$ soit non-d\\'enombrable, distinct de l'ensemble de tous les nombres r\\'eels?\n\nSolution *affirmative* de M. Souslin, *Fund. Math.* IV, p.311.\n\n10, premi\\'ere partie) Existe-il une fonction de deuxi\\'eme classe qui ne soit pas la limite de fonctions preque partout discontinues?\n\nSolution *affirmative* de M. Zalcwasser.\n\n12) Un ensemble ordonn\\'e dont tous les sous-ensembles bien ordonn\\'es (croissants on d\\'ecroissants) sont au plus d\\'enombraibles, a-t-il n\\'ecessairement une puissance non sup\\'erieure \\`a celle du continu?\n\nSolution *affirmative* de M. Urysohn, *Fund. Math.* V (h paraitre).\n\n15) Existe-il un continu dont tout sous-continu est ind\\'ecomposable?\n\nSolution *affirmative* de M. Knaster, *Fund. Math.* III pp. 247-286.\n\n16) Existe-il continu qui est une somme de ses vrais sous-continues satur\\'es disjoints?\n\nSolution *affirmative* de M. Knaster et Kuratowski, *Fund. Math.* V (\\`a paraitre).\n\n\n\n\n","slug":"75 Probelms (French)","published":0,"updated":"2023-12-27T06:00:21.838Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisuno0011eslrha3c2p34","content":"<ol type=\"1\">\r\n<li>Lorsqu'un ensemble de points <span class=\"math inline\">\\(P\\)</span>\r\nest une image biunivoque et continue (mais pas n'ecessairement\r\nbicontinue) d'un ensemble <span class=\"math inline\">\\(Q\\)</span> et\r\nlorsque <span class=\"math inline\">\\(Q\\)</span> est une image biunivoque\r\net continue de <span class=\"math inline\">\\(P\\)</span>, lest ensembles\r\n<span class=\"math inline\">\\(P\\)</span> et <span\r\nclass=\"math inline\">\\(Q\\)</span> sont-ils n'ecessairement\r\nhomeomorphes?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Un continu (born'e) plan, topologiquement homog`ene, est-il\r\nn'ecessairement hom'eomorphe `a une circonf'erence?</li>\r\n</ol>\r\n<p>(Un ensemble <span class=\"math inline\">\\(E\\)</span> est dit\r\n<em>topologiquement homog'ene</em>, lorsqu'il existe pour tout couple de\r\npoints <span class=\"math inline\">\\(a,b\\)</span> de <span\r\nclass=\"math inline\">\\(E\\)</span> une transformation biunivoque et\r\nbicontinue de <span class=\"math inline\">\\(E\\)</span> en lui-m'eme qui\r\ntransforme <span class=\"math inline\">\\(a\\)</span> en <span\r\nclass=\"math inline\">\\(b\\)</span>)</p>\r\n<p>Probl'eme de MM. B. Knaster et C. Kuratowski.</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>Un ensemble ordonn'e (lin'eairement) sans sauts ni lacunes et tel\r\nque tout ensemble de ses intervalles (contenant plus qu'un 'el'ement)\r\nn'empi'etant pas les uns sur les autres est au plus d'enombrable, est-il\r\nn'ecessairement un continu lin'eaire (ordinaire)?</li>\r\n</ol>\r\n<p>Probl'eme de M. M. Souslin.</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>Existe-t-il une d'ecomposition d'un intervalle en <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles (non vides)\r\nmesurables <span class=\"math inline\">\\(B\\)</span> et sans point commun\r\ndeux `a deux?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"5\" type=\"1\">\r\n<li>Existe-t-il un ensemble lin'eaire ind'enombrable <span\r\nclass=\"math inline\">\\(E\\)</span> tel que tout ensemble lin'eaire\r\nhom'eomorphe `a <span class=\"math inline\">\\(E\\)</span> soit de mesure\r\nlebesguienne nulle? Peut-on d'emontrer l'existence d'un tel ensemble,\r\nm'eme en admettant que <span class=\"math inline\">\\(2^{\\aleph_{0}} =\r\n\\aleph_{1}\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"6\" type=\"1\">\r\n<li>Peut-on d'emoutrer sans l'hypoth'ese du continu (<span\r\nclass=\"math inline\">\\(2^{\\aleph_{0}} = \\aleph_{1}\\)</span>) qu'une somme\r\nde <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles de mesure\r\nlebesguienne nulle n'est pas n'ecessairement de mesure lebesquienne\r\nnulle? qu'une somme de <span class=\"math inline\">\\(\\aleph_{1}\\)</span>\r\nensembles de premi'ere cat'egorie n'est pas n'ecessairement de premi'ere\r\ncat'egorie? qu'un produit de <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles (<span\r\nclass=\"math inline\">\\(A\\)</span>) n'est pas n'ecessairement un ensemble\r\n<span class=\"math inline\">\\(A\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"7\" type=\"1\">\r\n<li>Peut-on 'etablir sans l'hypoth'ese du continu l'esistence d'un\r\nensemble plan qui est de mesure (lebesguienne) nulle sur toute\r\nparall'ele `a l'axe d'abscisses et dont le compl'ementaire est de mesure\r\nnulle sur toute parall'ele `a l'axe d'ordonn'ees?</li>\r\n</ol>\r\n<p>Probl'eme de M. H. Steinhaus.</p>\r\n<ol start=\"8\" type=\"1\">\r\n<li>Peut-on donner un exemple effectif d'un ensemble de nombres r'eels\r\n<span class=\"math inline\">\\(E\\)</span> tel que toute somme, toute\r\ndiff'erence, tout produit et tout quotient de deux nombres de <span\r\nclass=\"math inline\">\\(E\\)</span> (la division par 0 except'ee)\r\nappartienne `a <span class=\"math inline\">\\(E\\)</span> et que <span\r\nclass=\"math inline\">\\(E\\)</span> soit ind'enombrable, mais distinct de\r\nl'ensemble de tous les nombres r'eels?</li>\r\n</ol>\r\n<p>Probl'eme de M. S. Mazurkiewicz.</p>\r\n<ol start=\"9\" type=\"1\">\r\n<li>Quelle est la puissance des ensembles compl'ementaires aux ensembles\r\n(<span class=\"math inline\">\\(A\\)</span>)?</li>\r\n</ol>\r\n<p>Probl'eme de M. N. Lusin.</p>\r\n<p><em>Remarque</em>. Les ensembles (<span\r\nclass=\"math inline\">\\(A\\)</span>) lin'eaires sont des projections\r\northogonales (sur une froite) des ensembles plans mesurables <span\r\nclass=\"math inline\">\\(B\\)</span>. M. Lusin a d'emontr'e que la puissance\r\nd'un ensemble ind'enombrable compl'ementaire `a un ensemble (<span\r\nclass=\"math inline\">\\(A\\)</span>) est <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> ou <span\r\nclass=\"math inline\">\\(2^{\\aleph_{0}}\\)</span>, mais on ne sait pas si\r\nelle peut ^etre en r'ealit'e <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> (dans le cas o'u <span\r\nclass=\"math inline\">\\(2^{\\aleph_{0}} &gt; \\aleph_{1}\\)</span>)</p>\r\n<ol start=\"10\" type=\"1\">\r\n<li>Existe-t-il une fonction de deuxi'eme classe qui n'est pas une\r\nlimite de fonctions presque partout continues? Peut-on donner un exemple\r\neffectif d'une fonction qui n'est pas une limite de fonctions\r\nponctuellement discontinues?</li>\r\n</ol>\r\n<p>Probl'eme de MM. T. Feosztyn et W. Sierpinski.</p>\r\n<ol start=\"11\" type=\"1\">\r\n<li>Existe il une classe (<span\r\nclass=\"math inline\">\\(\\mathcal{L}\\)</span>) de M. Fr'echet (c'est-`a\r\ndire une classe dans laquelle la limite est d'efinie) de puissance\r\nsup'erieure `a celle du continu, telle que tout ensemble non\r\nd'enombrable d''el'ements de cette classe contient au moins un 'el'ement\r\nde condensation?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"12\" type=\"1\">\r\n<li>Un ensemble ordonn'e (lin'eairement) dont tous les sousensembles\r\nbien ordonn'es (croissants et d'croissants) sont au plus d'enombrables,\r\na-t-il n'ecessairement une puissance non sup'erieure `a celle du\r\ncontinu?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"13\" type=\"1\">\r\n<li>Existe-il un ensemble plan ferm'e qui ne soit pas somme de deux\r\nensembles ferm'es sans points communs, mais qui est une somme d'une\r\ninfinit'e d'enombrable d'ensembles ferm'es sans points communs deux `a\r\ndeux.</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"14\" type=\"1\">\r\n<li>Un continu dans l'espace `a <span class=\"math inline\">\\(m\\)</span>\r\ndimensions qui est hom'eomorphe de tout continu qu'il contient, est il\r\nn'ecessairement un arc simple (c'est-`a-dire une image biunivoque et\r\ncontinu de l'intervalle 0-1)?</li>\r\n</ol>\r\n<p>Probl'eme de M. Mazurkiewicz.</p>\r\n<ol start=\"15\" type=\"1\">\r\n<li>Existe-il un continu dont tout sous continu est ind'ecomposable? (Un\r\ncontinu est dit ind'ecomposable lorsqu'il n'est pas une somme de deux\r\ncontinus diff'erents de lui.)</li>\r\n</ol>\r\n<p>Probl'eme de MM. Knaster et Kuratowski.</p>\r\n<ol start=\"16\" type=\"1\">\r\n<li>Existe il un continu (non born'e) qui est une somme de ses vrais\r\nsous continus satur'es n'ayant deux `a deux aucun point commun?</li>\r\n</ol>\r\n<p>(On dit qu'un vrai sous-continu <span\r\nclass=\"math inline\">\\(K\\)</span> de <span\r\nclass=\"math inline\">\\(C\\)</span> est <em>satur'e</em>, lorsqu'il\r\nn'existe aucun continu diff'erent de <span\r\nclass=\"math inline\">\\(K\\)</span> et de <span\r\nclass=\"math inline\">\\(C\\)</span> qui contienne <span\r\nclass=\"math inline\">\\(K\\)</span> et qui soit contenu dans <span\r\nclass=\"math inline\">\\(C\\)</span>.)</p>\r\n<p>Probl'eme de M. Kuratowski.</p>\r\n<ol start=\"17\" type=\"1\">\r\n<li>Quelle est la puissance de l'ensemble de toutes les valeurs que ne\r\nprend pas une fonction de classe 1 de M. Baire?</li>\r\n</ol>\r\n<p>(Ce probl'eme est 'equivalent au probl'eme 9 de M. Lusin, t. I.\r\np.224. Il suffirait de r'esoudre ce probl'eme pour les fonctions\r\nadmettant une infinit'e d'enombrable de points de discontinuit'e.)</p>\r\n<ol start=\"18\" type=\"1\">\r\n<li>Un ensemble (lin'eaire) de puissance inf'erieure `a celle du\r\ncontinu, est-il n'ecessairement d'e la premi'ere cath'egorie de M.\r\nBaire?</li>\r\n</ol>\r\n<p>Probl'eme de M. Ruziewicz.</p>\r\n<ol start=\"19\" type=\"1\">\r\n<li>Existe-t-il dans chaque ensemble biconnexe <span\r\nclass=\"math inline\">\\(B\\)</span> un point <span\r\nclass=\"math inline\">\\(p\\)</span> tel que l'ensemble <span\r\nclass=\"math inline\">\\(B - (p)\\)</span> ne contient aucun ensemble\r\nconnexe?</li>\r\n</ol>\r\n<p><em>Remarque</em>. D'apre'es un th'eor'eme de M. Kline (ce volume,\r\np.238), il ne peut exister dans un ensemble connexe <span\r\nclass=\"math inline\">\\(B\\)</span> plus d'un point <span\r\nclass=\"math inline\">\\(p\\)</span> jouissant de la propri'et'e en\r\nquestion. On sait, d'autre part, que, si un tel point existe, l'ensemble\r\n<span class=\"math inline\">\\(B\\)</span> est biconnexe, c.-`a-d. il n'est\r\npas somme de duex ensembles connexes disjoints cont'enant plus d'un\r\npoint (cf. Knaster et Kuratowski, <em>Fund. Math.</em> II, p,214.)</p>\r\n<p>Probl'eme de M. Kuratowski.</p>\r\n<ol start=\"20\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(f(E)\\)</span> une fonction d'efinie\r\npor tout ensemble <span class=\"math inline\">\\(E\\)</span> mesurable\r\n(<span class=\"math inline\">\\(L\\)</span>) d'un espace euclidien `a <span\r\nclass=\"math inline\">\\(m \\geq 3\\)</span> dimensions et satisfaisant aux\r\nconditions suivantes:</li>\r\n</ol>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(f(E)\\geq 0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(f(E_{0}) = 1\\)</span> pur un certain\r\nensemble <span class=\"math inline\">\\(E_{0}\\)</span> de mesure 1.</li>\r\n<li><span class=\"math inline\">\\(f(E_{1} +E_{2}) = f(E_{1}) +\r\nf(E_{2})\\)</span>, si <span class=\"math inline\">\\(E_{1} E_{2} =\r\n0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(f(E_{1}) = f(E_{2})\\)</span>, si <span\r\nclass=\"math inline\">\\(E_{1}\\)</span> et <span\r\nclass=\"math inline\">\\(E_{2}\\)</span> sont superposables.</li>\r\n</ol>\r\n<p>La fonction <span class=\"math inline\">\\(f(E)\\)</span> coincide-t-elle\r\nn'ecessairement avec la mesure lebesguienne de l'ensemble <span\r\nclass=\"math inline\">\\(E\\)</span>?</p>\r\n<p>(Pour <span class=\"math inline\">\\(m=1\\)</span> et <span\r\nclass=\"math inline\">\\(m=2\\)</span> la r'eponse est n'egative, comme l'a\r\nprouv'e M. Banach dans un m'emoire qui sera publi'e dans le tome IV de\r\nce jounal.)</p>\r\n<p>Probl'eme de M. Ruziewicz.</p>\r\n<ol start=\"21\" type=\"1\">\r\n<li>A 'etant un ensemble de nombres r'eels qui n'est de I cat'egorie\r\ndans aucun intervalle, existe-il une d'ecomposition: <span\r\nclass=\"math inline\">\\(A = B + C\\)</span>, <span class=\"math inline\">\\(B\r\n\\times C = 0\\)</span> telle que ni <span\r\nclass=\"math inline\">\\(B\\)</span> ni <span\r\nclass=\"math inline\">\\(C\\)</span> ne soient de I cat'egorie dans aucun\r\nintervalle?</li>\r\n</ol>\r\n<p><em>Remarque</em>. On en pourrait donner la solution affirmative dans\r\nl'hypoth'ese suppl'ementaire que <span class=\"math inline\">\\(A\\)</span>\r\nposs'ede la propri'et'e de Baire (au sens etabli dans ce volume), p.319.\r\nM. Sierpinski en a signal'e d'autre part, la solution affirmative dans\r\nl'hypoth'ese du continu, <span class=\"math inline\">\\(\\aleph_{1} =\r\n2^{\\aleph_{0}}\\)</span>.</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"22\" type=\"1\">\r\n<li>Appellons l'ensemle (lin'eaire) <span\r\nclass=\"math inline\">\\(E\\)</span> <em>parfaitement mesurable</em>, si\r\ntout ensemble hom'eomorphe `a <span class=\"math inline\">\\(E\\)</span> est\r\nmesurable au sens de Lebesgue. Quelle est la puissance de la classe des\r\nensembles parfaitement mesurables? Un ensemble compl'ementaire `a un\r\nensemble parf. mesurable est-il toujours parf. mesurable?</li>\r\n</ol>\r\n<p>Problem of M. Urysohn.</p>\r\n<ol start=\"23\" type=\"1\">\r\n<li>Esiste-t-il une fonction d'une variable r'eelle <span\r\nclass=\"math inline\">\\(f(x)\\)</span> pantachiquement dicontinue et telle\r\nqu'on ait pour tout <span class=\"math inline\">\\(x\\)</span> r'eel</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\lim \\frac{f(x+h) - f(x-h)}{2h} =\r\n0?\\]</span></p>\r\n<p>Problem of M. Steinhaus.</p>\r\n<ol start=\"24\" type=\"1\">\r\n<li>Une fonction satisfaisan `a la condition de Baire, est-elle\r\nn'ecessairement mesurable (<span class=\"math inline\">\\(L\\)</span>)?\r\nQuelle est la puissance de toutes les fonctions d'une variable r'eelle\r\nsatisfaisant `a la condition de Baire? (On dit qu'une fonction <span\r\nclass=\"math inline\">\\(f(x)\\)</span> satisfait `a la condition de Baire,\r\nsi elle continue sur tout ensemble parfait quand on n'eglige les\r\nensembles de premi'ere cat'egorie par rapport `a cet ensemble\r\nparfait.)</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"25\" type=\"1\">\r\n<li>Un ensemble plan, tel que toute droite le rencontre en deux (et\r\nseulement deux) points, peut-il ^etre mesurable (<span\r\nclass=\"math inline\">\\(B\\)</span>)? (L'existence d'un tel ensemble a\r\n'et'e d'emontr'e, `a l'aide du th'eor'eme de M. Zermelo, par MM.\r\nMazurkiewicz[^1] (en 1914) et Rosenthal[^2] (en 1922))</li>\r\n</ol>\r\n<p>[^1] Comptes Rendus de lu Soc. des Sciences de Varsovic, t. VII,\r\np.382.</p>\r\n<p>[^2] Sitzungaber d. Bayer. Akad. d. Wiss., math-phys. K1, 1922, p.\r\n223.</p>\r\n<ol start=\"26\" type=\"1\">\r\n<li>Une fonction de classe 3 de M. Baire, est-elle toujours une\r\nsuperposition de trois fonctions de classe 1, c'est-`a-dire existe-t-il\r\npour toute fonction <span class=\"math inline\">\\(f(x)\\)</span> de classe\r\n3 trois fonctions <span class=\"math inline\">\\(\\varphi(x)\\)</span>, <span\r\nclass=\"math inline\">\\(\\psi(x)\\)</span> et <span\r\nclass=\"math inline\">\\(\\vartheta(x)\\)</span> de classe, telles qu'on a\r\npour tout <span class=\"math inline\">\\(x\\)</span> r'eel</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[f(x) =\r\n\\varphi\\{\\psi[\\vartheta(x)]\\}\\]</span></p>\r\n<p>Probl'eme de M. Lusin.</p>\r\n<ol start=\"27\" type=\"1\">\r\n<li>L'ensemble <span class=\"math inline\">\\(D(E)\\)</span> des distances\r\ndes points d'un ensemble lin'eaire <span\r\nclass=\"math inline\">\\(E\\)</span> mesurable <span\r\nclass=\"math inline\">\\((B)\\)</span>, est-il toujours mesurable (<span\r\nclass=\"math inline\">\\(B\\)</span>)? ( <span\r\nclass=\"math inline\">\\(D(E)\\)</span> est done l'ensemble de tous les\r\nnombres <span class=\"math inline\">\\(|x-y|\\)</span>, o'u <span\r\nclass=\"math inline\">\\(x\\)</span> et <span\r\nclass=\"math inline\">\\(y\\)</span> appartiennent `a <span\r\nclass=\"math inline\">\\(E\\)</span>. On peut d'emontrer l'existence des\r\nensembles <span class=\"math inline\">\\(E\\)</span> mesurables (<span\r\nclass=\"math inline\">\\(L\\)</span>), tels que <span\r\nclass=\"math inline\">\\(D(E)\\)</span> est non mesurable (<span\r\nclass=\"math inline\">\\(L\\)</span>).)</li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpinski.</p>\r\n<ol start=\"28\" type=\"1\">\r\n<li><span class=\"math inline\">\\(E\\)</span> 'etant un ensemble plan\r\nmesurable (<span class=\"math inline\">\\(B\\)</span>), d'esignons par <span\r\nclass=\"math inline\">\\(N(E)\\)</span> l'ensemble de tous les nombres\r\nr'eels <span class=\"math inline\">\\(a\\)</span>, tels que la droite <span\r\nclass=\"math inline\">\\(x = a\\)</span> rencontre <span\r\nclass=\"math inline\">\\(E\\)</span> en une infinit'e non-d'enombrable de\r\npoints. L'ensemble <span class=\"math inline\">\\(N(E)\\)</span>, est il\r\nn'ecessairement un ensemble (<span class=\"math inline\">\\(A\\)</span>),\r\nou, plus simplement, est-il mesurable (<span\r\nclass=\"math inline\">\\(L\\)</span>)? (On peut d'emontrer que l'ensemble de\r\ntous les nombres r'eels <span class=\"math inline\">\\(a\\)</span>, tels que\r\nla droite <span class=\"math inline\">\\(x = a\\)</span> rencontre\r\nl'ensemble <span class=\"math inline\">\\(E\\)</span> (mesurable <span\r\nclass=\"math inline\">\\(B\\)</span>) en une infinit'e de points est\r\ntoujouts un ensemble <span class=\"math inline\">\\(A\\)</span>.)</li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpinski.</p>\r\n<ol start=\"29\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(F\\)</span> un ensemble plan, p. ex.\r\nferm'e (ou, plus g'en'eralement, mesurable)- Un point <span\r\nclass=\"math inline\">\\(x\\)</span> de <span\r\nclass=\"math inline\">\\(F\\)</span> sera dit <em>lin'eairment\r\naccessible</em> s'il sxiste un segment rectiligne <span\r\nclass=\"math inline\">\\(\\overline{xp}\\)</span> tel que tous ses points (le\r\npoint <span class=\"math inline\">\\(x\\)</span> except'e) soient 'etrangers\r\n`a <span class=\"math inline\">\\(F\\)</span>. Peut-on d'emontrer que\r\nl'ensemble <span class=\"math inline\">\\(A\\)</span> de tous les points\r\nlin'eairement accessibles de <span class=\"math inline\">\\(F\\)</span> est\r\ntoujours mesurable (<span class=\"math inline\">\\(L\\)</span>)?</li>\r\n</ol>\r\n<p>Probl'eme de M. Urysohn.</p>\r\n<ol start=\"30\" type=\"1\">\r\n<li><span class=\"math inline\">\\(f(x)\\)</span> 'etant une fonction\r\ndonn'ee quelconque (mesurable ou non), quelle est la mesure de\r\nl'ensomble de tous les points <span class=\"math inline\">\\(x\\)</span>,\r\ntels que</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\lim\\limits_{h\\to 0} \\left|\\frac{f(x+h)\r\n- f(x)}{h}\\right| = \\infty\\]</span></p>\r\n<p>Probl'eme de M. Ruziewicz.</p>\r\n<ol start=\"31\" type=\"1\">\r\n<li>Le th'eor'eme: \"<span class=\"math inline\">\\(\\mathsf{m} = 2\\cdot\r\n\\mathsf{m}\\)</span> quel soit le nombre cardinal <em>transfini</em>\r\n<span class=\"math inline\">\\(\\mathsf{m}\\)</span>\" est il 'equivalent `a\r\n<em>l'axiome du choix</em>?</li>\r\n</ol>\r\n<p>Cf. ma Note \"<em>Sur quelques th'eor'emes qui 'equivalent `a l'axiome\r\ndu choix</em>\" dans ce volume, p. 147.</p>\r\n<p>Probl'eme de M. Tajtelbaum-Tarski.</p>\r\n<ol start=\"32\" type=\"1\">\r\n<li>Un ensemble plan ferm'e, don tout point est lin'eairement\r\naccessible, est-il n'ecessairement de mesure superficielle nulle?</li>\r\n</ol>\r\n<p>Probl'eme de M. Banach.</p>\r\n<p>Un point <span class=\"math inline\">\\(x\\)</span> de <span\r\nclass=\"math inline\">\\(F\\)</span> est dit lin'eairement accessible s'il\r\nexiste un segment rectiligne <span\r\nclass=\"math inline\">\\(\\overline{xp}\\)</span> tel que tous ses points (le\r\npoint <span class=\"math inline\">\\(x\\)</span> excepr'e) soient 'etrangers\r\n`a <span class=\"math inline\">\\(F\\)</span>. M. Urysohn a d'emontr'e que\r\nl'ensemble de tous les points lin'eairement accessibles d'un ensemble\r\nplan ferm'e est toujouts un ensemble (<span\r\nclass=\"math inline\">\\(A\\)</span>) de M. Souslin, mais peut ne pas ^etre\r\nmesurable (<span class=\"math inline\">\\(B\\)</span>). Or on ne sait pas si\r\nl'ensemble de tous les points lin'eairement accessibles d'un ensemble\r\nplan <span class=\"math inline\">\\(G_{\\delta}\\)</span> est mesurable\r\n(<span class=\"math inline\">\\(L\\)</span>) (Cf. Probl'eme 29, <em>Fund.\r\nMath.</em> t. V, p. 337).</p>\r\n<ol start=\"33\" type=\"1\">\r\n<li>Une image biunivoque et continue (dans un sens) d'un ensemble\r\ncompl'emeutaire `a un ensemble (<span class=\"math inline\">\\(A\\)</span>)\r\nde M. Souslin, est elle de m^eme nature?</li>\r\n</ol>\r\n<p>Probl'eme de Sierpi'nski.</p>\r\n<ol start=\"34\" type=\"1\">\r\n<li>Appelons un ensemble (lin`eaire) mesurable (<span\r\nclass=\"math inline\">\\(B\\)</span>) de classe a <em>irr'eductible</em>\r\ns'il n'est de classe <span class=\"math inline\">\\(&lt;\\alpha\\)</span>\r\ndans aucun intervalle. Quelle est la puissance de l'ensemble de tous les\r\ntypes topologiques d'ensumbles irr'eductibles de classe <span\r\nclass=\"math inline\">\\(\\alpha\\)</span>?</li>\r\n</ol>\r\n<p>Appelons un ensemble (<span class=\"math inline\">\\(A\\)</span>)\r\nirr'eductible, s'il n'est mesurable (<span\r\nclass=\"math inline\">\\(B\\)</span>) dans aucun intervalle. Quelle est la\r\npuissance de tous les types topologiques des ensembles (<span\r\nclass=\"math inline\">\\(A\\)</span>) irr'eductibles?</p>\r\n<p>Probl'eme de MM. Alexandroff et Urysohn.</p>\r\n<ol start=\"35\" type=\"1\">\r\n<li>Appelons l'ensemble (lin'eaire) <span\r\nclass=\"math inline\">\\(E\\)</span> <em>parfaitement mesurable au sens\r\n'etroit</em>, si toute image univoque et continue de <span\r\nclass=\"math inline\">\\(E\\)</span> est mesurable au sens de Lebsgue. Un\r\nensemble compl'ementaire `a un ensemble parfaitement mesurable au sens\r\n'etroit, est-il toujours de m^eme nature?</li>\r\n</ol>\r\n<p>Cf. Probl'eme 22 de P. Urysohn (<em>Fund. Math.</em> t. IV, p. 368),\r\nr'esolu par M. Lavrentieff (<em>Fund. Math.</em> t. VI, p. 159).</p>\r\n<p>Probl'eme de M. O. Nikodym.</p>\r\n<ol start=\"36\" type=\"1\">\r\n<li>D'apr'es M. Souslin, si <span class=\"math inline\">\\(E\\)</span> est\r\nun ensemble (<span class=\"math inline\">\\(A\\)</span>) et <span\r\nclass=\"math inline\">\\(H\\)</span> un ensemble compl'ementaire `a un\r\nensemble (<span class=\"math inline\">\\(A\\)</span>), et si <span\r\nclass=\"math inline\">\\(E \\subset H\\)</span>, il existe un ensemble <span\r\nclass=\"math inline\">\\(Q\\)</span>, mesurable (<span\r\nclass=\"math inline\">\\(B\\)</span>), tel que <span\r\nclass=\"math inline\">\\(E\\subset Q \\subset H\\)</span>[^3]. Cette\r\nproposition, admet-elle une r'eciproque, c'est-`a-dire, <em><span\r\nclass=\"math inline\">\\(E\\)</span> 'etant un ensemble compl'ementaire `a\r\nun ensemble (<span class=\"math inline\">\\(A\\)</span>) et <span\r\nclass=\"math inline\">\\(H\\)</span> ------ un ensemble (<span\r\nclass=\"math inline\">\\(A\\)</span>), tel que <span class=\"math inline\">\\(E\r\n\\subset H\\)</span>, existe-til tujours un ensemble <span\r\nclass=\"math inline\">\\(Q\\)</span> mesurable (<span\r\nclass=\"math inline\">\\(B\\)</span>), tel que <span class=\"math inline\">\\(E\r\n\\subset Q \\subset H\\)</span>?</em></li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpi'nski.</p>\r\n<p>[^3] Voir p. e. N. Lusin et W. Sierpi'nski <em>Journ. de Math.</em>\r\nt. II (1923) p. 60; aussi <em>Bull. Acad. Cracovie</em> 1918 p. 40.</p>\r\n<ol start=\"37\" type=\"1\">\r\n<li>Un continu de Jordan (born'e) qui ne renferme qucune courbe simple\r\nferm'ee est-il hom'eomorphe `a un de ses (vrais) sous-continus?</li>\r\n</ol>\r\n<p>Probl'eme de M. Zarankiewicz.</p>\r\n<ol start=\"38\" type=\"1\">\r\n<li>Un carr'e et un cercle dont les aires sont 'egales peuvent-ils ^etre\r\nd'ecompos'es en un nombre fini de sous-ensembles disjoints repectivement\r\ncongruents?</li>\r\n</ol>\r\n<p>Probl'eme de M. Tarski.</p>\r\n<ol start=\"39\" type=\"1\">\r\n<li>Existe-il un ensemble ferm'e <em>plan</em> pour lequel l'ensemble\r\ndes points lin'eairement accessibles soit non-mesurable (<span\r\nclass=\"math inline\">\\(B\\)</span>)? (Dans l'espace le probl'eme est\r\nr'esolu par affirmative).</li>\r\n</ol>\r\n<p>Probl'eme de M. O. Nikodym.</p>\r\n<ol start=\"40\" type=\"1\">\r\n<li><span class=\"math inline\">\\(E\\)</span> 'etant un ensemble plan <span\r\nclass=\"math inline\">\\(G_{\\delta}\\)</span>, l'ensemble de tous les\r\nnombres r'eels <span class=\"math inline\">\\(a\\)</span>, tels que la\r\ndroite <span class=\"math inline\">\\(x =a\\)</span> rencontre l'ensemble\r\n<span class=\"math inline\">\\(E\\)</span> dans un et un seul point, est-il\r\nn'ecessairement compl'ementaire d'un ensemble (<span\r\nclass=\"math inline\">\\(A\\)</span>) de M. Souslin?</li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpi'nski.</p>\r\n<ol start=\"41\" type=\"1\">\r\n<li><span class=\"math inline\">\\(E_{1}, E_{2}, E_{3}, \\dots\\)</span>\r\n'etant une suite d'enombrable d'ensembles lin'eaires dont chacun est une\r\nprojection d;un ensemble plan compl'ementaire `a un ensemble (<span\r\nclass=\"math inline\">\\(A\\)</span>) de M. Souslin, l'ensemble $E_{1}E_{2}\r\nE_{3} $ est il de m^eme nature?</li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpi'nski.</p>\r\n<ol start=\"42\" type=\"1\">\r\n<li>Existe-t-il dans tout continu <span class=\"math inline\">\\(A\\)</span>\r\nun continu <span class=\"math inline\">\\(B\\)</span> tel que l'ensemble\r\n<span class=\"math inline\">\\(A-B\\)</span> soit connexe?</li>\r\n</ol>\r\n<p>Probl'eme de MM. Knaster et Zarankiewicz.</p>\r\n<ol start=\"43\" type=\"1\">\r\n<li><span class=\"math inline\">\\(D\\)</span> d'esignant un ensemble ferm'e\r\nhom'eomorphe d'un ensemble plan et situ'e dans l'espace euclidien `a 3\r\ndimensions, est-ce que tout point de <span\r\nclass=\"math inline\">\\(D\\)</span> est <em>accessible</em> dans cet\r\nespace?</li>\r\n</ol>\r\n<p>(Un point <span class=\"math inline\">\\(d\\)</span> de <span\r\nclass=\"math inline\">\\(D\\)</span> est dit <em>accessible</em> dans <span\r\nclass=\"math inline\">\\(E\\)</span>, lorsqu'il existe un continu <span\r\nclass=\"math inline\">\\(C \\subset E\\)</span> tel que <span\r\nclass=\"math inline\">\\((d) = CD\\)</span>).</p>\r\n<p>Probl'eme de M. Knaster.</p>\r\n<ol start=\"46\" type=\"1\">\r\n<li>Es wird gefragt die logischen Relationen zwischen den verschiedenen\r\nHomogenit\"atsbegriffen aufzutellen, insoweit sie sich beziehen auf im\r\nkleinen kompakten Mengen. Insbesondere auch wenn die Mengen als\r\nausammenh\"angend und (oder) im kleinen zusammenh\"angend vorausgesetzt\r\nwerden.</li>\r\n</ol>\r\n<p>(Vgl. D. van Dantzig, \"ber topologisch homogene Kontinua, dieser\r\nBand, S. 102, 103).</p>\r\n<p>Probl'eme de M. van Dantzig.</p>\r\n<ol start=\"47\" type=\"1\">\r\n<li>Ist eine jed (zusammenh\"angende, unberandete) <span\r\nclass=\"math inline\">\\(n\\)</span>-dimensionale Mannigfaltigkeit\r\ninvolutorisch homogen?</li>\r\n</ol>\r\n<p>(Vgl. D. van Dantzig, l. e. S. 104, ^7.)</p>\r\n<p>Probl'eme de M. van Dantzig.</p>\r\n<ol start=\"48\" type=\"1\">\r\n<li>Nennen wir eine topologische Gruppe <em>monothetisch</em>, falls\r\neine unendliche zyklische Gruppe in ihr dicht liegt (in welchem Falle\r\nsie kommutativ ist und additiv geschrieben weden kann), und\r\n<em>komplett</em>, falls eine jede Folge <span\r\nclass=\"math inline\">\\(x_{\\nu}\\)</span>, die dem Konvergenzkriterium\r\nCauchy's <span class=\"math inline\">\\(\\lim (x_{\\nu} - x_{\\mu} =\r\n0\\)</span> gen\"ugt, ein Limeselement in der Gruppe besitzt, so wird\r\ngefragt, ob eine monothetische Gruppe komplett sein kann ohne kompakt zu\r\nsein.</li>\r\n</ol>\r\n<p>(Vgl. l. c. S. 116 ^{29}a))</p>\r\n<p>Probl'eme de M. van Dantzig.</p>\r\n<ol start=\"49\" type=\"1\">\r\n<li>Soient <span class=\"math inline\">\\(X\\)</span> et <span\r\nclass=\"math inline\">\\(Y\\)</span> deux continus P'eaniens (= images\r\ncontinues de l'intervalle) et <span class=\"math inline\">\\(Z\\)</span>\r\nleur produit topologique (= l'espace de tous les couples <span\r\nclass=\"math inline\">\\(z = (x,y)\\)</span> o'u <span\r\nclass=\"math inline\">\\(\\lim z_{n}=z\\)</span> lorsque <span\r\nclass=\"math inline\">\\(\\lim x_{n} = x\\)</span> et <span\r\nclass=\"math inline\">\\(\\lim y_{n} = y\\)</span>).</li>\r\n</ol>\r\n<p>1^0. Si le continu <span class=\"math inline\">\\(X\\)</span>, ainsi que\r\n<span class=\"math inline\">\\(Y\\)</span>, poss'ede la propri'et'e que dans\r\nchaque transformation continue de ce continu en un sous-ensemble il\r\nexiste un point invariant, est-il vrai que <span\r\nclass=\"math inline\">\\(Z\\)</span> poss'ede la m^eme propri'et'e?</p>\r\n<p>2^0. Si le continu <span class=\"math inline\">\\(X\\)</span>, ainsi que\r\n<span class=\"math inline\">\\(Y\\)</span>, est uni-coh'erent (= dans chaque\r\nd'ecomposition de ce continu en deus sous-continus la partie commune de\r\nces sous-continus est connexe), est-il vrai que <span\r\nclass=\"math inline\">\\(Z\\)</span> est unicoh'erent?</p>\r\n<p>Probl'eme de M. Kuratowski.</p>\r\n<ol start=\"50\" type=\"1\">\r\n<li>Ist der topologische Kreis die einzige homogene im kleinen\r\nzusammenh\"angende Kurve? (Kurve = eindimensionaler zusammen-h\"angender\r\nkompakter Raum. Homogen hei<span class=\"math inline\">\\(\\beta\\)</span>t\r\nein Raum, der zu je zwei seiner Punkte <span\r\nclass=\"math inline\">\\(p\\)</span> und <span\r\nclass=\"math inline\">\\(q\\)</span> eine topologische Selbstabbildung\r\nbesitzt die <span class=\"math inline\">\\(p\\)</span> in <span\r\nclass=\"math inline\">\\(q\\)</span> \"uberf\"uhrt). In der Ebene ist der\r\nKreis die einzige homogene im kleinen zusammenh\"angende Kurve.</li>\r\n</ol>\r\n<p>(Vgl. Mazurkiewicz, Fund. Math. V, S. 137).</p>\r\n<p>Probl'eme de M. K. Menger.</p>\r\n<ol start=\"51\" type=\"1\">\r\n<li>Gibt es beliebig oder gar unendlich viele kompakte eindimensionale\r\nR\"aume, die zu je zweien eindimentional unvergleichbar sind? Dabei\r\nm\"ogen zwei R\"aume <span class=\"math inline\">\\(R\\)</span> und <span\r\nclass=\"math inline\">\\(R^{\\prime}\\)</span> eindimentional unvergleichbar\r\nhei<span class=\"math inline\">\\(\\beta\\)</span>en, wenn keine\r\neindimensionale Teilmenge von <span class=\"math inline\">\\(R\\)</span>,\r\n(bzw. von <span class=\"math inline\">\\(R^{\\prime}\\)</span>) hom\"oomorph\r\nist mit einer Teilmenge von <span\r\nclass=\"math inline\">\\(R^{\\prime}\\)</span> (bzw. von <span\r\nclass=\"math inline\">\\(R^{\\prime}\\)</span>). Beispielsweise sind\r\neindimensional unvergleichbar eine Strecke und ein Kontinuum ohne\r\nTeilbogen. (Wenn es <span class=\"math inline\">\\(n\\)</span>, bzw. <span\r\nclass=\"math inline\">\\(\\aleph_{0}\\)</span> paarweise eindimensional\r\nunvergleichbare Kurven gibt, so existieren kompakte eindimensionale\r\nR\"aume, welche mindestens <span class=\"math inline\">\\(2^{n} +1\\)</span>,\r\nbze. <span class=\"math inline\">\\(2^{\\aleph_{0}}\\)</span> monotone, <span\r\nclass=\"math inline\">\\(F_{\\sigma}\\)</span>-additive, toppologische,\r\nkompaktifizierbare Systeme von Teilmengen enthalten).</li>\r\n</ol>\r\n<p>(Vgl. Monatshefte f. Math. u. Phys. 36, S. 207).</p>\r\n<p>Probl'eme de M. K. Menger.</p>\r\n<ol start=\"52\" type=\"1\">\r\n<li>Existe-il un continu dont tout autre continu soit une image\r\ncontinue?</li>\r\n</ol>\r\n<p>Probl'eme de M. H. Hahn.</p>\r\n<ol start=\"53\" type=\"1\">\r\n<li><ol type=\"a\">\r\n<li>Ist jeder absolute Retrakt in endlich viele absolute Retrakte mit\r\nbeliebig kleinen Durchmessern zerlegbar?</li>\r\n</ol></li>\r\n</ol>\r\n<ol start=\"2\" type=\"a\">\r\n<li>Lasst sieh jede <span class=\"math inline\">\\(R\\)</span>-Menge in\r\nendlich viele absolu#e Retrakte zerlegen?</li>\r\n</ol>\r\n<p>(Die Definition von absoluten Retrakten und von <span\r\nclass=\"math inline\">\\(R\\)</span>-Mengen ist z. B. in meiner Note aus\r\nFund. Math. XIX, S. 222 angegeben).</p>\r\n<ol start=\"54\" type=\"1\">\r\n<li><p>Ist jedes Teilkontinuum <span class=\"math inline\">\\(C\\)</span>\r\ndes eaklidieelien <span class=\"math inline\">\\(n\\)</span>-dimensionalen\r\nRaumes <span class=\"math inline\">\\(R_{n}\\)</span>, welches <span\r\nclass=\"math inline\">\\(R_{n}\\)</span> zerschneidet und welches eich durch\r\nbeliebig kleine Transformationen (d. h. durch eine stetige Abbildung,\r\nwelehe jeden Punkt von <span class=\"math inline\">\\(C\\)</span> in einen\r\nbeliebig nahe liegenden Punkt von <span\r\nclass=\"math inline\">\\(R_{n}\\)</span> tiberfiibrt) in eine mit ihm\r\npunktfremde Teilmenge von R. \"uberf\"uhren lasst, eine (<span\r\nclass=\"math inline\">\\(n-1\\)</span>)-dimensionale\r\nMannigfaltigkeit?</p></li>\r\n<li><p>L\"asst sich jedes in <span class=\"math inline\">\\(R_{3}\\)</span>\r\nliegende und <span class=\"math inline\">\\(R_{3}\\)</span> zerschneidende\r\nStreckenbild in eich stetig und fixpunktfrei abbilden?</p></li>\r\n</ol>\r\n<p>Probl'emes de M. K. Borsuk.</p>\r\n<ol start=\"58\" type=\"1\">\r\n<li>Soient <span class=\"math inline\">\\(A\\)</span> et <span\r\nclass=\"math inline\">\\(B\\)</span> deux espaces topologiques et <span\r\nclass=\"math inline\">\\(A^{2}\\)</span> et <span\r\nclass=\"math inline\">\\(B^{2}\\)</span> respectivement leur carr'es (a. `a.\r\nd. <span class=\"math inline\">\\(A^{2}\\)</span> p. ex. se compose de tous\r\ntes couples (<span class=\"math inline\">\\(a_{1}\\)</span>, <span\r\nclass=\"math inline\">\\(a_{2}\\)</span>) extraite de <span\r\nclass=\"math inline\">\\(A\\)</span>).</li>\r\n</ol>\r\n<p>Est-il vrai que si <span class=\"math inline\">\\(A^{2}\\)</span> et\r\n<span class=\"math inline\">\\(B^{2}\\)</span> sont hom'eomorphes. <span\r\nclass=\"math inline\">\\(A\\)</span> et <span\r\nclass=\"math inline\">\\(B\\)</span> le sont aussi?</p>\r\n<p>En ess de relronae positire, on en d'eduit que, <span\r\nclass=\"math inline\">\\(C\\)</span> 'etant un ensemble qui n'est\r\nhom'eomorphe `a aucun, <span class=\"math inline\">\\(C^{n}\\)</span>, <span\r\nclass=\"math inline\">\\(n&gt;1\\)</span>, les ensembles <span\r\nclass=\"math inline\">\\(C^{m}\\)</span> et <span\r\nclass=\"math inline\">\\(C^{n}\\)</span> ne sont non plus hom'eomorphes pour\r\n<span class=\"math inline\">\\(m\\neq n\\)</span>; cela fournit dans le eas\r\no`u <span class=\"math inline\">\\(C\\)</span> est un intervalle 1e\r\nth'eor'eme de \"l'invariance de la dimension\" de M. Brouwer.</p>\r\n<p>Probl'eme de M. S. Ulam.</p>\r\n<ol start=\"57\" type=\"1\">\r\n<li>Existe-il un continu de dimension infinie qui n'en contient aucun de\r\ndimension finie?</li>\r\n</ol>\r\n<p>Probl'eme de M. S. Mazurkiewicz.</p>\r\n<ol start=\"58\" type=\"1\">\r\n<li>Gibt es in einer Menge <span class=\"math inline\">\\(E\\)</span> von\r\nder M\"achtigkeit <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ein\r\nabz\"ahlbares System von Teilmengen <span class=\"math inline\">\\(A_{1},\r\nA_{2},\\dots\\)</span> derart, dass man in der Gestalt <span\r\nclass=\"math display\">\\[X = \\overline{\\lim} A_{p_{n}}\\]</span> (<span\r\nclass=\"math inline\">\\(p_{1}, p_{2},,\\dots\\)</span> Teilfolge der\r\nnat\"urlichen Zahlen, <span\r\nclass=\"math inline\">\\(\\overline{\\lim}\\)</span> bedeutet dag Barel-sche\r\n<em>ensemble limite complet</em>) alle Teilmengen <span\r\nclass=\"math inline\">\\(X\\)</span> von <span\r\nclass=\"math inline\">\\(E\\)</span> erh\"alt?</li>\r\n</ol>\r\n<p>(Es handelt sich, die Verneinung ohne Benutzung der\r\nKontinuumhypethese zu beweisen).</p>\r\n<p>Probl'me de M. F. Hausdorff.</p>\r\n<ol start=\"59\" type=\"1\">\r\n<li>Une fonction jouissant de la propri'et'e de Baire (c'est-`a-dire\r\ncontinue sur tout ensemble parfait, lorsqu'on n'eglige un ensemble de\r\n<span class=\"math inline\">\\(1^{re}\\)</span> cat'egorie relativement `a\r\ncet ensemble) d'une fonction jouiseant de la propri'et'e de Baire,\r\nest-elle de la m^eme nature?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpi'nski.</p>\r\n<ol start=\"60\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(\\rho\\)</span> l'ensemble de toutes\r\nles transformations hom'eomorphes du plan cart'esien en lui-m^eme, de la\r\nforme: <span class=\"math display\">\\[x^{\\prime} = x, \\quad y^{\\prime}\r\n=f(x,y)\\]</span> et <span class=\"math display\">\\[x^{\\prime}=g(x,y),\r\n\\quad  y^{\\prime}=y.\\]</span></li>\r\n</ol>\r\n<p>D'esignons par <span class=\"math inline\">\\(\\sigma\\)</span> le groupe\r\nform'e par toutes les superpositions finies de toutes les\r\ntransformations appartenant `a <span\r\nclass=\"math inline\">\\(\\rho\\)</span>. Une transformation hom'eomorphe\r\narbitraire du plan en lui-m^eme se laisse-telle toujours approcher par\r\ncelles du groupe <span class=\"math inline\">\\(\\sigma\\)</span>?</p>\r\n<p>Un probl'eme analogue subsiste pour les espaces `a <span\r\nclass=\"math inline\">\\(n&gt;2\\)</span> dimensions. Probl'eme de M. S.\r\nUlam.</p>\r\n<ol start=\"61\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(E\\)</span> un ensemble plan <span\r\nclass=\"math inline\">\\(G_{\\delta}\\)</span> (plus g'en'eralement: un\r\nensemble borelien) dont tontes les intersections avec les droites\r\nparall'eles `a l'axe des <span class=\"math inline\">\\(y\\)</span> sont des\r\nensembles ferm'es (plus g'en'eralement: des <span\r\nclass=\"math inline\">\\(F_{\\sigma}\\)</span>). La projection de <span\r\nclass=\"math inline\">\\(E\\)</span> sur l'axe des <span\r\nclass=\"math inline\">\\(x\\)</span> est-elle toujours un ensemble\r\nborelien?</li>\r\n</ol>\r\n<p>Probl'eme de M. E. Szpilrajsn.</p>\r\n<ol start=\"62\" type=\"1\">\r\n<li>Die (reelle) Funktion <span class=\"math inline\">\\(f(x)\\)</span> der\r\nreellen Variablen <span class=\"math inline\">\\(x\\)</span> heisse\r\n<em>symmetrisch-stetig</em> wenn f\"ur jedes <span\r\nclass=\"math inline\">\\(x\\)</span> <span\r\nclass=\"math display\">\\[\\lim\\limits_{h \\to 0} [f(x+h) - f(x - h)] =\r\nO.\\]</span> Kann die Menge der Unstetigkeitsstellen einer solchen\r\nFunktion unabz\"ahlbar sein? Kann sie eine beliebig vorgeschriebene Menge\r\n<span class=\"math inline\">\\(F_{\\sigma}\\)</span> sei? (Dass sie eine\r\nbeliebig vorgeschriebene abz\"ahlbare Menge sein kann, ist leicht\r\neinzusehen.)</li>\r\n</ol>\r\n<p>Probl'eme de M. F. Hausdorff.</p>\r\n<ol start=\"63\" type=\"1\">\r\n<li>Deux espaces compacts <span class=\"math inline\">\\(A\\)</span> et\r\n<span class=\"math inline\">\\(B\\)</span> ont le <em>m^eme type\r\nd'homotopie</em>, lorsqu'il existe une transformation continue <span\r\nclass=\"math inline\">\\(f\\)</span> de <span\r\nclass=\"math inline\">\\(A\\)</span> en <span\r\nclass=\"math inline\">\\(B\\)</span> et une transformation continue <span\r\nclass=\"math inline\">\\(f\\)</span> de <span\r\nclass=\"math inline\">\\(A\\)</span> en <span\r\nclass=\"math inline\">\\(B\\)</span> et une transformation continue <span\r\nclass=\"math inline\">\\(\\varphi\\)</span> de <span\r\nclass=\"math inline\">\\(B\\)</span> en <span\r\nclass=\"math inline\">\\(A\\)</span>, telles que les transformations\r\nsuperpos'ees <span class=\"math inline\">\\(\\varphi f\\)</span> et <span\r\nclass=\"math inline\">\\(f\\varphi\\)</span> (consid'er'ees respectivement\r\ncomme des trans-formations de <span class=\"math inline\">\\(A\\)</span> en\r\n<span class=\"math inline\">\\(A\\)</span> et de <span\r\nclass=\"math inline\">\\(B\\)</span> en <span\r\nclass=\"math inline\">\\(B\\)</span>) soient homotopes `a l'identit'e. Deux\r\nvari'et'es ferm'ees de m^eme type d'homotopie sont-elles toujours\r\nhom'eomorphes?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Hurewicz.</p>\r\n<ol start=\"64\" type=\"1\">\r\n<li><p>Gibt es im <span class=\"math inline\">\\(R^{n}\\)</span> zwei\r\norientierbare Mannigfaltigkeiten <span\r\nclass=\"math inline\">\\(M_{1}^{k}\\)</span> und <span\r\nclass=\"math inline\">\\(M_{2}^{k}\\)</span>, deren Komplement\"arr\"aume\r\n<span class=\"math inline\">\\(R^{n} - M_{1}^{k}\\)</span> und <span\r\nclass=\"math inline\">\\(R^{n} - M_{2}^{k}\\)</span> hom\"oomorph und deren\r\nHomologieringe nicht isomorph sind?</p></li>\r\n<li><p>Soient <span class=\"math inline\">\\(B_{0}, B_{1}, B_{2}, \\dots,\r\nB_{\\omega}, \\dots, B_{\\alpha}, \\dots\\)</span> des classes boreliennes\r\nd'ensembles, form'ees en partant d'une classe quelconque d'ensembles\r\nabstraits. On sait que <span class=\"math inline\">\\(B_{\\alpha} =\r\nB_{\\alpha+}\\)</span>. entra^ine <span class=\"math inline\">\\(B_{\\alpha}=\r\nB_{\\beta}\\)</span> pour tout <span\r\nclass=\"math inline\">\\(\\beta&gt;\\alpha\\)</span>; soit <span\r\nclass=\"math inline\">\\(\\alpha_{0}\\)</span> le premier nombre <span\r\nclass=\"math inline\">\\(\\alpha\\)</span> satisfaisant `a cette condition.\r\nQuels sont les nombres <span class=\"math inline\">\\(v\\)</span> pour\r\nlesquels il existe des classes <span\r\nclass=\"math inline\">\\(B_{0}\\)</span> telles que l'on ait <span\r\nclass=\"math inline\">\\(\\alpha_{0} = v\\)</span>? (Cf. Fund. Math. t. XV,\r\np. 284).</p></li>\r\n</ol>\r\n<p>Probl'emes de M. A. Ko1mogoroff.</p>\r\n<ol start=\"66\" type=\"1\">\r\n<li>La propri'et'e <span class=\"math inline\">\\(LC\\)</span>\r\n<em>faible</em> entra^ine-t-elle la propri'et'e <span\r\nclass=\"math inline\">\\(LC\\)</span> forte pour tout espace m'etrique\r\ncompact? M^eme question pour les pro-pri'et'es <span\r\nclass=\"math inline\">\\(HLC\\)</span>. (Pour les d'efinitions voir Anaals\r\nof Mathematics, vol. 85, p. 119-129 et Duke Mathematical Journal, vol.\r\n1, p. 1-18).</li>\r\n</ol>\r\n<p>Probl'eme de M. S. Lefschetz.</p>\r\n<ol start=\"67\" type=\"1\">\r\n<li>La propri'et'e (<span class=\"math inline\">\\(C\\)</span>) des\r\nensembles lin'eaires est elle invariante par rapport aux transformations\r\nhom'eomorphes et, plus g'en'erale-ment, par rapport aux transformations\r\ncontinues? (On dit qu'un ensemble <span class=\"math inline\">\\(E\\)</span>\r\nposs'ede la <em>propri'et'e</em> (<span\r\nclass=\"math inline\">\\(C\\)</span>), lorsqu'il existe pour chaque suite\r\n<span class=\"math inline\">\\(\\{a_{n}\\}\\)</span> de nombres positifs une\r\nd'ecomposition $E=E_{1}+E_{2} + $ telle que le diam'etre de <span\r\nclass=\"math inline\">\\(E_{n}\\)</span> ne d'epasse pas <span\r\nclass=\"math inline\">\\(a_{n}\\)</span> pour <span\r\nclass=\"math inline\">\\(n=1, 2,\\dots\\)</span>. Cf. Fund. Math, t. XI, p.\r\n304; t. XV, p. 126; t. XXII, p. 310.)</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpi'nski.</p>\r\n<ol start=\"68\" type=\"1\">\r\n<li>Tai et <span class=\"math inline\">\\(E_{1}\\)</span> 'etant deux\r\nensembles lin'eaires toujours de premi'ere cat'egorie (c. `a d. de\r\npremi'ere cat'egorie sur tout ensemble parfait), l'ensemble <span\r\nclass=\"math inline\">\\(E_{1} \\times E_{2}\\)</span>. (c. `a d. l'ensemble\r\nde tous les points <span class=\"math inline\">\\((x, y)\\)</span> du plan\r\no'u <span class=\"math inline\">\\(x \\in E_{1}\\)</span> et <span\r\nclass=\"math inline\">\\(y \\in E_{2}\\)</span>) est-il de m^eme nature?</li>\r\n</ol>\r\n<p>Probl'eme de M. E. Szpilrajn.</p>\r\n<ol start=\"69\" type=\"1\">\r\n<li>Lorsqu'une conrbe de Jordan (dans un espace `a trois dimensions)\r\nposs'ede en chaque point une tangente d'etermin'ee, existe-t-il\r\nn'ecessairement une reprparam'etrique de cette courbe exprimant les\r\ncoordonn'ees cart'esiennes d'un point de cette courbe comme fonctions\r\nd'erivables d'un param'etre (et cela sans que les trois d'erive'ees\r\ns'annulent en m^eme temps)?</li>\r\n</ol>\r\n<p>En cas de r'epinse n'egative, la question est repos'ee en admenttant\r\nun ensemble de mesure nulle de valeues du param'etre o'u les conditions\r\nimpos'ees ne sont pas toutes deux v'erifi'ees.</p>\r\n<p>Probl'eme de M. M. Fr'echet.</p>\r\n<ol start=\"70\" type=\"1\">\r\n<li>Existe-t-il un ensemble lin'eaire <span\r\nclass=\"math inline\">\\(E\\)</span> tel que chaque ensemmble analytique\r\nlin'eaire est une image biunivoque et continue (dans un sens) de <span\r\nclass=\"math inline\">\\(E\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpi'nski.</p>\r\n<ol start=\"71\" type=\"1\">\r\n<li>Existe-t-il une suite infinie <span class=\"math inline\">\\(S\\)</span>\r\nde fonctions d'une variable r'eelle (mesurables ou non), telle que toute\r\nfonction d'une variable r'eelle dde classe <span\r\nclass=\"math inline\">\\(2\\)</span> Baire soit limite d'une suit extraite\r\nde <span class=\"math inline\">\\(S\\)</span>?</li>\r\n</ol>\r\n<p>(D'apr'es M. C. Burstin une telle suite <span\r\nclass=\"math inline\">\\(S\\)</span> ne peut ^etre compos'ee uniquement de\r\nfonctions mesurables[^4])</p>\r\n<p>Probl'eme de M. W. Sierpi'nski.</p>\r\n<p>[^4] Monatshefte f. Math. u. Phys. 28 (1917), p. 107.</p>\r\n<ol start=\"72\" type=\"1\">\r\n<li>Existe-t-il dans l'espace cart'esien `a <span\r\nclass=\"math inline\">\\(n\\)</span> dimensions (<span\r\nclass=\"math inline\">\\(n&gt;1\\)</span>) un ensemble toujours de premi'ere\r\ncat'egorie (c. `a d. de premi'ere cat'egorie sur chaque ensemble\r\nparfait) et qui soit de dimension positive?</li>\r\n</ol>\r\n<p>(M. W. Hurewicz a d'emontr'e `a l'aide de l'hypoth'ese du continu\r\nqu'il existe dans l'espace de Hilbert un ensemble ind'enombrable <span\r\nclass=\"math inline\">\\(H\\)</span> dont chaque sous-ensemble\r\nind'enombrable est de dimension infinie[^5]). M. F. Hausdorff a\r\nremarqu'e l'ensemble <span class=\"math inline\">\\(H\\)</span> est toujours\r\nde premi'ere cat'egorie. Cela r'esulte ais'ement du fait que chaque\r\nespace m'etrique s'eparable <span class=\"math inline\">\\(M\\)</span> est\r\nsomme d'un ensemble de dimension <span class=\"math inline\">\\(0\\)</span>\r\net d'un ensemble de premi'ere cat'egorie dans <span\r\nclass=\"math inline\">\\(M\\)</span>. -- <em>Il existe donc, so <span\r\nclass=\"math inline\">\\(2^{\\aleph} = \\aleph_{1}\\)</span>, dons l'espace de\r\nHilbert un ensemble toujours de premi'erie cat'egorie et de dimension\r\npositive</em>).</p>\r\n<p>Probl'eme de M. E. Szpilrajn.</p>\r\n<p>[^5] Fund. Math. 19 (1932), p.8.</p>\r\n<ol start=\"73\" type=\"1\">\r\n<li>Soient, dans l'espace euclidien `a trois dimensions, <span\r\nclass=\"math inline\">\\(E\\)</span> une image hom'eomorphe de la sph'ere\r\nsolide <span class=\"math inline\">\\(S\\)</span> et <span\r\nclass=\"math inline\">\\(L\\)</span> un segment rectiligne dont l'int'erieur\r\nest contenu dans l'int'erieur, et les extr'emeit'es dans la fronti'ere\r\nde <span class=\"math inline\">\\(E\\)</span>. Existe-t-il toujours une\r\nhom'eomorphie transformant <span class=\"math inline\">\\(E\\)</span> en\r\n<span class=\"math inline\">\\(S\\)</span> de facon que <span\r\nclass=\"math inline\">\\(L\\)</span> soit transorm'e en diam'etre de <span\r\nclass=\"math inline\">\\(S\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. K. Borsuk.</p>\r\n<ol start=\"74\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(\\mathbf{B}(\\mathbf{F})\\)</span> la\r\nplus petite famille d'ensembles contenant la famille donn'ee <span\r\nclass=\"math inline\">\\(\\mathbf{F}\\)</span> et close par rapoort aux\r\nop'erations <span class=\"math inline\">\\(\\sigma\\)</span> et <span\r\nclass=\"math inline\">\\(\\delta\\)</span> (addition et multiplication\r\nd'enombrables). Existe-t-il une famille d'enombrable <span\r\nclass=\"math inline\">\\(\\mathbf{D}\\)</span> d'ensembles, telle que tous\r\nles ensembles analytiques lin'eaires appartiennent `a <span\r\nclass=\"math inline\">\\(\\mathbf{B}(\\mathbf{D})\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. S. Ulam.</p>\r\n<ol start=\"75\" type=\"1\">\r\n<li>Existe-t-il un ensemble infini <span\r\nclass=\"math inline\">\\(E\\)</span> (p.e. l'ensemble de tous les nombres\r\nnaturels) et une fonction <span class=\"math inline\">\\(f(X)\\)</span> qui\r\nfait correspondre `a tout sous-ensemble <span\r\nclass=\"math inline\">\\(X\\)</span> de <span\r\nclass=\"math inline\">\\(E\\)</span> un sous-ensemble <span\r\nclass=\"math inline\">\\(f(X)\\)</span> de <span\r\nclass=\"math inline\">\\(E\\)</span>, de sorte que:</li>\r\n</ol>\r\n<p>1<span class=\"math inline\">\\(^\\circ\\)</span> <span\r\nclass=\"math inline\">\\(X \\subset f(X)\\)</span> pour <span\r\nclass=\"math inline\">\\(X \\subset E\\)</span>, 2<span\r\nclass=\"math inline\">\\(^\\circ\\)</span> <span class=\"math inline\">\\(f(X+Y)\r\n= f(X) + f(Y)\\)</span> pour <span class=\"math inline\">\\(X \\subset\r\nE\\)</span>, <span class=\"math inline\">\\(Y \\subset E\\)</span>, 3<span\r\nclass=\"math inline\">\\(^\\circ\\)</span> il existe pour tout ensemble <span\r\nclass=\"math inline\">\\(Y \\subset E\\)</span> au moins un ensemble <span\r\nclass=\"math inline\">\\(X \\subset E\\)</span>, tel que <span\r\nclass=\"math inline\">\\(Y = f(X)\\)</span>, 4<span\r\nclass=\"math inline\">\\(^\\circ\\)</span> il existe au moins un ensemble\r\n<span class=\"math inline\">\\(X_{0} \\subset E\\)</span>, tel que <span\r\nclass=\"math inline\">\\(f(X_{0}) \\neq X_{0}\\)</span>.</p>\r\n<p>Si l'on remplace la condition relative `a <span\r\nclass=\"math inline\">\\(f(X+Y)\\)</span> par la condition plus faible que\r\n<span class=\"math inline\">\\(f(X) \\subset f(Y)\\)</span> pur <span\r\nclass=\"math inline\">\\(X \\subset Y \\subset E\\)</span>, la r'eponse\r\npositive est 'evidente.</p>\r\n<p>Probl'eme de M. E. ech.</p>\r\n<h2 id=\"problemes-rsolus.\">Probl'emes r'solus.</h2>\r\n<p>Probl. 1) Lorsque un ensemble de points <span\r\nclass=\"math inline\">\\(P\\)</span> est une image biunvoque et continue\r\n(dans un sens) de <span class=\"math inline\">\\(Q\\)</span> et <span\r\nclass=\"math inline\">\\(Q\\)</span> est une image biunivoque et continue de\r\n<span class=\"math inline\">\\(P\\)</span>, peut-on affirmer que les\r\nensembles <span class=\"math inline\">\\(P\\)</span> et <span\r\nclass=\"math inline\">\\(Q\\)</span> sont hom'eomorphes?</p>\r\n<p>Solution <em>n'egative</em> de M. Kuratowski, <em>Fund. Math.</em> t.\r\nII, pp. 158-160</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>Existe-il une d'ecomposition d'un intervalle en <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles mesurables (<span\r\nclass=\"math inline\">\\(B\\)</span>), non-vides et sans points communs deux\r\n`a deux?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de MM. Lusin et Sierpinski, <em>Comptes\r\nRendus</em>, t. 175, p.357 (note du 21 ao^ut 1922).</p>\r\n<p>6, troisi'eme partie) Peut-on d'emontrer qu'un produit de <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles (<span\r\nclass=\"math inline\">\\(A\\)</span>) n'est pas n'ecessairement un ensemble\r\n(<span class=\"math inline\">\\(A\\)</span>)?</p>\r\n<p>Solution <em>affirmative</em> de MM. Lusin et Sierpinski, <em>Journ,\r\nde Math</em>. 1923 (Les auteurs d'efinissent un ensemble qui est\r\ncompl'ementaire d'un ensemble (<span class=\"math inline\">\\(A\\)</span>)\r\nn'est pas n'ecessairement un ensemble (<span\r\nclass=\"math inline\">\\(A\\)</span>))</p>\r\n<ol start=\"8\" type=\"1\">\r\n<li>Peut-on donner un exemple effectif d'un ensemble de nombres r'eels\r\n<span class=\"math inline\">\\(E\\)</span>, tel que toute somme, toute\r\ndiff'erence, tout produit et tout quotient de deux nombres de <span\r\nclass=\"math inline\">\\(E\\)</span> (except'e la division par 0)\r\nappartienne `a <span class=\"math inline\">\\(E_{1}\\)</span> et que <span\r\nclass=\"math inline\">\\(E\\)</span> soit non-d'enombrable, distinct de\r\nl'ensemble de tous les nombres r'eels?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de M. Souslin, <em>Fund. Math.</em> IV,\r\np.311.</p>\r\n<p>10, premi'ere partie) Existe-il une fonction de deuxi'eme classe qui\r\nne soit pas la limite de fonctions preque partout discontinues?</p>\r\n<p>Solution <em>affirmative</em> de M. Zalcwasser.</p>\r\n<ol start=\"12\" type=\"1\">\r\n<li>Un ensemble ordonn'e dont tous les sous-ensembles bien ordonn'es\r\n(croissants on d'ecroissants) sont au plus d'enombraibles, a-t-il\r\nn'ecessairement une puissance non sup'erieure `a celle du continu?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de M. Urysohn, <em>Fund. Math.</em> V\r\n(h paraitre).</p>\r\n<ol start=\"15\" type=\"1\">\r\n<li>Existe-il un continu dont tout sous-continu est\r\nind'ecomposable?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de M. Knaster, <em>Fund. Math.</em> III\r\npp. 247-286.</p>\r\n<ol start=\"16\" type=\"1\">\r\n<li>Existe-il continu qui est une somme de ses vrais sous-continues\r\nsatur'es disjoints?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de M. Knaster et Kuratowski, <em>Fund.\r\nMath.</em> V (`a paraitre).</p>\r\n","site":{"data":{}},"excerpt":"","more":"<ol type=\"1\">\r\n<li>Lorsqu'un ensemble de points <span class=\"math inline\">\\(P\\)</span>\r\nest une image biunivoque et continue (mais pas n'ecessairement\r\nbicontinue) d'un ensemble <span class=\"math inline\">\\(Q\\)</span> et\r\nlorsque <span class=\"math inline\">\\(Q\\)</span> est une image biunivoque\r\net continue de <span class=\"math inline\">\\(P\\)</span>, lest ensembles\r\n<span class=\"math inline\">\\(P\\)</span> et <span\r\nclass=\"math inline\">\\(Q\\)</span> sont-ils n'ecessairement\r\nhomeomorphes?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Un continu (born'e) plan, topologiquement homog`ene, est-il\r\nn'ecessairement hom'eomorphe `a une circonf'erence?</li>\r\n</ol>\r\n<p>(Un ensemble <span class=\"math inline\">\\(E\\)</span> est dit\r\n<em>topologiquement homog'ene</em>, lorsqu'il existe pour tout couple de\r\npoints <span class=\"math inline\">\\(a,b\\)</span> de <span\r\nclass=\"math inline\">\\(E\\)</span> une transformation biunivoque et\r\nbicontinue de <span class=\"math inline\">\\(E\\)</span> en lui-m'eme qui\r\ntransforme <span class=\"math inline\">\\(a\\)</span> en <span\r\nclass=\"math inline\">\\(b\\)</span>)</p>\r\n<p>Probl'eme de MM. B. Knaster et C. Kuratowski.</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>Un ensemble ordonn'e (lin'eairement) sans sauts ni lacunes et tel\r\nque tout ensemble de ses intervalles (contenant plus qu'un 'el'ement)\r\nn'empi'etant pas les uns sur les autres est au plus d'enombrable, est-il\r\nn'ecessairement un continu lin'eaire (ordinaire)?</li>\r\n</ol>\r\n<p>Probl'eme de M. M. Souslin.</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>Existe-t-il une d'ecomposition d'un intervalle en <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles (non vides)\r\nmesurables <span class=\"math inline\">\\(B\\)</span> et sans point commun\r\ndeux `a deux?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"5\" type=\"1\">\r\n<li>Existe-t-il un ensemble lin'eaire ind'enombrable <span\r\nclass=\"math inline\">\\(E\\)</span> tel que tout ensemble lin'eaire\r\nhom'eomorphe `a <span class=\"math inline\">\\(E\\)</span> soit de mesure\r\nlebesguienne nulle? Peut-on d'emontrer l'existence d'un tel ensemble,\r\nm'eme en admettant que <span class=\"math inline\">\\(2^{\\aleph_{0}} =\r\n\\aleph_{1}\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"6\" type=\"1\">\r\n<li>Peut-on d'emoutrer sans l'hypoth'ese du continu (<span\r\nclass=\"math inline\">\\(2^{\\aleph_{0}} = \\aleph_{1}\\)</span>) qu'une somme\r\nde <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles de mesure\r\nlebesguienne nulle n'est pas n'ecessairement de mesure lebesquienne\r\nnulle? qu'une somme de <span class=\"math inline\">\\(\\aleph_{1}\\)</span>\r\nensembles de premi'ere cat'egorie n'est pas n'ecessairement de premi'ere\r\ncat'egorie? qu'un produit de <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles (<span\r\nclass=\"math inline\">\\(A\\)</span>) n'est pas n'ecessairement un ensemble\r\n<span class=\"math inline\">\\(A\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"7\" type=\"1\">\r\n<li>Peut-on 'etablir sans l'hypoth'ese du continu l'esistence d'un\r\nensemble plan qui est de mesure (lebesguienne) nulle sur toute\r\nparall'ele `a l'axe d'abscisses et dont le compl'ementaire est de mesure\r\nnulle sur toute parall'ele `a l'axe d'ordonn'ees?</li>\r\n</ol>\r\n<p>Probl'eme de M. H. Steinhaus.</p>\r\n<ol start=\"8\" type=\"1\">\r\n<li>Peut-on donner un exemple effectif d'un ensemble de nombres r'eels\r\n<span class=\"math inline\">\\(E\\)</span> tel que toute somme, toute\r\ndiff'erence, tout produit et tout quotient de deux nombres de <span\r\nclass=\"math inline\">\\(E\\)</span> (la division par 0 except'ee)\r\nappartienne `a <span class=\"math inline\">\\(E\\)</span> et que <span\r\nclass=\"math inline\">\\(E\\)</span> soit ind'enombrable, mais distinct de\r\nl'ensemble de tous les nombres r'eels?</li>\r\n</ol>\r\n<p>Probl'eme de M. S. Mazurkiewicz.</p>\r\n<ol start=\"9\" type=\"1\">\r\n<li>Quelle est la puissance des ensembles compl'ementaires aux ensembles\r\n(<span class=\"math inline\">\\(A\\)</span>)?</li>\r\n</ol>\r\n<p>Probl'eme de M. N. Lusin.</p>\r\n<p><em>Remarque</em>. Les ensembles (<span\r\nclass=\"math inline\">\\(A\\)</span>) lin'eaires sont des projections\r\northogonales (sur une froite) des ensembles plans mesurables <span\r\nclass=\"math inline\">\\(B\\)</span>. M. Lusin a d'emontr'e que la puissance\r\nd'un ensemble ind'enombrable compl'ementaire `a un ensemble (<span\r\nclass=\"math inline\">\\(A\\)</span>) est <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> ou <span\r\nclass=\"math inline\">\\(2^{\\aleph_{0}}\\)</span>, mais on ne sait pas si\r\nelle peut ^etre en r'ealit'e <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> (dans le cas o'u <span\r\nclass=\"math inline\">\\(2^{\\aleph_{0}} &gt; \\aleph_{1}\\)</span>)</p>\r\n<ol start=\"10\" type=\"1\">\r\n<li>Existe-t-il une fonction de deuxi'eme classe qui n'est pas une\r\nlimite de fonctions presque partout continues? Peut-on donner un exemple\r\neffectif d'une fonction qui n'est pas une limite de fonctions\r\nponctuellement discontinues?</li>\r\n</ol>\r\n<p>Probl'eme de MM. T. Feosztyn et W. Sierpinski.</p>\r\n<ol start=\"11\" type=\"1\">\r\n<li>Existe il une classe (<span\r\nclass=\"math inline\">\\(\\mathcal{L}\\)</span>) de M. Fr'echet (c'est-`a\r\ndire une classe dans laquelle la limite est d'efinie) de puissance\r\nsup'erieure `a celle du continu, telle que tout ensemble non\r\nd'enombrable d''el'ements de cette classe contient au moins un 'el'ement\r\nde condensation?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"12\" type=\"1\">\r\n<li>Un ensemble ordonn'e (lin'eairement) dont tous les sousensembles\r\nbien ordonn'es (croissants et d'croissants) sont au plus d'enombrables,\r\na-t-il n'ecessairement une puissance non sup'erieure `a celle du\r\ncontinu?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"13\" type=\"1\">\r\n<li>Existe-il un ensemble plan ferm'e qui ne soit pas somme de deux\r\nensembles ferm'es sans points communs, mais qui est une somme d'une\r\ninfinit'e d'enombrable d'ensembles ferm'es sans points communs deux `a\r\ndeux.</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"14\" type=\"1\">\r\n<li>Un continu dans l'espace `a <span class=\"math inline\">\\(m\\)</span>\r\ndimensions qui est hom'eomorphe de tout continu qu'il contient, est il\r\nn'ecessairement un arc simple (c'est-`a-dire une image biunivoque et\r\ncontinu de l'intervalle 0-1)?</li>\r\n</ol>\r\n<p>Probl'eme de M. Mazurkiewicz.</p>\r\n<ol start=\"15\" type=\"1\">\r\n<li>Existe-il un continu dont tout sous continu est ind'ecomposable? (Un\r\ncontinu est dit ind'ecomposable lorsqu'il n'est pas une somme de deux\r\ncontinus diff'erents de lui.)</li>\r\n</ol>\r\n<p>Probl'eme de MM. Knaster et Kuratowski.</p>\r\n<ol start=\"16\" type=\"1\">\r\n<li>Existe il un continu (non born'e) qui est une somme de ses vrais\r\nsous continus satur'es n'ayant deux `a deux aucun point commun?</li>\r\n</ol>\r\n<p>(On dit qu'un vrai sous-continu <span\r\nclass=\"math inline\">\\(K\\)</span> de <span\r\nclass=\"math inline\">\\(C\\)</span> est <em>satur'e</em>, lorsqu'il\r\nn'existe aucun continu diff'erent de <span\r\nclass=\"math inline\">\\(K\\)</span> et de <span\r\nclass=\"math inline\">\\(C\\)</span> qui contienne <span\r\nclass=\"math inline\">\\(K\\)</span> et qui soit contenu dans <span\r\nclass=\"math inline\">\\(C\\)</span>.)</p>\r\n<p>Probl'eme de M. Kuratowski.</p>\r\n<ol start=\"17\" type=\"1\">\r\n<li>Quelle est la puissance de l'ensemble de toutes les valeurs que ne\r\nprend pas une fonction de classe 1 de M. Baire?</li>\r\n</ol>\r\n<p>(Ce probl'eme est 'equivalent au probl'eme 9 de M. Lusin, t. I.\r\np.224. Il suffirait de r'esoudre ce probl'eme pour les fonctions\r\nadmettant une infinit'e d'enombrable de points de discontinuit'e.)</p>\r\n<ol start=\"18\" type=\"1\">\r\n<li>Un ensemble (lin'eaire) de puissance inf'erieure `a celle du\r\ncontinu, est-il n'ecessairement d'e la premi'ere cath'egorie de M.\r\nBaire?</li>\r\n</ol>\r\n<p>Probl'eme de M. Ruziewicz.</p>\r\n<ol start=\"19\" type=\"1\">\r\n<li>Existe-t-il dans chaque ensemble biconnexe <span\r\nclass=\"math inline\">\\(B\\)</span> un point <span\r\nclass=\"math inline\">\\(p\\)</span> tel que l'ensemble <span\r\nclass=\"math inline\">\\(B - (p)\\)</span> ne contient aucun ensemble\r\nconnexe?</li>\r\n</ol>\r\n<p><em>Remarque</em>. D'apre'es un th'eor'eme de M. Kline (ce volume,\r\np.238), il ne peut exister dans un ensemble connexe <span\r\nclass=\"math inline\">\\(B\\)</span> plus d'un point <span\r\nclass=\"math inline\">\\(p\\)</span> jouissant de la propri'et'e en\r\nquestion. On sait, d'autre part, que, si un tel point existe, l'ensemble\r\n<span class=\"math inline\">\\(B\\)</span> est biconnexe, c.-`a-d. il n'est\r\npas somme de duex ensembles connexes disjoints cont'enant plus d'un\r\npoint (cf. Knaster et Kuratowski, <em>Fund. Math.</em> II, p,214.)</p>\r\n<p>Probl'eme de M. Kuratowski.</p>\r\n<ol start=\"20\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(f(E)\\)</span> une fonction d'efinie\r\npor tout ensemble <span class=\"math inline\">\\(E\\)</span> mesurable\r\n(<span class=\"math inline\">\\(L\\)</span>) d'un espace euclidien `a <span\r\nclass=\"math inline\">\\(m \\geq 3\\)</span> dimensions et satisfaisant aux\r\nconditions suivantes:</li>\r\n</ol>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(f(E)\\geq 0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(f(E_{0}) = 1\\)</span> pur un certain\r\nensemble <span class=\"math inline\">\\(E_{0}\\)</span> de mesure 1.</li>\r\n<li><span class=\"math inline\">\\(f(E_{1} +E_{2}) = f(E_{1}) +\r\nf(E_{2})\\)</span>, si <span class=\"math inline\">\\(E_{1} E_{2} =\r\n0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(f(E_{1}) = f(E_{2})\\)</span>, si <span\r\nclass=\"math inline\">\\(E_{1}\\)</span> et <span\r\nclass=\"math inline\">\\(E_{2}\\)</span> sont superposables.</li>\r\n</ol>\r\n<p>La fonction <span class=\"math inline\">\\(f(E)\\)</span> coincide-t-elle\r\nn'ecessairement avec la mesure lebesguienne de l'ensemble <span\r\nclass=\"math inline\">\\(E\\)</span>?</p>\r\n<p>(Pour <span class=\"math inline\">\\(m=1\\)</span> et <span\r\nclass=\"math inline\">\\(m=2\\)</span> la r'eponse est n'egative, comme l'a\r\nprouv'e M. Banach dans un m'emoire qui sera publi'e dans le tome IV de\r\nce jounal.)</p>\r\n<p>Probl'eme de M. Ruziewicz.</p>\r\n<ol start=\"21\" type=\"1\">\r\n<li>A 'etant un ensemble de nombres r'eels qui n'est de I cat'egorie\r\ndans aucun intervalle, existe-il une d'ecomposition: <span\r\nclass=\"math inline\">\\(A = B + C\\)</span>, <span class=\"math inline\">\\(B\r\n\\times C = 0\\)</span> telle que ni <span\r\nclass=\"math inline\">\\(B\\)</span> ni <span\r\nclass=\"math inline\">\\(C\\)</span> ne soient de I cat'egorie dans aucun\r\nintervalle?</li>\r\n</ol>\r\n<p><em>Remarque</em>. On en pourrait donner la solution affirmative dans\r\nl'hypoth'ese suppl'ementaire que <span class=\"math inline\">\\(A\\)</span>\r\nposs'ede la propri'et'e de Baire (au sens etabli dans ce volume), p.319.\r\nM. Sierpinski en a signal'e d'autre part, la solution affirmative dans\r\nl'hypoth'ese du continu, <span class=\"math inline\">\\(\\aleph_{1} =\r\n2^{\\aleph_{0}}\\)</span>.</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"22\" type=\"1\">\r\n<li>Appellons l'ensemle (lin'eaire) <span\r\nclass=\"math inline\">\\(E\\)</span> <em>parfaitement mesurable</em>, si\r\ntout ensemble hom'eomorphe `a <span class=\"math inline\">\\(E\\)</span> est\r\nmesurable au sens de Lebesgue. Quelle est la puissance de la classe des\r\nensembles parfaitement mesurables? Un ensemble compl'ementaire `a un\r\nensemble parf. mesurable est-il toujours parf. mesurable?</li>\r\n</ol>\r\n<p>Problem of M. Urysohn.</p>\r\n<ol start=\"23\" type=\"1\">\r\n<li>Esiste-t-il une fonction d'une variable r'eelle <span\r\nclass=\"math inline\">\\(f(x)\\)</span> pantachiquement dicontinue et telle\r\nqu'on ait pour tout <span class=\"math inline\">\\(x\\)</span> r'eel</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\lim \\frac{f(x+h) - f(x-h)}{2h} =\r\n0?\\]</span></p>\r\n<p>Problem of M. Steinhaus.</p>\r\n<ol start=\"24\" type=\"1\">\r\n<li>Une fonction satisfaisan `a la condition de Baire, est-elle\r\nn'ecessairement mesurable (<span class=\"math inline\">\\(L\\)</span>)?\r\nQuelle est la puissance de toutes les fonctions d'une variable r'eelle\r\nsatisfaisant `a la condition de Baire? (On dit qu'une fonction <span\r\nclass=\"math inline\">\\(f(x)\\)</span> satisfait `a la condition de Baire,\r\nsi elle continue sur tout ensemble parfait quand on n'eglige les\r\nensembles de premi'ere cat'egorie par rapport `a cet ensemble\r\nparfait.)</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"25\" type=\"1\">\r\n<li>Un ensemble plan, tel que toute droite le rencontre en deux (et\r\nseulement deux) points, peut-il ^etre mesurable (<span\r\nclass=\"math inline\">\\(B\\)</span>)? (L'existence d'un tel ensemble a\r\n'et'e d'emontr'e, `a l'aide du th'eor'eme de M. Zermelo, par MM.\r\nMazurkiewicz[^1] (en 1914) et Rosenthal[^2] (en 1922))</li>\r\n</ol>\r\n<p>[^1] Comptes Rendus de lu Soc. des Sciences de Varsovic, t. VII,\r\np.382.</p>\r\n<p>[^2] Sitzungaber d. Bayer. Akad. d. Wiss., math-phys. K1, 1922, p.\r\n223.</p>\r\n<ol start=\"26\" type=\"1\">\r\n<li>Une fonction de classe 3 de M. Baire, est-elle toujours une\r\nsuperposition de trois fonctions de classe 1, c'est-`a-dire existe-t-il\r\npour toute fonction <span class=\"math inline\">\\(f(x)\\)</span> de classe\r\n3 trois fonctions <span class=\"math inline\">\\(\\varphi(x)\\)</span>, <span\r\nclass=\"math inline\">\\(\\psi(x)\\)</span> et <span\r\nclass=\"math inline\">\\(\\vartheta(x)\\)</span> de classe, telles qu'on a\r\npour tout <span class=\"math inline\">\\(x\\)</span> r'eel</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[f(x) =\r\n\\varphi\\{\\psi[\\vartheta(x)]\\}\\]</span></p>\r\n<p>Probl'eme de M. Lusin.</p>\r\n<ol start=\"27\" type=\"1\">\r\n<li>L'ensemble <span class=\"math inline\">\\(D(E)\\)</span> des distances\r\ndes points d'un ensemble lin'eaire <span\r\nclass=\"math inline\">\\(E\\)</span> mesurable <span\r\nclass=\"math inline\">\\((B)\\)</span>, est-il toujours mesurable (<span\r\nclass=\"math inline\">\\(B\\)</span>)? ( <span\r\nclass=\"math inline\">\\(D(E)\\)</span> est done l'ensemble de tous les\r\nnombres <span class=\"math inline\">\\(|x-y|\\)</span>, o'u <span\r\nclass=\"math inline\">\\(x\\)</span> et <span\r\nclass=\"math inline\">\\(y\\)</span> appartiennent `a <span\r\nclass=\"math inline\">\\(E\\)</span>. On peut d'emontrer l'existence des\r\nensembles <span class=\"math inline\">\\(E\\)</span> mesurables (<span\r\nclass=\"math inline\">\\(L\\)</span>), tels que <span\r\nclass=\"math inline\">\\(D(E)\\)</span> est non mesurable (<span\r\nclass=\"math inline\">\\(L\\)</span>).)</li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpinski.</p>\r\n<ol start=\"28\" type=\"1\">\r\n<li><span class=\"math inline\">\\(E\\)</span> 'etant un ensemble plan\r\nmesurable (<span class=\"math inline\">\\(B\\)</span>), d'esignons par <span\r\nclass=\"math inline\">\\(N(E)\\)</span> l'ensemble de tous les nombres\r\nr'eels <span class=\"math inline\">\\(a\\)</span>, tels que la droite <span\r\nclass=\"math inline\">\\(x = a\\)</span> rencontre <span\r\nclass=\"math inline\">\\(E\\)</span> en une infinit'e non-d'enombrable de\r\npoints. L'ensemble <span class=\"math inline\">\\(N(E)\\)</span>, est il\r\nn'ecessairement un ensemble (<span class=\"math inline\">\\(A\\)</span>),\r\nou, plus simplement, est-il mesurable (<span\r\nclass=\"math inline\">\\(L\\)</span>)? (On peut d'emontrer que l'ensemble de\r\ntous les nombres r'eels <span class=\"math inline\">\\(a\\)</span>, tels que\r\nla droite <span class=\"math inline\">\\(x = a\\)</span> rencontre\r\nl'ensemble <span class=\"math inline\">\\(E\\)</span> (mesurable <span\r\nclass=\"math inline\">\\(B\\)</span>) en une infinit'e de points est\r\ntoujouts un ensemble <span class=\"math inline\">\\(A\\)</span>.)</li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpinski.</p>\r\n<ol start=\"29\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(F\\)</span> un ensemble plan, p. ex.\r\nferm'e (ou, plus g'en'eralement, mesurable)- Un point <span\r\nclass=\"math inline\">\\(x\\)</span> de <span\r\nclass=\"math inline\">\\(F\\)</span> sera dit <em>lin'eairment\r\naccessible</em> s'il sxiste un segment rectiligne <span\r\nclass=\"math inline\">\\(\\overline{xp}\\)</span> tel que tous ses points (le\r\npoint <span class=\"math inline\">\\(x\\)</span> except'e) soient 'etrangers\r\n`a <span class=\"math inline\">\\(F\\)</span>. Peut-on d'emontrer que\r\nl'ensemble <span class=\"math inline\">\\(A\\)</span> de tous les points\r\nlin'eairement accessibles de <span class=\"math inline\">\\(F\\)</span> est\r\ntoujours mesurable (<span class=\"math inline\">\\(L\\)</span>)?</li>\r\n</ol>\r\n<p>Probl'eme de M. Urysohn.</p>\r\n<ol start=\"30\" type=\"1\">\r\n<li><span class=\"math inline\">\\(f(x)\\)</span> 'etant une fonction\r\ndonn'ee quelconque (mesurable ou non), quelle est la mesure de\r\nl'ensomble de tous les points <span class=\"math inline\">\\(x\\)</span>,\r\ntels que</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\lim\\limits_{h\\to 0} \\left|\\frac{f(x+h)\r\n- f(x)}{h}\\right| = \\infty\\]</span></p>\r\n<p>Probl'eme de M. Ruziewicz.</p>\r\n<ol start=\"31\" type=\"1\">\r\n<li>Le th'eor'eme: \"<span class=\"math inline\">\\(\\mathsf{m} = 2\\cdot\r\n\\mathsf{m}\\)</span> quel soit le nombre cardinal <em>transfini</em>\r\n<span class=\"math inline\">\\(\\mathsf{m}\\)</span>\" est il 'equivalent `a\r\n<em>l'axiome du choix</em>?</li>\r\n</ol>\r\n<p>Cf. ma Note \"<em>Sur quelques th'eor'emes qui 'equivalent `a l'axiome\r\ndu choix</em>\" dans ce volume, p. 147.</p>\r\n<p>Probl'eme de M. Tajtelbaum-Tarski.</p>\r\n<ol start=\"32\" type=\"1\">\r\n<li>Un ensemble plan ferm'e, don tout point est lin'eairement\r\naccessible, est-il n'ecessairement de mesure superficielle nulle?</li>\r\n</ol>\r\n<p>Probl'eme de M. Banach.</p>\r\n<p>Un point <span class=\"math inline\">\\(x\\)</span> de <span\r\nclass=\"math inline\">\\(F\\)</span> est dit lin'eairement accessible s'il\r\nexiste un segment rectiligne <span\r\nclass=\"math inline\">\\(\\overline{xp}\\)</span> tel que tous ses points (le\r\npoint <span class=\"math inline\">\\(x\\)</span> excepr'e) soient 'etrangers\r\n`a <span class=\"math inline\">\\(F\\)</span>. M. Urysohn a d'emontr'e que\r\nl'ensemble de tous les points lin'eairement accessibles d'un ensemble\r\nplan ferm'e est toujouts un ensemble (<span\r\nclass=\"math inline\">\\(A\\)</span>) de M. Souslin, mais peut ne pas ^etre\r\nmesurable (<span class=\"math inline\">\\(B\\)</span>). Or on ne sait pas si\r\nl'ensemble de tous les points lin'eairement accessibles d'un ensemble\r\nplan <span class=\"math inline\">\\(G_{\\delta}\\)</span> est mesurable\r\n(<span class=\"math inline\">\\(L\\)</span>) (Cf. Probl'eme 29, <em>Fund.\r\nMath.</em> t. V, p. 337).</p>\r\n<ol start=\"33\" type=\"1\">\r\n<li>Une image biunivoque et continue (dans un sens) d'un ensemble\r\ncompl'emeutaire `a un ensemble (<span class=\"math inline\">\\(A\\)</span>)\r\nde M. Souslin, est elle de m^eme nature?</li>\r\n</ol>\r\n<p>Probl'eme de Sierpi'nski.</p>\r\n<ol start=\"34\" type=\"1\">\r\n<li>Appelons un ensemble (lin`eaire) mesurable (<span\r\nclass=\"math inline\">\\(B\\)</span>) de classe a <em>irr'eductible</em>\r\ns'il n'est de classe <span class=\"math inline\">\\(&lt;\\alpha\\)</span>\r\ndans aucun intervalle. Quelle est la puissance de l'ensemble de tous les\r\ntypes topologiques d'ensumbles irr'eductibles de classe <span\r\nclass=\"math inline\">\\(\\alpha\\)</span>?</li>\r\n</ol>\r\n<p>Appelons un ensemble (<span class=\"math inline\">\\(A\\)</span>)\r\nirr'eductible, s'il n'est mesurable (<span\r\nclass=\"math inline\">\\(B\\)</span>) dans aucun intervalle. Quelle est la\r\npuissance de tous les types topologiques des ensembles (<span\r\nclass=\"math inline\">\\(A\\)</span>) irr'eductibles?</p>\r\n<p>Probl'eme de MM. Alexandroff et Urysohn.</p>\r\n<ol start=\"35\" type=\"1\">\r\n<li>Appelons l'ensemble (lin'eaire) <span\r\nclass=\"math inline\">\\(E\\)</span> <em>parfaitement mesurable au sens\r\n'etroit</em>, si toute image univoque et continue de <span\r\nclass=\"math inline\">\\(E\\)</span> est mesurable au sens de Lebsgue. Un\r\nensemble compl'ementaire `a un ensemble parfaitement mesurable au sens\r\n'etroit, est-il toujours de m^eme nature?</li>\r\n</ol>\r\n<p>Cf. Probl'eme 22 de P. Urysohn (<em>Fund. Math.</em> t. IV, p. 368),\r\nr'esolu par M. Lavrentieff (<em>Fund. Math.</em> t. VI, p. 159).</p>\r\n<p>Probl'eme de M. O. Nikodym.</p>\r\n<ol start=\"36\" type=\"1\">\r\n<li>D'apr'es M. Souslin, si <span class=\"math inline\">\\(E\\)</span> est\r\nun ensemble (<span class=\"math inline\">\\(A\\)</span>) et <span\r\nclass=\"math inline\">\\(H\\)</span> un ensemble compl'ementaire `a un\r\nensemble (<span class=\"math inline\">\\(A\\)</span>), et si <span\r\nclass=\"math inline\">\\(E \\subset H\\)</span>, il existe un ensemble <span\r\nclass=\"math inline\">\\(Q\\)</span>, mesurable (<span\r\nclass=\"math inline\">\\(B\\)</span>), tel que <span\r\nclass=\"math inline\">\\(E\\subset Q \\subset H\\)</span>[^3]. Cette\r\nproposition, admet-elle une r'eciproque, c'est-`a-dire, <em><span\r\nclass=\"math inline\">\\(E\\)</span> 'etant un ensemble compl'ementaire `a\r\nun ensemble (<span class=\"math inline\">\\(A\\)</span>) et <span\r\nclass=\"math inline\">\\(H\\)</span> ------ un ensemble (<span\r\nclass=\"math inline\">\\(A\\)</span>), tel que <span class=\"math inline\">\\(E\r\n\\subset H\\)</span>, existe-til tujours un ensemble <span\r\nclass=\"math inline\">\\(Q\\)</span> mesurable (<span\r\nclass=\"math inline\">\\(B\\)</span>), tel que <span class=\"math inline\">\\(E\r\n\\subset Q \\subset H\\)</span>?</em></li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpi'nski.</p>\r\n<p>[^3] Voir p. e. N. Lusin et W. Sierpi'nski <em>Journ. de Math.</em>\r\nt. II (1923) p. 60; aussi <em>Bull. Acad. Cracovie</em> 1918 p. 40.</p>\r\n<ol start=\"37\" type=\"1\">\r\n<li>Un continu de Jordan (born'e) qui ne renferme qucune courbe simple\r\nferm'ee est-il hom'eomorphe `a un de ses (vrais) sous-continus?</li>\r\n</ol>\r\n<p>Probl'eme de M. Zarankiewicz.</p>\r\n<ol start=\"38\" type=\"1\">\r\n<li>Un carr'e et un cercle dont les aires sont 'egales peuvent-ils ^etre\r\nd'ecompos'es en un nombre fini de sous-ensembles disjoints repectivement\r\ncongruents?</li>\r\n</ol>\r\n<p>Probl'eme de M. Tarski.</p>\r\n<ol start=\"39\" type=\"1\">\r\n<li>Existe-il un ensemble ferm'e <em>plan</em> pour lequel l'ensemble\r\ndes points lin'eairement accessibles soit non-mesurable (<span\r\nclass=\"math inline\">\\(B\\)</span>)? (Dans l'espace le probl'eme est\r\nr'esolu par affirmative).</li>\r\n</ol>\r\n<p>Probl'eme de M. O. Nikodym.</p>\r\n<ol start=\"40\" type=\"1\">\r\n<li><span class=\"math inline\">\\(E\\)</span> 'etant un ensemble plan <span\r\nclass=\"math inline\">\\(G_{\\delta}\\)</span>, l'ensemble de tous les\r\nnombres r'eels <span class=\"math inline\">\\(a\\)</span>, tels que la\r\ndroite <span class=\"math inline\">\\(x =a\\)</span> rencontre l'ensemble\r\n<span class=\"math inline\">\\(E\\)</span> dans un et un seul point, est-il\r\nn'ecessairement compl'ementaire d'un ensemble (<span\r\nclass=\"math inline\">\\(A\\)</span>) de M. Souslin?</li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpi'nski.</p>\r\n<ol start=\"41\" type=\"1\">\r\n<li><span class=\"math inline\">\\(E_{1}, E_{2}, E_{3}, \\dots\\)</span>\r\n'etant une suite d'enombrable d'ensembles lin'eaires dont chacun est une\r\nprojection d;un ensemble plan compl'ementaire `a un ensemble (<span\r\nclass=\"math inline\">\\(A\\)</span>) de M. Souslin, l'ensemble $E_{1}E_{2}\r\nE_{3} $ est il de m^eme nature?</li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpi'nski.</p>\r\n<ol start=\"42\" type=\"1\">\r\n<li>Existe-t-il dans tout continu <span class=\"math inline\">\\(A\\)</span>\r\nun continu <span class=\"math inline\">\\(B\\)</span> tel que l'ensemble\r\n<span class=\"math inline\">\\(A-B\\)</span> soit connexe?</li>\r\n</ol>\r\n<p>Probl'eme de MM. Knaster et Zarankiewicz.</p>\r\n<ol start=\"43\" type=\"1\">\r\n<li><span class=\"math inline\">\\(D\\)</span> d'esignant un ensemble ferm'e\r\nhom'eomorphe d'un ensemble plan et situ'e dans l'espace euclidien `a 3\r\ndimensions, est-ce que tout point de <span\r\nclass=\"math inline\">\\(D\\)</span> est <em>accessible</em> dans cet\r\nespace?</li>\r\n</ol>\r\n<p>(Un point <span class=\"math inline\">\\(d\\)</span> de <span\r\nclass=\"math inline\">\\(D\\)</span> est dit <em>accessible</em> dans <span\r\nclass=\"math inline\">\\(E\\)</span>, lorsqu'il existe un continu <span\r\nclass=\"math inline\">\\(C \\subset E\\)</span> tel que <span\r\nclass=\"math inline\">\\((d) = CD\\)</span>).</p>\r\n<p>Probl'eme de M. Knaster.</p>\r\n<ol start=\"46\" type=\"1\">\r\n<li>Es wird gefragt die logischen Relationen zwischen den verschiedenen\r\nHomogenit\"atsbegriffen aufzutellen, insoweit sie sich beziehen auf im\r\nkleinen kompakten Mengen. Insbesondere auch wenn die Mengen als\r\nausammenh\"angend und (oder) im kleinen zusammenh\"angend vorausgesetzt\r\nwerden.</li>\r\n</ol>\r\n<p>(Vgl. D. van Dantzig, \"ber topologisch homogene Kontinua, dieser\r\nBand, S. 102, 103).</p>\r\n<p>Probl'eme de M. van Dantzig.</p>\r\n<ol start=\"47\" type=\"1\">\r\n<li>Ist eine jed (zusammenh\"angende, unberandete) <span\r\nclass=\"math inline\">\\(n\\)</span>-dimensionale Mannigfaltigkeit\r\ninvolutorisch homogen?</li>\r\n</ol>\r\n<p>(Vgl. D. van Dantzig, l. e. S. 104, ^7.)</p>\r\n<p>Probl'eme de M. van Dantzig.</p>\r\n<ol start=\"48\" type=\"1\">\r\n<li>Nennen wir eine topologische Gruppe <em>monothetisch</em>, falls\r\neine unendliche zyklische Gruppe in ihr dicht liegt (in welchem Falle\r\nsie kommutativ ist und additiv geschrieben weden kann), und\r\n<em>komplett</em>, falls eine jede Folge <span\r\nclass=\"math inline\">\\(x_{\\nu}\\)</span>, die dem Konvergenzkriterium\r\nCauchy's <span class=\"math inline\">\\(\\lim (x_{\\nu} - x_{\\mu} =\r\n0\\)</span> gen\"ugt, ein Limeselement in der Gruppe besitzt, so wird\r\ngefragt, ob eine monothetische Gruppe komplett sein kann ohne kompakt zu\r\nsein.</li>\r\n</ol>\r\n<p>(Vgl. l. c. S. 116 ^{29}a))</p>\r\n<p>Probl'eme de M. van Dantzig.</p>\r\n<ol start=\"49\" type=\"1\">\r\n<li>Soient <span class=\"math inline\">\\(X\\)</span> et <span\r\nclass=\"math inline\">\\(Y\\)</span> deux continus P'eaniens (= images\r\ncontinues de l'intervalle) et <span class=\"math inline\">\\(Z\\)</span>\r\nleur produit topologique (= l'espace de tous les couples <span\r\nclass=\"math inline\">\\(z = (x,y)\\)</span> o'u <span\r\nclass=\"math inline\">\\(\\lim z_{n}=z\\)</span> lorsque <span\r\nclass=\"math inline\">\\(\\lim x_{n} = x\\)</span> et <span\r\nclass=\"math inline\">\\(\\lim y_{n} = y\\)</span>).</li>\r\n</ol>\r\n<p>1^0. Si le continu <span class=\"math inline\">\\(X\\)</span>, ainsi que\r\n<span class=\"math inline\">\\(Y\\)</span>, poss'ede la propri'et'e que dans\r\nchaque transformation continue de ce continu en un sous-ensemble il\r\nexiste un point invariant, est-il vrai que <span\r\nclass=\"math inline\">\\(Z\\)</span> poss'ede la m^eme propri'et'e?</p>\r\n<p>2^0. Si le continu <span class=\"math inline\">\\(X\\)</span>, ainsi que\r\n<span class=\"math inline\">\\(Y\\)</span>, est uni-coh'erent (= dans chaque\r\nd'ecomposition de ce continu en deus sous-continus la partie commune de\r\nces sous-continus est connexe), est-il vrai que <span\r\nclass=\"math inline\">\\(Z\\)</span> est unicoh'erent?</p>\r\n<p>Probl'eme de M. Kuratowski.</p>\r\n<ol start=\"50\" type=\"1\">\r\n<li>Ist der topologische Kreis die einzige homogene im kleinen\r\nzusammenh\"angende Kurve? (Kurve = eindimensionaler zusammen-h\"angender\r\nkompakter Raum. Homogen hei<span class=\"math inline\">\\(\\beta\\)</span>t\r\nein Raum, der zu je zwei seiner Punkte <span\r\nclass=\"math inline\">\\(p\\)</span> und <span\r\nclass=\"math inline\">\\(q\\)</span> eine topologische Selbstabbildung\r\nbesitzt die <span class=\"math inline\">\\(p\\)</span> in <span\r\nclass=\"math inline\">\\(q\\)</span> \"uberf\"uhrt). In der Ebene ist der\r\nKreis die einzige homogene im kleinen zusammenh\"angende Kurve.</li>\r\n</ol>\r\n<p>(Vgl. Mazurkiewicz, Fund. Math. V, S. 137).</p>\r\n<p>Probl'eme de M. K. Menger.</p>\r\n<ol start=\"51\" type=\"1\">\r\n<li>Gibt es beliebig oder gar unendlich viele kompakte eindimensionale\r\nR\"aume, die zu je zweien eindimentional unvergleichbar sind? Dabei\r\nm\"ogen zwei R\"aume <span class=\"math inline\">\\(R\\)</span> und <span\r\nclass=\"math inline\">\\(R^{\\prime}\\)</span> eindimentional unvergleichbar\r\nhei<span class=\"math inline\">\\(\\beta\\)</span>en, wenn keine\r\neindimensionale Teilmenge von <span class=\"math inline\">\\(R\\)</span>,\r\n(bzw. von <span class=\"math inline\">\\(R^{\\prime}\\)</span>) hom\"oomorph\r\nist mit einer Teilmenge von <span\r\nclass=\"math inline\">\\(R^{\\prime}\\)</span> (bzw. von <span\r\nclass=\"math inline\">\\(R^{\\prime}\\)</span>). Beispielsweise sind\r\neindimensional unvergleichbar eine Strecke und ein Kontinuum ohne\r\nTeilbogen. (Wenn es <span class=\"math inline\">\\(n\\)</span>, bzw. <span\r\nclass=\"math inline\">\\(\\aleph_{0}\\)</span> paarweise eindimensional\r\nunvergleichbare Kurven gibt, so existieren kompakte eindimensionale\r\nR\"aume, welche mindestens <span class=\"math inline\">\\(2^{n} +1\\)</span>,\r\nbze. <span class=\"math inline\">\\(2^{\\aleph_{0}}\\)</span> monotone, <span\r\nclass=\"math inline\">\\(F_{\\sigma}\\)</span>-additive, toppologische,\r\nkompaktifizierbare Systeme von Teilmengen enthalten).</li>\r\n</ol>\r\n<p>(Vgl. Monatshefte f. Math. u. Phys. 36, S. 207).</p>\r\n<p>Probl'eme de M. K. Menger.</p>\r\n<ol start=\"52\" type=\"1\">\r\n<li>Existe-il un continu dont tout autre continu soit une image\r\ncontinue?</li>\r\n</ol>\r\n<p>Probl'eme de M. H. Hahn.</p>\r\n<ol start=\"53\" type=\"1\">\r\n<li><ol type=\"a\">\r\n<li>Ist jeder absolute Retrakt in endlich viele absolute Retrakte mit\r\nbeliebig kleinen Durchmessern zerlegbar?</li>\r\n</ol></li>\r\n</ol>\r\n<ol start=\"2\" type=\"a\">\r\n<li>Lasst sieh jede <span class=\"math inline\">\\(R\\)</span>-Menge in\r\nendlich viele absolu#e Retrakte zerlegen?</li>\r\n</ol>\r\n<p>(Die Definition von absoluten Retrakten und von <span\r\nclass=\"math inline\">\\(R\\)</span>-Mengen ist z. B. in meiner Note aus\r\nFund. Math. XIX, S. 222 angegeben).</p>\r\n<ol start=\"54\" type=\"1\">\r\n<li><p>Ist jedes Teilkontinuum <span class=\"math inline\">\\(C\\)</span>\r\ndes eaklidieelien <span class=\"math inline\">\\(n\\)</span>-dimensionalen\r\nRaumes <span class=\"math inline\">\\(R_{n}\\)</span>, welches <span\r\nclass=\"math inline\">\\(R_{n}\\)</span> zerschneidet und welches eich durch\r\nbeliebig kleine Transformationen (d. h. durch eine stetige Abbildung,\r\nwelehe jeden Punkt von <span class=\"math inline\">\\(C\\)</span> in einen\r\nbeliebig nahe liegenden Punkt von <span\r\nclass=\"math inline\">\\(R_{n}\\)</span> tiberfiibrt) in eine mit ihm\r\npunktfremde Teilmenge von R. \"uberf\"uhren lasst, eine (<span\r\nclass=\"math inline\">\\(n-1\\)</span>)-dimensionale\r\nMannigfaltigkeit?</p></li>\r\n<li><p>L\"asst sich jedes in <span class=\"math inline\">\\(R_{3}\\)</span>\r\nliegende und <span class=\"math inline\">\\(R_{3}\\)</span> zerschneidende\r\nStreckenbild in eich stetig und fixpunktfrei abbilden?</p></li>\r\n</ol>\r\n<p>Probl'emes de M. K. Borsuk.</p>\r\n<ol start=\"58\" type=\"1\">\r\n<li>Soient <span class=\"math inline\">\\(A\\)</span> et <span\r\nclass=\"math inline\">\\(B\\)</span> deux espaces topologiques et <span\r\nclass=\"math inline\">\\(A^{2}\\)</span> et <span\r\nclass=\"math inline\">\\(B^{2}\\)</span> respectivement leur carr'es (a. `a.\r\nd. <span class=\"math inline\">\\(A^{2}\\)</span> p. ex. se compose de tous\r\ntes couples (<span class=\"math inline\">\\(a_{1}\\)</span>, <span\r\nclass=\"math inline\">\\(a_{2}\\)</span>) extraite de <span\r\nclass=\"math inline\">\\(A\\)</span>).</li>\r\n</ol>\r\n<p>Est-il vrai que si <span class=\"math inline\">\\(A^{2}\\)</span> et\r\n<span class=\"math inline\">\\(B^{2}\\)</span> sont hom'eomorphes. <span\r\nclass=\"math inline\">\\(A\\)</span> et <span\r\nclass=\"math inline\">\\(B\\)</span> le sont aussi?</p>\r\n<p>En ess de relronae positire, on en d'eduit que, <span\r\nclass=\"math inline\">\\(C\\)</span> 'etant un ensemble qui n'est\r\nhom'eomorphe `a aucun, <span class=\"math inline\">\\(C^{n}\\)</span>, <span\r\nclass=\"math inline\">\\(n&gt;1\\)</span>, les ensembles <span\r\nclass=\"math inline\">\\(C^{m}\\)</span> et <span\r\nclass=\"math inline\">\\(C^{n}\\)</span> ne sont non plus hom'eomorphes pour\r\n<span class=\"math inline\">\\(m\\neq n\\)</span>; cela fournit dans le eas\r\no`u <span class=\"math inline\">\\(C\\)</span> est un intervalle 1e\r\nth'eor'eme de \"l'invariance de la dimension\" de M. Brouwer.</p>\r\n<p>Probl'eme de M. S. Ulam.</p>\r\n<ol start=\"57\" type=\"1\">\r\n<li>Existe-il un continu de dimension infinie qui n'en contient aucun de\r\ndimension finie?</li>\r\n</ol>\r\n<p>Probl'eme de M. S. Mazurkiewicz.</p>\r\n<ol start=\"58\" type=\"1\">\r\n<li>Gibt es in einer Menge <span class=\"math inline\">\\(E\\)</span> von\r\nder M\"achtigkeit <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ein\r\nabz\"ahlbares System von Teilmengen <span class=\"math inline\">\\(A_{1},\r\nA_{2},\\dots\\)</span> derart, dass man in der Gestalt <span\r\nclass=\"math display\">\\[X = \\overline{\\lim} A_{p_{n}}\\]</span> (<span\r\nclass=\"math inline\">\\(p_{1}, p_{2},,\\dots\\)</span> Teilfolge der\r\nnat\"urlichen Zahlen, <span\r\nclass=\"math inline\">\\(\\overline{\\lim}\\)</span> bedeutet dag Barel-sche\r\n<em>ensemble limite complet</em>) alle Teilmengen <span\r\nclass=\"math inline\">\\(X\\)</span> von <span\r\nclass=\"math inline\">\\(E\\)</span> erh\"alt?</li>\r\n</ol>\r\n<p>(Es handelt sich, die Verneinung ohne Benutzung der\r\nKontinuumhypethese zu beweisen).</p>\r\n<p>Probl'me de M. F. Hausdorff.</p>\r\n<ol start=\"59\" type=\"1\">\r\n<li>Une fonction jouissant de la propri'et'e de Baire (c'est-`a-dire\r\ncontinue sur tout ensemble parfait, lorsqu'on n'eglige un ensemble de\r\n<span class=\"math inline\">\\(1^{re}\\)</span> cat'egorie relativement `a\r\ncet ensemble) d'une fonction jouiseant de la propri'et'e de Baire,\r\nest-elle de la m^eme nature?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpi'nski.</p>\r\n<ol start=\"60\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(\\rho\\)</span> l'ensemble de toutes\r\nles transformations hom'eomorphes du plan cart'esien en lui-m^eme, de la\r\nforme: <span class=\"math display\">\\[x^{\\prime} = x, \\quad y^{\\prime}\r\n=f(x,y)\\]</span> et <span class=\"math display\">\\[x^{\\prime}=g(x,y),\r\n\\quad  y^{\\prime}=y.\\]</span></li>\r\n</ol>\r\n<p>D'esignons par <span class=\"math inline\">\\(\\sigma\\)</span> le groupe\r\nform'e par toutes les superpositions finies de toutes les\r\ntransformations appartenant `a <span\r\nclass=\"math inline\">\\(\\rho\\)</span>. Une transformation hom'eomorphe\r\narbitraire du plan en lui-m^eme se laisse-telle toujours approcher par\r\ncelles du groupe <span class=\"math inline\">\\(\\sigma\\)</span>?</p>\r\n<p>Un probl'eme analogue subsiste pour les espaces `a <span\r\nclass=\"math inline\">\\(n&gt;2\\)</span> dimensions. Probl'eme de M. S.\r\nUlam.</p>\r\n<ol start=\"61\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(E\\)</span> un ensemble plan <span\r\nclass=\"math inline\">\\(G_{\\delta}\\)</span> (plus g'en'eralement: un\r\nensemble borelien) dont tontes les intersections avec les droites\r\nparall'eles `a l'axe des <span class=\"math inline\">\\(y\\)</span> sont des\r\nensembles ferm'es (plus g'en'eralement: des <span\r\nclass=\"math inline\">\\(F_{\\sigma}\\)</span>). La projection de <span\r\nclass=\"math inline\">\\(E\\)</span> sur l'axe des <span\r\nclass=\"math inline\">\\(x\\)</span> est-elle toujours un ensemble\r\nborelien?</li>\r\n</ol>\r\n<p>Probl'eme de M. E. Szpilrajsn.</p>\r\n<ol start=\"62\" type=\"1\">\r\n<li>Die (reelle) Funktion <span class=\"math inline\">\\(f(x)\\)</span> der\r\nreellen Variablen <span class=\"math inline\">\\(x\\)</span> heisse\r\n<em>symmetrisch-stetig</em> wenn f\"ur jedes <span\r\nclass=\"math inline\">\\(x\\)</span> <span\r\nclass=\"math display\">\\[\\lim\\limits_{h \\to 0} [f(x+h) - f(x - h)] =\r\nO.\\]</span> Kann die Menge der Unstetigkeitsstellen einer solchen\r\nFunktion unabz\"ahlbar sein? Kann sie eine beliebig vorgeschriebene Menge\r\n<span class=\"math inline\">\\(F_{\\sigma}\\)</span> sei? (Dass sie eine\r\nbeliebig vorgeschriebene abz\"ahlbare Menge sein kann, ist leicht\r\neinzusehen.)</li>\r\n</ol>\r\n<p>Probl'eme de M. F. Hausdorff.</p>\r\n<ol start=\"63\" type=\"1\">\r\n<li>Deux espaces compacts <span class=\"math inline\">\\(A\\)</span> et\r\n<span class=\"math inline\">\\(B\\)</span> ont le <em>m^eme type\r\nd'homotopie</em>, lorsqu'il existe une transformation continue <span\r\nclass=\"math inline\">\\(f\\)</span> de <span\r\nclass=\"math inline\">\\(A\\)</span> en <span\r\nclass=\"math inline\">\\(B\\)</span> et une transformation continue <span\r\nclass=\"math inline\">\\(f\\)</span> de <span\r\nclass=\"math inline\">\\(A\\)</span> en <span\r\nclass=\"math inline\">\\(B\\)</span> et une transformation continue <span\r\nclass=\"math inline\">\\(\\varphi\\)</span> de <span\r\nclass=\"math inline\">\\(B\\)</span> en <span\r\nclass=\"math inline\">\\(A\\)</span>, telles que les transformations\r\nsuperpos'ees <span class=\"math inline\">\\(\\varphi f\\)</span> et <span\r\nclass=\"math inline\">\\(f\\varphi\\)</span> (consid'er'ees respectivement\r\ncomme des trans-formations de <span class=\"math inline\">\\(A\\)</span> en\r\n<span class=\"math inline\">\\(A\\)</span> et de <span\r\nclass=\"math inline\">\\(B\\)</span> en <span\r\nclass=\"math inline\">\\(B\\)</span>) soient homotopes `a l'identit'e. Deux\r\nvari'et'es ferm'ees de m^eme type d'homotopie sont-elles toujours\r\nhom'eomorphes?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Hurewicz.</p>\r\n<ol start=\"64\" type=\"1\">\r\n<li><p>Gibt es im <span class=\"math inline\">\\(R^{n}\\)</span> zwei\r\norientierbare Mannigfaltigkeiten <span\r\nclass=\"math inline\">\\(M_{1}^{k}\\)</span> und <span\r\nclass=\"math inline\">\\(M_{2}^{k}\\)</span>, deren Komplement\"arr\"aume\r\n<span class=\"math inline\">\\(R^{n} - M_{1}^{k}\\)</span> und <span\r\nclass=\"math inline\">\\(R^{n} - M_{2}^{k}\\)</span> hom\"oomorph und deren\r\nHomologieringe nicht isomorph sind?</p></li>\r\n<li><p>Soient <span class=\"math inline\">\\(B_{0}, B_{1}, B_{2}, \\dots,\r\nB_{\\omega}, \\dots, B_{\\alpha}, \\dots\\)</span> des classes boreliennes\r\nd'ensembles, form'ees en partant d'une classe quelconque d'ensembles\r\nabstraits. On sait que <span class=\"math inline\">\\(B_{\\alpha} =\r\nB_{\\alpha+}\\)</span>. entra^ine <span class=\"math inline\">\\(B_{\\alpha}=\r\nB_{\\beta}\\)</span> pour tout <span\r\nclass=\"math inline\">\\(\\beta&gt;\\alpha\\)</span>; soit <span\r\nclass=\"math inline\">\\(\\alpha_{0}\\)</span> le premier nombre <span\r\nclass=\"math inline\">\\(\\alpha\\)</span> satisfaisant `a cette condition.\r\nQuels sont les nombres <span class=\"math inline\">\\(v\\)</span> pour\r\nlesquels il existe des classes <span\r\nclass=\"math inline\">\\(B_{0}\\)</span> telles que l'on ait <span\r\nclass=\"math inline\">\\(\\alpha_{0} = v\\)</span>? (Cf. Fund. Math. t. XV,\r\np. 284).</p></li>\r\n</ol>\r\n<p>Probl'emes de M. A. Ko1mogoroff.</p>\r\n<ol start=\"66\" type=\"1\">\r\n<li>La propri'et'e <span class=\"math inline\">\\(LC\\)</span>\r\n<em>faible</em> entra^ine-t-elle la propri'et'e <span\r\nclass=\"math inline\">\\(LC\\)</span> forte pour tout espace m'etrique\r\ncompact? M^eme question pour les pro-pri'et'es <span\r\nclass=\"math inline\">\\(HLC\\)</span>. (Pour les d'efinitions voir Anaals\r\nof Mathematics, vol. 85, p. 119-129 et Duke Mathematical Journal, vol.\r\n1, p. 1-18).</li>\r\n</ol>\r\n<p>Probl'eme de M. S. Lefschetz.</p>\r\n<ol start=\"67\" type=\"1\">\r\n<li>La propri'et'e (<span class=\"math inline\">\\(C\\)</span>) des\r\nensembles lin'eaires est elle invariante par rapport aux transformations\r\nhom'eomorphes et, plus g'en'erale-ment, par rapport aux transformations\r\ncontinues? (On dit qu'un ensemble <span class=\"math inline\">\\(E\\)</span>\r\nposs'ede la <em>propri'et'e</em> (<span\r\nclass=\"math inline\">\\(C\\)</span>), lorsqu'il existe pour chaque suite\r\n<span class=\"math inline\">\\(\\{a_{n}\\}\\)</span> de nombres positifs une\r\nd'ecomposition $E=E_{1}+E_{2} + $ telle que le diam'etre de <span\r\nclass=\"math inline\">\\(E_{n}\\)</span> ne d'epasse pas <span\r\nclass=\"math inline\">\\(a_{n}\\)</span> pour <span\r\nclass=\"math inline\">\\(n=1, 2,\\dots\\)</span>. Cf. Fund. Math, t. XI, p.\r\n304; t. XV, p. 126; t. XXII, p. 310.)</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpi'nski.</p>\r\n<ol start=\"68\" type=\"1\">\r\n<li>Tai et <span class=\"math inline\">\\(E_{1}\\)</span> 'etant deux\r\nensembles lin'eaires toujours de premi'ere cat'egorie (c. `a d. de\r\npremi'ere cat'egorie sur tout ensemble parfait), l'ensemble <span\r\nclass=\"math inline\">\\(E_{1} \\times E_{2}\\)</span>. (c. `a d. l'ensemble\r\nde tous les points <span class=\"math inline\">\\((x, y)\\)</span> du plan\r\no'u <span class=\"math inline\">\\(x \\in E_{1}\\)</span> et <span\r\nclass=\"math inline\">\\(y \\in E_{2}\\)</span>) est-il de m^eme nature?</li>\r\n</ol>\r\n<p>Probl'eme de M. E. Szpilrajn.</p>\r\n<ol start=\"69\" type=\"1\">\r\n<li>Lorsqu'une conrbe de Jordan (dans un espace `a trois dimensions)\r\nposs'ede en chaque point une tangente d'etermin'ee, existe-t-il\r\nn'ecessairement une reprparam'etrique de cette courbe exprimant les\r\ncoordonn'ees cart'esiennes d'un point de cette courbe comme fonctions\r\nd'erivables d'un param'etre (et cela sans que les trois d'erive'ees\r\ns'annulent en m^eme temps)?</li>\r\n</ol>\r\n<p>En cas de r'epinse n'egative, la question est repos'ee en admenttant\r\nun ensemble de mesure nulle de valeues du param'etre o'u les conditions\r\nimpos'ees ne sont pas toutes deux v'erifi'ees.</p>\r\n<p>Probl'eme de M. M. Fr'echet.</p>\r\n<ol start=\"70\" type=\"1\">\r\n<li>Existe-t-il un ensemble lin'eaire <span\r\nclass=\"math inline\">\\(E\\)</span> tel que chaque ensemmble analytique\r\nlin'eaire est une image biunivoque et continue (dans un sens) de <span\r\nclass=\"math inline\">\\(E\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpi'nski.</p>\r\n<ol start=\"71\" type=\"1\">\r\n<li>Existe-t-il une suite infinie <span class=\"math inline\">\\(S\\)</span>\r\nde fonctions d'une variable r'eelle (mesurables ou non), telle que toute\r\nfonction d'une variable r'eelle dde classe <span\r\nclass=\"math inline\">\\(2\\)</span> Baire soit limite d'une suit extraite\r\nde <span class=\"math inline\">\\(S\\)</span>?</li>\r\n</ol>\r\n<p>(D'apr'es M. C. Burstin une telle suite <span\r\nclass=\"math inline\">\\(S\\)</span> ne peut ^etre compos'ee uniquement de\r\nfonctions mesurables[^4])</p>\r\n<p>Probl'eme de M. W. Sierpi'nski.</p>\r\n<p>[^4] Monatshefte f. Math. u. Phys. 28 (1917), p. 107.</p>\r\n<ol start=\"72\" type=\"1\">\r\n<li>Existe-t-il dans l'espace cart'esien `a <span\r\nclass=\"math inline\">\\(n\\)</span> dimensions (<span\r\nclass=\"math inline\">\\(n&gt;1\\)</span>) un ensemble toujours de premi'ere\r\ncat'egorie (c. `a d. de premi'ere cat'egorie sur chaque ensemble\r\nparfait) et qui soit de dimension positive?</li>\r\n</ol>\r\n<p>(M. W. Hurewicz a d'emontr'e `a l'aide de l'hypoth'ese du continu\r\nqu'il existe dans l'espace de Hilbert un ensemble ind'enombrable <span\r\nclass=\"math inline\">\\(H\\)</span> dont chaque sous-ensemble\r\nind'enombrable est de dimension infinie[^5]). M. F. Hausdorff a\r\nremarqu'e l'ensemble <span class=\"math inline\">\\(H\\)</span> est toujours\r\nde premi'ere cat'egorie. Cela r'esulte ais'ement du fait que chaque\r\nespace m'etrique s'eparable <span class=\"math inline\">\\(M\\)</span> est\r\nsomme d'un ensemble de dimension <span class=\"math inline\">\\(0\\)</span>\r\net d'un ensemble de premi'ere cat'egorie dans <span\r\nclass=\"math inline\">\\(M\\)</span>. -- <em>Il existe donc, so <span\r\nclass=\"math inline\">\\(2^{\\aleph} = \\aleph_{1}\\)</span>, dons l'espace de\r\nHilbert un ensemble toujours de premi'erie cat'egorie et de dimension\r\npositive</em>).</p>\r\n<p>Probl'eme de M. E. Szpilrajn.</p>\r\n<p>[^5] Fund. Math. 19 (1932), p.8.</p>\r\n<ol start=\"73\" type=\"1\">\r\n<li>Soient, dans l'espace euclidien `a trois dimensions, <span\r\nclass=\"math inline\">\\(E\\)</span> une image hom'eomorphe de la sph'ere\r\nsolide <span class=\"math inline\">\\(S\\)</span> et <span\r\nclass=\"math inline\">\\(L\\)</span> un segment rectiligne dont l'int'erieur\r\nest contenu dans l'int'erieur, et les extr'emeit'es dans la fronti'ere\r\nde <span class=\"math inline\">\\(E\\)</span>. Existe-t-il toujours une\r\nhom'eomorphie transformant <span class=\"math inline\">\\(E\\)</span> en\r\n<span class=\"math inline\">\\(S\\)</span> de facon que <span\r\nclass=\"math inline\">\\(L\\)</span> soit transorm'e en diam'etre de <span\r\nclass=\"math inline\">\\(S\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. K. Borsuk.</p>\r\n<ol start=\"74\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(\\mathbf{B}(\\mathbf{F})\\)</span> la\r\nplus petite famille d'ensembles contenant la famille donn'ee <span\r\nclass=\"math inline\">\\(\\mathbf{F}\\)</span> et close par rapoort aux\r\nop'erations <span class=\"math inline\">\\(\\sigma\\)</span> et <span\r\nclass=\"math inline\">\\(\\delta\\)</span> (addition et multiplication\r\nd'enombrables). Existe-t-il une famille d'enombrable <span\r\nclass=\"math inline\">\\(\\mathbf{D}\\)</span> d'ensembles, telle que tous\r\nles ensembles analytiques lin'eaires appartiennent `a <span\r\nclass=\"math inline\">\\(\\mathbf{B}(\\mathbf{D})\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. S. Ulam.</p>\r\n<ol start=\"75\" type=\"1\">\r\n<li>Existe-t-il un ensemble infini <span\r\nclass=\"math inline\">\\(E\\)</span> (p.e. l'ensemble de tous les nombres\r\nnaturels) et une fonction <span class=\"math inline\">\\(f(X)\\)</span> qui\r\nfait correspondre `a tout sous-ensemble <span\r\nclass=\"math inline\">\\(X\\)</span> de <span\r\nclass=\"math inline\">\\(E\\)</span> un sous-ensemble <span\r\nclass=\"math inline\">\\(f(X)\\)</span> de <span\r\nclass=\"math inline\">\\(E\\)</span>, de sorte que:</li>\r\n</ol>\r\n<p>1<span class=\"math inline\">\\(^\\circ\\)</span> <span\r\nclass=\"math inline\">\\(X \\subset f(X)\\)</span> pour <span\r\nclass=\"math inline\">\\(X \\subset E\\)</span>, 2<span\r\nclass=\"math inline\">\\(^\\circ\\)</span> <span class=\"math inline\">\\(f(X+Y)\r\n= f(X) + f(Y)\\)</span> pour <span class=\"math inline\">\\(X \\subset\r\nE\\)</span>, <span class=\"math inline\">\\(Y \\subset E\\)</span>, 3<span\r\nclass=\"math inline\">\\(^\\circ\\)</span> il existe pour tout ensemble <span\r\nclass=\"math inline\">\\(Y \\subset E\\)</span> au moins un ensemble <span\r\nclass=\"math inline\">\\(X \\subset E\\)</span>, tel que <span\r\nclass=\"math inline\">\\(Y = f(X)\\)</span>, 4<span\r\nclass=\"math inline\">\\(^\\circ\\)</span> il existe au moins un ensemble\r\n<span class=\"math inline\">\\(X_{0} \\subset E\\)</span>, tel que <span\r\nclass=\"math inline\">\\(f(X_{0}) \\neq X_{0}\\)</span>.</p>\r\n<p>Si l'on remplace la condition relative `a <span\r\nclass=\"math inline\">\\(f(X+Y)\\)</span> par la condition plus faible que\r\n<span class=\"math inline\">\\(f(X) \\subset f(Y)\\)</span> pur <span\r\nclass=\"math inline\">\\(X \\subset Y \\subset E\\)</span>, la r'eponse\r\npositive est 'evidente.</p>\r\n<p>Probl'eme de M. E. ech.</p>\r\n<h2 id=\"problemes-rsolus.\">Probl'emes r'solus.</h2>\r\n<p>Probl. 1) Lorsque un ensemble de points <span\r\nclass=\"math inline\">\\(P\\)</span> est une image biunvoque et continue\r\n(dans un sens) de <span class=\"math inline\">\\(Q\\)</span> et <span\r\nclass=\"math inline\">\\(Q\\)</span> est une image biunivoque et continue de\r\n<span class=\"math inline\">\\(P\\)</span>, peut-on affirmer que les\r\nensembles <span class=\"math inline\">\\(P\\)</span> et <span\r\nclass=\"math inline\">\\(Q\\)</span> sont hom'eomorphes?</p>\r\n<p>Solution <em>n'egative</em> de M. Kuratowski, <em>Fund. Math.</em> t.\r\nII, pp. 158-160</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>Existe-il une d'ecomposition d'un intervalle en <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles mesurables (<span\r\nclass=\"math inline\">\\(B\\)</span>), non-vides et sans points communs deux\r\n`a deux?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de MM. Lusin et Sierpinski, <em>Comptes\r\nRendus</em>, t. 175, p.357 (note du 21 ao^ut 1922).</p>\r\n<p>6, troisi'eme partie) Peut-on d'emontrer qu'un produit de <span\r\nclass=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles (<span\r\nclass=\"math inline\">\\(A\\)</span>) n'est pas n'ecessairement un ensemble\r\n(<span class=\"math inline\">\\(A\\)</span>)?</p>\r\n<p>Solution <em>affirmative</em> de MM. Lusin et Sierpinski, <em>Journ,\r\nde Math</em>. 1923 (Les auteurs d'efinissent un ensemble qui est\r\ncompl'ementaire d'un ensemble (<span class=\"math inline\">\\(A\\)</span>)\r\nn'est pas n'ecessairement un ensemble (<span\r\nclass=\"math inline\">\\(A\\)</span>))</p>\r\n<ol start=\"8\" type=\"1\">\r\n<li>Peut-on donner un exemple effectif d'un ensemble de nombres r'eels\r\n<span class=\"math inline\">\\(E\\)</span>, tel que toute somme, toute\r\ndiff'erence, tout produit et tout quotient de deux nombres de <span\r\nclass=\"math inline\">\\(E\\)</span> (except'e la division par 0)\r\nappartienne `a <span class=\"math inline\">\\(E_{1}\\)</span> et que <span\r\nclass=\"math inline\">\\(E\\)</span> soit non-d'enombrable, distinct de\r\nl'ensemble de tous les nombres r'eels?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de M. Souslin, <em>Fund. Math.</em> IV,\r\np.311.</p>\r\n<p>10, premi'ere partie) Existe-il une fonction de deuxi'eme classe qui\r\nne soit pas la limite de fonctions preque partout discontinues?</p>\r\n<p>Solution <em>affirmative</em> de M. Zalcwasser.</p>\r\n<ol start=\"12\" type=\"1\">\r\n<li>Un ensemble ordonn'e dont tous les sous-ensembles bien ordonn'es\r\n(croissants on d'ecroissants) sont au plus d'enombraibles, a-t-il\r\nn'ecessairement une puissance non sup'erieure `a celle du continu?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de M. Urysohn, <em>Fund. Math.</em> V\r\n(h paraitre).</p>\r\n<ol start=\"15\" type=\"1\">\r\n<li>Existe-il un continu dont tout sous-continu est\r\nind'ecomposable?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de M. Knaster, <em>Fund. Math.</em> III\r\npp. 247-286.</p>\r\n<ol start=\"16\" type=\"1\">\r\n<li>Existe-il continu qui est une somme de ses vrais sous-continues\r\nsatur'es disjoints?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de M. Knaster et Kuratowski, <em>Fund.\r\nMath.</em> V (`a paraitre).</p>\r\n"},{"title":"Nevanlinna Theory (I)","date":"2023-03-27T10:40:09.000Z","mathjax":true,"_content":"\n# Elnleitung.\n\nMittels der Poisson-Jensenschen und der spezielleren Jensenschen Formel\nkann man nun den nachstehenden Satz beweisen, den wir wegen der grundlegenden Bedeutang desselben flit die ganze Theorie den ersten Hauptsatz nennen:\n\nZu jeder meromorphen Funktion $f(x)$ geh\\\"ort eine reelle Funktion $T(r)$ von folgenden Eigenschaften :\n\n\n1. $T(r)$ ist eine wachsende Funktion von $r$ and eine konvexe Funktion von $\\log r$.\n\n2. Wenn $z$ eine beliebige van $x$ unabMingige, endliche oder unendliche komplexe Zahl bezeichnet, so ist\n$$m(r;z) + N(r;z) = T(r) + O(1).$$\nDie auf der linken Seite der Beziehung (I) stehenden zwei Glieder sind\nnichtnegativ. Das erste Glied $m(r;z)$ ist der Mittelwert der Gr\\\"oe  $\\log^{+} \\left| \\frac{1}{f-z}\\right|$ auf dem Kreis $|x| = r$ und erh\\\"alt also wesentliche Boitr\\\"aige von denjenigen Bogen dieses Kreises, auf denen der Funktionenwert $f$ nahe an dem Wert $z$ liegt ; man k\\\"onnte daher sagen, da $m(r;z)$ ein bla f\\\"ur die St\\\"arke der mittleren Hfinvergenz der Funktion $f(x)$ gegen den Wert $z$ f\\\"ur $r \\to \\infty$ angibt. Das zweite Glied $N(r;z)$ bestimmt wiederum, wie dicht diejenigen Punkte liegen, in denen die Funktion den betreffenden Wert $z$ tats\\\"achlich annimmt.  Die Summe in $m(r;z) + N(r; z)$ k\\\"onnte man deshalb als die \"z-Komponente\" in der Variation der meromorpben Funktion f\\\"ur $|x| \\to \\infty$ on bezeichnen: sie charakterisiert sozusagen die St\\\"arke der Affinit\\\"at, welche die Fnnktion zn dem komplexen Wert $z$ besitzt. Der erste Haoptsatz dr\\\"uckt nnn ana, da s\\\"amtliche z-Komponenten einer meromorphen Funktion gleich stark sind; je zwei von ihnen halten einander f\\\"ur $r \\to \\infty$ im Gleichgewicht, derart da ihre Differenz f\\\"ur jedes $r$ beschr\\\"ankt ist. Diese schon an sich bemerkenswerte Symmetrieeigenschaft der meromorphen Funktionen iat f\\\"ur die ganze Theorie von fondamentaler Wichtigkeit.\n \n\n Poisson-Jensen  Jensen \n\n\n $f(x)$  $T(r)$\n\n1. $T(r)$$r$$\\log r$\n\n\n2.  $z$  $x$ \n$$m(r;z) + N(r;z) = T(r) + O(1).$$\n (I) \n  $m(r;z)$  $|x| = r $  $\\log^{+} \\left| \\frac{1}{f-z}\\right|$  Boitraige $f$  $z$ $m(r;z)$  $f(x)$  $z$  $r \\to \\infty$ $N(r; z)$ $z$ $m(r;z) + N(r;z)$  $|x| z  \\to  \\infty$ on $z$   z   $r \\to \\infty$  $r$  f\\\n\n\n\n\nDieaer zweite Hauplsatz, wie wir ihn nennen, mann in folgender Weise ausgesprochen werden:\nEs seien $f(x)$ eine beliebige meromoryhe Futiklion, $T(r)$ lie eu ihr geh\\\"orige Fundamentalgr\\\"oe und $a, b, c$ drei non eitiander zerschiedene, endliche oder unendliche komplexe Sahlen. Dann besteht die Angleichung\n$$T (r) < N(r;a) + N(r; b) + N(r; c) - N_{1}(r) - S(r), \\tag{II}$$\nwo die Glieder $N_{1}$ und $S$ folgende Bedeiiftoiy haben :\n1. $N_{1}(r)$ wird durch die multiplen Stellen der Funktion gebildet nach folgender Vorschrift:\n\nldan bilde die Anzahl $n_{1}(r)$ der mehrachen Stellen von $f(x)$ in dem Abreise $|x|<r$ in der Weise, da eine m-fache Stelle nur ($m - 1$)-mal gez\\\"ahlt wird; dann ist\n$$N_{1}(r) = \\int_{0}^{r} \\frac{n_{1}(t)}{t} dt.$$\n\n2. Das Restglied $S(f)$ gen\\\"ugt der Ungleichung\n$$S(r) < O\\left(\\log T(r)\\right)$$\nauer m\\\"oglicherweise, im Falle einer Funktion von unendliclier Ordnung, fur eine WerJmenge $r$ von endlichem Gesamtma.\n\n\n $f(x)$ $T(r)$ $abc$  \n$$T (r) < N(r;a) + N(r; b) + N(r; c) - N_{1}(r) - S(r), \\tag{II}$$\n $N_{1}$  $S$ \n1. $N_{1}(r)$\n\n$|x| < r$$f(x)$$n_{1}(r)$m$m - 1 $ ) \n$$N_{1}(r) = \\int_{0}^{r} \\frac{n_{1}(t)}{t} dt.$$\n\n2.$S(f)$\n$$S(r) < O\\left(\\log T(r)\\right)$$\n $r$\n\n\nEs sei $f(x)$ eine in der endlichen Ebene\nmeromorphe Funktion.  Bezeichnen $z_{1}, z_{2}, \\cdots, z_{q}$ untereinander verschiedene, endliche oder unendliehe Zahlen, so ist\n\n$$(q-2) T(r) <  \\sum_{\\nu =1}^{q} N(r;z_{\\nu})- N_{1}(r) + S(r)  \\tag{III}$$\n\nwo $N_{1}(r)$ in derselben Weise, wie in dent zweiten Hauptsatz (S.63), mittels der mehrfachen Stellen von $f(x)$ gebildet wird, und das Restglied $S(r)$ ebenfalls den in diesem Satze angegebenen Bedingungeu gen\\\"ugt.\n\n $f(x)$  $z_{1}, z_{2}, \\cdots, z_{q}$ \n\n$$(q-2) T(r) <  \\sum_{\\nu =1}^{q} N(r;z_{\\nu})- N_{1}(r) + S(r)  \\tag{III}$$\n\n $N_{1}(r)$  (p.63)  $f(x)$  $S(r)$ \n\n\nIn der Ungleichung (III) ist die speziellere\n\n$$(q-2) T(r) <  \\sum_{\\nu =1}^{q} \\bar{N}(r;z_{\\nu}) + S(r)  \\tag{III$^{\\prime}$}$$\n\nenthalten, wo die  Bezeichnung N(t) die auf S.63 angegebene Bedeutung hat\n\n(III)\n\n$$(q-2) T(r) <  \\sum_{\\nu =1}^{q} \\bar{N}(r;z_{\\nu}) + S(r)  \\tag{III$^{\\prime}$}$$\n\n $N(t)$  63 ","source":"_drafts/Nevanlinna Theory (German).md","raw":"---\ntitle: Nevanlinna Theory (I)\ndate: 2023-03-27 18:40:09\ntags:\n    - [Sevaral Complex Variables]\ncategories:\n    - [Sevaral Complex Variables, Nevanlinna Theory]\nmathjax: true\n---\n\n# Elnleitung.\n\nMittels der Poisson-Jensenschen und der spezielleren Jensenschen Formel\nkann man nun den nachstehenden Satz beweisen, den wir wegen der grundlegenden Bedeutang desselben flit die ganze Theorie den ersten Hauptsatz nennen:\n\nZu jeder meromorphen Funktion $f(x)$ geh\\\"ort eine reelle Funktion $T(r)$ von folgenden Eigenschaften :\n\n\n1. $T(r)$ ist eine wachsende Funktion von $r$ and eine konvexe Funktion von $\\log r$.\n\n2. Wenn $z$ eine beliebige van $x$ unabMingige, endliche oder unendliche komplexe Zahl bezeichnet, so ist\n$$m(r;z) + N(r;z) = T(r) + O(1).$$\nDie auf der linken Seite der Beziehung (I) stehenden zwei Glieder sind\nnichtnegativ. Das erste Glied $m(r;z)$ ist der Mittelwert der Gr\\\"oe  $\\log^{+} \\left| \\frac{1}{f-z}\\right|$ auf dem Kreis $|x| = r$ und erh\\\"alt also wesentliche Boitr\\\"aige von denjenigen Bogen dieses Kreises, auf denen der Funktionenwert $f$ nahe an dem Wert $z$ liegt ; man k\\\"onnte daher sagen, da $m(r;z)$ ein bla f\\\"ur die St\\\"arke der mittleren Hfinvergenz der Funktion $f(x)$ gegen den Wert $z$ f\\\"ur $r \\to \\infty$ angibt. Das zweite Glied $N(r;z)$ bestimmt wiederum, wie dicht diejenigen Punkte liegen, in denen die Funktion den betreffenden Wert $z$ tats\\\"achlich annimmt.  Die Summe in $m(r;z) + N(r; z)$ k\\\"onnte man deshalb als die \"z-Komponente\" in der Variation der meromorpben Funktion f\\\"ur $|x| \\to \\infty$ on bezeichnen: sie charakterisiert sozusagen die St\\\"arke der Affinit\\\"at, welche die Fnnktion zn dem komplexen Wert $z$ besitzt. Der erste Haoptsatz dr\\\"uckt nnn ana, da s\\\"amtliche z-Komponenten einer meromorphen Funktion gleich stark sind; je zwei von ihnen halten einander f\\\"ur $r \\to \\infty$ im Gleichgewicht, derart da ihre Differenz f\\\"ur jedes $r$ beschr\\\"ankt ist. Diese schon an sich bemerkenswerte Symmetrieeigenschaft der meromorphen Funktionen iat f\\\"ur die ganze Theorie von fondamentaler Wichtigkeit.\n \n\n Poisson-Jensen  Jensen \n\n\n $f(x)$  $T(r)$\n\n1. $T(r)$$r$$\\log r$\n\n\n2.  $z$  $x$ \n$$m(r;z) + N(r;z) = T(r) + O(1).$$\n (I) \n  $m(r;z)$  $|x| = r $  $\\log^{+} \\left| \\frac{1}{f-z}\\right|$  Boitraige $f$  $z$ $m(r;z)$  $f(x)$  $z$  $r \\to \\infty$ $N(r; z)$ $z$ $m(r;z) + N(r;z)$  $|x| z  \\to  \\infty$ on $z$   z   $r \\to \\infty$  $r$  f\\\n\n\n\n\nDieaer zweite Hauplsatz, wie wir ihn nennen, mann in folgender Weise ausgesprochen werden:\nEs seien $f(x)$ eine beliebige meromoryhe Futiklion, $T(r)$ lie eu ihr geh\\\"orige Fundamentalgr\\\"oe und $a, b, c$ drei non eitiander zerschiedene, endliche oder unendliche komplexe Sahlen. Dann besteht die Angleichung\n$$T (r) < N(r;a) + N(r; b) + N(r; c) - N_{1}(r) - S(r), \\tag{II}$$\nwo die Glieder $N_{1}$ und $S$ folgende Bedeiiftoiy haben :\n1. $N_{1}(r)$ wird durch die multiplen Stellen der Funktion gebildet nach folgender Vorschrift:\n\nldan bilde die Anzahl $n_{1}(r)$ der mehrachen Stellen von $f(x)$ in dem Abreise $|x|<r$ in der Weise, da eine m-fache Stelle nur ($m - 1$)-mal gez\\\"ahlt wird; dann ist\n$$N_{1}(r) = \\int_{0}^{r} \\frac{n_{1}(t)}{t} dt.$$\n\n2. Das Restglied $S(f)$ gen\\\"ugt der Ungleichung\n$$S(r) < O\\left(\\log T(r)\\right)$$\nauer m\\\"oglicherweise, im Falle einer Funktion von unendliclier Ordnung, fur eine WerJmenge $r$ von endlichem Gesamtma.\n\n\n $f(x)$ $T(r)$ $abc$  \n$$T (r) < N(r;a) + N(r; b) + N(r; c) - N_{1}(r) - S(r), \\tag{II}$$\n $N_{1}$  $S$ \n1. $N_{1}(r)$\n\n$|x| < r$$f(x)$$n_{1}(r)$m$m - 1 $ ) \n$$N_{1}(r) = \\int_{0}^{r} \\frac{n_{1}(t)}{t} dt.$$\n\n2.$S(f)$\n$$S(r) < O\\left(\\log T(r)\\right)$$\n $r$\n\n\nEs sei $f(x)$ eine in der endlichen Ebene\nmeromorphe Funktion.  Bezeichnen $z_{1}, z_{2}, \\cdots, z_{q}$ untereinander verschiedene, endliche oder unendliehe Zahlen, so ist\n\n$$(q-2) T(r) <  \\sum_{\\nu =1}^{q} N(r;z_{\\nu})- N_{1}(r) + S(r)  \\tag{III}$$\n\nwo $N_{1}(r)$ in derselben Weise, wie in dent zweiten Hauptsatz (S.63), mittels der mehrfachen Stellen von $f(x)$ gebildet wird, und das Restglied $S(r)$ ebenfalls den in diesem Satze angegebenen Bedingungeu gen\\\"ugt.\n\n $f(x)$  $z_{1}, z_{2}, \\cdots, z_{q}$ \n\n$$(q-2) T(r) <  \\sum_{\\nu =1}^{q} N(r;z_{\\nu})- N_{1}(r) + S(r)  \\tag{III}$$\n\n $N_{1}(r)$  (p.63)  $f(x)$  $S(r)$ \n\n\nIn der Ungleichung (III) ist die speziellere\n\n$$(q-2) T(r) <  \\sum_{\\nu =1}^{q} \\bar{N}(r;z_{\\nu}) + S(r)  \\tag{III$^{\\prime}$}$$\n\nenthalten, wo die  Bezeichnung N(t) die auf S.63 angegebene Bedeutung hat\n\n(III)\n\n$$(q-2) T(r) <  \\sum_{\\nu =1}^{q} \\bar{N}(r;z_{\\nu}) + S(r)  \\tag{III$^{\\prime}$}$$\n\n $N(t)$  63 ","slug":"Nevanlinna Theory (German)","published":0,"updated":"2023-04-27T12:46:44.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisuno0014eslr0cy04a5g","content":"<h1 id=\"elnleitung.\">Elnleitung.</h1>\r\n<p>Mittels der Poisson-Jensenschen und der spezielleren Jensenschen\r\nFormel kann man nun den nachstehenden Satz beweisen, den wir wegen der\r\ngrundlegenden Bedeutang desselben flit die ganze Theorie den ersten\r\nHauptsatz nennen:</p>\r\n<p>Zu jeder meromorphen Funktion <span\r\nclass=\"math inline\">\\(f(x)\\)</span> geh\"ort eine reelle Funktion <span\r\nclass=\"math inline\">\\(T(r)\\)</span> von folgenden Eigenschaften :</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(T(r)\\)</span> ist eine wachsende\r\nFunktion von <span class=\"math inline\">\\(r\\)</span> and eine konvexe\r\nFunktion von <span class=\"math inline\">\\(\\log r\\)</span>.</p></li>\r\n<li><p>Wenn <span class=\"math inline\">\\(z\\)</span> eine beliebige van\r\n<span class=\"math inline\">\\(x\\)</span> unabMingige, endliche oder\r\nunendliche komplexe Zahl bezeichnet, so ist <span\r\nclass=\"math display\">\\[m(r;z) + N(r;z) = T(r) + O(1).\\]</span> Die auf\r\nder linken Seite der Beziehung (I) stehenden zwei Glieder sind\r\nnichtnegativ. Das erste Glied <span\r\nclass=\"math inline\">\\(m(r;z)\\)</span> ist der Mittelwert der Gr\"oe\r\n<span class=\"math inline\">\\(\\log^{+} \\left|\r\n\\frac{1}{f-z}\\right|\\)</span> auf dem Kreis <span\r\nclass=\"math inline\">\\(|x| = r\\)</span> und erh\"alt also wesentliche\r\nBoitr\"aige von denjenigen Bogen dieses Kreises, auf denen der\r\nFunktionenwert <span class=\"math inline\">\\(f\\)</span> nahe an dem Wert\r\n<span class=\"math inline\">\\(z\\)</span> liegt ; man k\"onnte daher sagen,\r\nda <span class=\"math inline\">\\(m(r;z)\\)</span> ein bla f\"ur die\r\nSt\"arke der mittleren Hfinvergenz der Funktion <span\r\nclass=\"math inline\">\\(f(x)\\)</span> gegen den Wert <span\r\nclass=\"math inline\">\\(z\\)</span> f\"ur <span class=\"math inline\">\\(r \\to\r\n\\infty\\)</span> angibt. Das zweite Glied <span\r\nclass=\"math inline\">\\(N(r;z)\\)</span> bestimmt wiederum, wie dicht\r\ndiejenigen Punkte liegen, in denen die Funktion den betreffenden Wert\r\n<span class=\"math inline\">\\(z\\)</span> tats\"achlich annimmt. Die Summe\r\nin <span class=\"math inline\">\\(m(r;z) + N(r; z)\\)</span> k\"onnte man\r\ndeshalb als die \"z-Komponente\" in der Variation der meromorpben Funktion\r\nf\"ur <span class=\"math inline\">\\(|x| \\to \\infty\\)</span> on bezeichnen:\r\nsie charakterisiert sozusagen die St\"arke der Affinit\"at, welche die\r\nFnnktion zn dem komplexen Wert <span class=\"math inline\">\\(z\\)</span>\r\nbesitzt. Der erste Haoptsatz dr\"uckt nnn ana, da s\"amtliche\r\nz-Komponenten einer meromorphen Funktion gleich stark sind; je zwei von\r\nihnen halten einander f\"ur <span class=\"math inline\">\\(r \\to\r\n\\infty\\)</span> im Gleichgewicht, derart da ihre Differenz f\"ur jedes\r\n<span class=\"math inline\">\\(r\\)</span> beschr\"ankt ist. Diese schon an\r\nsich bemerkenswerte Symmetrieeigenschaft der meromorphen Funktionen iat\r\nf\"ur die ganze Theorie von fondamentaler Wichtigkeit.</p></li>\r\n</ol>\r\n<p> Poisson-Jensen  Jensen \r\n</p>\r\n<p> <span class=\"math inline\">\\(f(x)\\)</span>\r\n <span\r\nclass=\"math inline\">\\(T(r)\\)</span></p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(T(r)\\)</span><span\r\nclass=\"math inline\">\\(r\\)</span><span\r\nclass=\"math inline\">\\(\\log r\\)</span></p></li>\r\n<li><p> <span class=\"math inline\">\\(z\\)</span>  <span\r\nclass=\"math inline\">\\(x\\)</span>  <span\r\nclass=\"math display\">\\[m(r;z) + N(r;z) = T(r) + O(1).\\]</span>  (I)\r\n   <span class=\"math inline\">\\(m(r;z)\\)</span>\r\n $|x| = r $  <span class=\"math inline\">\\(\\log^{+} \\left|\r\n\\frac{1}{f-z}\\right|\\)</span>\r\n\r\nBoitraige <span class=\"math inline\">\\(f\\)</span>\r\n <span class=\"math inline\">\\(z\\)</span> <span\r\nclass=\"math inline\">\\(m(r;z)\\)</span>  <span\r\nclass=\"math inline\">\\(f(x)\\)</span>  <span\r\nclass=\"math inline\">\\(z\\)</span>  <span class=\"math inline\">\\(r \\to\r\n\\infty\\)</span> <span class=\"math inline\">\\(N(r; z)\\)</span>\r\n<span\r\nclass=\"math inline\">\\(z\\)</span> <span\r\nclass=\"math inline\">\\(m(r;z) + N(r;z)\\)</span>  <span\r\nclass=\"math inline\">\\(|x| z  \\to \r\n\\infty\\)</span> on <span\r\nclass=\"math inline\">\\(z\\)</span> \r\n z   <span\r\nclass=\"math inline\">\\(r \\to \\infty\\)</span>\r\n <span class=\"math inline\">\\(r\\)</span>\r\n\r\nf</p></li>\r\n</ol>\r\n<p>Dieaer zweite Hauplsatz, wie wir ihn nennen, mann in folgender Weise\r\nausgesprochen werden: Es seien <span class=\"math inline\">\\(f(x)\\)</span>\r\neine beliebige meromoryhe Futiklion, <span\r\nclass=\"math inline\">\\(T(r)\\)</span> lie eu ihr geh\"orige\r\nFundamentalgr\"oe und <span class=\"math inline\">\\(a, b, c\\)</span> drei\r\nnon eitiander zerschiedene, endliche oder unendliche komplexe Sahlen.\r\nDann besteht die Angleichung <span class=\"math display\">\\[T (r) &lt;\r\nN(r;a) + N(r; b) + N(r; c) - N_{1}(r) - S(r), \\tag{II}\\]</span> wo die\r\nGlieder <span class=\"math inline\">\\(N_{1}\\)</span> und <span\r\nclass=\"math inline\">\\(S\\)</span> folgende Bedeiiftoiy haben : 1. <span\r\nclass=\"math inline\">\\(N_{1}(r)\\)</span> wird durch die multiplen Stellen\r\nder Funktion gebildet nach folgender Vorschrift:</p>\r\n<p>ldan bilde die Anzahl <span class=\"math inline\">\\(n_{1}(r)\\)</span>\r\nder mehrachen Stellen von <span class=\"math inline\">\\(f(x)\\)</span> in\r\ndem Abreise <span class=\"math inline\">\\(|x|&lt;r\\)</span> in der Weise,\r\nda eine m-fache Stelle nur (<span class=\"math inline\">\\(m -\r\n1\\)</span>)-mal gez\"ahlt wird; dann ist <span\r\nclass=\"math display\">\\[N_{1}(r) = \\int_{0}^{r} \\frac{n_{1}(t)}{t}\r\ndt.\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Das Restglied <span class=\"math inline\">\\(S(f)\\)</span> gen\"ugt der\r\nUngleichung <span class=\"math display\">\\[S(r) &lt; O\\left(\\log\r\nT(r)\\right)\\]</span> auer m\"oglicherweise, im Falle einer Funktion von\r\nunendliclier Ordnung, fur eine WerJmenge <span\r\nclass=\"math inline\">\\(r\\)</span> von endlichem Gesamtma.</li>\r\n</ol>\r\n<p>  <span\r\nclass=\"math inline\">\\(f(x)\\)</span> <span\r\nclass=\"math inline\">\\(T(r)\\)</span> <span\r\nclass=\"math inline\">\\(abc\\)</span> \r\n <span class=\"math display\">\\[T (r) &lt; N(r;a) + N(r; b) +\r\nN(r; c) - N_{1}(r) - S(r), \\tag{II}\\]</span>  <span\r\nclass=\"math inline\">\\(N_{1}\\)</span>  <span\r\nclass=\"math inline\">\\(S\\)</span>  1. <span\r\nclass=\"math inline\">\\(N_{1}(r)\\)</span></p>\r\n<p><span class=\"math inline\">\\(|x| &lt;\r\nr\\)</span><span class=\"math inline\">\\(f(x)\\)</span><span\r\nclass=\"math inline\">\\(n_{1}(r)\\)</span>m$m - 1 $ )\r\n <span class=\"math display\">\\[N_{1}(r) = \\int_{0}^{r}\r\n\\frac{n_{1}(t)}{t} dt.\\]</span></p>\r\n<p>2.<span class=\"math inline\">\\(S(f)\\)</span> <span\r\nclass=\"math display\">\\[S(r) &lt; O\\left(\\log T(r)\\right)\\]</span>\r\n <span\r\nclass=\"math inline\">\\(r\\)</span></p>\r\n<p>Es sei <span class=\"math inline\">\\(f(x)\\)</span> eine in der\r\nendlichen Ebene meromorphe Funktion. Bezeichnen <span\r\nclass=\"math inline\">\\(z_{1}, z_{2}, \\cdots, z_{q}\\)</span> untereinander\r\nverschiedene, endliche oder unendliehe Zahlen, so ist</p>\r\n<p><span class=\"math display\">\\[(q-2) T(r) &lt;  \\sum_{\\nu =1}^{q}\r\nN(r;z_{\\nu})- N_{1}(r) + S(r)  \\tag{III}\\]</span></p>\r\n<p>wo <span class=\"math inline\">\\(N_{1}(r)\\)</span> in derselben Weise,\r\nwie in dent zweiten Hauptsatz (S.63), mittels der mehrfachen Stellen von\r\n<span class=\"math inline\">\\(f(x)\\)</span> gebildet wird, und das\r\nRestglied <span class=\"math inline\">\\(S(r)\\)</span> ebenfalls den in\r\ndiesem Satze angegebenen Bedingungeu gen\"ugt.</p>\r\n<p> <span class=\"math inline\">\\(f(x)\\)</span>\r\n <span class=\"math inline\">\\(z_{1}, z_{2},\r\n\\cdots, z_{q}\\)</span> </p>\r\n<p><span class=\"math display\">\\[(q-2) T(r) &lt;  \\sum_{\\nu =1}^{q}\r\nN(r;z_{\\nu})- N_{1}(r) + S(r)  \\tag{III}\\]</span></p>\r\n<p> <span class=\"math inline\">\\(N_{1}(r)\\)</span>  (p.63)\r\n <span class=\"math inline\">\\(f(x)\\)</span>\r\n <span class=\"math inline\">\\(S(r)\\)</span>\r\n</p>\r\n<p>In der Ungleichung (III) ist die speziellere</p>\r\n<p><span class=\"math display\">\\[(q-2) T(r) &lt;  \\sum_{\\nu =1}^{q}\r\n\\bar{N}(r;z_{\\nu}) + S(r)  \\tag{III$^{\\prime}$}\\]</span></p>\r\n<p>enthalten, wo die Bezeichnung N(t) die auf S.63 angegebene Bedeutung\r\nhat</p>\r\n<p>(III)</p>\r\n<p><span class=\"math display\">\\[(q-2) T(r) &lt;  \\sum_{\\nu =1}^{q}\r\n\\bar{N}(r;z_{\\nu}) + S(r)  \\tag{III$^{\\prime}$}\\]</span></p>\r\n<p> <span class=\"math inline\">\\(N(t)\\)</span>  63\r\n</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"elnleitung.\">Elnleitung.</h1>\r\n<p>Mittels der Poisson-Jensenschen und der spezielleren Jensenschen\r\nFormel kann man nun den nachstehenden Satz beweisen, den wir wegen der\r\ngrundlegenden Bedeutang desselben flit die ganze Theorie den ersten\r\nHauptsatz nennen:</p>\r\n<p>Zu jeder meromorphen Funktion <span\r\nclass=\"math inline\">\\(f(x)\\)</span> geh\"ort eine reelle Funktion <span\r\nclass=\"math inline\">\\(T(r)\\)</span> von folgenden Eigenschaften :</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(T(r)\\)</span> ist eine wachsende\r\nFunktion von <span class=\"math inline\">\\(r\\)</span> and eine konvexe\r\nFunktion von <span class=\"math inline\">\\(\\log r\\)</span>.</p></li>\r\n<li><p>Wenn <span class=\"math inline\">\\(z\\)</span> eine beliebige van\r\n<span class=\"math inline\">\\(x\\)</span> unabMingige, endliche oder\r\nunendliche komplexe Zahl bezeichnet, so ist <span\r\nclass=\"math display\">\\[m(r;z) + N(r;z) = T(r) + O(1).\\]</span> Die auf\r\nder linken Seite der Beziehung (I) stehenden zwei Glieder sind\r\nnichtnegativ. Das erste Glied <span\r\nclass=\"math inline\">\\(m(r;z)\\)</span> ist der Mittelwert der Gr\"oe\r\n<span class=\"math inline\">\\(\\log^{+} \\left|\r\n\\frac{1}{f-z}\\right|\\)</span> auf dem Kreis <span\r\nclass=\"math inline\">\\(|x| = r\\)</span> und erh\"alt also wesentliche\r\nBoitr\"aige von denjenigen Bogen dieses Kreises, auf denen der\r\nFunktionenwert <span class=\"math inline\">\\(f\\)</span> nahe an dem Wert\r\n<span class=\"math inline\">\\(z\\)</span> liegt ; man k\"onnte daher sagen,\r\nda <span class=\"math inline\">\\(m(r;z)\\)</span> ein bla f\"ur die\r\nSt\"arke der mittleren Hfinvergenz der Funktion <span\r\nclass=\"math inline\">\\(f(x)\\)</span> gegen den Wert <span\r\nclass=\"math inline\">\\(z\\)</span> f\"ur <span class=\"math inline\">\\(r \\to\r\n\\infty\\)</span> angibt. Das zweite Glied <span\r\nclass=\"math inline\">\\(N(r;z)\\)</span> bestimmt wiederum, wie dicht\r\ndiejenigen Punkte liegen, in denen die Funktion den betreffenden Wert\r\n<span class=\"math inline\">\\(z\\)</span> tats\"achlich annimmt. Die Summe\r\nin <span class=\"math inline\">\\(m(r;z) + N(r; z)\\)</span> k\"onnte man\r\ndeshalb als die \"z-Komponente\" in der Variation der meromorpben Funktion\r\nf\"ur <span class=\"math inline\">\\(|x| \\to \\infty\\)</span> on bezeichnen:\r\nsie charakterisiert sozusagen die St\"arke der Affinit\"at, welche die\r\nFnnktion zn dem komplexen Wert <span class=\"math inline\">\\(z\\)</span>\r\nbesitzt. Der erste Haoptsatz dr\"uckt nnn ana, da s\"amtliche\r\nz-Komponenten einer meromorphen Funktion gleich stark sind; je zwei von\r\nihnen halten einander f\"ur <span class=\"math inline\">\\(r \\to\r\n\\infty\\)</span> im Gleichgewicht, derart da ihre Differenz f\"ur jedes\r\n<span class=\"math inline\">\\(r\\)</span> beschr\"ankt ist. Diese schon an\r\nsich bemerkenswerte Symmetrieeigenschaft der meromorphen Funktionen iat\r\nf\"ur die ganze Theorie von fondamentaler Wichtigkeit.</p></li>\r\n</ol>\r\n<p> Poisson-Jensen  Jensen \r\n</p>\r\n<p> <span class=\"math inline\">\\(f(x)\\)</span>\r\n <span\r\nclass=\"math inline\">\\(T(r)\\)</span></p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(T(r)\\)</span><span\r\nclass=\"math inline\">\\(r\\)</span><span\r\nclass=\"math inline\">\\(\\log r\\)</span></p></li>\r\n<li><p> <span class=\"math inline\">\\(z\\)</span>  <span\r\nclass=\"math inline\">\\(x\\)</span>  <span\r\nclass=\"math display\">\\[m(r;z) + N(r;z) = T(r) + O(1).\\]</span>  (I)\r\n   <span class=\"math inline\">\\(m(r;z)\\)</span>\r\n $|x| = r $  <span class=\"math inline\">\\(\\log^{+} \\left|\r\n\\frac{1}{f-z}\\right|\\)</span>\r\n\r\nBoitraige <span class=\"math inline\">\\(f\\)</span>\r\n <span class=\"math inline\">\\(z\\)</span> <span\r\nclass=\"math inline\">\\(m(r;z)\\)</span>  <span\r\nclass=\"math inline\">\\(f(x)\\)</span>  <span\r\nclass=\"math inline\">\\(z\\)</span>  <span class=\"math inline\">\\(r \\to\r\n\\infty\\)</span> <span class=\"math inline\">\\(N(r; z)\\)</span>\r\n<span\r\nclass=\"math inline\">\\(z\\)</span> <span\r\nclass=\"math inline\">\\(m(r;z) + N(r;z)\\)</span>  <span\r\nclass=\"math inline\">\\(|x| z  \\to \r\n\\infty\\)</span> on <span\r\nclass=\"math inline\">\\(z\\)</span> \r\n z   <span\r\nclass=\"math inline\">\\(r \\to \\infty\\)</span>\r\n <span class=\"math inline\">\\(r\\)</span>\r\n\r\nf</p></li>\r\n</ol>\r\n<p>Dieaer zweite Hauplsatz, wie wir ihn nennen, mann in folgender Weise\r\nausgesprochen werden: Es seien <span class=\"math inline\">\\(f(x)\\)</span>\r\neine beliebige meromoryhe Futiklion, <span\r\nclass=\"math inline\">\\(T(r)\\)</span> lie eu ihr geh\"orige\r\nFundamentalgr\"oe und <span class=\"math inline\">\\(a, b, c\\)</span> drei\r\nnon eitiander zerschiedene, endliche oder unendliche komplexe Sahlen.\r\nDann besteht die Angleichung <span class=\"math display\">\\[T (r) &lt;\r\nN(r;a) + N(r; b) + N(r; c) - N_{1}(r) - S(r), \\tag{II}\\]</span> wo die\r\nGlieder <span class=\"math inline\">\\(N_{1}\\)</span> und <span\r\nclass=\"math inline\">\\(S\\)</span> folgende Bedeiiftoiy haben : 1. <span\r\nclass=\"math inline\">\\(N_{1}(r)\\)</span> wird durch die multiplen Stellen\r\nder Funktion gebildet nach folgender Vorschrift:</p>\r\n<p>ldan bilde die Anzahl <span class=\"math inline\">\\(n_{1}(r)\\)</span>\r\nder mehrachen Stellen von <span class=\"math inline\">\\(f(x)\\)</span> in\r\ndem Abreise <span class=\"math inline\">\\(|x|&lt;r\\)</span> in der Weise,\r\nda eine m-fache Stelle nur (<span class=\"math inline\">\\(m -\r\n1\\)</span>)-mal gez\"ahlt wird; dann ist <span\r\nclass=\"math display\">\\[N_{1}(r) = \\int_{0}^{r} \\frac{n_{1}(t)}{t}\r\ndt.\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Das Restglied <span class=\"math inline\">\\(S(f)\\)</span> gen\"ugt der\r\nUngleichung <span class=\"math display\">\\[S(r) &lt; O\\left(\\log\r\nT(r)\\right)\\]</span> auer m\"oglicherweise, im Falle einer Funktion von\r\nunendliclier Ordnung, fur eine WerJmenge <span\r\nclass=\"math inline\">\\(r\\)</span> von endlichem Gesamtma.</li>\r\n</ol>\r\n<p>  <span\r\nclass=\"math inline\">\\(f(x)\\)</span> <span\r\nclass=\"math inline\">\\(T(r)\\)</span> <span\r\nclass=\"math inline\">\\(abc\\)</span> \r\n <span class=\"math display\">\\[T (r) &lt; N(r;a) + N(r; b) +\r\nN(r; c) - N_{1}(r) - S(r), \\tag{II}\\]</span>  <span\r\nclass=\"math inline\">\\(N_{1}\\)</span>  <span\r\nclass=\"math inline\">\\(S\\)</span>  1. <span\r\nclass=\"math inline\">\\(N_{1}(r)\\)</span></p>\r\n<p><span class=\"math inline\">\\(|x| &lt;\r\nr\\)</span><span class=\"math inline\">\\(f(x)\\)</span><span\r\nclass=\"math inline\">\\(n_{1}(r)\\)</span>m$m - 1 $ )\r\n <span class=\"math display\">\\[N_{1}(r) = \\int_{0}^{r}\r\n\\frac{n_{1}(t)}{t} dt.\\]</span></p>\r\n<p>2.<span class=\"math inline\">\\(S(f)\\)</span> <span\r\nclass=\"math display\">\\[S(r) &lt; O\\left(\\log T(r)\\right)\\]</span>\r\n <span\r\nclass=\"math inline\">\\(r\\)</span></p>\r\n<p>Es sei <span class=\"math inline\">\\(f(x)\\)</span> eine in der\r\nendlichen Ebene meromorphe Funktion. Bezeichnen <span\r\nclass=\"math inline\">\\(z_{1}, z_{2}, \\cdots, z_{q}\\)</span> untereinander\r\nverschiedene, endliche oder unendliehe Zahlen, so ist</p>\r\n<p><span class=\"math display\">\\[(q-2) T(r) &lt;  \\sum_{\\nu =1}^{q}\r\nN(r;z_{\\nu})- N_{1}(r) + S(r)  \\tag{III}\\]</span></p>\r\n<p>wo <span class=\"math inline\">\\(N_{1}(r)\\)</span> in derselben Weise,\r\nwie in dent zweiten Hauptsatz (S.63), mittels der mehrfachen Stellen von\r\n<span class=\"math inline\">\\(f(x)\\)</span> gebildet wird, und das\r\nRestglied <span class=\"math inline\">\\(S(r)\\)</span> ebenfalls den in\r\ndiesem Satze angegebenen Bedingungeu gen\"ugt.</p>\r\n<p> <span class=\"math inline\">\\(f(x)\\)</span>\r\n <span class=\"math inline\">\\(z_{1}, z_{2},\r\n\\cdots, z_{q}\\)</span> </p>\r\n<p><span class=\"math display\">\\[(q-2) T(r) &lt;  \\sum_{\\nu =1}^{q}\r\nN(r;z_{\\nu})- N_{1}(r) + S(r)  \\tag{III}\\]</span></p>\r\n<p> <span class=\"math inline\">\\(N_{1}(r)\\)</span>  (p.63)\r\n <span class=\"math inline\">\\(f(x)\\)</span>\r\n <span class=\"math inline\">\\(S(r)\\)</span>\r\n</p>\r\n<p>In der Ungleichung (III) ist die speziellere</p>\r\n<p><span class=\"math display\">\\[(q-2) T(r) &lt;  \\sum_{\\nu =1}^{q}\r\n\\bar{N}(r;z_{\\nu}) + S(r)  \\tag{III$^{\\prime}$}\\]</span></p>\r\n<p>enthalten, wo die Bezeichnung N(t) die auf S.63 angegebene Bedeutung\r\nhat</p>\r\n<p>(III)</p>\r\n<p><span class=\"math display\">\\[(q-2) T(r) &lt;  \\sum_{\\nu =1}^{q}\r\n\\bar{N}(r;z_{\\nu}) + S(r)  \\tag{III$^{\\prime}$}\\]</span></p>\r\n<p> <span class=\"math inline\">\\(N(t)\\)</span>  63\r\n</p>\r\n"},{"title":"Divisor","date":"2023-03-27T10:42:10.000Z","_content":"","source":"_drafts/Divisor Theory.md","raw":"---\ntitle: Divisor\ndate: 2023-03-27 18:42:10\ntags: \n    - [Algebraic Geometry]\ncategories: \n    - [Algebraic Geometry]\n---\n","slug":"Divisor Theory","published":0,"updated":"2023-04-06T11:17:47.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisunp0018eslr3eu7a6tc","content":"\r\n","site":{"data":{}},"excerpt":"","more":"\r\n"},{"title":"Kronecker dream of youth","mathjax":true,"_content":"\nKronecker's Jugendtraum (or Hilbert's 12th problem) is to find abelian extensions of arbitrary number fields by adjoining `special' values of transcendental \nKronecker once proved that all the Galois extensions of the rationals $\\mathbb{Q}$ with Abelian Galois groups are subfields of cyclotomic fields $\\mathbb{Q}(\\mu_n)$, where $\\mu_n$ is the group of $n$-th roots of unity.\n\n\nKronecher wrote in a letter to Dedekind:\n\n*Es handelt sich um meinen liebsten Jugendtraum, n\\\"amlich um den Nachweis, dass die Abel'schen Gleichungen mit Quadratwurzeln rationaler Zahlen durch die Transformations-Gleichungen elliptischer Functionen mit singularen Moduln grade so ersch\\\"opft werden, wie die ganzzahligen Abel'schen Gleichungen durch die Kreisteilungsgleichungen.*\n\n","source":"_drafts/Kronecker-dream-of-youth.md","raw":"---\ntitle: Kronecker dream of youth\ntags:\n    - [Hilbert's 23 Problems, Algebraic Number Theory]\ncategories:\n    - [Hilbert's 12th Problem, Commutative Algebra, Algebraic Number Theory, Algebraic Geometry]\nmathjax: true\n---\n\nKronecker's Jugendtraum (or Hilbert's 12th problem) is to find abelian extensions of arbitrary number fields by adjoining `special' values of transcendental \nKronecker once proved that all the Galois extensions of the rationals $\\mathbb{Q}$ with Abelian Galois groups are subfields of cyclotomic fields $\\mathbb{Q}(\\mu_n)$, where $\\mu_n$ is the group of $n$-th roots of unity.\n\n\nKronecher wrote in a letter to Dedekind:\n\n*Es handelt sich um meinen liebsten Jugendtraum, n\\\"amlich um den Nachweis, dass die Abel'schen Gleichungen mit Quadratwurzeln rationaler Zahlen durch die Transformations-Gleichungen elliptischer Functionen mit singularen Moduln grade so ersch\\\"opft werden, wie die ganzzahligen Abel'schen Gleichungen durch die Kreisteilungsgleichungen.*\n\n","slug":"Kronecker-dream-of-youth","published":0,"date":"2023-12-10T15:57:58.988Z","updated":"2023-12-10T16:51:15.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisunq001ceslrf9tm9r5o","content":"<p>Kronecker's Jugendtraum (or Hilbert's 12th problem) is to find\r\nabelian extensions of arbitrary number fields by adjoining `special'\r\nvalues of transcendental Kronecker once proved that all the Galois\r\nextensions of the rationals <span\r\nclass=\"math inline\">\\(\\mathbb{Q}\\)</span> with Abelian Galois groups are\r\nsubfields of cyclotomic fields <span\r\nclass=\"math inline\">\\(\\mathbb{Q}(\\mu_n)\\)</span>, where <span\r\nclass=\"math inline\">\\(\\mu_n\\)</span> is the group of <span\r\nclass=\"math inline\">\\(n\\)</span>-th roots of unity.</p>\r\n<p>Kronecher wrote in a letter to Dedekind:</p>\r\n<p><em>Es handelt sich um meinen liebsten Jugendtraum, n\"amlich um den\r\nNachweis, dass die Abel'schen Gleichungen mit Quadratwurzeln rationaler\r\nZahlen durch die Transformations-Gleichungen elliptischer Functionen mit\r\nsingularen Moduln grade so ersch\"opft werden, wie die ganzzahligen\r\nAbel'schen Gleichungen durch die Kreisteilungsgleichungen.</em></p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>Kronecker's Jugendtraum (or Hilbert's 12th problem) is to find\r\nabelian extensions of arbitrary number fields by adjoining `special'\r\nvalues of transcendental Kronecker once proved that all the Galois\r\nextensions of the rationals <span\r\nclass=\"math inline\">\\(\\mathbb{Q}\\)</span> with Abelian Galois groups are\r\nsubfields of cyclotomic fields <span\r\nclass=\"math inline\">\\(\\mathbb{Q}(\\mu_n)\\)</span>, where <span\r\nclass=\"math inline\">\\(\\mu_n\\)</span> is the group of <span\r\nclass=\"math inline\">\\(n\\)</span>-th roots of unity.</p>\r\n<p>Kronecher wrote in a letter to Dedekind:</p>\r\n<p><em>Es handelt sich um meinen liebsten Jugendtraum, n\"amlich um den\r\nNachweis, dass die Abel'schen Gleichungen mit Quadratwurzeln rationaler\r\nZahlen durch die Transformations-Gleichungen elliptischer Functionen mit\r\nsingularen Moduln grade so ersch\"opft werden, wie die ganzzahligen\r\nAbel'schen Gleichungen durch die Kreisteilungsgleichungen.</em></p>\r\n"},{"title":"Dedekind Domain","date":"2023-04-01T16:00:45.000Z","_content":"","source":"_drafts/Dedekind Domain.md","raw":"---\ntitle: Dedekind Domain\ndate: 2023-04-02 00:00:45\ntags:\n---\n","slug":"Dedekind Domain","published":0,"updated":"2023-04-06T11:17:47.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisunr001feslrfkvp0yor","content":"\r\n","site":{"data":{}},"excerpt":"","more":"\r\n"},{"title":"Nowicki Conjecture","date":"2023-04-01T08:22:43.000Z","mathjax":true,"_content":"Let $A[\\mathbf{x}] = A[x_{1}, \\cdots, x_{n}$] be the polynomial ring in n variables over an integral domain $A$, $D$ an $A$-[derivation](https://en.wikipedia.org/wiki/Derivation_(differential_algebra)) of $A[\\mathbf{x}]$ and denote \n$$D_{ij} := D(x_{i}) x_{j} - D(x_{j}) x_{i}, \\quad \\text{ for each } i, j \\in \\{1, \\cdots, n\\}.$$\n\n\n## Theorem 1 [Nowicki 1, Conjecture 6.9.10]\nAssume that $k[\\mathbf{y}] = k[y_{1}, \\cdots, y_{n}]$ is the polynomial ring in $n$ variables over a field $k$ of characteristic zero. If $\\Delta_{n}$ is the $k[\\mathbf{y}]$-derivation of $k[\\mathbf{y}][\\mathbf{x}]$ defined by $\\Delta_{n}(x_{i}) = y_{i}$ for $i = 1, \\cdots, n$, then $\\ker \\Delta_{n}$ is generated by $L^{\\Delta_{n}}_{ij}$ for $1  i < j  n$ over $k[\\mathbf{y}]$.\n\n\n## Proof\n\nWe prove the conjecture by induction on $n$. The assertion is clear when $n = 1$. Assume that $n \\geq 2$, and let $S_{l}$ be the set of $L_{i,j} := L^{\\Delta_{n}}_{i,j}$ for $1 \\leq i < j \\leq l$ for each $l \\leq n$. By the assumption on induction, $\\ker \\Delta_{n-1}$ is generated by $S_{n-1}$ over $k[\\mathbf{y}^{\\prime}] := k[y_{1}, \\cdots , y_{n-1}]$, since $L^{\\Delta_{n-1}}_{i,j} = L^{\\Delta_{n}}_{i,j}$ for each $i, j$. As discussed in Section 1, the $k[\\mathbf{y}^{\\prime}]$-derivation $\\Delta_{n-1}$ naturally extends to a $k[\\mathbf{y}]$-derivation $(\\Delta_{n-1})_{k[\\mathbf{y}]}$ of $k[\\mathbf{y}][\\mathbf{x}^{\\prime}] := k[\\mathbf{y}][x_{1}, \\cdots, x_{n-1}]$. Then, $(\\Delta_{n-1})k[\\mathbf{y}] = \\Delta_{n}|_{k[\\mathbf{y}][\\mathbf{x}^{\\prime}]}$, so we have $\\ker(\\Delta_{n-1})k[\\mathbf{y}] = k[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n}$. Moreover,\n$\\ker(\\Delta_{n-1})k[\\mathbf{y}] = k[\\mathbf{y}] \\otimes_{k[\\mathbf{y}^{\\prime}]} \\ker \\Delta_{n-1}$, since $k[\\mathbf{y}]$ is flat over $k[\\mathbf{y}^{\\prime}]$. Thus, we get\n\n\n$$\\begin{equation}\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n} = k[\\mathbf{y}][S_{n-1}].\n\\end{equation}$$\n\n\n\nLet $\\mathbf{e}_{1}, \\cdots , \\mathbf{e}_{n}$ be the coordinate unit vectors of $\\mathbb{R}^{n}$, $M$ the $\\mathbb{Z}$-submodule of $(\\mathbb{Z}^{n})^{2}$ generated by $(\\mathbf{e}_{j} - \\mathbf{e}_{i}, \\mathbf{e}_{i} - \\mathbf{e}_{j})$ for $1 \\leq i < j \\leq n$, and $\\Gamma = (\\mathbb{Z}^{n})^{2}/M$. Then, $\\Gamma$-gradings are defined on $k[\\mathbf{y}][\\mathbf{x}]$ and $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}] := k[\\mathbf{y}][\\mathbf{x}][(y_{1} \\cdots y_{n})^{-1}]$ as follows. Here, a $k$-algebra $R$ is said to be $\\Gamma$-graded if there exists a $k$-vector subspace $R_{\\gamma}$ of $R$ for each $\\gamma \\in \\Gamma$ such that $R = \\oplus_{\\gamma \\in \\Gamma} R_{\\gamma}$ and $R_{\\gamma} R_{\\mu} \\subset R_{\\gamma + \\mu}$ for $\\gamma, \\mu \\in \\Gamma$. Let $\\mathbb{Z}_{\\geq 0}$ denote the set of nonnegative integers, and $\\mathbf{y}^{a} = y^{a_{1}} \\cdots y^{a_{n}}$ and $\\mathbf{x}_{b} = x^{b_{1}} \\cdots x^{b_{n}}$ for $a = (a_{1}, \\cdots , a_{n})$ and $b = (b_{1}, \\cdots , b_{n})$. For each $\\gamma \\in \\Gamma$, we define $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma}$ (resp. $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\gamma}$) to be the $k$-vector space generated by $\\mathbf{y}^{a}\\mathbf{x}^{b}$ for $a, b \\in (\\mathbb{Z}_{\\geq 0})^{n} (resp. $a \\in \\mathbb{Z}^{n}, b \\in (\\mathbb{Z}_{\\geq 0})^{n}$) such that the image of $(a, b)$ in $\\Gamma$ is equal to $\\gamma$. Then, $\\Gamma$-gradings are defined on $k[\\mathbf{y}][\\mathbf{x}]$ and $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]$. Note that $\\Delta_{n}(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma})$ is contained in $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma - \\delta}$ for each $\\gamma \\in \\Gamma$, where $\\delta$ is the image of $(-\\mathbb{e}_{n}, \\mathbb{e}_{n})$ in $\\Gamma$. From this, we know that\n\n$$\\ker \\Delta_{n} = \\bigoplus_{\\gamma \\in \\Gamma} k[\\mathbf{y}] [ \\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}$$\n\nHence, we are reduced to showing that each $0 \\neq \\varPhi \\in k[\\mathbf{y}][\\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}$ belongs to $k[\\mathbf{y}][S_{n}]$ for $\\gamma \\in \\Gamma$. We may find $a = (a_{1}, \\cdots , a_{n}) \\in \\mathbb{Z}^{n}$ and $l \\in \\mathbb{Z}_{\\geq 0}$ such that the image of $(a, l\\mathbf{e}_{n})$ in $\\Gamma$ is equal to $\\gamma$. Let $m$ be the $x_{n}$-degree of $\\varPhi$, where $0 \\leq m \\leq l$, and $\\phi \\in k[\\mathbf{y}][\\mathbf{x}^{\\prime}]$ the coefficient of $x_{n}^{m}$ in $\\varPhi$. Then, $\\phi$ belongs to $k[\\mathbf{y}][\\mathbf{x}]_{\\mu}$, where $\\mu$ is the image of $(a, (l m)\\mathbf{e}_{n})$ in $\\Gamma$. Furthermore, $0 = \\Delta_{n}(\\varPhi) = \\Delta_{n}(\\varphi)x^{m}_{n} + m\\phi y_{n}x_{n}^{m-1} + \\Delta_{n}(\\varPhi - \\phi x^{m}_{n})$, and the $x_{n}$-degrees of $m\\phi y_{n}x_{n}^{m-1}$ and $\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})$ are at most $m - 1$. Hence, $\\Delta_{n}(\\phi) = 0$. Thus, $\\phi$ belongs to $k[\\mathbf{y}][S_{n-1}]$ by (1). Write $\\phi = \\sum_{b,\\mathbf{u}} r^{\\prime}_{b,\\mathbf{u}}y^{b}\\hat{y}^{-\\mathbf{u}}L^{\\mathbf{u}}$, where the sum is taken over $b \\in (\\mathbb{Z}_{\\geq 0})^{n}$ and $u = (u_{i,j})_{i,j}$ with $u_{i,j} \\in \\mathbb{Z}_{\\geq 0}$ for $1 \\leq i < j \\leq n - 1$, $r^{\\prime}_{b,\\mathbf{u}} \\in k$ for each $b$ and $\\mathbf{u}$, and \n\n$\\hat{y}^{-u} = \\prod_{1\\leq i < j \\leq n-1} (y_{i}y_{j})^{-u_{i,j}}, \\quad L^{\\mathbf{u}} = \\prod_{1 \\leq i<j\\leq n-1} L_{i,j}^{u_{i,j}}$ for each $\\mathbf{U}$.\n\nWe may assume that $r_{b,\\mathbf{u}}^{\\prime} = 0$ if $\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}$ is not in $k[\\mathbf{y}]$. Let $\\eta(b, \\mathbf{u})$ be the image of $(b - |\\mathbf{u}|\\mathbf{e}_{n}, |\\mathbf{u}|\\mathbf{e}_{n})$ in $\\Gamma$, where $|\\mathbf{u}| = \\sum_{i,j} u_{i,j}\n$. Then, $\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}L^{\\mathbf{u}}$ belongs to $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\eta(b,\\mathbf{u})}$ for each $b$ and $\\mathbf{u}$, since $(y_{i}y_{j})^{-1} L_{i,j}$ belongs to $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\delta}$ for each $i, j$.  Since $\\phi$ is in $k[\\mathbf{y}][\\mathbf{x}]_{\\mu}$, and $\\mu$ is the image of $(a, (l - m)\\mathbf{e}_{n})$, we may assume that $r_{b,\\mathbf{u}}^{\\prime} = 0$ unless $|u| = l - m$ and $b = a + (l - m)\\mathbf{e}_{n}$. For each $\\mathbf{u}$ with $r_{\\mathbf{u}} := r^{\\prime}_{a + (l-m) \\mathbf{e}_{n},\\mathbf{u}}\\neq 0$, write $\\mathbf{y}^{a}y_{n}^{l-m}\\hat{y}^{-\\mathbf{u}} =\ny_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} y_{n}^{s}$, where $\\rho_{i}(u) \\in \\mathbb{Z}_{\\geq 0}$ for $i = 1, \\cdots , n - 1$, and $s = a_{n} + l - m$. Then, we have $\\phi = y_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}$. Since $|u| = l - m$, it follows that\n\n$$\\begin{equation}\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\n\\end{equation}$$\n\nNow, we show that $\\varPhi$ belongs to $k[\\mathbf{y}][S_{n}]$ by contradiction. By replacing $\\varPhi$ if necessary, we may assume that $m$ is the minimum among the $x_{n}$-degrees of elements of $\\ker \\Delta_{n}\\backslash k[\\mathbf{y}][S_{n}]$. To obtain a contradiction, it suffices to deduce that\n\n$$\\begin{equation}\nm \\geq 2l - \\sum_{i=1}^{n-1} a_{i}\n\\end{equation}$$\n\n\nIn fact, (3) implies that $\\sum_{i=1}^{n-1}\n\\rho_{i}(\\mathbf{u}) \\geq m$ by (2), so we have $\\sum_{i=1}^{n-1}\\rho_{i}^{\\prime}(\\mathbf{u})  = m$ for some\nintegers $0 \\leq \\rho^{\\prime}_{i}(\\mathbf{u}) \\leq \\rho_{i}(\\mathbf{u})$ for $i = 1, \\cdots, n - 1$ for each $u$. Then,\n\n$$\\varPhi^{\\prime} := y_{n}^{s} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u} - \\rho_{i}^{\\prime}(\\mathbf{u})} L_{n,i}^{\\rho_{i}^{\\prime}(\\mathbf{u}} = y_{n}^{s} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u} - \\rho_{i}^{\\prime}(\\mathbf{u} } (y_{i}x_{n} x_{n}y_{i})^{\\rho_{i}^{\\prime}(\\mathbf{u} }$$\n\n\nis an element of $k[\\mathbf{y}][S_{n}]$ having $x_{n}$-degree $m$, in which the coefficient of $x_{n}^{m}$ is equal to $\\phi$. Hence, the $x_{n}$-degree of $\\varPhi - \\varPhi^{\\prime}$ is less than $m$. Since $\\varPhi - \\varPhi^{\\prime}$ is an element of $\\ker \\Delta_{n} \\backslash k[\\mathbf{y}][S_{n}]$, this contradicts the minimality of $m$.\n\nWe establish that (3) holds for any nonzero homogeneous element $\\varPhi$ of $\\ker \\Delta_{n}$ by contradiction.\nTake $\\varPhi$ which does not satisfy (3) so that $m$ would be the minimum among the $x_{n}$-degrees of such polynomials. Then, $t:= 2l - \\sum_{i=1}^{n-1}a_{i} -m$ is positive, and $\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) = m - t$ for each $\\mathbf{u}$ by (2). Hence, the $x_{n}$-degree of\n\n$$\\varPhi_{1}:= \\sum_{\\mathbf{u}} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} L_{n,i}^{\\rho_{i}(\\mathbf{u})} = \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} (y_{i}x_{n} - y_{n}x_{i})^{\\rho_{i}(\\mathbf{u})}$$\n\n\nis $m - t$. The coefficient of $x_{n}^{n-t}$ in $y_{n}^{s}\\varPhi_{1}$ is equal to $\\phi$, so the coefficient of $x_{n}^{m}$ in $y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$ is equal to that in $y_{1}^{t}\\varPhi$. Consequently, the $x_{n}$-degree $m^{\\prime}$ of $\\varPhi_{2}:= y_{1}^{t}\\varPhi - y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$ is less than $m$. We claim that $\\varPhi_{2} = 0$. In fact, if $\\gamma^{\\prime}$ is the image of $(a + t\\mathbf{e}_{1}, l\\mathbf{e}_{n})$ in $\\Gamma$, and $(a^{\\prime}_{1}, \\cdots , a_{n}^{\\prime}\n) := a + t\\mathbf{e}_{1}$, then $\\varPhi_{2}$ belongs to $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma^{\\prime}} \\cap \\ker \\Delta_{n}$, and\n\n\n$$2l - \\sum_{i=1}^{n-1} a^{\\prime}_{i} = 2l - \\sum_{i=1}^{n-1} a_{i} - t = m > m^{\\prime}$$\n\n\nThis implies that $\\varPhi_{2} = 0$ by the minimality of $m$. Hence, $y_{1}^{t} \\varPhi= y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$. Thus, $\\varPhi_{1}$ is divisible by $y_{1}$, since neither are $y_{n}$ and $L_{n,1}$. Recall that the kernel of a locally nilpotent derivation $D$ of an integral domain $R$ containing $Q$ is factorially closed in $R$, that is, $D(f g) =\n0$ implies $D(f ) = D(g) = 0$ for each $f, g \\in R \\ \\{0\\}$ (cf. [2, Proposition 1.3.32 (iii)]). Note\nthat $\\Delta_{n}$ is locally nilpotent, $\\Delta_{n}(\\varPhi_{1}) = 0$, $\\varPhi_{1} \\neq 0$ and $\\Delta_{n}(x_{n}) \\neq 0$. Hence, $\\varPhi_{1}$ is not divisible by $x_{n}$. By substituting zero for $x_{n}$, we obtain from $\\varPhi_{1}$ a nonzero polynomial\n\n$$\\sum_{\\mathbf{u}}r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} (- y_{n} x_{i})^{\\rho_{i}(\\mathbf{u})} = ( - y_{n} )^{m-i} \\varPsi, \\text{ where } \\varPsi = \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} x_{i}^{\\rho_{i}(\\mathbf{u})}.$$\n\nThen, $\\varPhi \\neq 0$, and $\\varPhi$ is divisible by $y_{1}$, since so is $\\phi_{1}$. Define $\\sigma \\in \\text{Aut}_{k} k[\\mathbf{y}][\\mathbf{x}]$ by $\\sigma(x_{i}) =\ny_{i}$ and $\\sigma(y_{i}) = x_{i}$ for $i = 1, \\cdots, n$. Then, $\\sigma(\\varPhi)$ is divisible by $x_{1}$. On the other hand, $\\sigma(L_{i,j}) = L_{j,i}$ and $\\sigma(x_{i}) = y_{i}$ are in $\\ker \\Delta_{n}$ for each $i, j$, so $\\sigma(\\varPsi)$ belongs to $\\ker \\Delta_{n}$. Thus, we have $\\sigma(\\varPsi) = 0$, because $x_{1}$ is not in $\\ker \\Delta_[n]$ and $\\ker \\Delta_{n}$ is factorially closed in $k[\\mathbf{y}][\\mathbf{x}]$. This contradicts that $\\varPsi \\neq 0$. Therefore, (3) holds true. Thereby, we have proved that $\\varPhi$ belongs to $k[\\mathbf{y}][S_{n}]$. This completes the proof of the conjecture.\n\n\n\n# Reference\n\n[1] Nowicki, Andrzej. Polynomial derivations and their rings of constants. Toru: Uniwersytet Mikolaja Kopernika, 1994.\n\n[2] Khoury, Joseph. Locally nilpotent derivations and their rings of constants. University of Ottawa (Canada), 2001.\n\n[3] Kuroda, Shigeru. \"A Simple Proof of Nowicki's Conjecture on the Kernel of an Elementary Derivation.\" Tokyo Journal of Mathematics 32.1 (2009): 247-251.\n\n[4] Drensky V, Makar-Limanov L. The conjecture of Nowicki on Weitzenbck derivations of polynomial algebras[J]. Journal of Algebra and Its Applications, 2009, 8(01): 41-51.\n\n[5] Drensky, Vesselin. \"Another proof of the Nowicki conjecture.\" Tokyo Journal of Mathematics 43.2 (2020): 537-542.\n\n","source":"_drafts/Nowicki Conjecture.md","raw":"---\ntitle: Nowicki Conjecture\ndate: 2023-04-01 16:22:43\ntags:\n    - [Notes]\ncategories:\n    - [Notes]\nmathjax: true\n---\nLet $A[\\mathbf{x}] = A[x_{1}, \\cdots, x_{n}$] be the polynomial ring in n variables over an integral domain $A$, $D$ an $A$-[derivation](https://en.wikipedia.org/wiki/Derivation_(differential_algebra)) of $A[\\mathbf{x}]$ and denote \n$$D_{ij} := D(x_{i}) x_{j} - D(x_{j}) x_{i}, \\quad \\text{ for each } i, j \\in \\{1, \\cdots, n\\}.$$\n\n\n## Theorem 1 [Nowicki 1, Conjecture 6.9.10]\nAssume that $k[\\mathbf{y}] = k[y_{1}, \\cdots, y_{n}]$ is the polynomial ring in $n$ variables over a field $k$ of characteristic zero. If $\\Delta_{n}$ is the $k[\\mathbf{y}]$-derivation of $k[\\mathbf{y}][\\mathbf{x}]$ defined by $\\Delta_{n}(x_{i}) = y_{i}$ for $i = 1, \\cdots, n$, then $\\ker \\Delta_{n}$ is generated by $L^{\\Delta_{n}}_{ij}$ for $1  i < j  n$ over $k[\\mathbf{y}]$.\n\n\n## Proof\n\nWe prove the conjecture by induction on $n$. The assertion is clear when $n = 1$. Assume that $n \\geq 2$, and let $S_{l}$ be the set of $L_{i,j} := L^{\\Delta_{n}}_{i,j}$ for $1 \\leq i < j \\leq l$ for each $l \\leq n$. By the assumption on induction, $\\ker \\Delta_{n-1}$ is generated by $S_{n-1}$ over $k[\\mathbf{y}^{\\prime}] := k[y_{1}, \\cdots , y_{n-1}]$, since $L^{\\Delta_{n-1}}_{i,j} = L^{\\Delta_{n}}_{i,j}$ for each $i, j$. As discussed in Section 1, the $k[\\mathbf{y}^{\\prime}]$-derivation $\\Delta_{n-1}$ naturally extends to a $k[\\mathbf{y}]$-derivation $(\\Delta_{n-1})_{k[\\mathbf{y}]}$ of $k[\\mathbf{y}][\\mathbf{x}^{\\prime}] := k[\\mathbf{y}][x_{1}, \\cdots, x_{n-1}]$. Then, $(\\Delta_{n-1})k[\\mathbf{y}] = \\Delta_{n}|_{k[\\mathbf{y}][\\mathbf{x}^{\\prime}]}$, so we have $\\ker(\\Delta_{n-1})k[\\mathbf{y}] = k[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n}$. Moreover,\n$\\ker(\\Delta_{n-1})k[\\mathbf{y}] = k[\\mathbf{y}] \\otimes_{k[\\mathbf{y}^{\\prime}]} \\ker \\Delta_{n-1}$, since $k[\\mathbf{y}]$ is flat over $k[\\mathbf{y}^{\\prime}]$. Thus, we get\n\n\n$$\\begin{equation}\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n} = k[\\mathbf{y}][S_{n-1}].\n\\end{equation}$$\n\n\n\nLet $\\mathbf{e}_{1}, \\cdots , \\mathbf{e}_{n}$ be the coordinate unit vectors of $\\mathbb{R}^{n}$, $M$ the $\\mathbb{Z}$-submodule of $(\\mathbb{Z}^{n})^{2}$ generated by $(\\mathbf{e}_{j} - \\mathbf{e}_{i}, \\mathbf{e}_{i} - \\mathbf{e}_{j})$ for $1 \\leq i < j \\leq n$, and $\\Gamma = (\\mathbb{Z}^{n})^{2}/M$. Then, $\\Gamma$-gradings are defined on $k[\\mathbf{y}][\\mathbf{x}]$ and $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}] := k[\\mathbf{y}][\\mathbf{x}][(y_{1} \\cdots y_{n})^{-1}]$ as follows. Here, a $k$-algebra $R$ is said to be $\\Gamma$-graded if there exists a $k$-vector subspace $R_{\\gamma}$ of $R$ for each $\\gamma \\in \\Gamma$ such that $R = \\oplus_{\\gamma \\in \\Gamma} R_{\\gamma}$ and $R_{\\gamma} R_{\\mu} \\subset R_{\\gamma + \\mu}$ for $\\gamma, \\mu \\in \\Gamma$. Let $\\mathbb{Z}_{\\geq 0}$ denote the set of nonnegative integers, and $\\mathbf{y}^{a} = y^{a_{1}} \\cdots y^{a_{n}}$ and $\\mathbf{x}_{b} = x^{b_{1}} \\cdots x^{b_{n}}$ for $a = (a_{1}, \\cdots , a_{n})$ and $b = (b_{1}, \\cdots , b_{n})$. For each $\\gamma \\in \\Gamma$, we define $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma}$ (resp. $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\gamma}$) to be the $k$-vector space generated by $\\mathbf{y}^{a}\\mathbf{x}^{b}$ for $a, b \\in (\\mathbb{Z}_{\\geq 0})^{n} (resp. $a \\in \\mathbb{Z}^{n}, b \\in (\\mathbb{Z}_{\\geq 0})^{n}$) such that the image of $(a, b)$ in $\\Gamma$ is equal to $\\gamma$. Then, $\\Gamma$-gradings are defined on $k[\\mathbf{y}][\\mathbf{x}]$ and $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]$. Note that $\\Delta_{n}(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma})$ is contained in $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma - \\delta}$ for each $\\gamma \\in \\Gamma$, where $\\delta$ is the image of $(-\\mathbb{e}_{n}, \\mathbb{e}_{n})$ in $\\Gamma$. From this, we know that\n\n$$\\ker \\Delta_{n} = \\bigoplus_{\\gamma \\in \\Gamma} k[\\mathbf{y}] [ \\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}$$\n\nHence, we are reduced to showing that each $0 \\neq \\varPhi \\in k[\\mathbf{y}][\\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}$ belongs to $k[\\mathbf{y}][S_{n}]$ for $\\gamma \\in \\Gamma$. We may find $a = (a_{1}, \\cdots , a_{n}) \\in \\mathbb{Z}^{n}$ and $l \\in \\mathbb{Z}_{\\geq 0}$ such that the image of $(a, l\\mathbf{e}_{n})$ in $\\Gamma$ is equal to $\\gamma$. Let $m$ be the $x_{n}$-degree of $\\varPhi$, where $0 \\leq m \\leq l$, and $\\phi \\in k[\\mathbf{y}][\\mathbf{x}^{\\prime}]$ the coefficient of $x_{n}^{m}$ in $\\varPhi$. Then, $\\phi$ belongs to $k[\\mathbf{y}][\\mathbf{x}]_{\\mu}$, where $\\mu$ is the image of $(a, (l m)\\mathbf{e}_{n})$ in $\\Gamma$. Furthermore, $0 = \\Delta_{n}(\\varPhi) = \\Delta_{n}(\\varphi)x^{m}_{n} + m\\phi y_{n}x_{n}^{m-1} + \\Delta_{n}(\\varPhi - \\phi x^{m}_{n})$, and the $x_{n}$-degrees of $m\\phi y_{n}x_{n}^{m-1}$ and $\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})$ are at most $m - 1$. Hence, $\\Delta_{n}(\\phi) = 0$. Thus, $\\phi$ belongs to $k[\\mathbf{y}][S_{n-1}]$ by (1). Write $\\phi = \\sum_{b,\\mathbf{u}} r^{\\prime}_{b,\\mathbf{u}}y^{b}\\hat{y}^{-\\mathbf{u}}L^{\\mathbf{u}}$, where the sum is taken over $b \\in (\\mathbb{Z}_{\\geq 0})^{n}$ and $u = (u_{i,j})_{i,j}$ with $u_{i,j} \\in \\mathbb{Z}_{\\geq 0}$ for $1 \\leq i < j \\leq n - 1$, $r^{\\prime}_{b,\\mathbf{u}} \\in k$ for each $b$ and $\\mathbf{u}$, and \n\n$\\hat{y}^{-u} = \\prod_{1\\leq i < j \\leq n-1} (y_{i}y_{j})^{-u_{i,j}}, \\quad L^{\\mathbf{u}} = \\prod_{1 \\leq i<j\\leq n-1} L_{i,j}^{u_{i,j}}$ for each $\\mathbf{U}$.\n\nWe may assume that $r_{b,\\mathbf{u}}^{\\prime} = 0$ if $\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}$ is not in $k[\\mathbf{y}]$. Let $\\eta(b, \\mathbf{u})$ be the image of $(b - |\\mathbf{u}|\\mathbf{e}_{n}, |\\mathbf{u}|\\mathbf{e}_{n})$ in $\\Gamma$, where $|\\mathbf{u}| = \\sum_{i,j} u_{i,j}\n$. Then, $\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}L^{\\mathbf{u}}$ belongs to $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\eta(b,\\mathbf{u})}$ for each $b$ and $\\mathbf{u}$, since $(y_{i}y_{j})^{-1} L_{i,j}$ belongs to $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\delta}$ for each $i, j$.  Since $\\phi$ is in $k[\\mathbf{y}][\\mathbf{x}]_{\\mu}$, and $\\mu$ is the image of $(a, (l - m)\\mathbf{e}_{n})$, we may assume that $r_{b,\\mathbf{u}}^{\\prime} = 0$ unless $|u| = l - m$ and $b = a + (l - m)\\mathbf{e}_{n}$. For each $\\mathbf{u}$ with $r_{\\mathbf{u}} := r^{\\prime}_{a + (l-m) \\mathbf{e}_{n},\\mathbf{u}}\\neq 0$, write $\\mathbf{y}^{a}y_{n}^{l-m}\\hat{y}^{-\\mathbf{u}} =\ny_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} y_{n}^{s}$, where $\\rho_{i}(u) \\in \\mathbb{Z}_{\\geq 0}$ for $i = 1, \\cdots , n - 1$, and $s = a_{n} + l - m$. Then, we have $\\phi = y_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}$. Since $|u| = l - m$, it follows that\n\n$$\\begin{equation}\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\n\\end{equation}$$\n\nNow, we show that $\\varPhi$ belongs to $k[\\mathbf{y}][S_{n}]$ by contradiction. By replacing $\\varPhi$ if necessary, we may assume that $m$ is the minimum among the $x_{n}$-degrees of elements of $\\ker \\Delta_{n}\\backslash k[\\mathbf{y}][S_{n}]$. To obtain a contradiction, it suffices to deduce that\n\n$$\\begin{equation}\nm \\geq 2l - \\sum_{i=1}^{n-1} a_{i}\n\\end{equation}$$\n\n\nIn fact, (3) implies that $\\sum_{i=1}^{n-1}\n\\rho_{i}(\\mathbf{u}) \\geq m$ by (2), so we have $\\sum_{i=1}^{n-1}\\rho_{i}^{\\prime}(\\mathbf{u})  = m$ for some\nintegers $0 \\leq \\rho^{\\prime}_{i}(\\mathbf{u}) \\leq \\rho_{i}(\\mathbf{u})$ for $i = 1, \\cdots, n - 1$ for each $u$. Then,\n\n$$\\varPhi^{\\prime} := y_{n}^{s} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u} - \\rho_{i}^{\\prime}(\\mathbf{u})} L_{n,i}^{\\rho_{i}^{\\prime}(\\mathbf{u}} = y_{n}^{s} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u} - \\rho_{i}^{\\prime}(\\mathbf{u} } (y_{i}x_{n} x_{n}y_{i})^{\\rho_{i}^{\\prime}(\\mathbf{u} }$$\n\n\nis an element of $k[\\mathbf{y}][S_{n}]$ having $x_{n}$-degree $m$, in which the coefficient of $x_{n}^{m}$ is equal to $\\phi$. Hence, the $x_{n}$-degree of $\\varPhi - \\varPhi^{\\prime}$ is less than $m$. Since $\\varPhi - \\varPhi^{\\prime}$ is an element of $\\ker \\Delta_{n} \\backslash k[\\mathbf{y}][S_{n}]$, this contradicts the minimality of $m$.\n\nWe establish that (3) holds for any nonzero homogeneous element $\\varPhi$ of $\\ker \\Delta_{n}$ by contradiction.\nTake $\\varPhi$ which does not satisfy (3) so that $m$ would be the minimum among the $x_{n}$-degrees of such polynomials. Then, $t:= 2l - \\sum_{i=1}^{n-1}a_{i} -m$ is positive, and $\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) = m - t$ for each $\\mathbf{u}$ by (2). Hence, the $x_{n}$-degree of\n\n$$\\varPhi_{1}:= \\sum_{\\mathbf{u}} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} L_{n,i}^{\\rho_{i}(\\mathbf{u})} = \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} (y_{i}x_{n} - y_{n}x_{i})^{\\rho_{i}(\\mathbf{u})}$$\n\n\nis $m - t$. The coefficient of $x_{n}^{n-t}$ in $y_{n}^{s}\\varPhi_{1}$ is equal to $\\phi$, so the coefficient of $x_{n}^{m}$ in $y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$ is equal to that in $y_{1}^{t}\\varPhi$. Consequently, the $x_{n}$-degree $m^{\\prime}$ of $\\varPhi_{2}:= y_{1}^{t}\\varPhi - y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$ is less than $m$. We claim that $\\varPhi_{2} = 0$. In fact, if $\\gamma^{\\prime}$ is the image of $(a + t\\mathbf{e}_{1}, l\\mathbf{e}_{n})$ in $\\Gamma$, and $(a^{\\prime}_{1}, \\cdots , a_{n}^{\\prime}\n) := a + t\\mathbf{e}_{1}$, then $\\varPhi_{2}$ belongs to $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma^{\\prime}} \\cap \\ker \\Delta_{n}$, and\n\n\n$$2l - \\sum_{i=1}^{n-1} a^{\\prime}_{i} = 2l - \\sum_{i=1}^{n-1} a_{i} - t = m > m^{\\prime}$$\n\n\nThis implies that $\\varPhi_{2} = 0$ by the minimality of $m$. Hence, $y_{1}^{t} \\varPhi= y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$. Thus, $\\varPhi_{1}$ is divisible by $y_{1}$, since neither are $y_{n}$ and $L_{n,1}$. Recall that the kernel of a locally nilpotent derivation $D$ of an integral domain $R$ containing $Q$ is factorially closed in $R$, that is, $D(f g) =\n0$ implies $D(f ) = D(g) = 0$ for each $f, g \\in R \\ \\{0\\}$ (cf. [2, Proposition 1.3.32 (iii)]). Note\nthat $\\Delta_{n}$ is locally nilpotent, $\\Delta_{n}(\\varPhi_{1}) = 0$, $\\varPhi_{1} \\neq 0$ and $\\Delta_{n}(x_{n}) \\neq 0$. Hence, $\\varPhi_{1}$ is not divisible by $x_{n}$. By substituting zero for $x_{n}$, we obtain from $\\varPhi_{1}$ a nonzero polynomial\n\n$$\\sum_{\\mathbf{u}}r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} (- y_{n} x_{i})^{\\rho_{i}(\\mathbf{u})} = ( - y_{n} )^{m-i} \\varPsi, \\text{ where } \\varPsi = \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} x_{i}^{\\rho_{i}(\\mathbf{u})}.$$\n\nThen, $\\varPhi \\neq 0$, and $\\varPhi$ is divisible by $y_{1}$, since so is $\\phi_{1}$. Define $\\sigma \\in \\text{Aut}_{k} k[\\mathbf{y}][\\mathbf{x}]$ by $\\sigma(x_{i}) =\ny_{i}$ and $\\sigma(y_{i}) = x_{i}$ for $i = 1, \\cdots, n$. Then, $\\sigma(\\varPhi)$ is divisible by $x_{1}$. On the other hand, $\\sigma(L_{i,j}) = L_{j,i}$ and $\\sigma(x_{i}) = y_{i}$ are in $\\ker \\Delta_{n}$ for each $i, j$, so $\\sigma(\\varPsi)$ belongs to $\\ker \\Delta_{n}$. Thus, we have $\\sigma(\\varPsi) = 0$, because $x_{1}$ is not in $\\ker \\Delta_[n]$ and $\\ker \\Delta_{n}$ is factorially closed in $k[\\mathbf{y}][\\mathbf{x}]$. This contradicts that $\\varPsi \\neq 0$. Therefore, (3) holds true. Thereby, we have proved that $\\varPhi$ belongs to $k[\\mathbf{y}][S_{n}]$. This completes the proof of the conjecture.\n\n\n\n# Reference\n\n[1] Nowicki, Andrzej. Polynomial derivations and their rings of constants. Toru: Uniwersytet Mikolaja Kopernika, 1994.\n\n[2] Khoury, Joseph. Locally nilpotent derivations and their rings of constants. University of Ottawa (Canada), 2001.\n\n[3] Kuroda, Shigeru. \"A Simple Proof of Nowicki's Conjecture on the Kernel of an Elementary Derivation.\" Tokyo Journal of Mathematics 32.1 (2009): 247-251.\n\n[4] Drensky V, Makar-Limanov L. The conjecture of Nowicki on Weitzenbck derivations of polynomial algebras[J]. Journal of Algebra and Its Applications, 2009, 8(01): 41-51.\n\n[5] Drensky, Vesselin. \"Another proof of the Nowicki conjecture.\" Tokyo Journal of Mathematics 43.2 (2020): 537-542.\n\n","slug":"Nowicki Conjecture","published":0,"updated":"2023-04-12T13:47:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqxisuns001jeslr2jz9bzlf","content":"<p>Let <span class=\"math inline\">\\(A[\\mathbf{x}] = A[x_{1}, \\cdots,\r\nx_{n}\\)</span>] be the polynomial ring in n variables over an integral\r\ndomain <span class=\"math inline\">\\(A\\)</span>, <span\r\nclass=\"math inline\">\\(D\\)</span> an <span\r\nclass=\"math inline\">\\(A\\)</span>-<a\r\nhref=\"https://en.wikipedia.org/wiki/Derivation_(differential_algebra)\">derivation</a>\r\nof <span class=\"math inline\">\\(A[\\mathbf{x}]\\)</span> and denote <span\r\nclass=\"math display\">\\[D_{ij} := D(x_{i}) x_{j} - D(x_{j}) x_{i}, \\quad\r\n\\text{ for each } i, j \\in \\{1, \\cdots, n\\}.\\]</span></p>\r\n<h2 id=\"theorem-1-nowicki-1-conjecture-6.9.10\">Theorem 1 [Nowicki 1,\r\nConjecture 6.9.10]</h2>\r\n<p>Assume that <span class=\"math inline\">\\(k[\\mathbf{y}] = k[y_{1},\r\n\\cdots, y_{n}]\\)</span> is the polynomial ring in <span\r\nclass=\"math inline\">\\(n\\)</span> variables over a field <span\r\nclass=\"math inline\">\\(k\\)</span> of characteristic zero. If <span\r\nclass=\"math inline\">\\(\\Delta_{n}\\)</span> is the <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}]\\)</span>-derivation of <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span> defined by\r\n<span class=\"math inline\">\\(\\Delta_{n}(x_{i}) = y_{i}\\)</span> for <span\r\nclass=\"math inline\">\\(i = 1, \\cdots, n\\)</span>, then <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> is generated by <span\r\nclass=\"math inline\">\\(L^{\\Delta_{n}}_{ij}\\)</span> for <span\r\nclass=\"math inline\">\\(1  i &lt; j  n\\)</span> over <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}]\\)</span>.</p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<p>We prove the conjecture by induction on <span\r\nclass=\"math inline\">\\(n\\)</span>. The assertion is clear when <span\r\nclass=\"math inline\">\\(n = 1\\)</span>. Assume that <span\r\nclass=\"math inline\">\\(n \\geq 2\\)</span>, and let <span\r\nclass=\"math inline\">\\(S_{l}\\)</span> be the set of <span\r\nclass=\"math inline\">\\(L_{i,j} := L^{\\Delta_{n}}_{i,j}\\)</span> for <span\r\nclass=\"math inline\">\\(1 \\leq i &lt; j \\leq l\\)</span> for each <span\r\nclass=\"math inline\">\\(l \\leq n\\)</span>. By the assumption on induction,\r\n<span class=\"math inline\">\\(\\ker \\Delta_{n-1}\\)</span> is generated by\r\n<span class=\"math inline\">\\(S_{n-1}\\)</span> over <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\prime}] := k[y_{1}, \\cdots ,\r\ny_{n-1}]\\)</span>, since <span\r\nclass=\"math inline\">\\(L^{\\Delta_{n-1}}_{i,j} =\r\nL^{\\Delta_{n}}_{i,j}\\)</span> for each <span class=\"math inline\">\\(i,\r\nj\\)</span>. As discussed in Section 1, the <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\prime}]\\)</span>-derivation <span\r\nclass=\"math inline\">\\(\\Delta_{n-1}\\)</span> naturally extends to a <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}]\\)</span>-derivation <span\r\nclass=\"math inline\">\\((\\Delta_{n-1})_{k[\\mathbf{y}]}\\)</span> of <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}^{\\prime}] :=\r\nk[\\mathbf{y}][x_{1}, \\cdots, x_{n-1}]\\)</span>. Then, <span\r\nclass=\"math inline\">\\((\\Delta_{n-1})k[\\mathbf{y}] =\r\n\\Delta_{n}|_{k[\\mathbf{y}][\\mathbf{x}^{\\prime}]}\\)</span>, so we have\r\n<span class=\"math inline\">\\(\\ker(\\Delta_{n-1})k[\\mathbf{y}] =\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n}\\)</span>.\r\nMoreover, <span class=\"math inline\">\\(\\ker(\\Delta_{n-1})k[\\mathbf{y}] =\r\nk[\\mathbf{y}] \\otimes_{k[\\mathbf{y}^{\\prime}]} \\ker\r\n\\Delta_{n-1}\\)</span>, since <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}]\\)</span> is flat over <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\prime}]\\)</span>. Thus, we get</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n} =\r\nk[\\mathbf{y}][S_{n-1}].\r\n\\end{equation}\\]</span></p>\r\n<p>Let <span class=\"math inline\">\\(\\mathbf{e}_{1}, \\cdots ,\r\n\\mathbf{e}_{n}\\)</span> be the coordinate unit vectors of <span\r\nclass=\"math inline\">\\(\\mathbb{R}^{n}\\)</span>, <span\r\nclass=\"math inline\">\\(M\\)</span> the <span\r\nclass=\"math inline\">\\(\\mathbb{Z}\\)</span>-submodule of <span\r\nclass=\"math inline\">\\((\\mathbb{Z}^{n})^{2}\\)</span> generated by <span\r\nclass=\"math inline\">\\((\\mathbf{e}_{j} - \\mathbf{e}_{i}, \\mathbf{e}_{i} -\r\n\\mathbf{e}_{j})\\)</span> for <span class=\"math inline\">\\(1 \\leq i &lt; j\r\n\\leq n\\)</span>, and <span class=\"math inline\">\\(\\Gamma =\r\n(\\mathbb{Z}^{n})^{2}/M\\)</span>. Then, <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span>-gradings are defined on <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span> and <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}] :=\r\nk[\\mathbf{y}][\\mathbf{x}][(y_{1} \\cdots y_{n})^{-1}]\\)</span> as\r\nfollows. Here, a <span class=\"math inline\">\\(k\\)</span>-algebra <span\r\nclass=\"math inline\">\\(R\\)</span> is said to be <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span>-graded if there exists a <span\r\nclass=\"math inline\">\\(k\\)</span>-vector subspace <span\r\nclass=\"math inline\">\\(R_{\\gamma}\\)</span> of <span\r\nclass=\"math inline\">\\(R\\)</span> for each <span\r\nclass=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span> such that <span\r\nclass=\"math inline\">\\(R = \\oplus_{\\gamma \\in \\Gamma} R_{\\gamma}\\)</span>\r\nand <span class=\"math inline\">\\(R_{\\gamma} R_{\\mu} \\subset R_{\\gamma +\r\n\\mu}\\)</span> for <span class=\"math inline\">\\(\\gamma, \\mu \\in\r\n\\Gamma\\)</span>. Let <span class=\"math inline\">\\(\\mathbb{Z}_{\\geq\r\n0}\\)</span> denote the set of nonnegative integers, and <span\r\nclass=\"math inline\">\\(\\mathbf{y}^{a} = y^{a_{1}} \\cdots\r\ny^{a_{n}}\\)</span> and <span class=\"math inline\">\\(\\mathbf{x}_{b} =\r\nx^{b_{1}} \\cdots x^{b_{n}}\\)</span> for <span class=\"math inline\">\\(a =\r\n(a_{1}, \\cdots , a_{n})\\)</span> and <span class=\"math inline\">\\(b =\r\n(b_{1}, \\cdots , b_{n})\\)</span>. For each <span\r\nclass=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span>, we define <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma}\\)</span> (resp.\r\n<span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\gamma}\\)</span>) to be the <span\r\nclass=\"math inline\">\\(k\\)</span>-vector space generated by <span\r\nclass=\"math inline\">\\(\\mathbf{y}^{a}\\mathbf{x}^{b}\\)</span> for $a, b\r\n(_{})^{n} (resp. <span class=\"math inline\">\\(a \\in \\mathbb{Z}^{n}, b \\in\r\n(\\mathbb{Z}_{\\geq 0})^{n}\\)</span>) such that the image of <span\r\nclass=\"math inline\">\\((a, b)\\)</span> in <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span> is equal to <span\r\nclass=\"math inline\">\\(\\gamma\\)</span>. Then, <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span>-gradings are defined on <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span> and <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]\\)</span>. Note\r\nthat <span\r\nclass=\"math inline\">\\(\\Delta_{n}(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma})\\)</span>\r\nis contained in <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma -\r\n\\delta}\\)</span> for each <span class=\"math inline\">\\(\\gamma \\in\r\n\\Gamma\\)</span>, where <span class=\"math inline\">\\(\\delta\\)</span> is\r\nthe image of <span class=\"math inline\">\\((-\\mathbb{e}_{n},\r\n\\mathbb{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span>.\r\nFrom this, we know that</p>\r\n<p><span class=\"math display\">\\[\\ker \\Delta_{n} = \\bigoplus_{\\gamma \\in\r\n\\Gamma} k[\\mathbf{y}] [ \\mathbf{x}]_{\\gamma} \\cap \\ker\r\n\\Delta_{n}\\]</span></p>\r\n<p>Hence, we are reduced to showing that each <span\r\nclass=\"math inline\">\\(0 \\neq \\varPhi \\in\r\nk[\\mathbf{y}][\\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}\\)</span> belongs\r\nto <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> for <span\r\nclass=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span>. We may find <span\r\nclass=\"math inline\">\\(a = (a_{1}, \\cdots , a_{n}) \\in\r\n\\mathbb{Z}^{n}\\)</span> and <span class=\"math inline\">\\(l \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> such that the image of <span\r\nclass=\"math inline\">\\((a, l\\mathbf{e}_{n})\\)</span> in <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span> is equal to <span\r\nclass=\"math inline\">\\(\\gamma\\)</span>. Let <span\r\nclass=\"math inline\">\\(m\\)</span> be the <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degree of <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span>, where <span\r\nclass=\"math inline\">\\(0 \\leq m \\leq l\\)</span>, and <span\r\nclass=\"math inline\">\\(\\phi \\in\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}]\\)</span> the coefficient of <span\r\nclass=\"math inline\">\\(x_{n}^{m}\\)</span> in <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span>. Then, <span\r\nclass=\"math inline\">\\(\\phi\\)</span> belongs to <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\mu}\\)</span>, where\r\n<span class=\"math inline\">\\(\\mu\\)</span> is the image of <span\r\nclass=\"math inline\">\\((a, (l m)\\mathbf{e}_{n})\\)</span> in <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span>. Furthermore, <span\r\nclass=\"math inline\">\\(0 = \\Delta_{n}(\\varPhi) =\r\n\\Delta_{n}(\\varphi)x^{m}_{n} + m\\phi y_{n}x_{n}^{m-1} +\r\n\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})\\)</span>, and the <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degrees of <span\r\nclass=\"math inline\">\\(m\\phi y_{n}x_{n}^{m-1}\\)</span> and <span\r\nclass=\"math inline\">\\(\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})\\)</span> are\r\nat most <span class=\"math inline\">\\(m - 1\\)</span>. Hence, <span\r\nclass=\"math inline\">\\(\\Delta_{n}(\\phi) = 0\\)</span>. Thus, <span\r\nclass=\"math inline\">\\(\\phi\\)</span> belongs to <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][S_{n-1}]\\)</span> by (1). Write\r\n<span class=\"math inline\">\\(\\phi = \\sum_{b,\\mathbf{u}}\r\nr^{\\prime}_{b,\\mathbf{u}}y^{b}\\hat{y}^{-\\mathbf{u}}L^{\\mathbf{u}}\\)</span>,\r\nwhere the sum is taken over <span class=\"math inline\">\\(b \\in\r\n(\\mathbb{Z}_{\\geq 0})^{n}\\)</span> and <span class=\"math inline\">\\(u =\r\n(u_{i,j})_{i,j}\\)</span> with <span class=\"math inline\">\\(u_{i,j} \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> for <span class=\"math inline\">\\(1 \\leq i\r\n&lt; j \\leq n - 1\\)</span>, <span\r\nclass=\"math inline\">\\(r^{\\prime}_{b,\\mathbf{u}} \\in k\\)</span> for each\r\n<span class=\"math inline\">\\(b\\)</span> and <span\r\nclass=\"math inline\">\\(\\mathbf{u}\\)</span>, and</p>\r\n<p><span class=\"math inline\">\\(\\hat{y}^{-u} = \\prod_{1\\leq i &lt; j \\leq\r\nn-1} (y_{i}y_{j})^{-u_{i,j}}, \\quad L^{\\mathbf{u}} = \\prod_{1 \\leq\r\ni&lt;j\\leq n-1} L_{i,j}^{u_{i,j}}\\)</span> for each <span\r\nclass=\"math inline\">\\(\\mathbf{U}\\)</span>.</p>\r\n<p>We may assume that <span\r\nclass=\"math inline\">\\(r_{b,\\mathbf{u}}^{\\prime} = 0\\)</span> if <span\r\nclass=\"math inline\">\\(\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}\\)</span>\r\nis not in <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>. Let <span\r\nclass=\"math inline\">\\(\\eta(b, \\mathbf{u})\\)</span> be the image of <span\r\nclass=\"math inline\">\\((b - |\\mathbf{u}|\\mathbf{e}_{n},\r\n|\\mathbf{u}|\\mathbf{e}_{n})\\)</span> in <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span>, where $|| = <em>{i,j} u</em>{i,j}\r\n$. Then, <span\r\nclass=\"math inline\">\\(\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}L^{\\mathbf{u}}\\)</span>\r\nbelongs to <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\eta(b,\\mathbf{u})}\\)</span> for each <span\r\nclass=\"math inline\">\\(b\\)</span> and <span\r\nclass=\"math inline\">\\(\\mathbf{u}\\)</span>, since <span\r\nclass=\"math inline\">\\((y_{i}y_{j})^{-1} L_{i,j}\\)</span> belongs to\r\n<span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\delta}\\)</span> for each <span\r\nclass=\"math inline\">\\(i, j\\)</span>. Since <span\r\nclass=\"math inline\">\\(\\phi\\)</span> is in <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\mu}\\)</span>, and\r\n<span class=\"math inline\">\\(\\mu\\)</span> is the image of <span\r\nclass=\"math inline\">\\((a, (l - m)\\mathbf{e}_{n})\\)</span>, we may assume\r\nthat <span class=\"math inline\">\\(r_{b,\\mathbf{u}}^{\\prime} = 0\\)</span>\r\nunless <span class=\"math inline\">\\(|u| = l - m\\)</span> and <span\r\nclass=\"math inline\">\\(b = a + (l - m)\\mathbf{e}_{n}\\)</span>. For each\r\n<span class=\"math inline\">\\(\\mathbf{u}\\)</span> with <span\r\nclass=\"math inline\">\\(r_{\\mathbf{u}} := r^{\\prime}_{a + (l-m)\r\n\\mathbf{e}_{n},\\mathbf{u}}\\neq 0\\)</span>, write <span\r\nclass=\"math inline\">\\(\\mathbf{y}^{a}y_{n}^{l-m}\\hat{y}^{-\\mathbf{u}} =\r\ny_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots y_{n-1}^{\\rho_{n-1}(\\mathbf{u})}\r\ny_{n}^{s}\\)</span>, where <span class=\"math inline\">\\(\\rho_{i}(u) \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> for <span class=\"math inline\">\\(i = 1,\r\n\\cdots , n - 1\\)</span>, and <span class=\"math inline\">\\(s = a_{n} + l -\r\nm\\)</span>. Then, we have <span class=\"math inline\">\\(\\phi =\r\ny_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})}\r\n\\cdots y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}\\)</span>. Since\r\n<span class=\"math inline\">\\(|u| = l - m\\)</span>, it follows that</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\r\n\\end{equation}\\]</span></p>\r\n<p>Now, we show that <span class=\"math inline\">\\(\\varPhi\\)</span>\r\nbelongs to <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> by\r\ncontradiction. By replacing <span class=\"math inline\">\\(\\varPhi\\)</span>\r\nif necessary, we may assume that <span class=\"math inline\">\\(m\\)</span>\r\nis the minimum among the <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degrees of elements of <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\backslash\r\nk[\\mathbf{y}][S_{n}]\\)</span>. To obtain a contradiction, it suffices to\r\ndeduce that</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm \\geq 2l - \\sum_{i=1}^{n-1} a_{i}\r\n\\end{equation}\\]</span></p>\r\n<p>In fact, (3) implies that <span\r\nclass=\"math inline\">\\(\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) \\geq\r\nm\\)</span> by (2), so we have <span\r\nclass=\"math inline\">\\(\\sum_{i=1}^{n-1}\\rho_{i}^{\\prime}(\\mathbf{u}) =\r\nm\\)</span> for some integers <span class=\"math inline\">\\(0 \\leq\r\n\\rho^{\\prime}_{i}(\\mathbf{u}) \\leq \\rho_{i}(\\mathbf{u})\\)</span> for\r\n<span class=\"math inline\">\\(i = 1, \\cdots, n - 1\\)</span> for each <span\r\nclass=\"math inline\">\\(u\\)</span>. Then,</p>\r\n<p><span class=\"math display\">\\[\\varPhi^{\\prime} := y_{n}^{s}\r\n\\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\ny_{i}^{\\rho_{i}(\\mathbf{u} - \\rho_{i}^{\\prime}(\\mathbf{u})}\r\nL_{n,i}^{\\rho_{i}^{\\prime}(\\mathbf{u}} = y_{n}^{s} \\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u} -\r\n\\rho_{i}^{\\prime}(\\mathbf{u} } (y_{i}x_{n}\r\nx_{n}y_{i})^{\\rho_{i}^{\\prime}(\\mathbf{u} }\\]</span></p>\r\n<p>is an element of <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> having <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degree <span\r\nclass=\"math inline\">\\(m\\)</span>, in which the coefficient of <span\r\nclass=\"math inline\">\\(x_{n}^{m}\\)</span> is equal to <span\r\nclass=\"math inline\">\\(\\phi\\)</span>. Hence, the <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degree of <span\r\nclass=\"math inline\">\\(\\varPhi - \\varPhi^{\\prime}\\)</span> is less than\r\n<span class=\"math inline\">\\(m\\)</span>. Since <span\r\nclass=\"math inline\">\\(\\varPhi - \\varPhi^{\\prime}\\)</span> is an element\r\nof <span class=\"math inline\">\\(\\ker \\Delta_{n} \\backslash\r\nk[\\mathbf{y}][S_{n}]\\)</span>, this contradicts the minimality of <span\r\nclass=\"math inline\">\\(m\\)</span>.</p>\r\n<p>We establish that (3) holds for any nonzero homogeneous element <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span> of <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> by contradiction. Take\r\n<span class=\"math inline\">\\(\\varPhi\\)</span> which does not satisfy (3)\r\nso that <span class=\"math inline\">\\(m\\)</span> would be the minimum\r\namong the <span class=\"math inline\">\\(x_{n}\\)</span>-degrees of such\r\npolynomials. Then, <span class=\"math inline\">\\(t:= 2l -\r\n\\sum_{i=1}^{n-1}a_{i} -m\\)</span> is positive, and <span\r\nclass=\"math inline\">\\(\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) = m -\r\nt\\)</span> for each <span class=\"math inline\">\\(\\mathbf{u}\\)</span> by\r\n(2). Hence, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree of</p>\r\n<p><span class=\"math display\">\\[\\varPhi_{1}:= \\sum_{\\mathbf{u}}\r\n\\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\nL_{n,i}^{\\rho_{i}(\\mathbf{u})} = \\sum_{\\mathbf{u}} r_{\\mathbf{u}}\r\nL^{\\mathbf{u}} \\prod_{i=1}^{n-1} (y_{i}x_{n} -\r\ny_{n}x_{i})^{\\rho_{i}(\\mathbf{u})}\\]</span></p>\r\n<p>is <span class=\"math inline\">\\(m - t\\)</span>. The coefficient of\r\n<span class=\"math inline\">\\(x_{n}^{n-t}\\)</span> in <span\r\nclass=\"math inline\">\\(y_{n}^{s}\\varPhi_{1}\\)</span> is equal to <span\r\nclass=\"math inline\">\\(\\phi\\)</span>, so the coefficient of <span\r\nclass=\"math inline\">\\(x_{n}^{m}\\)</span> in <span\r\nclass=\"math inline\">\\(y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span> is equal\r\nto that in <span class=\"math inline\">\\(y_{1}^{t}\\varPhi\\)</span>.\r\nConsequently, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree\r\n<span class=\"math inline\">\\(m^{\\prime}\\)</span> of <span\r\nclass=\"math inline\">\\(\\varPhi_{2}:= y_{1}^{t}\\varPhi -\r\ny_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span> is less than <span\r\nclass=\"math inline\">\\(m\\)</span>. We claim that <span\r\nclass=\"math inline\">\\(\\varPhi_{2} = 0\\)</span>. In fact, if <span\r\nclass=\"math inline\">\\(\\gamma^{\\prime}\\)</span> is the image of <span\r\nclass=\"math inline\">\\((a + t\\mathbf{e}_{1}, l\\mathbf{e}_{n})\\)</span> in\r\n<span class=\"math inline\">\\(\\Gamma\\)</span>, and <span\r\nclass=\"math inline\">\\((a^{\\prime}_{1}, \\cdots , a_{n}^{\\prime} ) := a +\r\nt\\mathbf{e}_{1}\\)</span>, then <span\r\nclass=\"math inline\">\\(\\varPhi_{2}\\)</span> belongs to <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma^{\\prime}} \\cap\r\n\\ker \\Delta_{n}\\)</span>, and</p>\r\n<p><span class=\"math display\">\\[2l - \\sum_{i=1}^{n-1} a^{\\prime}_{i} =\r\n2l - \\sum_{i=1}^{n-1} a_{i} - t = m &gt; m^{\\prime}\\]</span></p>\r\n<p>This implies that <span class=\"math inline\">\\(\\varPhi_{2} =\r\n0\\)</span> by the minimality of <span class=\"math inline\">\\(m\\)</span>.\r\nHence, <span class=\"math inline\">\\(y_{1}^{t} \\varPhi=\r\ny_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span>. Thus, <span\r\nclass=\"math inline\">\\(\\varPhi_{1}\\)</span> is divisible by <span\r\nclass=\"math inline\">\\(y_{1}\\)</span>, since neither are <span\r\nclass=\"math inline\">\\(y_{n}\\)</span> and <span\r\nclass=\"math inline\">\\(L_{n,1}\\)</span>. Recall that the kernel of a\r\nlocally nilpotent derivation <span class=\"math inline\">\\(D\\)</span> of\r\nan integral domain <span class=\"math inline\">\\(R\\)</span> containing\r\n<span class=\"math inline\">\\(Q\\)</span> is factorially closed in <span\r\nclass=\"math inline\">\\(R\\)</span>, that is, <span\r\nclass=\"math inline\">\\(D(f g) = 0\\)</span> implies <span\r\nclass=\"math inline\">\\(D(f ) = D(g) = 0\\)</span> for each <span\r\nclass=\"math inline\">\\(f, g \\in R \\ \\{0\\}\\)</span> (cf. [2, Proposition\r\n1.3.32 (iii)]). Note that <span\r\nclass=\"math inline\">\\(\\Delta_{n}\\)</span> is locally nilpotent, <span\r\nclass=\"math inline\">\\(\\Delta_{n}(\\varPhi_{1}) = 0\\)</span>, <span\r\nclass=\"math inline\">\\(\\varPhi_{1} \\neq 0\\)</span> and <span\r\nclass=\"math inline\">\\(\\Delta_{n}(x_{n}) \\neq 0\\)</span>. Hence, <span\r\nclass=\"math inline\">\\(\\varPhi_{1}\\)</span> is not divisible by <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>. By substituting zero for <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>, we obtain from <span\r\nclass=\"math inline\">\\(\\varPhi_{1}\\)</span> a nonzero polynomial</p>\r\n<p><span class=\"math display\">\\[\\sum_{\\mathbf{u}}r_{\\mathbf{u}}\r\nL^{\\mathbf{u}} \\prod_{i=1}^{n-1} (- y_{n} x_{i})^{\\rho_{i}(\\mathbf{u})}\r\n= ( - y_{n} )^{m-i} \\varPsi, \\text{ where } \\varPsi = \\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\nx_{i}^{\\rho_{i}(\\mathbf{u})}.\\]</span></p>\r\n<p>Then, <span class=\"math inline\">\\(\\varPhi \\neq 0\\)</span>, and <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span> is divisible by <span\r\nclass=\"math inline\">\\(y_{1}\\)</span>, since so is <span\r\nclass=\"math inline\">\\(\\phi_{1}\\)</span>. Define <span\r\nclass=\"math inline\">\\(\\sigma \\in \\text{Aut}_{k}\r\nk[\\mathbf{y}][\\mathbf{x}]\\)</span> by <span\r\nclass=\"math inline\">\\(\\sigma(x_{i}) = y_{i}\\)</span> and <span\r\nclass=\"math inline\">\\(\\sigma(y_{i}) = x_{i}\\)</span> for <span\r\nclass=\"math inline\">\\(i = 1, \\cdots, n\\)</span>. Then, <span\r\nclass=\"math inline\">\\(\\sigma(\\varPhi)\\)</span> is divisible by <span\r\nclass=\"math inline\">\\(x_{1}\\)</span>. On the other hand, <span\r\nclass=\"math inline\">\\(\\sigma(L_{i,j}) = L_{j,i}\\)</span> and <span\r\nclass=\"math inline\">\\(\\sigma(x_{i}) = y_{i}\\)</span> are in <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> for each <span\r\nclass=\"math inline\">\\(i, j\\)</span>, so <span\r\nclass=\"math inline\">\\(\\sigma(\\varPsi)\\)</span> belongs to <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span>. Thus, we have <span\r\nclass=\"math inline\">\\(\\sigma(\\varPsi) = 0\\)</span>, because <span\r\nclass=\"math inline\">\\(x_{1}\\)</span> is not in <span\r\nclass=\"math inline\">\\(\\ker \\Delta_[n]\\)</span> and <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> is factorially closed in\r\n<span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span>. This\r\ncontradicts that <span class=\"math inline\">\\(\\varPsi \\neq 0\\)</span>.\r\nTherefore, (3) holds true. Thereby, we have proved that <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span> belongs to <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span>. This completes the\r\nproof of the conjecture.</p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Nowicki, Andrzej. Polynomial derivations and their rings of\r\nconstants. Toru: Uniwersytet Mikolaja Kopernika, 1994.</p>\r\n<p>[2] Khoury, Joseph. Locally nilpotent derivations and their rings of\r\nconstants. University of Ottawa (Canada), 2001.</p>\r\n<p>[3] Kuroda, Shigeru. \"A Simple Proof of Nowicki's Conjecture on the\r\nKernel of an Elementary Derivation.\" Tokyo Journal of Mathematics 32.1\r\n(2009): 247-251.</p>\r\n<p>[4] Drensky V, Makar-Limanov L. The conjecture of Nowicki on\r\nWeitzenbck derivations of polynomial algebras[J]. Journal of Algebra\r\nand Its Applications, 2009, 8(01): 41-51.</p>\r\n<p>[5] Drensky, Vesselin. \"Another proof of the Nowicki conjecture.\"\r\nTokyo Journal of Mathematics 43.2 (2020): 537-542.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>Let <span class=\"math inline\">\\(A[\\mathbf{x}] = A[x_{1}, \\cdots,\r\nx_{n}\\)</span>] be the polynomial ring in n variables over an integral\r\ndomain <span class=\"math inline\">\\(A\\)</span>, <span\r\nclass=\"math inline\">\\(D\\)</span> an <span\r\nclass=\"math inline\">\\(A\\)</span>-<a\r\nhref=\"https://en.wikipedia.org/wiki/Derivation_(differential_algebra)\">derivation</a>\r\nof <span class=\"math inline\">\\(A[\\mathbf{x}]\\)</span> and denote <span\r\nclass=\"math display\">\\[D_{ij} := D(x_{i}) x_{j} - D(x_{j}) x_{i}, \\quad\r\n\\text{ for each } i, j \\in \\{1, \\cdots, n\\}.\\]</span></p>\r\n<h2 id=\"theorem-1-nowicki-1-conjecture-6.9.10\">Theorem 1 [Nowicki 1,\r\nConjecture 6.9.10]</h2>\r\n<p>Assume that <span class=\"math inline\">\\(k[\\mathbf{y}] = k[y_{1},\r\n\\cdots, y_{n}]\\)</span> is the polynomial ring in <span\r\nclass=\"math inline\">\\(n\\)</span> variables over a field <span\r\nclass=\"math inline\">\\(k\\)</span> of characteristic zero. If <span\r\nclass=\"math inline\">\\(\\Delta_{n}\\)</span> is the <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}]\\)</span>-derivation of <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span> defined by\r\n<span class=\"math inline\">\\(\\Delta_{n}(x_{i}) = y_{i}\\)</span> for <span\r\nclass=\"math inline\">\\(i = 1, \\cdots, n\\)</span>, then <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> is generated by <span\r\nclass=\"math inline\">\\(L^{\\Delta_{n}}_{ij}\\)</span> for <span\r\nclass=\"math inline\">\\(1  i &lt; j  n\\)</span> over <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}]\\)</span>.</p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<p>We prove the conjecture by induction on <span\r\nclass=\"math inline\">\\(n\\)</span>. The assertion is clear when <span\r\nclass=\"math inline\">\\(n = 1\\)</span>. Assume that <span\r\nclass=\"math inline\">\\(n \\geq 2\\)</span>, and let <span\r\nclass=\"math inline\">\\(S_{l}\\)</span> be the set of <span\r\nclass=\"math inline\">\\(L_{i,j} := L^{\\Delta_{n}}_{i,j}\\)</span> for <span\r\nclass=\"math inline\">\\(1 \\leq i &lt; j \\leq l\\)</span> for each <span\r\nclass=\"math inline\">\\(l \\leq n\\)</span>. By the assumption on induction,\r\n<span class=\"math inline\">\\(\\ker \\Delta_{n-1}\\)</span> is generated by\r\n<span class=\"math inline\">\\(S_{n-1}\\)</span> over <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\prime}] := k[y_{1}, \\cdots ,\r\ny_{n-1}]\\)</span>, since <span\r\nclass=\"math inline\">\\(L^{\\Delta_{n-1}}_{i,j} =\r\nL^{\\Delta_{n}}_{i,j}\\)</span> for each <span class=\"math inline\">\\(i,\r\nj\\)</span>. As discussed in Section 1, the <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\prime}]\\)</span>-derivation <span\r\nclass=\"math inline\">\\(\\Delta_{n-1}\\)</span> naturally extends to a <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}]\\)</span>-derivation <span\r\nclass=\"math inline\">\\((\\Delta_{n-1})_{k[\\mathbf{y}]}\\)</span> of <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}^{\\prime}] :=\r\nk[\\mathbf{y}][x_{1}, \\cdots, x_{n-1}]\\)</span>. Then, <span\r\nclass=\"math inline\">\\((\\Delta_{n-1})k[\\mathbf{y}] =\r\n\\Delta_{n}|_{k[\\mathbf{y}][\\mathbf{x}^{\\prime}]}\\)</span>, so we have\r\n<span class=\"math inline\">\\(\\ker(\\Delta_{n-1})k[\\mathbf{y}] =\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n}\\)</span>.\r\nMoreover, <span class=\"math inline\">\\(\\ker(\\Delta_{n-1})k[\\mathbf{y}] =\r\nk[\\mathbf{y}] \\otimes_{k[\\mathbf{y}^{\\prime}]} \\ker\r\n\\Delta_{n-1}\\)</span>, since <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}]\\)</span> is flat over <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\prime}]\\)</span>. Thus, we get</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n} =\r\nk[\\mathbf{y}][S_{n-1}].\r\n\\end{equation}\\]</span></p>\r\n<p>Let <span class=\"math inline\">\\(\\mathbf{e}_{1}, \\cdots ,\r\n\\mathbf{e}_{n}\\)</span> be the coordinate unit vectors of <span\r\nclass=\"math inline\">\\(\\mathbb{R}^{n}\\)</span>, <span\r\nclass=\"math inline\">\\(M\\)</span> the <span\r\nclass=\"math inline\">\\(\\mathbb{Z}\\)</span>-submodule of <span\r\nclass=\"math inline\">\\((\\mathbb{Z}^{n})^{2}\\)</span> generated by <span\r\nclass=\"math inline\">\\((\\mathbf{e}_{j} - \\mathbf{e}_{i}, \\mathbf{e}_{i} -\r\n\\mathbf{e}_{j})\\)</span> for <span class=\"math inline\">\\(1 \\leq i &lt; j\r\n\\leq n\\)</span>, and <span class=\"math inline\">\\(\\Gamma =\r\n(\\mathbb{Z}^{n})^{2}/M\\)</span>. Then, <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span>-gradings are defined on <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span> and <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}] :=\r\nk[\\mathbf{y}][\\mathbf{x}][(y_{1} \\cdots y_{n})^{-1}]\\)</span> as\r\nfollows. Here, a <span class=\"math inline\">\\(k\\)</span>-algebra <span\r\nclass=\"math inline\">\\(R\\)</span> is said to be <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span>-graded if there exists a <span\r\nclass=\"math inline\">\\(k\\)</span>-vector subspace <span\r\nclass=\"math inline\">\\(R_{\\gamma}\\)</span> of <span\r\nclass=\"math inline\">\\(R\\)</span> for each <span\r\nclass=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span> such that <span\r\nclass=\"math inline\">\\(R = \\oplus_{\\gamma \\in \\Gamma} R_{\\gamma}\\)</span>\r\nand <span class=\"math inline\">\\(R_{\\gamma} R_{\\mu} \\subset R_{\\gamma +\r\n\\mu}\\)</span> for <span class=\"math inline\">\\(\\gamma, \\mu \\in\r\n\\Gamma\\)</span>. Let <span class=\"math inline\">\\(\\mathbb{Z}_{\\geq\r\n0}\\)</span> denote the set of nonnegative integers, and <span\r\nclass=\"math inline\">\\(\\mathbf{y}^{a} = y^{a_{1}} \\cdots\r\ny^{a_{n}}\\)</span> and <span class=\"math inline\">\\(\\mathbf{x}_{b} =\r\nx^{b_{1}} \\cdots x^{b_{n}}\\)</span> for <span class=\"math inline\">\\(a =\r\n(a_{1}, \\cdots , a_{n})\\)</span> and <span class=\"math inline\">\\(b =\r\n(b_{1}, \\cdots , b_{n})\\)</span>. For each <span\r\nclass=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span>, we define <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma}\\)</span> (resp.\r\n<span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\gamma}\\)</span>) to be the <span\r\nclass=\"math inline\">\\(k\\)</span>-vector space generated by <span\r\nclass=\"math inline\">\\(\\mathbf{y}^{a}\\mathbf{x}^{b}\\)</span> for $a, b\r\n(_{})^{n} (resp. <span class=\"math inline\">\\(a \\in \\mathbb{Z}^{n}, b \\in\r\n(\\mathbb{Z}_{\\geq 0})^{n}\\)</span>) such that the image of <span\r\nclass=\"math inline\">\\((a, b)\\)</span> in <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span> is equal to <span\r\nclass=\"math inline\">\\(\\gamma\\)</span>. Then, <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span>-gradings are defined on <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span> and <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]\\)</span>. Note\r\nthat <span\r\nclass=\"math inline\">\\(\\Delta_{n}(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma})\\)</span>\r\nis contained in <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma -\r\n\\delta}\\)</span> for each <span class=\"math inline\">\\(\\gamma \\in\r\n\\Gamma\\)</span>, where <span class=\"math inline\">\\(\\delta\\)</span> is\r\nthe image of <span class=\"math inline\">\\((-\\mathbb{e}_{n},\r\n\\mathbb{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span>.\r\nFrom this, we know that</p>\r\n<p><span class=\"math display\">\\[\\ker \\Delta_{n} = \\bigoplus_{\\gamma \\in\r\n\\Gamma} k[\\mathbf{y}] [ \\mathbf{x}]_{\\gamma} \\cap \\ker\r\n\\Delta_{n}\\]</span></p>\r\n<p>Hence, we are reduced to showing that each <span\r\nclass=\"math inline\">\\(0 \\neq \\varPhi \\in\r\nk[\\mathbf{y}][\\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}\\)</span> belongs\r\nto <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> for <span\r\nclass=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span>. We may find <span\r\nclass=\"math inline\">\\(a = (a_{1}, \\cdots , a_{n}) \\in\r\n\\mathbb{Z}^{n}\\)</span> and <span class=\"math inline\">\\(l \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> such that the image of <span\r\nclass=\"math inline\">\\((a, l\\mathbf{e}_{n})\\)</span> in <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span> is equal to <span\r\nclass=\"math inline\">\\(\\gamma\\)</span>. Let <span\r\nclass=\"math inline\">\\(m\\)</span> be the <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degree of <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span>, where <span\r\nclass=\"math inline\">\\(0 \\leq m \\leq l\\)</span>, and <span\r\nclass=\"math inline\">\\(\\phi \\in\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}]\\)</span> the coefficient of <span\r\nclass=\"math inline\">\\(x_{n}^{m}\\)</span> in <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span>. Then, <span\r\nclass=\"math inline\">\\(\\phi\\)</span> belongs to <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\mu}\\)</span>, where\r\n<span class=\"math inline\">\\(\\mu\\)</span> is the image of <span\r\nclass=\"math inline\">\\((a, (l m)\\mathbf{e}_{n})\\)</span> in <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span>. Furthermore, <span\r\nclass=\"math inline\">\\(0 = \\Delta_{n}(\\varPhi) =\r\n\\Delta_{n}(\\varphi)x^{m}_{n} + m\\phi y_{n}x_{n}^{m-1} +\r\n\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})\\)</span>, and the <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degrees of <span\r\nclass=\"math inline\">\\(m\\phi y_{n}x_{n}^{m-1}\\)</span> and <span\r\nclass=\"math inline\">\\(\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})\\)</span> are\r\nat most <span class=\"math inline\">\\(m - 1\\)</span>. Hence, <span\r\nclass=\"math inline\">\\(\\Delta_{n}(\\phi) = 0\\)</span>. Thus, <span\r\nclass=\"math inline\">\\(\\phi\\)</span> belongs to <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][S_{n-1}]\\)</span> by (1). Write\r\n<span class=\"math inline\">\\(\\phi = \\sum_{b,\\mathbf{u}}\r\nr^{\\prime}_{b,\\mathbf{u}}y^{b}\\hat{y}^{-\\mathbf{u}}L^{\\mathbf{u}}\\)</span>,\r\nwhere the sum is taken over <span class=\"math inline\">\\(b \\in\r\n(\\mathbb{Z}_{\\geq 0})^{n}\\)</span> and <span class=\"math inline\">\\(u =\r\n(u_{i,j})_{i,j}\\)</span> with <span class=\"math inline\">\\(u_{i,j} \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> for <span class=\"math inline\">\\(1 \\leq i\r\n&lt; j \\leq n - 1\\)</span>, <span\r\nclass=\"math inline\">\\(r^{\\prime}_{b,\\mathbf{u}} \\in k\\)</span> for each\r\n<span class=\"math inline\">\\(b\\)</span> and <span\r\nclass=\"math inline\">\\(\\mathbf{u}\\)</span>, and</p>\r\n<p><span class=\"math inline\">\\(\\hat{y}^{-u} = \\prod_{1\\leq i &lt; j \\leq\r\nn-1} (y_{i}y_{j})^{-u_{i,j}}, \\quad L^{\\mathbf{u}} = \\prod_{1 \\leq\r\ni&lt;j\\leq n-1} L_{i,j}^{u_{i,j}}\\)</span> for each <span\r\nclass=\"math inline\">\\(\\mathbf{U}\\)</span>.</p>\r\n<p>We may assume that <span\r\nclass=\"math inline\">\\(r_{b,\\mathbf{u}}^{\\prime} = 0\\)</span> if <span\r\nclass=\"math inline\">\\(\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}\\)</span>\r\nis not in <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>. Let <span\r\nclass=\"math inline\">\\(\\eta(b, \\mathbf{u})\\)</span> be the image of <span\r\nclass=\"math inline\">\\((b - |\\mathbf{u}|\\mathbf{e}_{n},\r\n|\\mathbf{u}|\\mathbf{e}_{n})\\)</span> in <span\r\nclass=\"math inline\">\\(\\Gamma\\)</span>, where $|| = <em>{i,j} u</em>{i,j}\r\n$. Then, <span\r\nclass=\"math inline\">\\(\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}L^{\\mathbf{u}}\\)</span>\r\nbelongs to <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\eta(b,\\mathbf{u})}\\)</span> for each <span\r\nclass=\"math inline\">\\(b\\)</span> and <span\r\nclass=\"math inline\">\\(\\mathbf{u}\\)</span>, since <span\r\nclass=\"math inline\">\\((y_{i}y_{j})^{-1} L_{i,j}\\)</span> belongs to\r\n<span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\delta}\\)</span> for each <span\r\nclass=\"math inline\">\\(i, j\\)</span>. Since <span\r\nclass=\"math inline\">\\(\\phi\\)</span> is in <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\mu}\\)</span>, and\r\n<span class=\"math inline\">\\(\\mu\\)</span> is the image of <span\r\nclass=\"math inline\">\\((a, (l - m)\\mathbf{e}_{n})\\)</span>, we may assume\r\nthat <span class=\"math inline\">\\(r_{b,\\mathbf{u}}^{\\prime} = 0\\)</span>\r\nunless <span class=\"math inline\">\\(|u| = l - m\\)</span> and <span\r\nclass=\"math inline\">\\(b = a + (l - m)\\mathbf{e}_{n}\\)</span>. For each\r\n<span class=\"math inline\">\\(\\mathbf{u}\\)</span> with <span\r\nclass=\"math inline\">\\(r_{\\mathbf{u}} := r^{\\prime}_{a + (l-m)\r\n\\mathbf{e}_{n},\\mathbf{u}}\\neq 0\\)</span>, write <span\r\nclass=\"math inline\">\\(\\mathbf{y}^{a}y_{n}^{l-m}\\hat{y}^{-\\mathbf{u}} =\r\ny_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots y_{n-1}^{\\rho_{n-1}(\\mathbf{u})}\r\ny_{n}^{s}\\)</span>, where <span class=\"math inline\">\\(\\rho_{i}(u) \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> for <span class=\"math inline\">\\(i = 1,\r\n\\cdots , n - 1\\)</span>, and <span class=\"math inline\">\\(s = a_{n} + l -\r\nm\\)</span>. Then, we have <span class=\"math inline\">\\(\\phi =\r\ny_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})}\r\n\\cdots y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}\\)</span>. Since\r\n<span class=\"math inline\">\\(|u| = l - m\\)</span>, it follows that</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\r\n\\end{equation}\\]</span></p>\r\n<p>Now, we show that <span class=\"math inline\">\\(\\varPhi\\)</span>\r\nbelongs to <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> by\r\ncontradiction. By replacing <span class=\"math inline\">\\(\\varPhi\\)</span>\r\nif necessary, we may assume that <span class=\"math inline\">\\(m\\)</span>\r\nis the minimum among the <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degrees of elements of <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\backslash\r\nk[\\mathbf{y}][S_{n}]\\)</span>. To obtain a contradiction, it suffices to\r\ndeduce that</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm \\geq 2l - \\sum_{i=1}^{n-1} a_{i}\r\n\\end{equation}\\]</span></p>\r\n<p>In fact, (3) implies that <span\r\nclass=\"math inline\">\\(\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) \\geq\r\nm\\)</span> by (2), so we have <span\r\nclass=\"math inline\">\\(\\sum_{i=1}^{n-1}\\rho_{i}^{\\prime}(\\mathbf{u}) =\r\nm\\)</span> for some integers <span class=\"math inline\">\\(0 \\leq\r\n\\rho^{\\prime}_{i}(\\mathbf{u}) \\leq \\rho_{i}(\\mathbf{u})\\)</span> for\r\n<span class=\"math inline\">\\(i = 1, \\cdots, n - 1\\)</span> for each <span\r\nclass=\"math inline\">\\(u\\)</span>. Then,</p>\r\n<p><span class=\"math display\">\\[\\varPhi^{\\prime} := y_{n}^{s}\r\n\\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\ny_{i}^{\\rho_{i}(\\mathbf{u} - \\rho_{i}^{\\prime}(\\mathbf{u})}\r\nL_{n,i}^{\\rho_{i}^{\\prime}(\\mathbf{u}} = y_{n}^{s} \\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u} -\r\n\\rho_{i}^{\\prime}(\\mathbf{u} } (y_{i}x_{n}\r\nx_{n}y_{i})^{\\rho_{i}^{\\prime}(\\mathbf{u} }\\]</span></p>\r\n<p>is an element of <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> having <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degree <span\r\nclass=\"math inline\">\\(m\\)</span>, in which the coefficient of <span\r\nclass=\"math inline\">\\(x_{n}^{m}\\)</span> is equal to <span\r\nclass=\"math inline\">\\(\\phi\\)</span>. Hence, the <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>-degree of <span\r\nclass=\"math inline\">\\(\\varPhi - \\varPhi^{\\prime}\\)</span> is less than\r\n<span class=\"math inline\">\\(m\\)</span>. Since <span\r\nclass=\"math inline\">\\(\\varPhi - \\varPhi^{\\prime}\\)</span> is an element\r\nof <span class=\"math inline\">\\(\\ker \\Delta_{n} \\backslash\r\nk[\\mathbf{y}][S_{n}]\\)</span>, this contradicts the minimality of <span\r\nclass=\"math inline\">\\(m\\)</span>.</p>\r\n<p>We establish that (3) holds for any nonzero homogeneous element <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span> of <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> by contradiction. Take\r\n<span class=\"math inline\">\\(\\varPhi\\)</span> which does not satisfy (3)\r\nso that <span class=\"math inline\">\\(m\\)</span> would be the minimum\r\namong the <span class=\"math inline\">\\(x_{n}\\)</span>-degrees of such\r\npolynomials. Then, <span class=\"math inline\">\\(t:= 2l -\r\n\\sum_{i=1}^{n-1}a_{i} -m\\)</span> is positive, and <span\r\nclass=\"math inline\">\\(\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) = m -\r\nt\\)</span> for each <span class=\"math inline\">\\(\\mathbf{u}\\)</span> by\r\n(2). Hence, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree of</p>\r\n<p><span class=\"math display\">\\[\\varPhi_{1}:= \\sum_{\\mathbf{u}}\r\n\\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\nL_{n,i}^{\\rho_{i}(\\mathbf{u})} = \\sum_{\\mathbf{u}} r_{\\mathbf{u}}\r\nL^{\\mathbf{u}} \\prod_{i=1}^{n-1} (y_{i}x_{n} -\r\ny_{n}x_{i})^{\\rho_{i}(\\mathbf{u})}\\]</span></p>\r\n<p>is <span class=\"math inline\">\\(m - t\\)</span>. The coefficient of\r\n<span class=\"math inline\">\\(x_{n}^{n-t}\\)</span> in <span\r\nclass=\"math inline\">\\(y_{n}^{s}\\varPhi_{1}\\)</span> is equal to <span\r\nclass=\"math inline\">\\(\\phi\\)</span>, so the coefficient of <span\r\nclass=\"math inline\">\\(x_{n}^{m}\\)</span> in <span\r\nclass=\"math inline\">\\(y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span> is equal\r\nto that in <span class=\"math inline\">\\(y_{1}^{t}\\varPhi\\)</span>.\r\nConsequently, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree\r\n<span class=\"math inline\">\\(m^{\\prime}\\)</span> of <span\r\nclass=\"math inline\">\\(\\varPhi_{2}:= y_{1}^{t}\\varPhi -\r\ny_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span> is less than <span\r\nclass=\"math inline\">\\(m\\)</span>. We claim that <span\r\nclass=\"math inline\">\\(\\varPhi_{2} = 0\\)</span>. In fact, if <span\r\nclass=\"math inline\">\\(\\gamma^{\\prime}\\)</span> is the image of <span\r\nclass=\"math inline\">\\((a + t\\mathbf{e}_{1}, l\\mathbf{e}_{n})\\)</span> in\r\n<span class=\"math inline\">\\(\\Gamma\\)</span>, and <span\r\nclass=\"math inline\">\\((a^{\\prime}_{1}, \\cdots , a_{n}^{\\prime} ) := a +\r\nt\\mathbf{e}_{1}\\)</span>, then <span\r\nclass=\"math inline\">\\(\\varPhi_{2}\\)</span> belongs to <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma^{\\prime}} \\cap\r\n\\ker \\Delta_{n}\\)</span>, and</p>\r\n<p><span class=\"math display\">\\[2l - \\sum_{i=1}^{n-1} a^{\\prime}_{i} =\r\n2l - \\sum_{i=1}^{n-1} a_{i} - t = m &gt; m^{\\prime}\\]</span></p>\r\n<p>This implies that <span class=\"math inline\">\\(\\varPhi_{2} =\r\n0\\)</span> by the minimality of <span class=\"math inline\">\\(m\\)</span>.\r\nHence, <span class=\"math inline\">\\(y_{1}^{t} \\varPhi=\r\ny_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span>. Thus, <span\r\nclass=\"math inline\">\\(\\varPhi_{1}\\)</span> is divisible by <span\r\nclass=\"math inline\">\\(y_{1}\\)</span>, since neither are <span\r\nclass=\"math inline\">\\(y_{n}\\)</span> and <span\r\nclass=\"math inline\">\\(L_{n,1}\\)</span>. Recall that the kernel of a\r\nlocally nilpotent derivation <span class=\"math inline\">\\(D\\)</span> of\r\nan integral domain <span class=\"math inline\">\\(R\\)</span> containing\r\n<span class=\"math inline\">\\(Q\\)</span> is factorially closed in <span\r\nclass=\"math inline\">\\(R\\)</span>, that is, <span\r\nclass=\"math inline\">\\(D(f g) = 0\\)</span> implies <span\r\nclass=\"math inline\">\\(D(f ) = D(g) = 0\\)</span> for each <span\r\nclass=\"math inline\">\\(f, g \\in R \\ \\{0\\}\\)</span> (cf. [2, Proposition\r\n1.3.32 (iii)]). Note that <span\r\nclass=\"math inline\">\\(\\Delta_{n}\\)</span> is locally nilpotent, <span\r\nclass=\"math inline\">\\(\\Delta_{n}(\\varPhi_{1}) = 0\\)</span>, <span\r\nclass=\"math inline\">\\(\\varPhi_{1} \\neq 0\\)</span> and <span\r\nclass=\"math inline\">\\(\\Delta_{n}(x_{n}) \\neq 0\\)</span>. Hence, <span\r\nclass=\"math inline\">\\(\\varPhi_{1}\\)</span> is not divisible by <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>. By substituting zero for <span\r\nclass=\"math inline\">\\(x_{n}\\)</span>, we obtain from <span\r\nclass=\"math inline\">\\(\\varPhi_{1}\\)</span> a nonzero polynomial</p>\r\n<p><span class=\"math display\">\\[\\sum_{\\mathbf{u}}r_{\\mathbf{u}}\r\nL^{\\mathbf{u}} \\prod_{i=1}^{n-1} (- y_{n} x_{i})^{\\rho_{i}(\\mathbf{u})}\r\n= ( - y_{n} )^{m-i} \\varPsi, \\text{ where } \\varPsi = \\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\nx_{i}^{\\rho_{i}(\\mathbf{u})}.\\]</span></p>\r\n<p>Then, <span class=\"math inline\">\\(\\varPhi \\neq 0\\)</span>, and <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span> is divisible by <span\r\nclass=\"math inline\">\\(y_{1}\\)</span>, since so is <span\r\nclass=\"math inline\">\\(\\phi_{1}\\)</span>. Define <span\r\nclass=\"math inline\">\\(\\sigma \\in \\text{Aut}_{k}\r\nk[\\mathbf{y}][\\mathbf{x}]\\)</span> by <span\r\nclass=\"math inline\">\\(\\sigma(x_{i}) = y_{i}\\)</span> and <span\r\nclass=\"math inline\">\\(\\sigma(y_{i}) = x_{i}\\)</span> for <span\r\nclass=\"math inline\">\\(i = 1, \\cdots, n\\)</span>. Then, <span\r\nclass=\"math inline\">\\(\\sigma(\\varPhi)\\)</span> is divisible by <span\r\nclass=\"math inline\">\\(x_{1}\\)</span>. On the other hand, <span\r\nclass=\"math inline\">\\(\\sigma(L_{i,j}) = L_{j,i}\\)</span> and <span\r\nclass=\"math inline\">\\(\\sigma(x_{i}) = y_{i}\\)</span> are in <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> for each <span\r\nclass=\"math inline\">\\(i, j\\)</span>, so <span\r\nclass=\"math inline\">\\(\\sigma(\\varPsi)\\)</span> belongs to <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span>. Thus, we have <span\r\nclass=\"math inline\">\\(\\sigma(\\varPsi) = 0\\)</span>, because <span\r\nclass=\"math inline\">\\(x_{1}\\)</span> is not in <span\r\nclass=\"math inline\">\\(\\ker \\Delta_[n]\\)</span> and <span\r\nclass=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> is factorially closed in\r\n<span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span>. This\r\ncontradicts that <span class=\"math inline\">\\(\\varPsi \\neq 0\\)</span>.\r\nTherefore, (3) holds true. Thereby, we have proved that <span\r\nclass=\"math inline\">\\(\\varPhi\\)</span> belongs to <span\r\nclass=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span>. This completes the\r\nproof of the conjecture.</p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Nowicki, Andrzej. Polynomial derivations and their rings of\r\nconstants. Toru: Uniwersytet Mikolaja Kopernika, 1994.</p>\r\n<p>[2] Khoury, Joseph. Locally nilpotent derivations and their rings of\r\nconstants. University of Ottawa (Canada), 2001.</p>\r\n<p>[3] Kuroda, Shigeru. \"A Simple Proof of Nowicki's Conjecture on the\r\nKernel of an Elementary Derivation.\" Tokyo Journal of Mathematics 32.1\r\n(2009): 247-251.</p>\r\n<p>[4] Drensky V, Makar-Limanov L. The conjecture of Nowicki on\r\nWeitzenbck derivations of polynomial algebras[J]. Journal of Algebra\r\nand Its Applications, 2009, 8(01): 41-51.</p>\r\n<p>[5] Drensky, Vesselin. \"Another proof of the Nowicki conjecture.\"\r\nTokyo Journal of Mathematics 43.2 (2020): 537-542.</p>\r\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clqxisun30001eslrcdjf7im4","category_id":"clqxisunb0007eslr6fiq5jrz","_id":"clqxisuni000leslr5zmohphu"},{"post_id":"clqxisuna0006eslrcshz8z53","category_id":"clqxisunb0007eslr6fiq5jrz","_id":"clqxisunm000weslr69jqaz40"},{"post_id":"clqxisunk000peslr00vhh8qp","category_id":"clqxisunj000oeslr6e9r404q","_id":"clqxisuno0012eslr4xna3v8c"},{"post_id":"clqxisunc0009eslr5s2kaohh","category_id":"clqxisunj000oeslr6e9r404q","_id":"clqxisunp0015eslrdk2dg3i6"},{"post_id":"clqxisunm000veslrhi4y162t","category_id":"clqxisunj000oeslr6e9r404q","_id":"clqxisunq0019eslrdgozakrv"},{"post_id":"clqxisuno0011eslrha3c2p34","category_id":"clqxisunb0007eslr6fiq5jrz","_id":"clqxisuns001geslrap7e5n52"},{"post_id":"clqxisun70003eslrc1u30yul","category_id":"clqxisune000deslr98nlc8um","_id":"clqxisunu001oeslrh7bdgqyu"},{"post_id":"clqxisun70003eslrc1u30yul","category_id":"clqxisunq001aeslrf62q3ra3","_id":"clqxisunu001qeslrbre0e9cf"},{"post_id":"clqxisuns001jeslr2jz9bzlf","category_id":"clqxisunj000oeslr6e9r404q","_id":"clqxisunu001teslr7obi3h8l"},{"post_id":"clqxisuni000keslrgz1rbv5i","category_id":"clqxisunt001meslr7bo62wmk","_id":"clqxisunv001yeslr97tyeqs4"},{"post_id":"clqxisunl000reslr4u5x2qli","category_id":"clqxisune000deslr98nlc8um","_id":"clqxisunw0025eslrc1jb5t3p"},{"post_id":"clqxisunl000reslr4u5x2qli","category_id":"clqxisunq001aeslrf62q3ra3","_id":"clqxisunw0027eslrdhz5enjc"},{"post_id":"clqxisunn000xeslr7o8q84gp","category_id":"clqxisunt001meslr7bo62wmk","_id":"clqxisunw0029eslrgjpoepp6"},{"post_id":"clqxisung000feslr1ljad569","category_id":"clqxisunn0010eslr6baxdgam","_id":"clqxisunx002deslr0zo5g1uh"},{"post_id":"clqxisung000feslr1ljad569","category_id":"clqxisunw0028eslr90xh6y3v","_id":"clqxisunx002eeslre2u9f429"},{"post_id":"clqxisuno0014eslr0cy04a5g","category_id":"clqxisunn0010eslr6baxdgam","_id":"clqxisunx002geslr481sa6ov"},{"post_id":"clqxisuno0014eslr0cy04a5g","category_id":"clqxisunw0028eslr90xh6y3v","_id":"clqxisunx002heslrhb5nhhub"},{"post_id":"clqxisunp0018eslr3eu7a6tc","category_id":"clqxisunx002ceslr78smcdkt","_id":"clqxisuny002jeslre176hf1w"},{"post_id":"clqxisung000geslrfc1cal5q","category_id":"clqxisunn0010eslr6baxdgam","_id":"clqxisuny002meslrfrezbdxp"},{"post_id":"clqxisung000geslrfc1cal5q","category_id":"clqxisunw0028eslr90xh6y3v","_id":"clqxisuny002neslrfdn68hw3"},{"post_id":"clqxisunj000meslr1cuy8ey9","category_id":"clqxisunj000oeslr6e9r404q","_id":"clqxisuny002peslrh9f04xhq"},{"post_id":"clqxisunj000meslr1cuy8ey9","category_id":"clqxisuny002keslrhug3dwr9","_id":"clqxisunz002qeslr78jy1hcp"},{"post_id":"clqxisune000beslrbdvkb483","category_id":"clqxisunj000oeslr6e9r404q","_id":"clqxisunz002reslr5sq1chiu"},{"post_id":"clqxisune000beslrbdvkb483","category_id":"clqxisunv0023eslrct6ghg41","_id":"clqxisunz002teslredjcc9z3"},{"post_id":"clqxisune000beslrbdvkb483","category_id":"clqxisuny002leslrbk6z28jd","_id":"clqxisunz002ueslrayqi5ldt"},{"post_id":"clqxisunq001ceslrf9tm9r5o","category_id":"clqxisunx002feslr3ug406we","_id":"clqxisunz002weslr8uv51pz6"},{"post_id":"clqxisunq001ceslrf9tm9r5o","category_id":"clqxisuny002oeslr33upaz82","_id":"clqxisunz002xeslrginlglut"},{"post_id":"clqxisunq001ceslrf9tm9r5o","category_id":"clqxisunz002seslrhgewd47w","_id":"clqxisunz002yeslrblo5clpa"},{"post_id":"clqxisunq001ceslrf9tm9r5o","category_id":"clqxisunz002veslre2sb5bbp","_id":"clqxisuo0002zeslrhd7a3ov9"}],"PostTag":[{"post_id":"clqxisun30001eslrcdjf7im4","tag_id":"clqxisun80004eslr2w878ukp","_id":"clqxisunf000eeslrgxmjaqh6"},{"post_id":"clqxisuna0006eslrcshz8z53","tag_id":"clqxisun80004eslr2w878ukp","_id":"clqxisuni000jeslr70e9b7kx"},{"post_id":"clqxisunc0009eslr5s2kaohh","tag_id":"clqxisunh000heslrflpf0x7k","_id":"clqxisunk000qeslre8fkb47b"},{"post_id":"clqxisunk000peslr00vhh8qp","tag_id":"clqxisunh000heslrflpf0x7k","_id":"clqxisunm000teslrdstqhokk"},{"post_id":"clqxisunm000veslrhi4y162t","tag_id":"clqxisunh000heslrflpf0x7k","_id":"clqxisunn000zeslr8cqv0fun"},{"post_id":"clqxisune000beslrbdvkb483","tag_id":"clqxisunh000heslrflpf0x7k","_id":"clqxisuno0013eslrbokf4v9b"},{"post_id":"clqxisune000beslrbdvkb483","tag_id":"clqxisunl000seslr0wp13ayp","_id":"clqxisunp0016eslrdfowdfjj"},{"post_id":"clqxisuno0011eslrha3c2p34","tag_id":"clqxisun80004eslr2w878ukp","_id":"clqxisunq001beslrbagr5uu3"},{"post_id":"clqxisung000feslr1ljad569","tag_id":"clqxisunn000yeslr4wcyfi3f","_id":"clqxisunr001deslr4pwv4f3w"},{"post_id":"clqxisuno0014eslr0cy04a5g","tag_id":"clqxisunn000yeslr4wcyfi3f","_id":"clqxisuns001ieslr8ufz3w9k"},{"post_id":"clqxisung000geslrfc1cal5q","tag_id":"clqxisunn000yeslr4wcyfi3f","_id":"clqxisunt001keslrgy9b03pl"},{"post_id":"clqxisuns001jeslr2jz9bzlf","tag_id":"clqxisunh000heslrflpf0x7k","_id":"clqxisunt001neslrhhva2s3n"},{"post_id":"clqxisuni000keslrgz1rbv5i","tag_id":"clqxisunr001eeslrf9poe81o","_id":"clqxisunu001peslrg4k562hg"},{"post_id":"clqxisunj000meslr1cuy8ey9","tag_id":"clqxisunh000heslrflpf0x7k","_id":"clqxisunu001ueslrgb160jy4"},{"post_id":"clqxisunj000meslr1cuy8ey9","tag_id":"clqxisunt001leslre4y331mp","_id":"clqxisunu001veslrcghxdltt"},{"post_id":"clqxisunl000reslr4u5x2qli","tag_id":"clqxisunu001reslr1ye853nw","_id":"clqxisunv001zeslralcv1rr2"},{"post_id":"clqxisunn000xeslr7o8q84gp","tag_id":"clqxisunr001eeslrf9poe81o","_id":"clqxisunv0022eslr3v454uzd"},{"post_id":"clqxisunp0018eslr3eu7a6tc","tag_id":"clqxisunu001reslr1ye853nw","_id":"clqxisunw0026eslrd29j08ye"},{"post_id":"clqxisunq001ceslrf9tm9r5o","tag_id":"clqxisunw0024eslr365261po","_id":"clqxisunw002aeslr5y3vbfvc"}],"Tag":[{"name":"Set Theory","_id":"clqxisun80004eslr2w878ukp"},{"name":"Notes","_id":"clqxisunh000heslrflpf0x7k"},{"name":"Hilbert's 23 Problems","_id":"clqxisunl000seslr0wp13ayp"},{"name":"Sevaral Complex Variables","_id":"clqxisunn000yeslr4wcyfi3f"},{"name":"Algebraic Number Theory","_id":"clqxisunr001eeslrf9poe81o"},{"name":"Mathematical Logic","_id":"clqxisunt001leslre4y331mp"},{"name":"Algebraic Geometry","_id":"clqxisunu001reslr1ye853nw"},{"name":"Hilbert's 23 Problems,Algebraic Number Theory","_id":"clqxisunw0024eslr365261po"}]}}