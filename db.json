{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/seminar/email.txt","path":"seminar/email.txt","modified":1,"renderable":0},{"_id":"source/info/index/photo.jpg","path":"info/index/photo.jpg","modified":1,"renderable":0},{"_id":"source/research/pdf/Prob241110.pdf","path":"research/pdf/Prob241110.pdf","modified":1,"renderable":0},{"_id":"source/research/pdf/Zonal250109.pdf","path":"research/pdf/Zonal250109.pdf","modified":1,"renderable":0},{"_id":"source/seminar/pdf/whm20240202.pdf","path":"seminar/pdf/whm20240202.pdf","modified":1,"renderable":0},{"_id":"themes/Chic/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/Chic/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/Chic/source/assets/beian.png","path":"assets/beian.png","modified":1,"renderable":1},{"_id":"themes/Chic/source/assets/favicon.ico","path":"assets/favicon.ico","modified":1,"renderable":1},{"_id":"themes/Chic/source/assets/loading.svg","path":"assets/loading.svg","modified":1,"renderable":1},{"_id":"themes/Chic/source/assets/example_qr.png","path":"assets/example_qr.png","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/base.styl","path":"css/base.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/custom.styl","path":"css/custom.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/font.styl","path":"css/font.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/demo.css","path":"css/demo.css","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/layout.styl","path":"css/layout.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/media.styl","path":"css/media.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/variable.styl","path":"css/variable.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/image/avatar.jpg","path":"image/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/Chic/source/js/folding.js","path":"js/folding.js","modified":1,"renderable":1},{"_id":"themes/Chic/source/css/normalize.styl","path":"css/normalize.styl","modified":1,"renderable":1},{"_id":"themes/Chic/source/js/mathjax2.7.5.js","path":"js/mathjax2.7.5.js","modified":1,"renderable":1},{"_id":"themes/Chic/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/Chic/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/demo.css","path":"fonts/iconfont/demo.css","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/demo_index.html","path":"fonts/iconfont/demo_index.html","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.css","path":"fonts/iconfont/iconfont.css","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.eot","path":"fonts/iconfont/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.js","path":"fonts/iconfont/iconfont.js","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.json","path":"fonts/iconfont/iconfont.json","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.svg","path":"fonts/iconfont/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.ttf","path":"fonts/iconfont/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff","path":"fonts/iconfont/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff2","path":"fonts/iconfont/iconfont.woff2","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.TTF","path":"fonts/lanting/lanting.TTF","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.eot","path":"fonts/lanting/lanting.eot","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.otf","path":"fonts/lanting/lanting.otf","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff","path":"fonts/lanting/lanting.woff","modified":1,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff2","path":"fonts/lanting/lanting.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"source/_drafts/75 Probelms (French).md","hash":"535885b38fa9b552e3712311ca4d84310026371b","modified":1732688337051},{"_id":"source/_drafts/Cyclotomic Fields.md","hash":"d06b0ec98de6fa05529b136ec147bd57687a5ea7","modified":1708873867047},{"_id":"source/_drafts/Ergodicity-on-Fuschian-Group.md","hash":"c97d57e64208b23e1509aa579a7d0a0b8a098368","modified":1708873867048},{"_id":"source/_drafts/Hilbert12.md","hash":"e37a5023169629a363a017b45de4b9188d6fe2b4","modified":1708873867048},{"_id":"source/_drafts/Divisor Theory.md","hash":"55a3e24df60ca21ebc24c935965b0973585e99c7","modified":1708873867048},{"_id":"source/_drafts/Kronecker-dream-of-youth.md","hash":"b3972aebcfb7f57c0bae7cdaa54f86a8026fccda","modified":1708873867048},{"_id":"source/_drafts/Dedekind Domain.md","hash":"f0a34a35ba32409b1889ffce74c2287b3c60d0bb","modified":1708873867047},{"_id":"source/_drafts/Matiyasevich-theorem.md","hash":"14cb1698c33459c5c954eadfb6ee930f4e895851","modified":1708873867049},{"_id":"source/_drafts/Nevanlinna Theory (German).md","hash":"9999513717f6b3f15e46740f34f8f4fe710e97b9","modified":1708873867049},{"_id":"source/_drafts/Nowicki Conjecture.md","hash":"e79cd201d519b54532ba32198f19803ac19aa2f7","modified":1708873867049},{"_id":"source/category/index.md","hash":"4dbe2020a49b2342a85b166c8d60babd0ba6b84f","modified":1708873867053},{"_id":"source/info/index.md","hash":"4959c684e2d687257cbeb5fc46caeb044e4da225","modified":1736003678737},{"_id":"source/css/gitment.css","hash":"b41d95120f9e64fd4530ae00ceaef09c7ea20818","modified":1708873867054},{"_id":"source/_posts/75 Problems.md","hash":"a52232f19ea38e030a4aee175b60b8d2c19c840e","modified":1732720653182},{"_id":"source/_posts/A Letter to Mr. Lei Yunhai.md","hash":"2c7471413e6bd49c90c7d440bc608e28ca823f58","modified":1735708092873},{"_id":"source/_posts/Cichon's Diagram.md","hash":"4a84fb238e4e6e6651004f918b3d6b71e1f6723b","modified":1708873867050},{"_id":"source/_posts/Henkin‘s Theorem.md","hash":"086fba47489b30300f019d1429a5799e4d987b86","modified":1731476345660},{"_id":"source/_posts/Hilbert's Nullstellensatz.md","hash":"6408bd7ac8a7f9a7af3924b5a396c5c6759e0218","modified":1708873867050},{"_id":"source/_posts/Hilbert13.md","hash":"cb7b00d869efc9b5ff5b3218bf84221ef64d7b3f","modified":1708873867050},{"_id":"source/_posts/Hopf ergodic theorem.md","hash":"f2d505a8665fde29d1e7689c1b810d8f8b162b93","modified":1712747906602},{"_id":"source/_posts/Nevanlinna Theory.md","hash":"3f92f3dad88fe26a0538218a9c4df3e153393e89","modified":1708873867051},{"_id":"source/_posts/Nevanlinna Theory2.md","hash":"38844131a9b616e4c8d7d015b0ec6583107e9e87","modified":1708873867051},{"_id":"source/_posts/P=NP.md","hash":"bad689d892328a3df5edbabedec3eae911cb4adc","modified":1732721042952},{"_id":"source/_posts/Nowicki Conjecture.md","hash":"157377bc1f7bb088cc9c36e785cc1da56444f2f8","modified":1708873867051},{"_id":"source/_posts/Quadratic Reciprocity Law.md","hash":"8a9c9546f5e31d6138d7b2ebd52b0eff9b9759cf","modified":1735896961664},{"_id":"source/_posts/The Discovery of Neptune.md","hash":"a4d2bd45aeb7461aef368af2f9cbae75b4a0fac7","modified":1731789059517},{"_id":"source/_posts/The Naimark Problem.md","hash":"8abe925fc7c093f5b5c4f9bd59f379a7a15db061","modified":1708873867052},{"_id":"source/_posts/Zariski topology.md","hash":"fa76f14b9235f96876e0d366409709bd592dff33","modified":1708873867052},{"_id":"source/_posts/blacksquare-blacklozenge-clubsuit.md","hash":"6739a6c45c5c7d0d846b2b985ff23ba76cc6c17b","modified":1708873867053},{"_id":"source/research/index.md","hash":"5483c124c3611fd25a13c57e7bc5c020518eb4b4","modified":1757394564308},{"_id":"source/seminar/2024.md","hash":"3beae07c18704f8002608a8337a8b9c5c8c6dfbe","modified":1736004367941},{"_id":"source/seminar/email.txt","hash":"26223fd88fc43a4403b758cacbac56bc4a9ee00c","modified":1751501854998},{"_id":"source/seminar/Continuous Logic and Free Probability.md","hash":"807db1809dfe2e3c66c884d369abfb830411816c","modified":1758251972111},{"_id":"source/seminar/index.md","hash":"4246efac1f8e250af5c823b4bab980e46b76c4b2","modified":1758619673968},{"_id":"source/info/index/photo.jpg","hash":"16699358f0ab9fc03fbcbfb668373ce13ff83411","modified":1731395458949},{"_id":"source/_posts/Quadratic Reciprocity Law/QRL.png","hash":"092b3d430f9ec5a9bc19dd87a00fb7e5dee49bd0","modified":1735714707721},{"_id":"source/tag/index.md","hash":"be9590539c7296bfe7e7c1c378ba98c44a9b0782","modified":1708873867058},{"_id":"source/css/_common/comments/third_party/gitment.styl","hash":"cbf73a76ddfb8fbd0f5ef5d8bc62b7d18205b752","modified":1708873867054},{"_id":"source/css/_common/comments/third_party/third_party.styl","hash":"03397d363df01191f4cc5c1e6385f37d0d08ae54","modified":1708873867054},{"_id":"source/js/gitment.js","hash":"9862511054d3b09e2f2b59df3794b1fb58d1857d","modified":1708873867055},{"_id":"source/research/pdf/Prob241110.pdf","hash":"da0169e51a390c1b3f9e3accda37aefdbecf9cf7","modified":1735896785856},{"_id":"source/seminar/pdf/whm20240202.pdf","hash":"dea35267e1e5c82f0fdeb6dcfa5519326c7eb9d3","modified":1708873867057},{"_id":"themes/Chic/ChangeLogs.md","hash":"0244985e7e4797e3d0a0e173dce4e341f6aa5dd0","modified":1680779867000},{"_id":"themes/Chic/LICENSE.md","hash":"9911bdafa287bd65a822f84cc12012980bd10247","modified":1680779867000},{"_id":"themes/Chic/README-CN.md","hash":"af0765f26b72d49f1b29afe1a9d0c4a492912aaa","modified":1680779867000},{"_id":"themes/Chic/_config.yml","hash":"61b0f2fe815f8b11b0f89ed42e0b2888f8223c5e","modified":1746195671969},{"_id":"themes/Chic/README.md","hash":"e0bd27664e1d0b4ed1c8101d2bf69886c66c31d9","modified":1680779867000},{"_id":"themes/Chic/_default/single.html","hash":"e45092de238a2082a1d7954e5bcf39a396197620","modified":1704067920000},{"_id":"themes/Chic/package.json","hash":"8b4072879307eed0e74ae35390825c5e03b9229c","modified":1680779867000},{"_id":"themes/Chic/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1680404818000},{"_id":"themes/Chic/languages/default.yml","hash":"0628773c9f7466a9eac73a2a2fcc86fc5a9f7e73","modified":1704011201000},{"_id":"themes/Chic/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1680404818000},{"_id":"themes/Chic/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1680404818000},{"_id":"themes/Chic/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1680404818000},{"_id":"themes/Chic/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1680404818000},{"_id":"themes/Chic/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1680404818000},{"_id":"themes/Chic/languages/zh-CN.yml","hash":"ebc9773a3ab233fae36eea8eec39d3ba21e8ed52","modified":1704011244000},{"_id":"themes/Chic/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1680404818000},{"_id":"themes/Chic/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1680404818000},{"_id":"themes/Chic/languages/zh-TW.yml","hash":"a652c6f1e34d576cdf1f5931286e3ec9d244d45a","modified":1704011261000},{"_id":"themes/Chic/layout/archive.ejs","hash":"48cdf67b628eb6a1c24d484ed252f5b0e3f06ddf","modified":1680404818000},{"_id":"themes/Chic/layout/comments.swig","hash":"994959bf2179719ac6236347aef661a516eb4796","modified":1704070856000},{"_id":"themes/Chic/layout/category.ejs","hash":"cae7483c92ff639f74f8efe67959f37c97350800","modified":1680404818000},{"_id":"themes/Chic/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1680404818000},{"_id":"themes/Chic/layout/index.ejs","hash":"b3344720176ad12dc88745cc5b31d497356ca4fa","modified":1680404818000},{"_id":"themes/Chic/layout/layout.ejs","hash":"8565bbea5e904e75e8d1ff5186b3a53650a7fa70","modified":1680404818000},{"_id":"themes/Chic/layout/page.ejs","hash":"96a5db03943ca9fcc8943618cc39bbde5fa04239","modified":1704258498000},{"_id":"themes/Chic/layout/tag.ejs","hash":"d85ca78392be138b1589499cba95186b20c3a902","modified":1680404818000},{"_id":"themes/Chic/layout/post.ejs","hash":"b6264a94a84f79a5f6adbc603dd973ce1eac82a1","modified":1704258160000},{"_id":"themes/Chic/layout/seminar.ejs","hash":"ef4716f974390e1af38d30de1ab382a8c47bb750","modified":1735909248832},{"_id":"themes/Chic/scripts/imageTag.js","hash":"4b69804c1e4bf638eda7022499c440ce24e28587","modified":1680404818000},{"_id":"themes/Chic/source/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1680404818000},{"_id":"themes/Chic/layout/_partial/after-footer.ejs","hash":"860366fcf074c59ad7a8f36608b0636e06c47fa2","modified":1704196535000},{"_id":"themes/Chic/layout/_partial/article.ejs","hash":"901983fb54e375b539d71ccc860c2b0004f24fa0","modified":1704258005000},{"_id":"themes/Chic/layout/_partial/article-full.ejs","hash":"88b863f5375f3e633209488960225dc3979faafe","modified":1704253946000},{"_id":"themes/Chic/layout/_partial/counter.ejs","hash":"9a7f5c9543c9752c8bcf5606a9eb5b6c1bfaa0a1","modified":1704199856000},{"_id":"themes/Chic/layout/_partial/gitment.ejs","hash":"0704032fb2000245b647087a394e92665c02b76e","modified":1704010779000},{"_id":"themes/Chic/layout/_partial/gitalk.html","hash":"4bad67042a6de9b94bcde905eba99bccdfdde212","modified":1704067629000},{"_id":"themes/Chic/layout/_partial/head.ejs","hash":"8c91a3575037c2210cdfc4e78b0d863ac5ba5893","modified":1704254244000},{"_id":"themes/Chic/layout/_partial/header.ejs","hash":"8f1e5272a4de96a3ed94de1db988b05b34515463","modified":1680404818000},{"_id":"themes/Chic/layout/_partial/paginator.ejs","hash":"ab59d5db77f2aa64dfe03656e72fd49702c62e23","modified":1680404818000},{"_id":"themes/Chic/layout/_partial/comments.swig","hash":"a252e287237a8bb627408d9a871550ed9b8d8190","modified":1704011369000},{"_id":"themes/Chic/layout/_partial/toc.ejs","hash":"c47e8a5047ce0016f74b76028878d386af78bb7c","modified":1680404818000},{"_id":"themes/Chic/layout/_partial/footer.ejs","hash":"4a7c4d5d503fd28db42dfd8d73b40ad47b1474a5","modified":1704268713000},{"_id":"themes/Chic/layout/_page/archive.ejs","hash":"464549286c92ea0d6cb057c6936e0f1a5d1c1dd2","modified":1680404818000},{"_id":"themes/Chic/layout/_page/page.ejs","hash":"1d875d59cf4d6b681cc8cf755f19b5355e5d1144","modified":1680404818000},{"_id":"themes/Chic/layout/_page/category.ejs","hash":"e8464e11d08a711fe815ea1cd101aa41d7310ebf","modified":1680404818000},{"_id":"themes/Chic/layout/_page/post.ejs","hash":"6eb9cd3ee904e99ff78509298ae31a29fdbf49cf","modified":1680404818000},{"_id":"themes/Chic/layout/_page/profile.ejs","hash":"f49991a55cc08a1d90d8d6ae8d15a692163272e1","modified":1680404818000},{"_id":"themes/Chic/layout/_page/tag.ejs","hash":"0c20ff00532103f9a59639ca9956fc0bce4aabc2","modified":1680404818000},{"_id":"themes/Chic/layout/_plugins/gitalk.ejs","hash":"396e8c86e49c72f99431cd48001ae75c06d8b529","modified":1704209685000},{"_id":"themes/Chic/layout/_plugins/mathjax.ejs","hash":"53f088fe44d51c4d9fb61aeac4c23b3cfcc19762","modified":1680404818000},{"_id":"themes/Chic/layout/_plugins/site-visitor.ejs","hash":"5224474c5e145df97f9bfe1e6bf1d8b607823701","modified":1704261275000},{"_id":"themes/Chic/layout/_plugins/valine.ejs","hash":"dd78cef244bc22d64bcd885073b7763948b86807","modified":1704270656000},{"_id":"themes/Chic/layout/_widget/popular_post.ejs","hash":"56527a452f78a024628bdb2a64de353bf58dfe2a","modified":1704196764000},{"_id":"themes/Chic/source/assets/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1679489292000},{"_id":"themes/Chic/source/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1679489292000},{"_id":"themes/Chic/source/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1679489292000},{"_id":"themes/Chic/source/assets/example_qr.png","hash":"a79b7399f81fe05c8a69440a9ef01b47c2dfb5b6","modified":1679698479000},{"_id":"themes/Chic/source/assets/loading.svg","hash":"85082b002bae1335114b71550350907884187e38","modified":1679489292000},{"_id":"themes/Chic/source/css/base.styl","hash":"72aef06d738853f13f1697b091002d6d776bd56d","modified":1680404818000},{"_id":"themes/Chic/source/css/custom.styl","hash":"b434721f720d43be984e24301fd5e2b6b8d44f32","modified":1704084401000},{"_id":"themes/Chic/source/css/font.styl","hash":"8c1da30e223c0a3d7ef452abc9f0e4cc71dbc140","modified":1680404818000},{"_id":"themes/Chic/source/css/demo.css","hash":"f19c8dc3cc33f3c175285ecf063d86090b26daa0","modified":1735908707174},{"_id":"themes/Chic/source/css/layout.styl","hash":"4d9f83b5a3bac81e7857358744858fae708320de","modified":1680404818000},{"_id":"themes/Chic/source/css/media.styl","hash":"f96c0dbb9653667906a6dc271f637543ac5c7212","modified":1680404818000},{"_id":"themes/Chic/source/css/style.styl","hash":"1e0f617fbb5b4750fbe2370dce0552ecc0236cd1","modified":1735908520706},{"_id":"themes/Chic/source/css/variable.styl","hash":"906faa95457eba70118a0705e13b8f43409e502f","modified":1680404818000},{"_id":"themes/Chic/source/image/avatar.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1679489292000},{"_id":"themes/Chic/source/js/folding.js","hash":"72332586b2135c7b400f909c6b9dabcd30dea9c6","modified":1735908430027},{"_id":"themes/Chic/source/css/normalize.styl","hash":"b3337320133b7a336db7033aa6bbe94b054c0b21","modified":1680404818000},{"_id":"themes/Chic/source/js/mathjax2.7.5.js","hash":"7ba18c783d543cfb4b45a0118ccb73d3f68cd46e","modified":1680404818000},{"_id":"themes/Chic/source/js/script.js","hash":"5dd8ce4fa55a7201d7e2ffe417b48c95943a906b","modified":1680404818000},{"_id":"themes/Chic/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1680404818000},{"_id":"themes/Chic/layout/_partial/post/date.ejs","hash":"a999230f31f16ecc370b168974191d149d3bf08b","modified":1704199937000},{"_id":"themes/Chic/layout/_partial/post/single.html","hash":"2f8c008433b7bb053550e55eba198b20169063cb","modified":1704267670000},{"_id":"themes/Chic/layout/_third-party/comments/gitalk.swig","hash":"0460af10c54d9d97f6c4a1bcb3940c5675a9df20","modified":1704070815000},{"_id":"themes/Chic/layout/_partial/post/gitalk.ejs","hash":"dac239a8dba1159648cce6f8012144860604a79b","modified":1704071529000},{"_id":"themes/Chic/layout/_third-party/comments/index.swig","hash":"10af34b4d39cf344ee4921fd3aff2fc497298b44","modified":1704070896000},{"_id":"themes/Chic/layout/_third-party/comments/gitment.swig","hash":"53f605bb2554b096adbbe6e51ed834cf9bec84e2","modified":1704008358000},{"_id":"themes/Chic/source/css/_highlight/agate.styl","hash":"53027913ed8d4f75ac3e49e76aad824f0df62da3","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/androidstudio.styl","hash":"2af0861725f97f0ee2ded67c3d2d4548c62b2d16","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/arta.styl","hash":"b3e81e3e694ceb8deed178adb8b91013c5120e30","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-cave-dark.styl","hash":"ce63dd8548688d88254405eedfa75b1d7c82449e","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-dune-dark.styl","hash":"c196ff0ee064af0e507823694ae39020addfc280","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-estuary-dark.styl","hash":"0bb16a4eff93688f40787abc2f9e56e7d5cc93e7","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-heath-dark.styl","hash":"9a2e9a1d0a01bbdf158560c3ed1c134e098b2c68","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-forest-dark.styl","hash":"effbc5d75fa87203c847039869c22031b40d5b7d","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-lakeside-dark.styl","hash":"10ee3882fca7b97a37bd309d2d35fce9868647bb","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-plateau-dark.styl","hash":"84c80e6f67f62fce958d25817c277d2360272617","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-savanna-dark.styl","hash":"e32c1c70def8060fce5e790979a126da650ac642","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-seaside-dark.styl","hash":"2edf385215bbe1985b1a10106525d362667d28c2","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"538a14321193cd8abf2ddc484306631e54149ffb","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/brown-paper.styl","hash":"329b85ae9130a5587a6fb1c6f80396f9cca5ddc1","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/codepen-embed.styl","hash":"8b7b34484f76a6c2c3b1a9e49abb9b382f439ae8","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/darkula.styl","hash":"9717efa9194837ba3fb4d762997d33075dcf8bfa","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/dark.styl","hash":"f5e6e75958de59e87fc6be3a1668e870e20bc836","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/far.styl","hash":"aaac3028f5e33123cd123a583cddc9290c45ec8e","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/highlightjs.styl","hash":"65b5981dc3c57cedd1cb668c0e377230987e08d1","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/hopscotch.styl","hash":"1378a6bc67a32c0cbff72ab771268b53f9aa586d","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/hybrid.styl","hash":"b8eb5c69d12f2ee5ebc50265ae271699d7f1a8d3","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/ir-black.styl","hash":"53e5d74326a4527b92272bbd6946d4fec92720e8","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/gruvbox-dark.styl","hash":"76b744c14fd5600bea64731c05df97c2df75523f","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/kimbie.styl","hash":"51b889ca7c6fe178cfbbe28d875a6ea427184441","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/monokai.styl","hash":"f87be027848ea6bee623a08ad1e17b2f5b7937ee","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/monokai-sublime.styl","hash":"c385b11345894be7e6ce3c5f08663e199933b8e4","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/obsidian.styl","hash":"199e28326be8590883f0813ebbd54fcfaa4750fd","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/paraiso.styl","hash":"75f181eece6b71d033ea0c8d6cf00ae7efb9e29b","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/railscasts.styl","hash":"b6674db9210e0c4444e4835fff2d1361f3ebd64c","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/pojoaque.styl","hash":"2601b4285803a7cea5ccded8d624ca95f80e3d88","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/rainbow.styl","hash":"c0cf97aae3e10fdcd10414547a711c9effbc39b8","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/school-book.styl","hash":"beabbbcc7930f8de19159381a01c0ba41dc2291f","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/solarized-dark.styl","hash":"90c9da5aa594383697e5b18892a7f95beb053f55","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-bright.styl","hash":"7674fecb6d27350727dc0d2dc93bc018382ebbd0","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-blue.styl","hash":"f24c17d0ab815dcfaab3438cb9fe2ab4839f5e0d","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/sunburst.styl","hash":"af3eec0fd56151e55bbd49c31b151f36717611d8","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-eighties.styl","hash":"28d751075ebabf7d0327a36f725076fe82fdf626","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night.styl","hash":"16ba09b2db501e4e3e2e7d62595d9bf935bf27c4","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1680404818000},{"_id":"themes/Chic/source/css/_lib/looper.css","hash":"863144dc9af7c1e181670515bc85eaf768f4e287","modified":1680404818000},{"_id":"themes/Chic/source/css/_highlight/zenburn.styl","hash":"68ff9332ccc03f9389b15b713415cde016f8088f","modified":1680404818000},{"_id":"themes/Chic/source/css/_page/archive.styl","hash":"71ea842f068b29b4418dd09450db09d27dcf0947","modified":1680404818000},{"_id":"themes/Chic/source/css/_lib/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1680404818000},{"_id":"themes/Chic/source/css/_page/category.styl","hash":"cead361269616b7a6ddec3090d9fa34c3c6ac722","modified":1680404818000},{"_id":"themes/Chic/source/css/_page/page.styl","hash":"34e33b52d2e046aa2f5494e81ff4ac2d5ca78058","modified":1680404818000},{"_id":"themes/Chic/source/css/_page/profile.styl","hash":"057097e714284e72e97ab8a808a30df45555a342","modified":1680404818000},{"_id":"themes/Chic/source/css/_page/tag.styl","hash":"55b220cc58011876fb3a470cd1fde8ed87c93079","modified":1680404818000},{"_id":"themes/Chic/source/css/_partial/footer.styl","hash":"4f58e607eaa59cda3b5a9fdb3404ffb75c4d1a03","modified":1680404818000},{"_id":"themes/Chic/source/css/_partial/header.styl","hash":"be70b4ab3bcc977f1055664899742804c716929d","modified":1680404818000},{"_id":"themes/Chic/source/css/_partial/paginator.styl","hash":"b4f4a5180c4cbc70d186792b8a1fd0f5855bd86a","modified":1680404818000},{"_id":"themes/Chic/source/fonts/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1680404818000},{"_id":"themes/Chic/source/fonts/iconfont/demo_index.html","hash":"16e01463756a77b4acd15ade4e6b73f0376d75e1","modified":1680404818000},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.css","hash":"1e5540dca41dc53879226750f936e72daf616662","modified":1680404818000},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.eot","hash":"d18736f7885569e497698d17f49b9167add67dc6","modified":1680404818000},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.js","hash":"87bfdaae31251f4d605646c5ae9c67196f6cc4e2","modified":1680404818000},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.json","hash":"eae94b803d34035008842855d0bead92d2035281","modified":1680404818000},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.svg","hash":"5c9c4e44179a7435d0f91df4ce1154dd677ad8c2","modified":1680404818000},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.ttf","hash":"41c4f4dc82e42452dcfd19caed6c7dc333ee769e","modified":1680404818000},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff","hash":"a57593c49b56c16ac1def0e1f3dbca3f658b3579","modified":1680404818000},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff2","hash":"39d97a0f72417487f5c1e0a0abf8e27dd6ebda31","modified":1680404818000},{"_id":"themes/Chic/source/css/_page/_post/post_code.styl","hash":"06c3a3524ffd4b27e03e79489001997ea5d727d3","modified":1680404818000},{"_id":"themes/Chic/source/css/_page/_post/post_content.styl","hash":"5e3d63077549d8e2e5ff8c452e809760f5a99c17","modified":1680404818000},{"_id":"themes/Chic/source/css/_common/components/third-party.styl","hash":"20c47711e7ed6c5f46d4c4d58ac24f48102dd082","modified":1704071075000},{"_id":"themes/Chic/source/css/_page/_post/post_header.styl","hash":"d37b032bc5edca92c84bf62070a28fa40939df55","modified":1680404818000},{"_id":"themes/Chic/source/css/_page/_post/post_copyright.styl","hash":"64fd9f07ed45f035057d46740af0db70218714aa","modified":1680404818000},{"_id":"themes/Chic/source/css/_page/_post/post_nav.styl","hash":"03accaba13c995cbe65a05a88549ff74e992eb3f","modified":1680404818000},{"_id":"themes/Chic/source/css/_page/_post/post_toc.styl","hash":"15e1ec7af93f41184f986aba21991a79923b0a0e","modified":1680404818000},{"_id":"themes/Chic/source/css/_page/_post/post_tags.styl","hash":"2ff93677aa4d81da83c659b4dd4e3cb482d9ce7d","modified":1680404818000},{"_id":"themes/Chic/source/css/_common/components/third-party/gitalk.styl","hash":"ac7753d536341aa824d7bce0332735e838916995","modified":1704071030000},{"_id":"source/research/pdf/Zonal250109.pdf","hash":"d228cb0c2f8703cb4956b712492dcd6701d859ad","modified":1736000245031},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff2","hash":"5f325fcd2726a5b44e08b7004a5219e14847cbfa","modified":1680404818000},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff","hash":"642ad1f17d27d4b1010d1a0571d1b44cbc823d9d","modified":1680404818000},{"_id":"themes/Chic/source/fonts/lanting/lanting.eot","hash":"3e184614f037939a6f98d607da3ed7dffb350e65","modified":1680404818000},{"_id":"themes/Chic/source/fonts/lanting/lanting.TTF","hash":"97e9a4538cceef4b17d54c7dc589524905d1b685","modified":1680404818000},{"_id":"themes/Chic/source/fonts/lanting/lanting.otf","hash":"4e184da596772d3ef6e5763cdee3e46a1ce2f2dd","modified":1680404818000},{"_id":"public/css/gitment.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1758619684479},{"_id":"public/js/gitment.js","hash":"b10d86fd79656a6142270ff9f5f05b954b08ecea","modified":1758619684479},{"_id":"public/atom.xml","hash":"da4132af8ba06f3baf4cfc94770cf010f90b2b47","modified":1758619684479},{"_id":"public/sitemap.xml","hash":"96c302a64e9717d506594e36173934a6f0ea0b06","modified":1758619684479},{"_id":"public/sitemap.txt","hash":"2f1209f47c71b4e54a6cc44668cadae40bbf5f64","modified":1758619684479},{"_id":"public/content.json","hash":"56781597289b79b57050af76a78fc68d591278be","modified":1758619684479},{"_id":"public/category/index.html","hash":"133c8fe3a86c5b0674123b2b4e396f3a00377f31","modified":1758619684479},{"_id":"public/info/index.html","hash":"f302e09d8d8cbc99e791adf11ec62460a4d86cb5","modified":1758619684479},{"_id":"public/research/index.html","hash":"58661ca9d1b503e5a8c81bc86b0c03dc721550e8","modified":1758619684479},{"_id":"public/seminar/2024.html","hash":"a5f70531871006d180f74cee1321cca6e2f8cd0e","modified":1758619684479},{"_id":"public/seminar/Continuous Logic and Free Probability.html","hash":"99b5d78af61949aeaf02d8e671358d4a9943f751","modified":1758619684479},{"_id":"public/seminar/index.html","hash":"1c11a9e55f979f359b40572d42e16daaf9f2db3f","modified":1758619684479},{"_id":"public/tag/index.html","hash":"50a3a05b72f1fa7952dbfc9044c351dbf1a75284","modified":1758619684479},{"_id":"public/2024/11/17/A Letter to Mr. Lei Yunhai/index.html","hash":"1379b0b4adecb2955ce50b53e663d52e0a0fbd49","modified":1758619684479},{"_id":"public/2024/11/13/Henkin‘s Theorem/index.html","hash":"d8011d4814fa324b2a4228ccc89269ba7524ade6","modified":1758619684479},{"_id":"public/2024/02/18/blacksquare-blacklozenge-clubsuit/index.html","hash":"394ac61e1de7a0f077e23cace5a59b227e2219ba","modified":1758619684479},{"_id":"public/2024/01/17/Hopf ergodic theorem/index.html","hash":"2a6117d23aa040d841a0435d159e84331fc1644a","modified":1758619684479},{"_id":"public/2023/09/22/75 Problems/index.html","hash":"cd904c6b127295635d2f50c0c013e78821d9af44","modified":1758619684479},{"_id":"public/2023/07/31/Cichon's Diagram/index.html","hash":"e8ab8435defc7d830049e8222f5d5dae25d4e05a","modified":1758619684479},{"_id":"public/2023/04/11/Nowicki Conjecture/index.html","hash":"7b644fae51a7ad89757244f960f57a5683cbc612","modified":1758619684479},{"_id":"public/2023/04/10/P=NP/index.html","hash":"ba31e5ec18b669ce94d1554a501e0a00374f1acd","modified":1758619684479},{"_id":"public/2023/04/10/The Naimark Problem/index.html","hash":"a27ca7a40504a810a6c7495f237efab59f2ecee1","modified":1758619684479},{"_id":"public/2023/04/04/The Discovery of Neptune/index.html","hash":"e56d679d4527bf3419980c12597027ad4eb323c0","modified":1758619684479},{"_id":"public/2023/03/27/Quadratic Reciprocity Law/index.html","hash":"d3f7e3ad8d759c43117bac1f3759b012378e6210","modified":1758619684479},{"_id":"public/2023/03/27/Nevanlinna Theory2/index.html","hash":"7e6090c5dc58e61fe4264db19533937f72468e89","modified":1758619684479},{"_id":"public/2023/03/27/Nevanlinna Theory/index.html","hash":"e55b4bf084fee1d4a32ac67362a2780ec055466f","modified":1758619684479},{"_id":"public/2023/03/23/Hilbert13/index.html","hash":"31f57084062416e7947e256266234771e96c5db2","modified":1758619684479},{"_id":"public/2023/03/23/Hilbert's Nullstellensatz/index.html","hash":"2f54853acfe46942203095569e155db4c291678d","modified":1758619684479},{"_id":"public/categories/Algebraic-Number-Theory/index.html","hash":"e66d72a41cf41bb6ba0aa40ce8b7b9a1357390dd","modified":1758619684479},{"_id":"public/2023/03/23/Zariski topology/index.html","hash":"7965ff221cb2fc8d42435017910c42b2016861c3","modified":1758619684479},{"_id":"public/categories/Sevaral-Complex-Variables/index.html","hash":"ef7cadb308469a871d4d379d10ab2b134bc20a84","modified":1758619684479},{"_id":"public/categories/Set-Theory/index.html","hash":"e5fbb215aae0d30caf1afcf82bc48b29be2d4094","modified":1758619684479},{"_id":"public/categories/Sevaral-Complex-Variables/Fuchsian-Group/index.html","hash":"805a2f6f84b2867d378c63abd09f4fa6623a2ebd","modified":1758619684479},{"_id":"public/categories/Sevaral-Complex-Variables/Nevanlinna-Theory/index.html","hash":"2fcd908b3b3acd9aa21ebc7e72025221069dc3e4","modified":1758619684479},{"_id":"public/categories/Notes/index.html","hash":"dcb8028fbdfd00e2720d62e33a217af17f516986","modified":1758619684479},{"_id":"public/categories/Miscellanies/index.html","hash":"32c0d8e5aeaf79c49c62300c137991039fe84531","modified":1758619684479},{"_id":"public/categories/Commutative-Algebra/index.html","hash":"02986aedcfcf92a041d33565642fa40b6c13fbff","modified":1758619684479},{"_id":"public/categories/Mathematical-Logic/index.html","hash":"e207bf3abeed9522c4c4c57e3e4fa7184ac690bf","modified":1758619684479},{"_id":"public/categories/History-of-Mathematics/index.html","hash":"a5e40de0be943fc44e1a2a30940d6af6ba50475f","modified":1758619684479},{"_id":"public/categories/Commutative-Algebra/Algebraic-Geometry/index.html","hash":"964e0165e8228da02214e6db714520b7d363e809","modified":1758619684479},{"_id":"public/categories/History-of-Mathematics/Hilbert-s-23-Problems/index.html","hash":"bd93dc6fc3e418e3fe4277f531ea5d53525c7a73","modified":1758619684479},{"_id":"public/archives/index.html","hash":"8a6159c85696a0cc2ad6d068f61d743cc4188afd","modified":1758619684479},{"_id":"public/archives/page/2/index.html","hash":"c2622fd648700cdd16c1984dcd503d69bbefb549","modified":1758619684479},{"_id":"public/archives/2023/index.html","hash":"74f8a798a5385e6eaf89fba6a5cc5d90e2eaa0b7","modified":1758619684479},{"_id":"public/archives/2023/03/index.html","hash":"55ebfd487cb6971ae7cb1fd5650e1c5781d0fb00","modified":1758619684479},{"_id":"public/archives/2023/04/index.html","hash":"2fd453e865103f07cde7b4f897302ff65f98067c","modified":1758619684479},{"_id":"public/archives/2023/07/index.html","hash":"fc2925a0e357a4e31c5a6464eb67aab8661dfd23","modified":1758619684479},{"_id":"public/archives/2023/09/index.html","hash":"2ddd62e38a5302a5ed8d05c477c507149c9a6776","modified":1758619684479},{"_id":"public/archives/2024/index.html","hash":"3a8b9e0f7f74752bc742e41c971ae69c7e5b4d5f","modified":1758619684479},{"_id":"public/archives/2024/01/index.html","hash":"d2ac7c75e31a8c04433fcaac0c5a4e214f675946","modified":1758619684479},{"_id":"public/archives/2024/02/index.html","hash":"ca9e6caac87fff1435a5c1788a8ff1179a3b3936","modified":1758619684479},{"_id":"public/archives/2024/11/index.html","hash":"fc7fe4fcc93847a7d988e7322da58f157f303d52","modified":1758619684479},{"_id":"public/index.html","hash":"7fb92fee447346e0bcf382cbe8bf794f861071f7","modified":1758619684479},{"_id":"public/page/2/index.html","hash":"7fb92fee447346e0bcf382cbe8bf794f861071f7","modified":1758619684479},{"_id":"public/tags/Algebraic-Number-Theory/index.html","hash":"793cfdce7bbee8cd41978339cd1e35cde59e3d2e","modified":1758619684479},{"_id":"public/tags/Sevaral-Complex-Variables/index.html","hash":"43d8750f7b9fd2650e10d9680e887d745c2ea88a","modified":1758619684479},{"_id":"public/tags/Set-Theory/index.html","hash":"ef57fb6404c5050f41c176ee344afecee5b7efa7","modified":1758619684479},{"_id":"public/tags/Algebraic-Geometry/index.html","hash":"06f85a9232969db3575ab825ab9f352257593e85","modified":1758619684479},{"_id":"public/tags/Notes/index.html","hash":"de5331c94f70c70529dd3231f45e875595632f3b","modified":1758619684479},{"_id":"public/tags/Miscellanies/index.html","hash":"fb012ff9e69e05d3e8f33f63845419833fd03d36","modified":1758619684479},{"_id":"public/tags/Mathematical-Logic/index.html","hash":"e273b0029aa7214c81947021520cbcc89cc5df8e","modified":1758619684479},{"_id":"public/tags/Hilbert-s-23-Problems/index.html","hash":"510c7868f4dd7c0c2ebcfa543b12427ac656e0cd","modified":1758619684479},{"_id":"public/info/index/photo.jpg","hash":"16699358f0ab9fc03fbcbfb668373ce13ff83411","modified":1758619684479},{"_id":"public/seminar/email.txt","hash":"26223fd88fc43a4403b758cacbac56bc4a9ee00c","modified":1758619684479},{"_id":"public/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1758619684479},{"_id":"public/assets/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1758619684479},{"_id":"public/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1758619684479},{"_id":"public/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1758619684479},{"_id":"public/assets/loading.svg","hash":"85082b002bae1335114b71550350907884187e38","modified":1758619684479},{"_id":"public/assets/example_qr.png","hash":"a79b7399f81fe05c8a69440a9ef01b47c2dfb5b6","modified":1758619684479},{"_id":"public/image/avatar.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1758619684479},{"_id":"public/fonts/iconfont/iconfont.eot","hash":"d18736f7885569e497698d17f49b9167add67dc6","modified":1758619684479},{"_id":"public/fonts/iconfont/iconfont.svg","hash":"5c9c4e44179a7435d0f91df4ce1154dd677ad8c2","modified":1758619684479},{"_id":"public/fonts/iconfont/iconfont.woff","hash":"a57593c49b56c16ac1def0e1f3dbca3f658b3579","modified":1758619684479},{"_id":"public/fonts/iconfont/iconfont.woff2","hash":"39d97a0f72417487f5c1e0a0abf8e27dd6ebda31","modified":1758619684479},{"_id":"public/fonts/iconfont/iconfont.ttf","hash":"41c4f4dc82e42452dcfd19caed6c7dc333ee769e","modified":1758619684479},{"_id":"public/2023/03/27/Quadratic Reciprocity Law/QRL.png","hash":"092b3d430f9ec5a9bc19dd87a00fb7e5dee49bd0","modified":1758619684479},{"_id":"public/css/base.css","hash":"2fce73a3c2df8f93edeb5e34a53b7d83e5191d85","modified":1758619684479},{"_id":"public/css/custom.css","hash":"966bacf523742f4bc2d99deef1c25019dd988eea","modified":1758619684479},{"_id":"public/css/layout.css","hash":"9b81d7e5146871ae2d1010f3a10089bbb43e81e3","modified":1758619684479},{"_id":"public/css/font.css","hash":"87059edd1f2bfc4296f5599e73208893f2b06458","modified":1758619684479},{"_id":"public/css/variable.css","hash":"cb4180b3bbad471e30cf52ebb40e998d58a30d7d","modified":1758619684479},{"_id":"public/css/style.css","hash":"2ad43157bda379b8a97c085b638df5aa14695b05","modified":1758619684479},{"_id":"public/css/media.css","hash":"5023ee404900a47d61ca0591b2d4e9eace0fe88e","modified":1758619684479},{"_id":"public/css/normalize.css","hash":"2d4b663b6a4c68295b6ba240fa2dd9fb3863093c","modified":1758619684479},{"_id":"public/js/folding.js","hash":"b35b62ebd5420cc29de7758e9504247d62e30115","modified":1758619684479},{"_id":"public/js/script.js","hash":"5dd8ce4fa55a7201d7e2ffe417b48c95943a906b","modified":1758619684479},{"_id":"public/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1758619684479},{"_id":"public/js/mathjax2.7.5.js","hash":"7ba18c783d543cfb4b45a0118ccb73d3f68cd46e","modified":1758619684479},{"_id":"public/css/demo.css","hash":"f19c8dc3cc33f3c175285ecf063d86090b26daa0","modified":1758619684479},{"_id":"public/fonts/iconfont/demo_index.html","hash":"16e01463756a77b4acd15ade4e6b73f0376d75e1","modified":1758619684479},{"_id":"public/fonts/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1758619684479},{"_id":"public/fonts/iconfont/iconfont.css","hash":"1e5540dca41dc53879226750f936e72daf616662","modified":1758619684479},{"_id":"public/fonts/iconfont/iconfont.json","hash":"3123aa840109e385d58a75d34e88a2d621e1ada8","modified":1758619684479},{"_id":"public/fonts/iconfont/iconfont.js","hash":"87bfdaae31251f4d605646c5ae9c67196f6cc4e2","modified":1758619684479},{"_id":"public/research/pdf/Prob241110.pdf","hash":"da0169e51a390c1b3f9e3accda37aefdbecf9cf7","modified":1758619684479},{"_id":"public/seminar/pdf/whm20240202.pdf","hash":"dea35267e1e5c82f0fdeb6dcfa5519326c7eb9d3","modified":1758619684479},{"_id":"public/research/pdf/Zonal250109.pdf","hash":"d228cb0c2f8703cb4956b712492dcd6701d859ad","modified":1758619684479},{"_id":"public/fonts/lanting/lanting.woff2","hash":"5f325fcd2726a5b44e08b7004a5219e14847cbfa","modified":1758619684479},{"_id":"public/fonts/lanting/lanting.woff","hash":"642ad1f17d27d4b1010d1a0571d1b44cbc823d9d","modified":1758619684479},{"_id":"public/fonts/lanting/lanting.eot","hash":"3e184614f037939a6f98d607da3ed7dffb350e65","modified":1758619684479},{"_id":"public/fonts/lanting/lanting.TTF","hash":"97e9a4538cceef4b17d54c7dc589524905d1b685","modified":1758619684479},{"_id":"public/fonts/lanting/lanting.otf","hash":"4e184da596772d3ef6e5763cdee3e46a1ce2f2dd","modified":1758619684479}],"Category":[{"name":"Algebraic Number Theory","_id":"cmfwcr5rs0007m8nxfqlc3n13"},{"name":"Sevaral Complex Variables","_id":"cmfwcr5ru000dm8nx6ap79txh"},{"name":"Hilbert's 12th Problem","_id":"cmfwcr5rw000km8nxfri53nzw"},{"name":"Set Theory","_id":"cmfwcr5rx000tm8nxh4c0e8mz"},{"name":"Algebraic Geometry","_id":"cmfwcr5rz000zm8nxacng6eor"},{"name":"Fuchsian Group","parent":"cmfwcr5ru000dm8nx6ap79txh","_id":"cmfwcr5s00015m8nxb7hg144u"},{"name":"Nevanlinna Theory","parent":"cmfwcr5ru000dm8nx6ap79txh","_id":"cmfwcr5s3001lm8nx82mz9ocv"},{"name":"Commutative Algebra","parent":"cmfwcr5rw000km8nxfri53nzw","_id":"cmfwcr5s4001tm8nx07fu0vrd"},{"name":"Notes","_id":"cmfwcr5s50022m8nx8f2gf5z0"},{"name":"Hilbert's 10th Problem","_id":"cmfwcr5s60028m8nx253k5ets"},{"name":"Miscellanies","_id":"cmfwcr5s6002em8nxhg0o9nsy"},{"name":"Commutative Algebra","_id":"cmfwcr5s7002qm8nxf19o79of"},{"name":"Algebraic Number Theory","parent":"cmfwcr5s4001tm8nx07fu0vrd","_id":"cmfwcr5s8002zm8nx8fe111i2"},{"name":"Mathematical Logic","parent":"cmfwcr5s60028m8nx253k5ets","_id":"cmfwcr5s80032m8nxbf2g1y9f"},{"name":"Mathematical Logic","_id":"cmfwcr5s80033m8nx994943ff"},{"name":"History of Mathematics","_id":"cmfwcr5s90035m8nxh0wqgvt3"},{"name":"Algebraic Geometry","parent":"cmfwcr5s7002qm8nxf19o79of","_id":"cmfwcr5s90038m8nxdiha9ncy"},{"name":"Algebraic Geometry","parent":"cmfwcr5s8002zm8nx8fe111i2","_id":"cmfwcr5sa003fm8nx5rv5bfn2"},{"name":"Hilbert's 23 Problems","parent":"cmfwcr5s90035m8nxh0wqgvt3","_id":"cmfwcr5sa003gm8nx13qa1p61"}],"Data":[],"Page":[{"title":"category","layout":"category","date":"2023-04-02T03:14:35.000Z","_content":"","source":"category/index.md","raw":"---\ntitle: category\nlayout: category\ndate: 2023-04-02 11:14:35\n---\n","updated":"2024-02-25T15:11:07.053Z","path":"category/index.html","comments":1,"_id":"cmfwcr5rm0000m8nx6p2dg694","content":"\r\n","site":{"data":{}},"excerpt":"","more":"\r\n"},{"title":"about me","layout":"about","date":"2023-03-22T12:52:41.000Z","sticky":100,"top":true,"mathjax":true,"_content":"\n\n\n<table style=\"width: 100%; border-collapse: collapse; border: none;\">\n  <tr>\n    <td style=\"width: 30%; vertical-align: top; border: none;\">\n      <img src=\"photo.jpg\" alt=\"Taken on Guangzhou in 2019\" style=\"width: 100%;\" />\n    </td>\n    <td style=\"width: 70%; vertical-align: top; border: none;\">\n      <p>I'm Haoming Wang (<span style=\"font-family: 楷体_GB2312;\">王浩铭</span>), a PhD student at Sun Yat-sen University. Here's my math blog sharing new ideas and reading notes. This site is built with <a href=\"https://hexo.io/\">Hexo</a> + <a href=\"https://github.com/\">GitHub</a>. Math is supported by <a href=\"https://www.mathjax.org/\">Mathjax</a>.\n      Any question about this site, please leave your comment below or through <a href=\"https://github.com/blueairM\">GitHub</a>.</p>\n      **Education:**\n      <table style=\"width: 100%; border-collapse: collapse; border: none; margin-top: 10px;\">\n        <tr>\n          <td style=\"border: none;\"><em>2014.9-2018.7</em></td>\n          <td style=\"border: none;\">Bachelor in Statistics</td>\n          <td style=\"border: none;\">Northwest University</td>\n        </tr>\n        <tr>\n          <td style=\"border: none;\"><em>2018.9-2021.7</em></td>\n          <td style=\"border: none;\">Master in Statistics</td>\n          <td style=\"border: none;\">Sun Yat-sen University</td>\n        </tr>\n        <tr>\n          <td style=\"border: none;\"><em>2021.9-present</em></td>\n          <td style=\"border: none;\">PhD in Statistics</td>\n          <td style=\"border: none;\">Sun Yat-sen University</td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n\n\n","source":"info/index.md","raw":"---\ntitle: about me\nlayout: about\ndate: 2023-03-22 20:52:41\nsticky: 100\ntop: true\nmathjax: true\n---\n\n\n\n<table style=\"width: 100%; border-collapse: collapse; border: none;\">\n  <tr>\n    <td style=\"width: 30%; vertical-align: top; border: none;\">\n      <img src=\"photo.jpg\" alt=\"Taken on Guangzhou in 2019\" style=\"width: 100%;\" />\n    </td>\n    <td style=\"width: 70%; vertical-align: top; border: none;\">\n      <p>I'm Haoming Wang (<span style=\"font-family: 楷体_GB2312;\">王浩铭</span>), a PhD student at Sun Yat-sen University. Here's my math blog sharing new ideas and reading notes. This site is built with <a href=\"https://hexo.io/\">Hexo</a> + <a href=\"https://github.com/\">GitHub</a>. Math is supported by <a href=\"https://www.mathjax.org/\">Mathjax</a>.\n      Any question about this site, please leave your comment below or through <a href=\"https://github.com/blueairM\">GitHub</a>.</p>\n      **Education:**\n      <table style=\"width: 100%; border-collapse: collapse; border: none; margin-top: 10px;\">\n        <tr>\n          <td style=\"border: none;\"><em>2014.9-2018.7</em></td>\n          <td style=\"border: none;\">Bachelor in Statistics</td>\n          <td style=\"border: none;\">Northwest University</td>\n        </tr>\n        <tr>\n          <td style=\"border: none;\"><em>2018.9-2021.7</em></td>\n          <td style=\"border: none;\">Master in Statistics</td>\n          <td style=\"border: none;\">Sun Yat-sen University</td>\n        </tr>\n        <tr>\n          <td style=\"border: none;\"><em>2021.9-present</em></td>\n          <td style=\"border: none;\">PhD in Statistics</td>\n          <td style=\"border: none;\">Sun Yat-sen University</td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n\n\n","updated":"2025-01-04T15:14:38.737Z","path":"info/index.html","comments":1,"_id":"cmfwcr5rp0002m8nx1txx7sok","content":"<table style=\"width: 100%; border-collapse: collapse; border: none;\">\r\n<tr>\r\n<td style=\"width: 30%; vertical-align: top; border: none;\">\r\n<img src=\"/info/index/photo.jpg\" alt=\"Taken on Guangzhou in 2019\" style=\"width: 100%;\">\r\n</td>\r\n<td style=\"width: 70%; vertical-align: top; border: none;\">\r\n<p>\r\nI'm Haoming Wang (<span style=\"font-family: 楷体_GB2312;\">王浩铭</span>), a PhD student at Sun\r\nYat-sen University. Here's my math blog sharing new ideas and reading\r\nnotes. This site is built with <a href=\"https://hexo.io/\">Hexo</a> +\r\n<a href=\"https://github.com/\">GitHub</a>. Math is supported by\r\n<a href=\"https://www.mathjax.org/\">Mathjax</a>. Any question about this\r\nsite, please leave your comment below or through\r\n<a href=\"https://github.com/blueairM\">GitHub</a>.\r\n</p>\r\n<strong>Education:</strong>\r\n<table style=\"width: 100%; border-collapse: collapse; border: none; margin-top: 10px;\">\r\n<tr>\r\n<td style=\"border: none;\">\r\n<em>2014.9-2018.7</em>\r\n</td>\r\n<td style=\"border: none;\">\r\nBachelor in Statistics\r\n</td>\r\n<td style=\"border: none;\">\r\nNorthwest University\r\n</td>\r\n</tr>\r\n<tr>\r\n<td style=\"border: none;\">\r\n<em>2018.9-2021.7</em>\r\n</td>\r\n<td style=\"border: none;\">\r\nMaster in Statistics\r\n</td>\r\n<td style=\"border: none;\">\r\nSun Yat-sen University\r\n</td>\r\n</tr>\r\n<tr>\r\n<td style=\"border: none;\">\r\n<em>2021.9-present</em>\r\n</td>\r\n<td style=\"border: none;\">\r\nPhD in Statistics\r\n</td>\r\n<td style=\"border: none;\">\r\nSun Yat-sen University\r\n</td>\r\n</tr>\r\n</table>\r\n</td>\r\n</tr>\r\n</table>\r\n","site":{"data":{}},"excerpt":"","more":"<table style=\"width: 100%; border-collapse: collapse; border: none;\">\r\n<tr>\r\n<td style=\"width: 30%; vertical-align: top; border: none;\">\r\n<img src=\"/info/index/photo.jpg\" alt=\"Taken on Guangzhou in 2019\" style=\"width: 100%;\">\r\n</td>\r\n<td style=\"width: 70%; vertical-align: top; border: none;\">\r\n<p>\r\nI'm Haoming Wang (<span style=\"font-family: 楷体_GB2312;\">王浩铭</span>), a PhD student at Sun\r\nYat-sen University. Here's my math blog sharing new ideas and reading\r\nnotes. This site is built with <a href=\"https://hexo.io/\">Hexo</a> +\r\n<a href=\"https://github.com/\">GitHub</a>. Math is supported by\r\n<a href=\"https://www.mathjax.org/\">Mathjax</a>. Any question about this\r\nsite, please leave your comment below or through\r\n<a href=\"https://github.com/blueairM\">GitHub</a>.\r\n</p>\r\n<strong>Education:</strong>\r\n<table style=\"width: 100%; border-collapse: collapse; border: none; margin-top: 10px;\">\r\n<tr>\r\n<td style=\"border: none;\">\r\n<em>2014.9-2018.7</em>\r\n</td>\r\n<td style=\"border: none;\">\r\nBachelor in Statistics\r\n</td>\r\n<td style=\"border: none;\">\r\nNorthwest University\r\n</td>\r\n</tr>\r\n<tr>\r\n<td style=\"border: none;\">\r\n<em>2018.9-2021.7</em>\r\n</td>\r\n<td style=\"border: none;\">\r\nMaster in Statistics\r\n</td>\r\n<td style=\"border: none;\">\r\nSun Yat-sen University\r\n</td>\r\n</tr>\r\n<tr>\r\n<td style=\"border: none;\">\r\n<em>2021.9-present</em>\r\n</td>\r\n<td style=\"border: none;\">\r\nPhD in Statistics\r\n</td>\r\n<td style=\"border: none;\">\r\nSun Yat-sen University\r\n</td>\r\n</tr>\r\n</table>\r\n</td>\r\n</tr>\r\n</table>\r\n"},{"_content":".gitment-container {\n  font-family: sans-serif;\n  font-size: 14px;\n  line-height: 1.5;\n  color: #333;\n  word-wrap: break-word;\n}\n\n.gitment-container * {\n  box-sizing: border-box;\n}\n\n.gitment-container *:disabled {\n  cursor: not-allowed;\n}\n\n.gitment-container a,\n.gitment-container a:visited {\n  cursor: pointer;\n  text-decoration: none;\n}\n\n.gitment-container a:hover {\n  text-decoration: underline;\n}\n\n.gitment-container .gitment-hidden {\n  display: none;\n}\n\n.gitment-container .gitment-spinner-icon {\n  fill: #333;\n\n  -webkit-animation: gitment-spin 1s steps(12) infinite;\n  animation: gitment-spin 1s steps(12) infinite;\n}\n\n@-webkit-keyframes gitment-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg)\n  }\n}\n\n@keyframes gitment-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg)\n  }\n}\n\n.gitment-root-container {\n  margin: 19px 0;\n}\n\n.gitment-header-container {\n  margin: 19px 0;\n}\n\n.gitment-header-like-btn,\n.gitment-comment-like-btn {\n  cursor: pointer;\n}\n\n.gitment-comment-like-btn {\n  float: right;\n}\n\n.gitment-comment-like-btn.liked {\n  color: #F44336;\n}\n\n.gitment-header-like-btn svg {\n  vertical-align: middle;\n  height: 30px;\n}\n\n.gitment-comment-like-btn svg {\n  vertical-align: middle;\n  height: 20px;\n}\n\n.gitment-header-like-btn.liked svg,\n.gitment-comment-like-btn.liked svg {\n  fill: #F44336;\n}\n\na.gitment-header-issue-link,\na.gitment-header-issue-link:visited {\n  float: right;\n  line-height: 30px;\n  color: #666;\n}\n\na.gitment-header-issue-link:hover {\n  color: #666;\n}\n\n.gitment-comments-loading,\n.gitment-comments-error,\n.gitment-comments-empty {\n  text-align: center;\n  margin: 50px 0;\n}\n\n.gitment-comments-list {\n  list-style: none;\n  padding-left: 0;\n  margin: 0 0 38px;\n}\n\n.gitment-comment,\n.gitment-editor-container {\n  position: relative;\n  min-height: 60px;\n  padding-left: 60px;\n  margin: 19px 0;\n}\n\n.gitment-comment-avatar,\n.gitment-editor-avatar {\n  float: left;\n  margin-left: -60px;\n}\n\n.gitment-comment-avatar,\n.gitment-comment-avatar-img,\n.gitment-comment-avatar,\n.gitment-editor-avatar-img,\n.gitment-editor-avatar svg {\n  width: 44px;\n  height: 44px;\n  border-radius: 3px;\n}\n\n.gitment-editor-avatar .gitment-github-icon {\n  fill: #fff;\n  background-color: #333;\n}\n\n.gitment-comment-main,\n.gitment-editor-main {\n  position: relative;\n  border: 1px solid #CFD8DC;\n  border-radius: 0;\n}\n\n.gitment-editor-main::before,\n.gitment-editor-main::after,\n.gitment-comment-main::before,\n.gitment-comment-main::after {\n  position: absolute;\n  top: 11px;\n  left: -16px;\n  display: block;\n  width: 0;\n  height: 0;\n  pointer-events: none;\n  content: \"\";\n  border-color: transparent;\n  border-style: solid solid outset;\n}\n\n.gitment-editor-main::before,\n.gitment-comment-main::before {\n  border-width: 8px;\n  border-right-color: #CFD8DC;\n}\n\n.gitment-editor-main::after,\n.gitment-comment-main::after {\n  margin-top: 1px;\n  margin-left: 2px;\n  border-width: 7px;\n  border-right-color: #fff;\n}\n\n.gitment-comment-header {\n  margin: 12px 15px;\n  color: #666;\n  background-color: #fff;\n  border-radius: 3px;\n}\n\n.gitment-editor-header {\n  padding: 0;\n  margin: 0;\n  border-bottom: 1px solid #CFD8DC;\n}\n\na.gitment-comment-name,\na.gitment-comment-name:visited {\n  font-weight: 600;\n  color: #666;\n}\n\n.gitment-editor-tabs {\n  margin-bottom: -1px;\n  margin-left: -1px;\n}\n\n.gitment-editor-tab {\n  display: inline-block;\n  padding: 11px 12px;\n  font-size: 14px;\n  line-height: 20px;\n  color: #666;\n  text-decoration: none;\n  background-color: transparent;\n  border-width: 0 1px;\n  border-style: solid;\n  border-color: transparent;\n  border-radius: 0;\n\n  white-space: nowrap;\n  cursor: pointer;\n  user-select: none;\n\n  outline: none;\n}\n\n.gitment-editor-tab.gitment-selected {\n  color: #333;\n  background-color: #fff;\n  border-color: #CFD8DC;\n}\n\n.gitment-editor-login {\n  float: right;\n  margin-top: -30px;\n  margin-right: 15px;\n}\n\na.gitment-footer-project-link,\na.gitment-footer-project-link:visited,\na.gitment-editor-login-link,\na.gitment-editor-login-link:visited {\n  color: #2196F3;\n}\n\na.gitment-editor-logout-link,\na.gitment-editor-logout-link:visited {\n  color: #666;\n}\n\na.gitment-editor-logout-link:hover {\n  color: #2196F3;\n  text-decoration: none;\n}\n\n.gitment-comment-body {\n  position: relative;\n  margin: 12px 15px;\n  overflow: hidden;\n  border-radius: 3px;\n}\n\n.gitment-comment-body-folded {\n  cursor: pointer;\n}\n\n.gitment-comment-body-folded::before {\n  display: block !important;\n  content: \"\";\n  position: absolute;\n  width: 100%;\n  left: 0;\n  top: 0;\n  bottom: 50px;\n  pointer-events: none;\n  background: -webkit-linear-gradient(top, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9));\n  background: linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9));\n}\n\n.gitment-comment-body-folded::after {\n  display: block !important;\n  content: \"Click to Expand\" !important;\n  text-align: center;\n  color: #666;\n  position: absolute;\n  width: 100%;\n  height: 50px;\n  line-height: 50px;\n  left: 0;\n  bottom: 0;\n  pointer-events: none;\n  background: rgba(255, 255, 255, .9);\n}\n\n.gitment-editor-body {\n  margin: 0;\n}\n\n.gitment-comment-body > *:first-child,\n.gitment-editor-preview > *:first-child {\n  margin-top: 0 !important;\n}\n\n.gitment-comment-body > *:last-child,\n.gitment-editor-preview > *:last-child {\n  margin-bottom: 0 !important;\n}\n\n.gitment-editor-body textarea {\n  display: block;\n  width: 100%;\n  min-height: 150px;\n  max-height: 500px;\n  padding: 16px;\n  resize: vertical;\n\n  max-width: 100%;\n  margin: 0;\n  font-size: 14px;\n  line-height: 1.6;\n\n  background-color: #fff;\n\n  color: #333;\n  vertical-align: middle;\n  border: none;\n  border-radius: 0;\n  outline: none;\n  box-shadow: none;\n\n  overflow: visible;\n}\n\n.gitment-editor-body textarea:focus {\n  background-color: #fff;\n}\n\n.gitment-editor-preview {\n  min-height: 150px;\n\n  padding: 16px;\n  background-color: transparent;\n\n  width: 100%;\n  font-size: 14px;\n\n  line-height: 1.5;\n  word-wrap: break-word;\n}\n\n.gitment-editor-footer {\n  padding: 0;\n  margin-top: 10px;\n}\n\n.gitment-editor-footer::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\na.gitment-editor-footer-tip {\n  display: inline-block;\n  padding-top: 10px;\n  font-size: 12px;\n  color: #666;\n}\n\na.gitment-editor-footer-tip:hover {\n  color: #2196F3;\n  text-decoration: none;\n}\n\n.gitment-comments-pagination {\n  list-style: none;\n  text-align: right;\n  border-radius: 0;\n  margin: -19px 0 19px 0;\n}\n\n.gitment-comments-page-item {\n  display: inline-block;\n  cursor: pointer;\n  border: 1px solid #CFD8DC;\n  margin-left: -1px;\n  padding: .25rem .5rem;\n}\n\n.gitment-comments-page-item:hover {\n  background-color: #f5f5f5;\n}\n\n.gitment-comments-page-item.gitment-selected {\n  background-color: #f5f5f5;\n}\n\n.gitment-editor-submit,\n.gitment-comments-init-btn {\n  color: #fff;\n  background-color: #00BCD4;\n\n  position: relative;\n  display: inline-block;\n  padding: 7px 13px;\n  font-size: 14px;\n  font-weight: 600;\n  line-height: 20px;\n  white-space: nowrap;\n  vertical-align: middle;\n  cursor: pointer;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  background-size: 110% 110%;\n  border: none;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n}\n\n.gitment-editor-submit:hover,\n.gitment-comments-init-btn:hover {\n  background-color: #00ACC1;\n}\n\n.gitment-comments-init-btn:disabled,\n.gitment-editor-submit:disabled {\n  color: rgba(255,255,255,0.75);\n  background-color: #4DD0E1;\n  box-shadow: none;\n}\n\n.gitment-editor-submit {\n  float: right;\n}\n\n.gitment-footer-container {\n  margin-top: 30px;\n  margin-bottom: 20px;\n  text-align: right;\n  font-size: 12px;\n}\n\n/*\n * Markdown CSS\n * Copied from https://github.com/sindresorhus/github-markdown-css\n */\n.gitment-markdown {\n  -ms-text-size-adjust: 100%;\n  -webkit-text-size-adjust: 100%;\n  line-height: 1.5;\n  color: #333;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n  font-size: 16px;\n  line-height: 1.5;\n  word-wrap: break-word;\n}\n\n.gitment-markdown .pl-c {\n  color: #969896;\n}\n\n.gitment-markdown .pl-c1,\n.gitment-markdown .pl-s .pl-v {\n  color: #0086b3;\n}\n\n.gitment-markdown .pl-e,\n.gitment-markdown .pl-en {\n  color: #795da3;\n}\n\n.gitment-markdown .pl-smi,\n.gitment-markdown .pl-s .pl-s1 {\n  color: #333;\n}\n\n.gitment-markdown .pl-ent {\n  color: #63a35c;\n}\n\n.gitment-markdown .pl-k {\n  color: #a71d5d;\n}\n\n.gitment-markdown .pl-s,\n.gitment-markdown .pl-pds,\n.gitment-markdown .pl-s .pl-pse .pl-s1,\n.gitment-markdown .pl-sr,\n.gitment-markdown .pl-sr .pl-cce,\n.gitment-markdown .pl-sr .pl-sre,\n.gitment-markdown .pl-sr .pl-sra {\n  color: #183691;\n}\n\n.gitment-markdown .pl-v,\n.gitment-markdown .pl-smw {\n  color: #ed6a43;\n}\n\n.gitment-markdown .pl-bu {\n  color: #b52a1d;\n}\n\n.gitment-markdown .pl-ii {\n  color: #f8f8f8;\n  background-color: #b52a1d;\n}\n\n.gitment-markdown .pl-c2 {\n  color: #f8f8f8;\n  background-color: #b52a1d;\n}\n\n.gitment-markdown .pl-c2::before {\n  content: \"^M\";\n}\n\n.gitment-markdown .pl-sr .pl-cce {\n  font-weight: bold;\n  color: #63a35c;\n}\n\n.gitment-markdown .pl-ml {\n  color: #693a17;\n}\n\n.gitment-markdown .pl-mh,\n.gitment-markdown .pl-mh .pl-en,\n.gitment-markdown .pl-ms {\n  font-weight: bold;\n  color: #1d3e81;\n}\n\n.gitment-markdown .pl-mq {\n  color: #008080;\n}\n\n.gitment-markdown .pl-mi {\n  font-style: italic;\n  color: #333;\n}\n\n.gitment-markdown .pl-mb {\n  font-weight: bold;\n  color: #333;\n}\n\n.gitment-markdown .pl-md {\n  color: #bd2c00;\n  background-color: #ffecec;\n}\n\n.gitment-markdown .pl-mi1 {\n  color: #55a532;\n  background-color: #eaffea;\n}\n\n.gitment-markdown .pl-mc {\n  color: #ef9700;\n  background-color: #ffe3b4;\n}\n\n.gitment-markdown .pl-mi2 {\n  color: #d8d8d8;\n  background-color: #808080;\n}\n\n.gitment-markdown .pl-mdr {\n  font-weight: bold;\n  color: #795da3;\n}\n\n.gitment-markdown .pl-mo {\n  color: #1d3e81;\n}\n\n.gitment-markdown .pl-ba {\n  color: #595e62;\n}\n\n.gitment-markdown .pl-sg {\n  color: #c0c0c0;\n}\n\n.gitment-markdown .pl-corl {\n  text-decoration: underline;\n  color: #183691;\n}\n\n.gitment-markdown .octicon {\n  display: inline-block;\n  vertical-align: text-top;\n  fill: currentColor;\n}\n\n.gitment-markdown a {\n  background-color: transparent;\n  -webkit-text-decoration-skip: objects;\n}\n\n.gitment-markdown a:active,\n.gitment-markdown a:hover {\n  outline-width: 0;\n}\n\n.gitment-markdown strong {\n  font-weight: inherit;\n}\n\n.gitment-markdown strong {\n  font-weight: bolder;\n}\n\n.gitment-markdown h1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n.gitment-markdown img {\n  border-style: none;\n}\n\n.gitment-markdown svg:not(:root) {\n  overflow: hidden;\n}\n\n.gitment-markdown code,\n.gitment-markdown kbd,\n.gitment-markdown pre {\n  font-family: monospace, monospace;\n  font-size: 1em;\n}\n\n.gitment-markdown hr {\n  box-sizing: content-box;\n  height: 0;\n  overflow: visible;\n}\n\n.gitment-markdown input {\n  font: inherit;\n  margin: 0;\n}\n\n.gitment-markdown input {\n  overflow: visible;\n}\n\n.gitment-markdown [type=\"checkbox\"] {\n  box-sizing: border-box;\n  padding: 0;\n}\n\n.gitment-markdown * {\n  box-sizing: border-box;\n}\n\n.gitment-markdown input {\n  font-family: inherit;\n  font-size: inherit;\n  line-height: inherit;\n}\n\n.gitment-markdown a {\n  color: #0366d6;\n  text-decoration: none;\n}\n\n.gitment-markdown a:hover {\n  text-decoration: underline;\n}\n\n.gitment-markdown strong {\n  font-weight: 600;\n}\n\n.gitment-markdown hr {\n  height: 0;\n  margin: 15px 0;\n  overflow: hidden;\n  background: transparent;\n  border: 0;\n  border-bottom: 1px solid #dfe2e5;\n}\n\n.gitment-markdown hr::before {\n  display: table;\n  content: \"\";\n}\n\n.gitment-markdown hr::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\n.gitment-markdown table {\n  border-spacing: 0;\n  border-collapse: collapse;\n}\n\n.gitment-markdown td,\n.gitment-markdown th {\n  padding: 0;\n}\n\n.gitment-markdown h1,\n.gitment-markdown h2,\n.gitment-markdown h3,\n.gitment-markdown h4,\n.gitment-markdown h5,\n.gitment-markdown h6 {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown h1 {\n  font-size: 32px;\n  font-weight: 600;\n}\n\n.gitment-markdown h2 {\n  font-size: 24px;\n  font-weight: 600;\n}\n\n.gitment-markdown h3 {\n  font-size: 20px;\n  font-weight: 600;\n}\n\n.gitment-markdown h4 {\n  font-size: 16px;\n  font-weight: 600;\n}\n\n.gitment-markdown h5 {\n  font-size: 14px;\n  font-weight: 600;\n}\n\n.gitment-markdown h6 {\n  font-size: 12px;\n  font-weight: 600;\n}\n\n.gitment-markdown p {\n  margin-top: 0;\n  margin-bottom: 10px;\n}\n\n.gitment-markdown blockquote {\n  margin: 0;\n}\n\n.gitment-markdown ul,\n.gitment-markdown ol {\n  padding-left: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown ol ol,\n.gitment-markdown ul ol {\n  list-style-type: lower-roman;\n}\n\n.gitment-markdown ul ul ol,\n.gitment-markdown ul ol ol,\n.gitment-markdown ol ul ol,\n.gitment-markdown ol ol ol {\n  list-style-type: lower-alpha;\n}\n\n.gitment-markdown dd {\n  margin-left: 0;\n}\n\n.gitment-markdown code {\n  font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  font-size: 12px;\n}\n\n.gitment-markdown pre {\n  margin-top: 0;\n  margin-bottom: 0;\n  font: 12px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n}\n\n.gitment-markdown .octicon {\n  vertical-align: text-bottom;\n}\n\n.gitment-markdown .pl-0 {\n  padding-left: 0 !important;\n}\n\n.gitment-markdown .pl-1 {\n  padding-left: 4px !important;\n}\n\n.gitment-markdown .pl-2 {\n  padding-left: 8px !important;\n}\n\n.gitment-markdown .pl-3 {\n  padding-left: 16px !important;\n}\n\n.gitment-markdown .pl-4 {\n  padding-left: 24px !important;\n}\n\n.gitment-markdown .pl-5 {\n  padding-left: 32px !important;\n}\n\n.gitment-markdown .pl-6 {\n  padding-left: 40px !important;\n}\n\n.gitment-markdown::before {\n  display: table;\n  content: \"\";\n}\n\n.gitment-markdown::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\n.gitment-markdown>*:first-child {\n  margin-top: 0 !important;\n}\n\n.gitment-markdown>*:last-child {\n  margin-bottom: 0 !important;\n}\n\n.gitment-markdown a:not([href]) {\n  color: inherit;\n  text-decoration: none;\n}\n\n.gitment-markdown .anchor {\n  float: left;\n  padding-right: 4px;\n  margin-left: -20px;\n  line-height: 1;\n}\n\n.gitment-markdown .anchor:focus {\n  outline: none;\n}\n\n.gitment-markdown p,\n.gitment-markdown blockquote,\n.gitment-markdown ul,\n.gitment-markdown ol,\n.gitment-markdown dl,\n.gitment-markdown table,\n.gitment-markdown pre {\n  margin-top: 0;\n  margin-bottom: 16px;\n}\n\n.gitment-markdown hr {\n  height: 0.25em;\n  padding: 0;\n  margin: 24px 0;\n  background-color: #e1e4e8;\n  border: 0;\n}\n\n.gitment-markdown blockquote {\n  padding: 0 1em;\n  color: #6a737d;\n  border-left: 0.25em solid #dfe2e5;\n}\n\n.gitment-markdown blockquote>:first-child {\n  margin-top: 0;\n}\n\n.gitment-markdown blockquote>:last-child {\n  margin-bottom: 0;\n}\n\n.gitment-markdown kbd {\n  display: inline-block;\n  padding: 3px 5px;\n  font-size: 11px;\n  line-height: 10px;\n  color: #444d56;\n  vertical-align: middle;\n  background-color: #fafbfc;\n  border: solid 1px #c6cbd1;\n  border-bottom-color: #959da5;\n  border-radius: 0;\n  box-shadow: inset 0 -1px 0 #959da5;\n}\n\n.gitment-markdown h1,\n.gitment-markdown h2,\n.gitment-markdown h3,\n.gitment-markdown h4,\n.gitment-markdown h5,\n.gitment-markdown h6 {\n  margin-top: 24px;\n  margin-bottom: 16px;\n  font-weight: 600;\n  line-height: 1.25;\n}\n\n.gitment-markdown h1 .octicon-link,\n.gitment-markdown h2 .octicon-link,\n.gitment-markdown h3 .octicon-link,\n.gitment-markdown h4 .octicon-link,\n.gitment-markdown h5 .octicon-link,\n.gitment-markdown h6 .octicon-link {\n  color: #1b1f23;\n  vertical-align: middle;\n  visibility: hidden;\n}\n\n.gitment-markdown h1:hover .anchor,\n.gitment-markdown h2:hover .anchor,\n.gitment-markdown h3:hover .anchor,\n.gitment-markdown h4:hover .anchor,\n.gitment-markdown h5:hover .anchor,\n.gitment-markdown h6:hover .anchor {\n  text-decoration: none;\n}\n\n.gitment-markdown h1:hover .anchor .octicon-link,\n.gitment-markdown h2:hover .anchor .octicon-link,\n.gitment-markdown h3:hover .anchor .octicon-link,\n.gitment-markdown h4:hover .anchor .octicon-link,\n.gitment-markdown h5:hover .anchor .octicon-link,\n.gitment-markdown h6:hover .anchor .octicon-link {\n  visibility: visible;\n}\n\n.gitment-markdown h1 {\n  padding-bottom: 0.3em;\n  font-size: 2em;\n  border-bottom: 1px solid #eaecef;\n}\n\n.gitment-markdown h2 {\n  padding-bottom: 0.3em;\n  font-size: 1.5em;\n  border-bottom: 1px solid #eaecef;\n}\n\n.gitment-markdown h3 {\n  font-size: 1.25em;\n}\n\n.gitment-markdown h4 {\n  font-size: 1em;\n}\n\n.gitment-markdown h5 {\n  font-size: 0.875em;\n}\n\n.gitment-markdown h6 {\n  font-size: 0.85em;\n  color: #6a737d;\n}\n\n.gitment-markdown ul,\n.gitment-markdown ol {\n  padding-left: 2em;\n}\n\n.gitment-markdown ul ul,\n.gitment-markdown ul ol,\n.gitment-markdown ol ol,\n.gitment-markdown ol ul {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown li>p {\n  margin-top: 16px;\n}\n\n.gitment-markdown li+li {\n  margin-top: 0.25em;\n}\n\n.gitment-markdown dl {\n  padding: 0;\n}\n\n.gitment-markdown dl dt {\n  padding: 0;\n  margin-top: 16px;\n  font-size: 1em;\n  font-style: italic;\n  font-weight: 600;\n}\n\n.gitment-markdown dl dd {\n  padding: 0 16px;\n  margin-bottom: 16px;\n}\n\n.gitment-markdown table {\n  display: block;\n  width: 100%;\n  overflow: auto;\n}\n\n.gitment-markdown table th {\n  font-weight: 600;\n}\n\n.gitment-markdown table th,\n.gitment-markdown table td {\n  padding: 6px 13px;\n  border: 1px solid #dfe2e5;\n}\n\n.gitment-markdown table tr {\n  background-color: #fff;\n  border-top: 1px solid #c6cbd1;\n}\n\n.gitment-markdown table tr:nth-child(2n) {\n  background-color: #f5f5f5;\n}\n\n.gitment-markdown img {\n  max-width: 100%;\n  box-sizing: content-box;\n  background-color: #fff;\n}\n\n.gitment-markdown code {\n  padding: 0;\n  padding-top: 0.2em;\n  padding-bottom: 0.2em;\n  margin: 0;\n  font-size: 85%;\n  background-color: rgba(27,31,35,0.05);\n  border-radius: 0;\n}\n\n.gitment-markdown code::before,\n.gitment-markdown code::after {\n  letter-spacing: -0.2em;\n  content: \"\\00a0\";\n}\n\n.gitment-markdown pre {\n  word-wrap: normal;\n}\n\n.gitment-markdown pre>code {\n  padding: 0;\n  margin: 0;\n  font-size: 100%;\n  word-break: normal;\n  white-space: pre;\n  background: transparent;\n  border: 0;\n}\n\n.gitment-markdown .highlight {\n  margin-bottom: 16px;\n}\n\n.gitment-markdown .highlight pre {\n  margin-bottom: 0;\n  word-break: normal;\n}\n\n.gitment-markdown .highlight pre,\n.gitment-markdown pre {\n  padding: 16px;\n  overflow: auto;\n  font-size: 85%;\n  line-height: 1.45;\n  background-color: #f5f5f5;\n  border-radius: 0;\n}\n\n.gitment-markdown pre code {\n  display: inline;\n  max-width: auto;\n  padding: 0;\n  margin: 0;\n  overflow: visible;\n  line-height: inherit;\n  word-wrap: normal;\n  background-color: transparent;\n  border: 0;\n}\n\n.gitment-markdown pre code::before,\n.gitment-markdown pre code::after {\n  content: normal;\n}\n\n.gitment-markdown .full-commit .btn-outline:not(:disabled):hover {\n  color: #005cc5;\n  border-color: #005cc5;\n}\n\n.gitment-markdown kbd {\n  display: inline-block;\n  padding: 3px 5px;\n  font: 11px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  line-height: 10px;\n  color: #444d56;\n  vertical-align: middle;\n  background-color: #fcfcfc;\n  border: solid 1px #c6cbd1;\n  border-bottom-color: #959da5;\n  border-radius: 0;\n  box-shadow: inset 0 -1px 0 #959da5;\n}\n\n.gitment-markdown :checked+.radio-label {\n  position: relative;\n  z-index: 1;\n  border-color: #0366d6;\n}\n\n.gitment-markdown .task-list-item {\n  list-style-type: none;\n}\n\n.gitment-markdown .task-list-item+.task-list-item {\n  margin-top: 3px;\n}\n\n.gitment-markdown .task-list-item input {\n  margin: 0 0.2em 0.25em -1.6em;\n  vertical-align: middle;\n}\n\n.gitment-markdown hr {\n  border-bottom-color: #eee;\n}\n","source":"css/gitment.css","raw":".gitment-container {\n  font-family: sans-serif;\n  font-size: 14px;\n  line-height: 1.5;\n  color: #333;\n  word-wrap: break-word;\n}\n\n.gitment-container * {\n  box-sizing: border-box;\n}\n\n.gitment-container *:disabled {\n  cursor: not-allowed;\n}\n\n.gitment-container a,\n.gitment-container a:visited {\n  cursor: pointer;\n  text-decoration: none;\n}\n\n.gitment-container a:hover {\n  text-decoration: underline;\n}\n\n.gitment-container .gitment-hidden {\n  display: none;\n}\n\n.gitment-container .gitment-spinner-icon {\n  fill: #333;\n\n  -webkit-animation: gitment-spin 1s steps(12) infinite;\n  animation: gitment-spin 1s steps(12) infinite;\n}\n\n@-webkit-keyframes gitment-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg)\n  }\n}\n\n@keyframes gitment-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg)\n  }\n}\n\n.gitment-root-container {\n  margin: 19px 0;\n}\n\n.gitment-header-container {\n  margin: 19px 0;\n}\n\n.gitment-header-like-btn,\n.gitment-comment-like-btn {\n  cursor: pointer;\n}\n\n.gitment-comment-like-btn {\n  float: right;\n}\n\n.gitment-comment-like-btn.liked {\n  color: #F44336;\n}\n\n.gitment-header-like-btn svg {\n  vertical-align: middle;\n  height: 30px;\n}\n\n.gitment-comment-like-btn svg {\n  vertical-align: middle;\n  height: 20px;\n}\n\n.gitment-header-like-btn.liked svg,\n.gitment-comment-like-btn.liked svg {\n  fill: #F44336;\n}\n\na.gitment-header-issue-link,\na.gitment-header-issue-link:visited {\n  float: right;\n  line-height: 30px;\n  color: #666;\n}\n\na.gitment-header-issue-link:hover {\n  color: #666;\n}\n\n.gitment-comments-loading,\n.gitment-comments-error,\n.gitment-comments-empty {\n  text-align: center;\n  margin: 50px 0;\n}\n\n.gitment-comments-list {\n  list-style: none;\n  padding-left: 0;\n  margin: 0 0 38px;\n}\n\n.gitment-comment,\n.gitment-editor-container {\n  position: relative;\n  min-height: 60px;\n  padding-left: 60px;\n  margin: 19px 0;\n}\n\n.gitment-comment-avatar,\n.gitment-editor-avatar {\n  float: left;\n  margin-left: -60px;\n}\n\n.gitment-comment-avatar,\n.gitment-comment-avatar-img,\n.gitment-comment-avatar,\n.gitment-editor-avatar-img,\n.gitment-editor-avatar svg {\n  width: 44px;\n  height: 44px;\n  border-radius: 3px;\n}\n\n.gitment-editor-avatar .gitment-github-icon {\n  fill: #fff;\n  background-color: #333;\n}\n\n.gitment-comment-main,\n.gitment-editor-main {\n  position: relative;\n  border: 1px solid #CFD8DC;\n  border-radius: 0;\n}\n\n.gitment-editor-main::before,\n.gitment-editor-main::after,\n.gitment-comment-main::before,\n.gitment-comment-main::after {\n  position: absolute;\n  top: 11px;\n  left: -16px;\n  display: block;\n  width: 0;\n  height: 0;\n  pointer-events: none;\n  content: \"\";\n  border-color: transparent;\n  border-style: solid solid outset;\n}\n\n.gitment-editor-main::before,\n.gitment-comment-main::before {\n  border-width: 8px;\n  border-right-color: #CFD8DC;\n}\n\n.gitment-editor-main::after,\n.gitment-comment-main::after {\n  margin-top: 1px;\n  margin-left: 2px;\n  border-width: 7px;\n  border-right-color: #fff;\n}\n\n.gitment-comment-header {\n  margin: 12px 15px;\n  color: #666;\n  background-color: #fff;\n  border-radius: 3px;\n}\n\n.gitment-editor-header {\n  padding: 0;\n  margin: 0;\n  border-bottom: 1px solid #CFD8DC;\n}\n\na.gitment-comment-name,\na.gitment-comment-name:visited {\n  font-weight: 600;\n  color: #666;\n}\n\n.gitment-editor-tabs {\n  margin-bottom: -1px;\n  margin-left: -1px;\n}\n\n.gitment-editor-tab {\n  display: inline-block;\n  padding: 11px 12px;\n  font-size: 14px;\n  line-height: 20px;\n  color: #666;\n  text-decoration: none;\n  background-color: transparent;\n  border-width: 0 1px;\n  border-style: solid;\n  border-color: transparent;\n  border-radius: 0;\n\n  white-space: nowrap;\n  cursor: pointer;\n  user-select: none;\n\n  outline: none;\n}\n\n.gitment-editor-tab.gitment-selected {\n  color: #333;\n  background-color: #fff;\n  border-color: #CFD8DC;\n}\n\n.gitment-editor-login {\n  float: right;\n  margin-top: -30px;\n  margin-right: 15px;\n}\n\na.gitment-footer-project-link,\na.gitment-footer-project-link:visited,\na.gitment-editor-login-link,\na.gitment-editor-login-link:visited {\n  color: #2196F3;\n}\n\na.gitment-editor-logout-link,\na.gitment-editor-logout-link:visited {\n  color: #666;\n}\n\na.gitment-editor-logout-link:hover {\n  color: #2196F3;\n  text-decoration: none;\n}\n\n.gitment-comment-body {\n  position: relative;\n  margin: 12px 15px;\n  overflow: hidden;\n  border-radius: 3px;\n}\n\n.gitment-comment-body-folded {\n  cursor: pointer;\n}\n\n.gitment-comment-body-folded::before {\n  display: block !important;\n  content: \"\";\n  position: absolute;\n  width: 100%;\n  left: 0;\n  top: 0;\n  bottom: 50px;\n  pointer-events: none;\n  background: -webkit-linear-gradient(top, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9));\n  background: linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9));\n}\n\n.gitment-comment-body-folded::after {\n  display: block !important;\n  content: \"Click to Expand\" !important;\n  text-align: center;\n  color: #666;\n  position: absolute;\n  width: 100%;\n  height: 50px;\n  line-height: 50px;\n  left: 0;\n  bottom: 0;\n  pointer-events: none;\n  background: rgba(255, 255, 255, .9);\n}\n\n.gitment-editor-body {\n  margin: 0;\n}\n\n.gitment-comment-body > *:first-child,\n.gitment-editor-preview > *:first-child {\n  margin-top: 0 !important;\n}\n\n.gitment-comment-body > *:last-child,\n.gitment-editor-preview > *:last-child {\n  margin-bottom: 0 !important;\n}\n\n.gitment-editor-body textarea {\n  display: block;\n  width: 100%;\n  min-height: 150px;\n  max-height: 500px;\n  padding: 16px;\n  resize: vertical;\n\n  max-width: 100%;\n  margin: 0;\n  font-size: 14px;\n  line-height: 1.6;\n\n  background-color: #fff;\n\n  color: #333;\n  vertical-align: middle;\n  border: none;\n  border-radius: 0;\n  outline: none;\n  box-shadow: none;\n\n  overflow: visible;\n}\n\n.gitment-editor-body textarea:focus {\n  background-color: #fff;\n}\n\n.gitment-editor-preview {\n  min-height: 150px;\n\n  padding: 16px;\n  background-color: transparent;\n\n  width: 100%;\n  font-size: 14px;\n\n  line-height: 1.5;\n  word-wrap: break-word;\n}\n\n.gitment-editor-footer {\n  padding: 0;\n  margin-top: 10px;\n}\n\n.gitment-editor-footer::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\na.gitment-editor-footer-tip {\n  display: inline-block;\n  padding-top: 10px;\n  font-size: 12px;\n  color: #666;\n}\n\na.gitment-editor-footer-tip:hover {\n  color: #2196F3;\n  text-decoration: none;\n}\n\n.gitment-comments-pagination {\n  list-style: none;\n  text-align: right;\n  border-radius: 0;\n  margin: -19px 0 19px 0;\n}\n\n.gitment-comments-page-item {\n  display: inline-block;\n  cursor: pointer;\n  border: 1px solid #CFD8DC;\n  margin-left: -1px;\n  padding: .25rem .5rem;\n}\n\n.gitment-comments-page-item:hover {\n  background-color: #f5f5f5;\n}\n\n.gitment-comments-page-item.gitment-selected {\n  background-color: #f5f5f5;\n}\n\n.gitment-editor-submit,\n.gitment-comments-init-btn {\n  color: #fff;\n  background-color: #00BCD4;\n\n  position: relative;\n  display: inline-block;\n  padding: 7px 13px;\n  font-size: 14px;\n  font-weight: 600;\n  line-height: 20px;\n  white-space: nowrap;\n  vertical-align: middle;\n  cursor: pointer;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  background-size: 110% 110%;\n  border: none;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n}\n\n.gitment-editor-submit:hover,\n.gitment-comments-init-btn:hover {\n  background-color: #00ACC1;\n}\n\n.gitment-comments-init-btn:disabled,\n.gitment-editor-submit:disabled {\n  color: rgba(255,255,255,0.75);\n  background-color: #4DD0E1;\n  box-shadow: none;\n}\n\n.gitment-editor-submit {\n  float: right;\n}\n\n.gitment-footer-container {\n  margin-top: 30px;\n  margin-bottom: 20px;\n  text-align: right;\n  font-size: 12px;\n}\n\n/*\n * Markdown CSS\n * Copied from https://github.com/sindresorhus/github-markdown-css\n */\n.gitment-markdown {\n  -ms-text-size-adjust: 100%;\n  -webkit-text-size-adjust: 100%;\n  line-height: 1.5;\n  color: #333;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n  font-size: 16px;\n  line-height: 1.5;\n  word-wrap: break-word;\n}\n\n.gitment-markdown .pl-c {\n  color: #969896;\n}\n\n.gitment-markdown .pl-c1,\n.gitment-markdown .pl-s .pl-v {\n  color: #0086b3;\n}\n\n.gitment-markdown .pl-e,\n.gitment-markdown .pl-en {\n  color: #795da3;\n}\n\n.gitment-markdown .pl-smi,\n.gitment-markdown .pl-s .pl-s1 {\n  color: #333;\n}\n\n.gitment-markdown .pl-ent {\n  color: #63a35c;\n}\n\n.gitment-markdown .pl-k {\n  color: #a71d5d;\n}\n\n.gitment-markdown .pl-s,\n.gitment-markdown .pl-pds,\n.gitment-markdown .pl-s .pl-pse .pl-s1,\n.gitment-markdown .pl-sr,\n.gitment-markdown .pl-sr .pl-cce,\n.gitment-markdown .pl-sr .pl-sre,\n.gitment-markdown .pl-sr .pl-sra {\n  color: #183691;\n}\n\n.gitment-markdown .pl-v,\n.gitment-markdown .pl-smw {\n  color: #ed6a43;\n}\n\n.gitment-markdown .pl-bu {\n  color: #b52a1d;\n}\n\n.gitment-markdown .pl-ii {\n  color: #f8f8f8;\n  background-color: #b52a1d;\n}\n\n.gitment-markdown .pl-c2 {\n  color: #f8f8f8;\n  background-color: #b52a1d;\n}\n\n.gitment-markdown .pl-c2::before {\n  content: \"^M\";\n}\n\n.gitment-markdown .pl-sr .pl-cce {\n  font-weight: bold;\n  color: #63a35c;\n}\n\n.gitment-markdown .pl-ml {\n  color: #693a17;\n}\n\n.gitment-markdown .pl-mh,\n.gitment-markdown .pl-mh .pl-en,\n.gitment-markdown .pl-ms {\n  font-weight: bold;\n  color: #1d3e81;\n}\n\n.gitment-markdown .pl-mq {\n  color: #008080;\n}\n\n.gitment-markdown .pl-mi {\n  font-style: italic;\n  color: #333;\n}\n\n.gitment-markdown .pl-mb {\n  font-weight: bold;\n  color: #333;\n}\n\n.gitment-markdown .pl-md {\n  color: #bd2c00;\n  background-color: #ffecec;\n}\n\n.gitment-markdown .pl-mi1 {\n  color: #55a532;\n  background-color: #eaffea;\n}\n\n.gitment-markdown .pl-mc {\n  color: #ef9700;\n  background-color: #ffe3b4;\n}\n\n.gitment-markdown .pl-mi2 {\n  color: #d8d8d8;\n  background-color: #808080;\n}\n\n.gitment-markdown .pl-mdr {\n  font-weight: bold;\n  color: #795da3;\n}\n\n.gitment-markdown .pl-mo {\n  color: #1d3e81;\n}\n\n.gitment-markdown .pl-ba {\n  color: #595e62;\n}\n\n.gitment-markdown .pl-sg {\n  color: #c0c0c0;\n}\n\n.gitment-markdown .pl-corl {\n  text-decoration: underline;\n  color: #183691;\n}\n\n.gitment-markdown .octicon {\n  display: inline-block;\n  vertical-align: text-top;\n  fill: currentColor;\n}\n\n.gitment-markdown a {\n  background-color: transparent;\n  -webkit-text-decoration-skip: objects;\n}\n\n.gitment-markdown a:active,\n.gitment-markdown a:hover {\n  outline-width: 0;\n}\n\n.gitment-markdown strong {\n  font-weight: inherit;\n}\n\n.gitment-markdown strong {\n  font-weight: bolder;\n}\n\n.gitment-markdown h1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n.gitment-markdown img {\n  border-style: none;\n}\n\n.gitment-markdown svg:not(:root) {\n  overflow: hidden;\n}\n\n.gitment-markdown code,\n.gitment-markdown kbd,\n.gitment-markdown pre {\n  font-family: monospace, monospace;\n  font-size: 1em;\n}\n\n.gitment-markdown hr {\n  box-sizing: content-box;\n  height: 0;\n  overflow: visible;\n}\n\n.gitment-markdown input {\n  font: inherit;\n  margin: 0;\n}\n\n.gitment-markdown input {\n  overflow: visible;\n}\n\n.gitment-markdown [type=\"checkbox\"] {\n  box-sizing: border-box;\n  padding: 0;\n}\n\n.gitment-markdown * {\n  box-sizing: border-box;\n}\n\n.gitment-markdown input {\n  font-family: inherit;\n  font-size: inherit;\n  line-height: inherit;\n}\n\n.gitment-markdown a {\n  color: #0366d6;\n  text-decoration: none;\n}\n\n.gitment-markdown a:hover {\n  text-decoration: underline;\n}\n\n.gitment-markdown strong {\n  font-weight: 600;\n}\n\n.gitment-markdown hr {\n  height: 0;\n  margin: 15px 0;\n  overflow: hidden;\n  background: transparent;\n  border: 0;\n  border-bottom: 1px solid #dfe2e5;\n}\n\n.gitment-markdown hr::before {\n  display: table;\n  content: \"\";\n}\n\n.gitment-markdown hr::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\n.gitment-markdown table {\n  border-spacing: 0;\n  border-collapse: collapse;\n}\n\n.gitment-markdown td,\n.gitment-markdown th {\n  padding: 0;\n}\n\n.gitment-markdown h1,\n.gitment-markdown h2,\n.gitment-markdown h3,\n.gitment-markdown h4,\n.gitment-markdown h5,\n.gitment-markdown h6 {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown h1 {\n  font-size: 32px;\n  font-weight: 600;\n}\n\n.gitment-markdown h2 {\n  font-size: 24px;\n  font-weight: 600;\n}\n\n.gitment-markdown h3 {\n  font-size: 20px;\n  font-weight: 600;\n}\n\n.gitment-markdown h4 {\n  font-size: 16px;\n  font-weight: 600;\n}\n\n.gitment-markdown h5 {\n  font-size: 14px;\n  font-weight: 600;\n}\n\n.gitment-markdown h6 {\n  font-size: 12px;\n  font-weight: 600;\n}\n\n.gitment-markdown p {\n  margin-top: 0;\n  margin-bottom: 10px;\n}\n\n.gitment-markdown blockquote {\n  margin: 0;\n}\n\n.gitment-markdown ul,\n.gitment-markdown ol {\n  padding-left: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown ol ol,\n.gitment-markdown ul ol {\n  list-style-type: lower-roman;\n}\n\n.gitment-markdown ul ul ol,\n.gitment-markdown ul ol ol,\n.gitment-markdown ol ul ol,\n.gitment-markdown ol ol ol {\n  list-style-type: lower-alpha;\n}\n\n.gitment-markdown dd {\n  margin-left: 0;\n}\n\n.gitment-markdown code {\n  font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  font-size: 12px;\n}\n\n.gitment-markdown pre {\n  margin-top: 0;\n  margin-bottom: 0;\n  font: 12px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n}\n\n.gitment-markdown .octicon {\n  vertical-align: text-bottom;\n}\n\n.gitment-markdown .pl-0 {\n  padding-left: 0 !important;\n}\n\n.gitment-markdown .pl-1 {\n  padding-left: 4px !important;\n}\n\n.gitment-markdown .pl-2 {\n  padding-left: 8px !important;\n}\n\n.gitment-markdown .pl-3 {\n  padding-left: 16px !important;\n}\n\n.gitment-markdown .pl-4 {\n  padding-left: 24px !important;\n}\n\n.gitment-markdown .pl-5 {\n  padding-left: 32px !important;\n}\n\n.gitment-markdown .pl-6 {\n  padding-left: 40px !important;\n}\n\n.gitment-markdown::before {\n  display: table;\n  content: \"\";\n}\n\n.gitment-markdown::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\n.gitment-markdown>*:first-child {\n  margin-top: 0 !important;\n}\n\n.gitment-markdown>*:last-child {\n  margin-bottom: 0 !important;\n}\n\n.gitment-markdown a:not([href]) {\n  color: inherit;\n  text-decoration: none;\n}\n\n.gitment-markdown .anchor {\n  float: left;\n  padding-right: 4px;\n  margin-left: -20px;\n  line-height: 1;\n}\n\n.gitment-markdown .anchor:focus {\n  outline: none;\n}\n\n.gitment-markdown p,\n.gitment-markdown blockquote,\n.gitment-markdown ul,\n.gitment-markdown ol,\n.gitment-markdown dl,\n.gitment-markdown table,\n.gitment-markdown pre {\n  margin-top: 0;\n  margin-bottom: 16px;\n}\n\n.gitment-markdown hr {\n  height: 0.25em;\n  padding: 0;\n  margin: 24px 0;\n  background-color: #e1e4e8;\n  border: 0;\n}\n\n.gitment-markdown blockquote {\n  padding: 0 1em;\n  color: #6a737d;\n  border-left: 0.25em solid #dfe2e5;\n}\n\n.gitment-markdown blockquote>:first-child {\n  margin-top: 0;\n}\n\n.gitment-markdown blockquote>:last-child {\n  margin-bottom: 0;\n}\n\n.gitment-markdown kbd {\n  display: inline-block;\n  padding: 3px 5px;\n  font-size: 11px;\n  line-height: 10px;\n  color: #444d56;\n  vertical-align: middle;\n  background-color: #fafbfc;\n  border: solid 1px #c6cbd1;\n  border-bottom-color: #959da5;\n  border-radius: 0;\n  box-shadow: inset 0 -1px 0 #959da5;\n}\n\n.gitment-markdown h1,\n.gitment-markdown h2,\n.gitment-markdown h3,\n.gitment-markdown h4,\n.gitment-markdown h5,\n.gitment-markdown h6 {\n  margin-top: 24px;\n  margin-bottom: 16px;\n  font-weight: 600;\n  line-height: 1.25;\n}\n\n.gitment-markdown h1 .octicon-link,\n.gitment-markdown h2 .octicon-link,\n.gitment-markdown h3 .octicon-link,\n.gitment-markdown h4 .octicon-link,\n.gitment-markdown h5 .octicon-link,\n.gitment-markdown h6 .octicon-link {\n  color: #1b1f23;\n  vertical-align: middle;\n  visibility: hidden;\n}\n\n.gitment-markdown h1:hover .anchor,\n.gitment-markdown h2:hover .anchor,\n.gitment-markdown h3:hover .anchor,\n.gitment-markdown h4:hover .anchor,\n.gitment-markdown h5:hover .anchor,\n.gitment-markdown h6:hover .anchor {\n  text-decoration: none;\n}\n\n.gitment-markdown h1:hover .anchor .octicon-link,\n.gitment-markdown h2:hover .anchor .octicon-link,\n.gitment-markdown h3:hover .anchor .octicon-link,\n.gitment-markdown h4:hover .anchor .octicon-link,\n.gitment-markdown h5:hover .anchor .octicon-link,\n.gitment-markdown h6:hover .anchor .octicon-link {\n  visibility: visible;\n}\n\n.gitment-markdown h1 {\n  padding-bottom: 0.3em;\n  font-size: 2em;\n  border-bottom: 1px solid #eaecef;\n}\n\n.gitment-markdown h2 {\n  padding-bottom: 0.3em;\n  font-size: 1.5em;\n  border-bottom: 1px solid #eaecef;\n}\n\n.gitment-markdown h3 {\n  font-size: 1.25em;\n}\n\n.gitment-markdown h4 {\n  font-size: 1em;\n}\n\n.gitment-markdown h5 {\n  font-size: 0.875em;\n}\n\n.gitment-markdown h6 {\n  font-size: 0.85em;\n  color: #6a737d;\n}\n\n.gitment-markdown ul,\n.gitment-markdown ol {\n  padding-left: 2em;\n}\n\n.gitment-markdown ul ul,\n.gitment-markdown ul ol,\n.gitment-markdown ol ol,\n.gitment-markdown ol ul {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown li>p {\n  margin-top: 16px;\n}\n\n.gitment-markdown li+li {\n  margin-top: 0.25em;\n}\n\n.gitment-markdown dl {\n  padding: 0;\n}\n\n.gitment-markdown dl dt {\n  padding: 0;\n  margin-top: 16px;\n  font-size: 1em;\n  font-style: italic;\n  font-weight: 600;\n}\n\n.gitment-markdown dl dd {\n  padding: 0 16px;\n  margin-bottom: 16px;\n}\n\n.gitment-markdown table {\n  display: block;\n  width: 100%;\n  overflow: auto;\n}\n\n.gitment-markdown table th {\n  font-weight: 600;\n}\n\n.gitment-markdown table th,\n.gitment-markdown table td {\n  padding: 6px 13px;\n  border: 1px solid #dfe2e5;\n}\n\n.gitment-markdown table tr {\n  background-color: #fff;\n  border-top: 1px solid #c6cbd1;\n}\n\n.gitment-markdown table tr:nth-child(2n) {\n  background-color: #f5f5f5;\n}\n\n.gitment-markdown img {\n  max-width: 100%;\n  box-sizing: content-box;\n  background-color: #fff;\n}\n\n.gitment-markdown code {\n  padding: 0;\n  padding-top: 0.2em;\n  padding-bottom: 0.2em;\n  margin: 0;\n  font-size: 85%;\n  background-color: rgba(27,31,35,0.05);\n  border-radius: 0;\n}\n\n.gitment-markdown code::before,\n.gitment-markdown code::after {\n  letter-spacing: -0.2em;\n  content: \"\\00a0\";\n}\n\n.gitment-markdown pre {\n  word-wrap: normal;\n}\n\n.gitment-markdown pre>code {\n  padding: 0;\n  margin: 0;\n  font-size: 100%;\n  word-break: normal;\n  white-space: pre;\n  background: transparent;\n  border: 0;\n}\n\n.gitment-markdown .highlight {\n  margin-bottom: 16px;\n}\n\n.gitment-markdown .highlight pre {\n  margin-bottom: 0;\n  word-break: normal;\n}\n\n.gitment-markdown .highlight pre,\n.gitment-markdown pre {\n  padding: 16px;\n  overflow: auto;\n  font-size: 85%;\n  line-height: 1.45;\n  background-color: #f5f5f5;\n  border-radius: 0;\n}\n\n.gitment-markdown pre code {\n  display: inline;\n  max-width: auto;\n  padding: 0;\n  margin: 0;\n  overflow: visible;\n  line-height: inherit;\n  word-wrap: normal;\n  background-color: transparent;\n  border: 0;\n}\n\n.gitment-markdown pre code::before,\n.gitment-markdown pre code::after {\n  content: normal;\n}\n\n.gitment-markdown .full-commit .btn-outline:not(:disabled):hover {\n  color: #005cc5;\n  border-color: #005cc5;\n}\n\n.gitment-markdown kbd {\n  display: inline-block;\n  padding: 3px 5px;\n  font: 11px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  line-height: 10px;\n  color: #444d56;\n  vertical-align: middle;\n  background-color: #fcfcfc;\n  border: solid 1px #c6cbd1;\n  border-bottom-color: #959da5;\n  border-radius: 0;\n  box-shadow: inset 0 -1px 0 #959da5;\n}\n\n.gitment-markdown :checked+.radio-label {\n  position: relative;\n  z-index: 1;\n  border-color: #0366d6;\n}\n\n.gitment-markdown .task-list-item {\n  list-style-type: none;\n}\n\n.gitment-markdown .task-list-item+.task-list-item {\n  margin-top: 3px;\n}\n\n.gitment-markdown .task-list-item input {\n  margin: 0 0.2em 0.25em -1.6em;\n  vertical-align: middle;\n}\n\n.gitment-markdown hr {\n  border-bottom-color: #eee;\n}\n","date":"2024-02-25T15:11:07.054Z","updated":"2024-02-25T15:11:07.054Z","path":"css/gitment.css","layout":"false","title":"","comments":1,"_id":"cmfwcr5rr0005m8nx60n98wf9","content":".gitment-container {\n  font-family: sans-serif;\n  font-size: 14px;\n  line-height: 1.5;\n  color: #333;\n  word-wrap: break-word;\n}\n\n.gitment-container * {\n  box-sizing: border-box;\n}\n\n.gitment-container *:disabled {\n  cursor: not-allowed;\n}\n\n.gitment-container a,\n.gitment-container a:visited {\n  cursor: pointer;\n  text-decoration: none;\n}\n\n.gitment-container a:hover {\n  text-decoration: underline;\n}\n\n.gitment-container .gitment-hidden {\n  display: none;\n}\n\n.gitment-container .gitment-spinner-icon {\n  fill: #333;\n\n  -webkit-animation: gitment-spin 1s steps(12) infinite;\n  animation: gitment-spin 1s steps(12) infinite;\n}\n\n@-webkit-keyframes gitment-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg)\n  }\n}\n\n@keyframes gitment-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg)\n  }\n}\n\n.gitment-root-container {\n  margin: 19px 0;\n}\n\n.gitment-header-container {\n  margin: 19px 0;\n}\n\n.gitment-header-like-btn,\n.gitment-comment-like-btn {\n  cursor: pointer;\n}\n\n.gitment-comment-like-btn {\n  float: right;\n}\n\n.gitment-comment-like-btn.liked {\n  color: #F44336;\n}\n\n.gitment-header-like-btn svg {\n  vertical-align: middle;\n  height: 30px;\n}\n\n.gitment-comment-like-btn svg {\n  vertical-align: middle;\n  height: 20px;\n}\n\n.gitment-header-like-btn.liked svg,\n.gitment-comment-like-btn.liked svg {\n  fill: #F44336;\n}\n\na.gitment-header-issue-link,\na.gitment-header-issue-link:visited {\n  float: right;\n  line-height: 30px;\n  color: #666;\n}\n\na.gitment-header-issue-link:hover {\n  color: #666;\n}\n\n.gitment-comments-loading,\n.gitment-comments-error,\n.gitment-comments-empty {\n  text-align: center;\n  margin: 50px 0;\n}\n\n.gitment-comments-list {\n  list-style: none;\n  padding-left: 0;\n  margin: 0 0 38px;\n}\n\n.gitment-comment,\n.gitment-editor-container {\n  position: relative;\n  min-height: 60px;\n  padding-left: 60px;\n  margin: 19px 0;\n}\n\n.gitment-comment-avatar,\n.gitment-editor-avatar {\n  float: left;\n  margin-left: -60px;\n}\n\n.gitment-comment-avatar,\n.gitment-comment-avatar-img,\n.gitment-comment-avatar,\n.gitment-editor-avatar-img,\n.gitment-editor-avatar svg {\n  width: 44px;\n  height: 44px;\n  border-radius: 3px;\n}\n\n.gitment-editor-avatar .gitment-github-icon {\n  fill: #fff;\n  background-color: #333;\n}\n\n.gitment-comment-main,\n.gitment-editor-main {\n  position: relative;\n  border: 1px solid #CFD8DC;\n  border-radius: 0;\n}\n\n.gitment-editor-main::before,\n.gitment-editor-main::after,\n.gitment-comment-main::before,\n.gitment-comment-main::after {\n  position: absolute;\n  top: 11px;\n  left: -16px;\n  display: block;\n  width: 0;\n  height: 0;\n  pointer-events: none;\n  content: \"\";\n  border-color: transparent;\n  border-style: solid solid outset;\n}\n\n.gitment-editor-main::before,\n.gitment-comment-main::before {\n  border-width: 8px;\n  border-right-color: #CFD8DC;\n}\n\n.gitment-editor-main::after,\n.gitment-comment-main::after {\n  margin-top: 1px;\n  margin-left: 2px;\n  border-width: 7px;\n  border-right-color: #fff;\n}\n\n.gitment-comment-header {\n  margin: 12px 15px;\n  color: #666;\n  background-color: #fff;\n  border-radius: 3px;\n}\n\n.gitment-editor-header {\n  padding: 0;\n  margin: 0;\n  border-bottom: 1px solid #CFD8DC;\n}\n\na.gitment-comment-name,\na.gitment-comment-name:visited {\n  font-weight: 600;\n  color: #666;\n}\n\n.gitment-editor-tabs {\n  margin-bottom: -1px;\n  margin-left: -1px;\n}\n\n.gitment-editor-tab {\n  display: inline-block;\n  padding: 11px 12px;\n  font-size: 14px;\n  line-height: 20px;\n  color: #666;\n  text-decoration: none;\n  background-color: transparent;\n  border-width: 0 1px;\n  border-style: solid;\n  border-color: transparent;\n  border-radius: 0;\n\n  white-space: nowrap;\n  cursor: pointer;\n  user-select: none;\n\n  outline: none;\n}\n\n.gitment-editor-tab.gitment-selected {\n  color: #333;\n  background-color: #fff;\n  border-color: #CFD8DC;\n}\n\n.gitment-editor-login {\n  float: right;\n  margin-top: -30px;\n  margin-right: 15px;\n}\n\na.gitment-footer-project-link,\na.gitment-footer-project-link:visited,\na.gitment-editor-login-link,\na.gitment-editor-login-link:visited {\n  color: #2196F3;\n}\n\na.gitment-editor-logout-link,\na.gitment-editor-logout-link:visited {\n  color: #666;\n}\n\na.gitment-editor-logout-link:hover {\n  color: #2196F3;\n  text-decoration: none;\n}\n\n.gitment-comment-body {\n  position: relative;\n  margin: 12px 15px;\n  overflow: hidden;\n  border-radius: 3px;\n}\n\n.gitment-comment-body-folded {\n  cursor: pointer;\n}\n\n.gitment-comment-body-folded::before {\n  display: block !important;\n  content: \"\";\n  position: absolute;\n  width: 100%;\n  left: 0;\n  top: 0;\n  bottom: 50px;\n  pointer-events: none;\n  background: -webkit-linear-gradient(top, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9));\n  background: linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9));\n}\n\n.gitment-comment-body-folded::after {\n  display: block !important;\n  content: \"Click to Expand\" !important;\n  text-align: center;\n  color: #666;\n  position: absolute;\n  width: 100%;\n  height: 50px;\n  line-height: 50px;\n  left: 0;\n  bottom: 0;\n  pointer-events: none;\n  background: rgba(255, 255, 255, .9);\n}\n\n.gitment-editor-body {\n  margin: 0;\n}\n\n.gitment-comment-body > *:first-child,\n.gitment-editor-preview > *:first-child {\n  margin-top: 0 !important;\n}\n\n.gitment-comment-body > *:last-child,\n.gitment-editor-preview > *:last-child {\n  margin-bottom: 0 !important;\n}\n\n.gitment-editor-body textarea {\n  display: block;\n  width: 100%;\n  min-height: 150px;\n  max-height: 500px;\n  padding: 16px;\n  resize: vertical;\n\n  max-width: 100%;\n  margin: 0;\n  font-size: 14px;\n  line-height: 1.6;\n\n  background-color: #fff;\n\n  color: #333;\n  vertical-align: middle;\n  border: none;\n  border-radius: 0;\n  outline: none;\n  box-shadow: none;\n\n  overflow: visible;\n}\n\n.gitment-editor-body textarea:focus {\n  background-color: #fff;\n}\n\n.gitment-editor-preview {\n  min-height: 150px;\n\n  padding: 16px;\n  background-color: transparent;\n\n  width: 100%;\n  font-size: 14px;\n\n  line-height: 1.5;\n  word-wrap: break-word;\n}\n\n.gitment-editor-footer {\n  padding: 0;\n  margin-top: 10px;\n}\n\n.gitment-editor-footer::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\na.gitment-editor-footer-tip {\n  display: inline-block;\n  padding-top: 10px;\n  font-size: 12px;\n  color: #666;\n}\n\na.gitment-editor-footer-tip:hover {\n  color: #2196F3;\n  text-decoration: none;\n}\n\n.gitment-comments-pagination {\n  list-style: none;\n  text-align: right;\n  border-radius: 0;\n  margin: -19px 0 19px 0;\n}\n\n.gitment-comments-page-item {\n  display: inline-block;\n  cursor: pointer;\n  border: 1px solid #CFD8DC;\n  margin-left: -1px;\n  padding: .25rem .5rem;\n}\n\n.gitment-comments-page-item:hover {\n  background-color: #f5f5f5;\n}\n\n.gitment-comments-page-item.gitment-selected {\n  background-color: #f5f5f5;\n}\n\n.gitment-editor-submit,\n.gitment-comments-init-btn {\n  color: #fff;\n  background-color: #00BCD4;\n\n  position: relative;\n  display: inline-block;\n  padding: 7px 13px;\n  font-size: 14px;\n  font-weight: 600;\n  line-height: 20px;\n  white-space: nowrap;\n  vertical-align: middle;\n  cursor: pointer;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  background-size: 110% 110%;\n  border: none;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n}\n\n.gitment-editor-submit:hover,\n.gitment-comments-init-btn:hover {\n  background-color: #00ACC1;\n}\n\n.gitment-comments-init-btn:disabled,\n.gitment-editor-submit:disabled {\n  color: rgba(255,255,255,0.75);\n  background-color: #4DD0E1;\n  box-shadow: none;\n}\n\n.gitment-editor-submit {\n  float: right;\n}\n\n.gitment-footer-container {\n  margin-top: 30px;\n  margin-bottom: 20px;\n  text-align: right;\n  font-size: 12px;\n}\n\n/*\n * Markdown CSS\n * Copied from https://github.com/sindresorhus/github-markdown-css\n */\n.gitment-markdown {\n  -ms-text-size-adjust: 100%;\n  -webkit-text-size-adjust: 100%;\n  line-height: 1.5;\n  color: #333;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n  font-size: 16px;\n  line-height: 1.5;\n  word-wrap: break-word;\n}\n\n.gitment-markdown .pl-c {\n  color: #969896;\n}\n\n.gitment-markdown .pl-c1,\n.gitment-markdown .pl-s .pl-v {\n  color: #0086b3;\n}\n\n.gitment-markdown .pl-e,\n.gitment-markdown .pl-en {\n  color: #795da3;\n}\n\n.gitment-markdown .pl-smi,\n.gitment-markdown .pl-s .pl-s1 {\n  color: #333;\n}\n\n.gitment-markdown .pl-ent {\n  color: #63a35c;\n}\n\n.gitment-markdown .pl-k {\n  color: #a71d5d;\n}\n\n.gitment-markdown .pl-s,\n.gitment-markdown .pl-pds,\n.gitment-markdown .pl-s .pl-pse .pl-s1,\n.gitment-markdown .pl-sr,\n.gitment-markdown .pl-sr .pl-cce,\n.gitment-markdown .pl-sr .pl-sre,\n.gitment-markdown .pl-sr .pl-sra {\n  color: #183691;\n}\n\n.gitment-markdown .pl-v,\n.gitment-markdown .pl-smw {\n  color: #ed6a43;\n}\n\n.gitment-markdown .pl-bu {\n  color: #b52a1d;\n}\n\n.gitment-markdown .pl-ii {\n  color: #f8f8f8;\n  background-color: #b52a1d;\n}\n\n.gitment-markdown .pl-c2 {\n  color: #f8f8f8;\n  background-color: #b52a1d;\n}\n\n.gitment-markdown .pl-c2::before {\n  content: \"^M\";\n}\n\n.gitment-markdown .pl-sr .pl-cce {\n  font-weight: bold;\n  color: #63a35c;\n}\n\n.gitment-markdown .pl-ml {\n  color: #693a17;\n}\n\n.gitment-markdown .pl-mh,\n.gitment-markdown .pl-mh .pl-en,\n.gitment-markdown .pl-ms {\n  font-weight: bold;\n  color: #1d3e81;\n}\n\n.gitment-markdown .pl-mq {\n  color: #008080;\n}\n\n.gitment-markdown .pl-mi {\n  font-style: italic;\n  color: #333;\n}\n\n.gitment-markdown .pl-mb {\n  font-weight: bold;\n  color: #333;\n}\n\n.gitment-markdown .pl-md {\n  color: #bd2c00;\n  background-color: #ffecec;\n}\n\n.gitment-markdown .pl-mi1 {\n  color: #55a532;\n  background-color: #eaffea;\n}\n\n.gitment-markdown .pl-mc {\n  color: #ef9700;\n  background-color: #ffe3b4;\n}\n\n.gitment-markdown .pl-mi2 {\n  color: #d8d8d8;\n  background-color: #808080;\n}\n\n.gitment-markdown .pl-mdr {\n  font-weight: bold;\n  color: #795da3;\n}\n\n.gitment-markdown .pl-mo {\n  color: #1d3e81;\n}\n\n.gitment-markdown .pl-ba {\n  color: #595e62;\n}\n\n.gitment-markdown .pl-sg {\n  color: #c0c0c0;\n}\n\n.gitment-markdown .pl-corl {\n  text-decoration: underline;\n  color: #183691;\n}\n\n.gitment-markdown .octicon {\n  display: inline-block;\n  vertical-align: text-top;\n  fill: currentColor;\n}\n\n.gitment-markdown a {\n  background-color: transparent;\n  -webkit-text-decoration-skip: objects;\n}\n\n.gitment-markdown a:active,\n.gitment-markdown a:hover {\n  outline-width: 0;\n}\n\n.gitment-markdown strong {\n  font-weight: inherit;\n}\n\n.gitment-markdown strong {\n  font-weight: bolder;\n}\n\n.gitment-markdown h1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n.gitment-markdown img {\n  border-style: none;\n}\n\n.gitment-markdown svg:not(:root) {\n  overflow: hidden;\n}\n\n.gitment-markdown code,\n.gitment-markdown kbd,\n.gitment-markdown pre {\n  font-family: monospace, monospace;\n  font-size: 1em;\n}\n\n.gitment-markdown hr {\n  box-sizing: content-box;\n  height: 0;\n  overflow: visible;\n}\n\n.gitment-markdown input {\n  font: inherit;\n  margin: 0;\n}\n\n.gitment-markdown input {\n  overflow: visible;\n}\n\n.gitment-markdown [type=\"checkbox\"] {\n  box-sizing: border-box;\n  padding: 0;\n}\n\n.gitment-markdown * {\n  box-sizing: border-box;\n}\n\n.gitment-markdown input {\n  font-family: inherit;\n  font-size: inherit;\n  line-height: inherit;\n}\n\n.gitment-markdown a {\n  color: #0366d6;\n  text-decoration: none;\n}\n\n.gitment-markdown a:hover {\n  text-decoration: underline;\n}\n\n.gitment-markdown strong {\n  font-weight: 600;\n}\n\n.gitment-markdown hr {\n  height: 0;\n  margin: 15px 0;\n  overflow: hidden;\n  background: transparent;\n  border: 0;\n  border-bottom: 1px solid #dfe2e5;\n}\n\n.gitment-markdown hr::before {\n  display: table;\n  content: \"\";\n}\n\n.gitment-markdown hr::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\n.gitment-markdown table {\n  border-spacing: 0;\n  border-collapse: collapse;\n}\n\n.gitment-markdown td,\n.gitment-markdown th {\n  padding: 0;\n}\n\n.gitment-markdown h1,\n.gitment-markdown h2,\n.gitment-markdown h3,\n.gitment-markdown h4,\n.gitment-markdown h5,\n.gitment-markdown h6 {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown h1 {\n  font-size: 32px;\n  font-weight: 600;\n}\n\n.gitment-markdown h2 {\n  font-size: 24px;\n  font-weight: 600;\n}\n\n.gitment-markdown h3 {\n  font-size: 20px;\n  font-weight: 600;\n}\n\n.gitment-markdown h4 {\n  font-size: 16px;\n  font-weight: 600;\n}\n\n.gitment-markdown h5 {\n  font-size: 14px;\n  font-weight: 600;\n}\n\n.gitment-markdown h6 {\n  font-size: 12px;\n  font-weight: 600;\n}\n\n.gitment-markdown p {\n  margin-top: 0;\n  margin-bottom: 10px;\n}\n\n.gitment-markdown blockquote {\n  margin: 0;\n}\n\n.gitment-markdown ul,\n.gitment-markdown ol {\n  padding-left: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown ol ol,\n.gitment-markdown ul ol {\n  list-style-type: lower-roman;\n}\n\n.gitment-markdown ul ul ol,\n.gitment-markdown ul ol ol,\n.gitment-markdown ol ul ol,\n.gitment-markdown ol ol ol {\n  list-style-type: lower-alpha;\n}\n\n.gitment-markdown dd {\n  margin-left: 0;\n}\n\n.gitment-markdown code {\n  font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  font-size: 12px;\n}\n\n.gitment-markdown pre {\n  margin-top: 0;\n  margin-bottom: 0;\n  font: 12px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n}\n\n.gitment-markdown .octicon {\n  vertical-align: text-bottom;\n}\n\n.gitment-markdown .pl-0 {\n  padding-left: 0 !important;\n}\n\n.gitment-markdown .pl-1 {\n  padding-left: 4px !important;\n}\n\n.gitment-markdown .pl-2 {\n  padding-left: 8px !important;\n}\n\n.gitment-markdown .pl-3 {\n  padding-left: 16px !important;\n}\n\n.gitment-markdown .pl-4 {\n  padding-left: 24px !important;\n}\n\n.gitment-markdown .pl-5 {\n  padding-left: 32px !important;\n}\n\n.gitment-markdown .pl-6 {\n  padding-left: 40px !important;\n}\n\n.gitment-markdown::before {\n  display: table;\n  content: \"\";\n}\n\n.gitment-markdown::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\n.gitment-markdown>*:first-child {\n  margin-top: 0 !important;\n}\n\n.gitment-markdown>*:last-child {\n  margin-bottom: 0 !important;\n}\n\n.gitment-markdown a:not([href]) {\n  color: inherit;\n  text-decoration: none;\n}\n\n.gitment-markdown .anchor {\n  float: left;\n  padding-right: 4px;\n  margin-left: -20px;\n  line-height: 1;\n}\n\n.gitment-markdown .anchor:focus {\n  outline: none;\n}\n\n.gitment-markdown p,\n.gitment-markdown blockquote,\n.gitment-markdown ul,\n.gitment-markdown ol,\n.gitment-markdown dl,\n.gitment-markdown table,\n.gitment-markdown pre {\n  margin-top: 0;\n  margin-bottom: 16px;\n}\n\n.gitment-markdown hr {\n  height: 0.25em;\n  padding: 0;\n  margin: 24px 0;\n  background-color: #e1e4e8;\n  border: 0;\n}\n\n.gitment-markdown blockquote {\n  padding: 0 1em;\n  color: #6a737d;\n  border-left: 0.25em solid #dfe2e5;\n}\n\n.gitment-markdown blockquote>:first-child {\n  margin-top: 0;\n}\n\n.gitment-markdown blockquote>:last-child {\n  margin-bottom: 0;\n}\n\n.gitment-markdown kbd {\n  display: inline-block;\n  padding: 3px 5px;\n  font-size: 11px;\n  line-height: 10px;\n  color: #444d56;\n  vertical-align: middle;\n  background-color: #fafbfc;\n  border: solid 1px #c6cbd1;\n  border-bottom-color: #959da5;\n  border-radius: 0;\n  box-shadow: inset 0 -1px 0 #959da5;\n}\n\n.gitment-markdown h1,\n.gitment-markdown h2,\n.gitment-markdown h3,\n.gitment-markdown h4,\n.gitment-markdown h5,\n.gitment-markdown h6 {\n  margin-top: 24px;\n  margin-bottom: 16px;\n  font-weight: 600;\n  line-height: 1.25;\n}\n\n.gitment-markdown h1 .octicon-link,\n.gitment-markdown h2 .octicon-link,\n.gitment-markdown h3 .octicon-link,\n.gitment-markdown h4 .octicon-link,\n.gitment-markdown h5 .octicon-link,\n.gitment-markdown h6 .octicon-link {\n  color: #1b1f23;\n  vertical-align: middle;\n  visibility: hidden;\n}\n\n.gitment-markdown h1:hover .anchor,\n.gitment-markdown h2:hover .anchor,\n.gitment-markdown h3:hover .anchor,\n.gitment-markdown h4:hover .anchor,\n.gitment-markdown h5:hover .anchor,\n.gitment-markdown h6:hover .anchor {\n  text-decoration: none;\n}\n\n.gitment-markdown h1:hover .anchor .octicon-link,\n.gitment-markdown h2:hover .anchor .octicon-link,\n.gitment-markdown h3:hover .anchor .octicon-link,\n.gitment-markdown h4:hover .anchor .octicon-link,\n.gitment-markdown h5:hover .anchor .octicon-link,\n.gitment-markdown h6:hover .anchor .octicon-link {\n  visibility: visible;\n}\n\n.gitment-markdown h1 {\n  padding-bottom: 0.3em;\n  font-size: 2em;\n  border-bottom: 1px solid #eaecef;\n}\n\n.gitment-markdown h2 {\n  padding-bottom: 0.3em;\n  font-size: 1.5em;\n  border-bottom: 1px solid #eaecef;\n}\n\n.gitment-markdown h3 {\n  font-size: 1.25em;\n}\n\n.gitment-markdown h4 {\n  font-size: 1em;\n}\n\n.gitment-markdown h5 {\n  font-size: 0.875em;\n}\n\n.gitment-markdown h6 {\n  font-size: 0.85em;\n  color: #6a737d;\n}\n\n.gitment-markdown ul,\n.gitment-markdown ol {\n  padding-left: 2em;\n}\n\n.gitment-markdown ul ul,\n.gitment-markdown ul ol,\n.gitment-markdown ol ol,\n.gitment-markdown ol ul {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown li>p {\n  margin-top: 16px;\n}\n\n.gitment-markdown li+li {\n  margin-top: 0.25em;\n}\n\n.gitment-markdown dl {\n  padding: 0;\n}\n\n.gitment-markdown dl dt {\n  padding: 0;\n  margin-top: 16px;\n  font-size: 1em;\n  font-style: italic;\n  font-weight: 600;\n}\n\n.gitment-markdown dl dd {\n  padding: 0 16px;\n  margin-bottom: 16px;\n}\n\n.gitment-markdown table {\n  display: block;\n  width: 100%;\n  overflow: auto;\n}\n\n.gitment-markdown table th {\n  font-weight: 600;\n}\n\n.gitment-markdown table th,\n.gitment-markdown table td {\n  padding: 6px 13px;\n  border: 1px solid #dfe2e5;\n}\n\n.gitment-markdown table tr {\n  background-color: #fff;\n  border-top: 1px solid #c6cbd1;\n}\n\n.gitment-markdown table tr:nth-child(2n) {\n  background-color: #f5f5f5;\n}\n\n.gitment-markdown img {\n  max-width: 100%;\n  box-sizing: content-box;\n  background-color: #fff;\n}\n\n.gitment-markdown code {\n  padding: 0;\n  padding-top: 0.2em;\n  padding-bottom: 0.2em;\n  margin: 0;\n  font-size: 85%;\n  background-color: rgba(27,31,35,0.05);\n  border-radius: 0;\n}\n\n.gitment-markdown code::before,\n.gitment-markdown code::after {\n  letter-spacing: -0.2em;\n  content: \"\\00a0\";\n}\n\n.gitment-markdown pre {\n  word-wrap: normal;\n}\n\n.gitment-markdown pre>code {\n  padding: 0;\n  margin: 0;\n  font-size: 100%;\n  word-break: normal;\n  white-space: pre;\n  background: transparent;\n  border: 0;\n}\n\n.gitment-markdown .highlight {\n  margin-bottom: 16px;\n}\n\n.gitment-markdown .highlight pre {\n  margin-bottom: 0;\n  word-break: normal;\n}\n\n.gitment-markdown .highlight pre,\n.gitment-markdown pre {\n  padding: 16px;\n  overflow: auto;\n  font-size: 85%;\n  line-height: 1.45;\n  background-color: #f5f5f5;\n  border-radius: 0;\n}\n\n.gitment-markdown pre code {\n  display: inline;\n  max-width: auto;\n  padding: 0;\n  margin: 0;\n  overflow: visible;\n  line-height: inherit;\n  word-wrap: normal;\n  background-color: transparent;\n  border: 0;\n}\n\n.gitment-markdown pre code::before,\n.gitment-markdown pre code::after {\n  content: normal;\n}\n\n.gitment-markdown .full-commit .btn-outline:not(:disabled):hover {\n  color: #005cc5;\n  border-color: #005cc5;\n}\n\n.gitment-markdown kbd {\n  display: inline-block;\n  padding: 3px 5px;\n  font: 11px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  line-height: 10px;\n  color: #444d56;\n  vertical-align: middle;\n  background-color: #fcfcfc;\n  border: solid 1px #c6cbd1;\n  border-bottom-color: #959da5;\n  border-radius: 0;\n  box-shadow: inset 0 -1px 0 #959da5;\n}\n\n.gitment-markdown :checked+.radio-label {\n  position: relative;\n  z-index: 1;\n  border-color: #0366d6;\n}\n\n.gitment-markdown .task-list-item {\n  list-style-type: none;\n}\n\n.gitment-markdown .task-list-item+.task-list-item {\n  margin-top: 3px;\n}\n\n.gitment-markdown .task-list-item input {\n  margin: 0 0.2em 0.25em -1.6em;\n  vertical-align: middle;\n}\n\n.gitment-markdown hr {\n  border-bottom-color: #eee;\n}\n","site":{"data":{}},"excerpt":"","more":".gitment-container {\n  font-family: sans-serif;\n  font-size: 14px;\n  line-height: 1.5;\n  color: #333;\n  word-wrap: break-word;\n}\n\n.gitment-container * {\n  box-sizing: border-box;\n}\n\n.gitment-container *:disabled {\n  cursor: not-allowed;\n}\n\n.gitment-container a,\n.gitment-container a:visited {\n  cursor: pointer;\n  text-decoration: none;\n}\n\n.gitment-container a:hover {\n  text-decoration: underline;\n}\n\n.gitment-container .gitment-hidden {\n  display: none;\n}\n\n.gitment-container .gitment-spinner-icon {\n  fill: #333;\n\n  -webkit-animation: gitment-spin 1s steps(12) infinite;\n  animation: gitment-spin 1s steps(12) infinite;\n}\n\n@-webkit-keyframes gitment-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg)\n  }\n}\n\n@keyframes gitment-spin {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg)\n  }\n}\n\n.gitment-root-container {\n  margin: 19px 0;\n}\n\n.gitment-header-container {\n  margin: 19px 0;\n}\n\n.gitment-header-like-btn,\n.gitment-comment-like-btn {\n  cursor: pointer;\n}\n\n.gitment-comment-like-btn {\n  float: right;\n}\n\n.gitment-comment-like-btn.liked {\n  color: #F44336;\n}\n\n.gitment-header-like-btn svg {\n  vertical-align: middle;\n  height: 30px;\n}\n\n.gitment-comment-like-btn svg {\n  vertical-align: middle;\n  height: 20px;\n}\n\n.gitment-header-like-btn.liked svg,\n.gitment-comment-like-btn.liked svg {\n  fill: #F44336;\n}\n\na.gitment-header-issue-link,\na.gitment-header-issue-link:visited {\n  float: right;\n  line-height: 30px;\n  color: #666;\n}\n\na.gitment-header-issue-link:hover {\n  color: #666;\n}\n\n.gitment-comments-loading,\n.gitment-comments-error,\n.gitment-comments-empty {\n  text-align: center;\n  margin: 50px 0;\n}\n\n.gitment-comments-list {\n  list-style: none;\n  padding-left: 0;\n  margin: 0 0 38px;\n}\n\n.gitment-comment,\n.gitment-editor-container {\n  position: relative;\n  min-height: 60px;\n  padding-left: 60px;\n  margin: 19px 0;\n}\n\n.gitment-comment-avatar,\n.gitment-editor-avatar {\n  float: left;\n  margin-left: -60px;\n}\n\n.gitment-comment-avatar,\n.gitment-comment-avatar-img,\n.gitment-comment-avatar,\n.gitment-editor-avatar-img,\n.gitment-editor-avatar svg {\n  width: 44px;\n  height: 44px;\n  border-radius: 3px;\n}\n\n.gitment-editor-avatar .gitment-github-icon {\n  fill: #fff;\n  background-color: #333;\n}\n\n.gitment-comment-main,\n.gitment-editor-main {\n  position: relative;\n  border: 1px solid #CFD8DC;\n  border-radius: 0;\n}\n\n.gitment-editor-main::before,\n.gitment-editor-main::after,\n.gitment-comment-main::before,\n.gitment-comment-main::after {\n  position: absolute;\n  top: 11px;\n  left: -16px;\n  display: block;\n  width: 0;\n  height: 0;\n  pointer-events: none;\n  content: \"\";\n  border-color: transparent;\n  border-style: solid solid outset;\n}\n\n.gitment-editor-main::before,\n.gitment-comment-main::before {\n  border-width: 8px;\n  border-right-color: #CFD8DC;\n}\n\n.gitment-editor-main::after,\n.gitment-comment-main::after {\n  margin-top: 1px;\n  margin-left: 2px;\n  border-width: 7px;\n  border-right-color: #fff;\n}\n\n.gitment-comment-header {\n  margin: 12px 15px;\n  color: #666;\n  background-color: #fff;\n  border-radius: 3px;\n}\n\n.gitment-editor-header {\n  padding: 0;\n  margin: 0;\n  border-bottom: 1px solid #CFD8DC;\n}\n\na.gitment-comment-name,\na.gitment-comment-name:visited {\n  font-weight: 600;\n  color: #666;\n}\n\n.gitment-editor-tabs {\n  margin-bottom: -1px;\n  margin-left: -1px;\n}\n\n.gitment-editor-tab {\n  display: inline-block;\n  padding: 11px 12px;\n  font-size: 14px;\n  line-height: 20px;\n  color: #666;\n  text-decoration: none;\n  background-color: transparent;\n  border-width: 0 1px;\n  border-style: solid;\n  border-color: transparent;\n  border-radius: 0;\n\n  white-space: nowrap;\n  cursor: pointer;\n  user-select: none;\n\n  outline: none;\n}\n\n.gitment-editor-tab.gitment-selected {\n  color: #333;\n  background-color: #fff;\n  border-color: #CFD8DC;\n}\n\n.gitment-editor-login {\n  float: right;\n  margin-top: -30px;\n  margin-right: 15px;\n}\n\na.gitment-footer-project-link,\na.gitment-footer-project-link:visited,\na.gitment-editor-login-link,\na.gitment-editor-login-link:visited {\n  color: #2196F3;\n}\n\na.gitment-editor-logout-link,\na.gitment-editor-logout-link:visited {\n  color: #666;\n}\n\na.gitment-editor-logout-link:hover {\n  color: #2196F3;\n  text-decoration: none;\n}\n\n.gitment-comment-body {\n  position: relative;\n  margin: 12px 15px;\n  overflow: hidden;\n  border-radius: 3px;\n}\n\n.gitment-comment-body-folded {\n  cursor: pointer;\n}\n\n.gitment-comment-body-folded::before {\n  display: block !important;\n  content: \"\";\n  position: absolute;\n  width: 100%;\n  left: 0;\n  top: 0;\n  bottom: 50px;\n  pointer-events: none;\n  background: -webkit-linear-gradient(top, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9));\n  background: linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, .9));\n}\n\n.gitment-comment-body-folded::after {\n  display: block !important;\n  content: \"Click to Expand\" !important;\n  text-align: center;\n  color: #666;\n  position: absolute;\n  width: 100%;\n  height: 50px;\n  line-height: 50px;\n  left: 0;\n  bottom: 0;\n  pointer-events: none;\n  background: rgba(255, 255, 255, .9);\n}\n\n.gitment-editor-body {\n  margin: 0;\n}\n\n.gitment-comment-body > *:first-child,\n.gitment-editor-preview > *:first-child {\n  margin-top: 0 !important;\n}\n\n.gitment-comment-body > *:last-child,\n.gitment-editor-preview > *:last-child {\n  margin-bottom: 0 !important;\n}\n\n.gitment-editor-body textarea {\n  display: block;\n  width: 100%;\n  min-height: 150px;\n  max-height: 500px;\n  padding: 16px;\n  resize: vertical;\n\n  max-width: 100%;\n  margin: 0;\n  font-size: 14px;\n  line-height: 1.6;\n\n  background-color: #fff;\n\n  color: #333;\n  vertical-align: middle;\n  border: none;\n  border-radius: 0;\n  outline: none;\n  box-shadow: none;\n\n  overflow: visible;\n}\n\n.gitment-editor-body textarea:focus {\n  background-color: #fff;\n}\n\n.gitment-editor-preview {\n  min-height: 150px;\n\n  padding: 16px;\n  background-color: transparent;\n\n  width: 100%;\n  font-size: 14px;\n\n  line-height: 1.5;\n  word-wrap: break-word;\n}\n\n.gitment-editor-footer {\n  padding: 0;\n  margin-top: 10px;\n}\n\n.gitment-editor-footer::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\na.gitment-editor-footer-tip {\n  display: inline-block;\n  padding-top: 10px;\n  font-size: 12px;\n  color: #666;\n}\n\na.gitment-editor-footer-tip:hover {\n  color: #2196F3;\n  text-decoration: none;\n}\n\n.gitment-comments-pagination {\n  list-style: none;\n  text-align: right;\n  border-radius: 0;\n  margin: -19px 0 19px 0;\n}\n\n.gitment-comments-page-item {\n  display: inline-block;\n  cursor: pointer;\n  border: 1px solid #CFD8DC;\n  margin-left: -1px;\n  padding: .25rem .5rem;\n}\n\n.gitment-comments-page-item:hover {\n  background-color: #f5f5f5;\n}\n\n.gitment-comments-page-item.gitment-selected {\n  background-color: #f5f5f5;\n}\n\n.gitment-editor-submit,\n.gitment-comments-init-btn {\n  color: #fff;\n  background-color: #00BCD4;\n\n  position: relative;\n  display: inline-block;\n  padding: 7px 13px;\n  font-size: 14px;\n  font-weight: 600;\n  line-height: 20px;\n  white-space: nowrap;\n  vertical-align: middle;\n  cursor: pointer;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  background-size: 110% 110%;\n  border: none;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n}\n\n.gitment-editor-submit:hover,\n.gitment-comments-init-btn:hover {\n  background-color: #00ACC1;\n}\n\n.gitment-comments-init-btn:disabled,\n.gitment-editor-submit:disabled {\n  color: rgba(255,255,255,0.75);\n  background-color: #4DD0E1;\n  box-shadow: none;\n}\n\n.gitment-editor-submit {\n  float: right;\n}\n\n.gitment-footer-container {\n  margin-top: 30px;\n  margin-bottom: 20px;\n  text-align: right;\n  font-size: 12px;\n}\n\n/*\n * Markdown CSS\n * Copied from https://github.com/sindresorhus/github-markdown-css\n */\n.gitment-markdown {\n  -ms-text-size-adjust: 100%;\n  -webkit-text-size-adjust: 100%;\n  line-height: 1.5;\n  color: #333;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\n  font-size: 16px;\n  line-height: 1.5;\n  word-wrap: break-word;\n}\n\n.gitment-markdown .pl-c {\n  color: #969896;\n}\n\n.gitment-markdown .pl-c1,\n.gitment-markdown .pl-s .pl-v {\n  color: #0086b3;\n}\n\n.gitment-markdown .pl-e,\n.gitment-markdown .pl-en {\n  color: #795da3;\n}\n\n.gitment-markdown .pl-smi,\n.gitment-markdown .pl-s .pl-s1 {\n  color: #333;\n}\n\n.gitment-markdown .pl-ent {\n  color: #63a35c;\n}\n\n.gitment-markdown .pl-k {\n  color: #a71d5d;\n}\n\n.gitment-markdown .pl-s,\n.gitment-markdown .pl-pds,\n.gitment-markdown .pl-s .pl-pse .pl-s1,\n.gitment-markdown .pl-sr,\n.gitment-markdown .pl-sr .pl-cce,\n.gitment-markdown .pl-sr .pl-sre,\n.gitment-markdown .pl-sr .pl-sra {\n  color: #183691;\n}\n\n.gitment-markdown .pl-v,\n.gitment-markdown .pl-smw {\n  color: #ed6a43;\n}\n\n.gitment-markdown .pl-bu {\n  color: #b52a1d;\n}\n\n.gitment-markdown .pl-ii {\n  color: #f8f8f8;\n  background-color: #b52a1d;\n}\n\n.gitment-markdown .pl-c2 {\n  color: #f8f8f8;\n  background-color: #b52a1d;\n}\n\n.gitment-markdown .pl-c2::before {\n  content: \"^M\";\n}\n\n.gitment-markdown .pl-sr .pl-cce {\n  font-weight: bold;\n  color: #63a35c;\n}\n\n.gitment-markdown .pl-ml {\n  color: #693a17;\n}\n\n.gitment-markdown .pl-mh,\n.gitment-markdown .pl-mh .pl-en,\n.gitment-markdown .pl-ms {\n  font-weight: bold;\n  color: #1d3e81;\n}\n\n.gitment-markdown .pl-mq {\n  color: #008080;\n}\n\n.gitment-markdown .pl-mi {\n  font-style: italic;\n  color: #333;\n}\n\n.gitment-markdown .pl-mb {\n  font-weight: bold;\n  color: #333;\n}\n\n.gitment-markdown .pl-md {\n  color: #bd2c00;\n  background-color: #ffecec;\n}\n\n.gitment-markdown .pl-mi1 {\n  color: #55a532;\n  background-color: #eaffea;\n}\n\n.gitment-markdown .pl-mc {\n  color: #ef9700;\n  background-color: #ffe3b4;\n}\n\n.gitment-markdown .pl-mi2 {\n  color: #d8d8d8;\n  background-color: #808080;\n}\n\n.gitment-markdown .pl-mdr {\n  font-weight: bold;\n  color: #795da3;\n}\n\n.gitment-markdown .pl-mo {\n  color: #1d3e81;\n}\n\n.gitment-markdown .pl-ba {\n  color: #595e62;\n}\n\n.gitment-markdown .pl-sg {\n  color: #c0c0c0;\n}\n\n.gitment-markdown .pl-corl {\n  text-decoration: underline;\n  color: #183691;\n}\n\n.gitment-markdown .octicon {\n  display: inline-block;\n  vertical-align: text-top;\n  fill: currentColor;\n}\n\n.gitment-markdown a {\n  background-color: transparent;\n  -webkit-text-decoration-skip: objects;\n}\n\n.gitment-markdown a:active,\n.gitment-markdown a:hover {\n  outline-width: 0;\n}\n\n.gitment-markdown strong {\n  font-weight: inherit;\n}\n\n.gitment-markdown strong {\n  font-weight: bolder;\n}\n\n.gitment-markdown h1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n.gitment-markdown img {\n  border-style: none;\n}\n\n.gitment-markdown svg:not(:root) {\n  overflow: hidden;\n}\n\n.gitment-markdown code,\n.gitment-markdown kbd,\n.gitment-markdown pre {\n  font-family: monospace, monospace;\n  font-size: 1em;\n}\n\n.gitment-markdown hr {\n  box-sizing: content-box;\n  height: 0;\n  overflow: visible;\n}\n\n.gitment-markdown input {\n  font: inherit;\n  margin: 0;\n}\n\n.gitment-markdown input {\n  overflow: visible;\n}\n\n.gitment-markdown [type=\"checkbox\"] {\n  box-sizing: border-box;\n  padding: 0;\n}\n\n.gitment-markdown * {\n  box-sizing: border-box;\n}\n\n.gitment-markdown input {\n  font-family: inherit;\n  font-size: inherit;\n  line-height: inherit;\n}\n\n.gitment-markdown a {\n  color: #0366d6;\n  text-decoration: none;\n}\n\n.gitment-markdown a:hover {\n  text-decoration: underline;\n}\n\n.gitment-markdown strong {\n  font-weight: 600;\n}\n\n.gitment-markdown hr {\n  height: 0;\n  margin: 15px 0;\n  overflow: hidden;\n  background: transparent;\n  border: 0;\n  border-bottom: 1px solid #dfe2e5;\n}\n\n.gitment-markdown hr::before {\n  display: table;\n  content: \"\";\n}\n\n.gitment-markdown hr::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\n.gitment-markdown table {\n  border-spacing: 0;\n  border-collapse: collapse;\n}\n\n.gitment-markdown td,\n.gitment-markdown th {\n  padding: 0;\n}\n\n.gitment-markdown h1,\n.gitment-markdown h2,\n.gitment-markdown h3,\n.gitment-markdown h4,\n.gitment-markdown h5,\n.gitment-markdown h6 {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown h1 {\n  font-size: 32px;\n  font-weight: 600;\n}\n\n.gitment-markdown h2 {\n  font-size: 24px;\n  font-weight: 600;\n}\n\n.gitment-markdown h3 {\n  font-size: 20px;\n  font-weight: 600;\n}\n\n.gitment-markdown h4 {\n  font-size: 16px;\n  font-weight: 600;\n}\n\n.gitment-markdown h5 {\n  font-size: 14px;\n  font-weight: 600;\n}\n\n.gitment-markdown h6 {\n  font-size: 12px;\n  font-weight: 600;\n}\n\n.gitment-markdown p {\n  margin-top: 0;\n  margin-bottom: 10px;\n}\n\n.gitment-markdown blockquote {\n  margin: 0;\n}\n\n.gitment-markdown ul,\n.gitment-markdown ol {\n  padding-left: 0;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown ol ol,\n.gitment-markdown ul ol {\n  list-style-type: lower-roman;\n}\n\n.gitment-markdown ul ul ol,\n.gitment-markdown ul ol ol,\n.gitment-markdown ol ul ol,\n.gitment-markdown ol ol ol {\n  list-style-type: lower-alpha;\n}\n\n.gitment-markdown dd {\n  margin-left: 0;\n}\n\n.gitment-markdown code {\n  font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  font-size: 12px;\n}\n\n.gitment-markdown pre {\n  margin-top: 0;\n  margin-bottom: 0;\n  font: 12px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n}\n\n.gitment-markdown .octicon {\n  vertical-align: text-bottom;\n}\n\n.gitment-markdown .pl-0 {\n  padding-left: 0 !important;\n}\n\n.gitment-markdown .pl-1 {\n  padding-left: 4px !important;\n}\n\n.gitment-markdown .pl-2 {\n  padding-left: 8px !important;\n}\n\n.gitment-markdown .pl-3 {\n  padding-left: 16px !important;\n}\n\n.gitment-markdown .pl-4 {\n  padding-left: 24px !important;\n}\n\n.gitment-markdown .pl-5 {\n  padding-left: 32px !important;\n}\n\n.gitment-markdown .pl-6 {\n  padding-left: 40px !important;\n}\n\n.gitment-markdown::before {\n  display: table;\n  content: \"\";\n}\n\n.gitment-markdown::after {\n  display: table;\n  clear: both;\n  content: \"\";\n}\n\n.gitment-markdown>*:first-child {\n  margin-top: 0 !important;\n}\n\n.gitment-markdown>*:last-child {\n  margin-bottom: 0 !important;\n}\n\n.gitment-markdown a:not([href]) {\n  color: inherit;\n  text-decoration: none;\n}\n\n.gitment-markdown .anchor {\n  float: left;\n  padding-right: 4px;\n  margin-left: -20px;\n  line-height: 1;\n}\n\n.gitment-markdown .anchor:focus {\n  outline: none;\n}\n\n.gitment-markdown p,\n.gitment-markdown blockquote,\n.gitment-markdown ul,\n.gitment-markdown ol,\n.gitment-markdown dl,\n.gitment-markdown table,\n.gitment-markdown pre {\n  margin-top: 0;\n  margin-bottom: 16px;\n}\n\n.gitment-markdown hr {\n  height: 0.25em;\n  padding: 0;\n  margin: 24px 0;\n  background-color: #e1e4e8;\n  border: 0;\n}\n\n.gitment-markdown blockquote {\n  padding: 0 1em;\n  color: #6a737d;\n  border-left: 0.25em solid #dfe2e5;\n}\n\n.gitment-markdown blockquote>:first-child {\n  margin-top: 0;\n}\n\n.gitment-markdown blockquote>:last-child {\n  margin-bottom: 0;\n}\n\n.gitment-markdown kbd {\n  display: inline-block;\n  padding: 3px 5px;\n  font-size: 11px;\n  line-height: 10px;\n  color: #444d56;\n  vertical-align: middle;\n  background-color: #fafbfc;\n  border: solid 1px #c6cbd1;\n  border-bottom-color: #959da5;\n  border-radius: 0;\n  box-shadow: inset 0 -1px 0 #959da5;\n}\n\n.gitment-markdown h1,\n.gitment-markdown h2,\n.gitment-markdown h3,\n.gitment-markdown h4,\n.gitment-markdown h5,\n.gitment-markdown h6 {\n  margin-top: 24px;\n  margin-bottom: 16px;\n  font-weight: 600;\n  line-height: 1.25;\n}\n\n.gitment-markdown h1 .octicon-link,\n.gitment-markdown h2 .octicon-link,\n.gitment-markdown h3 .octicon-link,\n.gitment-markdown h4 .octicon-link,\n.gitment-markdown h5 .octicon-link,\n.gitment-markdown h6 .octicon-link {\n  color: #1b1f23;\n  vertical-align: middle;\n  visibility: hidden;\n}\n\n.gitment-markdown h1:hover .anchor,\n.gitment-markdown h2:hover .anchor,\n.gitment-markdown h3:hover .anchor,\n.gitment-markdown h4:hover .anchor,\n.gitment-markdown h5:hover .anchor,\n.gitment-markdown h6:hover .anchor {\n  text-decoration: none;\n}\n\n.gitment-markdown h1:hover .anchor .octicon-link,\n.gitment-markdown h2:hover .anchor .octicon-link,\n.gitment-markdown h3:hover .anchor .octicon-link,\n.gitment-markdown h4:hover .anchor .octicon-link,\n.gitment-markdown h5:hover .anchor .octicon-link,\n.gitment-markdown h6:hover .anchor .octicon-link {\n  visibility: visible;\n}\n\n.gitment-markdown h1 {\n  padding-bottom: 0.3em;\n  font-size: 2em;\n  border-bottom: 1px solid #eaecef;\n}\n\n.gitment-markdown h2 {\n  padding-bottom: 0.3em;\n  font-size: 1.5em;\n  border-bottom: 1px solid #eaecef;\n}\n\n.gitment-markdown h3 {\n  font-size: 1.25em;\n}\n\n.gitment-markdown h4 {\n  font-size: 1em;\n}\n\n.gitment-markdown h5 {\n  font-size: 0.875em;\n}\n\n.gitment-markdown h6 {\n  font-size: 0.85em;\n  color: #6a737d;\n}\n\n.gitment-markdown ul,\n.gitment-markdown ol {\n  padding-left: 2em;\n}\n\n.gitment-markdown ul ul,\n.gitment-markdown ul ol,\n.gitment-markdown ol ol,\n.gitment-markdown ol ul {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.gitment-markdown li>p {\n  margin-top: 16px;\n}\n\n.gitment-markdown li+li {\n  margin-top: 0.25em;\n}\n\n.gitment-markdown dl {\n  padding: 0;\n}\n\n.gitment-markdown dl dt {\n  padding: 0;\n  margin-top: 16px;\n  font-size: 1em;\n  font-style: italic;\n  font-weight: 600;\n}\n\n.gitment-markdown dl dd {\n  padding: 0 16px;\n  margin-bottom: 16px;\n}\n\n.gitment-markdown table {\n  display: block;\n  width: 100%;\n  overflow: auto;\n}\n\n.gitment-markdown table th {\n  font-weight: 600;\n}\n\n.gitment-markdown table th,\n.gitment-markdown table td {\n  padding: 6px 13px;\n  border: 1px solid #dfe2e5;\n}\n\n.gitment-markdown table tr {\n  background-color: #fff;\n  border-top: 1px solid #c6cbd1;\n}\n\n.gitment-markdown table tr:nth-child(2n) {\n  background-color: #f5f5f5;\n}\n\n.gitment-markdown img {\n  max-width: 100%;\n  box-sizing: content-box;\n  background-color: #fff;\n}\n\n.gitment-markdown code {\n  padding: 0;\n  padding-top: 0.2em;\n  padding-bottom: 0.2em;\n  margin: 0;\n  font-size: 85%;\n  background-color: rgba(27,31,35,0.05);\n  border-radius: 0;\n}\n\n.gitment-markdown code::before,\n.gitment-markdown code::after {\n  letter-spacing: -0.2em;\n  content: \"\\00a0\";\n}\n\n.gitment-markdown pre {\n  word-wrap: normal;\n}\n\n.gitment-markdown pre>code {\n  padding: 0;\n  margin: 0;\n  font-size: 100%;\n  word-break: normal;\n  white-space: pre;\n  background: transparent;\n  border: 0;\n}\n\n.gitment-markdown .highlight {\n  margin-bottom: 16px;\n}\n\n.gitment-markdown .highlight pre {\n  margin-bottom: 0;\n  word-break: normal;\n}\n\n.gitment-markdown .highlight pre,\n.gitment-markdown pre {\n  padding: 16px;\n  overflow: auto;\n  font-size: 85%;\n  line-height: 1.45;\n  background-color: #f5f5f5;\n  border-radius: 0;\n}\n\n.gitment-markdown pre code {\n  display: inline;\n  max-width: auto;\n  padding: 0;\n  margin: 0;\n  overflow: visible;\n  line-height: inherit;\n  word-wrap: normal;\n  background-color: transparent;\n  border: 0;\n}\n\n.gitment-markdown pre code::before,\n.gitment-markdown pre code::after {\n  content: normal;\n}\n\n.gitment-markdown .full-commit .btn-outline:not(:disabled):hover {\n  color: #005cc5;\n  border-color: #005cc5;\n}\n\n.gitment-markdown kbd {\n  display: inline-block;\n  padding: 3px 5px;\n  font: 11px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n  line-height: 10px;\n  color: #444d56;\n  vertical-align: middle;\n  background-color: #fcfcfc;\n  border: solid 1px #c6cbd1;\n  border-bottom-color: #959da5;\n  border-radius: 0;\n  box-shadow: inset 0 -1px 0 #959da5;\n}\n\n.gitment-markdown :checked+.radio-label {\n  position: relative;\n  z-index: 1;\n  border-color: #0366d6;\n}\n\n.gitment-markdown .task-list-item {\n  list-style-type: none;\n}\n\n.gitment-markdown .task-list-item+.task-list-item {\n  margin-top: 3px;\n}\n\n.gitment-markdown .task-list-item input {\n  margin: 0 0.2em 0.25em -1.6em;\n  vertical-align: middle;\n}\n\n.gitment-markdown hr {\n  border-bottom-color: #eee;\n}\n"},{"title":"Research","layout":"researches","date":"2024-11-11T12:52:41.000Z","sticky":100,"top":true,"mathjax":true,"_content":"\n\n# Research\n\nMy research interests are naive set theory, multivariate statistical analysis, probability and stochastic processes, and other scientific problems related to them. More specifically, my interests include not merely\n\n- Time change and transformation of probability measures\n- Special functions and statistical distributions\n- Infinite cardinal arithmetics and computational complexity \n- Countably normed rings and pure states in unbounded operators  \n- .  .  .  \n\n# Publications\n\n## Preprints\n\nThesis: Matrix Distributions under Classical Group Actions, 2025 [en](https://arxiv.org/abs/2505.00470) <span style=\"font-family: 楷体_GB2312;\">矩阵分布与典型群作用</span>, 2025 [ch]()\n\n\nAll publications are available on [arXiv](http://arxiv.org/a/wang_h_18).\n\n## Articles\n\n[1] <span style=\"font-family: 楷体_GB2312;\">\n吕裴, 蒋笑天, 王浩铭, 王戍堂. 关于惯性参照系的一条引理---对朗道<<场论>>中不同惯性系下间隔相等证明的补充. 2017. (遗稿)\n</span>\n\n[2] Wang, Haoming. On the distribution of the sample covariance from a matrix normal population[J]. 2025. Submitted.\n\n[3] Wang, Haoming. On incomplete Gamma and Beta integrals[J]. 2025. Submitted.\n\n[4] Wang, Haoming. On characterization of point processes by minimal predictable intensity[J]. 2025. Submitted.\n\n[5] Wang, Haoming. Martingale problem and quadratic family[J]. 2025. Submitted.\n\n[6] Wang, Haoming. Free limits of simultaneous diagonalisable adjoint operators. Preprint.\n\n\n# Books\n\n## Notes\n\n## Translations\n\nI have decided to translate these books into Chinese but typically guarantee no scedule time.\n\n\n<span style=\"font-family: 楷体_GB2312;\">我打算翻译一本德文书, 一本法文书, 还有一本科普读物, 但仍不知何时付梓.</span>\n\nE. Hopf, Ergodentheorie, 1937, <span style=\"font-family: 楷体_GB2312;\">霍普夫, 遍历论</span> \n\nP. Lévy, Theorie de l'addition des variables aléatoires, 1937, <span style=\"font-family: 楷体_GB2312;\">列维, 可加过程</span> \n\nW. Sierpinski, A selection of problems in the theory of numbers, 1964, <span style=\"font-family: 楷体_GB2312;\">谢尔宾斯基, 认识素数29讲</span> \n\n# Activities\n\n- Reviewer for [Zentralblatt für Mathematik](https://zbmath.org/)\n\n\n# Talks\n\n*2025/01/09*, The Conference of Complex Analysis in China 2024, Shenzhen, [Slides](https://blueairm.github.io/research/pdf/Zonal250109.pdf)\n\n*2024/11/10*, The Conference of Probability and Statistics in China 2024, Xiamen, [Slides](https://blueairm.github.io/research/pdf/Prob241110.pdf)\n","source":"research/index.md","raw":"---\ntitle: Research\nlayout: researches\ndate: 2024-11-11 20:52:41\nsticky: 100\ntop: true\nmathjax: true\n---\n\n\n# Research\n\nMy research interests are naive set theory, multivariate statistical analysis, probability and stochastic processes, and other scientific problems related to them. More specifically, my interests include not merely\n\n- Time change and transformation of probability measures\n- Special functions and statistical distributions\n- Infinite cardinal arithmetics and computational complexity \n- Countably normed rings and pure states in unbounded operators  \n- .  .  .  \n\n# Publications\n\n## Preprints\n\nThesis: Matrix Distributions under Classical Group Actions, 2025 [en](https://arxiv.org/abs/2505.00470) <span style=\"font-family: 楷体_GB2312;\">矩阵分布与典型群作用</span>, 2025 [ch]()\n\n\nAll publications are available on [arXiv](http://arxiv.org/a/wang_h_18).\n\n## Articles\n\n[1] <span style=\"font-family: 楷体_GB2312;\">\n吕裴, 蒋笑天, 王浩铭, 王戍堂. 关于惯性参照系的一条引理---对朗道<<场论>>中不同惯性系下间隔相等证明的补充. 2017. (遗稿)\n</span>\n\n[2] Wang, Haoming. On the distribution of the sample covariance from a matrix normal population[J]. 2025. Submitted.\n\n[3] Wang, Haoming. On incomplete Gamma and Beta integrals[J]. 2025. Submitted.\n\n[4] Wang, Haoming. On characterization of point processes by minimal predictable intensity[J]. 2025. Submitted.\n\n[5] Wang, Haoming. Martingale problem and quadratic family[J]. 2025. Submitted.\n\n[6] Wang, Haoming. Free limits of simultaneous diagonalisable adjoint operators. Preprint.\n\n\n# Books\n\n## Notes\n\n## Translations\n\nI have decided to translate these books into Chinese but typically guarantee no scedule time.\n\n\n<span style=\"font-family: 楷体_GB2312;\">我打算翻译一本德文书, 一本法文书, 还有一本科普读物, 但仍不知何时付梓.</span>\n\nE. Hopf, Ergodentheorie, 1937, <span style=\"font-family: 楷体_GB2312;\">霍普夫, 遍历论</span> \n\nP. Lévy, Theorie de l'addition des variables aléatoires, 1937, <span style=\"font-family: 楷体_GB2312;\">列维, 可加过程</span> \n\nW. Sierpinski, A selection of problems in the theory of numbers, 1964, <span style=\"font-family: 楷体_GB2312;\">谢尔宾斯基, 认识素数29讲</span> \n\n# Activities\n\n- Reviewer for [Zentralblatt für Mathematik](https://zbmath.org/)\n\n\n# Talks\n\n*2025/01/09*, The Conference of Complex Analysis in China 2024, Shenzhen, [Slides](https://blueairm.github.io/research/pdf/Zonal250109.pdf)\n\n*2024/11/10*, The Conference of Probability and Statistics in China 2024, Xiamen, [Slides](https://blueairm.github.io/research/pdf/Prob241110.pdf)\n","updated":"2025-09-09T05:09:24.308Z","path":"research/index.html","comments":1,"_id":"cmfwcr5rs0008m8nxhxh86wmd","content":"<h1 id=\"research\">Research</h1>\r\n<p>My research interests are naive set theory, multivariate statistical\r\nanalysis, probability and stochastic processes, and other scientific\r\nproblems related to them. More specifically, my interests include not\r\nmerely</p>\r\n<ul>\r\n<li>Time change and transformation of probability measures</li>\r\n<li>Special functions and statistical distributions</li>\r\n<li>Infinite cardinal arithmetics and computational complexity</li>\r\n<li>Countably normed rings and pure states in unbounded operators<br>\r\n</li>\r\n<li>. . .</li>\r\n</ul>\r\n<h1 id=\"publications\">Publications</h1>\r\n<h2 id=\"preprints\">Preprints</h2>\r\n<p>Thesis: Matrix Distributions under Classical Group Actions, 2025 <a href=\"https://arxiv.org/abs/2505.00470\">en</a> <span style=\"font-family: 楷体_GB2312;\">矩阵分布与典型群作用</span>, 2025 <a href>ch</a></p>\r\n<p>All publications are available on <a href=\"http://arxiv.org/a/wang_h_18\">arXiv</a>.</p>\r\n<h2 id=\"articles\">Articles</h2>\r\n<p>[1] <span style=\"font-family: 楷体_GB2312;\"> 吕裴, 蒋笑天, 王浩铭,\r\n王戍堂.\r\n关于惯性参照系的一条引理---对朗道&lt;<场论>&gt;中不同惯性系下间隔相等证明的补充.\r\n2017. (遗稿) </场论></span></p>\r\n<p>[2] Wang, Haoming. On the distribution of the sample covariance from\r\na matrix normal population[J]. 2025. Submitted.</p>\r\n<p>[3] Wang, Haoming. On incomplete Gamma and Beta integrals[J]. 2025.\r\nSubmitted.</p>\r\n<p>[4] Wang, Haoming. On characterization of point processes by minimal\r\npredictable intensity[J]. 2025. Submitted.</p>\r\n<p>[5] Wang, Haoming. Martingale problem and quadratic family[J]. 2025.\r\nSubmitted.</p>\r\n<p>[6] Wang, Haoming. Free limits of simultaneous diagonalisable adjoint\r\noperators. Preprint.</p>\r\n<h1 id=\"books\">Books</h1>\r\n<h2 id=\"notes\">Notes</h2>\r\n<h2 id=\"translations\">Translations</h2>\r\n<p>I have decided to translate these books into Chinese but typically\r\nguarantee no scedule time.</p>\r\n<p><span style=\"font-family: 楷体_GB2312;\">我打算翻译一本德文书,\r\n一本法文书, 还有一本科普读物, 但仍不知何时付梓.</span></p>\r\n<p>E. Hopf, Ergodentheorie, 1937, <span style=\"font-family: 楷体_GB2312;\">霍普夫, 遍历论</span></p>\r\n<p>P. Lévy, Theorie de l'addition des variables aléatoires, 1937, <span style=\"font-family: 楷体_GB2312;\">列维, 可加过程</span></p>\r\n<p>W. Sierpinski, A selection of problems in the theory of numbers,\r\n1964, <span style=\"font-family: 楷体_GB2312;\">谢尔宾斯基,\r\n认识素数29讲</span></p>\r\n<h1 id=\"activities\">Activities</h1>\r\n<ul>\r\n<li>Reviewer for <a href=\"https://zbmath.org/\">Zentralblatt für\r\nMathematik</a></li>\r\n</ul>\r\n<h1 id=\"talks\">Talks</h1>\r\n<p><em>2025/01/09</em>, The Conference of Complex Analysis in China\r\n2024, Shenzhen, <a href=\"https://blueairm.github.io/research/pdf/Zonal250109.pdf\">Slides</a></p>\r\n<p><em>2024/11/10</em>, The Conference of Probability and Statistics in\r\nChina 2024, Xiamen, <a href=\"https://blueairm.github.io/research/pdf/Prob241110.pdf\">Slides</a></p>\r\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"research\">Research</h1>\r\n<p>My research interests are naive set theory, multivariate statistical\r\nanalysis, probability and stochastic processes, and other scientific\r\nproblems related to them. More specifically, my interests include not\r\nmerely</p>\r\n<ul>\r\n<li>Time change and transformation of probability measures</li>\r\n<li>Special functions and statistical distributions</li>\r\n<li>Infinite cardinal arithmetics and computational complexity</li>\r\n<li>Countably normed rings and pure states in unbounded operators<br>\r\n</li>\r\n<li>. . .</li>\r\n</ul>\r\n<h1 id=\"publications\">Publications</h1>\r\n<h2 id=\"preprints\">Preprints</h2>\r\n<p>Thesis: Matrix Distributions under Classical Group Actions, 2025 <a href=\"https://arxiv.org/abs/2505.00470\">en</a> <span style=\"font-family: 楷体_GB2312;\">矩阵分布与典型群作用</span>, 2025 <a href>ch</a></p>\r\n<p>All publications are available on <a href=\"http://arxiv.org/a/wang_h_18\">arXiv</a>.</p>\r\n<h2 id=\"articles\">Articles</h2>\r\n<p>[1] <span style=\"font-family: 楷体_GB2312;\"> 吕裴, 蒋笑天, 王浩铭,\r\n王戍堂.\r\n关于惯性参照系的一条引理---对朗道&lt;<场论>&gt;中不同惯性系下间隔相等证明的补充.\r\n2017. (遗稿) </场论></span></p>\r\n<p>[2] Wang, Haoming. On the distribution of the sample covariance from\r\na matrix normal population[J]. 2025. Submitted.</p>\r\n<p>[3] Wang, Haoming. On incomplete Gamma and Beta integrals[J]. 2025.\r\nSubmitted.</p>\r\n<p>[4] Wang, Haoming. On characterization of point processes by minimal\r\npredictable intensity[J]. 2025. Submitted.</p>\r\n<p>[5] Wang, Haoming. Martingale problem and quadratic family[J]. 2025.\r\nSubmitted.</p>\r\n<p>[6] Wang, Haoming. Free limits of simultaneous diagonalisable adjoint\r\noperators. Preprint.</p>\r\n<h1 id=\"books\">Books</h1>\r\n<h2 id=\"notes\">Notes</h2>\r\n<h2 id=\"translations\">Translations</h2>\r\n<p>I have decided to translate these books into Chinese but typically\r\nguarantee no scedule time.</p>\r\n<p><span style=\"font-family: 楷体_GB2312;\">我打算翻译一本德文书,\r\n一本法文书, 还有一本科普读物, 但仍不知何时付梓.</span></p>\r\n<p>E. Hopf, Ergodentheorie, 1937, <span style=\"font-family: 楷体_GB2312;\">霍普夫, 遍历论</span></p>\r\n<p>P. Lévy, Theorie de l'addition des variables aléatoires, 1937, <span style=\"font-family: 楷体_GB2312;\">列维, 可加过程</span></p>\r\n<p>W. Sierpinski, A selection of problems in the theory of numbers,\r\n1964, <span style=\"font-family: 楷体_GB2312;\">谢尔宾斯基,\r\n认识素数29讲</span></p>\r\n<h1 id=\"activities\">Activities</h1>\r\n<ul>\r\n<li>Reviewer for <a href=\"https://zbmath.org/\">Zentralblatt für\r\nMathematik</a></li>\r\n</ul>\r\n<h1 id=\"talks\">Talks</h1>\r\n<p><em>2025/01/09</em>, The Conference of Complex Analysis in China\r\n2024, Shenzhen, <a href=\"https://blueairm.github.io/research/pdf/Zonal250109.pdf\">Slides</a></p>\r\n<p><em>2024/11/10</em>, The Conference of Probability and Statistics in\r\nChina 2024, Xiamen, <a href=\"https://blueairm.github.io/research/pdf/Prob241110.pdf\">Slides</a></p>\r\n"},{"title":"Seminar","layout":"semiar","date":"2024-01-30T12:52:41.000Z","sticky":100,"top":true,"mathjax":true,"pagination":true,"per_page":10,"_content":"\n\n\n## (2024/01/30-2024/12/31)\n\n2024/11/22, 10:00 a.m., [Tencent Meeting]()\n\nTang Dingxuan (Northwest A&F University)\n\n**Local Conditional Entropy For Amenable Group Actions**\n\nFor a countable discrete amenable group action, we study two types of measure-theoretical entropies and the concept of topological conditional entropy, both for finite measurable covers conditioned by finite partitions. Using an orbital approach, we establish a local conditional variational principle for an amenable group action. Moreover, we study the concept of conditional entropy tuples. At the end, we introduce the notion of conditional metric mean dimensions and present a corresponding variational principle.\n\nManuscript.\n\n\n2024/10/11, 10:00 a.m., [Tencent Meeting]()\n\nZhang Jiashu (Westlake University)\n\n**Homogeneous Besov Spaces in Dunkl Setting**\n\nThe purpose of this paper is to characterize the homogeneous Besov space in the Dunkl setting. We utilize a new discrete reproducing formula, that is, the building blocks are differences of the Dunkl-Poisson kernel which involves both the Euclidean metric and the Dunkl metric. To introduce the Besov spaces in the Dunkl setting, new test functions and distributions are introduced, and a new decomposition is established.\n\n[arXiv](https://arxiv.org/abs/2408.00340).\n\n\n2024/04/13, 13:00 p.m., [Tencent Meeting]()\n\nWang Tao (Nankai University)\n\n**General relativistic stochastic thermodynamics**\n\nBased on the recent work [[1](https://arxiv.org/abs/2306.01982),[2](https://arxiv.org/abs/2307.07805)], we formulate the first law and the second law of stochastic thermodynamics in the framework of general relativity. These laws are established for a charged Brownian particle moving in a heat reservoir and subjecting to an external electromagnetic field in generic stationary spacetime background, and in order to maintain general covariance, they are presented respectively in terms of the divergences of the energy current and the entropy density current. The stability of the equilibrium state is also analyzed.\n\n[Article 0](https://arxiv.org/abs/2311.04025), [Article 1](https://doi.org/10.1007/s10955-023-03204-5), [Article 2](https://doi.org/10.1007/s10955-023-03205-4). Two appears in Journal of Statistical Physics.\n\n\n\n2024/03/16, 13:00 p.m., [Tencent Meeting](https://meeting.tencent.com/v2/cloud-record/share?id=f4188d5c-1e25-47b7-b935-b4cd41040215) Password: 789A\n\nSheng Xi (University of Science and Technology of China)\n\n**Stochastic Approximation Algorithms Whose Averages are Competitive**\n\nThis report discusses a class of stochastic approximation algorithms for iterative processes.\nUnder the assumption of large deviations, the relationship between the long time behavior of the iterative process and the solution flow of the mean field is discussed.\nWhen this mean field satisfies a special property, competition, we show that the final behavior of the iterative process asymptotically approximates to some invariant manifold of co-dimension 1.\nFurther, we use a similar approximation algorithm to study the stochastic stability of competing systems and have similar conclusions.\n\n[arXiv](https://arxiv.org/abs/2311.07038). \n\n2024/02/23, 10:00 a.m., [Tencent Meeting](https://meeting.tencent.com/v2/cloud-record/share?id=2a1f7a17-350c-4abd-8bd2-6ffc1ac42b1e&from=3&record_type=2)\n\nWang Haoming (Sun Yat-sen University)\n\n**Hierarchy of Maximal ideals in the Banach Algebra II**\n\nBased on the series talk I, we discuss applications of results of the C*-algebra to the quantum mechanics.\n\nManuscript.\n\n2024/02/02, 13:00 p.m., [Tencent Meeting]()\n\nWang Haoming (Sun Yat-sen University)\n\n\n**Hierarchy of Maximal ideals in the Banach Algebra I**\n\nThis paper introduces two topologies, namely the weak\\*-topology (also known as the product topology) and the Zariski topology on the set of maximal ideals in the Banach algebra using both analytical and algebraic methods. It proves that under the condition of separability, the set of maximal ideals endowed with the weak\\*-topology is second countable and metrizable, and it demonstrates that the two topologies are homeomorphic. We illustrate examples such as the continuous function ring $C(X)$, where $X$ is a compact Hausdorff space and the $l^p$ space for $1 \\leq p < +\\infty$.\n\nManuscript, [Slides](https://blueairm.github.io/seminar/pdf/whm20240202.pdf)\n\n<div class=\"pagination\">\n  <a class=\"previous\" href=\"/seminar/index\">Previous Page</a>\n  <a>Next Page</a>\n</div>\n","source":"seminar/2024.md","raw":"---\ntitle: Seminar\nlayout: semiar\ndate: 2024-01-30 20:52:41\nsticky: 100\ntop: true\nmathjax: true\npagination: true\nper_page: 10\n---\n\n\n\n## (2024/01/30-2024/12/31)\n\n2024/11/22, 10:00 a.m., [Tencent Meeting]()\n\nTang Dingxuan (Northwest A&F University)\n\n**Local Conditional Entropy For Amenable Group Actions**\n\nFor a countable discrete amenable group action, we study two types of measure-theoretical entropies and the concept of topological conditional entropy, both for finite measurable covers conditioned by finite partitions. Using an orbital approach, we establish a local conditional variational principle for an amenable group action. Moreover, we study the concept of conditional entropy tuples. At the end, we introduce the notion of conditional metric mean dimensions and present a corresponding variational principle.\n\nManuscript.\n\n\n2024/10/11, 10:00 a.m., [Tencent Meeting]()\n\nZhang Jiashu (Westlake University)\n\n**Homogeneous Besov Spaces in Dunkl Setting**\n\nThe purpose of this paper is to characterize the homogeneous Besov space in the Dunkl setting. We utilize a new discrete reproducing formula, that is, the building blocks are differences of the Dunkl-Poisson kernel which involves both the Euclidean metric and the Dunkl metric. To introduce the Besov spaces in the Dunkl setting, new test functions and distributions are introduced, and a new decomposition is established.\n\n[arXiv](https://arxiv.org/abs/2408.00340).\n\n\n2024/04/13, 13:00 p.m., [Tencent Meeting]()\n\nWang Tao (Nankai University)\n\n**General relativistic stochastic thermodynamics**\n\nBased on the recent work [[1](https://arxiv.org/abs/2306.01982),[2](https://arxiv.org/abs/2307.07805)], we formulate the first law and the second law of stochastic thermodynamics in the framework of general relativity. These laws are established for a charged Brownian particle moving in a heat reservoir and subjecting to an external electromagnetic field in generic stationary spacetime background, and in order to maintain general covariance, they are presented respectively in terms of the divergences of the energy current and the entropy density current. The stability of the equilibrium state is also analyzed.\n\n[Article 0](https://arxiv.org/abs/2311.04025), [Article 1](https://doi.org/10.1007/s10955-023-03204-5), [Article 2](https://doi.org/10.1007/s10955-023-03205-4). Two appears in Journal of Statistical Physics.\n\n\n\n2024/03/16, 13:00 p.m., [Tencent Meeting](https://meeting.tencent.com/v2/cloud-record/share?id=f4188d5c-1e25-47b7-b935-b4cd41040215) Password: 789A\n\nSheng Xi (University of Science and Technology of China)\n\n**Stochastic Approximation Algorithms Whose Averages are Competitive**\n\nThis report discusses a class of stochastic approximation algorithms for iterative processes.\nUnder the assumption of large deviations, the relationship between the long time behavior of the iterative process and the solution flow of the mean field is discussed.\nWhen this mean field satisfies a special property, competition, we show that the final behavior of the iterative process asymptotically approximates to some invariant manifold of co-dimension 1.\nFurther, we use a similar approximation algorithm to study the stochastic stability of competing systems and have similar conclusions.\n\n[arXiv](https://arxiv.org/abs/2311.07038). \n\n2024/02/23, 10:00 a.m., [Tencent Meeting](https://meeting.tencent.com/v2/cloud-record/share?id=2a1f7a17-350c-4abd-8bd2-6ffc1ac42b1e&from=3&record_type=2)\n\nWang Haoming (Sun Yat-sen University)\n\n**Hierarchy of Maximal ideals in the Banach Algebra II**\n\nBased on the series talk I, we discuss applications of results of the C*-algebra to the quantum mechanics.\n\nManuscript.\n\n2024/02/02, 13:00 p.m., [Tencent Meeting]()\n\nWang Haoming (Sun Yat-sen University)\n\n\n**Hierarchy of Maximal ideals in the Banach Algebra I**\n\nThis paper introduces two topologies, namely the weak\\*-topology (also known as the product topology) and the Zariski topology on the set of maximal ideals in the Banach algebra using both analytical and algebraic methods. It proves that under the condition of separability, the set of maximal ideals endowed with the weak\\*-topology is second countable and metrizable, and it demonstrates that the two topologies are homeomorphic. We illustrate examples such as the continuous function ring $C(X)$, where $X$ is a compact Hausdorff space and the $l^p$ space for $1 \\leq p < +\\infty$.\n\nManuscript, [Slides](https://blueairm.github.io/seminar/pdf/whm20240202.pdf)\n\n<div class=\"pagination\">\n  <a class=\"previous\" href=\"/seminar/index\">Previous Page</a>\n  <a>Next Page</a>\n</div>\n","updated":"2025-01-04T15:26:07.941Z","path":"seminar/2024.html","comments":1,"_id":"cmfwcr5rt000am8nxebpn25c5","content":"<h2 id=\"section\">(2024/01/30-2024/12/31)</h2>\r\n<p>2024/11/22, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Tang Dingxuan (Northwest A&amp;F University)</p>\r\n<p><strong>Local Conditional Entropy For Amenable Group\r\nActions</strong></p>\r\n<p>For a countable discrete amenable group action, we study two types of\r\nmeasure-theoretical entropies and the concept of topological conditional\r\nentropy, both for finite measurable covers conditioned by finite\r\npartitions. Using an orbital approach, we establish a local conditional\r\nvariational principle for an amenable group action. Moreover, we study\r\nthe concept of conditional entropy tuples. At the end, we introduce the\r\nnotion of conditional metric mean dimensions and present a corresponding\r\nvariational principle.</p>\r\n<p>Manuscript.</p>\r\n<p>2024/10/11, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Zhang Jiashu (Westlake University)</p>\r\n<p><strong>Homogeneous Besov Spaces in Dunkl Setting</strong></p>\r\n<p>The purpose of this paper is to characterize the homogeneous Besov\r\nspace in the Dunkl setting. We utilize a new discrete reproducing\r\nformula, that is, the building blocks are differences of the\r\nDunkl-Poisson kernel which involves both the Euclidean metric and the\r\nDunkl metric. To introduce the Besov spaces in the Dunkl setting, new\r\ntest functions and distributions are introduced, and a new decomposition\r\nis established.</p>\r\n<p><a href=\"https://arxiv.org/abs/2408.00340\">arXiv</a>.</p>\r\n<p>2024/04/13, 13:00 p.m., <a href>Tencent Meeting</a></p>\r\n<p>Wang Tao (Nankai University)</p>\r\n<p><strong>General relativistic stochastic thermodynamics</strong></p>\r\n<p>Based on the recent work [<a href=\"https://arxiv.org/abs/2306.01982\">1</a>,<a href=\"https://arxiv.org/abs/2307.07805\">2</a>], we formulate the first\r\nlaw and the second law of stochastic thermodynamics in the framework of\r\ngeneral relativity. These laws are established for a charged Brownian\r\nparticle moving in a heat reservoir and subjecting to an external\r\nelectromagnetic field in generic stationary spacetime background, and in\r\norder to maintain general covariance, they are presented respectively in\r\nterms of the divergences of the energy current and the entropy density\r\ncurrent. The stability of the equilibrium state is also analyzed.</p>\r\n<p><a href=\"https://arxiv.org/abs/2311.04025\">Article 0</a>, <a href=\"https://doi.org/10.1007/s10955-023-03204-5\">Article 1</a>, <a href=\"https://doi.org/10.1007/s10955-023-03205-4\">Article 2</a>. Two\r\nappears in Journal of Statistical Physics.</p>\r\n<p>2024/03/16, 13:00 p.m., <a href=\"https://meeting.tencent.com/v2/cloud-record/share?id=f4188d5c-1e25-47b7-b935-b4cd41040215\">Tencent\r\nMeeting</a> Password: 789A</p>\r\n<p>Sheng Xi (University of Science and Technology of China)</p>\r\n<p><strong>Stochastic Approximation Algorithms Whose Averages are\r\nCompetitive</strong></p>\r\n<p>This report discusses a class of stochastic approximation algorithms\r\nfor iterative processes. Under the assumption of large deviations, the\r\nrelationship between the long time behavior of the iterative process and\r\nthe solution flow of the mean field is discussed. When this mean field\r\nsatisfies a special property, competition, we show that the final\r\nbehavior of the iterative process asymptotically approximates to some\r\ninvariant manifold of co-dimension 1. Further, we use a similar\r\napproximation algorithm to study the stochastic stability of competing\r\nsystems and have similar conclusions.</p>\r\n<p><a href=\"https://arxiv.org/abs/2311.07038\">arXiv</a>.</p>\r\n<p>2024/02/23, 10:00 a.m., <a href=\"https://meeting.tencent.com/v2/cloud-record/share?id=2a1f7a17-350c-4abd-8bd2-6ffc1ac42b1e&amp;from=3&amp;record_type=2\">Tencent\r\nMeeting</a></p>\r\n<p>Wang Haoming (Sun Yat-sen University)</p>\r\n<p><strong>Hierarchy of Maximal ideals in the Banach Algebra\r\nII</strong></p>\r\n<p>Based on the series talk I, we discuss applications of results of the\r\nC*-algebra to the quantum mechanics.</p>\r\n<p>Manuscript.</p>\r\n<p>2024/02/02, 13:00 p.m., <a href>Tencent Meeting</a></p>\r\n<p>Wang Haoming (Sun Yat-sen University)</p>\r\n<p><strong>Hierarchy of Maximal ideals in the Banach Algebra\r\nI</strong></p>\r\n<p>This paper introduces two topologies, namely the weak*-topology (also\r\nknown as the product topology) and the Zariski topology on the set of\r\nmaximal ideals in the Banach algebra using both analytical and algebraic\r\nmethods. It proves that under the condition of separability, the set of\r\nmaximal ideals endowed with the weak*-topology is second countable and\r\nmetrizable, and it demonstrates that the two topologies are\r\nhomeomorphic. We illustrate examples such as the continuous function\r\nring <span class=\"math inline\">\\(C(X)\\)</span>, where <span class=\"math inline\">\\(X\\)</span> is a compact Hausdorff space and the\r\n<span class=\"math inline\">\\(l^p\\)</span> space for <span class=\"math inline\">\\(1 \\leq p &lt; +\\infty\\)</span>.</p>\r\n<p>Manuscript, <a href=\"https://blueairm.github.io/seminar/pdf/whm20240202.pdf\">Slides</a></p>\r\n<div class=\"pagination\">\r\n<p><a class=\"previous\" href=\"/seminar/index\">Previous Page</a> <a>Next\r\nPage</a></p>\r\n</div>\r\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"section\">(2024/01/30-2024/12/31)</h2>\r\n<p>2024/11/22, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Tang Dingxuan (Northwest A&amp;F University)</p>\r\n<p><strong>Local Conditional Entropy For Amenable Group\r\nActions</strong></p>\r\n<p>For a countable discrete amenable group action, we study two types of\r\nmeasure-theoretical entropies and the concept of topological conditional\r\nentropy, both for finite measurable covers conditioned by finite\r\npartitions. Using an orbital approach, we establish a local conditional\r\nvariational principle for an amenable group action. Moreover, we study\r\nthe concept of conditional entropy tuples. At the end, we introduce the\r\nnotion of conditional metric mean dimensions and present a corresponding\r\nvariational principle.</p>\r\n<p>Manuscript.</p>\r\n<p>2024/10/11, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Zhang Jiashu (Westlake University)</p>\r\n<p><strong>Homogeneous Besov Spaces in Dunkl Setting</strong></p>\r\n<p>The purpose of this paper is to characterize the homogeneous Besov\r\nspace in the Dunkl setting. We utilize a new discrete reproducing\r\nformula, that is, the building blocks are differences of the\r\nDunkl-Poisson kernel which involves both the Euclidean metric and the\r\nDunkl metric. To introduce the Besov spaces in the Dunkl setting, new\r\ntest functions and distributions are introduced, and a new decomposition\r\nis established.</p>\r\n<p><a href=\"https://arxiv.org/abs/2408.00340\">arXiv</a>.</p>\r\n<p>2024/04/13, 13:00 p.m., <a href>Tencent Meeting</a></p>\r\n<p>Wang Tao (Nankai University)</p>\r\n<p><strong>General relativistic stochastic thermodynamics</strong></p>\r\n<p>Based on the recent work [<a href=\"https://arxiv.org/abs/2306.01982\">1</a>,<a href=\"https://arxiv.org/abs/2307.07805\">2</a>], we formulate the first\r\nlaw and the second law of stochastic thermodynamics in the framework of\r\ngeneral relativity. These laws are established for a charged Brownian\r\nparticle moving in a heat reservoir and subjecting to an external\r\nelectromagnetic field in generic stationary spacetime background, and in\r\norder to maintain general covariance, they are presented respectively in\r\nterms of the divergences of the energy current and the entropy density\r\ncurrent. The stability of the equilibrium state is also analyzed.</p>\r\n<p><a href=\"https://arxiv.org/abs/2311.04025\">Article 0</a>, <a href=\"https://doi.org/10.1007/s10955-023-03204-5\">Article 1</a>, <a href=\"https://doi.org/10.1007/s10955-023-03205-4\">Article 2</a>. Two\r\nappears in Journal of Statistical Physics.</p>\r\n<p>2024/03/16, 13:00 p.m., <a href=\"https://meeting.tencent.com/v2/cloud-record/share?id=f4188d5c-1e25-47b7-b935-b4cd41040215\">Tencent\r\nMeeting</a> Password: 789A</p>\r\n<p>Sheng Xi (University of Science and Technology of China)</p>\r\n<p><strong>Stochastic Approximation Algorithms Whose Averages are\r\nCompetitive</strong></p>\r\n<p>This report discusses a class of stochastic approximation algorithms\r\nfor iterative processes. Under the assumption of large deviations, the\r\nrelationship between the long time behavior of the iterative process and\r\nthe solution flow of the mean field is discussed. When this mean field\r\nsatisfies a special property, competition, we show that the final\r\nbehavior of the iterative process asymptotically approximates to some\r\ninvariant manifold of co-dimension 1. Further, we use a similar\r\napproximation algorithm to study the stochastic stability of competing\r\nsystems and have similar conclusions.</p>\r\n<p><a href=\"https://arxiv.org/abs/2311.07038\">arXiv</a>.</p>\r\n<p>2024/02/23, 10:00 a.m., <a href=\"https://meeting.tencent.com/v2/cloud-record/share?id=2a1f7a17-350c-4abd-8bd2-6ffc1ac42b1e&amp;from=3&amp;record_type=2\">Tencent\r\nMeeting</a></p>\r\n<p>Wang Haoming (Sun Yat-sen University)</p>\r\n<p><strong>Hierarchy of Maximal ideals in the Banach Algebra\r\nII</strong></p>\r\n<p>Based on the series talk I, we discuss applications of results of the\r\nC*-algebra to the quantum mechanics.</p>\r\n<p>Manuscript.</p>\r\n<p>2024/02/02, 13:00 p.m., <a href>Tencent Meeting</a></p>\r\n<p>Wang Haoming (Sun Yat-sen University)</p>\r\n<p><strong>Hierarchy of Maximal ideals in the Banach Algebra\r\nI</strong></p>\r\n<p>This paper introduces two topologies, namely the weak*-topology (also\r\nknown as the product topology) and the Zariski topology on the set of\r\nmaximal ideals in the Banach algebra using both analytical and algebraic\r\nmethods. It proves that under the condition of separability, the set of\r\nmaximal ideals endowed with the weak*-topology is second countable and\r\nmetrizable, and it demonstrates that the two topologies are\r\nhomeomorphic. We illustrate examples such as the continuous function\r\nring <span class=\"math inline\">\\(C(X)\\)</span>, where <span class=\"math inline\">\\(X\\)</span> is a compact Hausdorff space and the\r\n<span class=\"math inline\">\\(l^p\\)</span> space for <span class=\"math inline\">\\(1 \\leq p &lt; +\\infty\\)</span>.</p>\r\n<p>Manuscript, <a href=\"https://blueairm.github.io/seminar/pdf/whm20240202.pdf\">Slides</a></p>\r\n<div class=\"pagination\">\r\n<p><a class=\"previous\" href=\"/seminar/index\">Previous Page</a> <a>Next\r\nPage</a></p>\r\n</div>\r\n"},{"title":"Continuous Logic and Free Probability","layout":"semiar","date":"2024-01-30T12:52:41.000Z","sticky":100,"top":true,"mathjax":true,"pagination":true,"per_page":10,"_content":"\nThis webpage is about the 2025 seminar on *Continuous Logic and Free Probability*. There are *TEN* lecturers from diverse universities to give related talks. Titles and abstracts are updated on this webpage.\n\n## Summary\n\n2025/09/19, 10:00 a.m., [Tencent Meeting](https://meeting.tencent.com/crm/2aZ5RQd890)\n\nHu Yuqi (UC Irvine) Reviewer: Wang Wei (SYSU)\n\n**Basic continuous model theory**\n\nI will discuss continuous logic and show how it can be used to extend Voiculescu's free entropy of microstates to model-theoretic types. I will also present some results and open problems related to the analogy between microstates and types.\n\n在本报告中，我将探讨连续逻辑，并展示如何利用它将 Voiculescu 的自由微态熵推广至模型论类型。此外，我将介绍关于微态与类型类比方面的现有研究成果和未解之谜。\n\nReferences:\n\n[1] Isaac Goldbring (Ed.) Model Theory of Operator Algebras.\n\n*Dr. Hu discusses the basic concepts of continuous logic and free probability theory and their applications in model theory, with particular attention to concepts such as ultra-filters, metric spaces, uniformly continuous functions, and operator algebras, as well as their potential applications in probability theory and logic. -- Wang Wei*\n\n2025/10/03, 10:00 a.m., [Tencent Meeting]()\n\nLi Xiangchao (USTC) Reviewer: Xu Yuanyuan (CAS)\n\n**Central limit theorem for mesoscopic eigenvalue statistics of the free sum of matrices**\n\nThis paper studies the central limit theorem (CLT) for mesoscopic eigenvalue statistics of the free sum of random matrices. Consider matrices of the form:\n$$H_N = A_N + U_N B_N U_N^*,$$\nwhere $A_N, B_N$ are deterministic Hermitian matrices, and $U_N$ is a Haar-distributed random unitary (or orthogonal) matrix. The focus is on linear eigenvalue statistics:\n$$\\sum_{i=1}^N g\\left(\\frac{\\lambda_i - E}{\\eta}\\right) - \\mathbb{E}\\sum_{i=1}^N g\\left(\\frac{\\lambda_i - E}{\\eta}\\right)$$\nwithin the mesoscopic regime $N^{-1} \\ll \\eta \\ll 1$ in the regular bulk of the spectrum. The main result establishes convergence to a centered Gaussian random variable with variance:\n$$\\frac{1}{2\\beta\\pi^2} \\int_{\\mathbb{R}}\\int_{\\mathbb{R}} \\frac{(g(x_1) - g(x_2))^2}{(x_1 - x_2)^2} dx_1 dx_2 = \\frac{1}{\\beta\\pi} \\int_{\\mathbb{R}} |\\xi||\\hat{g}(\\xi)|^2 d\\xi,\n$$\nwhere $\\beta = 2$ (unitary case) or $\\beta = 1$ (orthogonal case). The proof uses:\n\n- Characteristic function analysis of linear statistics.\n\n- Ward identities from Haar measure invariance.\n\n- Local laws for resolvents, e.g., $|G_{ij}(z) - \\frac{1}{a_i - \\omega_B(z)}\\delta_{ij}| \\prec \\frac{1}{\\sqrt{N|\\eta|}}$.\n\n- Analytic subordination properties of free additive convolution:\n$$F_{\\mu_A}(\\omega_B(z)) = F_{\\mu_B}(\\omega_A(z)), \\quad F_\\mu(z) = -1/m_\\mu(z).$$\nExtensions include:\n\n- Orthogonal conjugation case ($H_N = A + OBO^T$).\n\n- Edge behavior with modified variance and bias terms. \n\nThis work connects to universality in random matrix theory and free probability, providing a unified framework for mesoscopic fluctuations.\n\n2025/10/17, 10:00 a.m., [Tencent Meeting]()\n\n[Wang Haoming](https://blueairm.github.io/) (SYSU) Reviewer: Koki Shimizu (TUS)\n\n**Simultaneous diagonalisable adjoint operators: A finite sample study**\n\nThis work is based on the proper orthogonal decomposition or Karhunen-Lo\\'eve theorem for stochastic processes. Four canonical digonal forms $T_{1}$, $T_{1\\frac{1}{2}}$, $T_{2}$ and $T_{3}$ are considered.\n\n- Four matrix normal distributions are introduced, extending the separable covariance $\\varPhi \\otimes  \\varPsi$ with potentially variable-level ($\\varPsi$) and/or sample-level ($\\varPhi$) correlations. \n\n- The corresponding Wishart distribution, matrix $t$-distribution, matrix $F$-distribution are considered in the finte sample case. Several well-known results, including the non-central Wishart distribution and normal quadratic forms, now appear as corollaries.\n\n- Distributions of the largest and smallest roots in principle component analysis and analysis of variance are calculated, with discussion of future extensions to large sample studies. \n\n[arXiv](https://arxiv.org/a/wang_h_18.html).\n\n2025/10/31, 10:00 a.m., [Tencent Meeting]()\n\nQian Jin (ECNU) Reviewer: Song Shichang (BJTU)\n\n**Continuous model theory and local geometry of Banach space**\n\nIn this talk, I will talk about model theoretic properties of finite representability and super-weak compactness of bounded convex metric spaces, and give a model theoretic proof of a result by Xiaoling Chen and Lixin Cheng on Kuratowski measure of noncompactness.\n\nPreprint.\n\n2025/11/14, 10:00 a.m., [Tencent Meeting]()\n\n[Liu Han](https://www.simis.cn/zh_cn/han-liu/) (Fudan) Reviewer: Liu Weihua (ZJU)\n\n**Asymptotic property C for certain wreath-like products of groups** \n\nIn this paper, we present generalizations of some results on the asymptotic property C for wreath products. Specifically, we prove that certain wreath-like products admit asymptotic property C, thus providing some new examples for further studies.\n\n[Article](https://arxiv.org/abs/2505.01268) *To appear in Journal of Noncommutative Geometry*.\n\n2025/11/28, 10:00 a.m., [Tencent Meeting]()\n\nZhu Yue (CAS) Reviewer: Yang Fan* (Tsinghua) *male\n\n**The free probability approach to random matrices**\n\nThis report offers an introduction to the powerful framework of free probability and its profound applications in random matrix theory. We will explore how the classical limit theorems, such as Wigner's semicircle law, find their natural explanation within this framework. The core concept of freeness - a non-commutative analogue of independence - will be introduced to explain the asymptotic behavior of large-dimensional random matrices. We will demonstrate how key tools like the R-transform and S-transform allow for the computation of limiting spectral distributions of sums and products of independent matrices through the operations of free additive and multiplicative convolution. This overview aims to illustrate why free probability has become the indispensable language for modern random matrix analysis.\n\n2025/12/05, 10:00 p.m., [Tencent Meeting]()\n\n[Yu Tingzhou](https://sites.google.com/view/tingzhou-yu/home) (Alberta) Reviewer: Liu Weihua (ZJU)\n\n**The circular law of random combination matrices** \n\nThis presentation will discuss recent findings on the spectral characteristics of $n\\times n$ random combinatorial matrices $M_n$, where each row is chosen independently and uniformly from the set of binary vectors containing exactly $d$ ones. Our research addresses two fundamental aspects of these matrices: the behavior of their smallest singular value and their limiting empirical spectral distribution (ESD).\n \nFirstly,  we establish the circular law for $M_n$ under specific sparsity conditions. For $\\log^2 n\\le d\\le n/2$, we show that the ESD of an appropriately normalized version of $M_n$ converges in probability to the uniform distribution on the unit disk in the complex plane. A crucial ingredient in this proof involves deriving quantitative lower tail bounds for the smallest singular value of the shifted matrices $M_n-zI_n$.\n \nSecondly, we investigate the smallest singular value $s_n(M_n)$ in the dense regime, where $d=pn$ for a fixed constant $p\\in (0, 1/2]$. We establish a probabilistic upper bound for $s_n(M_n)$. This result complements existing lower bounds of the order $\\Omega(n^{-1/2})$ and confirms that $s_n(M_n)$ is typically of the order $n^{-1/2}$ in this dense setting. These results are joint work with Dongbin Li and Alexander Litvak.\n\n\n2025/12/19, 10:00 p.m., [Tencent Meeting]()\n\n[Zhang Yilong](https://yl-zh.github.io/) (Bonn) Reviewer: Will Johnson (Fudan)\n\n**Hrushovski construction in ordered fields**\n\nThe Hrushovski construction is a variant of amalgamation methods. It was invented to construct new examples of strongly minimal theories. The method was later adapted to expansions of fields, including colored fields and powered fields. In this talk, I will present my attempt to apply the Hrushovski construction to ordered fields. I will construct an expansion of RCF by a dense multiplicative subgroup (green points). The construction induces a back-and-forth system, enabling us to study the dp-rank and the open core of this structure. I will also introduce my recent progress on powered fields, an expansion of RCF by \"power functions\" on the unit circle, and my plan to axiomatize expansions of the real field using the Hrushovski construction.\n\n[ArXiv](https://arxiv.org/abs/2501.01176).\n\n2026/01/02, 10:00 a.m., [Tencent Meeting]()\n\n[Wang Leda](https://futwangalerda.github.io/) (Yale) Reviewer: Chen Zaoli (USTC)\n\n**Approximate message passing algorithms for rotaionally invariant matrices**\n\nApproximate Message Passing (AMP) algorithms have seen widespread use across a variety of applications. However, the precise forms for their Onsager corrections and state evolutions depend on properties of the underlying random matrix ensemble, limiting the extent to which AMP algorithms derived for white noise may be applicable to data matrices that arise in practice. In this work, we study more general AMP algorithms for random matrices W that satisfy orthogonal rotational invariance in law, where W may have a spectral distribution that is different from the semicircle and Marcenko-Pastur laws characteristic of white noise. The Onsager corrections and state evolutions in these algorithms are defined by the free cumulants or rectangular free cumulants\nof the spectral distribution of W. Their forms were derived previously by Opper, Cakmak, and Winther using non-rigorous dynamic functional theory techniques, and we provide rigorous proofs.\n\nReferences:\n\n[1] Fan Zhou. Approximate Message Passing algorithms for rotationally invariant matrices. Ann. Stat. 50. (2022). \n\n2026/01/16, 10:00 a.m., [Tencent Meeting]()\n\n[Zou Guangyi](https://zouguangyi.wordpress.com/) (USTC) Reviewer: Chen Zaoli (USTC)\n\n**Edge statistics of random band matrices**\n\nRandom band matrices are interpolation models between Wigner matrices and random Schr\\\"odinger operators. When the bandwidth changes at different rates relative to the system size, the eigenvalues of band matrices exhibit two distinct behaviors: Wigner matrix eigenvalue statistics and Poisson eigenvalue statistics.\n\nIn this talk, we consider the edge statistics of band matrices and discuss the mechanism behind the transition between Wigner statistics and Poisson statistics of eigenvalues. Our discussion involves a type of Feynman diagram expansion and Feynman integral estimates. This discussion is based on collaborative work with Professor Dang-Zheng Liu (USTC), arxiv:2401.00492.\n\n带状矩阵的边界谱分布\n\n随机带状矩阵是 Wigner 矩阵和随机薛定谔算子之间的插值模型。当带宽相对系统大小以不同速率变化，带状矩阵的特征值会出现两种不同行为：Wigner 矩阵特征值统计和 Poisson 特征值统计。\n\n本次报告我们考虑带状矩阵的边缘谱分布特征值 Wigner 统计 / Poisson 统计转变背后的机制。我们的讨论会涉及到一类 Feynamn 图展开和 Feynman 积分估计。这次讨论基于我和刘党政教授（USTC）的合作工作 arxiv:2401.00492\n\n\n<div class=\"pagination\">\n  <a class=\"previous\" href=\"/seminar/index\">Previous Page</a>\n</div>\n","source":"seminar/Continuous Logic and Free Probability.md","raw":"---\ntitle: Continuous Logic and Free Probability\nlayout: semiar\ndate: 2024-01-30 20:52:41\nsticky: 100\ntop: true\nmathjax: true\npagination: true\nper_page: 10\n---\n\nThis webpage is about the 2025 seminar on *Continuous Logic and Free Probability*. There are *TEN* lecturers from diverse universities to give related talks. Titles and abstracts are updated on this webpage.\n\n## Summary\n\n2025/09/19, 10:00 a.m., [Tencent Meeting](https://meeting.tencent.com/crm/2aZ5RQd890)\n\nHu Yuqi (UC Irvine) Reviewer: Wang Wei (SYSU)\n\n**Basic continuous model theory**\n\nI will discuss continuous logic and show how it can be used to extend Voiculescu's free entropy of microstates to model-theoretic types. I will also present some results and open problems related to the analogy between microstates and types.\n\n在本报告中，我将探讨连续逻辑，并展示如何利用它将 Voiculescu 的自由微态熵推广至模型论类型。此外，我将介绍关于微态与类型类比方面的现有研究成果和未解之谜。\n\nReferences:\n\n[1] Isaac Goldbring (Ed.) Model Theory of Operator Algebras.\n\n*Dr. Hu discusses the basic concepts of continuous logic and free probability theory and their applications in model theory, with particular attention to concepts such as ultra-filters, metric spaces, uniformly continuous functions, and operator algebras, as well as their potential applications in probability theory and logic. -- Wang Wei*\n\n2025/10/03, 10:00 a.m., [Tencent Meeting]()\n\nLi Xiangchao (USTC) Reviewer: Xu Yuanyuan (CAS)\n\n**Central limit theorem for mesoscopic eigenvalue statistics of the free sum of matrices**\n\nThis paper studies the central limit theorem (CLT) for mesoscopic eigenvalue statistics of the free sum of random matrices. Consider matrices of the form:\n$$H_N = A_N + U_N B_N U_N^*,$$\nwhere $A_N, B_N$ are deterministic Hermitian matrices, and $U_N$ is a Haar-distributed random unitary (or orthogonal) matrix. The focus is on linear eigenvalue statistics:\n$$\\sum_{i=1}^N g\\left(\\frac{\\lambda_i - E}{\\eta}\\right) - \\mathbb{E}\\sum_{i=1}^N g\\left(\\frac{\\lambda_i - E}{\\eta}\\right)$$\nwithin the mesoscopic regime $N^{-1} \\ll \\eta \\ll 1$ in the regular bulk of the spectrum. The main result establishes convergence to a centered Gaussian random variable with variance:\n$$\\frac{1}{2\\beta\\pi^2} \\int_{\\mathbb{R}}\\int_{\\mathbb{R}} \\frac{(g(x_1) - g(x_2))^2}{(x_1 - x_2)^2} dx_1 dx_2 = \\frac{1}{\\beta\\pi} \\int_{\\mathbb{R}} |\\xi||\\hat{g}(\\xi)|^2 d\\xi,\n$$\nwhere $\\beta = 2$ (unitary case) or $\\beta = 1$ (orthogonal case). The proof uses:\n\n- Characteristic function analysis of linear statistics.\n\n- Ward identities from Haar measure invariance.\n\n- Local laws for resolvents, e.g., $|G_{ij}(z) - \\frac{1}{a_i - \\omega_B(z)}\\delta_{ij}| \\prec \\frac{1}{\\sqrt{N|\\eta|}}$.\n\n- Analytic subordination properties of free additive convolution:\n$$F_{\\mu_A}(\\omega_B(z)) = F_{\\mu_B}(\\omega_A(z)), \\quad F_\\mu(z) = -1/m_\\mu(z).$$\nExtensions include:\n\n- Orthogonal conjugation case ($H_N = A + OBO^T$).\n\n- Edge behavior with modified variance and bias terms. \n\nThis work connects to universality in random matrix theory and free probability, providing a unified framework for mesoscopic fluctuations.\n\n2025/10/17, 10:00 a.m., [Tencent Meeting]()\n\n[Wang Haoming](https://blueairm.github.io/) (SYSU) Reviewer: Koki Shimizu (TUS)\n\n**Simultaneous diagonalisable adjoint operators: A finite sample study**\n\nThis work is based on the proper orthogonal decomposition or Karhunen-Lo\\'eve theorem for stochastic processes. Four canonical digonal forms $T_{1}$, $T_{1\\frac{1}{2}}$, $T_{2}$ and $T_{3}$ are considered.\n\n- Four matrix normal distributions are introduced, extending the separable covariance $\\varPhi \\otimes  \\varPsi$ with potentially variable-level ($\\varPsi$) and/or sample-level ($\\varPhi$) correlations. \n\n- The corresponding Wishart distribution, matrix $t$-distribution, matrix $F$-distribution are considered in the finte sample case. Several well-known results, including the non-central Wishart distribution and normal quadratic forms, now appear as corollaries.\n\n- Distributions of the largest and smallest roots in principle component analysis and analysis of variance are calculated, with discussion of future extensions to large sample studies. \n\n[arXiv](https://arxiv.org/a/wang_h_18.html).\n\n2025/10/31, 10:00 a.m., [Tencent Meeting]()\n\nQian Jin (ECNU) Reviewer: Song Shichang (BJTU)\n\n**Continuous model theory and local geometry of Banach space**\n\nIn this talk, I will talk about model theoretic properties of finite representability and super-weak compactness of bounded convex metric spaces, and give a model theoretic proof of a result by Xiaoling Chen and Lixin Cheng on Kuratowski measure of noncompactness.\n\nPreprint.\n\n2025/11/14, 10:00 a.m., [Tencent Meeting]()\n\n[Liu Han](https://www.simis.cn/zh_cn/han-liu/) (Fudan) Reviewer: Liu Weihua (ZJU)\n\n**Asymptotic property C for certain wreath-like products of groups** \n\nIn this paper, we present generalizations of some results on the asymptotic property C for wreath products. Specifically, we prove that certain wreath-like products admit asymptotic property C, thus providing some new examples for further studies.\n\n[Article](https://arxiv.org/abs/2505.01268) *To appear in Journal of Noncommutative Geometry*.\n\n2025/11/28, 10:00 a.m., [Tencent Meeting]()\n\nZhu Yue (CAS) Reviewer: Yang Fan* (Tsinghua) *male\n\n**The free probability approach to random matrices**\n\nThis report offers an introduction to the powerful framework of free probability and its profound applications in random matrix theory. We will explore how the classical limit theorems, such as Wigner's semicircle law, find their natural explanation within this framework. The core concept of freeness - a non-commutative analogue of independence - will be introduced to explain the asymptotic behavior of large-dimensional random matrices. We will demonstrate how key tools like the R-transform and S-transform allow for the computation of limiting spectral distributions of sums and products of independent matrices through the operations of free additive and multiplicative convolution. This overview aims to illustrate why free probability has become the indispensable language for modern random matrix analysis.\n\n2025/12/05, 10:00 p.m., [Tencent Meeting]()\n\n[Yu Tingzhou](https://sites.google.com/view/tingzhou-yu/home) (Alberta) Reviewer: Liu Weihua (ZJU)\n\n**The circular law of random combination matrices** \n\nThis presentation will discuss recent findings on the spectral characteristics of $n\\times n$ random combinatorial matrices $M_n$, where each row is chosen independently and uniformly from the set of binary vectors containing exactly $d$ ones. Our research addresses two fundamental aspects of these matrices: the behavior of their smallest singular value and their limiting empirical spectral distribution (ESD).\n \nFirstly,  we establish the circular law for $M_n$ under specific sparsity conditions. For $\\log^2 n\\le d\\le n/2$, we show that the ESD of an appropriately normalized version of $M_n$ converges in probability to the uniform distribution on the unit disk in the complex plane. A crucial ingredient in this proof involves deriving quantitative lower tail bounds for the smallest singular value of the shifted matrices $M_n-zI_n$.\n \nSecondly, we investigate the smallest singular value $s_n(M_n)$ in the dense regime, where $d=pn$ for a fixed constant $p\\in (0, 1/2]$. We establish a probabilistic upper bound for $s_n(M_n)$. This result complements existing lower bounds of the order $\\Omega(n^{-1/2})$ and confirms that $s_n(M_n)$ is typically of the order $n^{-1/2}$ in this dense setting. These results are joint work with Dongbin Li and Alexander Litvak.\n\n\n2025/12/19, 10:00 p.m., [Tencent Meeting]()\n\n[Zhang Yilong](https://yl-zh.github.io/) (Bonn) Reviewer: Will Johnson (Fudan)\n\n**Hrushovski construction in ordered fields**\n\nThe Hrushovski construction is a variant of amalgamation methods. It was invented to construct new examples of strongly minimal theories. The method was later adapted to expansions of fields, including colored fields and powered fields. In this talk, I will present my attempt to apply the Hrushovski construction to ordered fields. I will construct an expansion of RCF by a dense multiplicative subgroup (green points). The construction induces a back-and-forth system, enabling us to study the dp-rank and the open core of this structure. I will also introduce my recent progress on powered fields, an expansion of RCF by \"power functions\" on the unit circle, and my plan to axiomatize expansions of the real field using the Hrushovski construction.\n\n[ArXiv](https://arxiv.org/abs/2501.01176).\n\n2026/01/02, 10:00 a.m., [Tencent Meeting]()\n\n[Wang Leda](https://futwangalerda.github.io/) (Yale) Reviewer: Chen Zaoli (USTC)\n\n**Approximate message passing algorithms for rotaionally invariant matrices**\n\nApproximate Message Passing (AMP) algorithms have seen widespread use across a variety of applications. However, the precise forms for their Onsager corrections and state evolutions depend on properties of the underlying random matrix ensemble, limiting the extent to which AMP algorithms derived for white noise may be applicable to data matrices that arise in practice. In this work, we study more general AMP algorithms for random matrices W that satisfy orthogonal rotational invariance in law, where W may have a spectral distribution that is different from the semicircle and Marcenko-Pastur laws characteristic of white noise. The Onsager corrections and state evolutions in these algorithms are defined by the free cumulants or rectangular free cumulants\nof the spectral distribution of W. Their forms were derived previously by Opper, Cakmak, and Winther using non-rigorous dynamic functional theory techniques, and we provide rigorous proofs.\n\nReferences:\n\n[1] Fan Zhou. Approximate Message Passing algorithms for rotationally invariant matrices. Ann. Stat. 50. (2022). \n\n2026/01/16, 10:00 a.m., [Tencent Meeting]()\n\n[Zou Guangyi](https://zouguangyi.wordpress.com/) (USTC) Reviewer: Chen Zaoli (USTC)\n\n**Edge statistics of random band matrices**\n\nRandom band matrices are interpolation models between Wigner matrices and random Schr\\\"odinger operators. When the bandwidth changes at different rates relative to the system size, the eigenvalues of band matrices exhibit two distinct behaviors: Wigner matrix eigenvalue statistics and Poisson eigenvalue statistics.\n\nIn this talk, we consider the edge statistics of band matrices and discuss the mechanism behind the transition between Wigner statistics and Poisson statistics of eigenvalues. Our discussion involves a type of Feynman diagram expansion and Feynman integral estimates. This discussion is based on collaborative work with Professor Dang-Zheng Liu (USTC), arxiv:2401.00492.\n\n带状矩阵的边界谱分布\n\n随机带状矩阵是 Wigner 矩阵和随机薛定谔算子之间的插值模型。当带宽相对系统大小以不同速率变化，带状矩阵的特征值会出现两种不同行为：Wigner 矩阵特征值统计和 Poisson 特征值统计。\n\n本次报告我们考虑带状矩阵的边缘谱分布特征值 Wigner 统计 / Poisson 统计转变背后的机制。我们的讨论会涉及到一类 Feynamn 图展开和 Feynman 积分估计。这次讨论基于我和刘党政教授（USTC）的合作工作 arxiv:2401.00492\n\n\n<div class=\"pagination\">\n  <a class=\"previous\" href=\"/seminar/index\">Previous Page</a>\n</div>\n","updated":"2025-09-19T03:19:32.111Z","path":"seminar/Continuous Logic and Free Probability.html","comments":1,"_id":"cmfwcr5ru000fm8nxe7lu34tx","content":"<p>This webpage is about the 2025 seminar on <em>Continuous Logic and\r\nFree Probability</em>. There are <em>TEN</em> lecturers from diverse\r\nuniversities to give related talks. Titles and abstracts are updated on\r\nthis webpage.</p>\r\n<h2 id=\"summary\">Summary</h2>\r\n<p>2025/09/19, 10:00 a.m., <a href=\"https://meeting.tencent.com/crm/2aZ5RQd890\">Tencent\r\nMeeting</a></p>\r\n<p>Hu Yuqi (UC Irvine) Reviewer: Wang Wei (SYSU)</p>\r\n<p><strong>Basic continuous model theory</strong></p>\r\n<p>I will discuss continuous logic and show how it can be used to extend\r\nVoiculescu's free entropy of microstates to model-theoretic types. I\r\nwill also present some results and open problems related to the analogy\r\nbetween microstates and types.</p>\r\n<p>在本报告中，我将探讨连续逻辑，并展示如何利用它将 Voiculescu\r\n的自由微态熵推广至模型论类型。此外，我将介绍关于微态与类型类比方面的现有研究成果和未解之谜。</p>\r\n<p>References:</p>\r\n<p>[1] Isaac Goldbring (Ed.) Model Theory of Operator Algebras.</p>\r\n<p><em>Dr. Hu discusses the basic concepts of continuous logic and free\r\nprobability theory and their applications in model theory, with\r\nparticular attention to concepts such as ultra-filters, metric spaces,\r\nuniformly continuous functions, and operator algebras, as well as their\r\npotential applications in probability theory and logic. -- Wang\r\nWei</em></p>\r\n<p>2025/10/03, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Li Xiangchao (USTC) Reviewer: Xu Yuanyuan (CAS)</p>\r\n<p><strong>Central limit theorem for mesoscopic eigenvalue statistics of\r\nthe free sum of matrices</strong></p>\r\n<p>This paper studies the central limit theorem (CLT) for mesoscopic\r\neigenvalue statistics of the free sum of random matrices. Consider\r\nmatrices of the form: <span class=\"math display\">\\[H_N = A_N + U_N B_N\r\nU_N^*,\\]</span> where <span class=\"math inline\">\\(A_N, B_N\\)</span> are\r\ndeterministic Hermitian matrices, and <span class=\"math inline\">\\(U_N\\)</span> is a Haar-distributed random unitary\r\n(or orthogonal) matrix. The focus is on linear eigenvalue statistics:\r\n<span class=\"math display\">\\[\\sum_{i=1}^N g\\left(\\frac{\\lambda_i -\r\nE}{\\eta}\\right) - \\mathbb{E}\\sum_{i=1}^N g\\left(\\frac{\\lambda_i -\r\nE}{\\eta}\\right)\\]</span> within the mesoscopic regime <span class=\"math inline\">\\(N^{-1} \\ll \\eta \\ll 1\\)</span> in the regular bulk\r\nof the spectrum. The main result establishes convergence to a centered\r\nGaussian random variable with variance: <span class=\"math display\">\\[\\frac{1}{2\\beta\\pi^2}\r\n\\int_{\\mathbb{R}}\\int_{\\mathbb{R}} \\frac{(g(x_1) - g(x_2))^2}{(x_1 -\r\nx_2)^2} dx_1 dx_2 = \\frac{1}{\\beta\\pi} \\int_{\\mathbb{R}}\r\n|\\xi||\\hat{g}(\\xi)|^2 d\\xi,\r\n\\]</span> where <span class=\"math inline\">\\(\\beta = 2\\)</span> (unitary\r\ncase) or <span class=\"math inline\">\\(\\beta = 1\\)</span> (orthogonal\r\ncase). The proof uses:</p>\r\n<ul>\r\n<li><p>Characteristic function analysis of linear statistics.</p></li>\r\n<li><p>Ward identities from Haar measure invariance.</p></li>\r\n<li><p>Local laws for resolvents, e.g., <span class=\"math inline\">\\(|G_{ij}(z) - \\frac{1}{a_i -\r\n\\omega_B(z)}\\delta_{ij}| \\prec\r\n\\frac{1}{\\sqrt{N|\\eta|}}\\)</span>.</p></li>\r\n<li><p>Analytic subordination properties of free additive convolution:\r\n<span class=\"math display\">\\[F_{\\mu_A}(\\omega_B(z)) =\r\nF_{\\mu_B}(\\omega_A(z)), \\quad F_\\mu(z) = -1/m_\\mu(z).\\]</span>\r\nExtensions include:</p></li>\r\n<li><p>Orthogonal conjugation case (<span class=\"math inline\">\\(H_N = A\r\n+ OBO^T\\)</span>).</p></li>\r\n<li><p>Edge behavior with modified variance and bias terms.</p></li>\r\n</ul>\r\n<p>This work connects to universality in random matrix theory and free\r\nprobability, providing a unified framework for mesoscopic\r\nfluctuations.</p>\r\n<p>2025/10/17, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p><a href=\"https://blueairm.github.io/\">Wang Haoming</a> (SYSU)\r\nReviewer: Koki Shimizu (TUS)</p>\r\n<p><strong>Simultaneous diagonalisable adjoint operators: A finite\r\nsample study</strong></p>\r\n<p>This work is based on the proper orthogonal decomposition or\r\nKarhunen-Lo'eve theorem for stochastic processes. Four canonical digonal\r\nforms <span class=\"math inline\">\\(T_{1}\\)</span>, <span class=\"math inline\">\\(T_{1\\frac{1}{2}}\\)</span>, <span class=\"math inline\">\\(T_{2}\\)</span> and <span class=\"math inline\">\\(T_{3}\\)</span> are considered.</p>\r\n<ul>\r\n<li><p>Four matrix normal distributions are introduced, extending the\r\nseparable covariance <span class=\"math inline\">\\(\\varPhi\r\n\\otimes  \\varPsi\\)</span> with potentially variable-level (<span class=\"math inline\">\\(\\varPsi\\)</span>) and/or sample-level (<span class=\"math inline\">\\(\\varPhi\\)</span>) correlations.</p></li>\r\n<li><p>The corresponding Wishart distribution, matrix <span class=\"math inline\">\\(t\\)</span>-distribution, matrix <span class=\"math inline\">\\(F\\)</span>-distribution are considered in the\r\nfinte sample case. Several well-known results, including the non-central\r\nWishart distribution and normal quadratic forms, now appear as\r\ncorollaries.</p></li>\r\n<li><p>Distributions of the largest and smallest roots in principle\r\ncomponent analysis and analysis of variance are calculated, with\r\ndiscussion of future extensions to large sample studies.</p></li>\r\n</ul>\r\n<p><a href=\"https://arxiv.org/a/wang_h_18.html\">arXiv</a>.</p>\r\n<p>2025/10/31, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Qian Jin (ECNU) Reviewer: Song Shichang (BJTU)</p>\r\n<p><strong>Continuous model theory and local geometry of Banach\r\nspace</strong></p>\r\n<p>In this talk, I will talk about model theoretic properties of finite\r\nrepresentability and super-weak compactness of bounded convex metric\r\nspaces, and give a model theoretic proof of a result by Xiaoling Chen\r\nand Lixin Cheng on Kuratowski measure of noncompactness.</p>\r\n<p>Preprint.</p>\r\n<p>2025/11/14, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p><a href=\"https://www.simis.cn/zh_cn/han-liu/\">Liu Han</a> (Fudan)\r\nReviewer: Liu Weihua (ZJU)</p>\r\n<p><strong>Asymptotic property C for certain wreath-like products of\r\ngroups</strong></p>\r\n<p>In this paper, we present generalizations of some results on the\r\nasymptotic property C for wreath products. Specifically, we prove that\r\ncertain wreath-like products admit asymptotic property C, thus providing\r\nsome new examples for further studies.</p>\r\n<p><a href=\"https://arxiv.org/abs/2505.01268\">Article</a> <em>To appear\r\nin Journal of Noncommutative Geometry</em>.</p>\r\n<p>2025/11/28, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Zhu Yue (CAS) Reviewer: Yang Fan* (Tsinghua) *male</p>\r\n<p><strong>The free probability approach to random matrices</strong></p>\r\n<p>This report offers an introduction to the powerful framework of free\r\nprobability and its profound applications in random matrix theory. We\r\nwill explore how the classical limit theorems, such as Wigner's\r\nsemicircle law, find their natural explanation within this framework.\r\nThe core concept of freeness - a non-commutative analogue of\r\nindependence - will be introduced to explain the asymptotic behavior of\r\nlarge-dimensional random matrices. We will demonstrate how key tools\r\nlike the R-transform and S-transform allow for the computation of\r\nlimiting spectral distributions of sums and products of independent\r\nmatrices through the operations of free additive and multiplicative\r\nconvolution. This overview aims to illustrate why free probability has\r\nbecome the indispensable language for modern random matrix analysis.</p>\r\n<p>2025/12/05, 10:00 p.m., <a href>Tencent Meeting</a></p>\r\n<p><a href=\"https://sites.google.com/view/tingzhou-yu/home\">Yu\r\nTingzhou</a> (Alberta) Reviewer: Liu Weihua (ZJU)</p>\r\n<p><strong>The circular law of random combination matrices</strong></p>\r\n<p>This presentation will discuss recent findings on the spectral\r\ncharacteristics of <span class=\"math inline\">\\(n\\times n\\)</span> random\r\ncombinatorial matrices <span class=\"math inline\">\\(M_n\\)</span>, where\r\neach row is chosen independently and uniformly from the set of binary\r\nvectors containing exactly <span class=\"math inline\">\\(d\\)</span> ones.\r\nOur research addresses two fundamental aspects of these matrices: the\r\nbehavior of their smallest singular value and their limiting empirical\r\nspectral distribution (ESD).</p>\r\n<p>Firstly, we establish the circular law for <span class=\"math inline\">\\(M_n\\)</span> under specific sparsity conditions.\r\nFor <span class=\"math inline\">\\(\\log^2 n\\le d\\le n/2\\)</span>, we show\r\nthat the ESD of an appropriately normalized version of <span class=\"math inline\">\\(M_n\\)</span> converges in probability to the\r\nuniform distribution on the unit disk in the complex plane. A crucial\r\ningredient in this proof involves deriving quantitative lower tail\r\nbounds for the smallest singular value of the shifted matrices <span class=\"math inline\">\\(M_n-zI_n\\)</span>.</p>\r\n<p>Secondly, we investigate the smallest singular value <span class=\"math inline\">\\(s_n(M_n)\\)</span> in the dense regime, where <span class=\"math inline\">\\(d=pn\\)</span> for a fixed constant <span class=\"math inline\">\\(p\\in (0, 1/2]\\)</span>. We establish a\r\nprobabilistic upper bound for <span class=\"math inline\">\\(s_n(M_n)\\)</span>. This result complements\r\nexisting lower bounds of the order <span class=\"math inline\">\\(\\Omega(n^{-1/2})\\)</span> and confirms that <span class=\"math inline\">\\(s_n(M_n)\\)</span> is typically of the order <span class=\"math inline\">\\(n^{-1/2}\\)</span> in this dense setting. These\r\nresults are joint work with Dongbin Li and Alexander Litvak.</p>\r\n<p>2025/12/19, 10:00 p.m., <a href>Tencent Meeting</a></p>\r\n<p><a href=\"https://yl-zh.github.io/\">Zhang Yilong</a> (Bonn) Reviewer:\r\nWill Johnson (Fudan)</p>\r\n<p><strong>Hrushovski construction in ordered fields</strong></p>\r\n<p>The Hrushovski construction is a variant of amalgamation methods. It\r\nwas invented to construct new examples of strongly minimal theories. The\r\nmethod was later adapted to expansions of fields, including colored\r\nfields and powered fields. In this talk, I will present my attempt to\r\napply the Hrushovski construction to ordered fields. I will construct an\r\nexpansion of RCF by a dense multiplicative subgroup (green points). The\r\nconstruction induces a back-and-forth system, enabling us to study the\r\ndp-rank and the open core of this structure. I will also introduce my\r\nrecent progress on powered fields, an expansion of RCF by \"power\r\nfunctions\" on the unit circle, and my plan to axiomatize expansions of\r\nthe real field using the Hrushovski construction.</p>\r\n<p><a href=\"https://arxiv.org/abs/2501.01176\">ArXiv</a>.</p>\r\n<p>2026/01/02, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p><a href=\"https://futwangalerda.github.io/\">Wang Leda</a> (Yale)\r\nReviewer: Chen Zaoli (USTC)</p>\r\n<p><strong>Approximate message passing algorithms for rotaionally\r\ninvariant matrices</strong></p>\r\n<p>Approximate Message Passing (AMP) algorithms have seen widespread use\r\nacross a variety of applications. However, the precise forms for their\r\nOnsager corrections and state evolutions depend on properties of the\r\nunderlying random matrix ensemble, limiting the extent to which AMP\r\nalgorithms derived for white noise may be applicable to data matrices\r\nthat arise in practice. In this work, we study more general AMP\r\nalgorithms for random matrices W that satisfy orthogonal rotational\r\ninvariance in law, where W may have a spectral distribution that is\r\ndifferent from the semicircle and Marcenko-Pastur laws characteristic of\r\nwhite noise. The Onsager corrections and state evolutions in these\r\nalgorithms are defined by the free cumulants or rectangular free\r\ncumulants of the spectral distribution of W. Their forms were derived\r\npreviously by Opper, Cakmak, and Winther using non-rigorous dynamic\r\nfunctional theory techniques, and we provide rigorous proofs.</p>\r\n<p>References:</p>\r\n<p>[1] Fan Zhou. Approximate Message Passing algorithms for rotationally\r\ninvariant matrices. Ann. Stat. 50. (2022).</p>\r\n<p>2026/01/16, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p><a href=\"https://zouguangyi.wordpress.com/\">Zou Guangyi</a> (USTC)\r\nReviewer: Chen Zaoli (USTC)</p>\r\n<p><strong>Edge statistics of random band matrices</strong></p>\r\n<p>Random band matrices are interpolation models between Wigner matrices\r\nand random Schr\"odinger operators. When the bandwidth changes at\r\ndifferent rates relative to the system size, the eigenvalues of band\r\nmatrices exhibit two distinct behaviors: Wigner matrix eigenvalue\r\nstatistics and Poisson eigenvalue statistics.</p>\r\n<p>In this talk, we consider the edge statistics of band matrices and\r\ndiscuss the mechanism behind the transition between Wigner statistics\r\nand Poisson statistics of eigenvalues. Our discussion involves a type of\r\nFeynman diagram expansion and Feynman integral estimates. This\r\ndiscussion is based on collaborative work with Professor Dang-Zheng Liu\r\n(USTC), arxiv:2401.00492.</p>\r\n<p>带状矩阵的边界谱分布</p>\r\n<p>随机带状矩阵是 Wigner\r\n矩阵和随机薛定谔算子之间的插值模型。当带宽相对系统大小以不同速率变化，带状矩阵的特征值会出现两种不同行为：Wigner\r\n矩阵特征值统计和 Poisson 特征值统计。</p>\r\n<p>本次报告我们考虑带状矩阵的边缘谱分布特征值 Wigner 统计 / Poisson\r\n统计转变背后的机制。我们的讨论会涉及到一类 Feynamn 图展开和 Feynman\r\n积分估计。这次讨论基于我和刘党政教授（USTC）的合作工作\r\narxiv:2401.00492</p>\r\n<div class=\"pagination\">\r\n<p><a class=\"previous\" href=\"/seminar/index\">Previous Page</a></p>\r\n</div>\r\n","site":{"data":{}},"excerpt":"","more":"<p>This webpage is about the 2025 seminar on <em>Continuous Logic and\r\nFree Probability</em>. There are <em>TEN</em> lecturers from diverse\r\nuniversities to give related talks. Titles and abstracts are updated on\r\nthis webpage.</p>\r\n<h2 id=\"summary\">Summary</h2>\r\n<p>2025/09/19, 10:00 a.m., <a href=\"https://meeting.tencent.com/crm/2aZ5RQd890\">Tencent\r\nMeeting</a></p>\r\n<p>Hu Yuqi (UC Irvine) Reviewer: Wang Wei (SYSU)</p>\r\n<p><strong>Basic continuous model theory</strong></p>\r\n<p>I will discuss continuous logic and show how it can be used to extend\r\nVoiculescu's free entropy of microstates to model-theoretic types. I\r\nwill also present some results and open problems related to the analogy\r\nbetween microstates and types.</p>\r\n<p>在本报告中，我将探讨连续逻辑，并展示如何利用它将 Voiculescu\r\n的自由微态熵推广至模型论类型。此外，我将介绍关于微态与类型类比方面的现有研究成果和未解之谜。</p>\r\n<p>References:</p>\r\n<p>[1] Isaac Goldbring (Ed.) Model Theory of Operator Algebras.</p>\r\n<p><em>Dr. Hu discusses the basic concepts of continuous logic and free\r\nprobability theory and their applications in model theory, with\r\nparticular attention to concepts such as ultra-filters, metric spaces,\r\nuniformly continuous functions, and operator algebras, as well as their\r\npotential applications in probability theory and logic. -- Wang\r\nWei</em></p>\r\n<p>2025/10/03, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Li Xiangchao (USTC) Reviewer: Xu Yuanyuan (CAS)</p>\r\n<p><strong>Central limit theorem for mesoscopic eigenvalue statistics of\r\nthe free sum of matrices</strong></p>\r\n<p>This paper studies the central limit theorem (CLT) for mesoscopic\r\neigenvalue statistics of the free sum of random matrices. Consider\r\nmatrices of the form: <span class=\"math display\">\\[H_N = A_N + U_N B_N\r\nU_N^*,\\]</span> where <span class=\"math inline\">\\(A_N, B_N\\)</span> are\r\ndeterministic Hermitian matrices, and <span class=\"math inline\">\\(U_N\\)</span> is a Haar-distributed random unitary\r\n(or orthogonal) matrix. The focus is on linear eigenvalue statistics:\r\n<span class=\"math display\">\\[\\sum_{i=1}^N g\\left(\\frac{\\lambda_i -\r\nE}{\\eta}\\right) - \\mathbb{E}\\sum_{i=1}^N g\\left(\\frac{\\lambda_i -\r\nE}{\\eta}\\right)\\]</span> within the mesoscopic regime <span class=\"math inline\">\\(N^{-1} \\ll \\eta \\ll 1\\)</span> in the regular bulk\r\nof the spectrum. The main result establishes convergence to a centered\r\nGaussian random variable with variance: <span class=\"math display\">\\[\\frac{1}{2\\beta\\pi^2}\r\n\\int_{\\mathbb{R}}\\int_{\\mathbb{R}} \\frac{(g(x_1) - g(x_2))^2}{(x_1 -\r\nx_2)^2} dx_1 dx_2 = \\frac{1}{\\beta\\pi} \\int_{\\mathbb{R}}\r\n|\\xi||\\hat{g}(\\xi)|^2 d\\xi,\r\n\\]</span> where <span class=\"math inline\">\\(\\beta = 2\\)</span> (unitary\r\ncase) or <span class=\"math inline\">\\(\\beta = 1\\)</span> (orthogonal\r\ncase). The proof uses:</p>\r\n<ul>\r\n<li><p>Characteristic function analysis of linear statistics.</p></li>\r\n<li><p>Ward identities from Haar measure invariance.</p></li>\r\n<li><p>Local laws for resolvents, e.g., <span class=\"math inline\">\\(|G_{ij}(z) - \\frac{1}{a_i -\r\n\\omega_B(z)}\\delta_{ij}| \\prec\r\n\\frac{1}{\\sqrt{N|\\eta|}}\\)</span>.</p></li>\r\n<li><p>Analytic subordination properties of free additive convolution:\r\n<span class=\"math display\">\\[F_{\\mu_A}(\\omega_B(z)) =\r\nF_{\\mu_B}(\\omega_A(z)), \\quad F_\\mu(z) = -1/m_\\mu(z).\\]</span>\r\nExtensions include:</p></li>\r\n<li><p>Orthogonal conjugation case (<span class=\"math inline\">\\(H_N = A\r\n+ OBO^T\\)</span>).</p></li>\r\n<li><p>Edge behavior with modified variance and bias terms.</p></li>\r\n</ul>\r\n<p>This work connects to universality in random matrix theory and free\r\nprobability, providing a unified framework for mesoscopic\r\nfluctuations.</p>\r\n<p>2025/10/17, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p><a href=\"https://blueairm.github.io/\">Wang Haoming</a> (SYSU)\r\nReviewer: Koki Shimizu (TUS)</p>\r\n<p><strong>Simultaneous diagonalisable adjoint operators: A finite\r\nsample study</strong></p>\r\n<p>This work is based on the proper orthogonal decomposition or\r\nKarhunen-Lo'eve theorem for stochastic processes. Four canonical digonal\r\nforms <span class=\"math inline\">\\(T_{1}\\)</span>, <span class=\"math inline\">\\(T_{1\\frac{1}{2}}\\)</span>, <span class=\"math inline\">\\(T_{2}\\)</span> and <span class=\"math inline\">\\(T_{3}\\)</span> are considered.</p>\r\n<ul>\r\n<li><p>Four matrix normal distributions are introduced, extending the\r\nseparable covariance <span class=\"math inline\">\\(\\varPhi\r\n\\otimes  \\varPsi\\)</span> with potentially variable-level (<span class=\"math inline\">\\(\\varPsi\\)</span>) and/or sample-level (<span class=\"math inline\">\\(\\varPhi\\)</span>) correlations.</p></li>\r\n<li><p>The corresponding Wishart distribution, matrix <span class=\"math inline\">\\(t\\)</span>-distribution, matrix <span class=\"math inline\">\\(F\\)</span>-distribution are considered in the\r\nfinte sample case. Several well-known results, including the non-central\r\nWishart distribution and normal quadratic forms, now appear as\r\ncorollaries.</p></li>\r\n<li><p>Distributions of the largest and smallest roots in principle\r\ncomponent analysis and analysis of variance are calculated, with\r\ndiscussion of future extensions to large sample studies.</p></li>\r\n</ul>\r\n<p><a href=\"https://arxiv.org/a/wang_h_18.html\">arXiv</a>.</p>\r\n<p>2025/10/31, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Qian Jin (ECNU) Reviewer: Song Shichang (BJTU)</p>\r\n<p><strong>Continuous model theory and local geometry of Banach\r\nspace</strong></p>\r\n<p>In this talk, I will talk about model theoretic properties of finite\r\nrepresentability and super-weak compactness of bounded convex metric\r\nspaces, and give a model theoretic proof of a result by Xiaoling Chen\r\nand Lixin Cheng on Kuratowski measure of noncompactness.</p>\r\n<p>Preprint.</p>\r\n<p>2025/11/14, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p><a href=\"https://www.simis.cn/zh_cn/han-liu/\">Liu Han</a> (Fudan)\r\nReviewer: Liu Weihua (ZJU)</p>\r\n<p><strong>Asymptotic property C for certain wreath-like products of\r\ngroups</strong></p>\r\n<p>In this paper, we present generalizations of some results on the\r\nasymptotic property C for wreath products. Specifically, we prove that\r\ncertain wreath-like products admit asymptotic property C, thus providing\r\nsome new examples for further studies.</p>\r\n<p><a href=\"https://arxiv.org/abs/2505.01268\">Article</a> <em>To appear\r\nin Journal of Noncommutative Geometry</em>.</p>\r\n<p>2025/11/28, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Zhu Yue (CAS) Reviewer: Yang Fan* (Tsinghua) *male</p>\r\n<p><strong>The free probability approach to random matrices</strong></p>\r\n<p>This report offers an introduction to the powerful framework of free\r\nprobability and its profound applications in random matrix theory. We\r\nwill explore how the classical limit theorems, such as Wigner's\r\nsemicircle law, find their natural explanation within this framework.\r\nThe core concept of freeness - a non-commutative analogue of\r\nindependence - will be introduced to explain the asymptotic behavior of\r\nlarge-dimensional random matrices. We will demonstrate how key tools\r\nlike the R-transform and S-transform allow for the computation of\r\nlimiting spectral distributions of sums and products of independent\r\nmatrices through the operations of free additive and multiplicative\r\nconvolution. This overview aims to illustrate why free probability has\r\nbecome the indispensable language for modern random matrix analysis.</p>\r\n<p>2025/12/05, 10:00 p.m., <a href>Tencent Meeting</a></p>\r\n<p><a href=\"https://sites.google.com/view/tingzhou-yu/home\">Yu\r\nTingzhou</a> (Alberta) Reviewer: Liu Weihua (ZJU)</p>\r\n<p><strong>The circular law of random combination matrices</strong></p>\r\n<p>This presentation will discuss recent findings on the spectral\r\ncharacteristics of <span class=\"math inline\">\\(n\\times n\\)</span> random\r\ncombinatorial matrices <span class=\"math inline\">\\(M_n\\)</span>, where\r\neach row is chosen independently and uniformly from the set of binary\r\nvectors containing exactly <span class=\"math inline\">\\(d\\)</span> ones.\r\nOur research addresses two fundamental aspects of these matrices: the\r\nbehavior of their smallest singular value and their limiting empirical\r\nspectral distribution (ESD).</p>\r\n<p>Firstly, we establish the circular law for <span class=\"math inline\">\\(M_n\\)</span> under specific sparsity conditions.\r\nFor <span class=\"math inline\">\\(\\log^2 n\\le d\\le n/2\\)</span>, we show\r\nthat the ESD of an appropriately normalized version of <span class=\"math inline\">\\(M_n\\)</span> converges in probability to the\r\nuniform distribution on the unit disk in the complex plane. A crucial\r\ningredient in this proof involves deriving quantitative lower tail\r\nbounds for the smallest singular value of the shifted matrices <span class=\"math inline\">\\(M_n-zI_n\\)</span>.</p>\r\n<p>Secondly, we investigate the smallest singular value <span class=\"math inline\">\\(s_n(M_n)\\)</span> in the dense regime, where <span class=\"math inline\">\\(d=pn\\)</span> for a fixed constant <span class=\"math inline\">\\(p\\in (0, 1/2]\\)</span>. We establish a\r\nprobabilistic upper bound for <span class=\"math inline\">\\(s_n(M_n)\\)</span>. This result complements\r\nexisting lower bounds of the order <span class=\"math inline\">\\(\\Omega(n^{-1/2})\\)</span> and confirms that <span class=\"math inline\">\\(s_n(M_n)\\)</span> is typically of the order <span class=\"math inline\">\\(n^{-1/2}\\)</span> in this dense setting. These\r\nresults are joint work with Dongbin Li and Alexander Litvak.</p>\r\n<p>2025/12/19, 10:00 p.m., <a href>Tencent Meeting</a></p>\r\n<p><a href=\"https://yl-zh.github.io/\">Zhang Yilong</a> (Bonn) Reviewer:\r\nWill Johnson (Fudan)</p>\r\n<p><strong>Hrushovski construction in ordered fields</strong></p>\r\n<p>The Hrushovski construction is a variant of amalgamation methods. It\r\nwas invented to construct new examples of strongly minimal theories. The\r\nmethod was later adapted to expansions of fields, including colored\r\nfields and powered fields. In this talk, I will present my attempt to\r\napply the Hrushovski construction to ordered fields. I will construct an\r\nexpansion of RCF by a dense multiplicative subgroup (green points). The\r\nconstruction induces a back-and-forth system, enabling us to study the\r\ndp-rank and the open core of this structure. I will also introduce my\r\nrecent progress on powered fields, an expansion of RCF by \"power\r\nfunctions\" on the unit circle, and my plan to axiomatize expansions of\r\nthe real field using the Hrushovski construction.</p>\r\n<p><a href=\"https://arxiv.org/abs/2501.01176\">ArXiv</a>.</p>\r\n<p>2026/01/02, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p><a href=\"https://futwangalerda.github.io/\">Wang Leda</a> (Yale)\r\nReviewer: Chen Zaoli (USTC)</p>\r\n<p><strong>Approximate message passing algorithms for rotaionally\r\ninvariant matrices</strong></p>\r\n<p>Approximate Message Passing (AMP) algorithms have seen widespread use\r\nacross a variety of applications. However, the precise forms for their\r\nOnsager corrections and state evolutions depend on properties of the\r\nunderlying random matrix ensemble, limiting the extent to which AMP\r\nalgorithms derived for white noise may be applicable to data matrices\r\nthat arise in practice. In this work, we study more general AMP\r\nalgorithms for random matrices W that satisfy orthogonal rotational\r\ninvariance in law, where W may have a spectral distribution that is\r\ndifferent from the semicircle and Marcenko-Pastur laws characteristic of\r\nwhite noise. The Onsager corrections and state evolutions in these\r\nalgorithms are defined by the free cumulants or rectangular free\r\ncumulants of the spectral distribution of W. Their forms were derived\r\npreviously by Opper, Cakmak, and Winther using non-rigorous dynamic\r\nfunctional theory techniques, and we provide rigorous proofs.</p>\r\n<p>References:</p>\r\n<p>[1] Fan Zhou. Approximate Message Passing algorithms for rotationally\r\ninvariant matrices. Ann. Stat. 50. (2022).</p>\r\n<p>2026/01/16, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p><a href=\"https://zouguangyi.wordpress.com/\">Zou Guangyi</a> (USTC)\r\nReviewer: Chen Zaoli (USTC)</p>\r\n<p><strong>Edge statistics of random band matrices</strong></p>\r\n<p>Random band matrices are interpolation models between Wigner matrices\r\nand random Schr\"odinger operators. When the bandwidth changes at\r\ndifferent rates relative to the system size, the eigenvalues of band\r\nmatrices exhibit two distinct behaviors: Wigner matrix eigenvalue\r\nstatistics and Poisson eigenvalue statistics.</p>\r\n<p>In this talk, we consider the edge statistics of band matrices and\r\ndiscuss the mechanism behind the transition between Wigner statistics\r\nand Poisson statistics of eigenvalues. Our discussion involves a type of\r\nFeynman diagram expansion and Feynman integral estimates. This\r\ndiscussion is based on collaborative work with Professor Dang-Zheng Liu\r\n(USTC), arxiv:2401.00492.</p>\r\n<p>带状矩阵的边界谱分布</p>\r\n<p>随机带状矩阵是 Wigner\r\n矩阵和随机薛定谔算子之间的插值模型。当带宽相对系统大小以不同速率变化，带状矩阵的特征值会出现两种不同行为：Wigner\r\n矩阵特征值统计和 Poisson 特征值统计。</p>\r\n<p>本次报告我们考虑带状矩阵的边缘谱分布特征值 Wigner 统计 / Poisson\r\n统计转变背后的机制。我们的讨论会涉及到一类 Feynamn 图展开和 Feynman\r\n积分估计。这次讨论基于我和刘党政教授（USTC）的合作工作\r\narxiv:2401.00492</p>\r\n<div class=\"pagination\">\r\n<p><a class=\"previous\" href=\"/seminar/index\">Previous Page</a></p>\r\n</div>\r\n"},{"title":"Seminar","layout":"semiars","date":"2024-01-30T12:52:41.000Z","sticky":100,"top":true,"mathjax":true,"pagination":true,"per_page":10,"_content":"\n\n# NWU Set Theory Seminar (From 2024 January)\n\n\n\nHello~ Welcome to the Set Theory Seminar at Northwest Univeristy!🎉🎉🎉\n\nThis is a regularly held up seminar organized by graduates from 2014, Mathematics and Applied Mathematics at the School of Mathematics, Northwest University. We invite you to join us for discussions, presentations, and auditions.\n\nFor subscription, please send an email including your resume to any organizer below. For instance, you can send it to one of the organizer [wanghm37@mail2.sysu.edu.cn](wanghm37@mail2.sysu.edu.cn). Once we have reviewed your resume, we will send you an email one day before, containing the title, abstract, and Tencent Meeting link for the upcoming event.\n\nOur discussions typically take place on Fridays, once every one to two weeks. The inaugural session is scheduled for February 2, 2024, from 1:00 p.m. to 3:00 p.m (Beijing Time). You can find updated information on titles and abstracts on [Seminar](https://blueairm.github.io/seminar/).\n\nIf you have any question or need help, feel free to ask!\n\n# News (Updated on 2025/06/16)\n\nWe are intended to organise an online seminar on *Continuous Logic and Free Probability*. Schedules and summaries are listed in [2025Special](/seminar/Continuous Logic and Free Probability). Please feel free to joint us. Related information will be updated on this website.\n\n\n## Organizers\n\n[Cao Zilong](https://scholar.google.com/citations?user=cago5xUAAAAJ&hl=zh-CN) *(Mathematical Statistics)*\n\nPhD, School of Mathematics, Northwest University\n\nEmail: [nwu_czl@stumail.nwu.edu.cn](nwu_czl@stumail.nwu.edu.cn) \n\n[Mu Miaomiao](https://nichole2023.github.io/) *(Number Theory, Algebraic Geometry)* *Female\n\nPhD, School of Mathematical Sciences, University of Science and Technology of China\n\nEmail: [mumm@mail.ustc.edu.cn](mumm@mail.ustc.edu.cn)\n\nQian Jingxu, *(Mathematical Physics)*\n\nGraduate, Department of Physics, National University of Defense Technology\n\nEmail: [qian_jingxu@alumni.nudt.edu.cn](qian_jingxu@alumni.nudt.edu.cn)\n\n[Shao Kerun](https://www.researchgate.net/profile/Kerun-Shao) *(Analysis, Partial Differential Equations)*\n\nEmail: [12335003@zju.edu.cn](12335003@zju.edu.cn)\n\nPhD, School of Mathematical Sciences, Zhejiang University\n\n[Sheng Xi](https://www.researchgate.net/profile/Xi-Sheng-3) *(Analysis, Topology, Dynamic Systems)*\n\nPhD, School of Mathematical Sciences, University of Science and Technology of China\n\nEmail: [sunx@mail.ustc.edu.cn](sunx@mail.ustc.edu.cn)\n\n[Wang Haoming](https://blueairm.github.io/) *(Combinatorics, Probability, Statistics)*\n\nPhD, School of Mathematics, Sun Yat-sen University\n\nEmail: [wanghm37@mail2.sysu.edu.cn](wanghm37@mail2.sysu.edu.cn)\n\nXue Xiaolong *(Topology, Differential Geometry)*\n\nPhD, Department of Mathematical Sciences, Tsinghua University\n\nEmail: [xxl19@mails.tsinghua.edu.cn](xxl19@mails.tsinghua.edu.cn)\n\n[Yang Yixuan](https://yxuanar.github.io/) *(Theoretical Computer Science, Mathematical Logic)*\n\nPhD, Department of Computer Science and Engineering, South University of Science and Technology of China \\& Department of Computer Science, Warwick University\n\nEmail: [nakeryang@gmail.com](nakeryang@gmail.com)\n\n\n## Upcoming Events\n\n2025/09/26, 10:00 a.m., [Tencent Meeting]()\n\nLin Zhuowei (Nankai University, Center for Combinatorics)\n\n**The Combinatorics of Flagged Weyl Characters**\n\nIn this talk, we introduce two aspects of flagged Weyl charcters, which can be restricted to Schubert polynomials. One is about coefficient-wise upper bounds and lower bounds of flagged Weyl charcters. This settles two conjectures proposed by Mészáros-St. Dizier-Tanjaya. The other one is about the principal specialization of Schubert polynomials, which improves the results previously obtained by Weigandt, Gao, and Mészáros-St. Dizier-Tanjaya.\n\n[Article1](https://doi.org/10.1016/j.aam.2024.102752), [Article2](https://doi.org/10.4153/S0008414X2510120X), and [arXiv](https://arxiv.org/abs/2412.02932).\n\n\n2025/11/07, 10:00 a.m., [Tencent Meeting]()\n\nChen Zaoli (Cornell University)\n\n**Extreme Value Theory of Long-Range Dependent Sequences** \n\nIn a long-range dependent setting, extreme values of a stationary processes exhibit both macroscopic and microscopic clustering features. Such an extremal clustering is subject to the dependence structure as well as the marginal distribution. In this talk, I will introduce the mechanism of a class of long-range dependent time series and its unique extremal behaviors. The talk is based on the following two articles.\n\n[1]\tExtremal clustering under moderately long range dependence and moderately heavy tails, Z. Chen and G. Samorodnitsky, Stochastic Processes and Their Applications, 2022.\n\n[2]\tModerately Heavy Extreme Values under Extreme Long Range Dependence, Z. Chen, arXiv: 2505.23103.\n\n\n\n2025/11/21, 10:00 a.m., [Tencent Meeting]()\n\n[Tan Ju](https://sites.google.com/view/ju-tan-math/) (Boston University)\n\n**Mirror Construction for Nakajima Quiver Varieties**\n\nIn this paper, we construct the ADHM quiver representations and the corresponding sheaves as the mirror objects of formal deformations of the framed immersed Lagrangian sphere decorated with flat bundles. More generally, we construct Nakajima quiver varieties as localized mirrors of framed nodal unions of Lagrangian spheres in dimension two. This produces a mirror functor from the Fukaya category of a framed plumbing of surfaces to the dg category of complexes of bundles over the corresponding Nakajima quiver varieties.\n\nFor affine ADE quivers in specific multiplicities, the corresponding (unframed) Lagrangian immersions are homological tori, whose moduli of stable deformations are asymptotically locally Euclidean (ALE) spaces. We show that framed stable Lagrangian branes are transformed into monadic complexes of framed torsion-free sheaves over the ALE spaces.\n\nA main ingredient is the notion of framed Lagrangian immersions and their Maurer-Cartan deformations. Moreover, using the formalism of quiver algebroid stacks, we find isomorphisms between the moduli of stable Lagrangian immersions and that of special Lagrangian fibers of an SYZ fibration in the affine $A_n$ cases.\n\n[ArXiv1](https://arxiv.org/abs/2206.03028), [ArXiv2](https://arxiv.org/abs/2404.16172).\n\n\n2025/07+, 10:00 a.m., [Tencent Meeting]()\n\nShao Kerun (Zhejiang University)\n\n**Existence of global solutions to semilinear wave equations** \n\nTBA.\n\n[Article](https://www.researchgate.net/profile/Kerun-Shao).\n\n\n2025/07+, 10:00 a.m., [TBA]()\n\nFeng Yu (Tsinghua University)\n\nTBA.\n\n\n## Past Events\n\n\n2025/07/04, 10:00 a.m., [Tencent Meeting](https://meeting.tencent.com/crm/NQDBn4ZJef)\n\nYang Zhilin (CAS)\n\n**Weak coupling limit of a Brownian particle in the curl of the 2D GFF**\n\nWe study the weak coupling limit of the following equation in $\\mathbb{R}^2$: $$dX_t^\\varepsilon=\\frac{\\hat{\\lambda}}{\\sqrt{\\log\\frac1\\varepsilon}}\\omega^\\varepsilon(X_t^\\varepsilon)dt+\\nu dB_t,\\quad X_0^\\varepsilon=0. $$ Here $\\omega^\\varepsilon=\\nabla^{\\perp}\\rho_\\varepsilon*\\xi$ with $\\xi$ representing the $2d$ Gaussian Free Field (GFF) and $\\rho_\\varepsilon$ denoting an appropriate identity. $B_t$ denotes a two-dimensional standard Brownian motion, and $\\hat{\\lambda},\\;\\nu>0$ are two given constants. We use the approach from \\cite{Cannizzaro.2023} to show that the second moment of $X_t^\\varepsilon$ under the annealed law converges to $(c(\\nu,\\hat\\lambda)^2+2\\nu^2)t$ with a precisely determined constant $c(\\nu,\\hat\\lambda)>0$, which implies a non-trivial limit of the drift terms as $\\varepsilon$ vanishes. We also prove that in this weak coupling regime, the sequence of solutions converges in distribution to $\\left(\\sqrt{\\frac{c(\\nu,\\hat\\lambda)^2}{2}+\\nu^2}\\right)\\widetilde{B}_t$ as $\\varepsilon$ vanishes, where $\\widetilde{B}_t$ is a two-dimensional standard Brownian motion.\n\n[ArXiv](https://arxiv.org/abs/2405.05778).\n\n\n2025/05/09, 10:00 a.m., [Tencent Meeting]()\n\nXue Xiaolong (Tsinghua University)\n\n**The rigidity of eigenfunctions's gradient estimates**\n\nWe introduce the rigidity results for eigenfunctions on Riemannian manifolds with nonnegative Ricci curvature. We also obtain the Li-Yau gradient estimate on convex domains and prove similar rigidity results.\n\n[Article](https://link.springer.com/article/10.1007/s00209-024-03665-8) in Mathematische Zeitschrift.\n\n\n2025/02/26, 10:00 a.m., [Tencent Meeting](https://meeting.tencent.com/crm/l7RgJdZmfe) Password: ETDR\n\nYilong Zhang (Bonn University)\n\n**Green points in the reals**\n\nWe construct an expansion of a real closed field by a multiplicative subgroup adapting Poizat's theory of green points Its theory is strongly dependent, and every open set definable in a model of this theory is semialgebraic. We prove that the real field with a dense family of logarithmic spirals, proposed by Zilber, satisfies our theory.\n\n[ArXiv](https://arxiv.org/abs/2501.01176).\n\n\n[2024](/seminar/2024)\n\n<div class=\"pagination\">\n  <a>Previous Page</a>\n  <a class=\"previous\" href=\"/seminar/2024\">Next Page</a>\n</div>\n","source":"seminar/index.md","raw":"---\ntitle: Seminar\nlayout: semiars\ndate: 2024-01-30 20:52:41\nsticky: 100\ntop: true\nmathjax: true\npagination: true\nper_page: 10\n---\n\n\n# NWU Set Theory Seminar (From 2024 January)\n\n\n\nHello~ Welcome to the Set Theory Seminar at Northwest Univeristy!🎉🎉🎉\n\nThis is a regularly held up seminar organized by graduates from 2014, Mathematics and Applied Mathematics at the School of Mathematics, Northwest University. We invite you to join us for discussions, presentations, and auditions.\n\nFor subscription, please send an email including your resume to any organizer below. For instance, you can send it to one of the organizer [wanghm37@mail2.sysu.edu.cn](wanghm37@mail2.sysu.edu.cn). Once we have reviewed your resume, we will send you an email one day before, containing the title, abstract, and Tencent Meeting link for the upcoming event.\n\nOur discussions typically take place on Fridays, once every one to two weeks. The inaugural session is scheduled for February 2, 2024, from 1:00 p.m. to 3:00 p.m (Beijing Time). You can find updated information on titles and abstracts on [Seminar](https://blueairm.github.io/seminar/).\n\nIf you have any question or need help, feel free to ask!\n\n# News (Updated on 2025/06/16)\n\nWe are intended to organise an online seminar on *Continuous Logic and Free Probability*. Schedules and summaries are listed in [2025Special](/seminar/Continuous Logic and Free Probability). Please feel free to joint us. Related information will be updated on this website.\n\n\n## Organizers\n\n[Cao Zilong](https://scholar.google.com/citations?user=cago5xUAAAAJ&hl=zh-CN) *(Mathematical Statistics)*\n\nPhD, School of Mathematics, Northwest University\n\nEmail: [nwu_czl@stumail.nwu.edu.cn](nwu_czl@stumail.nwu.edu.cn) \n\n[Mu Miaomiao](https://nichole2023.github.io/) *(Number Theory, Algebraic Geometry)* *Female\n\nPhD, School of Mathematical Sciences, University of Science and Technology of China\n\nEmail: [mumm@mail.ustc.edu.cn](mumm@mail.ustc.edu.cn)\n\nQian Jingxu, *(Mathematical Physics)*\n\nGraduate, Department of Physics, National University of Defense Technology\n\nEmail: [qian_jingxu@alumni.nudt.edu.cn](qian_jingxu@alumni.nudt.edu.cn)\n\n[Shao Kerun](https://www.researchgate.net/profile/Kerun-Shao) *(Analysis, Partial Differential Equations)*\n\nEmail: [12335003@zju.edu.cn](12335003@zju.edu.cn)\n\nPhD, School of Mathematical Sciences, Zhejiang University\n\n[Sheng Xi](https://www.researchgate.net/profile/Xi-Sheng-3) *(Analysis, Topology, Dynamic Systems)*\n\nPhD, School of Mathematical Sciences, University of Science and Technology of China\n\nEmail: [sunx@mail.ustc.edu.cn](sunx@mail.ustc.edu.cn)\n\n[Wang Haoming](https://blueairm.github.io/) *(Combinatorics, Probability, Statistics)*\n\nPhD, School of Mathematics, Sun Yat-sen University\n\nEmail: [wanghm37@mail2.sysu.edu.cn](wanghm37@mail2.sysu.edu.cn)\n\nXue Xiaolong *(Topology, Differential Geometry)*\n\nPhD, Department of Mathematical Sciences, Tsinghua University\n\nEmail: [xxl19@mails.tsinghua.edu.cn](xxl19@mails.tsinghua.edu.cn)\n\n[Yang Yixuan](https://yxuanar.github.io/) *(Theoretical Computer Science, Mathematical Logic)*\n\nPhD, Department of Computer Science and Engineering, South University of Science and Technology of China \\& Department of Computer Science, Warwick University\n\nEmail: [nakeryang@gmail.com](nakeryang@gmail.com)\n\n\n## Upcoming Events\n\n2025/09/26, 10:00 a.m., [Tencent Meeting]()\n\nLin Zhuowei (Nankai University, Center for Combinatorics)\n\n**The Combinatorics of Flagged Weyl Characters**\n\nIn this talk, we introduce two aspects of flagged Weyl charcters, which can be restricted to Schubert polynomials. One is about coefficient-wise upper bounds and lower bounds of flagged Weyl charcters. This settles two conjectures proposed by Mészáros-St. Dizier-Tanjaya. The other one is about the principal specialization of Schubert polynomials, which improves the results previously obtained by Weigandt, Gao, and Mészáros-St. Dizier-Tanjaya.\n\n[Article1](https://doi.org/10.1016/j.aam.2024.102752), [Article2](https://doi.org/10.4153/S0008414X2510120X), and [arXiv](https://arxiv.org/abs/2412.02932).\n\n\n2025/11/07, 10:00 a.m., [Tencent Meeting]()\n\nChen Zaoli (Cornell University)\n\n**Extreme Value Theory of Long-Range Dependent Sequences** \n\nIn a long-range dependent setting, extreme values of a stationary processes exhibit both macroscopic and microscopic clustering features. Such an extremal clustering is subject to the dependence structure as well as the marginal distribution. In this talk, I will introduce the mechanism of a class of long-range dependent time series and its unique extremal behaviors. The talk is based on the following two articles.\n\n[1]\tExtremal clustering under moderately long range dependence and moderately heavy tails, Z. Chen and G. Samorodnitsky, Stochastic Processes and Their Applications, 2022.\n\n[2]\tModerately Heavy Extreme Values under Extreme Long Range Dependence, Z. Chen, arXiv: 2505.23103.\n\n\n\n2025/11/21, 10:00 a.m., [Tencent Meeting]()\n\n[Tan Ju](https://sites.google.com/view/ju-tan-math/) (Boston University)\n\n**Mirror Construction for Nakajima Quiver Varieties**\n\nIn this paper, we construct the ADHM quiver representations and the corresponding sheaves as the mirror objects of formal deformations of the framed immersed Lagrangian sphere decorated with flat bundles. More generally, we construct Nakajima quiver varieties as localized mirrors of framed nodal unions of Lagrangian spheres in dimension two. This produces a mirror functor from the Fukaya category of a framed plumbing of surfaces to the dg category of complexes of bundles over the corresponding Nakajima quiver varieties.\n\nFor affine ADE quivers in specific multiplicities, the corresponding (unframed) Lagrangian immersions are homological tori, whose moduli of stable deformations are asymptotically locally Euclidean (ALE) spaces. We show that framed stable Lagrangian branes are transformed into monadic complexes of framed torsion-free sheaves over the ALE spaces.\n\nA main ingredient is the notion of framed Lagrangian immersions and their Maurer-Cartan deformations. Moreover, using the formalism of quiver algebroid stacks, we find isomorphisms between the moduli of stable Lagrangian immersions and that of special Lagrangian fibers of an SYZ fibration in the affine $A_n$ cases.\n\n[ArXiv1](https://arxiv.org/abs/2206.03028), [ArXiv2](https://arxiv.org/abs/2404.16172).\n\n\n2025/07+, 10:00 a.m., [Tencent Meeting]()\n\nShao Kerun (Zhejiang University)\n\n**Existence of global solutions to semilinear wave equations** \n\nTBA.\n\n[Article](https://www.researchgate.net/profile/Kerun-Shao).\n\n\n2025/07+, 10:00 a.m., [TBA]()\n\nFeng Yu (Tsinghua University)\n\nTBA.\n\n\n## Past Events\n\n\n2025/07/04, 10:00 a.m., [Tencent Meeting](https://meeting.tencent.com/crm/NQDBn4ZJef)\n\nYang Zhilin (CAS)\n\n**Weak coupling limit of a Brownian particle in the curl of the 2D GFF**\n\nWe study the weak coupling limit of the following equation in $\\mathbb{R}^2$: $$dX_t^\\varepsilon=\\frac{\\hat{\\lambda}}{\\sqrt{\\log\\frac1\\varepsilon}}\\omega^\\varepsilon(X_t^\\varepsilon)dt+\\nu dB_t,\\quad X_0^\\varepsilon=0. $$ Here $\\omega^\\varepsilon=\\nabla^{\\perp}\\rho_\\varepsilon*\\xi$ with $\\xi$ representing the $2d$ Gaussian Free Field (GFF) and $\\rho_\\varepsilon$ denoting an appropriate identity. $B_t$ denotes a two-dimensional standard Brownian motion, and $\\hat{\\lambda},\\;\\nu>0$ are two given constants. We use the approach from \\cite{Cannizzaro.2023} to show that the second moment of $X_t^\\varepsilon$ under the annealed law converges to $(c(\\nu,\\hat\\lambda)^2+2\\nu^2)t$ with a precisely determined constant $c(\\nu,\\hat\\lambda)>0$, which implies a non-trivial limit of the drift terms as $\\varepsilon$ vanishes. We also prove that in this weak coupling regime, the sequence of solutions converges in distribution to $\\left(\\sqrt{\\frac{c(\\nu,\\hat\\lambda)^2}{2}+\\nu^2}\\right)\\widetilde{B}_t$ as $\\varepsilon$ vanishes, where $\\widetilde{B}_t$ is a two-dimensional standard Brownian motion.\n\n[ArXiv](https://arxiv.org/abs/2405.05778).\n\n\n2025/05/09, 10:00 a.m., [Tencent Meeting]()\n\nXue Xiaolong (Tsinghua University)\n\n**The rigidity of eigenfunctions's gradient estimates**\n\nWe introduce the rigidity results for eigenfunctions on Riemannian manifolds with nonnegative Ricci curvature. We also obtain the Li-Yau gradient estimate on convex domains and prove similar rigidity results.\n\n[Article](https://link.springer.com/article/10.1007/s00209-024-03665-8) in Mathematische Zeitschrift.\n\n\n2025/02/26, 10:00 a.m., [Tencent Meeting](https://meeting.tencent.com/crm/l7RgJdZmfe) Password: ETDR\n\nYilong Zhang (Bonn University)\n\n**Green points in the reals**\n\nWe construct an expansion of a real closed field by a multiplicative subgroup adapting Poizat's theory of green points Its theory is strongly dependent, and every open set definable in a model of this theory is semialgebraic. We prove that the real field with a dense family of logarithmic spirals, proposed by Zilber, satisfies our theory.\n\n[ArXiv](https://arxiv.org/abs/2501.01176).\n\n\n[2024](/seminar/2024)\n\n<div class=\"pagination\">\n  <a>Previous Page</a>\n  <a class=\"previous\" href=\"/seminar/2024\">Next Page</a>\n</div>\n","updated":"2025-09-23T09:27:53.968Z","path":"seminar/index.html","comments":1,"_id":"cmfwcr5rv000hm8nx1ky805kt","content":"<h1 id=\"nwu-set-theory-seminar-from-2024-january\">NWU Set Theory Seminar\r\n(From 2024 January)</h1>\r\n<p>Hello~ Welcome to the Set Theory Seminar at Northwest\r\nUniveristy!🎉🎉🎉</p>\r\n<p>This is a regularly held up seminar organized by graduates from 2014,\r\nMathematics and Applied Mathematics at the School of Mathematics,\r\nNorthwest University. We invite you to join us for discussions,\r\npresentations, and auditions.</p>\r\n<p>For subscription, please send an email including your resume to any\r\norganizer below. For instance, you can send it to one of the organizer\r\n<a href=\"wanghm37@mail2.sysu.edu.cn\">wanghm37@mail2.sysu.edu.cn</a>.\r\nOnce we have reviewed your resume, we will send you an email one day\r\nbefore, containing the title, abstract, and Tencent Meeting link for the\r\nupcoming event.</p>\r\n<p>Our discussions typically take place on Fridays, once every one to\r\ntwo weeks. The inaugural session is scheduled for February 2, 2024, from\r\n1:00 p.m. to 3:00 p.m (Beijing Time). You can find updated information\r\non titles and abstracts on <a href=\"https://blueairm.github.io/seminar/\">Seminar</a>.</p>\r\n<p>If you have any question or need help, feel free to ask!</p>\r\n<h1 id=\"news-updated-on-20250616\">News (Updated on 2025/06/16)</h1>\r\n<p>We are intended to organise an online seminar on <em>Continuous Logic\r\nand Free Probability</em>. Schedules and summaries are listed in <a href=\"/seminar/Continuous%20Logic%20and%20Free%20Probability\">2025Special</a>.\r\nPlease feel free to joint us. Related information will be updated on\r\nthis website.</p>\r\n<h2 id=\"organizers\">Organizers</h2>\r\n<p><a href=\"https://scholar.google.com/citations?user=cago5xUAAAAJ&amp;hl=zh-CN\">Cao\r\nZilong</a> <em>(Mathematical Statistics)</em></p>\r\n<p>PhD, School of Mathematics, Northwest University</p>\r\n<p>Email: <a href=\"nwu_czl@stumail.nwu.edu.cn\">nwu_czl@stumail.nwu.edu.cn</a></p>\r\n<p><a href=\"https://nichole2023.github.io/\">Mu Miaomiao</a> <em>(Number\r\nTheory, Algebraic Geometry)</em> *Female</p>\r\n<p>PhD, School of Mathematical Sciences, University of Science and\r\nTechnology of China</p>\r\n<p>Email: <a href=\"mumm@mail.ustc.edu.cn\">mumm@mail.ustc.edu.cn</a></p>\r\n<p>Qian Jingxu, <em>(Mathematical Physics)</em></p>\r\n<p>Graduate, Department of Physics, National University of Defense\r\nTechnology</p>\r\n<p>Email: <a href=\"qian_jingxu@alumni.nudt.edu.cn\">qian_jingxu@alumni.nudt.edu.cn</a></p>\r\n<p><a href=\"https://www.researchgate.net/profile/Kerun-Shao\">Shao\r\nKerun</a> <em>(Analysis, Partial Differential Equations)</em></p>\r\n<p>Email: <a href=\"12335003@zju.edu.cn\">12335003@zju.edu.cn</a></p>\r\n<p>PhD, School of Mathematical Sciences, Zhejiang University</p>\r\n<p><a href=\"https://www.researchgate.net/profile/Xi-Sheng-3\">Sheng\r\nXi</a> <em>(Analysis, Topology, Dynamic Systems)</em></p>\r\n<p>PhD, School of Mathematical Sciences, University of Science and\r\nTechnology of China</p>\r\n<p>Email: <a href=\"sunx@mail.ustc.edu.cn\">sunx@mail.ustc.edu.cn</a></p>\r\n<p><a href=\"https://blueairm.github.io/\">Wang Haoming</a>\r\n<em>(Combinatorics, Probability, Statistics)</em></p>\r\n<p>PhD, School of Mathematics, Sun Yat-sen University</p>\r\n<p>Email: <a href=\"wanghm37@mail2.sysu.edu.cn\">wanghm37@mail2.sysu.edu.cn</a></p>\r\n<p>Xue Xiaolong <em>(Topology, Differential Geometry)</em></p>\r\n<p>PhD, Department of Mathematical Sciences, Tsinghua University</p>\r\n<p>Email: <a href=\"xxl19@mails.tsinghua.edu.cn\">xxl19@mails.tsinghua.edu.cn</a></p>\r\n<p><a href=\"https://yxuanar.github.io/\">Yang Yixuan</a> <em>(Theoretical\r\nComputer Science, Mathematical Logic)</em></p>\r\n<p>PhD, Department of Computer Science and Engineering, South University\r\nof Science and Technology of China &amp; Department of Computer Science,\r\nWarwick University</p>\r\n<p>Email: <a href=\"nakeryang@gmail.com\">nakeryang@gmail.com</a></p>\r\n<h2 id=\"upcoming-events\">Upcoming Events</h2>\r\n<p>2025/09/26, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Lin Zhuowei (Nankai University, Center for Combinatorics)</p>\r\n<p><strong>The Combinatorics of Flagged Weyl Characters</strong></p>\r\n<p>In this talk, we introduce two aspects of flagged Weyl charcters,\r\nwhich can be restricted to Schubert polynomials. One is about\r\ncoefficient-wise upper bounds and lower bounds of flagged Weyl\r\ncharcters. This settles two conjectures proposed by Mészáros-St.\r\nDizier-Tanjaya. The other one is about the principal specialization of\r\nSchubert polynomials, which improves the results previously obtained by\r\nWeigandt, Gao, and Mészáros-St. Dizier-Tanjaya.</p>\r\n<p><a href=\"https://doi.org/10.1016/j.aam.2024.102752\">Article1</a>, <a href=\"https://doi.org/10.4153/S0008414X2510120X\">Article2</a>, and <a href=\"https://arxiv.org/abs/2412.02932\">arXiv</a>.</p>\r\n<p>2025/11/07, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Chen Zaoli (Cornell University)</p>\r\n<p><strong>Extreme Value Theory of Long-Range Dependent\r\nSequences</strong></p>\r\n<p>In a long-range dependent setting, extreme values of a stationary\r\nprocesses exhibit both macroscopic and microscopic clustering features.\r\nSuch an extremal clustering is subject to the dependence structure as\r\nwell as the marginal distribution. In this talk, I will introduce the\r\nmechanism of a class of long-range dependent time series and its unique\r\nextremal behaviors. The talk is based on the following two articles.</p>\r\n<p>[1] Extremal clustering under moderately long range dependence and\r\nmoderately heavy tails, Z. Chen and G. Samorodnitsky, Stochastic\r\nProcesses and Their Applications, 2022.</p>\r\n<p>[2] Moderately Heavy Extreme Values under Extreme Long Range\r\nDependence, Z. Chen, arXiv: 2505.23103.</p>\r\n<p>2025/11/21, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p><a href=\"https://sites.google.com/view/ju-tan-math/\">Tan Ju</a>\r\n(Boston University)</p>\r\n<p><strong>Mirror Construction for Nakajima Quiver\r\nVarieties</strong></p>\r\n<p>In this paper, we construct the ADHM quiver representations and the\r\ncorresponding sheaves as the mirror objects of formal deformations of\r\nthe framed immersed Lagrangian sphere decorated with flat bundles. More\r\ngenerally, we construct Nakajima quiver varieties as localized mirrors\r\nof framed nodal unions of Lagrangian spheres in dimension two. This\r\nproduces a mirror functor from the Fukaya category of a framed plumbing\r\nof surfaces to the dg category of complexes of bundles over the\r\ncorresponding Nakajima quiver varieties.</p>\r\n<p>For affine ADE quivers in specific multiplicities, the corresponding\r\n(unframed) Lagrangian immersions are homological tori, whose moduli of\r\nstable deformations are asymptotically locally Euclidean (ALE) spaces.\r\nWe show that framed stable Lagrangian branes are transformed into\r\nmonadic complexes of framed torsion-free sheaves over the ALE\r\nspaces.</p>\r\n<p>A main ingredient is the notion of framed Lagrangian immersions and\r\ntheir Maurer-Cartan deformations. Moreover, using the formalism of\r\nquiver algebroid stacks, we find isomorphisms between the moduli of\r\nstable Lagrangian immersions and that of special Lagrangian fibers of an\r\nSYZ fibration in the affine <span class=\"math inline\">\\(A_n\\)</span>\r\ncases.</p>\r\n<p><a href=\"https://arxiv.org/abs/2206.03028\">ArXiv1</a>, <a href=\"https://arxiv.org/abs/2404.16172\">ArXiv2</a>.</p>\r\n<p>2025/07+, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Shao Kerun (Zhejiang University)</p>\r\n<p><strong>Existence of global solutions to semilinear wave\r\nequations</strong></p>\r\n<p>TBA.</p>\r\n<p><a href=\"https://www.researchgate.net/profile/Kerun-Shao\">Article</a>.</p>\r\n<p>2025/07+, 10:00 a.m., <a href>TBA</a></p>\r\n<p>Feng Yu (Tsinghua University)</p>\r\n<p>TBA.</p>\r\n<h2 id=\"past-events\">Past Events</h2>\r\n<p>2025/07/04, 10:00 a.m., <a href=\"https://meeting.tencent.com/crm/NQDBn4ZJef\">Tencent\r\nMeeting</a></p>\r\n<p>Yang Zhilin (CAS)</p>\r\n<p><strong>Weak coupling limit of a Brownian particle in the curl of the\r\n2D GFF</strong></p>\r\n<p>We study the weak coupling limit of the following equation in <span class=\"math inline\">\\(\\mathbb{R}^2\\)</span>: <span class=\"math display\">\\[dX_t^\\varepsilon=\\frac{\\hat{\\lambda}}{\\sqrt{\\log\\frac1\\varepsilon}}\\omega^\\varepsilon(X_t^\\varepsilon)dt+\\nu\r\ndB_t,\\quad X_0^\\varepsilon=0. \\]</span> Here <span class=\"math inline\">\\(\\omega^\\varepsilon=\\nabla^{\\perp}\\rho_\\varepsilon*\\xi\\)</span>\r\nwith <span class=\"math inline\">\\(\\xi\\)</span> representing the <span class=\"math inline\">\\(2d\\)</span> Gaussian Free Field (GFF) and <span class=\"math inline\">\\(\\rho_\\varepsilon\\)</span> denoting an appropriate\r\nidentity. <span class=\"math inline\">\\(B_t\\)</span> denotes a\r\ntwo-dimensional standard Brownian motion, and <span class=\"math inline\">\\(\\hat{\\lambda},\\;\\nu&gt;0\\)</span> are two given\r\nconstants. We use the approach from to show that the second moment of\r\n<span class=\"math inline\">\\(X_t^\\varepsilon\\)</span> under the annealed\r\nlaw converges to <span class=\"math inline\">\\((c(\\nu,\\hat\\lambda)^2+2\\nu^2)t\\)</span> with a\r\nprecisely determined constant <span class=\"math inline\">\\(c(\\nu,\\hat\\lambda)&gt;0\\)</span>, which implies a\r\nnon-trivial limit of the drift terms as <span class=\"math inline\">\\(\\varepsilon\\)</span> vanishes. We also prove that\r\nin this weak coupling regime, the sequence of solutions converges in\r\ndistribution to <span class=\"math inline\">\\(\\left(\\sqrt{\\frac{c(\\nu,\\hat\\lambda)^2}{2}+\\nu^2}\\right)\\widetilde{B}_t\\)</span>\r\nas <span class=\"math inline\">\\(\\varepsilon\\)</span> vanishes, where\r\n<span class=\"math inline\">\\(\\widetilde{B}_t\\)</span> is a\r\ntwo-dimensional standard Brownian motion.</p>\r\n<p><a href=\"https://arxiv.org/abs/2405.05778\">ArXiv</a>.</p>\r\n<p>2025/05/09, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Xue Xiaolong (Tsinghua University)</p>\r\n<p><strong>The rigidity of eigenfunctions's gradient\r\nestimates</strong></p>\r\n<p>We introduce the rigidity results for eigenfunctions on Riemannian\r\nmanifolds with nonnegative Ricci curvature. We also obtain the Li-Yau\r\ngradient estimate on convex domains and prove similar rigidity\r\nresults.</p>\r\n<p><a href=\"https://link.springer.com/article/10.1007/s00209-024-03665-8\">Article</a>\r\nin Mathematische Zeitschrift.</p>\r\n<p>2025/02/26, 10:00 a.m., <a href=\"https://meeting.tencent.com/crm/l7RgJdZmfe\">Tencent Meeting</a>\r\nPassword: ETDR</p>\r\n<p>Yilong Zhang (Bonn University)</p>\r\n<p><strong>Green points in the reals</strong></p>\r\n<p>We construct an expansion of a real closed field by a multiplicative\r\nsubgroup adapting Poizat's theory of green points Its theory is strongly\r\ndependent, and every open set definable in a model of this theory is\r\nsemialgebraic. We prove that the real field with a dense family of\r\nlogarithmic spirals, proposed by Zilber, satisfies our theory.</p>\r\n<p><a href=\"https://arxiv.org/abs/2501.01176\">ArXiv</a>.</p>\r\n<p><a href=\"/seminar/2024\">2024</a></p>\r\n<div class=\"pagination\">\r\n<p><a>Previous Page</a> <a class=\"previous\" href=\"/seminar/2024\">Next\r\nPage</a></p>\r\n</div>\r\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"nwu-set-theory-seminar-from-2024-january\">NWU Set Theory Seminar\r\n(From 2024 January)</h1>\r\n<p>Hello~ Welcome to the Set Theory Seminar at Northwest\r\nUniveristy!🎉🎉🎉</p>\r\n<p>This is a regularly held up seminar organized by graduates from 2014,\r\nMathematics and Applied Mathematics at the School of Mathematics,\r\nNorthwest University. We invite you to join us for discussions,\r\npresentations, and auditions.</p>\r\n<p>For subscription, please send an email including your resume to any\r\norganizer below. For instance, you can send it to one of the organizer\r\n<a href=\"wanghm37@mail2.sysu.edu.cn\">wanghm37@mail2.sysu.edu.cn</a>.\r\nOnce we have reviewed your resume, we will send you an email one day\r\nbefore, containing the title, abstract, and Tencent Meeting link for the\r\nupcoming event.</p>\r\n<p>Our discussions typically take place on Fridays, once every one to\r\ntwo weeks. The inaugural session is scheduled for February 2, 2024, from\r\n1:00 p.m. to 3:00 p.m (Beijing Time). You can find updated information\r\non titles and abstracts on <a href=\"https://blueairm.github.io/seminar/\">Seminar</a>.</p>\r\n<p>If you have any question or need help, feel free to ask!</p>\r\n<h1 id=\"news-updated-on-20250616\">News (Updated on 2025/06/16)</h1>\r\n<p>We are intended to organise an online seminar on <em>Continuous Logic\r\nand Free Probability</em>. Schedules and summaries are listed in <a href=\"/seminar/Continuous%20Logic%20and%20Free%20Probability\">2025Special</a>.\r\nPlease feel free to joint us. Related information will be updated on\r\nthis website.</p>\r\n<h2 id=\"organizers\">Organizers</h2>\r\n<p><a href=\"https://scholar.google.com/citations?user=cago5xUAAAAJ&amp;hl=zh-CN\">Cao\r\nZilong</a> <em>(Mathematical Statistics)</em></p>\r\n<p>PhD, School of Mathematics, Northwest University</p>\r\n<p>Email: <a href=\"nwu_czl@stumail.nwu.edu.cn\">nwu_czl@stumail.nwu.edu.cn</a></p>\r\n<p><a href=\"https://nichole2023.github.io/\">Mu Miaomiao</a> <em>(Number\r\nTheory, Algebraic Geometry)</em> *Female</p>\r\n<p>PhD, School of Mathematical Sciences, University of Science and\r\nTechnology of China</p>\r\n<p>Email: <a href=\"mumm@mail.ustc.edu.cn\">mumm@mail.ustc.edu.cn</a></p>\r\n<p>Qian Jingxu, <em>(Mathematical Physics)</em></p>\r\n<p>Graduate, Department of Physics, National University of Defense\r\nTechnology</p>\r\n<p>Email: <a href=\"qian_jingxu@alumni.nudt.edu.cn\">qian_jingxu@alumni.nudt.edu.cn</a></p>\r\n<p><a href=\"https://www.researchgate.net/profile/Kerun-Shao\">Shao\r\nKerun</a> <em>(Analysis, Partial Differential Equations)</em></p>\r\n<p>Email: <a href=\"12335003@zju.edu.cn\">12335003@zju.edu.cn</a></p>\r\n<p>PhD, School of Mathematical Sciences, Zhejiang University</p>\r\n<p><a href=\"https://www.researchgate.net/profile/Xi-Sheng-3\">Sheng\r\nXi</a> <em>(Analysis, Topology, Dynamic Systems)</em></p>\r\n<p>PhD, School of Mathematical Sciences, University of Science and\r\nTechnology of China</p>\r\n<p>Email: <a href=\"sunx@mail.ustc.edu.cn\">sunx@mail.ustc.edu.cn</a></p>\r\n<p><a href=\"https://blueairm.github.io/\">Wang Haoming</a>\r\n<em>(Combinatorics, Probability, Statistics)</em></p>\r\n<p>PhD, School of Mathematics, Sun Yat-sen University</p>\r\n<p>Email: <a href=\"wanghm37@mail2.sysu.edu.cn\">wanghm37@mail2.sysu.edu.cn</a></p>\r\n<p>Xue Xiaolong <em>(Topology, Differential Geometry)</em></p>\r\n<p>PhD, Department of Mathematical Sciences, Tsinghua University</p>\r\n<p>Email: <a href=\"xxl19@mails.tsinghua.edu.cn\">xxl19@mails.tsinghua.edu.cn</a></p>\r\n<p><a href=\"https://yxuanar.github.io/\">Yang Yixuan</a> <em>(Theoretical\r\nComputer Science, Mathematical Logic)</em></p>\r\n<p>PhD, Department of Computer Science and Engineering, South University\r\nof Science and Technology of China &amp; Department of Computer Science,\r\nWarwick University</p>\r\n<p>Email: <a href=\"nakeryang@gmail.com\">nakeryang@gmail.com</a></p>\r\n<h2 id=\"upcoming-events\">Upcoming Events</h2>\r\n<p>2025/09/26, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Lin Zhuowei (Nankai University, Center for Combinatorics)</p>\r\n<p><strong>The Combinatorics of Flagged Weyl Characters</strong></p>\r\n<p>In this talk, we introduce two aspects of flagged Weyl charcters,\r\nwhich can be restricted to Schubert polynomials. One is about\r\ncoefficient-wise upper bounds and lower bounds of flagged Weyl\r\ncharcters. This settles two conjectures proposed by Mészáros-St.\r\nDizier-Tanjaya. The other one is about the principal specialization of\r\nSchubert polynomials, which improves the results previously obtained by\r\nWeigandt, Gao, and Mészáros-St. Dizier-Tanjaya.</p>\r\n<p><a href=\"https://doi.org/10.1016/j.aam.2024.102752\">Article1</a>, <a href=\"https://doi.org/10.4153/S0008414X2510120X\">Article2</a>, and <a href=\"https://arxiv.org/abs/2412.02932\">arXiv</a>.</p>\r\n<p>2025/11/07, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Chen Zaoli (Cornell University)</p>\r\n<p><strong>Extreme Value Theory of Long-Range Dependent\r\nSequences</strong></p>\r\n<p>In a long-range dependent setting, extreme values of a stationary\r\nprocesses exhibit both macroscopic and microscopic clustering features.\r\nSuch an extremal clustering is subject to the dependence structure as\r\nwell as the marginal distribution. In this talk, I will introduce the\r\nmechanism of a class of long-range dependent time series and its unique\r\nextremal behaviors. The talk is based on the following two articles.</p>\r\n<p>[1] Extremal clustering under moderately long range dependence and\r\nmoderately heavy tails, Z. Chen and G. Samorodnitsky, Stochastic\r\nProcesses and Their Applications, 2022.</p>\r\n<p>[2] Moderately Heavy Extreme Values under Extreme Long Range\r\nDependence, Z. Chen, arXiv: 2505.23103.</p>\r\n<p>2025/11/21, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p><a href=\"https://sites.google.com/view/ju-tan-math/\">Tan Ju</a>\r\n(Boston University)</p>\r\n<p><strong>Mirror Construction for Nakajima Quiver\r\nVarieties</strong></p>\r\n<p>In this paper, we construct the ADHM quiver representations and the\r\ncorresponding sheaves as the mirror objects of formal deformations of\r\nthe framed immersed Lagrangian sphere decorated with flat bundles. More\r\ngenerally, we construct Nakajima quiver varieties as localized mirrors\r\nof framed nodal unions of Lagrangian spheres in dimension two. This\r\nproduces a mirror functor from the Fukaya category of a framed plumbing\r\nof surfaces to the dg category of complexes of bundles over the\r\ncorresponding Nakajima quiver varieties.</p>\r\n<p>For affine ADE quivers in specific multiplicities, the corresponding\r\n(unframed) Lagrangian immersions are homological tori, whose moduli of\r\nstable deformations are asymptotically locally Euclidean (ALE) spaces.\r\nWe show that framed stable Lagrangian branes are transformed into\r\nmonadic complexes of framed torsion-free sheaves over the ALE\r\nspaces.</p>\r\n<p>A main ingredient is the notion of framed Lagrangian immersions and\r\ntheir Maurer-Cartan deformations. Moreover, using the formalism of\r\nquiver algebroid stacks, we find isomorphisms between the moduli of\r\nstable Lagrangian immersions and that of special Lagrangian fibers of an\r\nSYZ fibration in the affine <span class=\"math inline\">\\(A_n\\)</span>\r\ncases.</p>\r\n<p><a href=\"https://arxiv.org/abs/2206.03028\">ArXiv1</a>, <a href=\"https://arxiv.org/abs/2404.16172\">ArXiv2</a>.</p>\r\n<p>2025/07+, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Shao Kerun (Zhejiang University)</p>\r\n<p><strong>Existence of global solutions to semilinear wave\r\nequations</strong></p>\r\n<p>TBA.</p>\r\n<p><a href=\"https://www.researchgate.net/profile/Kerun-Shao\">Article</a>.</p>\r\n<p>2025/07+, 10:00 a.m., <a href>TBA</a></p>\r\n<p>Feng Yu (Tsinghua University)</p>\r\n<p>TBA.</p>\r\n<h2 id=\"past-events\">Past Events</h2>\r\n<p>2025/07/04, 10:00 a.m., <a href=\"https://meeting.tencent.com/crm/NQDBn4ZJef\">Tencent\r\nMeeting</a></p>\r\n<p>Yang Zhilin (CAS)</p>\r\n<p><strong>Weak coupling limit of a Brownian particle in the curl of the\r\n2D GFF</strong></p>\r\n<p>We study the weak coupling limit of the following equation in <span class=\"math inline\">\\(\\mathbb{R}^2\\)</span>: <span class=\"math display\">\\[dX_t^\\varepsilon=\\frac{\\hat{\\lambda}}{\\sqrt{\\log\\frac1\\varepsilon}}\\omega^\\varepsilon(X_t^\\varepsilon)dt+\\nu\r\ndB_t,\\quad X_0^\\varepsilon=0. \\]</span> Here <span class=\"math inline\">\\(\\omega^\\varepsilon=\\nabla^{\\perp}\\rho_\\varepsilon*\\xi\\)</span>\r\nwith <span class=\"math inline\">\\(\\xi\\)</span> representing the <span class=\"math inline\">\\(2d\\)</span> Gaussian Free Field (GFF) and <span class=\"math inline\">\\(\\rho_\\varepsilon\\)</span> denoting an appropriate\r\nidentity. <span class=\"math inline\">\\(B_t\\)</span> denotes a\r\ntwo-dimensional standard Brownian motion, and <span class=\"math inline\">\\(\\hat{\\lambda},\\;\\nu&gt;0\\)</span> are two given\r\nconstants. We use the approach from to show that the second moment of\r\n<span class=\"math inline\">\\(X_t^\\varepsilon\\)</span> under the annealed\r\nlaw converges to <span class=\"math inline\">\\((c(\\nu,\\hat\\lambda)^2+2\\nu^2)t\\)</span> with a\r\nprecisely determined constant <span class=\"math inline\">\\(c(\\nu,\\hat\\lambda)&gt;0\\)</span>, which implies a\r\nnon-trivial limit of the drift terms as <span class=\"math inline\">\\(\\varepsilon\\)</span> vanishes. We also prove that\r\nin this weak coupling regime, the sequence of solutions converges in\r\ndistribution to <span class=\"math inline\">\\(\\left(\\sqrt{\\frac{c(\\nu,\\hat\\lambda)^2}{2}+\\nu^2}\\right)\\widetilde{B}_t\\)</span>\r\nas <span class=\"math inline\">\\(\\varepsilon\\)</span> vanishes, where\r\n<span class=\"math inline\">\\(\\widetilde{B}_t\\)</span> is a\r\ntwo-dimensional standard Brownian motion.</p>\r\n<p><a href=\"https://arxiv.org/abs/2405.05778\">ArXiv</a>.</p>\r\n<p>2025/05/09, 10:00 a.m., <a href>Tencent Meeting</a></p>\r\n<p>Xue Xiaolong (Tsinghua University)</p>\r\n<p><strong>The rigidity of eigenfunctions's gradient\r\nestimates</strong></p>\r\n<p>We introduce the rigidity results for eigenfunctions on Riemannian\r\nmanifolds with nonnegative Ricci curvature. We also obtain the Li-Yau\r\ngradient estimate on convex domains and prove similar rigidity\r\nresults.</p>\r\n<p><a href=\"https://link.springer.com/article/10.1007/s00209-024-03665-8\">Article</a>\r\nin Mathematische Zeitschrift.</p>\r\n<p>2025/02/26, 10:00 a.m., <a href=\"https://meeting.tencent.com/crm/l7RgJdZmfe\">Tencent Meeting</a>\r\nPassword: ETDR</p>\r\n<p>Yilong Zhang (Bonn University)</p>\r\n<p><strong>Green points in the reals</strong></p>\r\n<p>We construct an expansion of a real closed field by a multiplicative\r\nsubgroup adapting Poizat's theory of green points Its theory is strongly\r\ndependent, and every open set definable in a model of this theory is\r\nsemialgebraic. We prove that the real field with a dense family of\r\nlogarithmic spirals, proposed by Zilber, satisfies our theory.</p>\r\n<p><a href=\"https://arxiv.org/abs/2501.01176\">ArXiv</a>.</p>\r\n<p><a href=\"/seminar/2024\">2024</a></p>\r\n<div class=\"pagination\">\r\n<p><a>Previous Page</a> <a class=\"previous\" href=\"/seminar/2024\">Next\r\nPage</a></p>\r\n</div>\r\n"},{"title":"tag","layout":"tag","date":"2023-04-02T03:14:07.000Z","_content":"","source":"tag/index.md","raw":"---\ntitle: tag\nlayout: tag\ndate: 2023-04-02 11:14:07\n---\n","updated":"2024-02-25T15:11:07.058Z","path":"tag/index.html","comments":1,"_id":"cmfwcr5rw000lm8nx7tadg4vb","content":"\r\n","site":{"data":{}},"excerpt":"","more":"\r\n"},{"_content":"var Gitment =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar LS_ACCESS_TOKEN_KEY = exports.LS_ACCESS_TOKEN_KEY = 'gitment-comments-token';\nvar LS_USER_KEY = exports.LS_USER_KEY = 'gitment-user-info';\n\nvar NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = new Error('Comments Not Initialized');\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) {\n            if (b.hasOwnProperty(p)) d[p] = b[p];\n        }\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nregisterGlobals();\nexports.extras = {\n    allowStateChanges: allowStateChanges,\n    deepEqual: deepEqual,\n    getAtom: getAtom,\n    getDebugName: getDebugName,\n    getDependencyTree: getDependencyTree,\n    getAdministration: getAdministration,\n    getGlobalState: getGlobalState,\n    getObserverTree: getObserverTree,\n    isComputingDerivation: isComputingDerivation,\n    isSpyEnabled: isSpyEnabled,\n    onReactionError: onReactionError,\n    resetGlobalState: resetGlobalState,\n    shareGlobalState: shareGlobalState,\n    spyReport: spyReport,\n    spyReportEnd: spyReportEnd,\n    spyReportStart: spyReportStart,\n    setReactionScheduler: setReactionScheduler\n};\nif ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" ? \"undefined\" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === \"object\") {\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx(module.exports);\n}\nmodule.exports.default = module.exports;\nvar actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {\n    var actionName = args && args.length === 1 ? args[0] : value.name || key || \"<unnamed action>\";\n    var wrappedAction = action(actionName, value);\n    addHiddenProp(target, key, wrappedAction);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, true);\nvar boundActionDecorator = createClassPropertyDecorator(function (target, key, value) {\n    defineBoundAction(target, key, value);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, false);\nvar action = function action(arg1, arg2, arg3, arg4) {\n    if (arguments.length === 1 && typeof arg1 === \"function\") return createAction(arg1.name || \"<unnamed action>\", arg1);\n    if (arguments.length === 2 && typeof arg2 === \"function\") return createAction(arg1, arg2);\n    if (arguments.length === 1 && typeof arg1 === \"string\") return namedActionDecorator(arg1);\n    return namedActionDecorator(arg2).apply(null, arguments);\n};\nexports.action = action;\naction.bound = function boundAction(arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n        var action_1 = createAction(\"<not yet bound action>\", arg1);\n        action_1.autoBind = true;\n        return action_1;\n    }\n    return boundActionDecorator.apply(null, arguments);\n};\nfunction namedActionDecorator(name) {\n    return function (target, prop, descriptor) {\n        if (descriptor && typeof descriptor.value === \"function\") {\n            descriptor.value = createAction(name, descriptor.value);\n            descriptor.enumerable = false;\n            descriptor.configurable = true;\n            return descriptor;\n        }\n        return actionFieldDecorator(name).apply(this, arguments);\n    };\n}\nfunction runInAction(arg1, arg2, arg3) {\n    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action>\";\n    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\n    var scope = typeof arg1 === \"function\" ? arg2 : arg3;\n    invariant(typeof fn === \"function\", getMessage(\"m002\"));\n    invariant(fn.length === 0, getMessage(\"m003\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    return executeAction(actionName, fn, scope, undefined);\n}\nexports.runInAction = runInAction;\nfunction isAction(thing) {\n    return typeof thing === \"function\" && thing.isMobxAction === true;\n}\nexports.isAction = isAction;\nfunction defineBoundAction(target, propertyName, fn) {\n    var res = function res() {\n        return executeAction(propertyName, fn, target, arguments);\n    };\n    res.isMobxAction = true;\n    addHiddenProp(target, propertyName, res);\n}\nfunction autorun(arg1, arg2, arg3) {\n    var name, view, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        view = arg2;\n        scope = arg3;\n    } else {\n        name = arg1.name || \"Autorun@\" + getNextId();\n        view = arg1;\n        scope = arg2;\n    }\n    invariant(typeof view === \"function\", getMessage(\"m004\"));\n    invariant(isAction(view) === false, getMessage(\"m005\"));\n    if (scope) view = view.bind(scope);\n    var reaction = new Reaction(name, function () {\n        this.track(reactionRunner);\n    });\n    function reactionRunner() {\n        view(reaction);\n    }\n    reaction.schedule();\n    return reaction.getDisposer();\n}\nexports.autorun = autorun;\nfunction when(arg1, arg2, arg3, arg4) {\n    var name, predicate, effect, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        predicate = arg2;\n        effect = arg3;\n        scope = arg4;\n    } else {\n        name = \"When@\" + getNextId();\n        predicate = arg1;\n        effect = arg2;\n        scope = arg3;\n    }\n    var disposer = autorun(name, function (r) {\n        if (predicate.call(scope)) {\n            r.dispose();\n            var prevUntracked = untrackedStart();\n            effect.call(scope);\n            untrackedEnd(prevUntracked);\n        }\n    });\n    return disposer;\n}\nexports.when = when;\nfunction autorunAsync(arg1, arg2, arg3, arg4) {\n    var name, func, delay, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        func = arg2;\n        delay = arg3;\n        scope = arg4;\n    } else {\n        name = arg1.name || \"AutorunAsync@\" + getNextId();\n        func = arg1;\n        delay = arg2;\n        scope = arg3;\n    }\n    invariant(isAction(func) === false, getMessage(\"m006\"));\n    if (delay === void 0) delay = 1;\n    if (scope) func = func.bind(scope);\n    var isScheduled = false;\n    var r = new Reaction(name, function () {\n        if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                if (!r.isDisposed) r.track(reactionRunner);\n            }, delay);\n        }\n    });\n    function reactionRunner() {\n        func(r);\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.autorunAsync = autorunAsync;\nfunction reaction(expression, effect, arg3) {\n    if (arguments.length > 3) {\n        fail(getMessage(\"m007\"));\n    }\n    if (isModifierDescriptor(expression)) {\n        fail(getMessage(\"m008\"));\n    }\n    var opts;\n    if ((typeof arg3 === \"undefined\" ? \"undefined\" : _typeof(arg3)) === \"object\") {\n        opts = arg3;\n    } else {\n        opts = {};\n    }\n    opts.name = opts.name || expression.name || effect.name || \"Reaction@\" + getNextId();\n    opts.fireImmediately = arg3 === true || opts.fireImmediately === true;\n    opts.delay = opts.delay || 0;\n    opts.compareStructural = opts.compareStructural || opts.struct || false;\n    effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect);\n    if (opts.context) {\n        expression = expression.bind(opts.context);\n    }\n    var firstTime = true;\n    var isScheduled = false;\n    var nextValue;\n    var r = new Reaction(opts.name, function () {\n        if (firstTime || opts.delay < 1) {\n            reactionRunner();\n        } else if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                reactionRunner();\n            }, opts.delay);\n        }\n    });\n    function reactionRunner() {\n        if (r.isDisposed) return;\n        var changed = false;\n        r.track(function () {\n            var v = expression(r);\n            changed = valueDidChange(opts.compareStructural, nextValue, v);\n            nextValue = v;\n        });\n        if (firstTime && opts.fireImmediately) effect(nextValue, r);\n        if (!firstTime && changed === true) effect(nextValue, r);\n        if (firstTime) firstTime = false;\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.reaction = reaction;\nfunction createComputedDecorator(compareStructural) {\n    return createClassPropertyDecorator(function (target, name, _, __, originalDescriptor) {\n        invariant(typeof originalDescriptor !== \"undefined\", getMessage(\"m009\"));\n        invariant(typeof originalDescriptor.get === \"function\", getMessage(\"m010\"));\n        var adm = asObservableObject(target, \"\");\n        defineComputedProperty(adm, name, originalDescriptor.get, originalDescriptor.set, compareStructural, false);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        this.$mobx.values[name].set(value);\n    }, false, false);\n}\nvar computedDecorator = createComputedDecorator(false);\nvar computedStructDecorator = createComputedDecorator(true);\nvar computed = function computed(arg1, arg2, arg3) {\n    if (typeof arg2 === \"string\") {\n        return computedDecorator.apply(null, arguments);\n    }\n    invariant(typeof arg1 === \"function\", getMessage(\"m011\"));\n    invariant(arguments.length < 3, getMessage(\"m012\"));\n    var opts = (typeof arg2 === \"undefined\" ? \"undefined\" : _typeof(arg2)) === \"object\" ? arg2 : {};\n    opts.setter = typeof arg2 === \"function\" ? arg2 : opts.setter;\n    return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || \"\", opts.setter);\n};\nexports.computed = computed;\ncomputed.struct = computedStructDecorator;\nfunction createTransformer(transformer, onCleanup) {\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\n    var objectCache = {};\n    var resetId = globalState.resetId;\n    var Transformer = function (_super) {\n        __extends(Transformer, _super);\n        function Transformer(sourceIdentifier, sourceObject) {\n            var _this = _super.call(this, function () {\n                return transformer(sourceObject);\n            }, undefined, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier, undefined) || this;\n            _this.sourceIdentifier = sourceIdentifier;\n            _this.sourceObject = sourceObject;\n            return _this;\n        }\n        Transformer.prototype.onBecomeUnobserved = function () {\n            var lastValue = this.value;\n            _super.prototype.onBecomeUnobserved.call(this);\n            delete objectCache[this.sourceIdentifier];\n            if (onCleanup) onCleanup(lastValue, this.sourceObject);\n        };\n        return Transformer;\n    }(ComputedValue);\n    return function (object) {\n        if (resetId !== globalState.resetId) {\n            objectCache = {};\n            resetId = globalState.resetId;\n        }\n        var identifier = getMemoizationId(object);\n        var reactiveTransformer = objectCache[identifier];\n        if (reactiveTransformer) return reactiveTransformer.get();\n        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);\n        return reactiveTransformer.get();\n    };\n}\nexports.createTransformer = createTransformer;\nfunction getMemoizationId(object) {\n    if (object === null || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") throw new Error(\"[mobx] transform expected some kind of object, got: \" + object);\n    var tid = object.$transformId;\n    if (tid === undefined) {\n        tid = getNextId();\n        addHiddenProp(object, \"$transformId\", tid);\n    }\n    return tid;\n}\nfunction expr(expr, scope) {\n    if (!isComputingDerivation()) console.warn(getMessage(\"m013\"));\n    return computed(expr, { context: scope }).get();\n}\nexports.expr = expr;\nfunction extendObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, deepEnhancer, properties);\n}\nexports.extendObservable = extendObservable;\nfunction extendShallowObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, referenceEnhancer, properties);\n}\nexports.extendShallowObservable = extendShallowObservable;\nfunction extendObservableHelper(target, defaultEnhancer, properties) {\n    invariant(arguments.length >= 2, getMessage(\"m014\"));\n    invariant((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\", getMessage(\"m015\"));\n    invariant(!isObservableMap(target), getMessage(\"m016\"));\n    properties.forEach(function (propSet) {\n        invariant((typeof propSet === \"undefined\" ? \"undefined\" : _typeof(propSet)) === \"object\", getMessage(\"m017\"));\n        invariant(!isObservable(propSet), getMessage(\"m018\"));\n    });\n    var adm = asObservableObject(target);\n    var definedProps = {};\n    for (var i = properties.length - 1; i >= 0; i--) {\n        var propSet = properties[i];\n        for (var key in propSet) {\n            if (definedProps[key] !== true && hasOwnProperty(propSet, key)) {\n                definedProps[key] = true;\n                if (target === propSet && !isPropertyConfigurable(target, key)) continue;\n                var descriptor = Object.getOwnPropertyDescriptor(propSet, key);\n                defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer);\n            }\n        }\n    }\n    return target;\n}\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree);\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (hasObservers(node)) result.observers = getObservers(node).map(nodeToObserverTree);\n    return result;\n}\nfunction intercept(thing, propOrHandler, handler) {\n    if (typeof handler === \"function\") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);\n}\nexports.intercept = intercept;\nfunction interceptInterceptable(thing, handler) {\n    return getAdministration(thing).intercept(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    return getAdministration(thing, property).intercept(handler);\n}\nfunction isComputed(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableObject(value) === false) return false;\n        var atom = getAtom(value, property);\n        return isComputedValue(atom);\n    }\n    return isComputedValue(value);\n}\nexports.isComputed = isComputed;\nfunction isObservable(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableArray(value) || isObservableMap(value)) throw new Error(getMessage(\"m019\"));else if (isObservableObject(value)) {\n            var o = value.$mobx;\n            return o.values && !!o.values[property];\n        }\n        return false;\n    }\n    return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value);\n}\nexports.isObservable = isObservable;\nvar deepDecorator = createDecoratorForEnhancer(deepEnhancer);\nvar shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);\nvar refDecorator = createDecoratorForEnhancer(referenceEnhancer);\nvar deepStructDecorator = createDecoratorForEnhancer(deepStructEnhancer);\nvar refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);\nfunction createObservable(v) {\n    if (v === void 0) {\n        v = undefined;\n    }\n    if (typeof arguments[1] === \"string\") return deepDecorator.apply(null, arguments);\n    invariant(arguments.length <= 1, getMessage(\"m021\"));\n    invariant(!isModifierDescriptor(v), getMessage(\"m020\"));\n    if (isObservable(v)) return v;\n    var res = deepEnhancer(v, undefined, undefined);\n    if (res !== v) return res;\n    return observable.box(v);\n}\nvar IObservableFactories = function () {\n    function IObservableFactories() {}\n    IObservableFactories.prototype.box = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"box\");\n        return new ObservableValue(value, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowBox = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowBox\");\n        return new ObservableValue(value, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.array = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"array\");\n        return new ObservableArray(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowArray = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowArray\");\n        return new ObservableArray(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.map = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"map\");\n        return new ObservableMap(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowMap = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowMap\");\n        return new ObservableMap(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.object = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"object\");\n        var res = {};\n        asObservableObject(res, name);\n        extendObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.shallowObject = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowObject\");\n        var res = {};\n        asObservableObject(res, name);\n        extendShallowObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.ref = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(referenceEnhancer, arguments[0]);\n        } else {\n            return refDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.shallow = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(shallowEnhancer, arguments[0]);\n        } else {\n            return shallowDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.deep = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepEnhancer, arguments[0]);\n        } else {\n            return deepDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.struct = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepStructEnhancer, arguments[0]);\n        } else {\n            return deepStructDecorator.apply(null, arguments);\n        }\n    };\n    return IObservableFactories;\n}();\nexports.IObservableFactories = IObservableFactories;\nvar observable = createObservable;\nexports.observable = observable;\nObject.keys(IObservableFactories.prototype).forEach(function (key) {\n    return observable[key] = IObservableFactories.prototype[key];\n});\nobservable.deep.struct = observable.struct;\nobservable.ref.struct = function () {\n    if (arguments.length < 2) {\n        return createModifierDescriptor(refStructEnhancer, arguments[0]);\n    } else {\n        return refStructDecorator.apply(null, arguments);\n    }\n};\nfunction incorrectlyUsedAsDecorator(methodName) {\n    fail(\"Expected one or two arguments to observable.\" + methodName + \". Did you accidentally try to use observable.\" + methodName + \" as decorator?\");\n}\nfunction createDecoratorForEnhancer(enhancer) {\n    invariant(!!enhancer, \":(\");\n    return createClassPropertyDecorator(function (target, name, baseValue, _, baseDescriptor) {\n        assertPropertyConfigurable(target, name);\n        invariant(!baseDescriptor || !baseDescriptor.get, getMessage(\"m022\"));\n        var adm = asObservableObject(target, undefined);\n        defineObservableProperty(adm, name, baseValue, enhancer);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        setPropertyValue(this, name, value);\n    }, true, false);\n}\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (typeof cbOrFire === \"function\") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);\n}\nexports.observe = observe;\nfunction observeObservable(thing, listener, fireImmediately) {\n    return getAdministration(thing).observe(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    return getAdministration(thing, property).observe(listener, fireImmediately);\n}\nfunction toJS(source, detectCycles, __alreadySeen) {\n    if (detectCycles === void 0) {\n        detectCycles = true;\n    }\n    if (__alreadySeen === void 0) {\n        __alreadySeen = [];\n    }\n    function cache(value) {\n        if (detectCycles) __alreadySeen.push([source, value]);\n        return value;\n    }\n    if (isObservable(source)) {\n        if (detectCycles && __alreadySeen === null) __alreadySeen = [];\n        if (detectCycles && source !== null && (typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") {\n            for (var i = 0, l = __alreadySeen.length; i < l; i++) {\n                if (__alreadySeen[i][0] === source) return __alreadySeen[i][1];\n            }\n        }\n        if (isObservableArray(source)) {\n            var res = cache([]);\n            var toAdd = source.map(function (value) {\n                return toJS(value, detectCycles, __alreadySeen);\n            });\n            res.length = toAdd.length;\n            for (var i = 0, l = toAdd.length; i < l; i++) {\n                res[i] = toAdd[i];\n            }return res;\n        }\n        if (isObservableObject(source)) {\n            var res = cache({});\n            for (var key in source) {\n                res[key] = toJS(source[key], detectCycles, __alreadySeen);\n            }return res;\n        }\n        if (isObservableMap(source)) {\n            var res_1 = cache({});\n            source.forEach(function (value, key) {\n                return res_1[key] = toJS(value, detectCycles, __alreadySeen);\n            });\n            return res_1;\n        }\n        if (isObservableValue(source)) return toJS(source.get(), detectCycles, __alreadySeen);\n    }\n    return source;\n}\nexports.toJS = toJS;\nfunction transaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    deprecated(getMessage(\"m023\"));\n    return runInTransaction.apply(undefined, arguments);\n}\nexports.transaction = transaction;\nfunction runInTransaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    return executeAction(\"\", action);\n}\nfunction log(msg) {\n    console.log(msg);\n    return msg;\n}\nfunction whyRun(thing, prop) {\n    switch (arguments.length) {\n        case 0:\n            thing = globalState.trackingDerivation;\n            if (!thing) return log(getMessage(\"m024\"));\n            break;\n        case 2:\n            thing = getAtom(thing, prop);\n            break;\n    }\n    thing = getAtom(thing);\n    if (isComputedValue(thing)) return log(thing.whyRun());else if (isReaction(thing)) return log(thing.whyRun());\n    return fail(getMessage(\"m025\"));\n}\nexports.whyRun = whyRun;\nfunction createAction(actionName, fn) {\n    invariant(typeof fn === \"function\", getMessage(\"m026\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    var res = function res() {\n        return executeAction(actionName, fn, this, arguments);\n    };\n    res.originalFn = fn;\n    res.isMobxAction = true;\n    return res;\n}\nfunction executeAction(actionName, fn, scope, args) {\n    var runInfo = startAction(actionName, fn, scope, args);\n    try {\n        return fn.apply(scope, args);\n    } finally {\n        endAction(runInfo);\n    }\n}\nfunction startAction(actionName, fn, scope, args) {\n    var notifySpy = isSpyEnabled() && !!actionName;\n    var startTime = 0;\n    if (notifySpy) {\n        startTime = Date.now();\n        var l = args && args.length || 0;\n        var flattendArgs = new Array(l);\n        if (l > 0) for (var i = 0; i < l; i++) {\n            flattendArgs[i] = args[i];\n        }spyReportStart({\n            type: \"action\",\n            name: actionName,\n            fn: fn,\n            object: scope,\n            arguments: flattendArgs\n        });\n    }\n    var prevDerivation = untrackedStart();\n    startBatch();\n    var prevAllowStateChanges = allowStateChangesStart(true);\n    return {\n        prevDerivation: prevDerivation,\n        prevAllowStateChanges: prevAllowStateChanges,\n        notifySpy: notifySpy,\n        startTime: startTime\n    };\n}\nfunction endAction(runInfo) {\n    allowStateChangesEnd(runInfo.prevAllowStateChanges);\n    endBatch();\n    untrackedEnd(runInfo.prevDerivation);\n    if (runInfo.notifySpy) spyReportEnd({ time: Date.now() - runInfo.startTime });\n}\nfunction useStrict(strict) {\n    invariant(globalState.trackingDerivation === null, getMessage(\"m028\"));\n    globalState.strictMode = strict;\n    globalState.allowStateChanges = !strict;\n}\nexports.useStrict = useStrict;\nfunction isStrictModeEnabled() {\n    return globalState.strictMode;\n}\nexports.isStrictModeEnabled = isStrictModeEnabled;\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    var res;\n    try {\n        res = func();\n    } finally {\n        allowStateChangesEnd(prev);\n    }\n    return res;\n}\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nvar BaseAtom = function () {\n    function BaseAtom(name) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        this.name = name;\n        this.isPendingUnobservation = true;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.NOT_TRACKING;\n    }\n    BaseAtom.prototype.onBecomeUnobserved = function () {};\n    BaseAtom.prototype.reportObserved = function () {\n        reportObserved(this);\n    };\n    BaseAtom.prototype.reportChanged = function () {\n        startBatch();\n        propagateChanged(this);\n        endBatch();\n    };\n    BaseAtom.prototype.toString = function () {\n        return this.name;\n    };\n    return BaseAtom;\n}();\nexports.BaseAtom = BaseAtom;\nvar Atom = function (_super) {\n    __extends(Atom, _super);\n    function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        if (onBecomeObservedHandler === void 0) {\n            onBecomeObservedHandler = noop;\n        }\n        if (onBecomeUnobservedHandler === void 0) {\n            onBecomeUnobservedHandler = noop;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.name = name;\n        _this.onBecomeObservedHandler = onBecomeObservedHandler;\n        _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;\n        _this.isPendingUnobservation = false;\n        _this.isBeingTracked = false;\n        return _this;\n    }\n    Atom.prototype.reportObserved = function () {\n        startBatch();\n        _super.prototype.reportObserved.call(this);\n        if (!this.isBeingTracked) {\n            this.isBeingTracked = true;\n            this.onBecomeObservedHandler();\n        }\n        endBatch();\n        return !!globalState.trackingDerivation;\n    };\n    Atom.prototype.onBecomeUnobserved = function () {\n        this.isBeingTracked = false;\n        this.onBecomeUnobservedHandler();\n    };\n    return Atom;\n}(BaseAtom);\nexports.Atom = Atom;\nvar isAtom = createInstanceofPredicate(\"Atom\", BaseAtom);\nvar ComputedValue = function () {\n    function ComputedValue(derivation, scope, compareStructural, name, setter) {\n        this.derivation = derivation;\n        this.scope = scope;\n        this.compareStructural = compareStructural;\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.observing = [];\n        this.newObserving = null;\n        this.isPendingUnobservation = false;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.runId = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.UP_TO_DATE;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.value = undefined;\n        this.isComputing = false;\n        this.isRunningSetter = false;\n        this.name = name || \"ComputedValue@\" + getNextId();\n        if (setter) this.setter = createAction(name + \"-setter\", setter);\n    }\n    ComputedValue.prototype.onBecomeStale = function () {\n        propagateMaybeChanged(this);\n    };\n    ComputedValue.prototype.onBecomeUnobserved = function () {\n        invariant(this.dependenciesState !== IDerivationState.NOT_TRACKING, getMessage(\"m029\"));\n        clearObserving(this);\n        this.value = undefined;\n    };\n    ComputedValue.prototype.get = function () {\n        invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation);\n        if (globalState.inBatch === 0) {\n            startBatch();\n            if (shouldCompute(this)) this.value = this.computeValue(false);\n            endBatch();\n        } else {\n            reportObserved(this);\n            if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this);\n        }\n        var result = this.value;\n        if (isCaughtException(result)) throw result.cause;\n        return result;\n    };\n    ComputedValue.prototype.peek = function () {\n        var res = this.computeValue(false);\n        if (isCaughtException(res)) throw res.cause;\n        return res;\n    };\n    ComputedValue.prototype.set = function (value) {\n        if (this.setter) {\n            invariant(!this.isRunningSetter, \"The setter of computed value '\" + this.name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\");\n            this.isRunningSetter = true;\n            try {\n                this.setter.call(this.scope, value);\n            } finally {\n                this.isRunningSetter = false;\n            }\n        } else invariant(false, \"[ComputedValue '\" + this.name + \"'] It is not possible to assign a new value to a computed value.\");\n    };\n    ComputedValue.prototype.trackAndCompute = function () {\n        if (isSpyEnabled()) {\n            spyReport({\n                object: this.scope,\n                type: \"compute\",\n                fn: this.derivation\n            });\n        }\n        var oldValue = this.value;\n        var newValue = this.value = this.computeValue(true);\n        return isCaughtException(newValue) || valueDidChange(this.compareStructural, newValue, oldValue);\n    };\n    ComputedValue.prototype.computeValue = function (track) {\n        this.isComputing = true;\n        globalState.computationDepth++;\n        var res;\n        if (track) {\n            res = trackDerivedFunction(this, this.derivation, this.scope);\n        } else {\n            try {\n                res = this.derivation.call(this.scope);\n            } catch (e) {\n                res = new CaughtException(e);\n            }\n        }\n        globalState.computationDepth--;\n        this.isComputing = false;\n        return res;\n    };\n    ;\n    ComputedValue.prototype.observe = function (listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function () {\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener({\n                    type: \"update\",\n                    object: _this,\n                    newValue: newValue,\n                    oldValue: prevValue\n                });\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    ComputedValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ComputedValue.prototype.toString = function () {\n        return this.name + \"[\" + this.derivation.toString() + \"]\";\n    };\n    ComputedValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    ;\n    ComputedValue.prototype.whyRun = function () {\n        var isTracking = Boolean(globalState.trackingDerivation);\n        var observing = unique(this.isComputing ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        var observers = unique(getObservers(this).map(function (dep) {\n            return dep.name;\n        }));\n        return \"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + (isTracking ? \"[active] the value of this computation is needed by a reaction\" : this.isComputing ? \"[get] The value of this computed was requested outside a reaction\" : \"[idle] not running at the moment\") + \"\\n\" + (this.dependenciesState === IDerivationState.NOT_TRACKING ? getMessage(\"m032\") : \" * This computation will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this.isComputing && isTracking ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\\n  * If the outcome of this computation changes, the following observers will be re-run:\\n    \" + joinStrings(observers) + \"\\n\");\n    };\n    return ComputedValue;\n}();\nComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf;\nvar isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue);\nvar IDerivationState;\n(function (IDerivationState) {\n    IDerivationState[IDerivationState[\"NOT_TRACKING\"] = -1] = \"NOT_TRACKING\";\n    IDerivationState[IDerivationState[\"UP_TO_DATE\"] = 0] = \"UP_TO_DATE\";\n    IDerivationState[IDerivationState[\"POSSIBLY_STALE\"] = 1] = \"POSSIBLY_STALE\";\n    IDerivationState[IDerivationState[\"STALE\"] = 2] = \"STALE\";\n})(IDerivationState || (IDerivationState = {}));\nexports.IDerivationState = IDerivationState;\nvar CaughtException = function () {\n    function CaughtException(cause) {\n        this.cause = cause;\n    }\n    return CaughtException;\n}();\nfunction isCaughtException(e) {\n    return e instanceof CaughtException;\n}\nfunction shouldCompute(derivation) {\n    switch (derivation.dependenciesState) {\n        case IDerivationState.UP_TO_DATE:\n            return false;\n        case IDerivationState.NOT_TRACKING:\n        case IDerivationState.STALE:\n            return true;\n        case IDerivationState.POSSIBLY_STALE:\n            {\n                var prevUntracked = untrackedStart();\n                var obs = derivation.observing,\n                    l = obs.length;\n                for (var i = 0; i < l; i++) {\n                    var obj = obs[i];\n                    if (isComputedValue(obj)) {\n                        try {\n                            obj.get();\n                        } catch (e) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                        if (derivation.dependenciesState === IDerivationState.STALE) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                    }\n                }\n                changeDependenciesStateTo0(derivation);\n                untrackedEnd(prevUntracked);\n                return false;\n            }\n    }\n}\nfunction isComputingDerivation() {\n    return globalState.trackingDerivation !== null;\n}\nfunction checkIfStateModificationsAreAllowed(atom) {\n    var hasObservers = atom.observers.length > 0;\n    if (globalState.computationDepth > 0 && hasObservers) fail(getMessage(\"m031\") + atom.name);\n    if (!globalState.allowStateChanges && hasObservers) fail(getMessage(globalState.strictMode ? \"m030a\" : \"m030b\") + atom.name);\n}\nfunction trackDerivedFunction(derivation, f, context) {\n    changeDependenciesStateTo0(derivation);\n    derivation.newObserving = new Array(derivation.observing.length + 100);\n    derivation.unboundDepsCount = 0;\n    derivation.runId = ++globalState.runId;\n    var prevTracking = globalState.trackingDerivation;\n    globalState.trackingDerivation = derivation;\n    var result;\n    try {\n        result = f.call(context);\n    } catch (e) {\n        result = new CaughtException(e);\n    }\n    globalState.trackingDerivation = prevTracking;\n    bindDependencies(derivation);\n    return result;\n}\nfunction bindDependencies(derivation) {\n    var prevObserving = derivation.observing;\n    var observing = derivation.observing = derivation.newObserving;\n    derivation.newObserving = null;\n    var i0 = 0,\n        l = derivation.unboundDepsCount;\n    for (var i = 0; i < l; i++) {\n        var dep = observing[i];\n        if (dep.diffValue === 0) {\n            dep.diffValue = 1;\n            if (i0 !== i) observing[i0] = dep;\n            i0++;\n        }\n    }\n    observing.length = i0;\n    l = prevObserving.length;\n    while (l--) {\n        var dep = prevObserving[l];\n        if (dep.diffValue === 0) {\n            removeObserver(dep, derivation);\n        }\n        dep.diffValue = 0;\n    }\n    while (i0--) {\n        var dep = observing[i0];\n        if (dep.diffValue === 1) {\n            dep.diffValue = 0;\n            addObserver(dep, derivation);\n        }\n    }\n}\nfunction clearObserving(derivation) {\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        removeObserver(obs[i], derivation);\n    }derivation.dependenciesState = IDerivationState.NOT_TRACKING;\n    obs.length = 0;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    var res = action();\n    untrackedEnd(prev);\n    return res;\n}\nexports.untracked = untracked;\nfunction untrackedStart() {\n    var prev = globalState.trackingDerivation;\n    globalState.trackingDerivation = null;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.trackingDerivation = prev;\n}\nfunction changeDependenciesStateTo0(derivation) {\n    if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return;\n    derivation.dependenciesState = IDerivationState.UP_TO_DATE;\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nvar persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"];\nvar MobXGlobals = function () {\n    function MobXGlobals() {\n        this.version = 5;\n        this.trackingDerivation = null;\n        this.computationDepth = 0;\n        this.runId = 0;\n        this.mobxGuid = 0;\n        this.inBatch = 0;\n        this.pendingUnobservations = [];\n        this.pendingReactions = [];\n        this.isRunningReactions = false;\n        this.allowStateChanges = true;\n        this.strictMode = false;\n        this.resetId = 0;\n        this.spyListeners = [];\n        this.globalReactionErrorHandlers = [];\n    }\n    return MobXGlobals;\n}();\nvar globalState = new MobXGlobals();\nfunction shareGlobalState() {\n    var global = getGlobal();\n    var ownState = globalState;\n    if (global.__mobservableTrackingStack || global.__mobservableViewStack) throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\");\n    if (global.__mobxGlobal && global.__mobxGlobal.version !== ownState.version) throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\");\n    if (global.__mobxGlobal) globalState = global.__mobxGlobal;else global.__mobxGlobal = ownState;\n}\nfunction getGlobalState() {\n    return globalState;\n}\nfunction registerGlobals() {}\nfunction resetGlobalState() {\n    globalState.resetId++;\n    var defaultGlobals = new MobXGlobals();\n    for (var key in defaultGlobals) {\n        if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];\n    }globalState.allowStateChanges = !globalState.strictMode;\n}\nfunction hasObservers(observable) {\n    return observable.observers && observable.observers.length > 0;\n}\nfunction getObservers(observable) {\n    return observable.observers;\n}\nfunction invariantObservers(observable) {\n    var list = observable.observers;\n    var map = observable.observersIndexes;\n    var l = list.length;\n    for (var i = 0; i < l; i++) {\n        var id = list[i].__mapid;\n        if (i) {\n            invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\");\n        } else {\n            invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldnt be held in map.\");\n        }\n    }\n    invariant(list.length === 0 || Object.keys(map).length === list.length - 1, \"INTERNAL ERROR there is no junk in map\");\n}\nfunction addObserver(observable, node) {\n    var l = observable.observers.length;\n    if (l) {\n        observable.observersIndexes[node.__mapid] = l;\n    }\n    observable.observers[l] = node;\n    if (observable.lowestObserverState > node.dependenciesState) observable.lowestObserverState = node.dependenciesState;\n}\nfunction removeObserver(observable, node) {\n    if (observable.observers.length === 1) {\n        observable.observers.length = 0;\n        queueForUnobservation(observable);\n    } else {\n        var list = observable.observers;\n        var map_1 = observable.observersIndexes;\n        var filler = list.pop();\n        if (filler !== node) {\n            var index = map_1[node.__mapid] || 0;\n            if (index) {\n                map_1[filler.__mapid] = index;\n            } else {\n                delete map_1[filler.__mapid];\n            }\n            list[index] = filler;\n        }\n        delete map_1[node.__mapid];\n    }\n}\nfunction queueForUnobservation(observable) {\n    if (!observable.isPendingUnobservation) {\n        observable.isPendingUnobservation = true;\n        globalState.pendingUnobservations.push(observable);\n    }\n}\nfunction startBatch() {\n    globalState.inBatch++;\n}\nfunction endBatch() {\n    if (--globalState.inBatch === 0) {\n        runReactions();\n        var list = globalState.pendingUnobservations;\n        for (var i = 0; i < list.length; i++) {\n            var observable_1 = list[i];\n            observable_1.isPendingUnobservation = false;\n            if (observable_1.observers.length === 0) {\n                observable_1.onBecomeUnobserved();\n            }\n        }\n        globalState.pendingUnobservations = [];\n    }\n}\nfunction reportObserved(observable) {\n    var derivation = globalState.trackingDerivation;\n    if (derivation !== null) {\n        if (derivation.runId !== observable.lastAccessedBy) {\n            observable.lastAccessedBy = derivation.runId;\n            derivation.newObserving[derivation.unboundDepsCount++] = observable;\n        }\n    } else if (observable.observers.length === 0) {\n        queueForUnobservation(observable);\n    }\n}\nfunction invariantLOS(observable, msg) {\n    var min = getObservers(observable).reduce(function (a, b) {\n        return Math.min(a, b.dependenciesState);\n    }, 2);\n    if (min >= observable.lowestObserverState) return;\n    throw new Error(\"lowestObserverState is wrong for \" + msg + \" because \" + min + \" < \" + observable.lowestObserverState);\n}\nfunction propagateChanged(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale();\n        d.dependenciesState = IDerivationState.STALE;\n    }\n}\nfunction propagateChangeConfirmed(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.POSSIBLY_STALE) d.dependenciesState = IDerivationState.STALE;else if (d.dependenciesState === IDerivationState.UP_TO_DATE) observable.lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nfunction propagateMaybeChanged(observable) {\n    if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return;\n    observable.lowestObserverState = IDerivationState.POSSIBLY_STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {\n            d.dependenciesState = IDerivationState.POSSIBLY_STALE;\n            d.onBecomeStale();\n        }\n    }\n}\nvar Reaction = function () {\n    function Reaction(name, onInvalidate) {\n        if (name === void 0) {\n            name = \"Reaction@\" + getNextId();\n        }\n        this.name = name;\n        this.onInvalidate = onInvalidate;\n        this.observing = [];\n        this.newObserving = [];\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.diffValue = 0;\n        this.runId = 0;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.isDisposed = false;\n        this._isScheduled = false;\n        this._isTrackPending = false;\n        this._isRunning = false;\n    }\n    Reaction.prototype.onBecomeStale = function () {\n        this.schedule();\n    };\n    Reaction.prototype.schedule = function () {\n        if (!this._isScheduled) {\n            this._isScheduled = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    };\n    Reaction.prototype.isScheduled = function () {\n        return this._isScheduled;\n    };\n    Reaction.prototype.runReaction = function () {\n        if (!this.isDisposed) {\n            startBatch();\n            this._isScheduled = false;\n            if (shouldCompute(this)) {\n                this._isTrackPending = true;\n                this.onInvalidate();\n                if (this._isTrackPending && isSpyEnabled()) {\n                    spyReport({\n                        object: this,\n                        type: \"scheduled-reaction\"\n                    });\n                }\n            }\n            endBatch();\n        }\n    };\n    Reaction.prototype.track = function (fn) {\n        startBatch();\n        var notify = isSpyEnabled();\n        var startTime;\n        if (notify) {\n            startTime = Date.now();\n            spyReportStart({\n                object: this,\n                type: \"reaction\",\n                fn: fn\n            });\n        }\n        this._isRunning = true;\n        var result = trackDerivedFunction(this, fn, undefined);\n        this._isRunning = false;\n        this._isTrackPending = false;\n        if (this.isDisposed) {\n            clearObserving(this);\n        }\n        if (isCaughtException(result)) this.reportExceptionInDerivation(result.cause);\n        if (notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n        endBatch();\n    };\n    Reaction.prototype.reportExceptionInDerivation = function (error) {\n        var _this = this;\n        if (this.errorHandler) {\n            this.errorHandler(error, this);\n            return;\n        }\n        var message = \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this;\n        var messageToUser = getMessage(\"m037\");\n        console.error(message || messageToUser, error);\n        if (isSpyEnabled()) {\n            spyReport({\n                type: \"error\",\n                message: message,\n                error: error,\n                object: this\n            });\n        }\n        globalState.globalReactionErrorHandlers.forEach(function (f) {\n            return f(error, _this);\n        });\n    };\n    Reaction.prototype.dispose = function () {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            if (!this._isRunning) {\n                startBatch();\n                clearObserving(this);\n                endBatch();\n            }\n        }\n    };\n    Reaction.prototype.getDisposer = function () {\n        var r = this.dispose.bind(this);\n        r.$mobx = this;\n        r.onError = registerErrorHandler;\n        return r;\n    };\n    Reaction.prototype.toString = function () {\n        return \"Reaction[\" + this.name + \"]\";\n    };\n    Reaction.prototype.whyRun = function () {\n        var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        return \"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this._isRunning ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\";\n    };\n    return Reaction;\n}();\nexports.Reaction = Reaction;\nfunction registerErrorHandler(handler) {\n    invariant(this && this.$mobx && isReaction(this.$mobx), \"Invalid `this`\");\n    invariant(!this.$mobx.errorHandler, \"Only one onErrorHandler can be registered\");\n    this.$mobx.errorHandler = handler;\n}\nfunction onReactionError(handler) {\n    globalState.globalReactionErrorHandlers.push(handler);\n    return function () {\n        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n        if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);\n    };\n}\nvar MAX_REACTION_ITERATIONS = 100;\nvar reactionScheduler = function reactionScheduler(f) {\n    return f();\n};\nfunction runReactions() {\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) return;\n    reactionScheduler(runReactionsHelper);\n}\nfunction runReactionsHelper() {\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    while (allReactions.length > 0) {\n        if (++iterations === MAX_REACTION_ITERATIONS) {\n            console.error(\"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0]));\n            allReactions.splice(0);\n        }\n        var remainingReactions = allReactions.splice(0);\n        for (var i = 0, l = remainingReactions.length; i < l; i++) {\n            remainingReactions[i].runReaction();\n        }\n    }\n    globalState.isRunningReactions = false;\n}\nvar isReaction = createInstanceofPredicate(\"Reaction\", Reaction);\nfunction setReactionScheduler(fn) {\n    var baseScheduler = reactionScheduler;\n    reactionScheduler = function reactionScheduler(f) {\n        return fn(function () {\n            return baseScheduler(f);\n        });\n    };\n}\nfunction isSpyEnabled() {\n    return !!globalState.spyListeners.length;\n}\nfunction spyReport(event) {\n    if (!globalState.spyListeners.length) return;\n    var listeners = globalState.spyListeners;\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](event);\n    }\n}\nfunction spyReportStart(event) {\n    var change = objectAssign({}, event, { spyReportStart: true });\n    spyReport(change);\n}\nvar END_EVENT = { spyReportEnd: true };\nfunction spyReportEnd(change) {\n    if (change) spyReport(objectAssign({}, change, END_EVENT));else spyReport(END_EVENT);\n}\nfunction spy(listener) {\n    globalState.spyListeners.push(listener);\n    return once(function () {\n        var idx = globalState.spyListeners.indexOf(listener);\n        if (idx !== -1) globalState.spyListeners.splice(idx, 1);\n    });\n}\nexports.spy = spy;\nfunction hasInterceptors(interceptable) {\n    return interceptable.interceptors && interceptable.interceptors.length > 0;\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);\n    interceptors.push(handler);\n    return once(function () {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1) interceptors.splice(idx, 1);\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    try {\n        var interceptors = interceptable.interceptors;\n        if (interceptors) for (var i = 0, l = interceptors.length; i < l; i++) {\n            change = interceptors[i](change);\n            invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\");\n            if (!change) break;\n        }\n        return change;\n    } finally {\n        untrackedEnd(prevU);\n    }\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners && listenable.changeListeners.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners || (listenable.changeListeners = []);\n    listeners.push(handler);\n    return once(function () {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1) listeners.splice(idx, 1);\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners;\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](change);\n    }\n    untrackedEnd(prevU);\n}\nfunction asReference(value) {\n    deprecated(\"asReference is deprecated, use observable.ref instead\");\n    return observable.ref(value);\n}\nexports.asReference = asReference;\nfunction asStructure(value) {\n    deprecated(\"asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.\");\n    return observable.struct(value);\n}\nexports.asStructure = asStructure;\nfunction asFlat(value) {\n    deprecated(\"asFlat is deprecated, use observable.shallow instead\");\n    return observable.shallow(value);\n}\nexports.asFlat = asFlat;\nfunction asMap(data) {\n    deprecated(\"asMap is deprecated, use observable.map or observable.shallowMap instead\");\n    return observable.map(data || {});\n}\nexports.asMap = asMap;\nfunction isModifierDescriptor(thing) {\n    return (typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null && thing.isMobxModifierDescriptor === true;\n}\nexports.isModifierDescriptor = isModifierDescriptor;\nfunction createModifierDescriptor(enhancer, initialValue) {\n    invariant(!isModifierDescriptor(initialValue), \"Modifiers cannot be nested\");\n    return {\n        isMobxModifierDescriptor: true,\n        initialValue: initialValue,\n        enhancer: enhancer\n    };\n}\nfunction deepEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return observable.array(v, name);\n    if (isPlainObject(v)) return observable.object(v, name);\n    if (isES6Map(v)) return observable.map(v, name);\n    return v;\n}\nfunction shallowEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (v === undefined || v === null) return v;\n    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v)) return v;\n    if (Array.isArray(v)) return observable.shallowArray(v, name);\n    if (isPlainObject(v)) return observable.shallowObject(v, name);\n    if (isES6Map(v)) return observable.shallowMap(v, name);\n    return fail(\"The shallow modifier / decorator can only used in combination with arrays, objects and maps\");\n}\nfunction referenceEnhancer(newValue) {\n    return newValue;\n}\nfunction deepStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return new ObservableArray(v, deepStructEnhancer, name);\n    if (isES6Map(v)) return new ObservableMap(v, deepStructEnhancer, name);\n    if (isPlainObject(v)) {\n        var res = {};\n        asObservableObject(res, name);\n        extendObservableHelper(res, deepStructEnhancer, [v]);\n        return res;\n    }\n    return v;\n}\nfunction refStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    return v;\n}\nvar MAX_SPLICE_SIZE = 10000;\nvar safariPrototypeSetterInheritanceBug = function () {\n    var v = false;\n    var p = {};\n    Object.defineProperty(p, \"0\", { set: function set() {\n            v = true;\n        } });\n    Object.create(p)[\"0\"] = 1;\n    return v === false;\n}();\nvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\nvar StubArray = function () {\n    function StubArray() {}\n    return StubArray;\n}();\nStubArray.prototype = [];\nvar ObservableArrayAdministration = function () {\n    function ObservableArrayAdministration(name, enhancer, array, owned) {\n        this.array = array;\n        this.owned = owned;\n        this.lastKnownLength = 0;\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.atom = new BaseAtom(name || \"ObservableArray@\" + getNextId());\n        this.enhancer = function (newV, oldV) {\n            return enhancer(newV, oldV, name + \"[..]\");\n        };\n    }\n    ObservableArrayAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        if (fireImmediately) {\n            listener({\n                object: this.array,\n                type: \"splice\",\n                index: 0,\n                added: this.values.slice(),\n                addedCount: this.values.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    ObservableArrayAdministration.prototype.getArrayLength = function () {\n        this.atom.reportObserved();\n        return this.values.length;\n    };\n    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {\n        if (typeof newLength !== \"number\" || newLength < 0) throw new Error(\"[mobx.array] Out of range: \" + newLength);\n        var currentLength = this.values.length;\n        if (newLength === currentLength) return;else if (newLength > currentLength) {\n            var newItems = new Array(newLength - currentLength);\n            for (var i = 0; i < newLength - currentLength; i++) {\n                newItems[i] = undefined;\n            }this.spliceWithArray(currentLength, 0, newItems);\n        } else this.spliceWithArray(newLength, currentLength - newLength);\n    };\n    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {\n        if (oldLength !== this.lastKnownLength) throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\");\n        this.lastKnownLength += delta;\n        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1);\n    };\n    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        var _this = this;\n        checkIfStateModificationsAreAllowed(this.atom);\n        var length = this.values.length;\n        if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);\n        if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        if (newItems === undefined) newItems = [];\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.array,\n                type: \"splice\",\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change) return EMPTY_ARRAY;\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.map(function (v) {\n            return _this.enhancer(v, undefined);\n        });\n        var lengthDelta = newItems.length - deleteCount;\n        this.updateArrayLength(length, lengthDelta);\n        var res = this.spliceItemsIntoValues(index, deleteCount, newItems);\n        if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res);\n        return res;\n    };\n    ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) {\n        if (newItems.length < MAX_SPLICE_SIZE) {\n            return (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));\n        } else {\n            var res = this.values.slice(index, index + deleteCount);\n            this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount));\n            return res;\n        }\n        var _a;\n    };\n    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"update\",\n            index: index, newValue: newValue, oldValue: oldValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"splice\",\n            index: index, removed: removed, added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    return ObservableArrayAdministration;\n}();\nvar ObservableArray = function (_super) {\n    __extends(ObservableArray, _super);\n    function ObservableArray(initialValues, enhancer, name, owned) {\n        if (name === void 0) {\n            name = \"ObservableArray@\" + getNextId();\n        }\n        if (owned === void 0) {\n            owned = false;\n        }\n        var _this = _super.call(this) || this;\n        var adm = new ObservableArrayAdministration(name, enhancer, _this, owned);\n        addHiddenFinalProp(_this, \"$mobx\", adm);\n        if (initialValues && initialValues.length) {\n            adm.updateArrayLength(0, initialValues.length);\n            adm.values = initialValues.map(function (v) {\n                return enhancer(v, undefined, name + \"[..]\");\n            });\n            adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY);\n        } else {\n            adm.values = [];\n        }\n        if (safariPrototypeSetterInheritanceBug) {\n            Object.defineProperty(adm.array, \"0\", ENTRY_0);\n        }\n        return _this;\n    }\n    ObservableArray.prototype.intercept = function (handler) {\n        return this.$mobx.intercept(handler);\n    };\n    ObservableArray.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        return this.$mobx.observe(listener, fireImmediately);\n    };\n    ObservableArray.prototype.clear = function () {\n        return this.splice(0);\n    };\n    ObservableArray.prototype.concat = function () {\n        var arrays = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            arrays[_i] = arguments[_i];\n        }\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) {\n            return isObservableArray(a) ? a.peek() : a;\n        }));\n    };\n    ObservableArray.prototype.replace = function (newItems) {\n        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);\n    };\n    ObservableArray.prototype.toJS = function () {\n        return this.slice();\n    };\n    ObservableArray.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableArray.prototype.peek = function () {\n        return this.$mobx.values;\n    };\n    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {\n        if (fromIndex === void 0) {\n            fromIndex = 0;\n        }\n        this.$mobx.atom.reportObserved();\n        var items = this.$mobx.values,\n            l = items.length;\n        for (var i = fromIndex; i < l; i++) {\n            if (predicate.call(thisArg, items[i], i, this)) return items[i];\n        }return undefined;\n    };\n    ObservableArray.prototype.splice = function (index, deleteCount) {\n        var newItems = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            newItems[_i - 2] = arguments[_i];\n        }\n        switch (arguments.length) {\n            case 0:\n                return [];\n            case 1:\n                return this.$mobx.spliceWithArray(index);\n            case 2:\n                return this.$mobx.spliceWithArray(index, deleteCount);\n        }\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.push = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(adm.values.length, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.pop = function () {\n        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];\n    };\n    ObservableArray.prototype.shift = function () {\n        return this.splice(0, 1)[0];\n    };\n    ObservableArray.prototype.unshift = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(0, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.reverse = function () {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.reverse.apply(clone, arguments);\n    };\n    ObservableArray.prototype.sort = function (compareFn) {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.sort.apply(clone, arguments);\n    };\n    ObservableArray.prototype.remove = function (value) {\n        var idx = this.$mobx.values.indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    };\n    ObservableArray.prototype.move = function (fromIndex, toIndex) {\n        function checkIndex(index) {\n            if (index < 0) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\n            }\n            var length = this.$mobx.values.length;\n            if (index >= length) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\n            }\n        }\n        checkIndex.call(this, fromIndex);\n        checkIndex.call(this, toIndex);\n        if (fromIndex === toIndex) {\n            return;\n        }\n        var oldItems = this.$mobx.values;\n        var newItems;\n        if (fromIndex < toIndex) {\n            newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1));\n        } else {\n            newItems = oldItems.slice(0, toIndex).concat([oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\n        }\n        this.replace(newItems);\n    };\n    ObservableArray.prototype.toString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toString.apply(this.$mobx.values, arguments);\n    };\n    ObservableArray.prototype.toLocaleString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toLocaleString.apply(this.$mobx.values, arguments);\n    };\n    return ObservableArray;\n}(StubArray);\ndeclareIterator(ObservableArray.prototype, function () {\n    return arrayAsIterator(this.slice());\n});\nmakeNonEnumerable(ObservableArray.prototype, [\"constructor\", \"intercept\", \"observe\", \"clear\", \"concat\", \"replace\", \"toJS\", \"toJSON\", \"peek\", \"find\", \"splice\", \"spliceWithArray\", \"push\", \"pop\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"remove\", \"move\", \"toString\", \"toLocaleString\"]);\nObject.defineProperty(ObservableArray.prototype, \"length\", {\n    enumerable: false,\n    configurable: true,\n    get: function get() {\n        return this.$mobx.getArrayLength();\n    },\n    set: function set(newLength) {\n        this.$mobx.setArrayLength(newLength);\n    }\n});\n[\"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function (funcName) {\n    var baseFunc = Array.prototype[funcName];\n    invariant(typeof baseFunc === \"function\", \"Base function not defined on Array prototype: '\" + funcName + \"'\");\n    addHiddenProp(ObservableArray.prototype, funcName, function () {\n        this.$mobx.atom.reportObserved();\n        return baseFunc.apply(this.$mobx.values, arguments);\n    });\n});\nvar ENTRY_0 = {\n    configurable: true,\n    enumerable: false,\n    set: createArraySetter(0),\n    get: createArrayGetter(0)\n};\nfunction createArrayBufferItem(index) {\n    var set = createArraySetter(index);\n    var get = createArrayGetter(index);\n    Object.defineProperty(ObservableArray.prototype, \"\" + index, {\n        enumerable: false,\n        configurable: true,\n        set: set, get: get\n    });\n}\nfunction createArraySetter(index) {\n    return function (newValue) {\n        var adm = this.$mobx;\n        var values = adm.values;\n        if (index < values.length) {\n            checkIfStateModificationsAreAllowed(adm.atom);\n            var oldValue = values[index];\n            if (hasInterceptors(adm)) {\n                var change = interceptChange(adm, {\n                    type: \"update\",\n                    object: adm.array,\n                    index: index, newValue: newValue\n                });\n                if (!change) return;\n                newValue = change.newValue;\n            }\n            newValue = adm.enhancer(newValue, oldValue);\n            var changed = newValue !== oldValue;\n            if (changed) {\n                values[index] = newValue;\n                adm.notifyArrayChildUpdate(index, newValue, oldValue);\n            }\n        } else if (index === values.length) {\n            adm.spliceWithArray(index, 0, [newValue]);\n        } else throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length);\n    };\n}\nfunction createArrayGetter(index) {\n    return function () {\n        var impl = this.$mobx;\n        if (impl) {\n            if (index < impl.values.length) {\n                impl.atom.reportObserved();\n                return impl.values[index];\n            }\n            console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\");\n        }\n        return undefined;\n    };\n}\nfunction reserveArrayBuffer(max) {\n    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) {\n        createArrayBufferItem(index);\n    }OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n}\nreserveArrayBuffer(1000);\nvar isObservableArrayAdministration = createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\nfunction isObservableArray(thing) {\n    return isObject(thing) && isObservableArrayAdministration(thing.$mobx);\n}\nexports.isObservableArray = isObservableArray;\nvar ObservableMapMarker = {};\nvar ObservableMap = function () {\n    function ObservableMap(initialData, enhancer, name) {\n        if (enhancer === void 0) {\n            enhancer = deepEnhancer;\n        }\n        if (name === void 0) {\n            name = \"ObservableMap@\" + getNextId();\n        }\n        this.enhancer = enhancer;\n        this.name = name;\n        this.$mobx = ObservableMapMarker;\n        this._data = {};\n        this._hasMap = {};\n        this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + \".keys()\", true);\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.merge(initialData);\n    }\n    ObservableMap.prototype._has = function (key) {\n        return typeof this._data[key] !== \"undefined\";\n    };\n    ObservableMap.prototype.has = function (key) {\n        if (!this.isValidKey(key)) return false;\n        key = \"\" + key;\n        if (this._hasMap[key]) return this._hasMap[key].get();\n        return this._updateHasMapEntry(key, false).get();\n    };\n    ObservableMap.prototype.set = function (key, value) {\n        this.assertValidKey(key);\n        key = \"\" + key;\n        var hasKey = this._has(key);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? \"update\" : \"add\",\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change) return this;\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this._updateValue(key, value);\n        } else {\n            this._addValue(key, value);\n        }\n        return this;\n    };\n    ObservableMap.prototype.delete = function (key) {\n        var _this = this;\n        this.assertValidKey(key);\n        key = \"\" + key;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: \"delete\",\n                object: this,\n                name: key\n            });\n            if (!change) return false;\n        }\n        if (this._has(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"delete\",\n                object: this,\n                oldValue: this._data[key].value,\n                name: key\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            runInTransaction(function () {\n                _this._keys.remove(key);\n                _this._updateHasMapEntry(key, false);\n                var observable = _this._data[key];\n                observable.setNewValue(undefined);\n                _this._data[key] = undefined;\n            });\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n            return true;\n        }\n        return false;\n    };\n    ObservableMap.prototype._updateHasMapEntry = function (key, value) {\n        var entry = this._hasMap[key];\n        if (entry) {\n            entry.setNewValue(value);\n        } else {\n            entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + \".\" + key + \"?\", false);\n        }\n        return entry;\n    };\n    ObservableMap.prototype._updateValue = function (name, newValue) {\n        var observable = this._data[name];\n        newValue = observable.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"update\",\n                object: this,\n                oldValue: observable.value,\n                name: name, newValue: newValue\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            observable.setNewValue(newValue);\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableMap.prototype._addValue = function (name, newValue) {\n        var _this = this;\n        runInTransaction(function () {\n            var observable = _this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + \".\" + name, false);\n            newValue = observable.value;\n            _this._updateHasMapEntry(name, true);\n            _this._keys.push(name);\n        });\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            type: \"add\",\n            object: this,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableMap.prototype.get = function (key) {\n        key = \"\" + key;\n        if (this.has(key)) return this._data[key].get();\n        return undefined;\n    };\n    ObservableMap.prototype.keys = function () {\n        return arrayAsIterator(this._keys.slice());\n    };\n    ObservableMap.prototype.values = function () {\n        return arrayAsIterator(this._keys.map(this.get, this));\n    };\n    ObservableMap.prototype.entries = function () {\n        var _this = this;\n        return arrayAsIterator(this._keys.map(function (key) {\n            return [key, _this.get(key)];\n        }));\n    };\n    ObservableMap.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        this.keys().forEach(function (key) {\n            return callback.call(thisArg, _this.get(key), key, _this);\n        });\n    };\n    ObservableMap.prototype.merge = function (other) {\n        var _this = this;\n        if (isObservableMap(other)) {\n            other = other.toJS();\n        }\n        runInTransaction(function () {\n            if (isPlainObject(other)) Object.keys(other).forEach(function (key) {\n                return _this.set(key, other[key]);\n            });else if (Array.isArray(other)) other.forEach(function (_a) {\n                var key = _a[0],\n                    value = _a[1];\n                return _this.set(key, value);\n            });else if (isES6Map(other)) other.forEach(function (value, key) {\n                return _this.set(key, value);\n            });else if (other !== null && other !== undefined) fail(\"Cannot initialize map from \" + other);\n        });\n        return this;\n    };\n    ObservableMap.prototype.clear = function () {\n        var _this = this;\n        runInTransaction(function () {\n            untracked(function () {\n                _this.keys().forEach(_this.delete, _this);\n            });\n        });\n    };\n    ObservableMap.prototype.replace = function (values) {\n        var _this = this;\n        runInTransaction(function () {\n            _this.clear();\n            _this.merge(values);\n        });\n        return this;\n    };\n    Object.defineProperty(ObservableMap.prototype, \"size\", {\n        get: function get() {\n            return this._keys.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObservableMap.prototype.toJS = function () {\n        var _this = this;\n        var res = {};\n        this.keys().forEach(function (key) {\n            return res[key] = _this.get(key);\n        });\n        return res;\n    };\n    ObservableMap.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableMap.prototype.isValidKey = function (key) {\n        if (key === null || key === undefined) return false;\n        if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"boolean\") return true;\n        return false;\n    };\n    ObservableMap.prototype.assertValidKey = function (key) {\n        if (!this.isValidKey(key)) throw new Error(\"[mobx.map] Invalid key: '\" + key + \"', only strings, numbers and booleans are accepted as key in observable maps.\");\n    };\n    ObservableMap.prototype.toString = function () {\n        var _this = this;\n        return this.name + \"[{ \" + this.keys().map(function (key) {\n            return key + \": \" + (\"\" + _this.get(key));\n        }).join(\", \") + \" }]\";\n    };\n    ObservableMap.prototype.observe = function (listener, fireImmediately) {\n        invariant(fireImmediately !== true, getMessage(\"m033\"));\n        return registerListener(this, listener);\n    };\n    ObservableMap.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableMap;\n}();\nexports.ObservableMap = ObservableMap;\ndeclareIterator(ObservableMap.prototype, function () {\n    return this.entries();\n});\nfunction map(initialValues) {\n    deprecated(\"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\");\n    return observable.map(initialValues);\n}\nexports.map = map;\nvar isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap);\nexports.isObservableMap = isObservableMap;\nvar ObservableObjectAdministration = function () {\n    function ObservableObjectAdministration(target, name) {\n        this.target = target;\n        this.name = name;\n        this.values = {};\n        this.changeListeners = null;\n        this.interceptors = null;\n    }\n    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {\n        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\");\n        return registerListener(this, callback);\n    };\n    ObservableObjectAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableObjectAdministration;\n}();\nfunction asObservableObject(target, name) {\n    if (isObservableObject(target)) return target.$mobx;\n    invariant(Object.isExtensible(target), getMessage(\"m035\"));\n    if (!isPlainObject(target)) name = (target.constructor.name || \"ObservableObject\") + \"@\" + getNextId();\n    if (!name) name = \"ObservableObject@\" + getNextId();\n    var adm = new ObservableObjectAdministration(target, name);\n    addHiddenFinalProp(target, \"$mobx\", adm);\n    return adm;\n}\nfunction defineObservablePropertyFromDescriptor(adm, propName, descriptor, defaultEnhancer) {\n    if (adm.values[propName]) {\n        invariant(\"value\" in descriptor, \"The property \" + propName + \" in \" + adm.name + \" is already observable, cannot redefine it as computed property\");\n        adm.target[propName] = descriptor.value;\n        return;\n    }\n    if (\"value\" in descriptor) {\n        if (isModifierDescriptor(descriptor.value)) {\n            var modifierDescriptor = descriptor.value;\n            defineObservableProperty(adm, propName, modifierDescriptor.initialValue, modifierDescriptor.enhancer);\n        } else if (isAction(descriptor.value) && descriptor.value.autoBind === true) {\n            defineBoundAction(adm.target, propName, descriptor.value.originalFn);\n        } else if (isComputedValue(descriptor.value)) {\n            defineComputedPropertyFromComputedValue(adm, propName, descriptor.value);\n        } else {\n            defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer);\n        }\n    } else {\n        defineComputedProperty(adm, propName, descriptor.get, descriptor.set, false, true);\n    }\n}\nfunction defineObservableProperty(adm, propName, newValue, enhancer) {\n    assertPropertyConfigurable(adm.target, propName);\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            object: adm.target,\n            name: propName,\n            type: \"add\",\n            newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    var observable = adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + \".\" + propName, false);\n    newValue = observable.value;\n    Object.defineProperty(adm.target, propName, generateObservablePropConfig(propName));\n    notifyPropertyAddition(adm, adm.target, propName, newValue);\n}\nfunction defineComputedProperty(adm, propName, getter, setter, compareStructural, asInstanceProperty) {\n    if (asInstanceProperty) assertPropertyConfigurable(adm.target, propName);\n    adm.values[propName] = new ComputedValue(getter, adm.target, compareStructural, adm.name + \".\" + propName, setter);\n    if (asInstanceProperty) {\n        Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n    }\n}\nfunction defineComputedPropertyFromComputedValue(adm, propName, computedValue) {\n    var name = adm.name + \".\" + propName;\n    computedValue.name = name;\n    if (!computedValue.scope) computedValue.scope = adm.target;\n    adm.values[propName] = computedValue;\n    Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n}\nvar observablePropertyConfigs = {};\nvar computedPropertyConfigs = {};\nfunction generateObservablePropConfig(propName) {\n    return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            setPropertyValue(this, propName, v);\n        }\n    });\n}\nfunction generateComputedPropConfig(propName) {\n    return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: false,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            return this.$mobx.values[propName].set(v);\n        }\n    });\n}\nfunction setPropertyValue(instance, name, newValue) {\n    var adm = instance.$mobx;\n    var observable = adm.values[name];\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            type: \"update\",\n            object: instance,\n            name: name, newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    newValue = observable.prepareNewValue(newValue);\n    if (newValue !== UNCHANGED) {\n        var notify = hasListeners(adm);\n        var notifySpy = isSpyEnabled();\n        var change = notify || notifySpy ? {\n            type: \"update\",\n            object: instance,\n            oldValue: observable.value,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        observable.setNewValue(newValue);\n        if (notify) notifyListeners(adm, change);\n        if (notifySpy) spyReportEnd();\n    }\n}\nfunction notifyPropertyAddition(adm, object, name, newValue) {\n    var notify = hasListeners(adm);\n    var notifySpy = isSpyEnabled();\n    var change = notify || notifySpy ? {\n        type: \"add\",\n        object: object, name: name, newValue: newValue\n    } : null;\n    if (notifySpy) spyReportStart(change);\n    if (notify) notifyListeners(adm, change);\n    if (notifySpy) spyReportEnd();\n}\nvar isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\nfunction isObservableObject(thing) {\n    if (isObject(thing)) {\n        runLazyInitializers(thing);\n        return isObservableObjectAdministration(thing.$mobx);\n    }\n    return false;\n}\nexports.isObservableObject = isObservableObject;\nvar UNCHANGED = {};\nvar ObservableValue = function (_super) {\n    __extends(ObservableValue, _super);\n    function ObservableValue(value, enhancer, name, notifySpy) {\n        if (name === void 0) {\n            name = \"ObservableValue@\" + getNextId();\n        }\n        if (notifySpy === void 0) {\n            notifySpy = true;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.enhancer = enhancer;\n        _this.hasUnreportedChange = false;\n        _this.value = enhancer(value, undefined, name);\n        if (notifySpy && isSpyEnabled()) {\n            spyReport({ type: \"create\", object: _this, newValue: _this.value });\n        }\n        return _this;\n    }\n    ObservableValue.prototype.set = function (newValue) {\n        var oldValue = this.value;\n        newValue = this.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if (notifySpy) {\n                spyReportStart({\n                    type: \"update\",\n                    object: this,\n                    newValue: newValue, oldValue: oldValue\n                });\n            }\n            this.setNewValue(newValue);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableValue.prototype.prepareNewValue = function (newValue) {\n        checkIfStateModificationsAreAllowed(this);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue });\n            if (!change) return UNCHANGED;\n            newValue = change.newValue;\n        }\n        newValue = this.enhancer(newValue, this.value, this.name);\n        return this.value !== newValue ? newValue : UNCHANGED;\n    };\n    ObservableValue.prototype.setNewValue = function (newValue) {\n        var oldValue = this.value;\n        this.value = newValue;\n        this.reportChanged();\n        if (hasListeners(this)) {\n            notifyListeners(this, {\n                type: \"update\",\n                object: this,\n                newValue: newValue,\n                oldValue: oldValue\n            });\n        }\n    };\n    ObservableValue.prototype.get = function () {\n        this.reportObserved();\n        return this.value;\n    };\n    ObservableValue.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableValue.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately) listener({\n            object: this,\n            type: \"update\",\n            newValue: this.value,\n            oldValue: undefined\n        });\n        return registerListener(this, listener);\n    };\n    ObservableValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ObservableValue.prototype.toString = function () {\n        return this.name + \"[\" + this.value + \"]\";\n    };\n    ObservableValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    return ObservableValue;\n}(BaseAtom);\nObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf;\nvar isObservableValue = createInstanceofPredicate(\"ObservableValue\", ObservableValue);\nexports.isBoxedObservable = isObservableValue;\nfunction getAtom(thing, property) {\n    if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            invariant(property === undefined, getMessage(\"m036\"));\n            return thing.$mobx.atom;\n        }\n        if (isObservableMap(thing)) {\n            var anyThing = thing;\n            if (property === undefined) return getAtom(anyThing._keys);\n            var observable_2 = anyThing._data[property] || anyThing._hasMap[property];\n            invariant(!!observable_2, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\");\n            return observable_2;\n        }\n        runLazyInitializers(thing);\n        if (isObservableObject(thing)) {\n            if (!property) return fail(\"please specify a property\");\n            var observable_3 = thing.$mobx.values[property];\n            invariant(!!observable_3, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\");\n            return observable_3;\n        }\n        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n            return thing;\n        }\n    } else if (typeof thing === \"function\") {\n        if (isReaction(thing.$mobx)) {\n            return thing.$mobx;\n        }\n    }\n    return fail(\"Cannot obtain atom from \" + thing);\n}\nfunction getAdministration(thing, property) {\n    invariant(thing, \"Expecting some object\");\n    if (property !== undefined) return getAdministration(getAtom(thing, property));\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;\n    if (isObservableMap(thing)) return thing;\n    runLazyInitializers(thing);\n    if (thing.$mobx) return thing.$mobx;\n    invariant(false, \"Cannot obtain administration from \" + thing);\n}\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing)) named = getAdministration(thing);else named = getAtom(thing);\n    return named.name;\n}\nfunction createClassPropertyDecorator(onInitialize, _get, _set, enumerable, allowCustomArguments) {\n    function classPropertyDecorator(target, key, descriptor, customArgs, argLen) {\n        if (argLen === void 0) {\n            argLen = 0;\n        }\n        invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\");\n        if (!descriptor) {\n            var newDescriptor = {\n                enumerable: enumerable,\n                configurable: true,\n                get: function get() {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {\n                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);\n                    } else {\n                        _set.call(this, key, v);\n                    }\n                }\n            };\n            if (arguments.length < 3 || arguments.length === 5 && argLen < 3) {\n                Object.defineProperty(target, key, newDescriptor);\n            }\n            return newDescriptor;\n        } else {\n            if (!hasOwnProperty(target, \"__mobxLazyInitializers\")) {\n                addHiddenProp(target, \"__mobxLazyInitializers\", target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice() || []);\n            }\n            var value_1 = descriptor.value,\n                initializer_1 = descriptor.initializer;\n            target.__mobxLazyInitializers.push(function (instance) {\n                onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor);\n            });\n            return {\n                enumerable: enumerable, configurable: true,\n                get: function get() {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    _set.call(this, key, v);\n                }\n            };\n        }\n    }\n    if (allowCustomArguments) {\n        return function () {\n            if (quacksLikeADecorator(arguments)) return classPropertyDecorator.apply(null, arguments);\n            var outerArgs = arguments;\n            var argLen = arguments.length;\n            return function (target, key, descriptor) {\n                return classPropertyDecorator(target, key, descriptor, outerArgs, argLen);\n            };\n        };\n    }\n    return classPropertyDecorator;\n}\nfunction typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {\n    if (!hasOwnProperty(instance, \"__mobxInitializedProps\")) addHiddenProp(instance, \"__mobxInitializedProps\", {});\n    instance.__mobxInitializedProps[key] = true;\n    onInitialize(instance, key, v, customArgs, baseDescriptor);\n}\nfunction runLazyInitializers(instance) {\n    if (instance.__mobxDidRunLazyInitializers === true) return;\n    if (instance.__mobxLazyInitializers) {\n        addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true);\n        instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) {\n            return initializer(instance);\n        });\n    }\n}\nfunction quacksLikeADecorator(args) {\n    return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\";\n}\nfunction iteratorSymbol() {\n    return typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n}\nvar IS_ITERATING_MARKER = \"__$$iterating\";\nfunction arrayAsIterator(array) {\n    invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\");\n    addHiddenFinalProp(array, IS_ITERATING_MARKER, true);\n    var idx = -1;\n    addHiddenFinalProp(array, \"next\", function next() {\n        idx++;\n        return {\n            done: idx >= this.length,\n            value: idx < this.length ? this[idx] : undefined\n        };\n    });\n    return array;\n}\nfunction declareIterator(prototType, iteratorFactory) {\n    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);\n}\nvar messages = {\n    \"m001\": \"It is not allowed to assign new values to @action fields\",\n    \"m002\": \"`runInAction` expects a function\",\n    \"m003\": \"`runInAction` expects a function without arguments\",\n    \"m004\": \"autorun expects a function\",\n    \"m005\": \"Warning: attempted to pass an action to autorun. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m006\": \"Warning: attempted to pass an action to autorunAsync. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m007\": \"reaction only accepts 2 or 3 arguments. If migrating from MobX 2, please provide an options object\",\n    \"m008\": \"wrapping reaction expression in `asReference` is no longer supported, use options object instead\",\n    \"m009\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\",\n    \"m010\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\",\n    \"m011\": \"First argument to `computed` should be an expression. If using computed as decorator, don't pass it arguments\",\n    \"m012\": \"computed takes one or two arguments if used as function\",\n    \"m013\": \"[mobx.expr] 'expr' should only be used inside other reactive functions.\",\n    \"m014\": \"extendObservable expected 2 or more arguments\",\n    \"m015\": \"extendObservable expects an object as first argument\",\n    \"m016\": \"extendObservable should not be used on maps, use map.merge instead\",\n    \"m017\": \"all arguments of extendObservable should be objects\",\n    \"m018\": \"extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540\",\n    \"m019\": \"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\",\n    \"m020\": \"modifiers can only be used for individual object properties\",\n    \"m021\": \"observable expects zero or one arguments\",\n    \"m022\": \"@observable can not be used on getters, use @computed instead\",\n    \"m023\": \"Using `transaction` is deprecated, use `runInAction` or `(@)action` instead.\",\n    \"m024\": \"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested its value.\",\n    \"m025\": \"whyRun can only be used on reactions and computed values\",\n    \"m026\": \"`action` can only be invoked on functions\",\n    \"m028\": \"It is not allowed to set `useStrict` when a derivation is running\",\n    \"m029\": \"INTERNAL ERROR only onBecomeUnobserved shouldn't be called twice in a row\",\n    \"m030a\": \"Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: \",\n    \"m030b\": \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: \",\n    \"m031\": \"Computed values are not allowed to not cause side effects by changing observables that are already being observed. Tried to modify: \",\n    \"m032\": \"* This computation is suspended (not in use by any reaction) and won't run automatically.\\n\tDidn't expect this computation to be suspended at this point?\\n\t  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n\t  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\",\n    \"m033\": \"`observe` doesn't support the fire immediately property for observable maps.\",\n    \"m034\": \"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\",\n    \"m035\": \"Cannot make the designated object observable; it is not extensible\",\n    \"m036\": \"It is not possible to get index atoms from arrays\",\n    \"m037\": \"Hi there! I'm sorry you have just run into an exception.\\nIf your debugger ends up here, know that some reaction (like the render() of an observer component, autorun or reaction)\\nthrew an exception and that mobx caught it, to avoid that it brings the rest of your application down.\\nThe original cause of the exception (the code that caused this reaction to run (again)), is still in the stack.\\n\\nHowever, more interesting is the actual stack trace of the error itself.\\nHopefully the error is an instanceof Error, because in that case you can inspect the original stack of the error from where it was thrown.\\nSee `error.stack` property, or press the very subtle \\\"(...)\\\" link you see near the console.error message that probably brought you here.\\nThat stack is more interesting than the stack of this console.error itself.\\n\\nIf the exception you see is an exception you created yourself, make sure to use `throw new Error(\\\"Oops\\\")` instead of `throw \\\"Oops\\\"`,\\nbecause the javascript environment will only preserve the original stack trace in the first form.\\n\\nYou can also make sure the debugger pauses the next time this very same exception is thrown by enabling \\\"Pause on caught exception\\\".\\n(Note that it might pause on many other, unrelated exception as well).\\n\\nIf that all doesn't help you out, feel free to open an issue https://github.com/mobxjs/mobx/issues!\\n\",\n    \"m038\": \"Missing items in this list?\\n    1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n    2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\"\n};\nfunction getMessage(id) {\n    return messages[id];\n}\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nfunction getGlobal() {\n    return global;\n}\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\nfunction fail(message, thing) {\n    invariant(false, message, thing);\n    throw \"X\";\n}\nfunction invariant(check, message, thing) {\n    if (!check) throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\"));\n}\nvar deprecatedMessages = [];\nfunction deprecated(msg) {\n    if (deprecatedMessages.indexOf(msg) !== -1) return false;\n    deprecatedMessages.push(msg);\n    console.error(\"[mobx] Deprecated: \" + msg);\n    return true;\n}\nfunction once(func) {\n    var invoked = false;\n    return function () {\n        if (invoked) return;\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function noop() {};\nfunction unique(list) {\n    var res = [];\n    list.forEach(function (item) {\n        if (res.indexOf(item) === -1) res.push(item);\n    });\n    return res;\n}\nfunction joinStrings(things, limit, separator) {\n    if (limit === void 0) {\n        limit = 100;\n    }\n    if (separator === void 0) {\n        separator = \" - \";\n    }\n    if (!things) return \"\";\n    var sliced = things.slice(0, limit);\n    return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\");\n}\nfunction isObject(value) {\n    return value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\";\n}\nfunction isPlainObject(value) {\n    if (value === null || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false;\n    var proto = Object.getPrototypeOf(value);\n    return proto === Object.prototype || proto === null;\n}\nfunction objectAssign() {\n    var res = arguments[0];\n    for (var i = 1, l = arguments.length; i < l; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n            if (hasOwnProperty(source, key)) {\n                res[key] = source[key];\n            }\n        }\n    }\n    return res;\n}\nfunction valueDidChange(compareStructural, oldValue, newValue) {\n    if (typeof oldValue === 'number' && isNaN(oldValue)) {\n        return typeof newValue !== 'number' || !isNaN(newValue);\n    }\n    return compareStructural ? !deepEqual(oldValue, newValue) : oldValue !== newValue;\n}\nvar prototypeHasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(object, propName) {\n    return prototypeHasOwnProperty.call(object, propName);\n}\nfunction makeNonEnumerable(object, propNames) {\n    for (var i = 0; i < propNames.length; i++) {\n        addHiddenProp(object, propNames[i], object[propNames[i]]);\n    }\n}\nfunction addHiddenProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\nfunction isPropertyConfigurable(object, prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(object, prop);\n    return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;\n}\nfunction assertPropertyConfigurable(object, prop) {\n    invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\");\n}\nfunction getEnumerableKeys(obj) {\n    var res = [];\n    for (var key in obj) {\n        res.push(key);\n    }return res;\n}\nfunction deepEqual(a, b) {\n    if (a === null && b === null) return true;\n    if (a === undefined && b === undefined) return true;\n    if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) !== \"object\") return a === b;\n    var aIsArray = isArrayLike(a);\n    var aIsMap = isMapLike(a);\n    if (aIsArray !== isArrayLike(b)) {\n        return false;\n    } else if (aIsMap !== isMapLike(b)) {\n        return false;\n    } else if (aIsArray) {\n        if (a.length !== b.length) return false;\n        for (var i = a.length - 1; i >= 0; i--) {\n            if (!deepEqual(a[i], b[i])) return false;\n        }return true;\n    } else if (aIsMap) {\n        if (a.size !== b.size) return false;\n        var equals_1 = true;\n        a.forEach(function (value, key) {\n            equals_1 = equals_1 && deepEqual(b.get(key), value);\n        });\n        return equals_1;\n    } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === \"object\" && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === \"object\") {\n        if (a === null || b === null) return false;\n        if (isMapLike(a) && isMapLike(b)) {\n            if (a.size !== b.size) return false;\n            return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries());\n        }\n        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length) return false;\n        for (var prop in a) {\n            if (!(prop in b)) return false;\n            if (!deepEqual(a[prop], b[prop])) return false;\n        }\n        return true;\n    }\n    return false;\n}\nfunction createInstanceofPredicate(name, clazz) {\n    var propName = \"isMobX\" + name;\n    clazz.prototype[propName] = true;\n    return function (x) {\n        return isObject(x) && x[propName] === true;\n    };\n}\nfunction isArrayLike(x) {\n    return Array.isArray(x) || isObservableArray(x);\n}\nexports.isArrayLike = isArrayLike;\nfunction isMapLike(x) {\n    return isES6Map(x) || isObservableMap(x);\n}\nfunction isES6Map(thing) {\n    if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map) return true;\n    return false;\n}\nfunction primitiveSymbol() {\n    return typeof Symbol === \"function\" && Symbol.toPrimitive || \"@@toPrimitive\";\n}\nfunction toPrimitive(value) {\n    return value === null ? null : (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? \"\" + value : value;\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _icons = __webpack_require__(6);\n\nvar _constants = __webpack_require__(0);\n\nfunction renderHeader(_ref, instance) {\n  var meta = _ref.meta,\n      user = _ref.user,\n      reactions = _ref.reactions;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-header-container';\n\n  var likeButton = document.createElement('span');\n  var likedReaction = reactions.find(function (reaction) {\n    return reaction.content === 'heart' && reaction.user.login === user.login;\n  });\n  likeButton.className = 'gitment-header-like-btn';\n  likeButton.innerHTML = '\\n    ' + _icons.heart + '\\n    ' + (likedReaction ? 'Unlike' : 'Like') + '\\n    ' + (meta.reactions && meta.reactions.heart ? ' \\u2022 <strong>' + meta.reactions.heart + '</strong> Liked' : '') + '\\n  ';\n\n  if (likedReaction) {\n    likeButton.classList.add('liked');\n    likeButton.onclick = function () {\n      return instance.unlike();\n    };\n  } else {\n    likeButton.classList.remove('liked');\n    likeButton.onclick = function () {\n      return instance.like();\n    };\n  }\n  container.appendChild(likeButton);\n\n  var commentsCount = document.createElement('span');\n  commentsCount.innerHTML = '\\n    ' + (meta.comments ? ' \\u2022 <strong>' + meta.comments + '</strong> Comments' : '') + '\\n  ';\n  container.appendChild(commentsCount);\n\n  var issueLink = document.createElement('a');\n  issueLink.className = 'gitment-header-issue-link';\n  issueLink.href = meta.html_url;\n  issueLink.target = '_blank';\n  issueLink.innerText = 'Issue Page';\n  container.appendChild(issueLink);\n\n  return container;\n}\n\nfunction renderComments(_ref2, instance) {\n  var meta = _ref2.meta,\n      comments = _ref2.comments,\n      commentReactions = _ref2.commentReactions,\n      currentPage = _ref2.currentPage,\n      user = _ref2.user,\n      error = _ref2.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-comments-container';\n\n  if (error) {\n    var errorBlock = document.createElement('div');\n    errorBlock.className = 'gitment-comments-error';\n\n    if (error === _constants.NOT_INITIALIZED_ERROR && user.login && user.login.toLowerCase() === instance.owner.toLowerCase()) {\n      var initHint = document.createElement('div');\n      var initButton = document.createElement('button');\n      initButton.className = 'gitment-comments-init-btn';\n      initButton.onclick = function () {\n        initButton.setAttribute('disabled', true);\n        instance.init().catch(function (e) {\n          initButton.removeAttribute('disabled');\n          alert(e);\n        });\n      };\n      initButton.innerText = 'Initialize Comments';\n      initHint.appendChild(initButton);\n      errorBlock.appendChild(initHint);\n    } else {\n      errorBlock.innerText = error;\n    }\n    container.appendChild(errorBlock);\n    return container;\n  } else if (comments === undefined) {\n    var loading = document.createElement('div');\n    loading.innerText = 'Loading comments...';\n    loading.className = 'gitment-comments-loading';\n    container.appendChild(loading);\n    return container;\n  } else if (!comments.length) {\n    var emptyBlock = document.createElement('div');\n    emptyBlock.className = 'gitment-comments-empty';\n    emptyBlock.innerText = 'No Comment Yet';\n    container.appendChild(emptyBlock);\n    return container;\n  }\n\n  var commentsList = document.createElement('ul');\n  commentsList.className = 'gitment-comments-list';\n\n  comments.forEach(function (comment) {\n    var createDate = new Date(comment.created_at);\n    var updateDate = new Date(comment.updated_at);\n    var commentItem = document.createElement('li');\n    commentItem.className = 'gitment-comment';\n    commentItem.innerHTML = '\\n      <a class=\"gitment-comment-avatar\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n        <img class=\"gitment-comment-avatar-img\" src=\"' + comment.user.avatar_url + '\"/>\\n      </a>\\n      <div class=\"gitment-comment-main\">\\n        <div class=\"gitment-comment-header\">\\n          <a class=\"gitment-comment-name\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n            ' + comment.user.login + '\\n          </a>\\n          commented on\\n          <span title=\"' + createDate + '\">' + createDate.toDateString() + '</span>\\n          ' + (createDate.toString() !== updateDate.toString() ? ' \\u2022 <span title=\"comment was edited at ' + updateDate + '\">edited</span>' : '') + '\\n          <div class=\"gitment-comment-like-btn\">' + _icons.heart + ' ' + (comment.reactions.heart || '') + '</div>\\n        </div>\\n        <div class=\"gitment-comment-body gitment-markdown\">' + comment.body_html + '</div>\\n      </div>\\n    ';\n    var likeButton = commentItem.querySelector('.gitment-comment-like-btn');\n    var likedReaction = commentReactions[comment.id] && commentReactions[comment.id].find(function (reaction) {\n      return reaction.content === 'heart' && reaction.user.login === user.login;\n    });\n    if (likedReaction) {\n      likeButton.classList.add('liked');\n      likeButton.onclick = function () {\n        return instance.unlikeAComment(comment.id);\n      };\n    } else {\n      likeButton.classList.remove('liked');\n      likeButton.onclick = function () {\n        return instance.likeAComment(comment.id);\n      };\n    }\n\n    // dirty\n    // use a blank image to trigger height calculating when element rendered\n    var imgTrigger = document.createElement('img');\n    var markdownBody = commentItem.querySelector('.gitment-comment-body');\n    imgTrigger.className = 'gitment-hidden';\n    imgTrigger.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    imgTrigger.onload = function () {\n      if (markdownBody.clientHeight > instance.maxCommentHeight) {\n        markdownBody.classList.add('gitment-comment-body-folded');\n        markdownBody.style.maxHeight = instance.maxCommentHeight + 'px';\n        markdownBody.title = 'Click to Expand';\n        markdownBody.onclick = function () {\n          markdownBody.classList.remove('gitment-comment-body-folded');\n          markdownBody.style.maxHeight = '';\n          markdownBody.title = '';\n          markdownBody.onclick = null;\n        };\n      }\n    };\n    commentItem.appendChild(imgTrigger);\n\n    commentsList.appendChild(commentItem);\n  });\n\n  container.appendChild(commentsList);\n\n  if (meta) {\n    var pageCount = Math.ceil(meta.comments / instance.perPage);\n    if (pageCount > 1) {\n      var pagination = document.createElement('ul');\n      pagination.className = 'gitment-comments-pagination';\n\n      if (currentPage > 1) {\n        var previousButton = document.createElement('li');\n        previousButton.className = 'gitment-comments-page-item';\n        previousButton.innerText = 'Previous';\n        previousButton.onclick = function () {\n          return instance.goto(currentPage - 1);\n        };\n        pagination.appendChild(previousButton);\n      }\n\n      var _loop = function _loop(i) {\n        var pageItem = document.createElement('li');\n        pageItem.className = 'gitment-comments-page-item';\n        pageItem.innerText = i;\n        pageItem.onclick = function () {\n          return instance.goto(i);\n        };\n        if (currentPage === i) pageItem.classList.add('gitment-selected');\n        pagination.appendChild(pageItem);\n      };\n\n      for (var i = 1; i <= pageCount; i++) {\n        _loop(i);\n      }\n\n      if (currentPage < pageCount) {\n        var nextButton = document.createElement('li');\n        nextButton.className = 'gitment-comments-page-item';\n        nextButton.innerText = 'Next';\n        nextButton.onclick = function () {\n          return instance.goto(currentPage + 1);\n        };\n        pagination.appendChild(nextButton);\n      }\n\n      container.appendChild(pagination);\n    }\n  }\n\n  return container;\n}\n\nfunction renderEditor(_ref3, instance) {\n  var user = _ref3.user,\n      error = _ref3.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-editor-container';\n\n  var shouldDisable = user.login && !error ? '' : 'disabled';\n  var disabledTip = user.login ? '' : 'Login to Comment';\n  container.innerHTML = '\\n      ' + (user.login ? '<a class=\"gitment-editor-avatar\" href=\"' + user.html_url + '\" target=\"_blank\">\\n            <img class=\"gitment-editor-avatar-img\" src=\"' + user.avatar_url + '\"/>\\n          </a>' : user.isLoggingIn ? '<div class=\"gitment-editor-avatar\">' + _icons.spinner + '</div>' : '<a class=\"gitment-editor-avatar\" href=\"' + instance.loginLink + '\" title=\"login with GitHub\">\\n              ' + _icons.github + '\\n            </a>') + '\\n    </a>\\n    <div class=\"gitment-editor-main\">\\n      <div class=\"gitment-editor-header\">\\n        <nav class=\"gitment-editor-tabs\">\\n          <button class=\"gitment-editor-tab gitment-selected\">Write</button>\\n          <button class=\"gitment-editor-tab\">Preview</button>\\n        </nav>\\n        <div class=\"gitment-editor-login\">\\n          ' + (user.login ? '<a class=\"gitment-editor-logout-link\">Logout</a>' : user.isLoggingIn ? 'Logging in...' : '<a class=\"gitment-editor-login-link\" href=\"' + instance.loginLink + '\">Login</a> with GitHub') + '\\n        </div>\\n      </div>\\n      <div class=\"gitment-editor-body\">\\n        <div class=\"gitment-editor-write-field\">\\n          <textarea placeholder=\"Leave a comment\" title=\"' + disabledTip + '\" ' + shouldDisable + '></textarea>\\n        </div>\\n        <div class=\"gitment-editor-preview-field gitment-hidden\">\\n          <div class=\"gitment-editor-preview gitment-markdown\"></div>\\n        </div>\\n      </div>\\n    </div>\\n    <div class=\"gitment-editor-footer\">\\n      <a class=\"gitment-editor-footer-tip\" href=\"https://guides.github.com/features/mastering-markdown/\" target=\"_blank\">\\n        Styling with Markdown is supported\\n      </a>\\n      <button class=\"gitment-editor-submit\" title=\"' + disabledTip + '\" ' + shouldDisable + '>Comment</button>\\n    </div>\\n  ';\n  if (user.login) {\n    container.querySelector('.gitment-editor-logout-link').onclick = function () {\n      return instance.logout();\n    };\n  }\n\n  var writeField = container.querySelector('.gitment-editor-write-field');\n  var previewField = container.querySelector('.gitment-editor-preview-field');\n\n  var textarea = writeField.querySelector('textarea');\n  textarea.oninput = function () {\n    textarea.style.height = 'auto';\n    var style = window.getComputedStyle(textarea, null);\n    var height = parseInt(style.height, 10);\n    var clientHeight = textarea.clientHeight;\n    var scrollHeight = textarea.scrollHeight;\n    if (clientHeight < scrollHeight) {\n      textarea.style.height = height + scrollHeight - clientHeight + 'px';\n    }\n  };\n\n  var _container$querySelec = container.querySelectorAll('.gitment-editor-tab'),\n      _container$querySelec2 = _slicedToArray(_container$querySelec, 2),\n      writeTab = _container$querySelec2[0],\n      previewTab = _container$querySelec2[1];\n\n  writeTab.onclick = function () {\n    writeTab.classList.add('gitment-selected');\n    previewTab.classList.remove('gitment-selected');\n    writeField.classList.remove('gitment-hidden');\n    previewField.classList.add('gitment-hidden');\n\n    textarea.focus();\n  };\n  previewTab.onclick = function () {\n    previewTab.classList.add('gitment-selected');\n    writeTab.classList.remove('gitment-selected');\n    previewField.classList.remove('gitment-hidden');\n    writeField.classList.add('gitment-hidden');\n\n    var preview = previewField.querySelector('.gitment-editor-preview');\n    var content = textarea.value.trim();\n    if (!content) {\n      preview.innerText = 'Nothing to preview';\n      return;\n    }\n\n    preview.innerText = 'Loading preview...';\n    instance.markdown(content).then(function (html) {\n      return preview.innerHTML = html;\n    });\n  };\n\n  var submitButton = container.querySelector('.gitment-editor-submit');\n  submitButton.onclick = function () {\n    submitButton.innerText = 'Submitting...';\n    submitButton.setAttribute('disabled', true);\n    instance.post(textarea.value.trim()).then(function (data) {\n      textarea.value = '';\n      textarea.style.height = 'auto';\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    }).catch(function (e) {\n      alert(e);\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    });\n  };\n\n  return container;\n}\n\nfunction renderFooter() {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-footer-container';\n  container.innerHTML = '\\n    Powered by\\n    <a class=\"gitment-footer-project-link\" href=\"https://github.com/imsun/gitment\" target=\"_blank\">\\n      Gitment\\n    </a>\\n  ';\n  return container;\n}\n\nfunction render(state, instance) {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-root-container';\n  container.appendChild(instance.renderHeader(state, instance));\n  container.appendChild(instance.renderComments(state, instance));\n  container.appendChild(instance.renderEditor(state, instance));\n  container.appendChild(instance.renderFooter(state, instance));\n  return container;\n}\n\nexports.default = { render: render, renderHeader: renderHeader, renderComments: renderComments, renderEditor: renderEditor, renderFooter: renderFooter };\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.http = exports.Query = exports.isString = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.getTargetContainer = getTargetContainer;\n\nvar _constants = __webpack_require__(0);\n\nvar isString = exports.isString = function isString(s) {\n  return toString.call(s) === '[object String]';\n};\n\nfunction getTargetContainer(container) {\n  var targetContainer = void 0;\n  if (container instanceof Element) {\n    targetContainer = container;\n  } else if (isString(container)) {\n    targetContainer = document.getElementById(container);\n  } else {\n    targetContainer = document.createElement('div');\n  }\n\n  return targetContainer;\n}\n\nvar Query = exports.Query = {\n  parse: function parse() {\n    var search = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.search;\n\n    if (!search) return {};\n    var queryString = search[0] === '?' ? search.substring(1) : search;\n    var query = {};\n    queryString.split('&').forEach(function (queryStr) {\n      var _queryStr$split = queryStr.split('='),\n          _queryStr$split2 = _slicedToArray(_queryStr$split, 2),\n          key = _queryStr$split2[0],\n          value = _queryStr$split2[1];\n\n      if (key) query[key] = value;\n    });\n\n    return query;\n  },\n  stringify: function stringify(query) {\n    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '?';\n\n    var queryString = Object.keys(query).map(function (key) {\n      return key + '=' + encodeURIComponent(query[key] || '');\n    }).join('&');\n    return queryString ? prefix + queryString : '';\n  }\n};\n\nfunction ajaxFactory(method) {\n  return function (apiPath) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://api.github.com';\n\n    var req = new XMLHttpRequest();\n    var token = localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n\n    var url = '' + base + apiPath;\n    var body = null;\n    if (method === 'GET' || method === 'DELETE') {\n      url += Query.stringify(data);\n    }\n\n    var p = new Promise(function (resolve, reject) {\n      req.addEventListener('load', function () {\n        var contentType = req.getResponseHeader('content-type');\n        var res = req.responseText;\n        if (!/json/.test(contentType)) {\n          resolve(res);\n          return;\n        }\n        var data = req.responseText ? JSON.parse(res) : {};\n        if (data.message) {\n          reject(new Error(data.message));\n        } else {\n          resolve(data);\n        }\n      });\n      req.addEventListener('error', function (error) {\n        return reject(error);\n      });\n    });\n    req.open(method, url, true);\n\n    req.setRequestHeader('Accept', 'application/vnd.github.squirrel-girl-preview, application/vnd.github.html+json');\n    if (token) {\n      req.setRequestHeader('Authorization', 'token ' + token);\n    }\n    if (method !== 'GET' && method !== 'DELETE') {\n      body = JSON.stringify(data);\n      req.setRequestHeader('Content-Type', 'application/json');\n    }\n\n    req.send(body);\n    return p;\n  };\n}\n\nvar http = exports.http = {\n  get: ajaxFactory('GET'),\n  post: ajaxFactory('POST'),\n  delete: ajaxFactory('DELETE'),\n  put: ajaxFactory('PUT')\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mobx = __webpack_require__(1);\n\nvar _constants = __webpack_require__(0);\n\nvar _utils = __webpack_require__(3);\n\nvar _default = __webpack_require__(2);\n\nvar _default2 = _interopRequireDefault(_default);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar scope = 'public_repo';\n\nfunction extendRenderer(instance, renderer) {\n  instance[renderer] = function (container) {\n    var targetContainer = (0, _utils.getTargetContainer)(container);\n    var render = instance.theme[renderer] || instance.defaultTheme[renderer];\n\n    (0, _mobx.autorun)(function () {\n      var e = render(instance.state, instance);\n      if (targetContainer.firstChild) {\n        targetContainer.replaceChild(e, targetContainer.firstChild);\n      } else {\n        targetContainer.appendChild(e);\n      }\n    });\n\n    return targetContainer;\n  };\n}\n\nvar Gitment = function () {\n  _createClass(Gitment, [{\n    key: 'accessToken',\n    get: function get() {\n      return localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n    },\n    set: function set(token) {\n      localStorage.setItem(_constants.LS_ACCESS_TOKEN_KEY, token);\n    }\n  }, {\n    key: 'loginLink',\n    get: function get() {\n      var oauthUri = 'https://github.com/login/oauth/authorize';\n      var redirect_uri = this.oauth.redirect_uri || window.location.href;\n\n      var oauthParams = Object.assign({\n        scope: scope,\n        redirect_uri: redirect_uri\n      }, this.oauth);\n\n      return '' + oauthUri + _utils.Query.stringify(oauthParams);\n    }\n  }]);\n\n  function Gitment() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Gitment);\n\n    this.defaultTheme = _default2.default;\n    this.useTheme(_default2.default);\n\n    Object.assign(this, {\n      id: window.location.href,\n      title: window.document.title,\n      link: window.location.href,\n      desc: '',\n      labels: [],\n      theme: _default2.default,\n      oauth: {},\n      perPage: 20,\n      maxCommentHeight: 250\n    }, options);\n\n    this.useTheme(this.theme);\n\n    var user = {};\n    try {\n      var userInfo = localStorage.getItem(_constants.LS_USER_KEY);\n      if (this.accessToken && userInfo) {\n        Object.assign(user, JSON.parse(userInfo), {\n          fromCache: true\n        });\n      }\n    } catch (e) {\n      localStorage.removeItem(_constants.LS_USER_KEY);\n    }\n\n    this.state = (0, _mobx.observable)({\n      user: user,\n      error: null,\n      meta: {},\n      comments: undefined,\n      reactions: [],\n      commentReactions: {},\n      currentPage: 1\n    });\n\n    var query = _utils.Query.parse();\n    if (query.code) {\n      var _oauth = this.oauth,\n          client_id = _oauth.client_id,\n          client_secret = _oauth.client_secret;\n\n      var code = query.code;\n      delete query.code;\n      var search = _utils.Query.stringify(query);\n      var replacedUrl = '' + window.location.origin + window.location.pathname + search + window.location.hash;\n      history.replaceState({}, '', replacedUrl);\n\n      Object.assign(this, {\n        id: replacedUrl,\n        link: replacedUrl\n      }, options);\n\n      this.state.user.isLoggingIn = true;\n      _utils.http.post('https://github.com/login/oauth/access_token', {\n        code: code,\n        client_id: client_id,\n        client_secret: client_secret\n      }, '').then(function (data) {\n        _this.accessToken = data.access_token;\n        _this.update();\n      }).catch(function (e) {\n        _this.state.user.isLoggingIn = false;\n        alert(e);\n      });\n    } else {\n      this.update();\n    }\n  }\n\n  _createClass(Gitment, [{\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      return this.createIssue().then(function () {\n        return _this2.loadComments();\n      }).then(function (comments) {\n        _this2.state.error = null;\n        return comments;\n      });\n    }\n  }, {\n    key: 'useTheme',\n    value: function useTheme() {\n      var _this3 = this;\n\n      var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this.theme = theme;\n\n      var renderers = Object.keys(this.theme);\n      renderers.forEach(function (renderer) {\n        return extendRenderer(_this3, renderer);\n      });\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var _this4 = this;\n\n      return Promise.all([this.loadMeta(), this.loadUserInfo()]).then(function () {\n        return Promise.all([_this4.loadComments().then(function () {\n          return _this4.loadCommentReactions();\n        }), _this4.loadReactions()]);\n      }).catch(function (e) {\n        return _this4.state.error = e;\n      });\n    }\n  }, {\n    key: 'markdown',\n    value: function markdown(text) {\n      return _utils.http.post('/markdown', {\n        text: text,\n        mode: 'gfm'\n      });\n    }\n  }, {\n    key: 'createIssue',\n    value: function createIssue() {\n      var _this5 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo,\n          title = this.title,\n          link = this.link,\n          desc = this.desc,\n          labels = this.labels;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues', {\n        title: title,\n        labels: labels.concat(['gitment', id]),\n        body: link + '\\n\\n' + desc\n      }).then(function (meta) {\n        _this5.state.meta = meta;\n        return meta;\n      });\n    }\n  }, {\n    key: 'getIssue',\n    value: function getIssue() {\n      if (this.state.meta.id) return Promise.resolve(this.state.meta);\n\n      return this.loadMeta();\n    }\n  }, {\n    key: 'post',\n    value: function post(body) {\n      var _this6 = this;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.post(issue.comments_url, { body: body }, '');\n      }).then(function (data) {\n        _this6.state.meta.comments++;\n        var pageCount = Math.ceil(_this6.state.meta.comments / _this6.perPage);\n        if (_this6.state.currentPage === pageCount) {\n          _this6.state.comments.push(data);\n        }\n        return data;\n      });\n    }\n  }, {\n    key: 'loadMeta',\n    value: function loadMeta() {\n      var _this7 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo;\n\n      return _utils.http.get('/repos/' + owner + '/' + repo + '/issues', {\n        creator: owner,\n        labels: id\n      }).then(function (issues) {\n        if (!issues.length) return Promise.reject(_constants.NOT_INITIALIZED_ERROR);\n        _this7.state.meta = issues[0];\n        return issues[0];\n      });\n    }\n  }, {\n    key: 'loadComments',\n    value: function loadComments() {\n      var _this8 = this;\n\n      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentPage;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.get(issue.comments_url, { page: page, per_page: _this8.perPage }, '');\n      }).then(function (comments) {\n        _this8.state.comments = comments;\n        return comments;\n      });\n    }\n  }, {\n    key: 'loadUserInfo',\n    value: function loadUserInfo() {\n      var _this9 = this;\n\n      if (!this.accessToken) {\n        this.logout();\n        return Promise.resolve({});\n      }\n\n      return _utils.http.get('/user').then(function (user) {\n        _this9.state.user = user;\n        localStorage.setItem(_constants.LS_USER_KEY, JSON.stringify(user));\n        return user;\n      });\n    }\n  }, {\n    key: 'loadReactions',\n    value: function loadReactions() {\n      var _this10 = this;\n\n      if (!this.accessToken) {\n        this.state.reactions = [];\n        return Promise.resolve([]);\n      }\n\n      return this.getIssue().then(function (issue) {\n        if (!issue.reactions.total_count) return [];\n        return _utils.http.get(issue.reactions.url, {}, '');\n      }).then(function (reactions) {\n        _this10.state.reactions = reactions;\n        return reactions;\n      });\n    }\n  }, {\n    key: 'loadCommentReactions',\n    value: function loadCommentReactions() {\n      var _this11 = this;\n\n      if (!this.accessToken) {\n        this.state.commentReactions = {};\n        return Promise.resolve([]);\n      }\n\n      var comments = this.state.comments;\n      var comentReactions = {};\n\n      return Promise.all(comments.map(function (comment) {\n        if (!comment.reactions.total_count) return [];\n\n        var owner = _this11.owner,\n            repo = _this11.repo;\n\n        return _utils.http.get('/repos/' + owner + '/' + repo + '/issues/comments/' + comment.id + '/reactions', {});\n      })).then(function (reactionsArray) {\n        comments.forEach(function (comment, index) {\n          comentReactions[comment.id] = reactionsArray[index];\n        });\n        _this11.state.commentReactions = comentReactions;\n\n        return comentReactions;\n      });\n    }\n  }, {\n    key: 'login',\n    value: function login() {\n      window.location.href = this.loginLink;\n    }\n  }, {\n    key: 'logout',\n    value: function logout() {\n      localStorage.removeItem(_constants.LS_ACCESS_TOKEN_KEY);\n      localStorage.removeItem(_constants.LS_USER_KEY);\n      this.state.user = {};\n    }\n  }, {\n    key: 'goto',\n    value: function goto(page) {\n      this.state.currentPage = page;\n      this.state.comments = undefined;\n      return this.loadComments(page);\n    }\n  }, {\n    key: 'like',\n    value: function like() {\n      var _this12 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/' + this.state.meta.number + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this12.state.reactions.push(reaction);\n        _this12.state.meta.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlike',\n    value: function unlike() {\n      var _this13 = this;\n\n      if (!this.accessToken) return Promise.reject();\n\n      var _state = this.state,\n          user = _state.user,\n          reactions = _state.reactions;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        _this13.state.meta.reactions.heart--;\n      });\n    }\n  }, {\n    key: 'likeAComment',\n    value: function likeAComment(commentId) {\n      var _this14 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/comments/' + commentId + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this14.state.commentReactions[commentId].push(reaction);\n        comment.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlikeAComment',\n    value: function unlikeAComment(commentId) {\n      if (!this.accessToken) return Promise.reject();\n\n      var reactions = this.state.commentReactions[commentId];\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n      var user = this.state.user;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        comment.reactions.heart--;\n      });\n    }\n  }]);\n\n  return Gitment;\n}();\n\nmodule.exports = Gitment;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Modified from https://github.com/evil-icons/evil-icons\n */\n\nvar close = exports.close = '<svg class=\"gitment-close-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M37.304 11.282l1.414 1.414-26.022 26.02-1.414-1.413z\"/><path d=\"M12.696 11.282l26.022 26.02-1.414 1.415-26.022-26.02z\"/></svg>';\nvar github = exports.github = '<svg class=\"gitment-github-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 10c-8.3 0-15 6.7-15 15 0 6.6 4.3 12.2 10.3 14.2.8.1 1-.3 1-.7v-2.6c-4.2.9-5.1-2-5.1-2-.7-1.7-1.7-2.2-1.7-2.2-1.4-.9.1-.9.1-.9 1.5.1 2.3 1.5 2.3 1.5 1.3 2.3 3.5 1.6 4.4 1.2.1-1 .5-1.6 1-2-3.3-.4-6.8-1.7-6.8-7.4 0-1.6.6-3 1.5-4-.2-.4-.7-1.9.1-4 0 0 1.3-.4 4.1 1.5 1.2-.3 2.5-.5 3.8-.5 1.3 0 2.6.2 3.8.5 2.9-1.9 4.1-1.5 4.1-1.5.8 2.1.3 3.6.1 4 1 1 1.5 2.4 1.5 4 0 5.8-3.5 7-6.8 7.4.5.5 1 1.4 1 2.8v4.1c0 .4.3.9 1 .7 6-2 10.2-7.6 10.2-14.2C40 16.7 33.3 10 25 10z\"/></svg>';\nvar heart = exports.heart = '<svg class=\"gitment-heart-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 39.7l-.6-.5C11.5 28.7 8 25 8 19c0-5 4-9 9-9 4.1 0 6.4 2.3 8 4.1 1.6-1.8 3.9-4.1 8-4.1 5 0 9 4 9 9 0 6-3.5 9.7-16.4 20.2l-.6.5zM17 12c-3.9 0-7 3.1-7 7 0 5.1 3.2 8.5 15 18.1 11.8-9.6 15-13 15-18.1 0-3.9-3.1-7-7-7-3.5 0-5.4 2.1-6.9 3.8L25 17.1l-1.1-1.3C22.4 14.1 20.5 12 17 12z\"/></svg>';\nvar spinner = exports.spinner = '<svg class=\"gitment-spinner-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 18c-.6 0-1-.4-1-1V9c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M25 42c-.6 0-1-.4-1-1v-8c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M29 19c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M17 39.8c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".93\" d=\"M21 19c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M33 39.8c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.1-.3.2-.5.2z\"/><path opacity=\".65\" d=\"M17 26H9c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".3\" d=\"M41 26h-8c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".86\" d=\"M18.1 21.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M38.9 33.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".44\" d=\"M11.1 33.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.1.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M31.9 21.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.2.2-.3.2-.5.2z\"/></svg>';\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=gitment.browser.js.map","source":"js/gitment.js","raw":"var Gitment =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar LS_ACCESS_TOKEN_KEY = exports.LS_ACCESS_TOKEN_KEY = 'gitment-comments-token';\nvar LS_USER_KEY = exports.LS_USER_KEY = 'gitment-user-info';\n\nvar NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = new Error('Comments Not Initialized');\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) {\n            if (b.hasOwnProperty(p)) d[p] = b[p];\n        }\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nregisterGlobals();\nexports.extras = {\n    allowStateChanges: allowStateChanges,\n    deepEqual: deepEqual,\n    getAtom: getAtom,\n    getDebugName: getDebugName,\n    getDependencyTree: getDependencyTree,\n    getAdministration: getAdministration,\n    getGlobalState: getGlobalState,\n    getObserverTree: getObserverTree,\n    isComputingDerivation: isComputingDerivation,\n    isSpyEnabled: isSpyEnabled,\n    onReactionError: onReactionError,\n    resetGlobalState: resetGlobalState,\n    shareGlobalState: shareGlobalState,\n    spyReport: spyReport,\n    spyReportEnd: spyReportEnd,\n    spyReportStart: spyReportStart,\n    setReactionScheduler: setReactionScheduler\n};\nif ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" ? \"undefined\" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === \"object\") {\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx(module.exports);\n}\nmodule.exports.default = module.exports;\nvar actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {\n    var actionName = args && args.length === 1 ? args[0] : value.name || key || \"<unnamed action>\";\n    var wrappedAction = action(actionName, value);\n    addHiddenProp(target, key, wrappedAction);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, true);\nvar boundActionDecorator = createClassPropertyDecorator(function (target, key, value) {\n    defineBoundAction(target, key, value);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, false);\nvar action = function action(arg1, arg2, arg3, arg4) {\n    if (arguments.length === 1 && typeof arg1 === \"function\") return createAction(arg1.name || \"<unnamed action>\", arg1);\n    if (arguments.length === 2 && typeof arg2 === \"function\") return createAction(arg1, arg2);\n    if (arguments.length === 1 && typeof arg1 === \"string\") return namedActionDecorator(arg1);\n    return namedActionDecorator(arg2).apply(null, arguments);\n};\nexports.action = action;\naction.bound = function boundAction(arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n        var action_1 = createAction(\"<not yet bound action>\", arg1);\n        action_1.autoBind = true;\n        return action_1;\n    }\n    return boundActionDecorator.apply(null, arguments);\n};\nfunction namedActionDecorator(name) {\n    return function (target, prop, descriptor) {\n        if (descriptor && typeof descriptor.value === \"function\") {\n            descriptor.value = createAction(name, descriptor.value);\n            descriptor.enumerable = false;\n            descriptor.configurable = true;\n            return descriptor;\n        }\n        return actionFieldDecorator(name).apply(this, arguments);\n    };\n}\nfunction runInAction(arg1, arg2, arg3) {\n    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action>\";\n    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\n    var scope = typeof arg1 === \"function\" ? arg2 : arg3;\n    invariant(typeof fn === \"function\", getMessage(\"m002\"));\n    invariant(fn.length === 0, getMessage(\"m003\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    return executeAction(actionName, fn, scope, undefined);\n}\nexports.runInAction = runInAction;\nfunction isAction(thing) {\n    return typeof thing === \"function\" && thing.isMobxAction === true;\n}\nexports.isAction = isAction;\nfunction defineBoundAction(target, propertyName, fn) {\n    var res = function res() {\n        return executeAction(propertyName, fn, target, arguments);\n    };\n    res.isMobxAction = true;\n    addHiddenProp(target, propertyName, res);\n}\nfunction autorun(arg1, arg2, arg3) {\n    var name, view, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        view = arg2;\n        scope = arg3;\n    } else {\n        name = arg1.name || \"Autorun@\" + getNextId();\n        view = arg1;\n        scope = arg2;\n    }\n    invariant(typeof view === \"function\", getMessage(\"m004\"));\n    invariant(isAction(view) === false, getMessage(\"m005\"));\n    if (scope) view = view.bind(scope);\n    var reaction = new Reaction(name, function () {\n        this.track(reactionRunner);\n    });\n    function reactionRunner() {\n        view(reaction);\n    }\n    reaction.schedule();\n    return reaction.getDisposer();\n}\nexports.autorun = autorun;\nfunction when(arg1, arg2, arg3, arg4) {\n    var name, predicate, effect, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        predicate = arg2;\n        effect = arg3;\n        scope = arg4;\n    } else {\n        name = \"When@\" + getNextId();\n        predicate = arg1;\n        effect = arg2;\n        scope = arg3;\n    }\n    var disposer = autorun(name, function (r) {\n        if (predicate.call(scope)) {\n            r.dispose();\n            var prevUntracked = untrackedStart();\n            effect.call(scope);\n            untrackedEnd(prevUntracked);\n        }\n    });\n    return disposer;\n}\nexports.when = when;\nfunction autorunAsync(arg1, arg2, arg3, arg4) {\n    var name, func, delay, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        func = arg2;\n        delay = arg3;\n        scope = arg4;\n    } else {\n        name = arg1.name || \"AutorunAsync@\" + getNextId();\n        func = arg1;\n        delay = arg2;\n        scope = arg3;\n    }\n    invariant(isAction(func) === false, getMessage(\"m006\"));\n    if (delay === void 0) delay = 1;\n    if (scope) func = func.bind(scope);\n    var isScheduled = false;\n    var r = new Reaction(name, function () {\n        if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                if (!r.isDisposed) r.track(reactionRunner);\n            }, delay);\n        }\n    });\n    function reactionRunner() {\n        func(r);\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.autorunAsync = autorunAsync;\nfunction reaction(expression, effect, arg3) {\n    if (arguments.length > 3) {\n        fail(getMessage(\"m007\"));\n    }\n    if (isModifierDescriptor(expression)) {\n        fail(getMessage(\"m008\"));\n    }\n    var opts;\n    if ((typeof arg3 === \"undefined\" ? \"undefined\" : _typeof(arg3)) === \"object\") {\n        opts = arg3;\n    } else {\n        opts = {};\n    }\n    opts.name = opts.name || expression.name || effect.name || \"Reaction@\" + getNextId();\n    opts.fireImmediately = arg3 === true || opts.fireImmediately === true;\n    opts.delay = opts.delay || 0;\n    opts.compareStructural = opts.compareStructural || opts.struct || false;\n    effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect);\n    if (opts.context) {\n        expression = expression.bind(opts.context);\n    }\n    var firstTime = true;\n    var isScheduled = false;\n    var nextValue;\n    var r = new Reaction(opts.name, function () {\n        if (firstTime || opts.delay < 1) {\n            reactionRunner();\n        } else if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                reactionRunner();\n            }, opts.delay);\n        }\n    });\n    function reactionRunner() {\n        if (r.isDisposed) return;\n        var changed = false;\n        r.track(function () {\n            var v = expression(r);\n            changed = valueDidChange(opts.compareStructural, nextValue, v);\n            nextValue = v;\n        });\n        if (firstTime && opts.fireImmediately) effect(nextValue, r);\n        if (!firstTime && changed === true) effect(nextValue, r);\n        if (firstTime) firstTime = false;\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.reaction = reaction;\nfunction createComputedDecorator(compareStructural) {\n    return createClassPropertyDecorator(function (target, name, _, __, originalDescriptor) {\n        invariant(typeof originalDescriptor !== \"undefined\", getMessage(\"m009\"));\n        invariant(typeof originalDescriptor.get === \"function\", getMessage(\"m010\"));\n        var adm = asObservableObject(target, \"\");\n        defineComputedProperty(adm, name, originalDescriptor.get, originalDescriptor.set, compareStructural, false);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        this.$mobx.values[name].set(value);\n    }, false, false);\n}\nvar computedDecorator = createComputedDecorator(false);\nvar computedStructDecorator = createComputedDecorator(true);\nvar computed = function computed(arg1, arg2, arg3) {\n    if (typeof arg2 === \"string\") {\n        return computedDecorator.apply(null, arguments);\n    }\n    invariant(typeof arg1 === \"function\", getMessage(\"m011\"));\n    invariant(arguments.length < 3, getMessage(\"m012\"));\n    var opts = (typeof arg2 === \"undefined\" ? \"undefined\" : _typeof(arg2)) === \"object\" ? arg2 : {};\n    opts.setter = typeof arg2 === \"function\" ? arg2 : opts.setter;\n    return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || \"\", opts.setter);\n};\nexports.computed = computed;\ncomputed.struct = computedStructDecorator;\nfunction createTransformer(transformer, onCleanup) {\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\n    var objectCache = {};\n    var resetId = globalState.resetId;\n    var Transformer = function (_super) {\n        __extends(Transformer, _super);\n        function Transformer(sourceIdentifier, sourceObject) {\n            var _this = _super.call(this, function () {\n                return transformer(sourceObject);\n            }, undefined, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier, undefined) || this;\n            _this.sourceIdentifier = sourceIdentifier;\n            _this.sourceObject = sourceObject;\n            return _this;\n        }\n        Transformer.prototype.onBecomeUnobserved = function () {\n            var lastValue = this.value;\n            _super.prototype.onBecomeUnobserved.call(this);\n            delete objectCache[this.sourceIdentifier];\n            if (onCleanup) onCleanup(lastValue, this.sourceObject);\n        };\n        return Transformer;\n    }(ComputedValue);\n    return function (object) {\n        if (resetId !== globalState.resetId) {\n            objectCache = {};\n            resetId = globalState.resetId;\n        }\n        var identifier = getMemoizationId(object);\n        var reactiveTransformer = objectCache[identifier];\n        if (reactiveTransformer) return reactiveTransformer.get();\n        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);\n        return reactiveTransformer.get();\n    };\n}\nexports.createTransformer = createTransformer;\nfunction getMemoizationId(object) {\n    if (object === null || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") throw new Error(\"[mobx] transform expected some kind of object, got: \" + object);\n    var tid = object.$transformId;\n    if (tid === undefined) {\n        tid = getNextId();\n        addHiddenProp(object, \"$transformId\", tid);\n    }\n    return tid;\n}\nfunction expr(expr, scope) {\n    if (!isComputingDerivation()) console.warn(getMessage(\"m013\"));\n    return computed(expr, { context: scope }).get();\n}\nexports.expr = expr;\nfunction extendObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, deepEnhancer, properties);\n}\nexports.extendObservable = extendObservable;\nfunction extendShallowObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, referenceEnhancer, properties);\n}\nexports.extendShallowObservable = extendShallowObservable;\nfunction extendObservableHelper(target, defaultEnhancer, properties) {\n    invariant(arguments.length >= 2, getMessage(\"m014\"));\n    invariant((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\", getMessage(\"m015\"));\n    invariant(!isObservableMap(target), getMessage(\"m016\"));\n    properties.forEach(function (propSet) {\n        invariant((typeof propSet === \"undefined\" ? \"undefined\" : _typeof(propSet)) === \"object\", getMessage(\"m017\"));\n        invariant(!isObservable(propSet), getMessage(\"m018\"));\n    });\n    var adm = asObservableObject(target);\n    var definedProps = {};\n    for (var i = properties.length - 1; i >= 0; i--) {\n        var propSet = properties[i];\n        for (var key in propSet) {\n            if (definedProps[key] !== true && hasOwnProperty(propSet, key)) {\n                definedProps[key] = true;\n                if (target === propSet && !isPropertyConfigurable(target, key)) continue;\n                var descriptor = Object.getOwnPropertyDescriptor(propSet, key);\n                defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer);\n            }\n        }\n    }\n    return target;\n}\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree);\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (hasObservers(node)) result.observers = getObservers(node).map(nodeToObserverTree);\n    return result;\n}\nfunction intercept(thing, propOrHandler, handler) {\n    if (typeof handler === \"function\") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);\n}\nexports.intercept = intercept;\nfunction interceptInterceptable(thing, handler) {\n    return getAdministration(thing).intercept(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    return getAdministration(thing, property).intercept(handler);\n}\nfunction isComputed(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableObject(value) === false) return false;\n        var atom = getAtom(value, property);\n        return isComputedValue(atom);\n    }\n    return isComputedValue(value);\n}\nexports.isComputed = isComputed;\nfunction isObservable(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableArray(value) || isObservableMap(value)) throw new Error(getMessage(\"m019\"));else if (isObservableObject(value)) {\n            var o = value.$mobx;\n            return o.values && !!o.values[property];\n        }\n        return false;\n    }\n    return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value);\n}\nexports.isObservable = isObservable;\nvar deepDecorator = createDecoratorForEnhancer(deepEnhancer);\nvar shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);\nvar refDecorator = createDecoratorForEnhancer(referenceEnhancer);\nvar deepStructDecorator = createDecoratorForEnhancer(deepStructEnhancer);\nvar refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);\nfunction createObservable(v) {\n    if (v === void 0) {\n        v = undefined;\n    }\n    if (typeof arguments[1] === \"string\") return deepDecorator.apply(null, arguments);\n    invariant(arguments.length <= 1, getMessage(\"m021\"));\n    invariant(!isModifierDescriptor(v), getMessage(\"m020\"));\n    if (isObservable(v)) return v;\n    var res = deepEnhancer(v, undefined, undefined);\n    if (res !== v) return res;\n    return observable.box(v);\n}\nvar IObservableFactories = function () {\n    function IObservableFactories() {}\n    IObservableFactories.prototype.box = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"box\");\n        return new ObservableValue(value, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowBox = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowBox\");\n        return new ObservableValue(value, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.array = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"array\");\n        return new ObservableArray(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowArray = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowArray\");\n        return new ObservableArray(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.map = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"map\");\n        return new ObservableMap(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowMap = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowMap\");\n        return new ObservableMap(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.object = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"object\");\n        var res = {};\n        asObservableObject(res, name);\n        extendObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.shallowObject = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowObject\");\n        var res = {};\n        asObservableObject(res, name);\n        extendShallowObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.ref = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(referenceEnhancer, arguments[0]);\n        } else {\n            return refDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.shallow = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(shallowEnhancer, arguments[0]);\n        } else {\n            return shallowDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.deep = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepEnhancer, arguments[0]);\n        } else {\n            return deepDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.struct = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepStructEnhancer, arguments[0]);\n        } else {\n            return deepStructDecorator.apply(null, arguments);\n        }\n    };\n    return IObservableFactories;\n}();\nexports.IObservableFactories = IObservableFactories;\nvar observable = createObservable;\nexports.observable = observable;\nObject.keys(IObservableFactories.prototype).forEach(function (key) {\n    return observable[key] = IObservableFactories.prototype[key];\n});\nobservable.deep.struct = observable.struct;\nobservable.ref.struct = function () {\n    if (arguments.length < 2) {\n        return createModifierDescriptor(refStructEnhancer, arguments[0]);\n    } else {\n        return refStructDecorator.apply(null, arguments);\n    }\n};\nfunction incorrectlyUsedAsDecorator(methodName) {\n    fail(\"Expected one or two arguments to observable.\" + methodName + \". Did you accidentally try to use observable.\" + methodName + \" as decorator?\");\n}\nfunction createDecoratorForEnhancer(enhancer) {\n    invariant(!!enhancer, \":(\");\n    return createClassPropertyDecorator(function (target, name, baseValue, _, baseDescriptor) {\n        assertPropertyConfigurable(target, name);\n        invariant(!baseDescriptor || !baseDescriptor.get, getMessage(\"m022\"));\n        var adm = asObservableObject(target, undefined);\n        defineObservableProperty(adm, name, baseValue, enhancer);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        setPropertyValue(this, name, value);\n    }, true, false);\n}\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (typeof cbOrFire === \"function\") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);\n}\nexports.observe = observe;\nfunction observeObservable(thing, listener, fireImmediately) {\n    return getAdministration(thing).observe(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    return getAdministration(thing, property).observe(listener, fireImmediately);\n}\nfunction toJS(source, detectCycles, __alreadySeen) {\n    if (detectCycles === void 0) {\n        detectCycles = true;\n    }\n    if (__alreadySeen === void 0) {\n        __alreadySeen = [];\n    }\n    function cache(value) {\n        if (detectCycles) __alreadySeen.push([source, value]);\n        return value;\n    }\n    if (isObservable(source)) {\n        if (detectCycles && __alreadySeen === null) __alreadySeen = [];\n        if (detectCycles && source !== null && (typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") {\n            for (var i = 0, l = __alreadySeen.length; i < l; i++) {\n                if (__alreadySeen[i][0] === source) return __alreadySeen[i][1];\n            }\n        }\n        if (isObservableArray(source)) {\n            var res = cache([]);\n            var toAdd = source.map(function (value) {\n                return toJS(value, detectCycles, __alreadySeen);\n            });\n            res.length = toAdd.length;\n            for (var i = 0, l = toAdd.length; i < l; i++) {\n                res[i] = toAdd[i];\n            }return res;\n        }\n        if (isObservableObject(source)) {\n            var res = cache({});\n            for (var key in source) {\n                res[key] = toJS(source[key], detectCycles, __alreadySeen);\n            }return res;\n        }\n        if (isObservableMap(source)) {\n            var res_1 = cache({});\n            source.forEach(function (value, key) {\n                return res_1[key] = toJS(value, detectCycles, __alreadySeen);\n            });\n            return res_1;\n        }\n        if (isObservableValue(source)) return toJS(source.get(), detectCycles, __alreadySeen);\n    }\n    return source;\n}\nexports.toJS = toJS;\nfunction transaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    deprecated(getMessage(\"m023\"));\n    return runInTransaction.apply(undefined, arguments);\n}\nexports.transaction = transaction;\nfunction runInTransaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    return executeAction(\"\", action);\n}\nfunction log(msg) {\n    console.log(msg);\n    return msg;\n}\nfunction whyRun(thing, prop) {\n    switch (arguments.length) {\n        case 0:\n            thing = globalState.trackingDerivation;\n            if (!thing) return log(getMessage(\"m024\"));\n            break;\n        case 2:\n            thing = getAtom(thing, prop);\n            break;\n    }\n    thing = getAtom(thing);\n    if (isComputedValue(thing)) return log(thing.whyRun());else if (isReaction(thing)) return log(thing.whyRun());\n    return fail(getMessage(\"m025\"));\n}\nexports.whyRun = whyRun;\nfunction createAction(actionName, fn) {\n    invariant(typeof fn === \"function\", getMessage(\"m026\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    var res = function res() {\n        return executeAction(actionName, fn, this, arguments);\n    };\n    res.originalFn = fn;\n    res.isMobxAction = true;\n    return res;\n}\nfunction executeAction(actionName, fn, scope, args) {\n    var runInfo = startAction(actionName, fn, scope, args);\n    try {\n        return fn.apply(scope, args);\n    } finally {\n        endAction(runInfo);\n    }\n}\nfunction startAction(actionName, fn, scope, args) {\n    var notifySpy = isSpyEnabled() && !!actionName;\n    var startTime = 0;\n    if (notifySpy) {\n        startTime = Date.now();\n        var l = args && args.length || 0;\n        var flattendArgs = new Array(l);\n        if (l > 0) for (var i = 0; i < l; i++) {\n            flattendArgs[i] = args[i];\n        }spyReportStart({\n            type: \"action\",\n            name: actionName,\n            fn: fn,\n            object: scope,\n            arguments: flattendArgs\n        });\n    }\n    var prevDerivation = untrackedStart();\n    startBatch();\n    var prevAllowStateChanges = allowStateChangesStart(true);\n    return {\n        prevDerivation: prevDerivation,\n        prevAllowStateChanges: prevAllowStateChanges,\n        notifySpy: notifySpy,\n        startTime: startTime\n    };\n}\nfunction endAction(runInfo) {\n    allowStateChangesEnd(runInfo.prevAllowStateChanges);\n    endBatch();\n    untrackedEnd(runInfo.prevDerivation);\n    if (runInfo.notifySpy) spyReportEnd({ time: Date.now() - runInfo.startTime });\n}\nfunction useStrict(strict) {\n    invariant(globalState.trackingDerivation === null, getMessage(\"m028\"));\n    globalState.strictMode = strict;\n    globalState.allowStateChanges = !strict;\n}\nexports.useStrict = useStrict;\nfunction isStrictModeEnabled() {\n    return globalState.strictMode;\n}\nexports.isStrictModeEnabled = isStrictModeEnabled;\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    var res;\n    try {\n        res = func();\n    } finally {\n        allowStateChangesEnd(prev);\n    }\n    return res;\n}\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nvar BaseAtom = function () {\n    function BaseAtom(name) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        this.name = name;\n        this.isPendingUnobservation = true;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.NOT_TRACKING;\n    }\n    BaseAtom.prototype.onBecomeUnobserved = function () {};\n    BaseAtom.prototype.reportObserved = function () {\n        reportObserved(this);\n    };\n    BaseAtom.prototype.reportChanged = function () {\n        startBatch();\n        propagateChanged(this);\n        endBatch();\n    };\n    BaseAtom.prototype.toString = function () {\n        return this.name;\n    };\n    return BaseAtom;\n}();\nexports.BaseAtom = BaseAtom;\nvar Atom = function (_super) {\n    __extends(Atom, _super);\n    function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        if (onBecomeObservedHandler === void 0) {\n            onBecomeObservedHandler = noop;\n        }\n        if (onBecomeUnobservedHandler === void 0) {\n            onBecomeUnobservedHandler = noop;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.name = name;\n        _this.onBecomeObservedHandler = onBecomeObservedHandler;\n        _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;\n        _this.isPendingUnobservation = false;\n        _this.isBeingTracked = false;\n        return _this;\n    }\n    Atom.prototype.reportObserved = function () {\n        startBatch();\n        _super.prototype.reportObserved.call(this);\n        if (!this.isBeingTracked) {\n            this.isBeingTracked = true;\n            this.onBecomeObservedHandler();\n        }\n        endBatch();\n        return !!globalState.trackingDerivation;\n    };\n    Atom.prototype.onBecomeUnobserved = function () {\n        this.isBeingTracked = false;\n        this.onBecomeUnobservedHandler();\n    };\n    return Atom;\n}(BaseAtom);\nexports.Atom = Atom;\nvar isAtom = createInstanceofPredicate(\"Atom\", BaseAtom);\nvar ComputedValue = function () {\n    function ComputedValue(derivation, scope, compareStructural, name, setter) {\n        this.derivation = derivation;\n        this.scope = scope;\n        this.compareStructural = compareStructural;\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.observing = [];\n        this.newObserving = null;\n        this.isPendingUnobservation = false;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.runId = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.UP_TO_DATE;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.value = undefined;\n        this.isComputing = false;\n        this.isRunningSetter = false;\n        this.name = name || \"ComputedValue@\" + getNextId();\n        if (setter) this.setter = createAction(name + \"-setter\", setter);\n    }\n    ComputedValue.prototype.onBecomeStale = function () {\n        propagateMaybeChanged(this);\n    };\n    ComputedValue.prototype.onBecomeUnobserved = function () {\n        invariant(this.dependenciesState !== IDerivationState.NOT_TRACKING, getMessage(\"m029\"));\n        clearObserving(this);\n        this.value = undefined;\n    };\n    ComputedValue.prototype.get = function () {\n        invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation);\n        if (globalState.inBatch === 0) {\n            startBatch();\n            if (shouldCompute(this)) this.value = this.computeValue(false);\n            endBatch();\n        } else {\n            reportObserved(this);\n            if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this);\n        }\n        var result = this.value;\n        if (isCaughtException(result)) throw result.cause;\n        return result;\n    };\n    ComputedValue.prototype.peek = function () {\n        var res = this.computeValue(false);\n        if (isCaughtException(res)) throw res.cause;\n        return res;\n    };\n    ComputedValue.prototype.set = function (value) {\n        if (this.setter) {\n            invariant(!this.isRunningSetter, \"The setter of computed value '\" + this.name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\");\n            this.isRunningSetter = true;\n            try {\n                this.setter.call(this.scope, value);\n            } finally {\n                this.isRunningSetter = false;\n            }\n        } else invariant(false, \"[ComputedValue '\" + this.name + \"'] It is not possible to assign a new value to a computed value.\");\n    };\n    ComputedValue.prototype.trackAndCompute = function () {\n        if (isSpyEnabled()) {\n            spyReport({\n                object: this.scope,\n                type: \"compute\",\n                fn: this.derivation\n            });\n        }\n        var oldValue = this.value;\n        var newValue = this.value = this.computeValue(true);\n        return isCaughtException(newValue) || valueDidChange(this.compareStructural, newValue, oldValue);\n    };\n    ComputedValue.prototype.computeValue = function (track) {\n        this.isComputing = true;\n        globalState.computationDepth++;\n        var res;\n        if (track) {\n            res = trackDerivedFunction(this, this.derivation, this.scope);\n        } else {\n            try {\n                res = this.derivation.call(this.scope);\n            } catch (e) {\n                res = new CaughtException(e);\n            }\n        }\n        globalState.computationDepth--;\n        this.isComputing = false;\n        return res;\n    };\n    ;\n    ComputedValue.prototype.observe = function (listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function () {\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener({\n                    type: \"update\",\n                    object: _this,\n                    newValue: newValue,\n                    oldValue: prevValue\n                });\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    ComputedValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ComputedValue.prototype.toString = function () {\n        return this.name + \"[\" + this.derivation.toString() + \"]\";\n    };\n    ComputedValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    ;\n    ComputedValue.prototype.whyRun = function () {\n        var isTracking = Boolean(globalState.trackingDerivation);\n        var observing = unique(this.isComputing ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        var observers = unique(getObservers(this).map(function (dep) {\n            return dep.name;\n        }));\n        return \"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + (isTracking ? \"[active] the value of this computation is needed by a reaction\" : this.isComputing ? \"[get] The value of this computed was requested outside a reaction\" : \"[idle] not running at the moment\") + \"\\n\" + (this.dependenciesState === IDerivationState.NOT_TRACKING ? getMessage(\"m032\") : \" * This computation will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this.isComputing && isTracking ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\\n  * If the outcome of this computation changes, the following observers will be re-run:\\n    \" + joinStrings(observers) + \"\\n\");\n    };\n    return ComputedValue;\n}();\nComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf;\nvar isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue);\nvar IDerivationState;\n(function (IDerivationState) {\n    IDerivationState[IDerivationState[\"NOT_TRACKING\"] = -1] = \"NOT_TRACKING\";\n    IDerivationState[IDerivationState[\"UP_TO_DATE\"] = 0] = \"UP_TO_DATE\";\n    IDerivationState[IDerivationState[\"POSSIBLY_STALE\"] = 1] = \"POSSIBLY_STALE\";\n    IDerivationState[IDerivationState[\"STALE\"] = 2] = \"STALE\";\n})(IDerivationState || (IDerivationState = {}));\nexports.IDerivationState = IDerivationState;\nvar CaughtException = function () {\n    function CaughtException(cause) {\n        this.cause = cause;\n    }\n    return CaughtException;\n}();\nfunction isCaughtException(e) {\n    return e instanceof CaughtException;\n}\nfunction shouldCompute(derivation) {\n    switch (derivation.dependenciesState) {\n        case IDerivationState.UP_TO_DATE:\n            return false;\n        case IDerivationState.NOT_TRACKING:\n        case IDerivationState.STALE:\n            return true;\n        case IDerivationState.POSSIBLY_STALE:\n            {\n                var prevUntracked = untrackedStart();\n                var obs = derivation.observing,\n                    l = obs.length;\n                for (var i = 0; i < l; i++) {\n                    var obj = obs[i];\n                    if (isComputedValue(obj)) {\n                        try {\n                            obj.get();\n                        } catch (e) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                        if (derivation.dependenciesState === IDerivationState.STALE) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                    }\n                }\n                changeDependenciesStateTo0(derivation);\n                untrackedEnd(prevUntracked);\n                return false;\n            }\n    }\n}\nfunction isComputingDerivation() {\n    return globalState.trackingDerivation !== null;\n}\nfunction checkIfStateModificationsAreAllowed(atom) {\n    var hasObservers = atom.observers.length > 0;\n    if (globalState.computationDepth > 0 && hasObservers) fail(getMessage(\"m031\") + atom.name);\n    if (!globalState.allowStateChanges && hasObservers) fail(getMessage(globalState.strictMode ? \"m030a\" : \"m030b\") + atom.name);\n}\nfunction trackDerivedFunction(derivation, f, context) {\n    changeDependenciesStateTo0(derivation);\n    derivation.newObserving = new Array(derivation.observing.length + 100);\n    derivation.unboundDepsCount = 0;\n    derivation.runId = ++globalState.runId;\n    var prevTracking = globalState.trackingDerivation;\n    globalState.trackingDerivation = derivation;\n    var result;\n    try {\n        result = f.call(context);\n    } catch (e) {\n        result = new CaughtException(e);\n    }\n    globalState.trackingDerivation = prevTracking;\n    bindDependencies(derivation);\n    return result;\n}\nfunction bindDependencies(derivation) {\n    var prevObserving = derivation.observing;\n    var observing = derivation.observing = derivation.newObserving;\n    derivation.newObserving = null;\n    var i0 = 0,\n        l = derivation.unboundDepsCount;\n    for (var i = 0; i < l; i++) {\n        var dep = observing[i];\n        if (dep.diffValue === 0) {\n            dep.diffValue = 1;\n            if (i0 !== i) observing[i0] = dep;\n            i0++;\n        }\n    }\n    observing.length = i0;\n    l = prevObserving.length;\n    while (l--) {\n        var dep = prevObserving[l];\n        if (dep.diffValue === 0) {\n            removeObserver(dep, derivation);\n        }\n        dep.diffValue = 0;\n    }\n    while (i0--) {\n        var dep = observing[i0];\n        if (dep.diffValue === 1) {\n            dep.diffValue = 0;\n            addObserver(dep, derivation);\n        }\n    }\n}\nfunction clearObserving(derivation) {\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        removeObserver(obs[i], derivation);\n    }derivation.dependenciesState = IDerivationState.NOT_TRACKING;\n    obs.length = 0;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    var res = action();\n    untrackedEnd(prev);\n    return res;\n}\nexports.untracked = untracked;\nfunction untrackedStart() {\n    var prev = globalState.trackingDerivation;\n    globalState.trackingDerivation = null;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.trackingDerivation = prev;\n}\nfunction changeDependenciesStateTo0(derivation) {\n    if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return;\n    derivation.dependenciesState = IDerivationState.UP_TO_DATE;\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nvar persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"];\nvar MobXGlobals = function () {\n    function MobXGlobals() {\n        this.version = 5;\n        this.trackingDerivation = null;\n        this.computationDepth = 0;\n        this.runId = 0;\n        this.mobxGuid = 0;\n        this.inBatch = 0;\n        this.pendingUnobservations = [];\n        this.pendingReactions = [];\n        this.isRunningReactions = false;\n        this.allowStateChanges = true;\n        this.strictMode = false;\n        this.resetId = 0;\n        this.spyListeners = [];\n        this.globalReactionErrorHandlers = [];\n    }\n    return MobXGlobals;\n}();\nvar globalState = new MobXGlobals();\nfunction shareGlobalState() {\n    var global = getGlobal();\n    var ownState = globalState;\n    if (global.__mobservableTrackingStack || global.__mobservableViewStack) throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\");\n    if (global.__mobxGlobal && global.__mobxGlobal.version !== ownState.version) throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\");\n    if (global.__mobxGlobal) globalState = global.__mobxGlobal;else global.__mobxGlobal = ownState;\n}\nfunction getGlobalState() {\n    return globalState;\n}\nfunction registerGlobals() {}\nfunction resetGlobalState() {\n    globalState.resetId++;\n    var defaultGlobals = new MobXGlobals();\n    for (var key in defaultGlobals) {\n        if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];\n    }globalState.allowStateChanges = !globalState.strictMode;\n}\nfunction hasObservers(observable) {\n    return observable.observers && observable.observers.length > 0;\n}\nfunction getObservers(observable) {\n    return observable.observers;\n}\nfunction invariantObservers(observable) {\n    var list = observable.observers;\n    var map = observable.observersIndexes;\n    var l = list.length;\n    for (var i = 0; i < l; i++) {\n        var id = list[i].__mapid;\n        if (i) {\n            invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\");\n        } else {\n            invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldnt be held in map.\");\n        }\n    }\n    invariant(list.length === 0 || Object.keys(map).length === list.length - 1, \"INTERNAL ERROR there is no junk in map\");\n}\nfunction addObserver(observable, node) {\n    var l = observable.observers.length;\n    if (l) {\n        observable.observersIndexes[node.__mapid] = l;\n    }\n    observable.observers[l] = node;\n    if (observable.lowestObserverState > node.dependenciesState) observable.lowestObserverState = node.dependenciesState;\n}\nfunction removeObserver(observable, node) {\n    if (observable.observers.length === 1) {\n        observable.observers.length = 0;\n        queueForUnobservation(observable);\n    } else {\n        var list = observable.observers;\n        var map_1 = observable.observersIndexes;\n        var filler = list.pop();\n        if (filler !== node) {\n            var index = map_1[node.__mapid] || 0;\n            if (index) {\n                map_1[filler.__mapid] = index;\n            } else {\n                delete map_1[filler.__mapid];\n            }\n            list[index] = filler;\n        }\n        delete map_1[node.__mapid];\n    }\n}\nfunction queueForUnobservation(observable) {\n    if (!observable.isPendingUnobservation) {\n        observable.isPendingUnobservation = true;\n        globalState.pendingUnobservations.push(observable);\n    }\n}\nfunction startBatch() {\n    globalState.inBatch++;\n}\nfunction endBatch() {\n    if (--globalState.inBatch === 0) {\n        runReactions();\n        var list = globalState.pendingUnobservations;\n        for (var i = 0; i < list.length; i++) {\n            var observable_1 = list[i];\n            observable_1.isPendingUnobservation = false;\n            if (observable_1.observers.length === 0) {\n                observable_1.onBecomeUnobserved();\n            }\n        }\n        globalState.pendingUnobservations = [];\n    }\n}\nfunction reportObserved(observable) {\n    var derivation = globalState.trackingDerivation;\n    if (derivation !== null) {\n        if (derivation.runId !== observable.lastAccessedBy) {\n            observable.lastAccessedBy = derivation.runId;\n            derivation.newObserving[derivation.unboundDepsCount++] = observable;\n        }\n    } else if (observable.observers.length === 0) {\n        queueForUnobservation(observable);\n    }\n}\nfunction invariantLOS(observable, msg) {\n    var min = getObservers(observable).reduce(function (a, b) {\n        return Math.min(a, b.dependenciesState);\n    }, 2);\n    if (min >= observable.lowestObserverState) return;\n    throw new Error(\"lowestObserverState is wrong for \" + msg + \" because \" + min + \" < \" + observable.lowestObserverState);\n}\nfunction propagateChanged(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale();\n        d.dependenciesState = IDerivationState.STALE;\n    }\n}\nfunction propagateChangeConfirmed(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.POSSIBLY_STALE) d.dependenciesState = IDerivationState.STALE;else if (d.dependenciesState === IDerivationState.UP_TO_DATE) observable.lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nfunction propagateMaybeChanged(observable) {\n    if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return;\n    observable.lowestObserverState = IDerivationState.POSSIBLY_STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {\n            d.dependenciesState = IDerivationState.POSSIBLY_STALE;\n            d.onBecomeStale();\n        }\n    }\n}\nvar Reaction = function () {\n    function Reaction(name, onInvalidate) {\n        if (name === void 0) {\n            name = \"Reaction@\" + getNextId();\n        }\n        this.name = name;\n        this.onInvalidate = onInvalidate;\n        this.observing = [];\n        this.newObserving = [];\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.diffValue = 0;\n        this.runId = 0;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.isDisposed = false;\n        this._isScheduled = false;\n        this._isTrackPending = false;\n        this._isRunning = false;\n    }\n    Reaction.prototype.onBecomeStale = function () {\n        this.schedule();\n    };\n    Reaction.prototype.schedule = function () {\n        if (!this._isScheduled) {\n            this._isScheduled = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    };\n    Reaction.prototype.isScheduled = function () {\n        return this._isScheduled;\n    };\n    Reaction.prototype.runReaction = function () {\n        if (!this.isDisposed) {\n            startBatch();\n            this._isScheduled = false;\n            if (shouldCompute(this)) {\n                this._isTrackPending = true;\n                this.onInvalidate();\n                if (this._isTrackPending && isSpyEnabled()) {\n                    spyReport({\n                        object: this,\n                        type: \"scheduled-reaction\"\n                    });\n                }\n            }\n            endBatch();\n        }\n    };\n    Reaction.prototype.track = function (fn) {\n        startBatch();\n        var notify = isSpyEnabled();\n        var startTime;\n        if (notify) {\n            startTime = Date.now();\n            spyReportStart({\n                object: this,\n                type: \"reaction\",\n                fn: fn\n            });\n        }\n        this._isRunning = true;\n        var result = trackDerivedFunction(this, fn, undefined);\n        this._isRunning = false;\n        this._isTrackPending = false;\n        if (this.isDisposed) {\n            clearObserving(this);\n        }\n        if (isCaughtException(result)) this.reportExceptionInDerivation(result.cause);\n        if (notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n        endBatch();\n    };\n    Reaction.prototype.reportExceptionInDerivation = function (error) {\n        var _this = this;\n        if (this.errorHandler) {\n            this.errorHandler(error, this);\n            return;\n        }\n        var message = \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this;\n        var messageToUser = getMessage(\"m037\");\n        console.error(message || messageToUser, error);\n        if (isSpyEnabled()) {\n            spyReport({\n                type: \"error\",\n                message: message,\n                error: error,\n                object: this\n            });\n        }\n        globalState.globalReactionErrorHandlers.forEach(function (f) {\n            return f(error, _this);\n        });\n    };\n    Reaction.prototype.dispose = function () {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            if (!this._isRunning) {\n                startBatch();\n                clearObserving(this);\n                endBatch();\n            }\n        }\n    };\n    Reaction.prototype.getDisposer = function () {\n        var r = this.dispose.bind(this);\n        r.$mobx = this;\n        r.onError = registerErrorHandler;\n        return r;\n    };\n    Reaction.prototype.toString = function () {\n        return \"Reaction[\" + this.name + \"]\";\n    };\n    Reaction.prototype.whyRun = function () {\n        var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        return \"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this._isRunning ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\";\n    };\n    return Reaction;\n}();\nexports.Reaction = Reaction;\nfunction registerErrorHandler(handler) {\n    invariant(this && this.$mobx && isReaction(this.$mobx), \"Invalid `this`\");\n    invariant(!this.$mobx.errorHandler, \"Only one onErrorHandler can be registered\");\n    this.$mobx.errorHandler = handler;\n}\nfunction onReactionError(handler) {\n    globalState.globalReactionErrorHandlers.push(handler);\n    return function () {\n        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n        if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);\n    };\n}\nvar MAX_REACTION_ITERATIONS = 100;\nvar reactionScheduler = function reactionScheduler(f) {\n    return f();\n};\nfunction runReactions() {\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) return;\n    reactionScheduler(runReactionsHelper);\n}\nfunction runReactionsHelper() {\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    while (allReactions.length > 0) {\n        if (++iterations === MAX_REACTION_ITERATIONS) {\n            console.error(\"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0]));\n            allReactions.splice(0);\n        }\n        var remainingReactions = allReactions.splice(0);\n        for (var i = 0, l = remainingReactions.length; i < l; i++) {\n            remainingReactions[i].runReaction();\n        }\n    }\n    globalState.isRunningReactions = false;\n}\nvar isReaction = createInstanceofPredicate(\"Reaction\", Reaction);\nfunction setReactionScheduler(fn) {\n    var baseScheduler = reactionScheduler;\n    reactionScheduler = function reactionScheduler(f) {\n        return fn(function () {\n            return baseScheduler(f);\n        });\n    };\n}\nfunction isSpyEnabled() {\n    return !!globalState.spyListeners.length;\n}\nfunction spyReport(event) {\n    if (!globalState.spyListeners.length) return;\n    var listeners = globalState.spyListeners;\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](event);\n    }\n}\nfunction spyReportStart(event) {\n    var change = objectAssign({}, event, { spyReportStart: true });\n    spyReport(change);\n}\nvar END_EVENT = { spyReportEnd: true };\nfunction spyReportEnd(change) {\n    if (change) spyReport(objectAssign({}, change, END_EVENT));else spyReport(END_EVENT);\n}\nfunction spy(listener) {\n    globalState.spyListeners.push(listener);\n    return once(function () {\n        var idx = globalState.spyListeners.indexOf(listener);\n        if (idx !== -1) globalState.spyListeners.splice(idx, 1);\n    });\n}\nexports.spy = spy;\nfunction hasInterceptors(interceptable) {\n    return interceptable.interceptors && interceptable.interceptors.length > 0;\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);\n    interceptors.push(handler);\n    return once(function () {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1) interceptors.splice(idx, 1);\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    try {\n        var interceptors = interceptable.interceptors;\n        if (interceptors) for (var i = 0, l = interceptors.length; i < l; i++) {\n            change = interceptors[i](change);\n            invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\");\n            if (!change) break;\n        }\n        return change;\n    } finally {\n        untrackedEnd(prevU);\n    }\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners && listenable.changeListeners.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners || (listenable.changeListeners = []);\n    listeners.push(handler);\n    return once(function () {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1) listeners.splice(idx, 1);\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners;\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](change);\n    }\n    untrackedEnd(prevU);\n}\nfunction asReference(value) {\n    deprecated(\"asReference is deprecated, use observable.ref instead\");\n    return observable.ref(value);\n}\nexports.asReference = asReference;\nfunction asStructure(value) {\n    deprecated(\"asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.\");\n    return observable.struct(value);\n}\nexports.asStructure = asStructure;\nfunction asFlat(value) {\n    deprecated(\"asFlat is deprecated, use observable.shallow instead\");\n    return observable.shallow(value);\n}\nexports.asFlat = asFlat;\nfunction asMap(data) {\n    deprecated(\"asMap is deprecated, use observable.map or observable.shallowMap instead\");\n    return observable.map(data || {});\n}\nexports.asMap = asMap;\nfunction isModifierDescriptor(thing) {\n    return (typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null && thing.isMobxModifierDescriptor === true;\n}\nexports.isModifierDescriptor = isModifierDescriptor;\nfunction createModifierDescriptor(enhancer, initialValue) {\n    invariant(!isModifierDescriptor(initialValue), \"Modifiers cannot be nested\");\n    return {\n        isMobxModifierDescriptor: true,\n        initialValue: initialValue,\n        enhancer: enhancer\n    };\n}\nfunction deepEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return observable.array(v, name);\n    if (isPlainObject(v)) return observable.object(v, name);\n    if (isES6Map(v)) return observable.map(v, name);\n    return v;\n}\nfunction shallowEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (v === undefined || v === null) return v;\n    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v)) return v;\n    if (Array.isArray(v)) return observable.shallowArray(v, name);\n    if (isPlainObject(v)) return observable.shallowObject(v, name);\n    if (isES6Map(v)) return observable.shallowMap(v, name);\n    return fail(\"The shallow modifier / decorator can only used in combination with arrays, objects and maps\");\n}\nfunction referenceEnhancer(newValue) {\n    return newValue;\n}\nfunction deepStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return new ObservableArray(v, deepStructEnhancer, name);\n    if (isES6Map(v)) return new ObservableMap(v, deepStructEnhancer, name);\n    if (isPlainObject(v)) {\n        var res = {};\n        asObservableObject(res, name);\n        extendObservableHelper(res, deepStructEnhancer, [v]);\n        return res;\n    }\n    return v;\n}\nfunction refStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    return v;\n}\nvar MAX_SPLICE_SIZE = 10000;\nvar safariPrototypeSetterInheritanceBug = function () {\n    var v = false;\n    var p = {};\n    Object.defineProperty(p, \"0\", { set: function set() {\n            v = true;\n        } });\n    Object.create(p)[\"0\"] = 1;\n    return v === false;\n}();\nvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\nvar StubArray = function () {\n    function StubArray() {}\n    return StubArray;\n}();\nStubArray.prototype = [];\nvar ObservableArrayAdministration = function () {\n    function ObservableArrayAdministration(name, enhancer, array, owned) {\n        this.array = array;\n        this.owned = owned;\n        this.lastKnownLength = 0;\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.atom = new BaseAtom(name || \"ObservableArray@\" + getNextId());\n        this.enhancer = function (newV, oldV) {\n            return enhancer(newV, oldV, name + \"[..]\");\n        };\n    }\n    ObservableArrayAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        if (fireImmediately) {\n            listener({\n                object: this.array,\n                type: \"splice\",\n                index: 0,\n                added: this.values.slice(),\n                addedCount: this.values.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    ObservableArrayAdministration.prototype.getArrayLength = function () {\n        this.atom.reportObserved();\n        return this.values.length;\n    };\n    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {\n        if (typeof newLength !== \"number\" || newLength < 0) throw new Error(\"[mobx.array] Out of range: \" + newLength);\n        var currentLength = this.values.length;\n        if (newLength === currentLength) return;else if (newLength > currentLength) {\n            var newItems = new Array(newLength - currentLength);\n            for (var i = 0; i < newLength - currentLength; i++) {\n                newItems[i] = undefined;\n            }this.spliceWithArray(currentLength, 0, newItems);\n        } else this.spliceWithArray(newLength, currentLength - newLength);\n    };\n    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {\n        if (oldLength !== this.lastKnownLength) throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\");\n        this.lastKnownLength += delta;\n        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1);\n    };\n    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        var _this = this;\n        checkIfStateModificationsAreAllowed(this.atom);\n        var length = this.values.length;\n        if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);\n        if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        if (newItems === undefined) newItems = [];\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.array,\n                type: \"splice\",\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change) return EMPTY_ARRAY;\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.map(function (v) {\n            return _this.enhancer(v, undefined);\n        });\n        var lengthDelta = newItems.length - deleteCount;\n        this.updateArrayLength(length, lengthDelta);\n        var res = this.spliceItemsIntoValues(index, deleteCount, newItems);\n        if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res);\n        return res;\n    };\n    ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) {\n        if (newItems.length < MAX_SPLICE_SIZE) {\n            return (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));\n        } else {\n            var res = this.values.slice(index, index + deleteCount);\n            this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount));\n            return res;\n        }\n        var _a;\n    };\n    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"update\",\n            index: index, newValue: newValue, oldValue: oldValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"splice\",\n            index: index, removed: removed, added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    return ObservableArrayAdministration;\n}();\nvar ObservableArray = function (_super) {\n    __extends(ObservableArray, _super);\n    function ObservableArray(initialValues, enhancer, name, owned) {\n        if (name === void 0) {\n            name = \"ObservableArray@\" + getNextId();\n        }\n        if (owned === void 0) {\n            owned = false;\n        }\n        var _this = _super.call(this) || this;\n        var adm = new ObservableArrayAdministration(name, enhancer, _this, owned);\n        addHiddenFinalProp(_this, \"$mobx\", adm);\n        if (initialValues && initialValues.length) {\n            adm.updateArrayLength(0, initialValues.length);\n            adm.values = initialValues.map(function (v) {\n                return enhancer(v, undefined, name + \"[..]\");\n            });\n            adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY);\n        } else {\n            adm.values = [];\n        }\n        if (safariPrototypeSetterInheritanceBug) {\n            Object.defineProperty(adm.array, \"0\", ENTRY_0);\n        }\n        return _this;\n    }\n    ObservableArray.prototype.intercept = function (handler) {\n        return this.$mobx.intercept(handler);\n    };\n    ObservableArray.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        return this.$mobx.observe(listener, fireImmediately);\n    };\n    ObservableArray.prototype.clear = function () {\n        return this.splice(0);\n    };\n    ObservableArray.prototype.concat = function () {\n        var arrays = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            arrays[_i] = arguments[_i];\n        }\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) {\n            return isObservableArray(a) ? a.peek() : a;\n        }));\n    };\n    ObservableArray.prototype.replace = function (newItems) {\n        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);\n    };\n    ObservableArray.prototype.toJS = function () {\n        return this.slice();\n    };\n    ObservableArray.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableArray.prototype.peek = function () {\n        return this.$mobx.values;\n    };\n    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {\n        if (fromIndex === void 0) {\n            fromIndex = 0;\n        }\n        this.$mobx.atom.reportObserved();\n        var items = this.$mobx.values,\n            l = items.length;\n        for (var i = fromIndex; i < l; i++) {\n            if (predicate.call(thisArg, items[i], i, this)) return items[i];\n        }return undefined;\n    };\n    ObservableArray.prototype.splice = function (index, deleteCount) {\n        var newItems = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            newItems[_i - 2] = arguments[_i];\n        }\n        switch (arguments.length) {\n            case 0:\n                return [];\n            case 1:\n                return this.$mobx.spliceWithArray(index);\n            case 2:\n                return this.$mobx.spliceWithArray(index, deleteCount);\n        }\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.push = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(adm.values.length, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.pop = function () {\n        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];\n    };\n    ObservableArray.prototype.shift = function () {\n        return this.splice(0, 1)[0];\n    };\n    ObservableArray.prototype.unshift = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(0, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.reverse = function () {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.reverse.apply(clone, arguments);\n    };\n    ObservableArray.prototype.sort = function (compareFn) {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.sort.apply(clone, arguments);\n    };\n    ObservableArray.prototype.remove = function (value) {\n        var idx = this.$mobx.values.indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    };\n    ObservableArray.prototype.move = function (fromIndex, toIndex) {\n        function checkIndex(index) {\n            if (index < 0) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\n            }\n            var length = this.$mobx.values.length;\n            if (index >= length) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\n            }\n        }\n        checkIndex.call(this, fromIndex);\n        checkIndex.call(this, toIndex);\n        if (fromIndex === toIndex) {\n            return;\n        }\n        var oldItems = this.$mobx.values;\n        var newItems;\n        if (fromIndex < toIndex) {\n            newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1));\n        } else {\n            newItems = oldItems.slice(0, toIndex).concat([oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\n        }\n        this.replace(newItems);\n    };\n    ObservableArray.prototype.toString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toString.apply(this.$mobx.values, arguments);\n    };\n    ObservableArray.prototype.toLocaleString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toLocaleString.apply(this.$mobx.values, arguments);\n    };\n    return ObservableArray;\n}(StubArray);\ndeclareIterator(ObservableArray.prototype, function () {\n    return arrayAsIterator(this.slice());\n});\nmakeNonEnumerable(ObservableArray.prototype, [\"constructor\", \"intercept\", \"observe\", \"clear\", \"concat\", \"replace\", \"toJS\", \"toJSON\", \"peek\", \"find\", \"splice\", \"spliceWithArray\", \"push\", \"pop\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"remove\", \"move\", \"toString\", \"toLocaleString\"]);\nObject.defineProperty(ObservableArray.prototype, \"length\", {\n    enumerable: false,\n    configurable: true,\n    get: function get() {\n        return this.$mobx.getArrayLength();\n    },\n    set: function set(newLength) {\n        this.$mobx.setArrayLength(newLength);\n    }\n});\n[\"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function (funcName) {\n    var baseFunc = Array.prototype[funcName];\n    invariant(typeof baseFunc === \"function\", \"Base function not defined on Array prototype: '\" + funcName + \"'\");\n    addHiddenProp(ObservableArray.prototype, funcName, function () {\n        this.$mobx.atom.reportObserved();\n        return baseFunc.apply(this.$mobx.values, arguments);\n    });\n});\nvar ENTRY_0 = {\n    configurable: true,\n    enumerable: false,\n    set: createArraySetter(0),\n    get: createArrayGetter(0)\n};\nfunction createArrayBufferItem(index) {\n    var set = createArraySetter(index);\n    var get = createArrayGetter(index);\n    Object.defineProperty(ObservableArray.prototype, \"\" + index, {\n        enumerable: false,\n        configurable: true,\n        set: set, get: get\n    });\n}\nfunction createArraySetter(index) {\n    return function (newValue) {\n        var adm = this.$mobx;\n        var values = adm.values;\n        if (index < values.length) {\n            checkIfStateModificationsAreAllowed(adm.atom);\n            var oldValue = values[index];\n            if (hasInterceptors(adm)) {\n                var change = interceptChange(adm, {\n                    type: \"update\",\n                    object: adm.array,\n                    index: index, newValue: newValue\n                });\n                if (!change) return;\n                newValue = change.newValue;\n            }\n            newValue = adm.enhancer(newValue, oldValue);\n            var changed = newValue !== oldValue;\n            if (changed) {\n                values[index] = newValue;\n                adm.notifyArrayChildUpdate(index, newValue, oldValue);\n            }\n        } else if (index === values.length) {\n            adm.spliceWithArray(index, 0, [newValue]);\n        } else throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length);\n    };\n}\nfunction createArrayGetter(index) {\n    return function () {\n        var impl = this.$mobx;\n        if (impl) {\n            if (index < impl.values.length) {\n                impl.atom.reportObserved();\n                return impl.values[index];\n            }\n            console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\");\n        }\n        return undefined;\n    };\n}\nfunction reserveArrayBuffer(max) {\n    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) {\n        createArrayBufferItem(index);\n    }OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n}\nreserveArrayBuffer(1000);\nvar isObservableArrayAdministration = createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\nfunction isObservableArray(thing) {\n    return isObject(thing) && isObservableArrayAdministration(thing.$mobx);\n}\nexports.isObservableArray = isObservableArray;\nvar ObservableMapMarker = {};\nvar ObservableMap = function () {\n    function ObservableMap(initialData, enhancer, name) {\n        if (enhancer === void 0) {\n            enhancer = deepEnhancer;\n        }\n        if (name === void 0) {\n            name = \"ObservableMap@\" + getNextId();\n        }\n        this.enhancer = enhancer;\n        this.name = name;\n        this.$mobx = ObservableMapMarker;\n        this._data = {};\n        this._hasMap = {};\n        this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + \".keys()\", true);\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.merge(initialData);\n    }\n    ObservableMap.prototype._has = function (key) {\n        return typeof this._data[key] !== \"undefined\";\n    };\n    ObservableMap.prototype.has = function (key) {\n        if (!this.isValidKey(key)) return false;\n        key = \"\" + key;\n        if (this._hasMap[key]) return this._hasMap[key].get();\n        return this._updateHasMapEntry(key, false).get();\n    };\n    ObservableMap.prototype.set = function (key, value) {\n        this.assertValidKey(key);\n        key = \"\" + key;\n        var hasKey = this._has(key);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? \"update\" : \"add\",\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change) return this;\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this._updateValue(key, value);\n        } else {\n            this._addValue(key, value);\n        }\n        return this;\n    };\n    ObservableMap.prototype.delete = function (key) {\n        var _this = this;\n        this.assertValidKey(key);\n        key = \"\" + key;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: \"delete\",\n                object: this,\n                name: key\n            });\n            if (!change) return false;\n        }\n        if (this._has(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"delete\",\n                object: this,\n                oldValue: this._data[key].value,\n                name: key\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            runInTransaction(function () {\n                _this._keys.remove(key);\n                _this._updateHasMapEntry(key, false);\n                var observable = _this._data[key];\n                observable.setNewValue(undefined);\n                _this._data[key] = undefined;\n            });\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n            return true;\n        }\n        return false;\n    };\n    ObservableMap.prototype._updateHasMapEntry = function (key, value) {\n        var entry = this._hasMap[key];\n        if (entry) {\n            entry.setNewValue(value);\n        } else {\n            entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + \".\" + key + \"?\", false);\n        }\n        return entry;\n    };\n    ObservableMap.prototype._updateValue = function (name, newValue) {\n        var observable = this._data[name];\n        newValue = observable.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"update\",\n                object: this,\n                oldValue: observable.value,\n                name: name, newValue: newValue\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            observable.setNewValue(newValue);\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableMap.prototype._addValue = function (name, newValue) {\n        var _this = this;\n        runInTransaction(function () {\n            var observable = _this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + \".\" + name, false);\n            newValue = observable.value;\n            _this._updateHasMapEntry(name, true);\n            _this._keys.push(name);\n        });\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            type: \"add\",\n            object: this,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableMap.prototype.get = function (key) {\n        key = \"\" + key;\n        if (this.has(key)) return this._data[key].get();\n        return undefined;\n    };\n    ObservableMap.prototype.keys = function () {\n        return arrayAsIterator(this._keys.slice());\n    };\n    ObservableMap.prototype.values = function () {\n        return arrayAsIterator(this._keys.map(this.get, this));\n    };\n    ObservableMap.prototype.entries = function () {\n        var _this = this;\n        return arrayAsIterator(this._keys.map(function (key) {\n            return [key, _this.get(key)];\n        }));\n    };\n    ObservableMap.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        this.keys().forEach(function (key) {\n            return callback.call(thisArg, _this.get(key), key, _this);\n        });\n    };\n    ObservableMap.prototype.merge = function (other) {\n        var _this = this;\n        if (isObservableMap(other)) {\n            other = other.toJS();\n        }\n        runInTransaction(function () {\n            if (isPlainObject(other)) Object.keys(other).forEach(function (key) {\n                return _this.set(key, other[key]);\n            });else if (Array.isArray(other)) other.forEach(function (_a) {\n                var key = _a[0],\n                    value = _a[1];\n                return _this.set(key, value);\n            });else if (isES6Map(other)) other.forEach(function (value, key) {\n                return _this.set(key, value);\n            });else if (other !== null && other !== undefined) fail(\"Cannot initialize map from \" + other);\n        });\n        return this;\n    };\n    ObservableMap.prototype.clear = function () {\n        var _this = this;\n        runInTransaction(function () {\n            untracked(function () {\n                _this.keys().forEach(_this.delete, _this);\n            });\n        });\n    };\n    ObservableMap.prototype.replace = function (values) {\n        var _this = this;\n        runInTransaction(function () {\n            _this.clear();\n            _this.merge(values);\n        });\n        return this;\n    };\n    Object.defineProperty(ObservableMap.prototype, \"size\", {\n        get: function get() {\n            return this._keys.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObservableMap.prototype.toJS = function () {\n        var _this = this;\n        var res = {};\n        this.keys().forEach(function (key) {\n            return res[key] = _this.get(key);\n        });\n        return res;\n    };\n    ObservableMap.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableMap.prototype.isValidKey = function (key) {\n        if (key === null || key === undefined) return false;\n        if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"boolean\") return true;\n        return false;\n    };\n    ObservableMap.prototype.assertValidKey = function (key) {\n        if (!this.isValidKey(key)) throw new Error(\"[mobx.map] Invalid key: '\" + key + \"', only strings, numbers and booleans are accepted as key in observable maps.\");\n    };\n    ObservableMap.prototype.toString = function () {\n        var _this = this;\n        return this.name + \"[{ \" + this.keys().map(function (key) {\n            return key + \": \" + (\"\" + _this.get(key));\n        }).join(\", \") + \" }]\";\n    };\n    ObservableMap.prototype.observe = function (listener, fireImmediately) {\n        invariant(fireImmediately !== true, getMessage(\"m033\"));\n        return registerListener(this, listener);\n    };\n    ObservableMap.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableMap;\n}();\nexports.ObservableMap = ObservableMap;\ndeclareIterator(ObservableMap.prototype, function () {\n    return this.entries();\n});\nfunction map(initialValues) {\n    deprecated(\"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\");\n    return observable.map(initialValues);\n}\nexports.map = map;\nvar isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap);\nexports.isObservableMap = isObservableMap;\nvar ObservableObjectAdministration = function () {\n    function ObservableObjectAdministration(target, name) {\n        this.target = target;\n        this.name = name;\n        this.values = {};\n        this.changeListeners = null;\n        this.interceptors = null;\n    }\n    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {\n        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\");\n        return registerListener(this, callback);\n    };\n    ObservableObjectAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableObjectAdministration;\n}();\nfunction asObservableObject(target, name) {\n    if (isObservableObject(target)) return target.$mobx;\n    invariant(Object.isExtensible(target), getMessage(\"m035\"));\n    if (!isPlainObject(target)) name = (target.constructor.name || \"ObservableObject\") + \"@\" + getNextId();\n    if (!name) name = \"ObservableObject@\" + getNextId();\n    var adm = new ObservableObjectAdministration(target, name);\n    addHiddenFinalProp(target, \"$mobx\", adm);\n    return adm;\n}\nfunction defineObservablePropertyFromDescriptor(adm, propName, descriptor, defaultEnhancer) {\n    if (adm.values[propName]) {\n        invariant(\"value\" in descriptor, \"The property \" + propName + \" in \" + adm.name + \" is already observable, cannot redefine it as computed property\");\n        adm.target[propName] = descriptor.value;\n        return;\n    }\n    if (\"value\" in descriptor) {\n        if (isModifierDescriptor(descriptor.value)) {\n            var modifierDescriptor = descriptor.value;\n            defineObservableProperty(adm, propName, modifierDescriptor.initialValue, modifierDescriptor.enhancer);\n        } else if (isAction(descriptor.value) && descriptor.value.autoBind === true) {\n            defineBoundAction(adm.target, propName, descriptor.value.originalFn);\n        } else if (isComputedValue(descriptor.value)) {\n            defineComputedPropertyFromComputedValue(adm, propName, descriptor.value);\n        } else {\n            defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer);\n        }\n    } else {\n        defineComputedProperty(adm, propName, descriptor.get, descriptor.set, false, true);\n    }\n}\nfunction defineObservableProperty(adm, propName, newValue, enhancer) {\n    assertPropertyConfigurable(adm.target, propName);\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            object: adm.target,\n            name: propName,\n            type: \"add\",\n            newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    var observable = adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + \".\" + propName, false);\n    newValue = observable.value;\n    Object.defineProperty(adm.target, propName, generateObservablePropConfig(propName));\n    notifyPropertyAddition(adm, adm.target, propName, newValue);\n}\nfunction defineComputedProperty(adm, propName, getter, setter, compareStructural, asInstanceProperty) {\n    if (asInstanceProperty) assertPropertyConfigurable(adm.target, propName);\n    adm.values[propName] = new ComputedValue(getter, adm.target, compareStructural, adm.name + \".\" + propName, setter);\n    if (asInstanceProperty) {\n        Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n    }\n}\nfunction defineComputedPropertyFromComputedValue(adm, propName, computedValue) {\n    var name = adm.name + \".\" + propName;\n    computedValue.name = name;\n    if (!computedValue.scope) computedValue.scope = adm.target;\n    adm.values[propName] = computedValue;\n    Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n}\nvar observablePropertyConfigs = {};\nvar computedPropertyConfigs = {};\nfunction generateObservablePropConfig(propName) {\n    return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            setPropertyValue(this, propName, v);\n        }\n    });\n}\nfunction generateComputedPropConfig(propName) {\n    return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: false,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            return this.$mobx.values[propName].set(v);\n        }\n    });\n}\nfunction setPropertyValue(instance, name, newValue) {\n    var adm = instance.$mobx;\n    var observable = adm.values[name];\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            type: \"update\",\n            object: instance,\n            name: name, newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    newValue = observable.prepareNewValue(newValue);\n    if (newValue !== UNCHANGED) {\n        var notify = hasListeners(adm);\n        var notifySpy = isSpyEnabled();\n        var change = notify || notifySpy ? {\n            type: \"update\",\n            object: instance,\n            oldValue: observable.value,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        observable.setNewValue(newValue);\n        if (notify) notifyListeners(adm, change);\n        if (notifySpy) spyReportEnd();\n    }\n}\nfunction notifyPropertyAddition(adm, object, name, newValue) {\n    var notify = hasListeners(adm);\n    var notifySpy = isSpyEnabled();\n    var change = notify || notifySpy ? {\n        type: \"add\",\n        object: object, name: name, newValue: newValue\n    } : null;\n    if (notifySpy) spyReportStart(change);\n    if (notify) notifyListeners(adm, change);\n    if (notifySpy) spyReportEnd();\n}\nvar isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\nfunction isObservableObject(thing) {\n    if (isObject(thing)) {\n        runLazyInitializers(thing);\n        return isObservableObjectAdministration(thing.$mobx);\n    }\n    return false;\n}\nexports.isObservableObject = isObservableObject;\nvar UNCHANGED = {};\nvar ObservableValue = function (_super) {\n    __extends(ObservableValue, _super);\n    function ObservableValue(value, enhancer, name, notifySpy) {\n        if (name === void 0) {\n            name = \"ObservableValue@\" + getNextId();\n        }\n        if (notifySpy === void 0) {\n            notifySpy = true;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.enhancer = enhancer;\n        _this.hasUnreportedChange = false;\n        _this.value = enhancer(value, undefined, name);\n        if (notifySpy && isSpyEnabled()) {\n            spyReport({ type: \"create\", object: _this, newValue: _this.value });\n        }\n        return _this;\n    }\n    ObservableValue.prototype.set = function (newValue) {\n        var oldValue = this.value;\n        newValue = this.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if (notifySpy) {\n                spyReportStart({\n                    type: \"update\",\n                    object: this,\n                    newValue: newValue, oldValue: oldValue\n                });\n            }\n            this.setNewValue(newValue);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableValue.prototype.prepareNewValue = function (newValue) {\n        checkIfStateModificationsAreAllowed(this);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue });\n            if (!change) return UNCHANGED;\n            newValue = change.newValue;\n        }\n        newValue = this.enhancer(newValue, this.value, this.name);\n        return this.value !== newValue ? newValue : UNCHANGED;\n    };\n    ObservableValue.prototype.setNewValue = function (newValue) {\n        var oldValue = this.value;\n        this.value = newValue;\n        this.reportChanged();\n        if (hasListeners(this)) {\n            notifyListeners(this, {\n                type: \"update\",\n                object: this,\n                newValue: newValue,\n                oldValue: oldValue\n            });\n        }\n    };\n    ObservableValue.prototype.get = function () {\n        this.reportObserved();\n        return this.value;\n    };\n    ObservableValue.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableValue.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately) listener({\n            object: this,\n            type: \"update\",\n            newValue: this.value,\n            oldValue: undefined\n        });\n        return registerListener(this, listener);\n    };\n    ObservableValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ObservableValue.prototype.toString = function () {\n        return this.name + \"[\" + this.value + \"]\";\n    };\n    ObservableValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    return ObservableValue;\n}(BaseAtom);\nObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf;\nvar isObservableValue = createInstanceofPredicate(\"ObservableValue\", ObservableValue);\nexports.isBoxedObservable = isObservableValue;\nfunction getAtom(thing, property) {\n    if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            invariant(property === undefined, getMessage(\"m036\"));\n            return thing.$mobx.atom;\n        }\n        if (isObservableMap(thing)) {\n            var anyThing = thing;\n            if (property === undefined) return getAtom(anyThing._keys);\n            var observable_2 = anyThing._data[property] || anyThing._hasMap[property];\n            invariant(!!observable_2, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\");\n            return observable_2;\n        }\n        runLazyInitializers(thing);\n        if (isObservableObject(thing)) {\n            if (!property) return fail(\"please specify a property\");\n            var observable_3 = thing.$mobx.values[property];\n            invariant(!!observable_3, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\");\n            return observable_3;\n        }\n        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n            return thing;\n        }\n    } else if (typeof thing === \"function\") {\n        if (isReaction(thing.$mobx)) {\n            return thing.$mobx;\n        }\n    }\n    return fail(\"Cannot obtain atom from \" + thing);\n}\nfunction getAdministration(thing, property) {\n    invariant(thing, \"Expecting some object\");\n    if (property !== undefined) return getAdministration(getAtom(thing, property));\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;\n    if (isObservableMap(thing)) return thing;\n    runLazyInitializers(thing);\n    if (thing.$mobx) return thing.$mobx;\n    invariant(false, \"Cannot obtain administration from \" + thing);\n}\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing)) named = getAdministration(thing);else named = getAtom(thing);\n    return named.name;\n}\nfunction createClassPropertyDecorator(onInitialize, _get, _set, enumerable, allowCustomArguments) {\n    function classPropertyDecorator(target, key, descriptor, customArgs, argLen) {\n        if (argLen === void 0) {\n            argLen = 0;\n        }\n        invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\");\n        if (!descriptor) {\n            var newDescriptor = {\n                enumerable: enumerable,\n                configurable: true,\n                get: function get() {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {\n                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);\n                    } else {\n                        _set.call(this, key, v);\n                    }\n                }\n            };\n            if (arguments.length < 3 || arguments.length === 5 && argLen < 3) {\n                Object.defineProperty(target, key, newDescriptor);\n            }\n            return newDescriptor;\n        } else {\n            if (!hasOwnProperty(target, \"__mobxLazyInitializers\")) {\n                addHiddenProp(target, \"__mobxLazyInitializers\", target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice() || []);\n            }\n            var value_1 = descriptor.value,\n                initializer_1 = descriptor.initializer;\n            target.__mobxLazyInitializers.push(function (instance) {\n                onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor);\n            });\n            return {\n                enumerable: enumerable, configurable: true,\n                get: function get() {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    _set.call(this, key, v);\n                }\n            };\n        }\n    }\n    if (allowCustomArguments) {\n        return function () {\n            if (quacksLikeADecorator(arguments)) return classPropertyDecorator.apply(null, arguments);\n            var outerArgs = arguments;\n            var argLen = arguments.length;\n            return function (target, key, descriptor) {\n                return classPropertyDecorator(target, key, descriptor, outerArgs, argLen);\n            };\n        };\n    }\n    return classPropertyDecorator;\n}\nfunction typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {\n    if (!hasOwnProperty(instance, \"__mobxInitializedProps\")) addHiddenProp(instance, \"__mobxInitializedProps\", {});\n    instance.__mobxInitializedProps[key] = true;\n    onInitialize(instance, key, v, customArgs, baseDescriptor);\n}\nfunction runLazyInitializers(instance) {\n    if (instance.__mobxDidRunLazyInitializers === true) return;\n    if (instance.__mobxLazyInitializers) {\n        addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true);\n        instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) {\n            return initializer(instance);\n        });\n    }\n}\nfunction quacksLikeADecorator(args) {\n    return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\";\n}\nfunction iteratorSymbol() {\n    return typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n}\nvar IS_ITERATING_MARKER = \"__$$iterating\";\nfunction arrayAsIterator(array) {\n    invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\");\n    addHiddenFinalProp(array, IS_ITERATING_MARKER, true);\n    var idx = -1;\n    addHiddenFinalProp(array, \"next\", function next() {\n        idx++;\n        return {\n            done: idx >= this.length,\n            value: idx < this.length ? this[idx] : undefined\n        };\n    });\n    return array;\n}\nfunction declareIterator(prototType, iteratorFactory) {\n    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);\n}\nvar messages = {\n    \"m001\": \"It is not allowed to assign new values to @action fields\",\n    \"m002\": \"`runInAction` expects a function\",\n    \"m003\": \"`runInAction` expects a function without arguments\",\n    \"m004\": \"autorun expects a function\",\n    \"m005\": \"Warning: attempted to pass an action to autorun. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m006\": \"Warning: attempted to pass an action to autorunAsync. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m007\": \"reaction only accepts 2 or 3 arguments. If migrating from MobX 2, please provide an options object\",\n    \"m008\": \"wrapping reaction expression in `asReference` is no longer supported, use options object instead\",\n    \"m009\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\",\n    \"m010\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\",\n    \"m011\": \"First argument to `computed` should be an expression. If using computed as decorator, don't pass it arguments\",\n    \"m012\": \"computed takes one or two arguments if used as function\",\n    \"m013\": \"[mobx.expr] 'expr' should only be used inside other reactive functions.\",\n    \"m014\": \"extendObservable expected 2 or more arguments\",\n    \"m015\": \"extendObservable expects an object as first argument\",\n    \"m016\": \"extendObservable should not be used on maps, use map.merge instead\",\n    \"m017\": \"all arguments of extendObservable should be objects\",\n    \"m018\": \"extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540\",\n    \"m019\": \"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\",\n    \"m020\": \"modifiers can only be used for individual object properties\",\n    \"m021\": \"observable expects zero or one arguments\",\n    \"m022\": \"@observable can not be used on getters, use @computed instead\",\n    \"m023\": \"Using `transaction` is deprecated, use `runInAction` or `(@)action` instead.\",\n    \"m024\": \"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested its value.\",\n    \"m025\": \"whyRun can only be used on reactions and computed values\",\n    \"m026\": \"`action` can only be invoked on functions\",\n    \"m028\": \"It is not allowed to set `useStrict` when a derivation is running\",\n    \"m029\": \"INTERNAL ERROR only onBecomeUnobserved shouldn't be called twice in a row\",\n    \"m030a\": \"Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: \",\n    \"m030b\": \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: \",\n    \"m031\": \"Computed values are not allowed to not cause side effects by changing observables that are already being observed. Tried to modify: \",\n    \"m032\": \"* This computation is suspended (not in use by any reaction) and won't run automatically.\\n\tDidn't expect this computation to be suspended at this point?\\n\t  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n\t  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\",\n    \"m033\": \"`observe` doesn't support the fire immediately property for observable maps.\",\n    \"m034\": \"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\",\n    \"m035\": \"Cannot make the designated object observable; it is not extensible\",\n    \"m036\": \"It is not possible to get index atoms from arrays\",\n    \"m037\": \"Hi there! I'm sorry you have just run into an exception.\\nIf your debugger ends up here, know that some reaction (like the render() of an observer component, autorun or reaction)\\nthrew an exception and that mobx caught it, to avoid that it brings the rest of your application down.\\nThe original cause of the exception (the code that caused this reaction to run (again)), is still in the stack.\\n\\nHowever, more interesting is the actual stack trace of the error itself.\\nHopefully the error is an instanceof Error, because in that case you can inspect the original stack of the error from where it was thrown.\\nSee `error.stack` property, or press the very subtle \\\"(...)\\\" link you see near the console.error message that probably brought you here.\\nThat stack is more interesting than the stack of this console.error itself.\\n\\nIf the exception you see is an exception you created yourself, make sure to use `throw new Error(\\\"Oops\\\")` instead of `throw \\\"Oops\\\"`,\\nbecause the javascript environment will only preserve the original stack trace in the first form.\\n\\nYou can also make sure the debugger pauses the next time this very same exception is thrown by enabling \\\"Pause on caught exception\\\".\\n(Note that it might pause on many other, unrelated exception as well).\\n\\nIf that all doesn't help you out, feel free to open an issue https://github.com/mobxjs/mobx/issues!\\n\",\n    \"m038\": \"Missing items in this list?\\n    1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n    2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\"\n};\nfunction getMessage(id) {\n    return messages[id];\n}\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nfunction getGlobal() {\n    return global;\n}\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\nfunction fail(message, thing) {\n    invariant(false, message, thing);\n    throw \"X\";\n}\nfunction invariant(check, message, thing) {\n    if (!check) throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\"));\n}\nvar deprecatedMessages = [];\nfunction deprecated(msg) {\n    if (deprecatedMessages.indexOf(msg) !== -1) return false;\n    deprecatedMessages.push(msg);\n    console.error(\"[mobx] Deprecated: \" + msg);\n    return true;\n}\nfunction once(func) {\n    var invoked = false;\n    return function () {\n        if (invoked) return;\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function noop() {};\nfunction unique(list) {\n    var res = [];\n    list.forEach(function (item) {\n        if (res.indexOf(item) === -1) res.push(item);\n    });\n    return res;\n}\nfunction joinStrings(things, limit, separator) {\n    if (limit === void 0) {\n        limit = 100;\n    }\n    if (separator === void 0) {\n        separator = \" - \";\n    }\n    if (!things) return \"\";\n    var sliced = things.slice(0, limit);\n    return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\");\n}\nfunction isObject(value) {\n    return value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\";\n}\nfunction isPlainObject(value) {\n    if (value === null || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false;\n    var proto = Object.getPrototypeOf(value);\n    return proto === Object.prototype || proto === null;\n}\nfunction objectAssign() {\n    var res = arguments[0];\n    for (var i = 1, l = arguments.length; i < l; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n            if (hasOwnProperty(source, key)) {\n                res[key] = source[key];\n            }\n        }\n    }\n    return res;\n}\nfunction valueDidChange(compareStructural, oldValue, newValue) {\n    if (typeof oldValue === 'number' && isNaN(oldValue)) {\n        return typeof newValue !== 'number' || !isNaN(newValue);\n    }\n    return compareStructural ? !deepEqual(oldValue, newValue) : oldValue !== newValue;\n}\nvar prototypeHasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(object, propName) {\n    return prototypeHasOwnProperty.call(object, propName);\n}\nfunction makeNonEnumerable(object, propNames) {\n    for (var i = 0; i < propNames.length; i++) {\n        addHiddenProp(object, propNames[i], object[propNames[i]]);\n    }\n}\nfunction addHiddenProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\nfunction isPropertyConfigurable(object, prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(object, prop);\n    return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;\n}\nfunction assertPropertyConfigurable(object, prop) {\n    invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\");\n}\nfunction getEnumerableKeys(obj) {\n    var res = [];\n    for (var key in obj) {\n        res.push(key);\n    }return res;\n}\nfunction deepEqual(a, b) {\n    if (a === null && b === null) return true;\n    if (a === undefined && b === undefined) return true;\n    if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) !== \"object\") return a === b;\n    var aIsArray = isArrayLike(a);\n    var aIsMap = isMapLike(a);\n    if (aIsArray !== isArrayLike(b)) {\n        return false;\n    } else if (aIsMap !== isMapLike(b)) {\n        return false;\n    } else if (aIsArray) {\n        if (a.length !== b.length) return false;\n        for (var i = a.length - 1; i >= 0; i--) {\n            if (!deepEqual(a[i], b[i])) return false;\n        }return true;\n    } else if (aIsMap) {\n        if (a.size !== b.size) return false;\n        var equals_1 = true;\n        a.forEach(function (value, key) {\n            equals_1 = equals_1 && deepEqual(b.get(key), value);\n        });\n        return equals_1;\n    } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === \"object\" && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === \"object\") {\n        if (a === null || b === null) return false;\n        if (isMapLike(a) && isMapLike(b)) {\n            if (a.size !== b.size) return false;\n            return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries());\n        }\n        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length) return false;\n        for (var prop in a) {\n            if (!(prop in b)) return false;\n            if (!deepEqual(a[prop], b[prop])) return false;\n        }\n        return true;\n    }\n    return false;\n}\nfunction createInstanceofPredicate(name, clazz) {\n    var propName = \"isMobX\" + name;\n    clazz.prototype[propName] = true;\n    return function (x) {\n        return isObject(x) && x[propName] === true;\n    };\n}\nfunction isArrayLike(x) {\n    return Array.isArray(x) || isObservableArray(x);\n}\nexports.isArrayLike = isArrayLike;\nfunction isMapLike(x) {\n    return isES6Map(x) || isObservableMap(x);\n}\nfunction isES6Map(thing) {\n    if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map) return true;\n    return false;\n}\nfunction primitiveSymbol() {\n    return typeof Symbol === \"function\" && Symbol.toPrimitive || \"@@toPrimitive\";\n}\nfunction toPrimitive(value) {\n    return value === null ? null : (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? \"\" + value : value;\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _icons = __webpack_require__(6);\n\nvar _constants = __webpack_require__(0);\n\nfunction renderHeader(_ref, instance) {\n  var meta = _ref.meta,\n      user = _ref.user,\n      reactions = _ref.reactions;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-header-container';\n\n  var likeButton = document.createElement('span');\n  var likedReaction = reactions.find(function (reaction) {\n    return reaction.content === 'heart' && reaction.user.login === user.login;\n  });\n  likeButton.className = 'gitment-header-like-btn';\n  likeButton.innerHTML = '\\n    ' + _icons.heart + '\\n    ' + (likedReaction ? 'Unlike' : 'Like') + '\\n    ' + (meta.reactions && meta.reactions.heart ? ' \\u2022 <strong>' + meta.reactions.heart + '</strong> Liked' : '') + '\\n  ';\n\n  if (likedReaction) {\n    likeButton.classList.add('liked');\n    likeButton.onclick = function () {\n      return instance.unlike();\n    };\n  } else {\n    likeButton.classList.remove('liked');\n    likeButton.onclick = function () {\n      return instance.like();\n    };\n  }\n  container.appendChild(likeButton);\n\n  var commentsCount = document.createElement('span');\n  commentsCount.innerHTML = '\\n    ' + (meta.comments ? ' \\u2022 <strong>' + meta.comments + '</strong> Comments' : '') + '\\n  ';\n  container.appendChild(commentsCount);\n\n  var issueLink = document.createElement('a');\n  issueLink.className = 'gitment-header-issue-link';\n  issueLink.href = meta.html_url;\n  issueLink.target = '_blank';\n  issueLink.innerText = 'Issue Page';\n  container.appendChild(issueLink);\n\n  return container;\n}\n\nfunction renderComments(_ref2, instance) {\n  var meta = _ref2.meta,\n      comments = _ref2.comments,\n      commentReactions = _ref2.commentReactions,\n      currentPage = _ref2.currentPage,\n      user = _ref2.user,\n      error = _ref2.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-comments-container';\n\n  if (error) {\n    var errorBlock = document.createElement('div');\n    errorBlock.className = 'gitment-comments-error';\n\n    if (error === _constants.NOT_INITIALIZED_ERROR && user.login && user.login.toLowerCase() === instance.owner.toLowerCase()) {\n      var initHint = document.createElement('div');\n      var initButton = document.createElement('button');\n      initButton.className = 'gitment-comments-init-btn';\n      initButton.onclick = function () {\n        initButton.setAttribute('disabled', true);\n        instance.init().catch(function (e) {\n          initButton.removeAttribute('disabled');\n          alert(e);\n        });\n      };\n      initButton.innerText = 'Initialize Comments';\n      initHint.appendChild(initButton);\n      errorBlock.appendChild(initHint);\n    } else {\n      errorBlock.innerText = error;\n    }\n    container.appendChild(errorBlock);\n    return container;\n  } else if (comments === undefined) {\n    var loading = document.createElement('div');\n    loading.innerText = 'Loading comments...';\n    loading.className = 'gitment-comments-loading';\n    container.appendChild(loading);\n    return container;\n  } else if (!comments.length) {\n    var emptyBlock = document.createElement('div');\n    emptyBlock.className = 'gitment-comments-empty';\n    emptyBlock.innerText = 'No Comment Yet';\n    container.appendChild(emptyBlock);\n    return container;\n  }\n\n  var commentsList = document.createElement('ul');\n  commentsList.className = 'gitment-comments-list';\n\n  comments.forEach(function (comment) {\n    var createDate = new Date(comment.created_at);\n    var updateDate = new Date(comment.updated_at);\n    var commentItem = document.createElement('li');\n    commentItem.className = 'gitment-comment';\n    commentItem.innerHTML = '\\n      <a class=\"gitment-comment-avatar\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n        <img class=\"gitment-comment-avatar-img\" src=\"' + comment.user.avatar_url + '\"/>\\n      </a>\\n      <div class=\"gitment-comment-main\">\\n        <div class=\"gitment-comment-header\">\\n          <a class=\"gitment-comment-name\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n            ' + comment.user.login + '\\n          </a>\\n          commented on\\n          <span title=\"' + createDate + '\">' + createDate.toDateString() + '</span>\\n          ' + (createDate.toString() !== updateDate.toString() ? ' \\u2022 <span title=\"comment was edited at ' + updateDate + '\">edited</span>' : '') + '\\n          <div class=\"gitment-comment-like-btn\">' + _icons.heart + ' ' + (comment.reactions.heart || '') + '</div>\\n        </div>\\n        <div class=\"gitment-comment-body gitment-markdown\">' + comment.body_html + '</div>\\n      </div>\\n    ';\n    var likeButton = commentItem.querySelector('.gitment-comment-like-btn');\n    var likedReaction = commentReactions[comment.id] && commentReactions[comment.id].find(function (reaction) {\n      return reaction.content === 'heart' && reaction.user.login === user.login;\n    });\n    if (likedReaction) {\n      likeButton.classList.add('liked');\n      likeButton.onclick = function () {\n        return instance.unlikeAComment(comment.id);\n      };\n    } else {\n      likeButton.classList.remove('liked');\n      likeButton.onclick = function () {\n        return instance.likeAComment(comment.id);\n      };\n    }\n\n    // dirty\n    // use a blank image to trigger height calculating when element rendered\n    var imgTrigger = document.createElement('img');\n    var markdownBody = commentItem.querySelector('.gitment-comment-body');\n    imgTrigger.className = 'gitment-hidden';\n    imgTrigger.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    imgTrigger.onload = function () {\n      if (markdownBody.clientHeight > instance.maxCommentHeight) {\n        markdownBody.classList.add('gitment-comment-body-folded');\n        markdownBody.style.maxHeight = instance.maxCommentHeight + 'px';\n        markdownBody.title = 'Click to Expand';\n        markdownBody.onclick = function () {\n          markdownBody.classList.remove('gitment-comment-body-folded');\n          markdownBody.style.maxHeight = '';\n          markdownBody.title = '';\n          markdownBody.onclick = null;\n        };\n      }\n    };\n    commentItem.appendChild(imgTrigger);\n\n    commentsList.appendChild(commentItem);\n  });\n\n  container.appendChild(commentsList);\n\n  if (meta) {\n    var pageCount = Math.ceil(meta.comments / instance.perPage);\n    if (pageCount > 1) {\n      var pagination = document.createElement('ul');\n      pagination.className = 'gitment-comments-pagination';\n\n      if (currentPage > 1) {\n        var previousButton = document.createElement('li');\n        previousButton.className = 'gitment-comments-page-item';\n        previousButton.innerText = 'Previous';\n        previousButton.onclick = function () {\n          return instance.goto(currentPage - 1);\n        };\n        pagination.appendChild(previousButton);\n      }\n\n      var _loop = function _loop(i) {\n        var pageItem = document.createElement('li');\n        pageItem.className = 'gitment-comments-page-item';\n        pageItem.innerText = i;\n        pageItem.onclick = function () {\n          return instance.goto(i);\n        };\n        if (currentPage === i) pageItem.classList.add('gitment-selected');\n        pagination.appendChild(pageItem);\n      };\n\n      for (var i = 1; i <= pageCount; i++) {\n        _loop(i);\n      }\n\n      if (currentPage < pageCount) {\n        var nextButton = document.createElement('li');\n        nextButton.className = 'gitment-comments-page-item';\n        nextButton.innerText = 'Next';\n        nextButton.onclick = function () {\n          return instance.goto(currentPage + 1);\n        };\n        pagination.appendChild(nextButton);\n      }\n\n      container.appendChild(pagination);\n    }\n  }\n\n  return container;\n}\n\nfunction renderEditor(_ref3, instance) {\n  var user = _ref3.user,\n      error = _ref3.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-editor-container';\n\n  var shouldDisable = user.login && !error ? '' : 'disabled';\n  var disabledTip = user.login ? '' : 'Login to Comment';\n  container.innerHTML = '\\n      ' + (user.login ? '<a class=\"gitment-editor-avatar\" href=\"' + user.html_url + '\" target=\"_blank\">\\n            <img class=\"gitment-editor-avatar-img\" src=\"' + user.avatar_url + '\"/>\\n          </a>' : user.isLoggingIn ? '<div class=\"gitment-editor-avatar\">' + _icons.spinner + '</div>' : '<a class=\"gitment-editor-avatar\" href=\"' + instance.loginLink + '\" title=\"login with GitHub\">\\n              ' + _icons.github + '\\n            </a>') + '\\n    </a>\\n    <div class=\"gitment-editor-main\">\\n      <div class=\"gitment-editor-header\">\\n        <nav class=\"gitment-editor-tabs\">\\n          <button class=\"gitment-editor-tab gitment-selected\">Write</button>\\n          <button class=\"gitment-editor-tab\">Preview</button>\\n        </nav>\\n        <div class=\"gitment-editor-login\">\\n          ' + (user.login ? '<a class=\"gitment-editor-logout-link\">Logout</a>' : user.isLoggingIn ? 'Logging in...' : '<a class=\"gitment-editor-login-link\" href=\"' + instance.loginLink + '\">Login</a> with GitHub') + '\\n        </div>\\n      </div>\\n      <div class=\"gitment-editor-body\">\\n        <div class=\"gitment-editor-write-field\">\\n          <textarea placeholder=\"Leave a comment\" title=\"' + disabledTip + '\" ' + shouldDisable + '></textarea>\\n        </div>\\n        <div class=\"gitment-editor-preview-field gitment-hidden\">\\n          <div class=\"gitment-editor-preview gitment-markdown\"></div>\\n        </div>\\n      </div>\\n    </div>\\n    <div class=\"gitment-editor-footer\">\\n      <a class=\"gitment-editor-footer-tip\" href=\"https://guides.github.com/features/mastering-markdown/\" target=\"_blank\">\\n        Styling with Markdown is supported\\n      </a>\\n      <button class=\"gitment-editor-submit\" title=\"' + disabledTip + '\" ' + shouldDisable + '>Comment</button>\\n    </div>\\n  ';\n  if (user.login) {\n    container.querySelector('.gitment-editor-logout-link').onclick = function () {\n      return instance.logout();\n    };\n  }\n\n  var writeField = container.querySelector('.gitment-editor-write-field');\n  var previewField = container.querySelector('.gitment-editor-preview-field');\n\n  var textarea = writeField.querySelector('textarea');\n  textarea.oninput = function () {\n    textarea.style.height = 'auto';\n    var style = window.getComputedStyle(textarea, null);\n    var height = parseInt(style.height, 10);\n    var clientHeight = textarea.clientHeight;\n    var scrollHeight = textarea.scrollHeight;\n    if (clientHeight < scrollHeight) {\n      textarea.style.height = height + scrollHeight - clientHeight + 'px';\n    }\n  };\n\n  var _container$querySelec = container.querySelectorAll('.gitment-editor-tab'),\n      _container$querySelec2 = _slicedToArray(_container$querySelec, 2),\n      writeTab = _container$querySelec2[0],\n      previewTab = _container$querySelec2[1];\n\n  writeTab.onclick = function () {\n    writeTab.classList.add('gitment-selected');\n    previewTab.classList.remove('gitment-selected');\n    writeField.classList.remove('gitment-hidden');\n    previewField.classList.add('gitment-hidden');\n\n    textarea.focus();\n  };\n  previewTab.onclick = function () {\n    previewTab.classList.add('gitment-selected');\n    writeTab.classList.remove('gitment-selected');\n    previewField.classList.remove('gitment-hidden');\n    writeField.classList.add('gitment-hidden');\n\n    var preview = previewField.querySelector('.gitment-editor-preview');\n    var content = textarea.value.trim();\n    if (!content) {\n      preview.innerText = 'Nothing to preview';\n      return;\n    }\n\n    preview.innerText = 'Loading preview...';\n    instance.markdown(content).then(function (html) {\n      return preview.innerHTML = html;\n    });\n  };\n\n  var submitButton = container.querySelector('.gitment-editor-submit');\n  submitButton.onclick = function () {\n    submitButton.innerText = 'Submitting...';\n    submitButton.setAttribute('disabled', true);\n    instance.post(textarea.value.trim()).then(function (data) {\n      textarea.value = '';\n      textarea.style.height = 'auto';\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    }).catch(function (e) {\n      alert(e);\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    });\n  };\n\n  return container;\n}\n\nfunction renderFooter() {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-footer-container';\n  container.innerHTML = '\\n    Powered by\\n    <a class=\"gitment-footer-project-link\" href=\"https://github.com/imsun/gitment\" target=\"_blank\">\\n      Gitment\\n    </a>\\n  ';\n  return container;\n}\n\nfunction render(state, instance) {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-root-container';\n  container.appendChild(instance.renderHeader(state, instance));\n  container.appendChild(instance.renderComments(state, instance));\n  container.appendChild(instance.renderEditor(state, instance));\n  container.appendChild(instance.renderFooter(state, instance));\n  return container;\n}\n\nexports.default = { render: render, renderHeader: renderHeader, renderComments: renderComments, renderEditor: renderEditor, renderFooter: renderFooter };\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.http = exports.Query = exports.isString = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.getTargetContainer = getTargetContainer;\n\nvar _constants = __webpack_require__(0);\n\nvar isString = exports.isString = function isString(s) {\n  return toString.call(s) === '[object String]';\n};\n\nfunction getTargetContainer(container) {\n  var targetContainer = void 0;\n  if (container instanceof Element) {\n    targetContainer = container;\n  } else if (isString(container)) {\n    targetContainer = document.getElementById(container);\n  } else {\n    targetContainer = document.createElement('div');\n  }\n\n  return targetContainer;\n}\n\nvar Query = exports.Query = {\n  parse: function parse() {\n    var search = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.search;\n\n    if (!search) return {};\n    var queryString = search[0] === '?' ? search.substring(1) : search;\n    var query = {};\n    queryString.split('&').forEach(function (queryStr) {\n      var _queryStr$split = queryStr.split('='),\n          _queryStr$split2 = _slicedToArray(_queryStr$split, 2),\n          key = _queryStr$split2[0],\n          value = _queryStr$split2[1];\n\n      if (key) query[key] = value;\n    });\n\n    return query;\n  },\n  stringify: function stringify(query) {\n    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '?';\n\n    var queryString = Object.keys(query).map(function (key) {\n      return key + '=' + encodeURIComponent(query[key] || '');\n    }).join('&');\n    return queryString ? prefix + queryString : '';\n  }\n};\n\nfunction ajaxFactory(method) {\n  return function (apiPath) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://api.github.com';\n\n    var req = new XMLHttpRequest();\n    var token = localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n\n    var url = '' + base + apiPath;\n    var body = null;\n    if (method === 'GET' || method === 'DELETE') {\n      url += Query.stringify(data);\n    }\n\n    var p = new Promise(function (resolve, reject) {\n      req.addEventListener('load', function () {\n        var contentType = req.getResponseHeader('content-type');\n        var res = req.responseText;\n        if (!/json/.test(contentType)) {\n          resolve(res);\n          return;\n        }\n        var data = req.responseText ? JSON.parse(res) : {};\n        if (data.message) {\n          reject(new Error(data.message));\n        } else {\n          resolve(data);\n        }\n      });\n      req.addEventListener('error', function (error) {\n        return reject(error);\n      });\n    });\n    req.open(method, url, true);\n\n    req.setRequestHeader('Accept', 'application/vnd.github.squirrel-girl-preview, application/vnd.github.html+json');\n    if (token) {\n      req.setRequestHeader('Authorization', 'token ' + token);\n    }\n    if (method !== 'GET' && method !== 'DELETE') {\n      body = JSON.stringify(data);\n      req.setRequestHeader('Content-Type', 'application/json');\n    }\n\n    req.send(body);\n    return p;\n  };\n}\n\nvar http = exports.http = {\n  get: ajaxFactory('GET'),\n  post: ajaxFactory('POST'),\n  delete: ajaxFactory('DELETE'),\n  put: ajaxFactory('PUT')\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mobx = __webpack_require__(1);\n\nvar _constants = __webpack_require__(0);\n\nvar _utils = __webpack_require__(3);\n\nvar _default = __webpack_require__(2);\n\nvar _default2 = _interopRequireDefault(_default);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar scope = 'public_repo';\n\nfunction extendRenderer(instance, renderer) {\n  instance[renderer] = function (container) {\n    var targetContainer = (0, _utils.getTargetContainer)(container);\n    var render = instance.theme[renderer] || instance.defaultTheme[renderer];\n\n    (0, _mobx.autorun)(function () {\n      var e = render(instance.state, instance);\n      if (targetContainer.firstChild) {\n        targetContainer.replaceChild(e, targetContainer.firstChild);\n      } else {\n        targetContainer.appendChild(e);\n      }\n    });\n\n    return targetContainer;\n  };\n}\n\nvar Gitment = function () {\n  _createClass(Gitment, [{\n    key: 'accessToken',\n    get: function get() {\n      return localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n    },\n    set: function set(token) {\n      localStorage.setItem(_constants.LS_ACCESS_TOKEN_KEY, token);\n    }\n  }, {\n    key: 'loginLink',\n    get: function get() {\n      var oauthUri = 'https://github.com/login/oauth/authorize';\n      var redirect_uri = this.oauth.redirect_uri || window.location.href;\n\n      var oauthParams = Object.assign({\n        scope: scope,\n        redirect_uri: redirect_uri\n      }, this.oauth);\n\n      return '' + oauthUri + _utils.Query.stringify(oauthParams);\n    }\n  }]);\n\n  function Gitment() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Gitment);\n\n    this.defaultTheme = _default2.default;\n    this.useTheme(_default2.default);\n\n    Object.assign(this, {\n      id: window.location.href,\n      title: window.document.title,\n      link: window.location.href,\n      desc: '',\n      labels: [],\n      theme: _default2.default,\n      oauth: {},\n      perPage: 20,\n      maxCommentHeight: 250\n    }, options);\n\n    this.useTheme(this.theme);\n\n    var user = {};\n    try {\n      var userInfo = localStorage.getItem(_constants.LS_USER_KEY);\n      if (this.accessToken && userInfo) {\n        Object.assign(user, JSON.parse(userInfo), {\n          fromCache: true\n        });\n      }\n    } catch (e) {\n      localStorage.removeItem(_constants.LS_USER_KEY);\n    }\n\n    this.state = (0, _mobx.observable)({\n      user: user,\n      error: null,\n      meta: {},\n      comments: undefined,\n      reactions: [],\n      commentReactions: {},\n      currentPage: 1\n    });\n\n    var query = _utils.Query.parse();\n    if (query.code) {\n      var _oauth = this.oauth,\n          client_id = _oauth.client_id,\n          client_secret = _oauth.client_secret;\n\n      var code = query.code;\n      delete query.code;\n      var search = _utils.Query.stringify(query);\n      var replacedUrl = '' + window.location.origin + window.location.pathname + search + window.location.hash;\n      history.replaceState({}, '', replacedUrl);\n\n      Object.assign(this, {\n        id: replacedUrl,\n        link: replacedUrl\n      }, options);\n\n      this.state.user.isLoggingIn = true;\n      _utils.http.post('https://github.com/login/oauth/access_token', {\n        code: code,\n        client_id: client_id,\n        client_secret: client_secret\n      }, '').then(function (data) {\n        _this.accessToken = data.access_token;\n        _this.update();\n      }).catch(function (e) {\n        _this.state.user.isLoggingIn = false;\n        alert(e);\n      });\n    } else {\n      this.update();\n    }\n  }\n\n  _createClass(Gitment, [{\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      return this.createIssue().then(function () {\n        return _this2.loadComments();\n      }).then(function (comments) {\n        _this2.state.error = null;\n        return comments;\n      });\n    }\n  }, {\n    key: 'useTheme',\n    value: function useTheme() {\n      var _this3 = this;\n\n      var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this.theme = theme;\n\n      var renderers = Object.keys(this.theme);\n      renderers.forEach(function (renderer) {\n        return extendRenderer(_this3, renderer);\n      });\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var _this4 = this;\n\n      return Promise.all([this.loadMeta(), this.loadUserInfo()]).then(function () {\n        return Promise.all([_this4.loadComments().then(function () {\n          return _this4.loadCommentReactions();\n        }), _this4.loadReactions()]);\n      }).catch(function (e) {\n        return _this4.state.error = e;\n      });\n    }\n  }, {\n    key: 'markdown',\n    value: function markdown(text) {\n      return _utils.http.post('/markdown', {\n        text: text,\n        mode: 'gfm'\n      });\n    }\n  }, {\n    key: 'createIssue',\n    value: function createIssue() {\n      var _this5 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo,\n          title = this.title,\n          link = this.link,\n          desc = this.desc,\n          labels = this.labels;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues', {\n        title: title,\n        labels: labels.concat(['gitment', id]),\n        body: link + '\\n\\n' + desc\n      }).then(function (meta) {\n        _this5.state.meta = meta;\n        return meta;\n      });\n    }\n  }, {\n    key: 'getIssue',\n    value: function getIssue() {\n      if (this.state.meta.id) return Promise.resolve(this.state.meta);\n\n      return this.loadMeta();\n    }\n  }, {\n    key: 'post',\n    value: function post(body) {\n      var _this6 = this;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.post(issue.comments_url, { body: body }, '');\n      }).then(function (data) {\n        _this6.state.meta.comments++;\n        var pageCount = Math.ceil(_this6.state.meta.comments / _this6.perPage);\n        if (_this6.state.currentPage === pageCount) {\n          _this6.state.comments.push(data);\n        }\n        return data;\n      });\n    }\n  }, {\n    key: 'loadMeta',\n    value: function loadMeta() {\n      var _this7 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo;\n\n      return _utils.http.get('/repos/' + owner + '/' + repo + '/issues', {\n        creator: owner,\n        labels: id\n      }).then(function (issues) {\n        if (!issues.length) return Promise.reject(_constants.NOT_INITIALIZED_ERROR);\n        _this7.state.meta = issues[0];\n        return issues[0];\n      });\n    }\n  }, {\n    key: 'loadComments',\n    value: function loadComments() {\n      var _this8 = this;\n\n      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentPage;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.get(issue.comments_url, { page: page, per_page: _this8.perPage }, '');\n      }).then(function (comments) {\n        _this8.state.comments = comments;\n        return comments;\n      });\n    }\n  }, {\n    key: 'loadUserInfo',\n    value: function loadUserInfo() {\n      var _this9 = this;\n\n      if (!this.accessToken) {\n        this.logout();\n        return Promise.resolve({});\n      }\n\n      return _utils.http.get('/user').then(function (user) {\n        _this9.state.user = user;\n        localStorage.setItem(_constants.LS_USER_KEY, JSON.stringify(user));\n        return user;\n      });\n    }\n  }, {\n    key: 'loadReactions',\n    value: function loadReactions() {\n      var _this10 = this;\n\n      if (!this.accessToken) {\n        this.state.reactions = [];\n        return Promise.resolve([]);\n      }\n\n      return this.getIssue().then(function (issue) {\n        if (!issue.reactions.total_count) return [];\n        return _utils.http.get(issue.reactions.url, {}, '');\n      }).then(function (reactions) {\n        _this10.state.reactions = reactions;\n        return reactions;\n      });\n    }\n  }, {\n    key: 'loadCommentReactions',\n    value: function loadCommentReactions() {\n      var _this11 = this;\n\n      if (!this.accessToken) {\n        this.state.commentReactions = {};\n        return Promise.resolve([]);\n      }\n\n      var comments = this.state.comments;\n      var comentReactions = {};\n\n      return Promise.all(comments.map(function (comment) {\n        if (!comment.reactions.total_count) return [];\n\n        var owner = _this11.owner,\n            repo = _this11.repo;\n\n        return _utils.http.get('/repos/' + owner + '/' + repo + '/issues/comments/' + comment.id + '/reactions', {});\n      })).then(function (reactionsArray) {\n        comments.forEach(function (comment, index) {\n          comentReactions[comment.id] = reactionsArray[index];\n        });\n        _this11.state.commentReactions = comentReactions;\n\n        return comentReactions;\n      });\n    }\n  }, {\n    key: 'login',\n    value: function login() {\n      window.location.href = this.loginLink;\n    }\n  }, {\n    key: 'logout',\n    value: function logout() {\n      localStorage.removeItem(_constants.LS_ACCESS_TOKEN_KEY);\n      localStorage.removeItem(_constants.LS_USER_KEY);\n      this.state.user = {};\n    }\n  }, {\n    key: 'goto',\n    value: function goto(page) {\n      this.state.currentPage = page;\n      this.state.comments = undefined;\n      return this.loadComments(page);\n    }\n  }, {\n    key: 'like',\n    value: function like() {\n      var _this12 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/' + this.state.meta.number + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this12.state.reactions.push(reaction);\n        _this12.state.meta.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlike',\n    value: function unlike() {\n      var _this13 = this;\n\n      if (!this.accessToken) return Promise.reject();\n\n      var _state = this.state,\n          user = _state.user,\n          reactions = _state.reactions;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        _this13.state.meta.reactions.heart--;\n      });\n    }\n  }, {\n    key: 'likeAComment',\n    value: function likeAComment(commentId) {\n      var _this14 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/comments/' + commentId + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this14.state.commentReactions[commentId].push(reaction);\n        comment.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlikeAComment',\n    value: function unlikeAComment(commentId) {\n      if (!this.accessToken) return Promise.reject();\n\n      var reactions = this.state.commentReactions[commentId];\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n      var user = this.state.user;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        comment.reactions.heart--;\n      });\n    }\n  }]);\n\n  return Gitment;\n}();\n\nmodule.exports = Gitment;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Modified from https://github.com/evil-icons/evil-icons\n */\n\nvar close = exports.close = '<svg class=\"gitment-close-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M37.304 11.282l1.414 1.414-26.022 26.02-1.414-1.413z\"/><path d=\"M12.696 11.282l26.022 26.02-1.414 1.415-26.022-26.02z\"/></svg>';\nvar github = exports.github = '<svg class=\"gitment-github-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 10c-8.3 0-15 6.7-15 15 0 6.6 4.3 12.2 10.3 14.2.8.1 1-.3 1-.7v-2.6c-4.2.9-5.1-2-5.1-2-.7-1.7-1.7-2.2-1.7-2.2-1.4-.9.1-.9.1-.9 1.5.1 2.3 1.5 2.3 1.5 1.3 2.3 3.5 1.6 4.4 1.2.1-1 .5-1.6 1-2-3.3-.4-6.8-1.7-6.8-7.4 0-1.6.6-3 1.5-4-.2-.4-.7-1.9.1-4 0 0 1.3-.4 4.1 1.5 1.2-.3 2.5-.5 3.8-.5 1.3 0 2.6.2 3.8.5 2.9-1.9 4.1-1.5 4.1-1.5.8 2.1.3 3.6.1 4 1 1 1.5 2.4 1.5 4 0 5.8-3.5 7-6.8 7.4.5.5 1 1.4 1 2.8v4.1c0 .4.3.9 1 .7 6-2 10.2-7.6 10.2-14.2C40 16.7 33.3 10 25 10z\"/></svg>';\nvar heart = exports.heart = '<svg class=\"gitment-heart-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 39.7l-.6-.5C11.5 28.7 8 25 8 19c0-5 4-9 9-9 4.1 0 6.4 2.3 8 4.1 1.6-1.8 3.9-4.1 8-4.1 5 0 9 4 9 9 0 6-3.5 9.7-16.4 20.2l-.6.5zM17 12c-3.9 0-7 3.1-7 7 0 5.1 3.2 8.5 15 18.1 11.8-9.6 15-13 15-18.1 0-3.9-3.1-7-7-7-3.5 0-5.4 2.1-6.9 3.8L25 17.1l-1.1-1.3C22.4 14.1 20.5 12 17 12z\"/></svg>';\nvar spinner = exports.spinner = '<svg class=\"gitment-spinner-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 18c-.6 0-1-.4-1-1V9c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M25 42c-.6 0-1-.4-1-1v-8c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M29 19c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M17 39.8c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".93\" d=\"M21 19c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M33 39.8c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.1-.3.2-.5.2z\"/><path opacity=\".65\" d=\"M17 26H9c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".3\" d=\"M41 26h-8c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".86\" d=\"M18.1 21.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M38.9 33.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".44\" d=\"M11.1 33.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.1.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M31.9 21.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.2.2-.3.2-.5.2z\"/></svg>';\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=gitment.browser.js.map","date":"2024-02-25T15:11:07.055Z","updated":"2024-02-25T15:11:07.055Z","path":"js/gitment.js","layout":"false","title":"","comments":1,"_id":"cmfwcr5rw000pm8nx1gth1iwg","content":"var Gitment =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar LS_ACCESS_TOKEN_KEY = exports.LS_ACCESS_TOKEN_KEY = 'gitment-comments-token';\nvar LS_USER_KEY = exports.LS_USER_KEY = 'gitment-user-info';\n\nvar NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = new Error('Comments Not Initialized');\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) {\n            if (b.hasOwnProperty(p)) d[p] = b[p];\n        }\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nregisterGlobals();\nexports.extras = {\n    allowStateChanges: allowStateChanges,\n    deepEqual: deepEqual,\n    getAtom: getAtom,\n    getDebugName: getDebugName,\n    getDependencyTree: getDependencyTree,\n    getAdministration: getAdministration,\n    getGlobalState: getGlobalState,\n    getObserverTree: getObserverTree,\n    isComputingDerivation: isComputingDerivation,\n    isSpyEnabled: isSpyEnabled,\n    onReactionError: onReactionError,\n    resetGlobalState: resetGlobalState,\n    shareGlobalState: shareGlobalState,\n    spyReport: spyReport,\n    spyReportEnd: spyReportEnd,\n    spyReportStart: spyReportStart,\n    setReactionScheduler: setReactionScheduler\n};\nif ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" ? \"undefined\" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === \"object\") {\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx(module.exports);\n}\nmodule.exports.default = module.exports;\nvar actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {\n    var actionName = args && args.length === 1 ? args[0] : value.name || key || \"<unnamed action>\";\n    var wrappedAction = action(actionName, value);\n    addHiddenProp(target, key, wrappedAction);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, true);\nvar boundActionDecorator = createClassPropertyDecorator(function (target, key, value) {\n    defineBoundAction(target, key, value);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, false);\nvar action = function action(arg1, arg2, arg3, arg4) {\n    if (arguments.length === 1 && typeof arg1 === \"function\") return createAction(arg1.name || \"<unnamed action>\", arg1);\n    if (arguments.length === 2 && typeof arg2 === \"function\") return createAction(arg1, arg2);\n    if (arguments.length === 1 && typeof arg1 === \"string\") return namedActionDecorator(arg1);\n    return namedActionDecorator(arg2).apply(null, arguments);\n};\nexports.action = action;\naction.bound = function boundAction(arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n        var action_1 = createAction(\"<not yet bound action>\", arg1);\n        action_1.autoBind = true;\n        return action_1;\n    }\n    return boundActionDecorator.apply(null, arguments);\n};\nfunction namedActionDecorator(name) {\n    return function (target, prop, descriptor) {\n        if (descriptor && typeof descriptor.value === \"function\") {\n            descriptor.value = createAction(name, descriptor.value);\n            descriptor.enumerable = false;\n            descriptor.configurable = true;\n            return descriptor;\n        }\n        return actionFieldDecorator(name).apply(this, arguments);\n    };\n}\nfunction runInAction(arg1, arg2, arg3) {\n    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action>\";\n    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\n    var scope = typeof arg1 === \"function\" ? arg2 : arg3;\n    invariant(typeof fn === \"function\", getMessage(\"m002\"));\n    invariant(fn.length === 0, getMessage(\"m003\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    return executeAction(actionName, fn, scope, undefined);\n}\nexports.runInAction = runInAction;\nfunction isAction(thing) {\n    return typeof thing === \"function\" && thing.isMobxAction === true;\n}\nexports.isAction = isAction;\nfunction defineBoundAction(target, propertyName, fn) {\n    var res = function res() {\n        return executeAction(propertyName, fn, target, arguments);\n    };\n    res.isMobxAction = true;\n    addHiddenProp(target, propertyName, res);\n}\nfunction autorun(arg1, arg2, arg3) {\n    var name, view, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        view = arg2;\n        scope = arg3;\n    } else {\n        name = arg1.name || \"Autorun@\" + getNextId();\n        view = arg1;\n        scope = arg2;\n    }\n    invariant(typeof view === \"function\", getMessage(\"m004\"));\n    invariant(isAction(view) === false, getMessage(\"m005\"));\n    if (scope) view = view.bind(scope);\n    var reaction = new Reaction(name, function () {\n        this.track(reactionRunner);\n    });\n    function reactionRunner() {\n        view(reaction);\n    }\n    reaction.schedule();\n    return reaction.getDisposer();\n}\nexports.autorun = autorun;\nfunction when(arg1, arg2, arg3, arg4) {\n    var name, predicate, effect, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        predicate = arg2;\n        effect = arg3;\n        scope = arg4;\n    } else {\n        name = \"When@\" + getNextId();\n        predicate = arg1;\n        effect = arg2;\n        scope = arg3;\n    }\n    var disposer = autorun(name, function (r) {\n        if (predicate.call(scope)) {\n            r.dispose();\n            var prevUntracked = untrackedStart();\n            effect.call(scope);\n            untrackedEnd(prevUntracked);\n        }\n    });\n    return disposer;\n}\nexports.when = when;\nfunction autorunAsync(arg1, arg2, arg3, arg4) {\n    var name, func, delay, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        func = arg2;\n        delay = arg3;\n        scope = arg4;\n    } else {\n        name = arg1.name || \"AutorunAsync@\" + getNextId();\n        func = arg1;\n        delay = arg2;\n        scope = arg3;\n    }\n    invariant(isAction(func) === false, getMessage(\"m006\"));\n    if (delay === void 0) delay = 1;\n    if (scope) func = func.bind(scope);\n    var isScheduled = false;\n    var r = new Reaction(name, function () {\n        if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                if (!r.isDisposed) r.track(reactionRunner);\n            }, delay);\n        }\n    });\n    function reactionRunner() {\n        func(r);\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.autorunAsync = autorunAsync;\nfunction reaction(expression, effect, arg3) {\n    if (arguments.length > 3) {\n        fail(getMessage(\"m007\"));\n    }\n    if (isModifierDescriptor(expression)) {\n        fail(getMessage(\"m008\"));\n    }\n    var opts;\n    if ((typeof arg3 === \"undefined\" ? \"undefined\" : _typeof(arg3)) === \"object\") {\n        opts = arg3;\n    } else {\n        opts = {};\n    }\n    opts.name = opts.name || expression.name || effect.name || \"Reaction@\" + getNextId();\n    opts.fireImmediately = arg3 === true || opts.fireImmediately === true;\n    opts.delay = opts.delay || 0;\n    opts.compareStructural = opts.compareStructural || opts.struct || false;\n    effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect);\n    if (opts.context) {\n        expression = expression.bind(opts.context);\n    }\n    var firstTime = true;\n    var isScheduled = false;\n    var nextValue;\n    var r = new Reaction(opts.name, function () {\n        if (firstTime || opts.delay < 1) {\n            reactionRunner();\n        } else if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                reactionRunner();\n            }, opts.delay);\n        }\n    });\n    function reactionRunner() {\n        if (r.isDisposed) return;\n        var changed = false;\n        r.track(function () {\n            var v = expression(r);\n            changed = valueDidChange(opts.compareStructural, nextValue, v);\n            nextValue = v;\n        });\n        if (firstTime && opts.fireImmediately) effect(nextValue, r);\n        if (!firstTime && changed === true) effect(nextValue, r);\n        if (firstTime) firstTime = false;\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.reaction = reaction;\nfunction createComputedDecorator(compareStructural) {\n    return createClassPropertyDecorator(function (target, name, _, __, originalDescriptor) {\n        invariant(typeof originalDescriptor !== \"undefined\", getMessage(\"m009\"));\n        invariant(typeof originalDescriptor.get === \"function\", getMessage(\"m010\"));\n        var adm = asObservableObject(target, \"\");\n        defineComputedProperty(adm, name, originalDescriptor.get, originalDescriptor.set, compareStructural, false);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        this.$mobx.values[name].set(value);\n    }, false, false);\n}\nvar computedDecorator = createComputedDecorator(false);\nvar computedStructDecorator = createComputedDecorator(true);\nvar computed = function computed(arg1, arg2, arg3) {\n    if (typeof arg2 === \"string\") {\n        return computedDecorator.apply(null, arguments);\n    }\n    invariant(typeof arg1 === \"function\", getMessage(\"m011\"));\n    invariant(arguments.length < 3, getMessage(\"m012\"));\n    var opts = (typeof arg2 === \"undefined\" ? \"undefined\" : _typeof(arg2)) === \"object\" ? arg2 : {};\n    opts.setter = typeof arg2 === \"function\" ? arg2 : opts.setter;\n    return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || \"\", opts.setter);\n};\nexports.computed = computed;\ncomputed.struct = computedStructDecorator;\nfunction createTransformer(transformer, onCleanup) {\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\n    var objectCache = {};\n    var resetId = globalState.resetId;\n    var Transformer = function (_super) {\n        __extends(Transformer, _super);\n        function Transformer(sourceIdentifier, sourceObject) {\n            var _this = _super.call(this, function () {\n                return transformer(sourceObject);\n            }, undefined, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier, undefined) || this;\n            _this.sourceIdentifier = sourceIdentifier;\n            _this.sourceObject = sourceObject;\n            return _this;\n        }\n        Transformer.prototype.onBecomeUnobserved = function () {\n            var lastValue = this.value;\n            _super.prototype.onBecomeUnobserved.call(this);\n            delete objectCache[this.sourceIdentifier];\n            if (onCleanup) onCleanup(lastValue, this.sourceObject);\n        };\n        return Transformer;\n    }(ComputedValue);\n    return function (object) {\n        if (resetId !== globalState.resetId) {\n            objectCache = {};\n            resetId = globalState.resetId;\n        }\n        var identifier = getMemoizationId(object);\n        var reactiveTransformer = objectCache[identifier];\n        if (reactiveTransformer) return reactiveTransformer.get();\n        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);\n        return reactiveTransformer.get();\n    };\n}\nexports.createTransformer = createTransformer;\nfunction getMemoizationId(object) {\n    if (object === null || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") throw new Error(\"[mobx] transform expected some kind of object, got: \" + object);\n    var tid = object.$transformId;\n    if (tid === undefined) {\n        tid = getNextId();\n        addHiddenProp(object, \"$transformId\", tid);\n    }\n    return tid;\n}\nfunction expr(expr, scope) {\n    if (!isComputingDerivation()) console.warn(getMessage(\"m013\"));\n    return computed(expr, { context: scope }).get();\n}\nexports.expr = expr;\nfunction extendObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, deepEnhancer, properties);\n}\nexports.extendObservable = extendObservable;\nfunction extendShallowObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, referenceEnhancer, properties);\n}\nexports.extendShallowObservable = extendShallowObservable;\nfunction extendObservableHelper(target, defaultEnhancer, properties) {\n    invariant(arguments.length >= 2, getMessage(\"m014\"));\n    invariant((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\", getMessage(\"m015\"));\n    invariant(!isObservableMap(target), getMessage(\"m016\"));\n    properties.forEach(function (propSet) {\n        invariant((typeof propSet === \"undefined\" ? \"undefined\" : _typeof(propSet)) === \"object\", getMessage(\"m017\"));\n        invariant(!isObservable(propSet), getMessage(\"m018\"));\n    });\n    var adm = asObservableObject(target);\n    var definedProps = {};\n    for (var i = properties.length - 1; i >= 0; i--) {\n        var propSet = properties[i];\n        for (var key in propSet) {\n            if (definedProps[key] !== true && hasOwnProperty(propSet, key)) {\n                definedProps[key] = true;\n                if (target === propSet && !isPropertyConfigurable(target, key)) continue;\n                var descriptor = Object.getOwnPropertyDescriptor(propSet, key);\n                defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer);\n            }\n        }\n    }\n    return target;\n}\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree);\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (hasObservers(node)) result.observers = getObservers(node).map(nodeToObserverTree);\n    return result;\n}\nfunction intercept(thing, propOrHandler, handler) {\n    if (typeof handler === \"function\") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);\n}\nexports.intercept = intercept;\nfunction interceptInterceptable(thing, handler) {\n    return getAdministration(thing).intercept(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    return getAdministration(thing, property).intercept(handler);\n}\nfunction isComputed(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableObject(value) === false) return false;\n        var atom = getAtom(value, property);\n        return isComputedValue(atom);\n    }\n    return isComputedValue(value);\n}\nexports.isComputed = isComputed;\nfunction isObservable(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableArray(value) || isObservableMap(value)) throw new Error(getMessage(\"m019\"));else if (isObservableObject(value)) {\n            var o = value.$mobx;\n            return o.values && !!o.values[property];\n        }\n        return false;\n    }\n    return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value);\n}\nexports.isObservable = isObservable;\nvar deepDecorator = createDecoratorForEnhancer(deepEnhancer);\nvar shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);\nvar refDecorator = createDecoratorForEnhancer(referenceEnhancer);\nvar deepStructDecorator = createDecoratorForEnhancer(deepStructEnhancer);\nvar refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);\nfunction createObservable(v) {\n    if (v === void 0) {\n        v = undefined;\n    }\n    if (typeof arguments[1] === \"string\") return deepDecorator.apply(null, arguments);\n    invariant(arguments.length <= 1, getmessage(\"m021\")); invariant(!ismodifierdescriptor(v), getmessage(\"m020\")); if (isobservable(v)) return v; var res=\"deepEnhancer(v,\" undefined, undefined); (res !=\"=\" v) res; observable.box(v); } iobservablefactories=\"function\" () { function iobservablefactories() {} iobservablefactories.prototype.box=\"function\" (value, name) (arguments.length> 2) incorrectlyUsedAsDecorator(\"box\");\n        return new ObservableValue(value, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowBox = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowBox\");\n        return new ObservableValue(value, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.array = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"array\");\n        return new ObservableArray(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowArray = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowArray\");\n        return new ObservableArray(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.map = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"map\");\n        return new ObservableMap(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowMap = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowMap\");\n        return new ObservableMap(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.object = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"object\");\n        var res = {};\n        asObservableObject(res, name);\n        extendObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.shallowObject = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowObject\");\n        var res = {};\n        asObservableObject(res, name);\n        extendShallowObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.ref = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(referenceEnhancer, arguments[0]);\n        } else {\n            return refDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.shallow = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(shallowEnhancer, arguments[0]);\n        } else {\n            return shallowDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.deep = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepEnhancer, arguments[0]);\n        } else {\n            return deepDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.struct = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepStructEnhancer, arguments[0]);\n        } else {\n            return deepStructDecorator.apply(null, arguments);\n        }\n    };\n    return IObservableFactories;\n}();\nexports.IObservableFactories = IObservableFactories;\nvar observable = createObservable;\nexports.observable = observable;\nObject.keys(IObservableFactories.prototype).forEach(function (key) {\n    return observable[key] = IObservableFactories.prototype[key];\n});\nobservable.deep.struct = observable.struct;\nobservable.ref.struct = function () {\n    if (arguments.length < 2) {\n        return createModifierDescriptor(refStructEnhancer, arguments[0]);\n    } else {\n        return refStructDecorator.apply(null, arguments);\n    }\n};\nfunction incorrectlyUsedAsDecorator(methodName) {\n    fail(\"Expected one or two arguments to observable.\" + methodName + \". Did you accidentally try to use observable.\" + methodName + \" as decorator?\");\n}\nfunction createDecoratorForEnhancer(enhancer) {\n    invariant(!!enhancer, \":(\");\n    return createClassPropertyDecorator(function (target, name, baseValue, _, baseDescriptor) {\n        assertPropertyConfigurable(target, name);\n        invariant(!baseDescriptor || !baseDescriptor.get, getMessage(\"m022\"));\n        var adm = asObservableObject(target, undefined);\n        defineObservableProperty(adm, name, baseValue, enhancer);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        setPropertyValue(this, name, value);\n    }, true, false);\n}\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (typeof cbOrFire === \"function\") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);\n}\nexports.observe = observe;\nfunction observeObservable(thing, listener, fireImmediately) {\n    return getAdministration(thing).observe(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    return getAdministration(thing, property).observe(listener, fireImmediately);\n}\nfunction toJS(source, detectCycles, __alreadySeen) {\n    if (detectCycles === void 0) {\n        detectCycles = true;\n    }\n    if (__alreadySeen === void 0) {\n        __alreadySeen = [];\n    }\n    function cache(value) {\n        if (detectCycles) __alreadySeen.push([source, value]);\n        return value;\n    }\n    if (isObservable(source)) {\n        if (detectCycles && __alreadySeen === null) __alreadySeen = [];\n        if (detectCycles && source !== null && (typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") {\n            for (var i = 0, l = __alreadySeen.length; i < l; i++) {\n                if (__alreadySeen[i][0] === source) return __alreadySeen[i][1];\n            }\n        }\n        if (isObservableArray(source)) {\n            var res = cache([]);\n            var toAdd = source.map(function (value) {\n                return toJS(value, detectCycles, __alreadySeen);\n            });\n            res.length = toAdd.length;\n            for (var i = 0, l = toAdd.length; i < l; i++) {\n                res[i] = toAdd[i];\n            }return res;\n        }\n        if (isObservableObject(source)) {\n            var res = cache({});\n            for (var key in source) {\n                res[key] = toJS(source[key], detectCycles, __alreadySeen);\n            }return res;\n        }\n        if (isObservableMap(source)) {\n            var res_1 = cache({});\n            source.forEach(function (value, key) {\n                return res_1[key] = toJS(value, detectCycles, __alreadySeen);\n            });\n            return res_1;\n        }\n        if (isObservableValue(source)) return toJS(source.get(), detectCycles, __alreadySeen);\n    }\n    return source;\n}\nexports.toJS = toJS;\nfunction transaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    deprecated(getMessage(\"m023\"));\n    return runInTransaction.apply(undefined, arguments);\n}\nexports.transaction = transaction;\nfunction runInTransaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    return executeAction(\"\", action);\n}\nfunction log(msg) {\n    console.log(msg);\n    return msg;\n}\nfunction whyRun(thing, prop) {\n    switch (arguments.length) {\n        case 0:\n            thing = globalState.trackingDerivation;\n            if (!thing) return log(getMessage(\"m024\"));\n            break;\n        case 2:\n            thing = getAtom(thing, prop);\n            break;\n    }\n    thing = getAtom(thing);\n    if (isComputedValue(thing)) return log(thing.whyRun());else if (isReaction(thing)) return log(thing.whyRun());\n    return fail(getMessage(\"m025\"));\n}\nexports.whyRun = whyRun;\nfunction createAction(actionName, fn) {\n    invariant(typeof fn === \"function\", getMessage(\"m026\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    var res = function res() {\n        return executeAction(actionName, fn, this, arguments);\n    };\n    res.originalFn = fn;\n    res.isMobxAction = true;\n    return res;\n}\nfunction executeAction(actionName, fn, scope, args) {\n    var runInfo = startAction(actionName, fn, scope, args);\n    try {\n        return fn.apply(scope, args);\n    } finally {\n        endAction(runInfo);\n    }\n}\nfunction startAction(actionName, fn, scope, args) {\n    var notifySpy = isSpyEnabled() && !!actionName;\n    var startTime = 0;\n    if (notifySpy) {\n        startTime = Date.now();\n        var l = args && args.length || 0;\n        var flattendArgs = new Array(l);\n        if (l > 0) for (var i = 0; i < l; i++) {\n            flattendArgs[i] = args[i];\n        }spyReportStart({\n            type: \"action\",\n            name: actionName,\n            fn: fn,\n            object: scope,\n            arguments: flattendArgs\n        });\n    }\n    var prevDerivation = untrackedStart();\n    startBatch();\n    var prevAllowStateChanges = allowStateChangesStart(true);\n    return {\n        prevDerivation: prevDerivation,\n        prevAllowStateChanges: prevAllowStateChanges,\n        notifySpy: notifySpy,\n        startTime: startTime\n    };\n}\nfunction endAction(runInfo) {\n    allowStateChangesEnd(runInfo.prevAllowStateChanges);\n    endBatch();\n    untrackedEnd(runInfo.prevDerivation);\n    if (runInfo.notifySpy) spyReportEnd({ time: Date.now() - runInfo.startTime });\n}\nfunction useStrict(strict) {\n    invariant(globalState.trackingDerivation === null, getMessage(\"m028\"));\n    globalState.strictMode = strict;\n    globalState.allowStateChanges = !strict;\n}\nexports.useStrict = useStrict;\nfunction isStrictModeEnabled() {\n    return globalState.strictMode;\n}\nexports.isStrictModeEnabled = isStrictModeEnabled;\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    var res;\n    try {\n        res = func();\n    } finally {\n        allowStateChangesEnd(prev);\n    }\n    return res;\n}\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nvar BaseAtom = function () {\n    function BaseAtom(name) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        this.name = name;\n        this.isPendingUnobservation = true;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.NOT_TRACKING;\n    }\n    BaseAtom.prototype.onBecomeUnobserved = function () {};\n    BaseAtom.prototype.reportObserved = function () {\n        reportObserved(this);\n    };\n    BaseAtom.prototype.reportChanged = function () {\n        startBatch();\n        propagateChanged(this);\n        endBatch();\n    };\n    BaseAtom.prototype.toString = function () {\n        return this.name;\n    };\n    return BaseAtom;\n}();\nexports.BaseAtom = BaseAtom;\nvar Atom = function (_super) {\n    __extends(Atom, _super);\n    function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        if (onBecomeObservedHandler === void 0) {\n            onBecomeObservedHandler = noop;\n        }\n        if (onBecomeUnobservedHandler === void 0) {\n            onBecomeUnobservedHandler = noop;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.name = name;\n        _this.onBecomeObservedHandler = onBecomeObservedHandler;\n        _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;\n        _this.isPendingUnobservation = false;\n        _this.isBeingTracked = false;\n        return _this;\n    }\n    Atom.prototype.reportObserved = function () {\n        startBatch();\n        _super.prototype.reportObserved.call(this);\n        if (!this.isBeingTracked) {\n            this.isBeingTracked = true;\n            this.onBecomeObservedHandler();\n        }\n        endBatch();\n        return !!globalState.trackingDerivation;\n    };\n    Atom.prototype.onBecomeUnobserved = function () {\n        this.isBeingTracked = false;\n        this.onBecomeUnobservedHandler();\n    };\n    return Atom;\n}(BaseAtom);\nexports.Atom = Atom;\nvar isAtom = createInstanceofPredicate(\"Atom\", BaseAtom);\nvar ComputedValue = function () {\n    function ComputedValue(derivation, scope, compareStructural, name, setter) {\n        this.derivation = derivation;\n        this.scope = scope;\n        this.compareStructural = compareStructural;\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.observing = [];\n        this.newObserving = null;\n        this.isPendingUnobservation = false;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.runId = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.UP_TO_DATE;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.value = undefined;\n        this.isComputing = false;\n        this.isRunningSetter = false;\n        this.name = name || \"ComputedValue@\" + getNextId();\n        if (setter) this.setter = createAction(name + \"-setter\", setter);\n    }\n    ComputedValue.prototype.onBecomeStale = function () {\n        propagateMaybeChanged(this);\n    };\n    ComputedValue.prototype.onBecomeUnobserved = function () {\n        invariant(this.dependenciesState !== IDerivationState.NOT_TRACKING, getMessage(\"m029\"));\n        clearObserving(this);\n        this.value = undefined;\n    };\n    ComputedValue.prototype.get = function () {\n        invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation);\n        if (globalState.inBatch === 0) {\n            startBatch();\n            if (shouldCompute(this)) this.value = this.computeValue(false);\n            endBatch();\n        } else {\n            reportObserved(this);\n            if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this);\n        }\n        var result = this.value;\n        if (isCaughtException(result)) throw result.cause;\n        return result;\n    };\n    ComputedValue.prototype.peek = function () {\n        var res = this.computeValue(false);\n        if (isCaughtException(res)) throw res.cause;\n        return res;\n    };\n    ComputedValue.prototype.set = function (value) {\n        if (this.setter) {\n            invariant(!this.isRunningSetter, \"The setter of computed value '\" + this.name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\");\n            this.isRunningSetter = true;\n            try {\n                this.setter.call(this.scope, value);\n            } finally {\n                this.isRunningSetter = false;\n            }\n        } else invariant(false, \"[ComputedValue '\" + this.name + \"'] It is not possible to assign a new value to a computed value.\");\n    };\n    ComputedValue.prototype.trackAndCompute = function () {\n        if (isSpyEnabled()) {\n            spyReport({\n                object: this.scope,\n                type: \"compute\",\n                fn: this.derivation\n            });\n        }\n        var oldValue = this.value;\n        var newValue = this.value = this.computeValue(true);\n        return isCaughtException(newValue) || valueDidChange(this.compareStructural, newValue, oldValue);\n    };\n    ComputedValue.prototype.computeValue = function (track) {\n        this.isComputing = true;\n        globalState.computationDepth++;\n        var res;\n        if (track) {\n            res = trackDerivedFunction(this, this.derivation, this.scope);\n        } else {\n            try {\n                res = this.derivation.call(this.scope);\n            } catch (e) {\n                res = new CaughtException(e);\n            }\n        }\n        globalState.computationDepth--;\n        this.isComputing = false;\n        return res;\n    };\n    ;\n    ComputedValue.prototype.observe = function (listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function () {\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener({\n                    type: \"update\",\n                    object: _this,\n                    newValue: newValue,\n                    oldValue: prevValue\n                });\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    ComputedValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ComputedValue.prototype.toString = function () {\n        return this.name + \"[\" + this.derivation.toString() + \"]\";\n    };\n    ComputedValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    ;\n    ComputedValue.prototype.whyRun = function () {\n        var isTracking = Boolean(globalState.trackingDerivation);\n        var observing = unique(this.isComputing ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        var observers = unique(getObservers(this).map(function (dep) {\n            return dep.name;\n        }));\n        return \"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + (isTracking ? \"[active] the value of this computation is needed by a reaction\" : this.isComputing ? \"[get] The value of this computed was requested outside a reaction\" : \"[idle] not running at the moment\") + \"\\n\" + (this.dependenciesState === IDerivationState.NOT_TRACKING ? getMessage(\"m032\") : \" * This computation will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this.isComputing && isTracking ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\\n  * If the outcome of this computation changes, the following observers will be re-run:\\n    \" + joinStrings(observers) + \"\\n\");\n    };\n    return ComputedValue;\n}();\nComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf;\nvar isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue);\nvar IDerivationState;\n(function (IDerivationState) {\n    IDerivationState[IDerivationState[\"NOT_TRACKING\"] = -1] = \"NOT_TRACKING\";\n    IDerivationState[IDerivationState[\"UP_TO_DATE\"] = 0] = \"UP_TO_DATE\";\n    IDerivationState[IDerivationState[\"POSSIBLY_STALE\"] = 1] = \"POSSIBLY_STALE\";\n    IDerivationState[IDerivationState[\"STALE\"] = 2] = \"STALE\";\n})(IDerivationState || (IDerivationState = {}));\nexports.IDerivationState = IDerivationState;\nvar CaughtException = function () {\n    function CaughtException(cause) {\n        this.cause = cause;\n    }\n    return CaughtException;\n}();\nfunction isCaughtException(e) {\n    return e instanceof CaughtException;\n}\nfunction shouldCompute(derivation) {\n    switch (derivation.dependenciesState) {\n        case IDerivationState.UP_TO_DATE:\n            return false;\n        case IDerivationState.NOT_TRACKING:\n        case IDerivationState.STALE:\n            return true;\n        case IDerivationState.POSSIBLY_STALE:\n            {\n                var prevUntracked = untrackedStart();\n                var obs = derivation.observing,\n                    l = obs.length;\n                for (var i = 0; i < l; i++) {\n                    var obj = obs[i];\n                    if (isComputedValue(obj)) {\n                        try {\n                            obj.get();\n                        } catch (e) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                        if (derivation.dependenciesState === IDerivationState.STALE) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                    }\n                }\n                changeDependenciesStateTo0(derivation);\n                untrackedEnd(prevUntracked);\n                return false;\n            }\n    }\n}\nfunction isComputingDerivation() {\n    return globalState.trackingDerivation !== null;\n}\nfunction checkIfStateModificationsAreAllowed(atom) {\n    var hasObservers = atom.observers.length > 0;\n    if (globalState.computationDepth > 0 && hasObservers) fail(getMessage(\"m031\") + atom.name);\n    if (!globalState.allowStateChanges && hasObservers) fail(getMessage(globalState.strictMode ? \"m030a\" : \"m030b\") + atom.name);\n}\nfunction trackDerivedFunction(derivation, f, context) {\n    changeDependenciesStateTo0(derivation);\n    derivation.newObserving = new Array(derivation.observing.length + 100);\n    derivation.unboundDepsCount = 0;\n    derivation.runId = ++globalState.runId;\n    var prevTracking = globalState.trackingDerivation;\n    globalState.trackingDerivation = derivation;\n    var result;\n    try {\n        result = f.call(context);\n    } catch (e) {\n        result = new CaughtException(e);\n    }\n    globalState.trackingDerivation = prevTracking;\n    bindDependencies(derivation);\n    return result;\n}\nfunction bindDependencies(derivation) {\n    var prevObserving = derivation.observing;\n    var observing = derivation.observing = derivation.newObserving;\n    derivation.newObserving = null;\n    var i0 = 0,\n        l = derivation.unboundDepsCount;\n    for (var i = 0; i < l; i++) {\n        var dep = observing[i];\n        if (dep.diffValue === 0) {\n            dep.diffValue = 1;\n            if (i0 !== i) observing[i0] = dep;\n            i0++;\n        }\n    }\n    observing.length = i0;\n    l = prevObserving.length;\n    while (l--) {\n        var dep = prevObserving[l];\n        if (dep.diffValue === 0) {\n            removeObserver(dep, derivation);\n        }\n        dep.diffValue = 0;\n    }\n    while (i0--) {\n        var dep = observing[i0];\n        if (dep.diffValue === 1) {\n            dep.diffValue = 0;\n            addObserver(dep, derivation);\n        }\n    }\n}\nfunction clearObserving(derivation) {\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        removeObserver(obs[i], derivation);\n    }derivation.dependenciesState = IDerivationState.NOT_TRACKING;\n    obs.length = 0;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    var res = action();\n    untrackedEnd(prev);\n    return res;\n}\nexports.untracked = untracked;\nfunction untrackedStart() {\n    var prev = globalState.trackingDerivation;\n    globalState.trackingDerivation = null;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.trackingDerivation = prev;\n}\nfunction changeDependenciesStateTo0(derivation) {\n    if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return;\n    derivation.dependenciesState = IDerivationState.UP_TO_DATE;\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nvar persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"];\nvar MobXGlobals = function () {\n    function MobXGlobals() {\n        this.version = 5;\n        this.trackingDerivation = null;\n        this.computationDepth = 0;\n        this.runId = 0;\n        this.mobxGuid = 0;\n        this.inBatch = 0;\n        this.pendingUnobservations = [];\n        this.pendingReactions = [];\n        this.isRunningReactions = false;\n        this.allowStateChanges = true;\n        this.strictMode = false;\n        this.resetId = 0;\n        this.spyListeners = [];\n        this.globalReactionErrorHandlers = [];\n    }\n    return MobXGlobals;\n}();\nvar globalState = new MobXGlobals();\nfunction shareGlobalState() {\n    var global = getGlobal();\n    var ownState = globalState;\n    if (global.__mobservableTrackingStack || global.__mobservableViewStack) throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\");\n    if (global.__mobxGlobal && global.__mobxGlobal.version !== ownState.version) throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\");\n    if (global.__mobxGlobal) globalState = global.__mobxGlobal;else global.__mobxGlobal = ownState;\n}\nfunction getGlobalState() {\n    return globalState;\n}\nfunction registerGlobals() {}\nfunction resetGlobalState() {\n    globalState.resetId++;\n    var defaultGlobals = new MobXGlobals();\n    for (var key in defaultGlobals) {\n        if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];\n    }globalState.allowStateChanges = !globalState.strictMode;\n}\nfunction hasObservers(observable) {\n    return observable.observers && observable.observers.length > 0;\n}\nfunction getObservers(observable) {\n    return observable.observers;\n}\nfunction invariantObservers(observable) {\n    var list = observable.observers;\n    var map = observable.observersIndexes;\n    var l = list.length;\n    for (var i = 0; i < l; i++) {\n        var id = list[i].__mapid;\n        if (i) {\n            invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\");\n        } else {\n            invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldnt be held in map.\");\n        }\n    }\n    invariant(list.length === 0 || Object.keys(map).length === list.length - 1, \"INTERNAL ERROR there is no junk in map\");\n}\nfunction addObserver(observable, node) {\n    var l = observable.observers.length;\n    if (l) {\n        observable.observersIndexes[node.__mapid] = l;\n    }\n    observable.observers[l] = node;\n    if (observable.lowestObserverState > node.dependenciesState) observable.lowestObserverState = node.dependenciesState;\n}\nfunction removeObserver(observable, node) {\n    if (observable.observers.length === 1) {\n        observable.observers.length = 0;\n        queueForUnobservation(observable);\n    } else {\n        var list = observable.observers;\n        var map_1 = observable.observersIndexes;\n        var filler = list.pop();\n        if (filler !== node) {\n            var index = map_1[node.__mapid] || 0;\n            if (index) {\n                map_1[filler.__mapid] = index;\n            } else {\n                delete map_1[filler.__mapid];\n            }\n            list[index] = filler;\n        }\n        delete map_1[node.__mapid];\n    }\n}\nfunction queueForUnobservation(observable) {\n    if (!observable.isPendingUnobservation) {\n        observable.isPendingUnobservation = true;\n        globalState.pendingUnobservations.push(observable);\n    }\n}\nfunction startBatch() {\n    globalState.inBatch++;\n}\nfunction endBatch() {\n    if (--globalState.inBatch === 0) {\n        runReactions();\n        var list = globalState.pendingUnobservations;\n        for (var i = 0; i < list.length; i++) {\n            var observable_1 = list[i];\n            observable_1.isPendingUnobservation = false;\n            if (observable_1.observers.length === 0) {\n                observable_1.onBecomeUnobserved();\n            }\n        }\n        globalState.pendingUnobservations = [];\n    }\n}\nfunction reportObserved(observable) {\n    var derivation = globalState.trackingDerivation;\n    if (derivation !== null) {\n        if (derivation.runId !== observable.lastAccessedBy) {\n            observable.lastAccessedBy = derivation.runId;\n            derivation.newObserving[derivation.unboundDepsCount++] = observable;\n        }\n    } else if (observable.observers.length === 0) {\n        queueForUnobservation(observable);\n    }\n}\nfunction invariantLOS(observable, msg) {\n    var min = getObservers(observable).reduce(function (a, b) {\n        return Math.min(a, b.dependenciesState);\n    }, 2);\n    if (min >= observable.lowestObserverState) return;\n    throw new Error(\"lowestObserverState is wrong for \" + msg + \" because \" + min + \" < \" + observable.lowestObserverState);\n}\nfunction propagateChanged(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale();\n        d.dependenciesState = IDerivationState.STALE;\n    }\n}\nfunction propagateChangeConfirmed(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.POSSIBLY_STALE) d.dependenciesState = IDerivationState.STALE;else if (d.dependenciesState === IDerivationState.UP_TO_DATE) observable.lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nfunction propagateMaybeChanged(observable) {\n    if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return;\n    observable.lowestObserverState = IDerivationState.POSSIBLY_STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {\n            d.dependenciesState = IDerivationState.POSSIBLY_STALE;\n            d.onBecomeStale();\n        }\n    }\n}\nvar Reaction = function () {\n    function Reaction(name, onInvalidate) {\n        if (name === void 0) {\n            name = \"Reaction@\" + getNextId();\n        }\n        this.name = name;\n        this.onInvalidate = onInvalidate;\n        this.observing = [];\n        this.newObserving = [];\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.diffValue = 0;\n        this.runId = 0;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.isDisposed = false;\n        this._isScheduled = false;\n        this._isTrackPending = false;\n        this._isRunning = false;\n    }\n    Reaction.prototype.onBecomeStale = function () {\n        this.schedule();\n    };\n    Reaction.prototype.schedule = function () {\n        if (!this._isScheduled) {\n            this._isScheduled = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    };\n    Reaction.prototype.isScheduled = function () {\n        return this._isScheduled;\n    };\n    Reaction.prototype.runReaction = function () {\n        if (!this.isDisposed) {\n            startBatch();\n            this._isScheduled = false;\n            if (shouldCompute(this)) {\n                this._isTrackPending = true;\n                this.onInvalidate();\n                if (this._isTrackPending && isSpyEnabled()) {\n                    spyReport({\n                        object: this,\n                        type: \"scheduled-reaction\"\n                    });\n                }\n            }\n            endBatch();\n        }\n    };\n    Reaction.prototype.track = function (fn) {\n        startBatch();\n        var notify = isSpyEnabled();\n        var startTime;\n        if (notify) {\n            startTime = Date.now();\n            spyReportStart({\n                object: this,\n                type: \"reaction\",\n                fn: fn\n            });\n        }\n        this._isRunning = true;\n        var result = trackDerivedFunction(this, fn, undefined);\n        this._isRunning = false;\n        this._isTrackPending = false;\n        if (this.isDisposed) {\n            clearObserving(this);\n        }\n        if (isCaughtException(result)) this.reportExceptionInDerivation(result.cause);\n        if (notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n        endBatch();\n    };\n    Reaction.prototype.reportExceptionInDerivation = function (error) {\n        var _this = this;\n        if (this.errorHandler) {\n            this.errorHandler(error, this);\n            return;\n        }\n        var message = \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this;\n        var messageToUser = getMessage(\"m037\");\n        console.error(message || messageToUser, error);\n        if (isSpyEnabled()) {\n            spyReport({\n                type: \"error\",\n                message: message,\n                error: error,\n                object: this\n            });\n        }\n        globalState.globalReactionErrorHandlers.forEach(function (f) {\n            return f(error, _this);\n        });\n    };\n    Reaction.prototype.dispose = function () {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            if (!this._isRunning) {\n                startBatch();\n                clearObserving(this);\n                endBatch();\n            }\n        }\n    };\n    Reaction.prototype.getDisposer = function () {\n        var r = this.dispose.bind(this);\n        r.$mobx = this;\n        r.onError = registerErrorHandler;\n        return r;\n    };\n    Reaction.prototype.toString = function () {\n        return \"Reaction[\" + this.name + \"]\";\n    };\n    Reaction.prototype.whyRun = function () {\n        var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        return \"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this._isRunning ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\";\n    };\n    return Reaction;\n}();\nexports.Reaction = Reaction;\nfunction registerErrorHandler(handler) {\n    invariant(this && this.$mobx && isReaction(this.$mobx), \"Invalid `this`\");\n    invariant(!this.$mobx.errorHandler, \"Only one onErrorHandler can be registered\");\n    this.$mobx.errorHandler = handler;\n}\nfunction onReactionError(handler) {\n    globalState.globalReactionErrorHandlers.push(handler);\n    return function () {\n        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n        if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);\n    };\n}\nvar MAX_REACTION_ITERATIONS = 100;\nvar reactionScheduler = function reactionScheduler(f) {\n    return f();\n};\nfunction runReactions() {\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) return;\n    reactionScheduler(runReactionsHelper);\n}\nfunction runReactionsHelper() {\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    while (allReactions.length > 0) {\n        if (++iterations === MAX_REACTION_ITERATIONS) {\n            console.error(\"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0]));\n            allReactions.splice(0);\n        }\n        var remainingReactions = allReactions.splice(0);\n        for (var i = 0, l = remainingReactions.length; i < l; i++) {\n            remainingReactions[i].runReaction();\n        }\n    }\n    globalState.isRunningReactions = false;\n}\nvar isReaction = createInstanceofPredicate(\"Reaction\", Reaction);\nfunction setReactionScheduler(fn) {\n    var baseScheduler = reactionScheduler;\n    reactionScheduler = function reactionScheduler(f) {\n        return fn(function () {\n            return baseScheduler(f);\n        });\n    };\n}\nfunction isSpyEnabled() {\n    return !!globalState.spyListeners.length;\n}\nfunction spyReport(event) {\n    if (!globalState.spyListeners.length) return;\n    var listeners = globalState.spyListeners;\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](event);\n    }\n}\nfunction spyReportStart(event) {\n    var change = objectAssign({}, event, { spyReportStart: true });\n    spyReport(change);\n}\nvar END_EVENT = { spyReportEnd: true };\nfunction spyReportEnd(change) {\n    if (change) spyReport(objectAssign({}, change, END_EVENT));else spyReport(END_EVENT);\n}\nfunction spy(listener) {\n    globalState.spyListeners.push(listener);\n    return once(function () {\n        var idx = globalState.spyListeners.indexOf(listener);\n        if (idx !== -1) globalState.spyListeners.splice(idx, 1);\n    });\n}\nexports.spy = spy;\nfunction hasInterceptors(interceptable) {\n    return interceptable.interceptors && interceptable.interceptors.length > 0;\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);\n    interceptors.push(handler);\n    return once(function () {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1) interceptors.splice(idx, 1);\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    try {\n        var interceptors = interceptable.interceptors;\n        if (interceptors) for (var i = 0, l = interceptors.length; i < l; i++) {\n            change = interceptors[i](change);\n            invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\");\n            if (!change) break;\n        }\n        return change;\n    } finally {\n        untrackedEnd(prevU);\n    }\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners && listenable.changeListeners.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners || (listenable.changeListeners = []);\n    listeners.push(handler);\n    return once(function () {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1) listeners.splice(idx, 1);\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners;\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](change);\n    }\n    untrackedEnd(prevU);\n}\nfunction asReference(value) {\n    deprecated(\"asReference is deprecated, use observable.ref instead\");\n    return observable.ref(value);\n}\nexports.asReference = asReference;\nfunction asStructure(value) {\n    deprecated(\"asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.\");\n    return observable.struct(value);\n}\nexports.asStructure = asStructure;\nfunction asFlat(value) {\n    deprecated(\"asFlat is deprecated, use observable.shallow instead\");\n    return observable.shallow(value);\n}\nexports.asFlat = asFlat;\nfunction asMap(data) {\n    deprecated(\"asMap is deprecated, use observable.map or observable.shallowMap instead\");\n    return observable.map(data || {});\n}\nexports.asMap = asMap;\nfunction isModifierDescriptor(thing) {\n    return (typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null && thing.isMobxModifierDescriptor === true;\n}\nexports.isModifierDescriptor = isModifierDescriptor;\nfunction createModifierDescriptor(enhancer, initialValue) {\n    invariant(!isModifierDescriptor(initialValue), \"Modifiers cannot be nested\");\n    return {\n        isMobxModifierDescriptor: true,\n        initialValue: initialValue,\n        enhancer: enhancer\n    };\n}\nfunction deepEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return observable.array(v, name);\n    if (isPlainObject(v)) return observable.object(v, name);\n    if (isES6Map(v)) return observable.map(v, name);\n    return v;\n}\nfunction shallowEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (v === undefined || v === null) return v;\n    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v)) return v;\n    if (Array.isArray(v)) return observable.shallowArray(v, name);\n    if (isPlainObject(v)) return observable.shallowObject(v, name);\n    if (isES6Map(v)) return observable.shallowMap(v, name);\n    return fail(\"The shallow modifier / decorator can only used in combination with arrays, objects and maps\");\n}\nfunction referenceEnhancer(newValue) {\n    return newValue;\n}\nfunction deepStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return new ObservableArray(v, deepStructEnhancer, name);\n    if (isES6Map(v)) return new ObservableMap(v, deepStructEnhancer, name);\n    if (isPlainObject(v)) {\n        var res = {};\n        asObservableObject(res, name);\n        extendObservableHelper(res, deepStructEnhancer, [v]);\n        return res;\n    }\n    return v;\n}\nfunction refStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    return v;\n}\nvar MAX_SPLICE_SIZE = 10000;\nvar safariPrototypeSetterInheritanceBug = function () {\n    var v = false;\n    var p = {};\n    Object.defineProperty(p, \"0\", { set: function set() {\n            v = true;\n        } });\n    Object.create(p)[\"0\"] = 1;\n    return v === false;\n}();\nvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\nvar StubArray = function () {\n    function StubArray() {}\n    return StubArray;\n}();\nStubArray.prototype = [];\nvar ObservableArrayAdministration = function () {\n    function ObservableArrayAdministration(name, enhancer, array, owned) {\n        this.array = array;\n        this.owned = owned;\n        this.lastKnownLength = 0;\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.atom = new BaseAtom(name || \"ObservableArray@\" + getNextId());\n        this.enhancer = function (newV, oldV) {\n            return enhancer(newV, oldV, name + \"[..]\");\n        };\n    }\n    ObservableArrayAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        if (fireImmediately) {\n            listener({\n                object: this.array,\n                type: \"splice\",\n                index: 0,\n                added: this.values.slice(),\n                addedCount: this.values.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    ObservableArrayAdministration.prototype.getArrayLength = function () {\n        this.atom.reportObserved();\n        return this.values.length;\n    };\n    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {\n        if (typeof newLength !== \"number\" || newLength < 0) throw new Error(\"[mobx.array] Out of range: \" + newLength);\n        var currentLength = this.values.length;\n        if (newLength === currentLength) return;else if (newLength > currentLength) {\n            var newItems = new Array(newLength - currentLength);\n            for (var i = 0; i < newLength - currentLength; i++) {\n                newItems[i] = undefined;\n            }this.spliceWithArray(currentLength, 0, newItems);\n        } else this.spliceWithArray(newLength, currentLength - newLength);\n    };\n    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {\n        if (oldLength !== this.lastKnownLength) throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\");\n        this.lastKnownLength += delta;\n        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1);\n    };\n    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        var _this = this;\n        checkIfStateModificationsAreAllowed(this.atom);\n        var length = this.values.length;\n        if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);\n        if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        if (newItems === undefined) newItems = [];\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.array,\n                type: \"splice\",\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change) return EMPTY_ARRAY;\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.map(function (v) {\n            return _this.enhancer(v, undefined);\n        });\n        var lengthDelta = newItems.length - deleteCount;\n        this.updateArrayLength(length, lengthDelta);\n        var res = this.spliceItemsIntoValues(index, deleteCount, newItems);\n        if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res);\n        return res;\n    };\n    ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) {\n        if (newItems.length < MAX_SPLICE_SIZE) {\n            return (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));\n        } else {\n            var res = this.values.slice(index, index + deleteCount);\n            this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount));\n            return res;\n        }\n        var _a;\n    };\n    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"update\",\n            index: index, newValue: newValue, oldValue: oldValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"splice\",\n            index: index, removed: removed, added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    return ObservableArrayAdministration;\n}();\nvar ObservableArray = function (_super) {\n    __extends(ObservableArray, _super);\n    function ObservableArray(initialValues, enhancer, name, owned) {\n        if (name === void 0) {\n            name = \"ObservableArray@\" + getNextId();\n        }\n        if (owned === void 0) {\n            owned = false;\n        }\n        var _this = _super.call(this) || this;\n        var adm = new ObservableArrayAdministration(name, enhancer, _this, owned);\n        addHiddenFinalProp(_this, \"$mobx\", adm);\n        if (initialValues && initialValues.length) {\n            adm.updateArrayLength(0, initialValues.length);\n            adm.values = initialValues.map(function (v) {\n                return enhancer(v, undefined, name + \"[..]\");\n            });\n            adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY);\n        } else {\n            adm.values = [];\n        }\n        if (safariPrototypeSetterInheritanceBug) {\n            Object.defineProperty(adm.array, \"0\", ENTRY_0);\n        }\n        return _this;\n    }\n    ObservableArray.prototype.intercept = function (handler) {\n        return this.$mobx.intercept(handler);\n    };\n    ObservableArray.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        return this.$mobx.observe(listener, fireImmediately);\n    };\n    ObservableArray.prototype.clear = function () {\n        return this.splice(0);\n    };\n    ObservableArray.prototype.concat = function () {\n        var arrays = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            arrays[_i] = arguments[_i];\n        }\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) {\n            return isObservableArray(a) ? a.peek() : a;\n        }));\n    };\n    ObservableArray.prototype.replace = function (newItems) {\n        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);\n    };\n    ObservableArray.prototype.toJS = function () {\n        return this.slice();\n    };\n    ObservableArray.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableArray.prototype.peek = function () {\n        return this.$mobx.values;\n    };\n    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {\n        if (fromIndex === void 0) {\n            fromIndex = 0;\n        }\n        this.$mobx.atom.reportObserved();\n        var items = this.$mobx.values,\n            l = items.length;\n        for (var i = fromIndex; i < l; i++) {\n            if (predicate.call(thisArg, items[i], i, this)) return items[i];\n        }return undefined;\n    };\n    ObservableArray.prototype.splice = function (index, deleteCount) {\n        var newItems = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            newItems[_i - 2] = arguments[_i];\n        }\n        switch (arguments.length) {\n            case 0:\n                return [];\n            case 1:\n                return this.$mobx.spliceWithArray(index);\n            case 2:\n                return this.$mobx.spliceWithArray(index, deleteCount);\n        }\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.push = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(adm.values.length, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.pop = function () {\n        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];\n    };\n    ObservableArray.prototype.shift = function () {\n        return this.splice(0, 1)[0];\n    };\n    ObservableArray.prototype.unshift = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(0, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.reverse = function () {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.reverse.apply(clone, arguments);\n    };\n    ObservableArray.prototype.sort = function (compareFn) {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.sort.apply(clone, arguments);\n    };\n    ObservableArray.prototype.remove = function (value) {\n        var idx = this.$mobx.values.indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    };\n    ObservableArray.prototype.move = function (fromIndex, toIndex) {\n        function checkIndex(index) {\n            if (index < 0) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\n            }\n            var length = this.$mobx.values.length;\n            if (index >= length) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\n            }\n        }\n        checkIndex.call(this, fromIndex);\n        checkIndex.call(this, toIndex);\n        if (fromIndex === toIndex) {\n            return;\n        }\n        var oldItems = this.$mobx.values;\n        var newItems;\n        if (fromIndex < toIndex) {\n            newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1));\n        } else {\n            newItems = oldItems.slice(0, toIndex).concat([oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\n        }\n        this.replace(newItems);\n    };\n    ObservableArray.prototype.toString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toString.apply(this.$mobx.values, arguments);\n    };\n    ObservableArray.prototype.toLocaleString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toLocaleString.apply(this.$mobx.values, arguments);\n    };\n    return ObservableArray;\n}(StubArray);\ndeclareIterator(ObservableArray.prototype, function () {\n    return arrayAsIterator(this.slice());\n});\nmakeNonEnumerable(ObservableArray.prototype, [\"constructor\", \"intercept\", \"observe\", \"clear\", \"concat\", \"replace\", \"toJS\", \"toJSON\", \"peek\", \"find\", \"splice\", \"spliceWithArray\", \"push\", \"pop\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"remove\", \"move\", \"toString\", \"toLocaleString\"]);\nObject.defineProperty(ObservableArray.prototype, \"length\", {\n    enumerable: false,\n    configurable: true,\n    get: function get() {\n        return this.$mobx.getArrayLength();\n    },\n    set: function set(newLength) {\n        this.$mobx.setArrayLength(newLength);\n    }\n});\n[\"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function (funcName) {\n    var baseFunc = Array.prototype[funcName];\n    invariant(typeof baseFunc === \"function\", \"Base function not defined on Array prototype: '\" + funcName + \"'\");\n    addHiddenProp(ObservableArray.prototype, funcName, function () {\n        this.$mobx.atom.reportObserved();\n        return baseFunc.apply(this.$mobx.values, arguments);\n    });\n});\nvar ENTRY_0 = {\n    configurable: true,\n    enumerable: false,\n    set: createArraySetter(0),\n    get: createArrayGetter(0)\n};\nfunction createArrayBufferItem(index) {\n    var set = createArraySetter(index);\n    var get = createArrayGetter(index);\n    Object.defineProperty(ObservableArray.prototype, \"\" + index, {\n        enumerable: false,\n        configurable: true,\n        set: set, get: get\n    });\n}\nfunction createArraySetter(index) {\n    return function (newValue) {\n        var adm = this.$mobx;\n        var values = adm.values;\n        if (index < values.length) {\n            checkIfStateModificationsAreAllowed(adm.atom);\n            var oldValue = values[index];\n            if (hasInterceptors(adm)) {\n                var change = interceptChange(adm, {\n                    type: \"update\",\n                    object: adm.array,\n                    index: index, newValue: newValue\n                });\n                if (!change) return;\n                newValue = change.newValue;\n            }\n            newValue = adm.enhancer(newValue, oldValue);\n            var changed = newValue !== oldValue;\n            if (changed) {\n                values[index] = newValue;\n                adm.notifyArrayChildUpdate(index, newValue, oldValue);\n            }\n        } else if (index === values.length) {\n            adm.spliceWithArray(index, 0, [newValue]);\n        } else throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length);\n    };\n}\nfunction createArrayGetter(index) {\n    return function () {\n        var impl = this.$mobx;\n        if (impl) {\n            if (index < impl.values.length) {\n                impl.atom.reportObserved();\n                return impl.values[index];\n            }\n            console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\");\n        }\n        return undefined;\n    };\n}\nfunction reserveArrayBuffer(max) {\n    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) {\n        createArrayBufferItem(index);\n    }OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n}\nreserveArrayBuffer(1000);\nvar isObservableArrayAdministration = createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\nfunction isObservableArray(thing) {\n    return isObject(thing) && isObservableArrayAdministration(thing.$mobx);\n}\nexports.isObservableArray = isObservableArray;\nvar ObservableMapMarker = {};\nvar ObservableMap = function () {\n    function ObservableMap(initialData, enhancer, name) {\n        if (enhancer === void 0) {\n            enhancer = deepEnhancer;\n        }\n        if (name === void 0) {\n            name = \"ObservableMap@\" + getNextId();\n        }\n        this.enhancer = enhancer;\n        this.name = name;\n        this.$mobx = ObservableMapMarker;\n        this._data = {};\n        this._hasMap = {};\n        this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + \".keys()\", true);\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.merge(initialData);\n    }\n    ObservableMap.prototype._has = function (key) {\n        return typeof this._data[key] !== \"undefined\";\n    };\n    ObservableMap.prototype.has = function (key) {\n        if (!this.isValidKey(key)) return false;\n        key = \"\" + key;\n        if (this._hasMap[key]) return this._hasMap[key].get();\n        return this._updateHasMapEntry(key, false).get();\n    };\n    ObservableMap.prototype.set = function (key, value) {\n        this.assertValidKey(key);\n        key = \"\" + key;\n        var hasKey = this._has(key);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? \"update\" : \"add\",\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change) return this;\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this._updateValue(key, value);\n        } else {\n            this._addValue(key, value);\n        }\n        return this;\n    };\n    ObservableMap.prototype.delete = function (key) {\n        var _this = this;\n        this.assertValidKey(key);\n        key = \"\" + key;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: \"delete\",\n                object: this,\n                name: key\n            });\n            if (!change) return false;\n        }\n        if (this._has(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"delete\",\n                object: this,\n                oldValue: this._data[key].value,\n                name: key\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            runInTransaction(function () {\n                _this._keys.remove(key);\n                _this._updateHasMapEntry(key, false);\n                var observable = _this._data[key];\n                observable.setNewValue(undefined);\n                _this._data[key] = undefined;\n            });\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n            return true;\n        }\n        return false;\n    };\n    ObservableMap.prototype._updateHasMapEntry = function (key, value) {\n        var entry = this._hasMap[key];\n        if (entry) {\n            entry.setNewValue(value);\n        } else {\n            entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + \".\" + key + \"?\", false);\n        }\n        return entry;\n    };\n    ObservableMap.prototype._updateValue = function (name, newValue) {\n        var observable = this._data[name];\n        newValue = observable.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"update\",\n                object: this,\n                oldValue: observable.value,\n                name: name, newValue: newValue\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            observable.setNewValue(newValue);\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableMap.prototype._addValue = function (name, newValue) {\n        var _this = this;\n        runInTransaction(function () {\n            var observable = _this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + \".\" + name, false);\n            newValue = observable.value;\n            _this._updateHasMapEntry(name, true);\n            _this._keys.push(name);\n        });\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            type: \"add\",\n            object: this,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableMap.prototype.get = function (key) {\n        key = \"\" + key;\n        if (this.has(key)) return this._data[key].get();\n        return undefined;\n    };\n    ObservableMap.prototype.keys = function () {\n        return arrayAsIterator(this._keys.slice());\n    };\n    ObservableMap.prototype.values = function () {\n        return arrayAsIterator(this._keys.map(this.get, this));\n    };\n    ObservableMap.prototype.entries = function () {\n        var _this = this;\n        return arrayAsIterator(this._keys.map(function (key) {\n            return [key, _this.get(key)];\n        }));\n    };\n    ObservableMap.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        this.keys().forEach(function (key) {\n            return callback.call(thisArg, _this.get(key), key, _this);\n        });\n    };\n    ObservableMap.prototype.merge = function (other) {\n        var _this = this;\n        if (isObservableMap(other)) {\n            other = other.toJS();\n        }\n        runInTransaction(function () {\n            if (isPlainObject(other)) Object.keys(other).forEach(function (key) {\n                return _this.set(key, other[key]);\n            });else if (Array.isArray(other)) other.forEach(function (_a) {\n                var key = _a[0],\n                    value = _a[1];\n                return _this.set(key, value);\n            });else if (isES6Map(other)) other.forEach(function (value, key) {\n                return _this.set(key, value);\n            });else if (other !== null && other !== undefined) fail(\"Cannot initialize map from \" + other);\n        });\n        return this;\n    };\n    ObservableMap.prototype.clear = function () {\n        var _this = this;\n        runInTransaction(function () {\n            untracked(function () {\n                _this.keys().forEach(_this.delete, _this);\n            });\n        });\n    };\n    ObservableMap.prototype.replace = function (values) {\n        var _this = this;\n        runInTransaction(function () {\n            _this.clear();\n            _this.merge(values);\n        });\n        return this;\n    };\n    Object.defineProperty(ObservableMap.prototype, \"size\", {\n        get: function get() {\n            return this._keys.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObservableMap.prototype.toJS = function () {\n        var _this = this;\n        var res = {};\n        this.keys().forEach(function (key) {\n            return res[key] = _this.get(key);\n        });\n        return res;\n    };\n    ObservableMap.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableMap.prototype.isValidKey = function (key) {\n        if (key === null || key === undefined) return false;\n        if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"boolean\") return true;\n        return false;\n    };\n    ObservableMap.prototype.assertValidKey = function (key) {\n        if (!this.isValidKey(key)) throw new Error(\"[mobx.map] Invalid key: '\" + key + \"', only strings, numbers and booleans are accepted as key in observable maps.\");\n    };\n    ObservableMap.prototype.toString = function () {\n        var _this = this;\n        return this.name + \"[{ \" + this.keys().map(function (key) {\n            return key + \": \" + (\"\" + _this.get(key));\n        }).join(\", \") + \" }]\";\n    };\n    ObservableMap.prototype.observe = function (listener, fireImmediately) {\n        invariant(fireImmediately !== true, getMessage(\"m033\"));\n        return registerListener(this, listener);\n    };\n    ObservableMap.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableMap;\n}();\nexports.ObservableMap = ObservableMap;\ndeclareIterator(ObservableMap.prototype, function () {\n    return this.entries();\n});\nfunction map(initialValues) {\n    deprecated(\"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\");\n    return observable.map(initialValues);\n}\nexports.map = map;\nvar isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap);\nexports.isObservableMap = isObservableMap;\nvar ObservableObjectAdministration = function () {\n    function ObservableObjectAdministration(target, name) {\n        this.target = target;\n        this.name = name;\n        this.values = {};\n        this.changeListeners = null;\n        this.interceptors = null;\n    }\n    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {\n        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\");\n        return registerListener(this, callback);\n    };\n    ObservableObjectAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableObjectAdministration;\n}();\nfunction asObservableObject(target, name) {\n    if (isObservableObject(target)) return target.$mobx;\n    invariant(Object.isExtensible(target), getMessage(\"m035\"));\n    if (!isPlainObject(target)) name = (target.constructor.name || \"ObservableObject\") + \"@\" + getNextId();\n    if (!name) name = \"ObservableObject@\" + getNextId();\n    var adm = new ObservableObjectAdministration(target, name);\n    addHiddenFinalProp(target, \"$mobx\", adm);\n    return adm;\n}\nfunction defineObservablePropertyFromDescriptor(adm, propName, descriptor, defaultEnhancer) {\n    if (adm.values[propName]) {\n        invariant(\"value\" in descriptor, \"The property \" + propName + \" in \" + adm.name + \" is already observable, cannot redefine it as computed property\");\n        adm.target[propName] = descriptor.value;\n        return;\n    }\n    if (\"value\" in descriptor) {\n        if (isModifierDescriptor(descriptor.value)) {\n            var modifierDescriptor = descriptor.value;\n            defineObservableProperty(adm, propName, modifierDescriptor.initialValue, modifierDescriptor.enhancer);\n        } else if (isAction(descriptor.value) && descriptor.value.autoBind === true) {\n            defineBoundAction(adm.target, propName, descriptor.value.originalFn);\n        } else if (isComputedValue(descriptor.value)) {\n            defineComputedPropertyFromComputedValue(adm, propName, descriptor.value);\n        } else {\n            defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer);\n        }\n    } else {\n        defineComputedProperty(adm, propName, descriptor.get, descriptor.set, false, true);\n    }\n}\nfunction defineObservableProperty(adm, propName, newValue, enhancer) {\n    assertPropertyConfigurable(adm.target, propName);\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            object: adm.target,\n            name: propName,\n            type: \"add\",\n            newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    var observable = adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + \".\" + propName, false);\n    newValue = observable.value;\n    Object.defineProperty(adm.target, propName, generateObservablePropConfig(propName));\n    notifyPropertyAddition(adm, adm.target, propName, newValue);\n}\nfunction defineComputedProperty(adm, propName, getter, setter, compareStructural, asInstanceProperty) {\n    if (asInstanceProperty) assertPropertyConfigurable(adm.target, propName);\n    adm.values[propName] = new ComputedValue(getter, adm.target, compareStructural, adm.name + \".\" + propName, setter);\n    if (asInstanceProperty) {\n        Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n    }\n}\nfunction defineComputedPropertyFromComputedValue(adm, propName, computedValue) {\n    var name = adm.name + \".\" + propName;\n    computedValue.name = name;\n    if (!computedValue.scope) computedValue.scope = adm.target;\n    adm.values[propName] = computedValue;\n    Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n}\nvar observablePropertyConfigs = {};\nvar computedPropertyConfigs = {};\nfunction generateObservablePropConfig(propName) {\n    return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            setPropertyValue(this, propName, v);\n        }\n    });\n}\nfunction generateComputedPropConfig(propName) {\n    return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: false,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            return this.$mobx.values[propName].set(v);\n        }\n    });\n}\nfunction setPropertyValue(instance, name, newValue) {\n    var adm = instance.$mobx;\n    var observable = adm.values[name];\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            type: \"update\",\n            object: instance,\n            name: name, newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    newValue = observable.prepareNewValue(newValue);\n    if (newValue !== UNCHANGED) {\n        var notify = hasListeners(adm);\n        var notifySpy = isSpyEnabled();\n        var change = notify || notifySpy ? {\n            type: \"update\",\n            object: instance,\n            oldValue: observable.value,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        observable.setNewValue(newValue);\n        if (notify) notifyListeners(adm, change);\n        if (notifySpy) spyReportEnd();\n    }\n}\nfunction notifyPropertyAddition(adm, object, name, newValue) {\n    var notify = hasListeners(adm);\n    var notifySpy = isSpyEnabled();\n    var change = notify || notifySpy ? {\n        type: \"add\",\n        object: object, name: name, newValue: newValue\n    } : null;\n    if (notifySpy) spyReportStart(change);\n    if (notify) notifyListeners(adm, change);\n    if (notifySpy) spyReportEnd();\n}\nvar isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\nfunction isObservableObject(thing) {\n    if (isObject(thing)) {\n        runLazyInitializers(thing);\n        return isObservableObjectAdministration(thing.$mobx);\n    }\n    return false;\n}\nexports.isObservableObject = isObservableObject;\nvar UNCHANGED = {};\nvar ObservableValue = function (_super) {\n    __extends(ObservableValue, _super);\n    function ObservableValue(value, enhancer, name, notifySpy) {\n        if (name === void 0) {\n            name = \"ObservableValue@\" + getNextId();\n        }\n        if (notifySpy === void 0) {\n            notifySpy = true;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.enhancer = enhancer;\n        _this.hasUnreportedChange = false;\n        _this.value = enhancer(value, undefined, name);\n        if (notifySpy && isSpyEnabled()) {\n            spyReport({ type: \"create\", object: _this, newValue: _this.value });\n        }\n        return _this;\n    }\n    ObservableValue.prototype.set = function (newValue) {\n        var oldValue = this.value;\n        newValue = this.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if (notifySpy) {\n                spyReportStart({\n                    type: \"update\",\n                    object: this,\n                    newValue: newValue, oldValue: oldValue\n                });\n            }\n            this.setNewValue(newValue);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableValue.prototype.prepareNewValue = function (newValue) {\n        checkIfStateModificationsAreAllowed(this);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue });\n            if (!change) return UNCHANGED;\n            newValue = change.newValue;\n        }\n        newValue = this.enhancer(newValue, this.value, this.name);\n        return this.value !== newValue ? newValue : UNCHANGED;\n    };\n    ObservableValue.prototype.setNewValue = function (newValue) {\n        var oldValue = this.value;\n        this.value = newValue;\n        this.reportChanged();\n        if (hasListeners(this)) {\n            notifyListeners(this, {\n                type: \"update\",\n                object: this,\n                newValue: newValue,\n                oldValue: oldValue\n            });\n        }\n    };\n    ObservableValue.prototype.get = function () {\n        this.reportObserved();\n        return this.value;\n    };\n    ObservableValue.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableValue.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately) listener({\n            object: this,\n            type: \"update\",\n            newValue: this.value,\n            oldValue: undefined\n        });\n        return registerListener(this, listener);\n    };\n    ObservableValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ObservableValue.prototype.toString = function () {\n        return this.name + \"[\" + this.value + \"]\";\n    };\n    ObservableValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    return ObservableValue;\n}(BaseAtom);\nObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf;\nvar isObservableValue = createInstanceofPredicate(\"ObservableValue\", ObservableValue);\nexports.isBoxedObservable = isObservableValue;\nfunction getAtom(thing, property) {\n    if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            invariant(property === undefined, getMessage(\"m036\"));\n            return thing.$mobx.atom;\n        }\n        if (isObservableMap(thing)) {\n            var anyThing = thing;\n            if (property === undefined) return getAtom(anyThing._keys);\n            var observable_2 = anyThing._data[property] || anyThing._hasMap[property];\n            invariant(!!observable_2, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\");\n            return observable_2;\n        }\n        runLazyInitializers(thing);\n        if (isObservableObject(thing)) {\n            if (!property) return fail(\"please specify a property\");\n            var observable_3 = thing.$mobx.values[property];\n            invariant(!!observable_3, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\");\n            return observable_3;\n        }\n        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n            return thing;\n        }\n    } else if (typeof thing === \"function\") {\n        if (isReaction(thing.$mobx)) {\n            return thing.$mobx;\n        }\n    }\n    return fail(\"Cannot obtain atom from \" + thing);\n}\nfunction getAdministration(thing, property) {\n    invariant(thing, \"Expecting some object\");\n    if (property !== undefined) return getAdministration(getAtom(thing, property));\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;\n    if (isObservableMap(thing)) return thing;\n    runLazyInitializers(thing);\n    if (thing.$mobx) return thing.$mobx;\n    invariant(false, \"Cannot obtain administration from \" + thing);\n}\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing)) named = getAdministration(thing);else named = getAtom(thing);\n    return named.name;\n}\nfunction createClassPropertyDecorator(onInitialize, _get, _set, enumerable, allowCustomArguments) {\n    function classPropertyDecorator(target, key, descriptor, customArgs, argLen) {\n        if (argLen === void 0) {\n            argLen = 0;\n        }\n        invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\");\n        if (!descriptor) {\n            var newDescriptor = {\n                enumerable: enumerable,\n                configurable: true,\n                get: function get() {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {\n                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);\n                    } else {\n                        _set.call(this, key, v);\n                    }\n                }\n            };\n            if (arguments.length < 3 || arguments.length === 5 && argLen < 3) {\n                Object.defineProperty(target, key, newDescriptor);\n            }\n            return newDescriptor;\n        } else {\n            if (!hasOwnProperty(target, \"__mobxLazyInitializers\")) {\n                addHiddenProp(target, \"__mobxLazyInitializers\", target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice() || []);\n            }\n            var value_1 = descriptor.value,\n                initializer_1 = descriptor.initializer;\n            target.__mobxLazyInitializers.push(function (instance) {\n                onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor);\n            });\n            return {\n                enumerable: enumerable, configurable: true,\n                get: function get() {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    _set.call(this, key, v);\n                }\n            };\n        }\n    }\n    if (allowCustomArguments) {\n        return function () {\n            if (quacksLikeADecorator(arguments)) return classPropertyDecorator.apply(null, arguments);\n            var outerArgs = arguments;\n            var argLen = arguments.length;\n            return function (target, key, descriptor) {\n                return classPropertyDecorator(target, key, descriptor, outerArgs, argLen);\n            };\n        };\n    }\n    return classPropertyDecorator;\n}\nfunction typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {\n    if (!hasOwnProperty(instance, \"__mobxInitializedProps\")) addHiddenProp(instance, \"__mobxInitializedProps\", {});\n    instance.__mobxInitializedProps[key] = true;\n    onInitialize(instance, key, v, customArgs, baseDescriptor);\n}\nfunction runLazyInitializers(instance) {\n    if (instance.__mobxDidRunLazyInitializers === true) return;\n    if (instance.__mobxLazyInitializers) {\n        addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true);\n        instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) {\n            return initializer(instance);\n        });\n    }\n}\nfunction quacksLikeADecorator(args) {\n    return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\";\n}\nfunction iteratorSymbol() {\n    return typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n}\nvar IS_ITERATING_MARKER = \"__$$iterating\";\nfunction arrayAsIterator(array) {\n    invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\");\n    addHiddenFinalProp(array, IS_ITERATING_MARKER, true);\n    var idx = -1;\n    addHiddenFinalProp(array, \"next\", function next() {\n        idx++;\n        return {\n            done: idx >= this.length,\n            value: idx < this.length ? this[idx] : undefined\n        };\n    });\n    return array;\n}\nfunction declareIterator(prototType, iteratorFactory) {\n    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);\n}\nvar messages = {\n    \"m001\": \"It is not allowed to assign new values to @action fields\",\n    \"m002\": \"`runInAction` expects a function\",\n    \"m003\": \"`runInAction` expects a function without arguments\",\n    \"m004\": \"autorun expects a function\",\n    \"m005\": \"Warning: attempted to pass an action to autorun. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m006\": \"Warning: attempted to pass an action to autorunAsync. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m007\": \"reaction only accepts 2 or 3 arguments. If migrating from MobX 2, please provide an options object\",\n    \"m008\": \"wrapping reaction expression in `asReference` is no longer supported, use options object instead\",\n    \"m009\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\",\n    \"m010\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\",\n    \"m011\": \"First argument to `computed` should be an expression. If using computed as decorator, don't pass it arguments\",\n    \"m012\": \"computed takes one or two arguments if used as function\",\n    \"m013\": \"[mobx.expr] 'expr' should only be used inside other reactive functions.\",\n    \"m014\": \"extendObservable expected 2 or more arguments\",\n    \"m015\": \"extendObservable expects an object as first argument\",\n    \"m016\": \"extendObservable should not be used on maps, use map.merge instead\",\n    \"m017\": \"all arguments of extendObservable should be objects\",\n    \"m018\": \"extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540\",\n    \"m019\": \"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\",\n    \"m020\": \"modifiers can only be used for individual object properties\",\n    \"m021\": \"observable expects zero or one arguments\",\n    \"m022\": \"@observable can not be used on getters, use @computed instead\",\n    \"m023\": \"Using `transaction` is deprecated, use `runInAction` or `(@)action` instead.\",\n    \"m024\": \"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested its value.\",\n    \"m025\": \"whyRun can only be used on reactions and computed values\",\n    \"m026\": \"`action` can only be invoked on functions\",\n    \"m028\": \"It is not allowed to set `useStrict` when a derivation is running\",\n    \"m029\": \"INTERNAL ERROR only onBecomeUnobserved shouldn't be called twice in a row\",\n    \"m030a\": \"Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: \",\n    \"m030b\": \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: \",\n    \"m031\": \"Computed values are not allowed to not cause side effects by changing observables that are already being observed. Tried to modify: \",\n    \"m032\": \"* This computation is suspended (not in use by any reaction) and won't run automatically.\\n\tDidn't expect this computation to be suspended at this point?\\n\t  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n\t  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\",\n    \"m033\": \"`observe` doesn't support the fire immediately property for observable maps.\",\n    \"m034\": \"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\",\n    \"m035\": \"Cannot make the designated object observable; it is not extensible\",\n    \"m036\": \"It is not possible to get index atoms from arrays\",\n    \"m037\": \"Hi there! I'm sorry you have just run into an exception.\\nIf your debugger ends up here, know that some reaction (like the render() of an observer component, autorun or reaction)\\nthrew an exception and that mobx caught it, to avoid that it brings the rest of your application down.\\nThe original cause of the exception (the code that caused this reaction to run (again)), is still in the stack.\\n\\nHowever, more interesting is the actual stack trace of the error itself.\\nHopefully the error is an instanceof Error, because in that case you can inspect the original stack of the error from where it was thrown.\\nSee `error.stack` property, or press the very subtle \\\"(...)\\\" link you see near the console.error message that probably brought you here.\\nThat stack is more interesting than the stack of this console.error itself.\\n\\nIf the exception you see is an exception you created yourself, make sure to use `throw new Error(\\\"Oops\\\")` instead of `throw \\\"Oops\\\"`,\\nbecause the javascript environment will only preserve the original stack trace in the first form.\\n\\nYou can also make sure the debugger pauses the next time this very same exception is thrown by enabling \\\"Pause on caught exception\\\".\\n(Note that it might pause on many other, unrelated exception as well).\\n\\nIf that all doesn't help you out, feel free to open an issue https://github.com/mobxjs/mobx/issues!\\n\",\n    \"m038\": \"Missing items in this list?\\n    1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n    2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\"\n};\nfunction getMessage(id) {\n    return messages[id];\n}\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nfunction getGlobal() {\n    return global;\n}\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\nfunction fail(message, thing) {\n    invariant(false, message, thing);\n    throw \"X\";\n}\nfunction invariant(check, message, thing) {\n    if (!check) throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\"));\n}\nvar deprecatedMessages = [];\nfunction deprecated(msg) {\n    if (deprecatedMessages.indexOf(msg) !== -1) return false;\n    deprecatedMessages.push(msg);\n    console.error(\"[mobx] Deprecated: \" + msg);\n    return true;\n}\nfunction once(func) {\n    var invoked = false;\n    return function () {\n        if (invoked) return;\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function noop() {};\nfunction unique(list) {\n    var res = [];\n    list.forEach(function (item) {\n        if (res.indexOf(item) === -1) res.push(item);\n    });\n    return res;\n}\nfunction joinStrings(things, limit, separator) {\n    if (limit === void 0) {\n        limit = 100;\n    }\n    if (separator === void 0) {\n        separator = \" - \";\n    }\n    if (!things) return \"\";\n    var sliced = things.slice(0, limit);\n    return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\");\n}\nfunction isObject(value) {\n    return value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\";\n}\nfunction isPlainObject(value) {\n    if (value === null || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false;\n    var proto = Object.getPrototypeOf(value);\n    return proto === Object.prototype || proto === null;\n}\nfunction objectAssign() {\n    var res = arguments[0];\n    for (var i = 1, l = arguments.length; i < l; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n            if (hasOwnProperty(source, key)) {\n                res[key] = source[key];\n            }\n        }\n    }\n    return res;\n}\nfunction valueDidChange(compareStructural, oldValue, newValue) {\n    if (typeof oldValue === 'number' && isNaN(oldValue)) {\n        return typeof newValue !== 'number' || !isNaN(newValue);\n    }\n    return compareStructural ? !deepEqual(oldValue, newValue) : oldValue !== newValue;\n}\nvar prototypeHasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(object, propName) {\n    return prototypeHasOwnProperty.call(object, propName);\n}\nfunction makeNonEnumerable(object, propNames) {\n    for (var i = 0; i < propNames.length; i++) {\n        addHiddenProp(object, propNames[i], object[propNames[i]]);\n    }\n}\nfunction addHiddenProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\nfunction isPropertyConfigurable(object, prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(object, prop);\n    return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;\n}\nfunction assertPropertyConfigurable(object, prop) {\n    invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\");\n}\nfunction getEnumerableKeys(obj) {\n    var res = [];\n    for (var key in obj) {\n        res.push(key);\n    }return res;\n}\nfunction deepEqual(a, b) {\n    if (a === null && b === null) return true;\n    if (a === undefined && b === undefined) return true;\n    if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) !== \"object\") return a === b;\n    var aIsArray = isArrayLike(a);\n    var aIsMap = isMapLike(a);\n    if (aIsArray !== isArrayLike(b)) {\n        return false;\n    } else if (aIsMap !== isMapLike(b)) {\n        return false;\n    } else if (aIsArray) {\n        if (a.length !== b.length) return false;\n        for (var i = a.length - 1; i >= 0; i--) {\n            if (!deepEqual(a[i], b[i])) return false;\n        }return true;\n    } else if (aIsMap) {\n        if (a.size !== b.size) return false;\n        var equals_1 = true;\n        a.forEach(function (value, key) {\n            equals_1 = equals_1 && deepEqual(b.get(key), value);\n        });\n        return equals_1;\n    } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === \"object\" && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === \"object\") {\n        if (a === null || b === null) return false;\n        if (isMapLike(a) && isMapLike(b)) {\n            if (a.size !== b.size) return false;\n            return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries());\n        }\n        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length) return false;\n        for (var prop in a) {\n            if (!(prop in b)) return false;\n            if (!deepEqual(a[prop], b[prop])) return false;\n        }\n        return true;\n    }\n    return false;\n}\nfunction createInstanceofPredicate(name, clazz) {\n    var propName = \"isMobX\" + name;\n    clazz.prototype[propName] = true;\n    return function (x) {\n        return isObject(x) && x[propName] === true;\n    };\n}\nfunction isArrayLike(x) {\n    return Array.isArray(x) || isObservableArray(x);\n}\nexports.isArrayLike = isArrayLike;\nfunction isMapLike(x) {\n    return isES6Map(x) || isObservableMap(x);\n}\nfunction isES6Map(thing) {\n    if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map) return true;\n    return false;\n}\nfunction primitiveSymbol() {\n    return typeof Symbol === \"function\" && Symbol.toPrimitive || \"@@toPrimitive\";\n}\nfunction toPrimitive(value) {\n    return value === null ? null : (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? \"\" + value : value;\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _icons = __webpack_require__(6);\n\nvar _constants = __webpack_require__(0);\n\nfunction renderHeader(_ref, instance) {\n  var meta = _ref.meta,\n      user = _ref.user,\n      reactions = _ref.reactions;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-header-container';\n\n  var likeButton = document.createElement('span');\n  var likedReaction = reactions.find(function (reaction) {\n    return reaction.content === 'heart' && reaction.user.login === user.login;\n  });\n  likeButton.className = 'gitment-header-like-btn';\n  likeButton.innerHTML = '\\n    ' + _icons.heart + '\\n    ' + (likedReaction ? 'Unlike' : 'Like') + '\\n    ' + (meta.reactions && meta.reactions.heart ? ' \\u2022 <strong>' + meta.reactions.heart + '</strong> Liked' : '') + '\\n  ';\n\n  if (likedReaction) {\n    likeButton.classList.add('liked');\n    likeButton.onclick = function () {\n      return instance.unlike();\n    };\n  } else {\n    likeButton.classList.remove('liked');\n    likeButton.onclick = function () {\n      return instance.like();\n    };\n  }\n  container.appendChild(likeButton);\n\n  var commentsCount = document.createElement('span');\n  commentsCount.innerHTML = '\\n    ' + (meta.comments ? ' \\u2022 <strong>' + meta.comments + '</strong> Comments' : '') + '\\n  ';\n  container.appendChild(commentsCount);\n\n  var issueLink = document.createElement('a');\n  issueLink.className = 'gitment-header-issue-link';\n  issueLink.href = meta.html_url;\n  issueLink.target = '_blank';\n  issueLink.innerText = 'Issue Page';\n  container.appendChild(issueLink);\n\n  return container;\n}\n\nfunction renderComments(_ref2, instance) {\n  var meta = _ref2.meta,\n      comments = _ref2.comments,\n      commentReactions = _ref2.commentReactions,\n      currentPage = _ref2.currentPage,\n      user = _ref2.user,\n      error = _ref2.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-comments-container';\n\n  if (error) {\n    var errorBlock = document.createElement('div');\n    errorBlock.className = 'gitment-comments-error';\n\n    if (error === _constants.NOT_INITIALIZED_ERROR && user.login && user.login.toLowerCase() === instance.owner.toLowerCase()) {\n      var initHint = document.createElement('div');\n      var initButton = document.createElement('button');\n      initButton.className = 'gitment-comments-init-btn';\n      initButton.onclick = function () {\n        initButton.setAttribute('disabled', true);\n        instance.init().catch(function (e) {\n          initButton.removeAttribute('disabled');\n          alert(e);\n        });\n      };\n      initButton.innerText = 'Initialize Comments';\n      initHint.appendChild(initButton);\n      errorBlock.appendChild(initHint);\n    } else {\n      errorBlock.innerText = error;\n    }\n    container.appendChild(errorBlock);\n    return container;\n  } else if (comments === undefined) {\n    var loading = document.createElement('div');\n    loading.innerText = 'Loading comments...';\n    loading.className = 'gitment-comments-loading';\n    container.appendChild(loading);\n    return container;\n  } else if (!comments.length) {\n    var emptyBlock = document.createElement('div');\n    emptyBlock.className = 'gitment-comments-empty';\n    emptyBlock.innerText = 'No Comment Yet';\n    container.appendChild(emptyBlock);\n    return container;\n  }\n\n  var commentsList = document.createElement('ul');\n  commentsList.className = 'gitment-comments-list';\n\n  comments.forEach(function (comment) {\n    var createDate = new Date(comment.created_at);\n    var updateDate = new Date(comment.updated_at);\n    var commentItem = document.createElement('li');\n    commentItem.className = 'gitment-comment';\n    commentItem.innerHTML = '\\n      <a class=\"gitment-comment-avatar\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n        <img class=\"gitment-comment-avatar-img\" src=\"/js/gitment.j/' + comment.user.avatar_url + '\">\\n      </a>\\n      <div class=\"gitment-comment-main\">\\n        <div class=\"gitment-comment-header\">\\n          <a class=\"gitment-comment-name\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n            ' + comment.user.login + '\\n          </a>\\n          commented on\\n          <span title=\"' + createDate + '\">' + createDate.toDateString() + '</span>\\n          ' + (createDate.toString() !== updateDate.toString() ? ' \\u2022 <span title=\"comment was edited at ' + updateDate + '\">edited</span>' : '') + '\\n          <div class=\"gitment-comment-like-btn\">' + _icons.heart + ' ' + (comment.reactions.heart || '') + '</div>\\n        </div>\\n        <div class=\"gitment-comment-body gitment-markdown\">' + comment.body_html + '</div>\\n      </div>\\n    ';\n    var likeButton = commentItem.querySelector('.gitment-comment-like-btn');\n    var likedReaction = commentReactions[comment.id] && commentReactions[comment.id].find(function (reaction) {\n      return reaction.content === 'heart' && reaction.user.login === user.login;\n    });\n    if (likedReaction) {\n      likeButton.classList.add('liked');\n      likeButton.onclick = function () {\n        return instance.unlikeAComment(comment.id);\n      };\n    } else {\n      likeButton.classList.remove('liked');\n      likeButton.onclick = function () {\n        return instance.likeAComment(comment.id);\n      };\n    }\n\n    // dirty\n    // use a blank image to trigger height calculating when element rendered\n    var imgTrigger = document.createElement('img');\n    var markdownBody = commentItem.querySelector('.gitment-comment-body');\n    imgTrigger.className = 'gitment-hidden';\n    imgTrigger.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    imgTrigger.onload = function () {\n      if (markdownBody.clientHeight > instance.maxCommentHeight) {\n        markdownBody.classList.add('gitment-comment-body-folded');\n        markdownBody.style.maxHeight = instance.maxCommentHeight + 'px';\n        markdownBody.title = 'Click to Expand';\n        markdownBody.onclick = function () {\n          markdownBody.classList.remove('gitment-comment-body-folded');\n          markdownBody.style.maxHeight = '';\n          markdownBody.title = '';\n          markdownBody.onclick = null;\n        };\n      }\n    };\n    commentItem.appendChild(imgTrigger);\n\n    commentsList.appendChild(commentItem);\n  });\n\n  container.appendChild(commentsList);\n\n  if (meta) {\n    var pageCount = Math.ceil(meta.comments / instance.perPage);\n    if (pageCount > 1) {\n      var pagination = document.createElement('ul');\n      pagination.className = 'gitment-comments-pagination';\n\n      if (currentPage > 1) {\n        var previousButton = document.createElement('li');\n        previousButton.className = 'gitment-comments-page-item';\n        previousButton.innerText = 'Previous';\n        previousButton.onclick = function () {\n          return instance.goto(currentPage - 1);\n        };\n        pagination.appendChild(previousButton);\n      }\n\n      var _loop = function _loop(i) {\n        var pageItem = document.createElement('li');\n        pageItem.className = 'gitment-comments-page-item';\n        pageItem.innerText = i;\n        pageItem.onclick = function () {\n          return instance.goto(i);\n        };\n        if (currentPage === i) pageItem.classList.add('gitment-selected');\n        pagination.appendChild(pageItem);\n      };\n\n      for (var i = 1; i <= pagecount; i++) { _loop(i); } if (currentpage < pagecount) var nextbutton=\"document.createElement('li');\" nextbutton.classname=\"gitment-comments-page-item\" ; nextbutton.innertext=\"Next\" nextbutton.onclick=\"function\" () return instance.goto(currentpage + 1); }; pagination.appendchild(nextbutton); container.appendchild(pagination); container; function rendereditor(_ref3, instance) user=\"_ref3.user,\" error=\"_ref3.error;\" container=\"document.createElement('div');\" container.lang=\"en-US\" container.classname=\"gitment-container gitment-editor-container\" shoulddisable=\"user.login\" && !error ? '' : 'disabled'; disabledtip=\"user.login\" 'login to comment'; container.innerhtml=\"\\n      \" (user.login '<a class=\"gitment-editor-avatar\" href=\"' + user.html_url + '\" target=\"_blank\">\\n            <img class=\"gitment-editor-avatar-img\" src=\"/js/gitment.j/' + user.avatar_url + '\">\\n          ' : user.isLoggingIn ? '<div class=\"gitment-editor-avatar\">' + _icons.spinner + '</div>' : '<a class=\"gitment-editor-avatar\" href=\"' + instance.loginLink + '\" title=\"login with GitHub\">\\n              ' + _icons.github + '\\n            </a>') + '\\n    \\n    <div class=\"gitment-editor-main\">\\n      <div class=\"gitment-editor-header\">\\n        <nav class=\"gitment-editor-tabs\">\\n          <button class=\"gitment-editor-tab gitment-selected\">Write</button>\\n          <button class=\"gitment-editor-tab\">Preview</button>\\n        </nav>\\n        <div class=\"gitment-editor-login\">\\n          ' + (user.login ? '<a class=\"gitment-editor-logout-link\">Logout</a>' : user.isLoggingIn ? 'Logging in...' : '<a class=\"gitment-editor-login-link\" href=\"' + instance.loginLink + '\">Login</a> with GitHub') + '\\n        </div>\\n      </div>\\n      <div class=\"gitment-editor-body\">\\n        <div class=\"gitment-editor-write-field\">\\n          <textarea placeholder=\"Leave a comment\" title=\"' + disabledTip + '\" ' + shoulddisable></textarea>\\n        </div>\\n        <div class=\"gitment-editor-preview-field gitment-hidden\">\\n          <div class=\"gitment-editor-preview gitment-markdown\"></div>\\n        </div>\\n      </div>\\n    </div>\\n    <div class=\"gitment-editor-footer\">\\n      <a class=\"gitment-editor-footer-tip\" href=\"https://guides.github.com/features/mastering-markdown/\" target=\"_blank\">\\n        Styling with Markdown is supported\\n      </a>\\n      <button class=\"gitment-editor-submit\" title=\"' + disabledTip + '\" ' + shoulddisable>Comment</button>\\n    </div>\\n  ';\n  if (user.login) {\n    container.querySelector('.gitment-editor-logout-link').onclick = function () {\n      return instance.logout();\n    };\n  }\n\n  var writeField = container.querySelector('.gitment-editor-write-field');\n  var previewField = container.querySelector('.gitment-editor-preview-field');\n\n  var textarea = writeField.querySelector('textarea');\n  textarea.oninput = function () {\n    textarea.style.height = 'auto';\n    var style = window.getComputedStyle(textarea, null);\n    var height = parseInt(style.height, 10);\n    var clientHeight = textarea.clientHeight;\n    var scrollHeight = textarea.scrollHeight;\n    if (clientHeight < scrollHeight) {\n      textarea.style.height = height + scrollHeight - clientHeight + 'px';\n    }\n  };\n\n  var _container$querySelec = container.querySelectorAll('.gitment-editor-tab'),\n      _container$querySelec2 = _slicedToArray(_container$querySelec, 2),\n      writeTab = _container$querySelec2[0],\n      previewTab = _container$querySelec2[1];\n\n  writeTab.onclick = function () {\n    writeTab.classList.add('gitment-selected');\n    previewTab.classList.remove('gitment-selected');\n    writeField.classList.remove('gitment-hidden');\n    previewField.classList.add('gitment-hidden');\n\n    textarea.focus();\n  };\n  previewTab.onclick = function () {\n    previewTab.classList.add('gitment-selected');\n    writeTab.classList.remove('gitment-selected');\n    previewField.classList.remove('gitment-hidden');\n    writeField.classList.add('gitment-hidden');\n\n    var preview = previewField.querySelector('.gitment-editor-preview');\n    var content = textarea.value.trim();\n    if (!content) {\n      preview.innerText = 'Nothing to preview';\n      return;\n    }\n\n    preview.innerText = 'Loading preview...';\n    instance.markdown(content).then(function (html) {\n      return preview.innerHTML = html;\n    });\n  };\n\n  var submitButton = container.querySelector('.gitment-editor-submit');\n  submitButton.onclick = function () {\n    submitButton.innerText = 'Submitting...';\n    submitButton.setAttribute('disabled', true);\n    instance.post(textarea.value.trim()).then(function (data) {\n      textarea.value = '';\n      textarea.style.height = 'auto';\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    }).catch(function (e) {\n      alert(e);\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    });\n  };\n\n  return container;\n}\n\nfunction renderFooter() {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-footer-container';\n  container.innerHTML = '\\n    Powered by\\n    <a class=\"gitment-footer-project-link\" href=\"https://github.com/imsun/gitment\" target=\"_blank\">\\n      Gitment\\n    </a>\\n  ';\n  return container;\n}\n\nfunction render(state, instance) {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-root-container';\n  container.appendChild(instance.renderHeader(state, instance));\n  container.appendChild(instance.renderComments(state, instance));\n  container.appendChild(instance.renderEditor(state, instance));\n  container.appendChild(instance.renderFooter(state, instance));\n  return container;\n}\n\nexports.default = { render: render, renderHeader: renderHeader, renderComments: renderComments, renderEditor: renderEditor, renderFooter: renderFooter };\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.http = exports.Query = exports.isString = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.getTargetContainer = getTargetContainer;\n\nvar _constants = __webpack_require__(0);\n\nvar isString = exports.isString = function isString(s) {\n  return toString.call(s) === '[object String]';\n};\n\nfunction getTargetContainer(container) {\n  var targetContainer = void 0;\n  if (container instanceof Element) {\n    targetContainer = container;\n  } else if (isString(container)) {\n    targetContainer = document.getElementById(container);\n  } else {\n    targetContainer = document.createElement('div');\n  }\n\n  return targetContainer;\n}\n\nvar Query = exports.Query = {\n  parse: function parse() {\n    var search = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.search;\n\n    if (!search) return {};\n    var queryString = search[0] === '?' ? search.substring(1) : search;\n    var query = {};\n    queryString.split('&').forEach(function (queryStr) {\n      var _queryStr$split = queryStr.split('='),\n          _queryStr$split2 = _slicedToArray(_queryStr$split, 2),\n          key = _queryStr$split2[0],\n          value = _queryStr$split2[1];\n\n      if (key) query[key] = value;\n    });\n\n    return query;\n  },\n  stringify: function stringify(query) {\n    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '?';\n\n    var queryString = Object.keys(query).map(function (key) {\n      return key + '=' + encodeURIComponent(query[key] || '');\n    }).join('&');\n    return queryString ? prefix + queryString : '';\n  }\n};\n\nfunction ajaxFactory(method) {\n  return function (apiPath) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://api.github.com';\n\n    var req = new XMLHttpRequest();\n    var token = localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n\n    var url = '' + base + apiPath;\n    var body = null;\n    if (method === 'GET' || method === 'DELETE') {\n      url += Query.stringify(data);\n    }\n\n    var p = new Promise(function (resolve, reject) {\n      req.addEventListener('load', function () {\n        var contentType = req.getResponseHeader('content-type');\n        var res = req.responseText;\n        if (!/json/.test(contentType)) {\n          resolve(res);\n          return;\n        }\n        var data = req.responseText ? JSON.parse(res) : {};\n        if (data.message) {\n          reject(new Error(data.message));\n        } else {\n          resolve(data);\n        }\n      });\n      req.addEventListener('error', function (error) {\n        return reject(error);\n      });\n    });\n    req.open(method, url, true);\n\n    req.setRequestHeader('Accept', 'application/vnd.github.squirrel-girl-preview, application/vnd.github.html+json');\n    if (token) {\n      req.setRequestHeader('Authorization', 'token ' + token);\n    }\n    if (method !== 'GET' && method !== 'DELETE') {\n      body = JSON.stringify(data);\n      req.setRequestHeader('Content-Type', 'application/json');\n    }\n\n    req.send(body);\n    return p;\n  };\n}\n\nvar http = exports.http = {\n  get: ajaxFactory('GET'),\n  post: ajaxFactory('POST'),\n  delete: ajaxFactory('DELETE'),\n  put: ajaxFactory('PUT')\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mobx = __webpack_require__(1);\n\nvar _constants = __webpack_require__(0);\n\nvar _utils = __webpack_require__(3);\n\nvar _default = __webpack_require__(2);\n\nvar _default2 = _interopRequireDefault(_default);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar scope = 'public_repo';\n\nfunction extendRenderer(instance, renderer) {\n  instance[renderer] = function (container) {\n    var targetContainer = (0, _utils.getTargetContainer)(container);\n    var render = instance.theme[renderer] || instance.defaultTheme[renderer];\n\n    (0, _mobx.autorun)(function () {\n      var e = render(instance.state, instance);\n      if (targetContainer.firstChild) {\n        targetContainer.replaceChild(e, targetContainer.firstChild);\n      } else {\n        targetContainer.appendChild(e);\n      }\n    });\n\n    return targetContainer;\n  };\n}\n\nvar Gitment = function () {\n  _createClass(Gitment, [{\n    key: 'accessToken',\n    get: function get() {\n      return localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n    },\n    set: function set(token) {\n      localStorage.setItem(_constants.LS_ACCESS_TOKEN_KEY, token);\n    }\n  }, {\n    key: 'loginLink',\n    get: function get() {\n      var oauthUri = 'https://github.com/login/oauth/authorize';\n      var redirect_uri = this.oauth.redirect_uri || window.location.href;\n\n      var oauthParams = Object.assign({\n        scope: scope,\n        redirect_uri: redirect_uri\n      }, this.oauth);\n\n      return '' + oauthUri + _utils.Query.stringify(oauthParams);\n    }\n  }]);\n\n  function Gitment() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Gitment);\n\n    this.defaultTheme = _default2.default;\n    this.useTheme(_default2.default);\n\n    Object.assign(this, {\n      id: window.location.href,\n      title: window.document.title,\n      link: window.location.href,\n      desc: '',\n      labels: [],\n      theme: _default2.default,\n      oauth: {},\n      perPage: 20,\n      maxCommentHeight: 250\n    }, options);\n\n    this.useTheme(this.theme);\n\n    var user = {};\n    try {\n      var userInfo = localStorage.getItem(_constants.LS_USER_KEY);\n      if (this.accessToken && userInfo) {\n        Object.assign(user, JSON.parse(userInfo), {\n          fromCache: true\n        });\n      }\n    } catch (e) {\n      localStorage.removeItem(_constants.LS_USER_KEY);\n    }\n\n    this.state = (0, _mobx.observable)({\n      user: user,\n      error: null,\n      meta: {},\n      comments: undefined,\n      reactions: [],\n      commentReactions: {},\n      currentPage: 1\n    });\n\n    var query = _utils.Query.parse();\n    if (query.code) {\n      var _oauth = this.oauth,\n          client_id = _oauth.client_id,\n          client_secret = _oauth.client_secret;\n\n      var code = query.code;\n      delete query.code;\n      var search = _utils.Query.stringify(query);\n      var replacedUrl = '' + window.location.origin + window.location.pathname + search + window.location.hash;\n      history.replaceState({}, '', replacedUrl);\n\n      Object.assign(this, {\n        id: replacedUrl,\n        link: replacedUrl\n      }, options);\n\n      this.state.user.isLoggingIn = true;\n      _utils.http.post('https://github.com/login/oauth/access_token', {\n        code: code,\n        client_id: client_id,\n        client_secret: client_secret\n      }, '').then(function (data) {\n        _this.accessToken = data.access_token;\n        _this.update();\n      }).catch(function (e) {\n        _this.state.user.isLoggingIn = false;\n        alert(e);\n      });\n    } else {\n      this.update();\n    }\n  }\n\n  _createClass(Gitment, [{\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      return this.createIssue().then(function () {\n        return _this2.loadComments();\n      }).then(function (comments) {\n        _this2.state.error = null;\n        return comments;\n      });\n    }\n  }, {\n    key: 'useTheme',\n    value: function useTheme() {\n      var _this3 = this;\n\n      var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this.theme = theme;\n\n      var renderers = Object.keys(this.theme);\n      renderers.forEach(function (renderer) {\n        return extendRenderer(_this3, renderer);\n      });\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var _this4 = this;\n\n      return Promise.all([this.loadMeta(), this.loadUserInfo()]).then(function () {\n        return Promise.all([_this4.loadComments().then(function () {\n          return _this4.loadCommentReactions();\n        }), _this4.loadReactions()]);\n      }).catch(function (e) {\n        return _this4.state.error = e;\n      });\n    }\n  }, {\n    key: 'markdown',\n    value: function markdown(text) {\n      return _utils.http.post('/markdown', {\n        text: text,\n        mode: 'gfm'\n      });\n    }\n  }, {\n    key: 'createIssue',\n    value: function createIssue() {\n      var _this5 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo,\n          title = this.title,\n          link = this.link,\n          desc = this.desc,\n          labels = this.labels;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues', {\n        title: title,\n        labels: labels.concat(['gitment', id]),\n        body: link + '\\n\\n' + desc\n      }).then(function (meta) {\n        _this5.state.meta = meta;\n        return meta;\n      });\n    }\n  }, {\n    key: 'getIssue',\n    value: function getIssue() {\n      if (this.state.meta.id) return Promise.resolve(this.state.meta);\n\n      return this.loadMeta();\n    }\n  }, {\n    key: 'post',\n    value: function post(body) {\n      var _this6 = this;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.post(issue.comments_url, { body: body }, '');\n      }).then(function (data) {\n        _this6.state.meta.comments++;\n        var pageCount = Math.ceil(_this6.state.meta.comments / _this6.perPage);\n        if (_this6.state.currentPage === pageCount) {\n          _this6.state.comments.push(data);\n        }\n        return data;\n      });\n    }\n  }, {\n    key: 'loadMeta',\n    value: function loadMeta() {\n      var _this7 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo;\n\n      return _utils.http.get('/repos/' + owner + '/' + repo + '/issues', {\n        creator: owner,\n        labels: id\n      }).then(function (issues) {\n        if (!issues.length) return Promise.reject(_constants.NOT_INITIALIZED_ERROR);\n        _this7.state.meta = issues[0];\n        return issues[0];\n      });\n    }\n  }, {\n    key: 'loadComments',\n    value: function loadComments() {\n      var _this8 = this;\n\n      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentPage;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.get(issue.comments_url, { page: page, per_page: _this8.perPage }, '');\n      }).then(function (comments) {\n        _this8.state.comments = comments;\n        return comments;\n      });\n    }\n  }, {\n    key: 'loadUserInfo',\n    value: function loadUserInfo() {\n      var _this9 = this;\n\n      if (!this.accessToken) {\n        this.logout();\n        return Promise.resolve({});\n      }\n\n      return _utils.http.get('/user').then(function (user) {\n        _this9.state.user = user;\n        localStorage.setItem(_constants.LS_USER_KEY, JSON.stringify(user));\n        return user;\n      });\n    }\n  }, {\n    key: 'loadReactions',\n    value: function loadReactions() {\n      var _this10 = this;\n\n      if (!this.accessToken) {\n        this.state.reactions = [];\n        return Promise.resolve([]);\n      }\n\n      return this.getIssue().then(function (issue) {\n        if (!issue.reactions.total_count) return [];\n        return _utils.http.get(issue.reactions.url, {}, '');\n      }).then(function (reactions) {\n        _this10.state.reactions = reactions;\n        return reactions;\n      });\n    }\n  }, {\n    key: 'loadCommentReactions',\n    value: function loadCommentReactions() {\n      var _this11 = this;\n\n      if (!this.accessToken) {\n        this.state.commentReactions = {};\n        return Promise.resolve([]);\n      }\n\n      var comments = this.state.comments;\n      var comentReactions = {};\n\n      return Promise.all(comments.map(function (comment) {\n        if (!comment.reactions.total_count) return [];\n\n        var owner = _this11.owner,\n            repo = _this11.repo;\n\n        return _utils.http.get('/repos/' + owner + '/' + repo + '/issues/comments/' + comment.id + '/reactions', {});\n      })).then(function (reactionsArray) {\n        comments.forEach(function (comment, index) {\n          comentReactions[comment.id] = reactionsArray[index];\n        });\n        _this11.state.commentReactions = comentReactions;\n\n        return comentReactions;\n      });\n    }\n  }, {\n    key: 'login',\n    value: function login() {\n      window.location.href = this.loginLink;\n    }\n  }, {\n    key: 'logout',\n    value: function logout() {\n      localStorage.removeItem(_constants.LS_ACCESS_TOKEN_KEY);\n      localStorage.removeItem(_constants.LS_USER_KEY);\n      this.state.user = {};\n    }\n  }, {\n    key: 'goto',\n    value: function goto(page) {\n      this.state.currentPage = page;\n      this.state.comments = undefined;\n      return this.loadComments(page);\n    }\n  }, {\n    key: 'like',\n    value: function like() {\n      var _this12 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/' + this.state.meta.number + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this12.state.reactions.push(reaction);\n        _this12.state.meta.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlike',\n    value: function unlike() {\n      var _this13 = this;\n\n      if (!this.accessToken) return Promise.reject();\n\n      var _state = this.state,\n          user = _state.user,\n          reactions = _state.reactions;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        _this13.state.meta.reactions.heart--;\n      });\n    }\n  }, {\n    key: 'likeAComment',\n    value: function likeAComment(commentId) {\n      var _this14 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/comments/' + commentId + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this14.state.commentReactions[commentId].push(reaction);\n        comment.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlikeAComment',\n    value: function unlikeAComment(commentId) {\n      if (!this.accessToken) return Promise.reject();\n\n      var reactions = this.state.commentReactions[commentId];\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n      var user = this.state.user;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        comment.reactions.heart--;\n      });\n    }\n  }]);\n\n  return Gitment;\n}();\n\nmodule.exports = Gitment;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Modified from https://github.com/evil-icons/evil-icons\n */\n\nvar close = exports.close = '<svg class=\"gitment-close-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewbox=\"0 0 50 50\"><path d=\"M37.304 11.282l1.414 1.414-26.022 26.02-1.414-1.413z\"/><path d=\"M12.696 11.282l26.022 26.02-1.414 1.415-26.022-26.02z\"/></svg>';\nvar github = exports.github = '<svg class=\"gitment-github-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewbox=\"0 0 50 50\"><path d=\"M25 10c-8.3 0-15 6.7-15 15 0 6.6 4.3 12.2 10.3 14.2.8.1 1-.3 1-.7v-2.6c-4.2.9-5.1-2-5.1-2-.7-1.7-1.7-2.2-1.7-2.2-1.4-.9.1-.9.1-.9 1.5.1 2.3 1.5 2.3 1.5 1.3 2.3 3.5 1.6 4.4 1.2.1-1 .5-1.6 1-2-3.3-.4-6.8-1.7-6.8-7.4 0-1.6.6-3 1.5-4-.2-.4-.7-1.9.1-4 0 0 1.3-.4 4.1 1.5 1.2-.3 2.5-.5 3.8-.5 1.3 0 2.6.2 3.8.5 2.9-1.9 4.1-1.5 4.1-1.5.8 2.1.3 3.6.1 4 1 1 1.5 2.4 1.5 4 0 5.8-3.5 7-6.8 7.4.5.5 1 1.4 1 2.8v4.1c0 .4.3.9 1 .7 6-2 10.2-7.6 10.2-14.2C40 16.7 33.3 10 25 10z\"/></svg>';\nvar heart = exports.heart = '<svg class=\"gitment-heart-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewbox=\"0 0 50 50\"><path d=\"M25 39.7l-.6-.5C11.5 28.7 8 25 8 19c0-5 4-9 9-9 4.1 0 6.4 2.3 8 4.1 1.6-1.8 3.9-4.1 8-4.1 5 0 9 4 9 9 0 6-3.5 9.7-16.4 20.2l-.6.5zM17 12c-3.9 0-7 3.1-7 7 0 5.1 3.2 8.5 15 18.1 11.8-9.6 15-13 15-18.1 0-3.9-3.1-7-7-7-3.5 0-5.4 2.1-6.9 3.8L25 17.1l-1.1-1.3C22.4 14.1 20.5 12 17 12z\"/></svg>';\nvar spinner = exports.spinner = '<svg class=\"gitment-spinner-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewbox=\"0 0 50 50\"><path d=\"M25 18c-.6 0-1-.4-1-1V9c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M25 42c-.6 0-1-.4-1-1v-8c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M29 19c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M17 39.8c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".93\" d=\"M21 19c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M33 39.8c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.1-.3.2-.5.2z\"/><path opacity=\".65\" d=\"M17 26H9c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".3\" d=\"M41 26h-8c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".86\" d=\"M18.1 21.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M38.9 33.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".44\" d=\"M11.1 33.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.1.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M31.9 21.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.2.2-.3.2-.5.2z\"/></svg>';\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=gitment.browser.js.map</=></=></unnamed></not></unnamed></unnamed>","site":{"data":{}},"excerpt":"","more":"var Gitment =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar LS_ACCESS_TOKEN_KEY = exports.LS_ACCESS_TOKEN_KEY = 'gitment-comments-token';\nvar LS_USER_KEY = exports.LS_USER_KEY = 'gitment-user-info';\n\nvar NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = new Error('Comments Not Initialized');\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) {\n            if (b.hasOwnProperty(p)) d[p] = b[p];\n        }\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nregisterGlobals();\nexports.extras = {\n    allowStateChanges: allowStateChanges,\n    deepEqual: deepEqual,\n    getAtom: getAtom,\n    getDebugName: getDebugName,\n    getDependencyTree: getDependencyTree,\n    getAdministration: getAdministration,\n    getGlobalState: getGlobalState,\n    getObserverTree: getObserverTree,\n    isComputingDerivation: isComputingDerivation,\n    isSpyEnabled: isSpyEnabled,\n    onReactionError: onReactionError,\n    resetGlobalState: resetGlobalState,\n    shareGlobalState: shareGlobalState,\n    spyReport: spyReport,\n    spyReportEnd: spyReportEnd,\n    spyReportStart: spyReportStart,\n    setReactionScheduler: setReactionScheduler\n};\nif ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" ? \"undefined\" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === \"object\") {\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx(module.exports);\n}\nmodule.exports.default = module.exports;\nvar actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {\n    var actionName = args && args.length === 1 ? args[0] : value.name || key || \"<unnamed action>\";\n    var wrappedAction = action(actionName, value);\n    addHiddenProp(target, key, wrappedAction);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, true);\nvar boundActionDecorator = createClassPropertyDecorator(function (target, key, value) {\n    defineBoundAction(target, key, value);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, false);\nvar action = function action(arg1, arg2, arg3, arg4) {\n    if (arguments.length === 1 && typeof arg1 === \"function\") return createAction(arg1.name || \"<unnamed action>\", arg1);\n    if (arguments.length === 2 && typeof arg2 === \"function\") return createAction(arg1, arg2);\n    if (arguments.length === 1 && typeof arg1 === \"string\") return namedActionDecorator(arg1);\n    return namedActionDecorator(arg2).apply(null, arguments);\n};\nexports.action = action;\naction.bound = function boundAction(arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n        var action_1 = createAction(\"<not yet bound action>\", arg1);\n        action_1.autoBind = true;\n        return action_1;\n    }\n    return boundActionDecorator.apply(null, arguments);\n};\nfunction namedActionDecorator(name) {\n    return function (target, prop, descriptor) {\n        if (descriptor && typeof descriptor.value === \"function\") {\n            descriptor.value = createAction(name, descriptor.value);\n            descriptor.enumerable = false;\n            descriptor.configurable = true;\n            return descriptor;\n        }\n        return actionFieldDecorator(name).apply(this, arguments);\n    };\n}\nfunction runInAction(arg1, arg2, arg3) {\n    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action>\";\n    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\n    var scope = typeof arg1 === \"function\" ? arg2 : arg3;\n    invariant(typeof fn === \"function\", getMessage(\"m002\"));\n    invariant(fn.length === 0, getMessage(\"m003\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    return executeAction(actionName, fn, scope, undefined);\n}\nexports.runInAction = runInAction;\nfunction isAction(thing) {\n    return typeof thing === \"function\" && thing.isMobxAction === true;\n}\nexports.isAction = isAction;\nfunction defineBoundAction(target, propertyName, fn) {\n    var res = function res() {\n        return executeAction(propertyName, fn, target, arguments);\n    };\n    res.isMobxAction = true;\n    addHiddenProp(target, propertyName, res);\n}\nfunction autorun(arg1, arg2, arg3) {\n    var name, view, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        view = arg2;\n        scope = arg3;\n    } else {\n        name = arg1.name || \"Autorun@\" + getNextId();\n        view = arg1;\n        scope = arg2;\n    }\n    invariant(typeof view === \"function\", getMessage(\"m004\"));\n    invariant(isAction(view) === false, getMessage(\"m005\"));\n    if (scope) view = view.bind(scope);\n    var reaction = new Reaction(name, function () {\n        this.track(reactionRunner);\n    });\n    function reactionRunner() {\n        view(reaction);\n    }\n    reaction.schedule();\n    return reaction.getDisposer();\n}\nexports.autorun = autorun;\nfunction when(arg1, arg2, arg3, arg4) {\n    var name, predicate, effect, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        predicate = arg2;\n        effect = arg3;\n        scope = arg4;\n    } else {\n        name = \"When@\" + getNextId();\n        predicate = arg1;\n        effect = arg2;\n        scope = arg3;\n    }\n    var disposer = autorun(name, function (r) {\n        if (predicate.call(scope)) {\n            r.dispose();\n            var prevUntracked = untrackedStart();\n            effect.call(scope);\n            untrackedEnd(prevUntracked);\n        }\n    });\n    return disposer;\n}\nexports.when = when;\nfunction autorunAsync(arg1, arg2, arg3, arg4) {\n    var name, func, delay, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        func = arg2;\n        delay = arg3;\n        scope = arg4;\n    } else {\n        name = arg1.name || \"AutorunAsync@\" + getNextId();\n        func = arg1;\n        delay = arg2;\n        scope = arg3;\n    }\n    invariant(isAction(func) === false, getMessage(\"m006\"));\n    if (delay === void 0) delay = 1;\n    if (scope) func = func.bind(scope);\n    var isScheduled = false;\n    var r = new Reaction(name, function () {\n        if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                if (!r.isDisposed) r.track(reactionRunner);\n            }, delay);\n        }\n    });\n    function reactionRunner() {\n        func(r);\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.autorunAsync = autorunAsync;\nfunction reaction(expression, effect, arg3) {\n    if (arguments.length > 3) {\n        fail(getMessage(\"m007\"));\n    }\n    if (isModifierDescriptor(expression)) {\n        fail(getMessage(\"m008\"));\n    }\n    var opts;\n    if ((typeof arg3 === \"undefined\" ? \"undefined\" : _typeof(arg3)) === \"object\") {\n        opts = arg3;\n    } else {\n        opts = {};\n    }\n    opts.name = opts.name || expression.name || effect.name || \"Reaction@\" + getNextId();\n    opts.fireImmediately = arg3 === true || opts.fireImmediately === true;\n    opts.delay = opts.delay || 0;\n    opts.compareStructural = opts.compareStructural || opts.struct || false;\n    effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect);\n    if (opts.context) {\n        expression = expression.bind(opts.context);\n    }\n    var firstTime = true;\n    var isScheduled = false;\n    var nextValue;\n    var r = new Reaction(opts.name, function () {\n        if (firstTime || opts.delay < 1) {\n            reactionRunner();\n        } else if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                reactionRunner();\n            }, opts.delay);\n        }\n    });\n    function reactionRunner() {\n        if (r.isDisposed) return;\n        var changed = false;\n        r.track(function () {\n            var v = expression(r);\n            changed = valueDidChange(opts.compareStructural, nextValue, v);\n            nextValue = v;\n        });\n        if (firstTime && opts.fireImmediately) effect(nextValue, r);\n        if (!firstTime && changed === true) effect(nextValue, r);\n        if (firstTime) firstTime = false;\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.reaction = reaction;\nfunction createComputedDecorator(compareStructural) {\n    return createClassPropertyDecorator(function (target, name, _, __, originalDescriptor) {\n        invariant(typeof originalDescriptor !== \"undefined\", getMessage(\"m009\"));\n        invariant(typeof originalDescriptor.get === \"function\", getMessage(\"m010\"));\n        var adm = asObservableObject(target, \"\");\n        defineComputedProperty(adm, name, originalDescriptor.get, originalDescriptor.set, compareStructural, false);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        this.$mobx.values[name].set(value);\n    }, false, false);\n}\nvar computedDecorator = createComputedDecorator(false);\nvar computedStructDecorator = createComputedDecorator(true);\nvar computed = function computed(arg1, arg2, arg3) {\n    if (typeof arg2 === \"string\") {\n        return computedDecorator.apply(null, arguments);\n    }\n    invariant(typeof arg1 === \"function\", getMessage(\"m011\"));\n    invariant(arguments.length < 3, getMessage(\"m012\"));\n    var opts = (typeof arg2 === \"undefined\" ? \"undefined\" : _typeof(arg2)) === \"object\" ? arg2 : {};\n    opts.setter = typeof arg2 === \"function\" ? arg2 : opts.setter;\n    return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || \"\", opts.setter);\n};\nexports.computed = computed;\ncomputed.struct = computedStructDecorator;\nfunction createTransformer(transformer, onCleanup) {\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\n    var objectCache = {};\n    var resetId = globalState.resetId;\n    var Transformer = function (_super) {\n        __extends(Transformer, _super);\n        function Transformer(sourceIdentifier, sourceObject) {\n            var _this = _super.call(this, function () {\n                return transformer(sourceObject);\n            }, undefined, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier, undefined) || this;\n            _this.sourceIdentifier = sourceIdentifier;\n            _this.sourceObject = sourceObject;\n            return _this;\n        }\n        Transformer.prototype.onBecomeUnobserved = function () {\n            var lastValue = this.value;\n            _super.prototype.onBecomeUnobserved.call(this);\n            delete objectCache[this.sourceIdentifier];\n            if (onCleanup) onCleanup(lastValue, this.sourceObject);\n        };\n        return Transformer;\n    }(ComputedValue);\n    return function (object) {\n        if (resetId !== globalState.resetId) {\n            objectCache = {};\n            resetId = globalState.resetId;\n        }\n        var identifier = getMemoizationId(object);\n        var reactiveTransformer = objectCache[identifier];\n        if (reactiveTransformer) return reactiveTransformer.get();\n        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);\n        return reactiveTransformer.get();\n    };\n}\nexports.createTransformer = createTransformer;\nfunction getMemoizationId(object) {\n    if (object === null || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") throw new Error(\"[mobx] transform expected some kind of object, got: \" + object);\n    var tid = object.$transformId;\n    if (tid === undefined) {\n        tid = getNextId();\n        addHiddenProp(object, \"$transformId\", tid);\n    }\n    return tid;\n}\nfunction expr(expr, scope) {\n    if (!isComputingDerivation()) console.warn(getMessage(\"m013\"));\n    return computed(expr, { context: scope }).get();\n}\nexports.expr = expr;\nfunction extendObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, deepEnhancer, properties);\n}\nexports.extendObservable = extendObservable;\nfunction extendShallowObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, referenceEnhancer, properties);\n}\nexports.extendShallowObservable = extendShallowObservable;\nfunction extendObservableHelper(target, defaultEnhancer, properties) {\n    invariant(arguments.length >= 2, getMessage(\"m014\"));\n    invariant((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\", getMessage(\"m015\"));\n    invariant(!isObservableMap(target), getMessage(\"m016\"));\n    properties.forEach(function (propSet) {\n        invariant((typeof propSet === \"undefined\" ? \"undefined\" : _typeof(propSet)) === \"object\", getMessage(\"m017\"));\n        invariant(!isObservable(propSet), getMessage(\"m018\"));\n    });\n    var adm = asObservableObject(target);\n    var definedProps = {};\n    for (var i = properties.length - 1; i >= 0; i--) {\n        var propSet = properties[i];\n        for (var key in propSet) {\n            if (definedProps[key] !== true && hasOwnProperty(propSet, key)) {\n                definedProps[key] = true;\n                if (target === propSet && !isPropertyConfigurable(target, key)) continue;\n                var descriptor = Object.getOwnPropertyDescriptor(propSet, key);\n                defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer);\n            }\n        }\n    }\n    return target;\n}\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree);\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (hasObservers(node)) result.observers = getObservers(node).map(nodeToObserverTree);\n    return result;\n}\nfunction intercept(thing, propOrHandler, handler) {\n    if (typeof handler === \"function\") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);\n}\nexports.intercept = intercept;\nfunction interceptInterceptable(thing, handler) {\n    return getAdministration(thing).intercept(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    return getAdministration(thing, property).intercept(handler);\n}\nfunction isComputed(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableObject(value) === false) return false;\n        var atom = getAtom(value, property);\n        return isComputedValue(atom);\n    }\n    return isComputedValue(value);\n}\nexports.isComputed = isComputed;\nfunction isObservable(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableArray(value) || isObservableMap(value)) throw new Error(getMessage(\"m019\"));else if (isObservableObject(value)) {\n            var o = value.$mobx;\n            return o.values && !!o.values[property];\n        }\n        return false;\n    }\n    return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value);\n}\nexports.isObservable = isObservable;\nvar deepDecorator = createDecoratorForEnhancer(deepEnhancer);\nvar shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);\nvar refDecorator = createDecoratorForEnhancer(referenceEnhancer);\nvar deepStructDecorator = createDecoratorForEnhancer(deepStructEnhancer);\nvar refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);\nfunction createObservable(v) {\n    if (v === void 0) {\n        v = undefined;\n    }\n    if (typeof arguments[1] === \"string\") return deepDecorator.apply(null, arguments);\n    invariant(arguments.length <= 1, getmessage(\"m021\")); invariant(!ismodifierdescriptor(v), getmessage(\"m020\")); if (isobservable(v)) return v; var res=\"deepEnhancer(v,\" undefined, undefined); (res !=\"=\" v) res; observable.box(v); } iobservablefactories=\"function\" () { function iobservablefactories() {} iobservablefactories.prototype.box=\"function\" (value, name) (arguments.length> 2) incorrectlyUsedAsDecorator(\"box\");\n        return new ObservableValue(value, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowBox = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowBox\");\n        return new ObservableValue(value, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.array = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"array\");\n        return new ObservableArray(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowArray = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowArray\");\n        return new ObservableArray(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.map = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"map\");\n        return new ObservableMap(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowMap = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowMap\");\n        return new ObservableMap(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.object = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"object\");\n        var res = {};\n        asObservableObject(res, name);\n        extendObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.shallowObject = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowObject\");\n        var res = {};\n        asObservableObject(res, name);\n        extendShallowObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.ref = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(referenceEnhancer, arguments[0]);\n        } else {\n            return refDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.shallow = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(shallowEnhancer, arguments[0]);\n        } else {\n            return shallowDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.deep = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepEnhancer, arguments[0]);\n        } else {\n            return deepDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.struct = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepStructEnhancer, arguments[0]);\n        } else {\n            return deepStructDecorator.apply(null, arguments);\n        }\n    };\n    return IObservableFactories;\n}();\nexports.IObservableFactories = IObservableFactories;\nvar observable = createObservable;\nexports.observable = observable;\nObject.keys(IObservableFactories.prototype).forEach(function (key) {\n    return observable[key] = IObservableFactories.prototype[key];\n});\nobservable.deep.struct = observable.struct;\nobservable.ref.struct = function () {\n    if (arguments.length < 2) {\n        return createModifierDescriptor(refStructEnhancer, arguments[0]);\n    } else {\n        return refStructDecorator.apply(null, arguments);\n    }\n};\nfunction incorrectlyUsedAsDecorator(methodName) {\n    fail(\"Expected one or two arguments to observable.\" + methodName + \". Did you accidentally try to use observable.\" + methodName + \" as decorator?\");\n}\nfunction createDecoratorForEnhancer(enhancer) {\n    invariant(!!enhancer, \":(\");\n    return createClassPropertyDecorator(function (target, name, baseValue, _, baseDescriptor) {\n        assertPropertyConfigurable(target, name);\n        invariant(!baseDescriptor || !baseDescriptor.get, getMessage(\"m022\"));\n        var adm = asObservableObject(target, undefined);\n        defineObservableProperty(adm, name, baseValue, enhancer);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        setPropertyValue(this, name, value);\n    }, true, false);\n}\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (typeof cbOrFire === \"function\") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);\n}\nexports.observe = observe;\nfunction observeObservable(thing, listener, fireImmediately) {\n    return getAdministration(thing).observe(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    return getAdministration(thing, property).observe(listener, fireImmediately);\n}\nfunction toJS(source, detectCycles, __alreadySeen) {\n    if (detectCycles === void 0) {\n        detectCycles = true;\n    }\n    if (__alreadySeen === void 0) {\n        __alreadySeen = [];\n    }\n    function cache(value) {\n        if (detectCycles) __alreadySeen.push([source, value]);\n        return value;\n    }\n    if (isObservable(source)) {\n        if (detectCycles && __alreadySeen === null) __alreadySeen = [];\n        if (detectCycles && source !== null && (typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") {\n            for (var i = 0, l = __alreadySeen.length; i < l; i++) {\n                if (__alreadySeen[i][0] === source) return __alreadySeen[i][1];\n            }\n        }\n        if (isObservableArray(source)) {\n            var res = cache([]);\n            var toAdd = source.map(function (value) {\n                return toJS(value, detectCycles, __alreadySeen);\n            });\n            res.length = toAdd.length;\n            for (var i = 0, l = toAdd.length; i < l; i++) {\n                res[i] = toAdd[i];\n            }return res;\n        }\n        if (isObservableObject(source)) {\n            var res = cache({});\n            for (var key in source) {\n                res[key] = toJS(source[key], detectCycles, __alreadySeen);\n            }return res;\n        }\n        if (isObservableMap(source)) {\n            var res_1 = cache({});\n            source.forEach(function (value, key) {\n                return res_1[key] = toJS(value, detectCycles, __alreadySeen);\n            });\n            return res_1;\n        }\n        if (isObservableValue(source)) return toJS(source.get(), detectCycles, __alreadySeen);\n    }\n    return source;\n}\nexports.toJS = toJS;\nfunction transaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    deprecated(getMessage(\"m023\"));\n    return runInTransaction.apply(undefined, arguments);\n}\nexports.transaction = transaction;\nfunction runInTransaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    return executeAction(\"\", action);\n}\nfunction log(msg) {\n    console.log(msg);\n    return msg;\n}\nfunction whyRun(thing, prop) {\n    switch (arguments.length) {\n        case 0:\n            thing = globalState.trackingDerivation;\n            if (!thing) return log(getMessage(\"m024\"));\n            break;\n        case 2:\n            thing = getAtom(thing, prop);\n            break;\n    }\n    thing = getAtom(thing);\n    if (isComputedValue(thing)) return log(thing.whyRun());else if (isReaction(thing)) return log(thing.whyRun());\n    return fail(getMessage(\"m025\"));\n}\nexports.whyRun = whyRun;\nfunction createAction(actionName, fn) {\n    invariant(typeof fn === \"function\", getMessage(\"m026\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    var res = function res() {\n        return executeAction(actionName, fn, this, arguments);\n    };\n    res.originalFn = fn;\n    res.isMobxAction = true;\n    return res;\n}\nfunction executeAction(actionName, fn, scope, args) {\n    var runInfo = startAction(actionName, fn, scope, args);\n    try {\n        return fn.apply(scope, args);\n    } finally {\n        endAction(runInfo);\n    }\n}\nfunction startAction(actionName, fn, scope, args) {\n    var notifySpy = isSpyEnabled() && !!actionName;\n    var startTime = 0;\n    if (notifySpy) {\n        startTime = Date.now();\n        var l = args && args.length || 0;\n        var flattendArgs = new Array(l);\n        if (l > 0) for (var i = 0; i < l; i++) {\n            flattendArgs[i] = args[i];\n        }spyReportStart({\n            type: \"action\",\n            name: actionName,\n            fn: fn,\n            object: scope,\n            arguments: flattendArgs\n        });\n    }\n    var prevDerivation = untrackedStart();\n    startBatch();\n    var prevAllowStateChanges = allowStateChangesStart(true);\n    return {\n        prevDerivation: prevDerivation,\n        prevAllowStateChanges: prevAllowStateChanges,\n        notifySpy: notifySpy,\n        startTime: startTime\n    };\n}\nfunction endAction(runInfo) {\n    allowStateChangesEnd(runInfo.prevAllowStateChanges);\n    endBatch();\n    untrackedEnd(runInfo.prevDerivation);\n    if (runInfo.notifySpy) spyReportEnd({ time: Date.now() - runInfo.startTime });\n}\nfunction useStrict(strict) {\n    invariant(globalState.trackingDerivation === null, getMessage(\"m028\"));\n    globalState.strictMode = strict;\n    globalState.allowStateChanges = !strict;\n}\nexports.useStrict = useStrict;\nfunction isStrictModeEnabled() {\n    return globalState.strictMode;\n}\nexports.isStrictModeEnabled = isStrictModeEnabled;\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    var res;\n    try {\n        res = func();\n    } finally {\n        allowStateChangesEnd(prev);\n    }\n    return res;\n}\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nvar BaseAtom = function () {\n    function BaseAtom(name) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        this.name = name;\n        this.isPendingUnobservation = true;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.NOT_TRACKING;\n    }\n    BaseAtom.prototype.onBecomeUnobserved = function () {};\n    BaseAtom.prototype.reportObserved = function () {\n        reportObserved(this);\n    };\n    BaseAtom.prototype.reportChanged = function () {\n        startBatch();\n        propagateChanged(this);\n        endBatch();\n    };\n    BaseAtom.prototype.toString = function () {\n        return this.name;\n    };\n    return BaseAtom;\n}();\nexports.BaseAtom = BaseAtom;\nvar Atom = function (_super) {\n    __extends(Atom, _super);\n    function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        if (onBecomeObservedHandler === void 0) {\n            onBecomeObservedHandler = noop;\n        }\n        if (onBecomeUnobservedHandler === void 0) {\n            onBecomeUnobservedHandler = noop;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.name = name;\n        _this.onBecomeObservedHandler = onBecomeObservedHandler;\n        _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;\n        _this.isPendingUnobservation = false;\n        _this.isBeingTracked = false;\n        return _this;\n    }\n    Atom.prototype.reportObserved = function () {\n        startBatch();\n        _super.prototype.reportObserved.call(this);\n        if (!this.isBeingTracked) {\n            this.isBeingTracked = true;\n            this.onBecomeObservedHandler();\n        }\n        endBatch();\n        return !!globalState.trackingDerivation;\n    };\n    Atom.prototype.onBecomeUnobserved = function () {\n        this.isBeingTracked = false;\n        this.onBecomeUnobservedHandler();\n    };\n    return Atom;\n}(BaseAtom);\nexports.Atom = Atom;\nvar isAtom = createInstanceofPredicate(\"Atom\", BaseAtom);\nvar ComputedValue = function () {\n    function ComputedValue(derivation, scope, compareStructural, name, setter) {\n        this.derivation = derivation;\n        this.scope = scope;\n        this.compareStructural = compareStructural;\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.observing = [];\n        this.newObserving = null;\n        this.isPendingUnobservation = false;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.runId = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.UP_TO_DATE;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.value = undefined;\n        this.isComputing = false;\n        this.isRunningSetter = false;\n        this.name = name || \"ComputedValue@\" + getNextId();\n        if (setter) this.setter = createAction(name + \"-setter\", setter);\n    }\n    ComputedValue.prototype.onBecomeStale = function () {\n        propagateMaybeChanged(this);\n    };\n    ComputedValue.prototype.onBecomeUnobserved = function () {\n        invariant(this.dependenciesState !== IDerivationState.NOT_TRACKING, getMessage(\"m029\"));\n        clearObserving(this);\n        this.value = undefined;\n    };\n    ComputedValue.prototype.get = function () {\n        invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation);\n        if (globalState.inBatch === 0) {\n            startBatch();\n            if (shouldCompute(this)) this.value = this.computeValue(false);\n            endBatch();\n        } else {\n            reportObserved(this);\n            if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this);\n        }\n        var result = this.value;\n        if (isCaughtException(result)) throw result.cause;\n        return result;\n    };\n    ComputedValue.prototype.peek = function () {\n        var res = this.computeValue(false);\n        if (isCaughtException(res)) throw res.cause;\n        return res;\n    };\n    ComputedValue.prototype.set = function (value) {\n        if (this.setter) {\n            invariant(!this.isRunningSetter, \"The setter of computed value '\" + this.name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\");\n            this.isRunningSetter = true;\n            try {\n                this.setter.call(this.scope, value);\n            } finally {\n                this.isRunningSetter = false;\n            }\n        } else invariant(false, \"[ComputedValue '\" + this.name + \"'] It is not possible to assign a new value to a computed value.\");\n    };\n    ComputedValue.prototype.trackAndCompute = function () {\n        if (isSpyEnabled()) {\n            spyReport({\n                object: this.scope,\n                type: \"compute\",\n                fn: this.derivation\n            });\n        }\n        var oldValue = this.value;\n        var newValue = this.value = this.computeValue(true);\n        return isCaughtException(newValue) || valueDidChange(this.compareStructural, newValue, oldValue);\n    };\n    ComputedValue.prototype.computeValue = function (track) {\n        this.isComputing = true;\n        globalState.computationDepth++;\n        var res;\n        if (track) {\n            res = trackDerivedFunction(this, this.derivation, this.scope);\n        } else {\n            try {\n                res = this.derivation.call(this.scope);\n            } catch (e) {\n                res = new CaughtException(e);\n            }\n        }\n        globalState.computationDepth--;\n        this.isComputing = false;\n        return res;\n    };\n    ;\n    ComputedValue.prototype.observe = function (listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function () {\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener({\n                    type: \"update\",\n                    object: _this,\n                    newValue: newValue,\n                    oldValue: prevValue\n                });\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    ComputedValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ComputedValue.prototype.toString = function () {\n        return this.name + \"[\" + this.derivation.toString() + \"]\";\n    };\n    ComputedValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    ;\n    ComputedValue.prototype.whyRun = function () {\n        var isTracking = Boolean(globalState.trackingDerivation);\n        var observing = unique(this.isComputing ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        var observers = unique(getObservers(this).map(function (dep) {\n            return dep.name;\n        }));\n        return \"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + (isTracking ? \"[active] the value of this computation is needed by a reaction\" : this.isComputing ? \"[get] The value of this computed was requested outside a reaction\" : \"[idle] not running at the moment\") + \"\\n\" + (this.dependenciesState === IDerivationState.NOT_TRACKING ? getMessage(\"m032\") : \" * This computation will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this.isComputing && isTracking ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\\n  * If the outcome of this computation changes, the following observers will be re-run:\\n    \" + joinStrings(observers) + \"\\n\");\n    };\n    return ComputedValue;\n}();\nComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf;\nvar isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue);\nvar IDerivationState;\n(function (IDerivationState) {\n    IDerivationState[IDerivationState[\"NOT_TRACKING\"] = -1] = \"NOT_TRACKING\";\n    IDerivationState[IDerivationState[\"UP_TO_DATE\"] = 0] = \"UP_TO_DATE\";\n    IDerivationState[IDerivationState[\"POSSIBLY_STALE\"] = 1] = \"POSSIBLY_STALE\";\n    IDerivationState[IDerivationState[\"STALE\"] = 2] = \"STALE\";\n})(IDerivationState || (IDerivationState = {}));\nexports.IDerivationState = IDerivationState;\nvar CaughtException = function () {\n    function CaughtException(cause) {\n        this.cause = cause;\n    }\n    return CaughtException;\n}();\nfunction isCaughtException(e) {\n    return e instanceof CaughtException;\n}\nfunction shouldCompute(derivation) {\n    switch (derivation.dependenciesState) {\n        case IDerivationState.UP_TO_DATE:\n            return false;\n        case IDerivationState.NOT_TRACKING:\n        case IDerivationState.STALE:\n            return true;\n        case IDerivationState.POSSIBLY_STALE:\n            {\n                var prevUntracked = untrackedStart();\n                var obs = derivation.observing,\n                    l = obs.length;\n                for (var i = 0; i < l; i++) {\n                    var obj = obs[i];\n                    if (isComputedValue(obj)) {\n                        try {\n                            obj.get();\n                        } catch (e) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                        if (derivation.dependenciesState === IDerivationState.STALE) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                    }\n                }\n                changeDependenciesStateTo0(derivation);\n                untrackedEnd(prevUntracked);\n                return false;\n            }\n    }\n}\nfunction isComputingDerivation() {\n    return globalState.trackingDerivation !== null;\n}\nfunction checkIfStateModificationsAreAllowed(atom) {\n    var hasObservers = atom.observers.length > 0;\n    if (globalState.computationDepth > 0 && hasObservers) fail(getMessage(\"m031\") + atom.name);\n    if (!globalState.allowStateChanges && hasObservers) fail(getMessage(globalState.strictMode ? \"m030a\" : \"m030b\") + atom.name);\n}\nfunction trackDerivedFunction(derivation, f, context) {\n    changeDependenciesStateTo0(derivation);\n    derivation.newObserving = new Array(derivation.observing.length + 100);\n    derivation.unboundDepsCount = 0;\n    derivation.runId = ++globalState.runId;\n    var prevTracking = globalState.trackingDerivation;\n    globalState.trackingDerivation = derivation;\n    var result;\n    try {\n        result = f.call(context);\n    } catch (e) {\n        result = new CaughtException(e);\n    }\n    globalState.trackingDerivation = prevTracking;\n    bindDependencies(derivation);\n    return result;\n}\nfunction bindDependencies(derivation) {\n    var prevObserving = derivation.observing;\n    var observing = derivation.observing = derivation.newObserving;\n    derivation.newObserving = null;\n    var i0 = 0,\n        l = derivation.unboundDepsCount;\n    for (var i = 0; i < l; i++) {\n        var dep = observing[i];\n        if (dep.diffValue === 0) {\n            dep.diffValue = 1;\n            if (i0 !== i) observing[i0] = dep;\n            i0++;\n        }\n    }\n    observing.length = i0;\n    l = prevObserving.length;\n    while (l--) {\n        var dep = prevObserving[l];\n        if (dep.diffValue === 0) {\n            removeObserver(dep, derivation);\n        }\n        dep.diffValue = 0;\n    }\n    while (i0--) {\n        var dep = observing[i0];\n        if (dep.diffValue === 1) {\n            dep.diffValue = 0;\n            addObserver(dep, derivation);\n        }\n    }\n}\nfunction clearObserving(derivation) {\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        removeObserver(obs[i], derivation);\n    }derivation.dependenciesState = IDerivationState.NOT_TRACKING;\n    obs.length = 0;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    var res = action();\n    untrackedEnd(prev);\n    return res;\n}\nexports.untracked = untracked;\nfunction untrackedStart() {\n    var prev = globalState.trackingDerivation;\n    globalState.trackingDerivation = null;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.trackingDerivation = prev;\n}\nfunction changeDependenciesStateTo0(derivation) {\n    if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return;\n    derivation.dependenciesState = IDerivationState.UP_TO_DATE;\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nvar persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"];\nvar MobXGlobals = function () {\n    function MobXGlobals() {\n        this.version = 5;\n        this.trackingDerivation = null;\n        this.computationDepth = 0;\n        this.runId = 0;\n        this.mobxGuid = 0;\n        this.inBatch = 0;\n        this.pendingUnobservations = [];\n        this.pendingReactions = [];\n        this.isRunningReactions = false;\n        this.allowStateChanges = true;\n        this.strictMode = false;\n        this.resetId = 0;\n        this.spyListeners = [];\n        this.globalReactionErrorHandlers = [];\n    }\n    return MobXGlobals;\n}();\nvar globalState = new MobXGlobals();\nfunction shareGlobalState() {\n    var global = getGlobal();\n    var ownState = globalState;\n    if (global.__mobservableTrackingStack || global.__mobservableViewStack) throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\");\n    if (global.__mobxGlobal && global.__mobxGlobal.version !== ownState.version) throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\");\n    if (global.__mobxGlobal) globalState = global.__mobxGlobal;else global.__mobxGlobal = ownState;\n}\nfunction getGlobalState() {\n    return globalState;\n}\nfunction registerGlobals() {}\nfunction resetGlobalState() {\n    globalState.resetId++;\n    var defaultGlobals = new MobXGlobals();\n    for (var key in defaultGlobals) {\n        if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];\n    }globalState.allowStateChanges = !globalState.strictMode;\n}\nfunction hasObservers(observable) {\n    return observable.observers && observable.observers.length > 0;\n}\nfunction getObservers(observable) {\n    return observable.observers;\n}\nfunction invariantObservers(observable) {\n    var list = observable.observers;\n    var map = observable.observersIndexes;\n    var l = list.length;\n    for (var i = 0; i < l; i++) {\n        var id = list[i].__mapid;\n        if (i) {\n            invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\");\n        } else {\n            invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldnt be held in map.\");\n        }\n    }\n    invariant(list.length === 0 || Object.keys(map).length === list.length - 1, \"INTERNAL ERROR there is no junk in map\");\n}\nfunction addObserver(observable, node) {\n    var l = observable.observers.length;\n    if (l) {\n        observable.observersIndexes[node.__mapid] = l;\n    }\n    observable.observers[l] = node;\n    if (observable.lowestObserverState > node.dependenciesState) observable.lowestObserverState = node.dependenciesState;\n}\nfunction removeObserver(observable, node) {\n    if (observable.observers.length === 1) {\n        observable.observers.length = 0;\n        queueForUnobservation(observable);\n    } else {\n        var list = observable.observers;\n        var map_1 = observable.observersIndexes;\n        var filler = list.pop();\n        if (filler !== node) {\n            var index = map_1[node.__mapid] || 0;\n            if (index) {\n                map_1[filler.__mapid] = index;\n            } else {\n                delete map_1[filler.__mapid];\n            }\n            list[index] = filler;\n        }\n        delete map_1[node.__mapid];\n    }\n}\nfunction queueForUnobservation(observable) {\n    if (!observable.isPendingUnobservation) {\n        observable.isPendingUnobservation = true;\n        globalState.pendingUnobservations.push(observable);\n    }\n}\nfunction startBatch() {\n    globalState.inBatch++;\n}\nfunction endBatch() {\n    if (--globalState.inBatch === 0) {\n        runReactions();\n        var list = globalState.pendingUnobservations;\n        for (var i = 0; i < list.length; i++) {\n            var observable_1 = list[i];\n            observable_1.isPendingUnobservation = false;\n            if (observable_1.observers.length === 0) {\n                observable_1.onBecomeUnobserved();\n            }\n        }\n        globalState.pendingUnobservations = [];\n    }\n}\nfunction reportObserved(observable) {\n    var derivation = globalState.trackingDerivation;\n    if (derivation !== null) {\n        if (derivation.runId !== observable.lastAccessedBy) {\n            observable.lastAccessedBy = derivation.runId;\n            derivation.newObserving[derivation.unboundDepsCount++] = observable;\n        }\n    } else if (observable.observers.length === 0) {\n        queueForUnobservation(observable);\n    }\n}\nfunction invariantLOS(observable, msg) {\n    var min = getObservers(observable).reduce(function (a, b) {\n        return Math.min(a, b.dependenciesState);\n    }, 2);\n    if (min >= observable.lowestObserverState) return;\n    throw new Error(\"lowestObserverState is wrong for \" + msg + \" because \" + min + \" < \" + observable.lowestObserverState);\n}\nfunction propagateChanged(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale();\n        d.dependenciesState = IDerivationState.STALE;\n    }\n}\nfunction propagateChangeConfirmed(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.POSSIBLY_STALE) d.dependenciesState = IDerivationState.STALE;else if (d.dependenciesState === IDerivationState.UP_TO_DATE) observable.lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nfunction propagateMaybeChanged(observable) {\n    if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return;\n    observable.lowestObserverState = IDerivationState.POSSIBLY_STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {\n            d.dependenciesState = IDerivationState.POSSIBLY_STALE;\n            d.onBecomeStale();\n        }\n    }\n}\nvar Reaction = function () {\n    function Reaction(name, onInvalidate) {\n        if (name === void 0) {\n            name = \"Reaction@\" + getNextId();\n        }\n        this.name = name;\n        this.onInvalidate = onInvalidate;\n        this.observing = [];\n        this.newObserving = [];\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.diffValue = 0;\n        this.runId = 0;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.isDisposed = false;\n        this._isScheduled = false;\n        this._isTrackPending = false;\n        this._isRunning = false;\n    }\n    Reaction.prototype.onBecomeStale = function () {\n        this.schedule();\n    };\n    Reaction.prototype.schedule = function () {\n        if (!this._isScheduled) {\n            this._isScheduled = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    };\n    Reaction.prototype.isScheduled = function () {\n        return this._isScheduled;\n    };\n    Reaction.prototype.runReaction = function () {\n        if (!this.isDisposed) {\n            startBatch();\n            this._isScheduled = false;\n            if (shouldCompute(this)) {\n                this._isTrackPending = true;\n                this.onInvalidate();\n                if (this._isTrackPending && isSpyEnabled()) {\n                    spyReport({\n                        object: this,\n                        type: \"scheduled-reaction\"\n                    });\n                }\n            }\n            endBatch();\n        }\n    };\n    Reaction.prototype.track = function (fn) {\n        startBatch();\n        var notify = isSpyEnabled();\n        var startTime;\n        if (notify) {\n            startTime = Date.now();\n            spyReportStart({\n                object: this,\n                type: \"reaction\",\n                fn: fn\n            });\n        }\n        this._isRunning = true;\n        var result = trackDerivedFunction(this, fn, undefined);\n        this._isRunning = false;\n        this._isTrackPending = false;\n        if (this.isDisposed) {\n            clearObserving(this);\n        }\n        if (isCaughtException(result)) this.reportExceptionInDerivation(result.cause);\n        if (notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n        endBatch();\n    };\n    Reaction.prototype.reportExceptionInDerivation = function (error) {\n        var _this = this;\n        if (this.errorHandler) {\n            this.errorHandler(error, this);\n            return;\n        }\n        var message = \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this;\n        var messageToUser = getMessage(\"m037\");\n        console.error(message || messageToUser, error);\n        if (isSpyEnabled()) {\n            spyReport({\n                type: \"error\",\n                message: message,\n                error: error,\n                object: this\n            });\n        }\n        globalState.globalReactionErrorHandlers.forEach(function (f) {\n            return f(error, _this);\n        });\n    };\n    Reaction.prototype.dispose = function () {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            if (!this._isRunning) {\n                startBatch();\n                clearObserving(this);\n                endBatch();\n            }\n        }\n    };\n    Reaction.prototype.getDisposer = function () {\n        var r = this.dispose.bind(this);\n        r.$mobx = this;\n        r.onError = registerErrorHandler;\n        return r;\n    };\n    Reaction.prototype.toString = function () {\n        return \"Reaction[\" + this.name + \"]\";\n    };\n    Reaction.prototype.whyRun = function () {\n        var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        return \"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this._isRunning ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\";\n    };\n    return Reaction;\n}();\nexports.Reaction = Reaction;\nfunction registerErrorHandler(handler) {\n    invariant(this && this.$mobx && isReaction(this.$mobx), \"Invalid `this`\");\n    invariant(!this.$mobx.errorHandler, \"Only one onErrorHandler can be registered\");\n    this.$mobx.errorHandler = handler;\n}\nfunction onReactionError(handler) {\n    globalState.globalReactionErrorHandlers.push(handler);\n    return function () {\n        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n        if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);\n    };\n}\nvar MAX_REACTION_ITERATIONS = 100;\nvar reactionScheduler = function reactionScheduler(f) {\n    return f();\n};\nfunction runReactions() {\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) return;\n    reactionScheduler(runReactionsHelper);\n}\nfunction runReactionsHelper() {\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    while (allReactions.length > 0) {\n        if (++iterations === MAX_REACTION_ITERATIONS) {\n            console.error(\"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0]));\n            allReactions.splice(0);\n        }\n        var remainingReactions = allReactions.splice(0);\n        for (var i = 0, l = remainingReactions.length; i < l; i++) {\n            remainingReactions[i].runReaction();\n        }\n    }\n    globalState.isRunningReactions = false;\n}\nvar isReaction = createInstanceofPredicate(\"Reaction\", Reaction);\nfunction setReactionScheduler(fn) {\n    var baseScheduler = reactionScheduler;\n    reactionScheduler = function reactionScheduler(f) {\n        return fn(function () {\n            return baseScheduler(f);\n        });\n    };\n}\nfunction isSpyEnabled() {\n    return !!globalState.spyListeners.length;\n}\nfunction spyReport(event) {\n    if (!globalState.spyListeners.length) return;\n    var listeners = globalState.spyListeners;\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](event);\n    }\n}\nfunction spyReportStart(event) {\n    var change = objectAssign({}, event, { spyReportStart: true });\n    spyReport(change);\n}\nvar END_EVENT = { spyReportEnd: true };\nfunction spyReportEnd(change) {\n    if (change) spyReport(objectAssign({}, change, END_EVENT));else spyReport(END_EVENT);\n}\nfunction spy(listener) {\n    globalState.spyListeners.push(listener);\n    return once(function () {\n        var idx = globalState.spyListeners.indexOf(listener);\n        if (idx !== -1) globalState.spyListeners.splice(idx, 1);\n    });\n}\nexports.spy = spy;\nfunction hasInterceptors(interceptable) {\n    return interceptable.interceptors && interceptable.interceptors.length > 0;\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);\n    interceptors.push(handler);\n    return once(function () {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1) interceptors.splice(idx, 1);\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    try {\n        var interceptors = interceptable.interceptors;\n        if (interceptors) for (var i = 0, l = interceptors.length; i < l; i++) {\n            change = interceptors[i](change);\n            invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\");\n            if (!change) break;\n        }\n        return change;\n    } finally {\n        untrackedEnd(prevU);\n    }\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners && listenable.changeListeners.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners || (listenable.changeListeners = []);\n    listeners.push(handler);\n    return once(function () {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1) listeners.splice(idx, 1);\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners;\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](change);\n    }\n    untrackedEnd(prevU);\n}\nfunction asReference(value) {\n    deprecated(\"asReference is deprecated, use observable.ref instead\");\n    return observable.ref(value);\n}\nexports.asReference = asReference;\nfunction asStructure(value) {\n    deprecated(\"asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.\");\n    return observable.struct(value);\n}\nexports.asStructure = asStructure;\nfunction asFlat(value) {\n    deprecated(\"asFlat is deprecated, use observable.shallow instead\");\n    return observable.shallow(value);\n}\nexports.asFlat = asFlat;\nfunction asMap(data) {\n    deprecated(\"asMap is deprecated, use observable.map or observable.shallowMap instead\");\n    return observable.map(data || {});\n}\nexports.asMap = asMap;\nfunction isModifierDescriptor(thing) {\n    return (typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null && thing.isMobxModifierDescriptor === true;\n}\nexports.isModifierDescriptor = isModifierDescriptor;\nfunction createModifierDescriptor(enhancer, initialValue) {\n    invariant(!isModifierDescriptor(initialValue), \"Modifiers cannot be nested\");\n    return {\n        isMobxModifierDescriptor: true,\n        initialValue: initialValue,\n        enhancer: enhancer\n    };\n}\nfunction deepEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return observable.array(v, name);\n    if (isPlainObject(v)) return observable.object(v, name);\n    if (isES6Map(v)) return observable.map(v, name);\n    return v;\n}\nfunction shallowEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (v === undefined || v === null) return v;\n    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v)) return v;\n    if (Array.isArray(v)) return observable.shallowArray(v, name);\n    if (isPlainObject(v)) return observable.shallowObject(v, name);\n    if (isES6Map(v)) return observable.shallowMap(v, name);\n    return fail(\"The shallow modifier / decorator can only used in combination with arrays, objects and maps\");\n}\nfunction referenceEnhancer(newValue) {\n    return newValue;\n}\nfunction deepStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return new ObservableArray(v, deepStructEnhancer, name);\n    if (isES6Map(v)) return new ObservableMap(v, deepStructEnhancer, name);\n    if (isPlainObject(v)) {\n        var res = {};\n        asObservableObject(res, name);\n        extendObservableHelper(res, deepStructEnhancer, [v]);\n        return res;\n    }\n    return v;\n}\nfunction refStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    return v;\n}\nvar MAX_SPLICE_SIZE = 10000;\nvar safariPrototypeSetterInheritanceBug = function () {\n    var v = false;\n    var p = {};\n    Object.defineProperty(p, \"0\", { set: function set() {\n            v = true;\n        } });\n    Object.create(p)[\"0\"] = 1;\n    return v === false;\n}();\nvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\nvar StubArray = function () {\n    function StubArray() {}\n    return StubArray;\n}();\nStubArray.prototype = [];\nvar ObservableArrayAdministration = function () {\n    function ObservableArrayAdministration(name, enhancer, array, owned) {\n        this.array = array;\n        this.owned = owned;\n        this.lastKnownLength = 0;\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.atom = new BaseAtom(name || \"ObservableArray@\" + getNextId());\n        this.enhancer = function (newV, oldV) {\n            return enhancer(newV, oldV, name + \"[..]\");\n        };\n    }\n    ObservableArrayAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        if (fireImmediately) {\n            listener({\n                object: this.array,\n                type: \"splice\",\n                index: 0,\n                added: this.values.slice(),\n                addedCount: this.values.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    ObservableArrayAdministration.prototype.getArrayLength = function () {\n        this.atom.reportObserved();\n        return this.values.length;\n    };\n    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {\n        if (typeof newLength !== \"number\" || newLength < 0) throw new Error(\"[mobx.array] Out of range: \" + newLength);\n        var currentLength = this.values.length;\n        if (newLength === currentLength) return;else if (newLength > currentLength) {\n            var newItems = new Array(newLength - currentLength);\n            for (var i = 0; i < newLength - currentLength; i++) {\n                newItems[i] = undefined;\n            }this.spliceWithArray(currentLength, 0, newItems);\n        } else this.spliceWithArray(newLength, currentLength - newLength);\n    };\n    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {\n        if (oldLength !== this.lastKnownLength) throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\");\n        this.lastKnownLength += delta;\n        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1);\n    };\n    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        var _this = this;\n        checkIfStateModificationsAreAllowed(this.atom);\n        var length = this.values.length;\n        if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);\n        if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        if (newItems === undefined) newItems = [];\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.array,\n                type: \"splice\",\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change) return EMPTY_ARRAY;\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.map(function (v) {\n            return _this.enhancer(v, undefined);\n        });\n        var lengthDelta = newItems.length - deleteCount;\n        this.updateArrayLength(length, lengthDelta);\n        var res = this.spliceItemsIntoValues(index, deleteCount, newItems);\n        if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res);\n        return res;\n    };\n    ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) {\n        if (newItems.length < MAX_SPLICE_SIZE) {\n            return (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));\n        } else {\n            var res = this.values.slice(index, index + deleteCount);\n            this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount));\n            return res;\n        }\n        var _a;\n    };\n    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"update\",\n            index: index, newValue: newValue, oldValue: oldValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"splice\",\n            index: index, removed: removed, added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    return ObservableArrayAdministration;\n}();\nvar ObservableArray = function (_super) {\n    __extends(ObservableArray, _super);\n    function ObservableArray(initialValues, enhancer, name, owned) {\n        if (name === void 0) {\n            name = \"ObservableArray@\" + getNextId();\n        }\n        if (owned === void 0) {\n            owned = false;\n        }\n        var _this = _super.call(this) || this;\n        var adm = new ObservableArrayAdministration(name, enhancer, _this, owned);\n        addHiddenFinalProp(_this, \"$mobx\", adm);\n        if (initialValues && initialValues.length) {\n            adm.updateArrayLength(0, initialValues.length);\n            adm.values = initialValues.map(function (v) {\n                return enhancer(v, undefined, name + \"[..]\");\n            });\n            adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY);\n        } else {\n            adm.values = [];\n        }\n        if (safariPrototypeSetterInheritanceBug) {\n            Object.defineProperty(adm.array, \"0\", ENTRY_0);\n        }\n        return _this;\n    }\n    ObservableArray.prototype.intercept = function (handler) {\n        return this.$mobx.intercept(handler);\n    };\n    ObservableArray.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        return this.$mobx.observe(listener, fireImmediately);\n    };\n    ObservableArray.prototype.clear = function () {\n        return this.splice(0);\n    };\n    ObservableArray.prototype.concat = function () {\n        var arrays = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            arrays[_i] = arguments[_i];\n        }\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) {\n            return isObservableArray(a) ? a.peek() : a;\n        }));\n    };\n    ObservableArray.prototype.replace = function (newItems) {\n        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);\n    };\n    ObservableArray.prototype.toJS = function () {\n        return this.slice();\n    };\n    ObservableArray.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableArray.prototype.peek = function () {\n        return this.$mobx.values;\n    };\n    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {\n        if (fromIndex === void 0) {\n            fromIndex = 0;\n        }\n        this.$mobx.atom.reportObserved();\n        var items = this.$mobx.values,\n            l = items.length;\n        for (var i = fromIndex; i < l; i++) {\n            if (predicate.call(thisArg, items[i], i, this)) return items[i];\n        }return undefined;\n    };\n    ObservableArray.prototype.splice = function (index, deleteCount) {\n        var newItems = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            newItems[_i - 2] = arguments[_i];\n        }\n        switch (arguments.length) {\n            case 0:\n                return [];\n            case 1:\n                return this.$mobx.spliceWithArray(index);\n            case 2:\n                return this.$mobx.spliceWithArray(index, deleteCount);\n        }\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.push = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(adm.values.length, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.pop = function () {\n        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];\n    };\n    ObservableArray.prototype.shift = function () {\n        return this.splice(0, 1)[0];\n    };\n    ObservableArray.prototype.unshift = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(0, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.reverse = function () {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.reverse.apply(clone, arguments);\n    };\n    ObservableArray.prototype.sort = function (compareFn) {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.sort.apply(clone, arguments);\n    };\n    ObservableArray.prototype.remove = function (value) {\n        var idx = this.$mobx.values.indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    };\n    ObservableArray.prototype.move = function (fromIndex, toIndex) {\n        function checkIndex(index) {\n            if (index < 0) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\n            }\n            var length = this.$mobx.values.length;\n            if (index >= length) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\n            }\n        }\n        checkIndex.call(this, fromIndex);\n        checkIndex.call(this, toIndex);\n        if (fromIndex === toIndex) {\n            return;\n        }\n        var oldItems = this.$mobx.values;\n        var newItems;\n        if (fromIndex < toIndex) {\n            newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1));\n        } else {\n            newItems = oldItems.slice(0, toIndex).concat([oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\n        }\n        this.replace(newItems);\n    };\n    ObservableArray.prototype.toString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toString.apply(this.$mobx.values, arguments);\n    };\n    ObservableArray.prototype.toLocaleString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toLocaleString.apply(this.$mobx.values, arguments);\n    };\n    return ObservableArray;\n}(StubArray);\ndeclareIterator(ObservableArray.prototype, function () {\n    return arrayAsIterator(this.slice());\n});\nmakeNonEnumerable(ObservableArray.prototype, [\"constructor\", \"intercept\", \"observe\", \"clear\", \"concat\", \"replace\", \"toJS\", \"toJSON\", \"peek\", \"find\", \"splice\", \"spliceWithArray\", \"push\", \"pop\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"remove\", \"move\", \"toString\", \"toLocaleString\"]);\nObject.defineProperty(ObservableArray.prototype, \"length\", {\n    enumerable: false,\n    configurable: true,\n    get: function get() {\n        return this.$mobx.getArrayLength();\n    },\n    set: function set(newLength) {\n        this.$mobx.setArrayLength(newLength);\n    }\n});\n[\"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function (funcName) {\n    var baseFunc = Array.prototype[funcName];\n    invariant(typeof baseFunc === \"function\", \"Base function not defined on Array prototype: '\" + funcName + \"'\");\n    addHiddenProp(ObservableArray.prototype, funcName, function () {\n        this.$mobx.atom.reportObserved();\n        return baseFunc.apply(this.$mobx.values, arguments);\n    });\n});\nvar ENTRY_0 = {\n    configurable: true,\n    enumerable: false,\n    set: createArraySetter(0),\n    get: createArrayGetter(0)\n};\nfunction createArrayBufferItem(index) {\n    var set = createArraySetter(index);\n    var get = createArrayGetter(index);\n    Object.defineProperty(ObservableArray.prototype, \"\" + index, {\n        enumerable: false,\n        configurable: true,\n        set: set, get: get\n    });\n}\nfunction createArraySetter(index) {\n    return function (newValue) {\n        var adm = this.$mobx;\n        var values = adm.values;\n        if (index < values.length) {\n            checkIfStateModificationsAreAllowed(adm.atom);\n            var oldValue = values[index];\n            if (hasInterceptors(adm)) {\n                var change = interceptChange(adm, {\n                    type: \"update\",\n                    object: adm.array,\n                    index: index, newValue: newValue\n                });\n                if (!change) return;\n                newValue = change.newValue;\n            }\n            newValue = adm.enhancer(newValue, oldValue);\n            var changed = newValue !== oldValue;\n            if (changed) {\n                values[index] = newValue;\n                adm.notifyArrayChildUpdate(index, newValue, oldValue);\n            }\n        } else if (index === values.length) {\n            adm.spliceWithArray(index, 0, [newValue]);\n        } else throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length);\n    };\n}\nfunction createArrayGetter(index) {\n    return function () {\n        var impl = this.$mobx;\n        if (impl) {\n            if (index < impl.values.length) {\n                impl.atom.reportObserved();\n                return impl.values[index];\n            }\n            console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\");\n        }\n        return undefined;\n    };\n}\nfunction reserveArrayBuffer(max) {\n    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) {\n        createArrayBufferItem(index);\n    }OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n}\nreserveArrayBuffer(1000);\nvar isObservableArrayAdministration = createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\nfunction isObservableArray(thing) {\n    return isObject(thing) && isObservableArrayAdministration(thing.$mobx);\n}\nexports.isObservableArray = isObservableArray;\nvar ObservableMapMarker = {};\nvar ObservableMap = function () {\n    function ObservableMap(initialData, enhancer, name) {\n        if (enhancer === void 0) {\n            enhancer = deepEnhancer;\n        }\n        if (name === void 0) {\n            name = \"ObservableMap@\" + getNextId();\n        }\n        this.enhancer = enhancer;\n        this.name = name;\n        this.$mobx = ObservableMapMarker;\n        this._data = {};\n        this._hasMap = {};\n        this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + \".keys()\", true);\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.merge(initialData);\n    }\n    ObservableMap.prototype._has = function (key) {\n        return typeof this._data[key] !== \"undefined\";\n    };\n    ObservableMap.prototype.has = function (key) {\n        if (!this.isValidKey(key)) return false;\n        key = \"\" + key;\n        if (this._hasMap[key]) return this._hasMap[key].get();\n        return this._updateHasMapEntry(key, false).get();\n    };\n    ObservableMap.prototype.set = function (key, value) {\n        this.assertValidKey(key);\n        key = \"\" + key;\n        var hasKey = this._has(key);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? \"update\" : \"add\",\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change) return this;\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this._updateValue(key, value);\n        } else {\n            this._addValue(key, value);\n        }\n        return this;\n    };\n    ObservableMap.prototype.delete = function (key) {\n        var _this = this;\n        this.assertValidKey(key);\n        key = \"\" + key;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: \"delete\",\n                object: this,\n                name: key\n            });\n            if (!change) return false;\n        }\n        if (this._has(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"delete\",\n                object: this,\n                oldValue: this._data[key].value,\n                name: key\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            runInTransaction(function () {\n                _this._keys.remove(key);\n                _this._updateHasMapEntry(key, false);\n                var observable = _this._data[key];\n                observable.setNewValue(undefined);\n                _this._data[key] = undefined;\n            });\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n            return true;\n        }\n        return false;\n    };\n    ObservableMap.prototype._updateHasMapEntry = function (key, value) {\n        var entry = this._hasMap[key];\n        if (entry) {\n            entry.setNewValue(value);\n        } else {\n            entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + \".\" + key + \"?\", false);\n        }\n        return entry;\n    };\n    ObservableMap.prototype._updateValue = function (name, newValue) {\n        var observable = this._data[name];\n        newValue = observable.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"update\",\n                object: this,\n                oldValue: observable.value,\n                name: name, newValue: newValue\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            observable.setNewValue(newValue);\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableMap.prototype._addValue = function (name, newValue) {\n        var _this = this;\n        runInTransaction(function () {\n            var observable = _this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + \".\" + name, false);\n            newValue = observable.value;\n            _this._updateHasMapEntry(name, true);\n            _this._keys.push(name);\n        });\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            type: \"add\",\n            object: this,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableMap.prototype.get = function (key) {\n        key = \"\" + key;\n        if (this.has(key)) return this._data[key].get();\n        return undefined;\n    };\n    ObservableMap.prototype.keys = function () {\n        return arrayAsIterator(this._keys.slice());\n    };\n    ObservableMap.prototype.values = function () {\n        return arrayAsIterator(this._keys.map(this.get, this));\n    };\n    ObservableMap.prototype.entries = function () {\n        var _this = this;\n        return arrayAsIterator(this._keys.map(function (key) {\n            return [key, _this.get(key)];\n        }));\n    };\n    ObservableMap.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        this.keys().forEach(function (key) {\n            return callback.call(thisArg, _this.get(key), key, _this);\n        });\n    };\n    ObservableMap.prototype.merge = function (other) {\n        var _this = this;\n        if (isObservableMap(other)) {\n            other = other.toJS();\n        }\n        runInTransaction(function () {\n            if (isPlainObject(other)) Object.keys(other).forEach(function (key) {\n                return _this.set(key, other[key]);\n            });else if (Array.isArray(other)) other.forEach(function (_a) {\n                var key = _a[0],\n                    value = _a[1];\n                return _this.set(key, value);\n            });else if (isES6Map(other)) other.forEach(function (value, key) {\n                return _this.set(key, value);\n            });else if (other !== null && other !== undefined) fail(\"Cannot initialize map from \" + other);\n        });\n        return this;\n    };\n    ObservableMap.prototype.clear = function () {\n        var _this = this;\n        runInTransaction(function () {\n            untracked(function () {\n                _this.keys().forEach(_this.delete, _this);\n            });\n        });\n    };\n    ObservableMap.prototype.replace = function (values) {\n        var _this = this;\n        runInTransaction(function () {\n            _this.clear();\n            _this.merge(values);\n        });\n        return this;\n    };\n    Object.defineProperty(ObservableMap.prototype, \"size\", {\n        get: function get() {\n            return this._keys.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObservableMap.prototype.toJS = function () {\n        var _this = this;\n        var res = {};\n        this.keys().forEach(function (key) {\n            return res[key] = _this.get(key);\n        });\n        return res;\n    };\n    ObservableMap.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableMap.prototype.isValidKey = function (key) {\n        if (key === null || key === undefined) return false;\n        if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"boolean\") return true;\n        return false;\n    };\n    ObservableMap.prototype.assertValidKey = function (key) {\n        if (!this.isValidKey(key)) throw new Error(\"[mobx.map] Invalid key: '\" + key + \"', only strings, numbers and booleans are accepted as key in observable maps.\");\n    };\n    ObservableMap.prototype.toString = function () {\n        var _this = this;\n        return this.name + \"[{ \" + this.keys().map(function (key) {\n            return key + \": \" + (\"\" + _this.get(key));\n        }).join(\", \") + \" }]\";\n    };\n    ObservableMap.prototype.observe = function (listener, fireImmediately) {\n        invariant(fireImmediately !== true, getMessage(\"m033\"));\n        return registerListener(this, listener);\n    };\n    ObservableMap.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableMap;\n}();\nexports.ObservableMap = ObservableMap;\ndeclareIterator(ObservableMap.prototype, function () {\n    return this.entries();\n});\nfunction map(initialValues) {\n    deprecated(\"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\");\n    return observable.map(initialValues);\n}\nexports.map = map;\nvar isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap);\nexports.isObservableMap = isObservableMap;\nvar ObservableObjectAdministration = function () {\n    function ObservableObjectAdministration(target, name) {\n        this.target = target;\n        this.name = name;\n        this.values = {};\n        this.changeListeners = null;\n        this.interceptors = null;\n    }\n    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {\n        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\");\n        return registerListener(this, callback);\n    };\n    ObservableObjectAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableObjectAdministration;\n}();\nfunction asObservableObject(target, name) {\n    if (isObservableObject(target)) return target.$mobx;\n    invariant(Object.isExtensible(target), getMessage(\"m035\"));\n    if (!isPlainObject(target)) name = (target.constructor.name || \"ObservableObject\") + \"@\" + getNextId();\n    if (!name) name = \"ObservableObject@\" + getNextId();\n    var adm = new ObservableObjectAdministration(target, name);\n    addHiddenFinalProp(target, \"$mobx\", adm);\n    return adm;\n}\nfunction defineObservablePropertyFromDescriptor(adm, propName, descriptor, defaultEnhancer) {\n    if (adm.values[propName]) {\n        invariant(\"value\" in descriptor, \"The property \" + propName + \" in \" + adm.name + \" is already observable, cannot redefine it as computed property\");\n        adm.target[propName] = descriptor.value;\n        return;\n    }\n    if (\"value\" in descriptor) {\n        if (isModifierDescriptor(descriptor.value)) {\n            var modifierDescriptor = descriptor.value;\n            defineObservableProperty(adm, propName, modifierDescriptor.initialValue, modifierDescriptor.enhancer);\n        } else if (isAction(descriptor.value) && descriptor.value.autoBind === true) {\n            defineBoundAction(adm.target, propName, descriptor.value.originalFn);\n        } else if (isComputedValue(descriptor.value)) {\n            defineComputedPropertyFromComputedValue(adm, propName, descriptor.value);\n        } else {\n            defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer);\n        }\n    } else {\n        defineComputedProperty(adm, propName, descriptor.get, descriptor.set, false, true);\n    }\n}\nfunction defineObservableProperty(adm, propName, newValue, enhancer) {\n    assertPropertyConfigurable(adm.target, propName);\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            object: adm.target,\n            name: propName,\n            type: \"add\",\n            newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    var observable = adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + \".\" + propName, false);\n    newValue = observable.value;\n    Object.defineProperty(adm.target, propName, generateObservablePropConfig(propName));\n    notifyPropertyAddition(adm, adm.target, propName, newValue);\n}\nfunction defineComputedProperty(adm, propName, getter, setter, compareStructural, asInstanceProperty) {\n    if (asInstanceProperty) assertPropertyConfigurable(adm.target, propName);\n    adm.values[propName] = new ComputedValue(getter, adm.target, compareStructural, adm.name + \".\" + propName, setter);\n    if (asInstanceProperty) {\n        Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n    }\n}\nfunction defineComputedPropertyFromComputedValue(adm, propName, computedValue) {\n    var name = adm.name + \".\" + propName;\n    computedValue.name = name;\n    if (!computedValue.scope) computedValue.scope = adm.target;\n    adm.values[propName] = computedValue;\n    Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n}\nvar observablePropertyConfigs = {};\nvar computedPropertyConfigs = {};\nfunction generateObservablePropConfig(propName) {\n    return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            setPropertyValue(this, propName, v);\n        }\n    });\n}\nfunction generateComputedPropConfig(propName) {\n    return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: false,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            return this.$mobx.values[propName].set(v);\n        }\n    });\n}\nfunction setPropertyValue(instance, name, newValue) {\n    var adm = instance.$mobx;\n    var observable = adm.values[name];\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            type: \"update\",\n            object: instance,\n            name: name, newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    newValue = observable.prepareNewValue(newValue);\n    if (newValue !== UNCHANGED) {\n        var notify = hasListeners(adm);\n        var notifySpy = isSpyEnabled();\n        var change = notify || notifySpy ? {\n            type: \"update\",\n            object: instance,\n            oldValue: observable.value,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        observable.setNewValue(newValue);\n        if (notify) notifyListeners(adm, change);\n        if (notifySpy) spyReportEnd();\n    }\n}\nfunction notifyPropertyAddition(adm, object, name, newValue) {\n    var notify = hasListeners(adm);\n    var notifySpy = isSpyEnabled();\n    var change = notify || notifySpy ? {\n        type: \"add\",\n        object: object, name: name, newValue: newValue\n    } : null;\n    if (notifySpy) spyReportStart(change);\n    if (notify) notifyListeners(adm, change);\n    if (notifySpy) spyReportEnd();\n}\nvar isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\nfunction isObservableObject(thing) {\n    if (isObject(thing)) {\n        runLazyInitializers(thing);\n        return isObservableObjectAdministration(thing.$mobx);\n    }\n    return false;\n}\nexports.isObservableObject = isObservableObject;\nvar UNCHANGED = {};\nvar ObservableValue = function (_super) {\n    __extends(ObservableValue, _super);\n    function ObservableValue(value, enhancer, name, notifySpy) {\n        if (name === void 0) {\n            name = \"ObservableValue@\" + getNextId();\n        }\n        if (notifySpy === void 0) {\n            notifySpy = true;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.enhancer = enhancer;\n        _this.hasUnreportedChange = false;\n        _this.value = enhancer(value, undefined, name);\n        if (notifySpy && isSpyEnabled()) {\n            spyReport({ type: \"create\", object: _this, newValue: _this.value });\n        }\n        return _this;\n    }\n    ObservableValue.prototype.set = function (newValue) {\n        var oldValue = this.value;\n        newValue = this.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if (notifySpy) {\n                spyReportStart({\n                    type: \"update\",\n                    object: this,\n                    newValue: newValue, oldValue: oldValue\n                });\n            }\n            this.setNewValue(newValue);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableValue.prototype.prepareNewValue = function (newValue) {\n        checkIfStateModificationsAreAllowed(this);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue });\n            if (!change) return UNCHANGED;\n            newValue = change.newValue;\n        }\n        newValue = this.enhancer(newValue, this.value, this.name);\n        return this.value !== newValue ? newValue : UNCHANGED;\n    };\n    ObservableValue.prototype.setNewValue = function (newValue) {\n        var oldValue = this.value;\n        this.value = newValue;\n        this.reportChanged();\n        if (hasListeners(this)) {\n            notifyListeners(this, {\n                type: \"update\",\n                object: this,\n                newValue: newValue,\n                oldValue: oldValue\n            });\n        }\n    };\n    ObservableValue.prototype.get = function () {\n        this.reportObserved();\n        return this.value;\n    };\n    ObservableValue.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableValue.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately) listener({\n            object: this,\n            type: \"update\",\n            newValue: this.value,\n            oldValue: undefined\n        });\n        return registerListener(this, listener);\n    };\n    ObservableValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ObservableValue.prototype.toString = function () {\n        return this.name + \"[\" + this.value + \"]\";\n    };\n    ObservableValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    return ObservableValue;\n}(BaseAtom);\nObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf;\nvar isObservableValue = createInstanceofPredicate(\"ObservableValue\", ObservableValue);\nexports.isBoxedObservable = isObservableValue;\nfunction getAtom(thing, property) {\n    if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            invariant(property === undefined, getMessage(\"m036\"));\n            return thing.$mobx.atom;\n        }\n        if (isObservableMap(thing)) {\n            var anyThing = thing;\n            if (property === undefined) return getAtom(anyThing._keys);\n            var observable_2 = anyThing._data[property] || anyThing._hasMap[property];\n            invariant(!!observable_2, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\");\n            return observable_2;\n        }\n        runLazyInitializers(thing);\n        if (isObservableObject(thing)) {\n            if (!property) return fail(\"please specify a property\");\n            var observable_3 = thing.$mobx.values[property];\n            invariant(!!observable_3, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\");\n            return observable_3;\n        }\n        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n            return thing;\n        }\n    } else if (typeof thing === \"function\") {\n        if (isReaction(thing.$mobx)) {\n            return thing.$mobx;\n        }\n    }\n    return fail(\"Cannot obtain atom from \" + thing);\n}\nfunction getAdministration(thing, property) {\n    invariant(thing, \"Expecting some object\");\n    if (property !== undefined) return getAdministration(getAtom(thing, property));\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;\n    if (isObservableMap(thing)) return thing;\n    runLazyInitializers(thing);\n    if (thing.$mobx) return thing.$mobx;\n    invariant(false, \"Cannot obtain administration from \" + thing);\n}\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing)) named = getAdministration(thing);else named = getAtom(thing);\n    return named.name;\n}\nfunction createClassPropertyDecorator(onInitialize, _get, _set, enumerable, allowCustomArguments) {\n    function classPropertyDecorator(target, key, descriptor, customArgs, argLen) {\n        if (argLen === void 0) {\n            argLen = 0;\n        }\n        invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\");\n        if (!descriptor) {\n            var newDescriptor = {\n                enumerable: enumerable,\n                configurable: true,\n                get: function get() {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {\n                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);\n                    } else {\n                        _set.call(this, key, v);\n                    }\n                }\n            };\n            if (arguments.length < 3 || arguments.length === 5 && argLen < 3) {\n                Object.defineProperty(target, key, newDescriptor);\n            }\n            return newDescriptor;\n        } else {\n            if (!hasOwnProperty(target, \"__mobxLazyInitializers\")) {\n                addHiddenProp(target, \"__mobxLazyInitializers\", target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice() || []);\n            }\n            var value_1 = descriptor.value,\n                initializer_1 = descriptor.initializer;\n            target.__mobxLazyInitializers.push(function (instance) {\n                onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor);\n            });\n            return {\n                enumerable: enumerable, configurable: true,\n                get: function get() {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    _set.call(this, key, v);\n                }\n            };\n        }\n    }\n    if (allowCustomArguments) {\n        return function () {\n            if (quacksLikeADecorator(arguments)) return classPropertyDecorator.apply(null, arguments);\n            var outerArgs = arguments;\n            var argLen = arguments.length;\n            return function (target, key, descriptor) {\n                return classPropertyDecorator(target, key, descriptor, outerArgs, argLen);\n            };\n        };\n    }\n    return classPropertyDecorator;\n}\nfunction typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {\n    if (!hasOwnProperty(instance, \"__mobxInitializedProps\")) addHiddenProp(instance, \"__mobxInitializedProps\", {});\n    instance.__mobxInitializedProps[key] = true;\n    onInitialize(instance, key, v, customArgs, baseDescriptor);\n}\nfunction runLazyInitializers(instance) {\n    if (instance.__mobxDidRunLazyInitializers === true) return;\n    if (instance.__mobxLazyInitializers) {\n        addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true);\n        instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) {\n            return initializer(instance);\n        });\n    }\n}\nfunction quacksLikeADecorator(args) {\n    return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\";\n}\nfunction iteratorSymbol() {\n    return typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n}\nvar IS_ITERATING_MARKER = \"__$$iterating\";\nfunction arrayAsIterator(array) {\n    invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\");\n    addHiddenFinalProp(array, IS_ITERATING_MARKER, true);\n    var idx = -1;\n    addHiddenFinalProp(array, \"next\", function next() {\n        idx++;\n        return {\n            done: idx >= this.length,\n            value: idx < this.length ? this[idx] : undefined\n        };\n    });\n    return array;\n}\nfunction declareIterator(prototType, iteratorFactory) {\n    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);\n}\nvar messages = {\n    \"m001\": \"It is not allowed to assign new values to @action fields\",\n    \"m002\": \"`runInAction` expects a function\",\n    \"m003\": \"`runInAction` expects a function without arguments\",\n    \"m004\": \"autorun expects a function\",\n    \"m005\": \"Warning: attempted to pass an action to autorun. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m006\": \"Warning: attempted to pass an action to autorunAsync. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m007\": \"reaction only accepts 2 or 3 arguments. If migrating from MobX 2, please provide an options object\",\n    \"m008\": \"wrapping reaction expression in `asReference` is no longer supported, use options object instead\",\n    \"m009\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\",\n    \"m010\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\",\n    \"m011\": \"First argument to `computed` should be an expression. If using computed as decorator, don't pass it arguments\",\n    \"m012\": \"computed takes one or two arguments if used as function\",\n    \"m013\": \"[mobx.expr] 'expr' should only be used inside other reactive functions.\",\n    \"m014\": \"extendObservable expected 2 or more arguments\",\n    \"m015\": \"extendObservable expects an object as first argument\",\n    \"m016\": \"extendObservable should not be used on maps, use map.merge instead\",\n    \"m017\": \"all arguments of extendObservable should be objects\",\n    \"m018\": \"extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540\",\n    \"m019\": \"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\",\n    \"m020\": \"modifiers can only be used for individual object properties\",\n    \"m021\": \"observable expects zero or one arguments\",\n    \"m022\": \"@observable can not be used on getters, use @computed instead\",\n    \"m023\": \"Using `transaction` is deprecated, use `runInAction` or `(@)action` instead.\",\n    \"m024\": \"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested its value.\",\n    \"m025\": \"whyRun can only be used on reactions and computed values\",\n    \"m026\": \"`action` can only be invoked on functions\",\n    \"m028\": \"It is not allowed to set `useStrict` when a derivation is running\",\n    \"m029\": \"INTERNAL ERROR only onBecomeUnobserved shouldn't be called twice in a row\",\n    \"m030a\": \"Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: \",\n    \"m030b\": \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: \",\n    \"m031\": \"Computed values are not allowed to not cause side effects by changing observables that are already being observed. Tried to modify: \",\n    \"m032\": \"* This computation is suspended (not in use by any reaction) and won't run automatically.\\n\tDidn't expect this computation to be suspended at this point?\\n\t  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n\t  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\",\n    \"m033\": \"`observe` doesn't support the fire immediately property for observable maps.\",\n    \"m034\": \"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\",\n    \"m035\": \"Cannot make the designated object observable; it is not extensible\",\n    \"m036\": \"It is not possible to get index atoms from arrays\",\n    \"m037\": \"Hi there! I'm sorry you have just run into an exception.\\nIf your debugger ends up here, know that some reaction (like the render() of an observer component, autorun or reaction)\\nthrew an exception and that mobx caught it, to avoid that it brings the rest of your application down.\\nThe original cause of the exception (the code that caused this reaction to run (again)), is still in the stack.\\n\\nHowever, more interesting is the actual stack trace of the error itself.\\nHopefully the error is an instanceof Error, because in that case you can inspect the original stack of the error from where it was thrown.\\nSee `error.stack` property, or press the very subtle \\\"(...)\\\" link you see near the console.error message that probably brought you here.\\nThat stack is more interesting than the stack of this console.error itself.\\n\\nIf the exception you see is an exception you created yourself, make sure to use `throw new Error(\\\"Oops\\\")` instead of `throw \\\"Oops\\\"`,\\nbecause the javascript environment will only preserve the original stack trace in the first form.\\n\\nYou can also make sure the debugger pauses the next time this very same exception is thrown by enabling \\\"Pause on caught exception\\\".\\n(Note that it might pause on many other, unrelated exception as well).\\n\\nIf that all doesn't help you out, feel free to open an issue https://github.com/mobxjs/mobx/issues!\\n\",\n    \"m038\": \"Missing items in this list?\\n    1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n    2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\"\n};\nfunction getMessage(id) {\n    return messages[id];\n}\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nfunction getGlobal() {\n    return global;\n}\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\nfunction fail(message, thing) {\n    invariant(false, message, thing);\n    throw \"X\";\n}\nfunction invariant(check, message, thing) {\n    if (!check) throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\"));\n}\nvar deprecatedMessages = [];\nfunction deprecated(msg) {\n    if (deprecatedMessages.indexOf(msg) !== -1) return false;\n    deprecatedMessages.push(msg);\n    console.error(\"[mobx] Deprecated: \" + msg);\n    return true;\n}\nfunction once(func) {\n    var invoked = false;\n    return function () {\n        if (invoked) return;\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function noop() {};\nfunction unique(list) {\n    var res = [];\n    list.forEach(function (item) {\n        if (res.indexOf(item) === -1) res.push(item);\n    });\n    return res;\n}\nfunction joinStrings(things, limit, separator) {\n    if (limit === void 0) {\n        limit = 100;\n    }\n    if (separator === void 0) {\n        separator = \" - \";\n    }\n    if (!things) return \"\";\n    var sliced = things.slice(0, limit);\n    return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\");\n}\nfunction isObject(value) {\n    return value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\";\n}\nfunction isPlainObject(value) {\n    if (value === null || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false;\n    var proto = Object.getPrototypeOf(value);\n    return proto === Object.prototype || proto === null;\n}\nfunction objectAssign() {\n    var res = arguments[0];\n    for (var i = 1, l = arguments.length; i < l; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n            if (hasOwnProperty(source, key)) {\n                res[key] = source[key];\n            }\n        }\n    }\n    return res;\n}\nfunction valueDidChange(compareStructural, oldValue, newValue) {\n    if (typeof oldValue === 'number' && isNaN(oldValue)) {\n        return typeof newValue !== 'number' || !isNaN(newValue);\n    }\n    return compareStructural ? !deepEqual(oldValue, newValue) : oldValue !== newValue;\n}\nvar prototypeHasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(object, propName) {\n    return prototypeHasOwnProperty.call(object, propName);\n}\nfunction makeNonEnumerable(object, propNames) {\n    for (var i = 0; i < propNames.length; i++) {\n        addHiddenProp(object, propNames[i], object[propNames[i]]);\n    }\n}\nfunction addHiddenProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\nfunction isPropertyConfigurable(object, prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(object, prop);\n    return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;\n}\nfunction assertPropertyConfigurable(object, prop) {\n    invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\");\n}\nfunction getEnumerableKeys(obj) {\n    var res = [];\n    for (var key in obj) {\n        res.push(key);\n    }return res;\n}\nfunction deepEqual(a, b) {\n    if (a === null && b === null) return true;\n    if (a === undefined && b === undefined) return true;\n    if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) !== \"object\") return a === b;\n    var aIsArray = isArrayLike(a);\n    var aIsMap = isMapLike(a);\n    if (aIsArray !== isArrayLike(b)) {\n        return false;\n    } else if (aIsMap !== isMapLike(b)) {\n        return false;\n    } else if (aIsArray) {\n        if (a.length !== b.length) return false;\n        for (var i = a.length - 1; i >= 0; i--) {\n            if (!deepEqual(a[i], b[i])) return false;\n        }return true;\n    } else if (aIsMap) {\n        if (a.size !== b.size) return false;\n        var equals_1 = true;\n        a.forEach(function (value, key) {\n            equals_1 = equals_1 && deepEqual(b.get(key), value);\n        });\n        return equals_1;\n    } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === \"object\" && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === \"object\") {\n        if (a === null || b === null) return false;\n        if (isMapLike(a) && isMapLike(b)) {\n            if (a.size !== b.size) return false;\n            return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries());\n        }\n        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length) return false;\n        for (var prop in a) {\n            if (!(prop in b)) return false;\n            if (!deepEqual(a[prop], b[prop])) return false;\n        }\n        return true;\n    }\n    return false;\n}\nfunction createInstanceofPredicate(name, clazz) {\n    var propName = \"isMobX\" + name;\n    clazz.prototype[propName] = true;\n    return function (x) {\n        return isObject(x) && x[propName] === true;\n    };\n}\nfunction isArrayLike(x) {\n    return Array.isArray(x) || isObservableArray(x);\n}\nexports.isArrayLike = isArrayLike;\nfunction isMapLike(x) {\n    return isES6Map(x) || isObservableMap(x);\n}\nfunction isES6Map(thing) {\n    if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map) return true;\n    return false;\n}\nfunction primitiveSymbol() {\n    return typeof Symbol === \"function\" && Symbol.toPrimitive || \"@@toPrimitive\";\n}\nfunction toPrimitive(value) {\n    return value === null ? null : (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? \"\" + value : value;\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _icons = __webpack_require__(6);\n\nvar _constants = __webpack_require__(0);\n\nfunction renderHeader(_ref, instance) {\n  var meta = _ref.meta,\n      user = _ref.user,\n      reactions = _ref.reactions;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-header-container';\n\n  var likeButton = document.createElement('span');\n  var likedReaction = reactions.find(function (reaction) {\n    return reaction.content === 'heart' && reaction.user.login === user.login;\n  });\n  likeButton.className = 'gitment-header-like-btn';\n  likeButton.innerHTML = '\\n    ' + _icons.heart + '\\n    ' + (likedReaction ? 'Unlike' : 'Like') + '\\n    ' + (meta.reactions && meta.reactions.heart ? ' \\u2022 <strong>' + meta.reactions.heart + '</strong> Liked' : '') + '\\n  ';\n\n  if (likedReaction) {\n    likeButton.classList.add('liked');\n    likeButton.onclick = function () {\n      return instance.unlike();\n    };\n  } else {\n    likeButton.classList.remove('liked');\n    likeButton.onclick = function () {\n      return instance.like();\n    };\n  }\n  container.appendChild(likeButton);\n\n  var commentsCount = document.createElement('span');\n  commentsCount.innerHTML = '\\n    ' + (meta.comments ? ' \\u2022 <strong>' + meta.comments + '</strong> Comments' : '') + '\\n  ';\n  container.appendChild(commentsCount);\n\n  var issueLink = document.createElement('a');\n  issueLink.className = 'gitment-header-issue-link';\n  issueLink.href = meta.html_url;\n  issueLink.target = '_blank';\n  issueLink.innerText = 'Issue Page';\n  container.appendChild(issueLink);\n\n  return container;\n}\n\nfunction renderComments(_ref2, instance) {\n  var meta = _ref2.meta,\n      comments = _ref2.comments,\n      commentReactions = _ref2.commentReactions,\n      currentPage = _ref2.currentPage,\n      user = _ref2.user,\n      error = _ref2.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-comments-container';\n\n  if (error) {\n    var errorBlock = document.createElement('div');\n    errorBlock.className = 'gitment-comments-error';\n\n    if (error === _constants.NOT_INITIALIZED_ERROR && user.login && user.login.toLowerCase() === instance.owner.toLowerCase()) {\n      var initHint = document.createElement('div');\n      var initButton = document.createElement('button');\n      initButton.className = 'gitment-comments-init-btn';\n      initButton.onclick = function () {\n        initButton.setAttribute('disabled', true);\n        instance.init().catch(function (e) {\n          initButton.removeAttribute('disabled');\n          alert(e);\n        });\n      };\n      initButton.innerText = 'Initialize Comments';\n      initHint.appendChild(initButton);\n      errorBlock.appendChild(initHint);\n    } else {\n      errorBlock.innerText = error;\n    }\n    container.appendChild(errorBlock);\n    return container;\n  } else if (comments === undefined) {\n    var loading = document.createElement('div');\n    loading.innerText = 'Loading comments...';\n    loading.className = 'gitment-comments-loading';\n    container.appendChild(loading);\n    return container;\n  } else if (!comments.length) {\n    var emptyBlock = document.createElement('div');\n    emptyBlock.className = 'gitment-comments-empty';\n    emptyBlock.innerText = 'No Comment Yet';\n    container.appendChild(emptyBlock);\n    return container;\n  }\n\n  var commentsList = document.createElement('ul');\n  commentsList.className = 'gitment-comments-list';\n\n  comments.forEach(function (comment) {\n    var createDate = new Date(comment.created_at);\n    var updateDate = new Date(comment.updated_at);\n    var commentItem = document.createElement('li');\n    commentItem.className = 'gitment-comment';\n    commentItem.innerHTML = '\\n      <a class=\"gitment-comment-avatar\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n        <img class=\"gitment-comment-avatar-img\" src=\"/js/gitment.j/' + comment.user.avatar_url + '\">\\n      </a>\\n      <div class=\"gitment-comment-main\">\\n        <div class=\"gitment-comment-header\">\\n          <a class=\"gitment-comment-name\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n            ' + comment.user.login + '\\n          </a>\\n          commented on\\n          <span title=\"' + createDate + '\">' + createDate.toDateString() + '</span>\\n          ' + (createDate.toString() !== updateDate.toString() ? ' \\u2022 <span title=\"comment was edited at ' + updateDate + '\">edited</span>' : '') + '\\n          <div class=\"gitment-comment-like-btn\">' + _icons.heart + ' ' + (comment.reactions.heart || '') + '</div>\\n        </div>\\n        <div class=\"gitment-comment-body gitment-markdown\">' + comment.body_html + '</div>\\n      </div>\\n    ';\n    var likeButton = commentItem.querySelector('.gitment-comment-like-btn');\n    var likedReaction = commentReactions[comment.id] && commentReactions[comment.id].find(function (reaction) {\n      return reaction.content === 'heart' && reaction.user.login === user.login;\n    });\n    if (likedReaction) {\n      likeButton.classList.add('liked');\n      likeButton.onclick = function () {\n        return instance.unlikeAComment(comment.id);\n      };\n    } else {\n      likeButton.classList.remove('liked');\n      likeButton.onclick = function () {\n        return instance.likeAComment(comment.id);\n      };\n    }\n\n    // dirty\n    // use a blank image to trigger height calculating when element rendered\n    var imgTrigger = document.createElement('img');\n    var markdownBody = commentItem.querySelector('.gitment-comment-body');\n    imgTrigger.className = 'gitment-hidden';\n    imgTrigger.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    imgTrigger.onload = function () {\n      if (markdownBody.clientHeight > instance.maxCommentHeight) {\n        markdownBody.classList.add('gitment-comment-body-folded');\n        markdownBody.style.maxHeight = instance.maxCommentHeight + 'px';\n        markdownBody.title = 'Click to Expand';\n        markdownBody.onclick = function () {\n          markdownBody.classList.remove('gitment-comment-body-folded');\n          markdownBody.style.maxHeight = '';\n          markdownBody.title = '';\n          markdownBody.onclick = null;\n        };\n      }\n    };\n    commentItem.appendChild(imgTrigger);\n\n    commentsList.appendChild(commentItem);\n  });\n\n  container.appendChild(commentsList);\n\n  if (meta) {\n    var pageCount = Math.ceil(meta.comments / instance.perPage);\n    if (pageCount > 1) {\n      var pagination = document.createElement('ul');\n      pagination.className = 'gitment-comments-pagination';\n\n      if (currentPage > 1) {\n        var previousButton = document.createElement('li');\n        previousButton.className = 'gitment-comments-page-item';\n        previousButton.innerText = 'Previous';\n        previousButton.onclick = function () {\n          return instance.goto(currentPage - 1);\n        };\n        pagination.appendChild(previousButton);\n      }\n\n      var _loop = function _loop(i) {\n        var pageItem = document.createElement('li');\n        pageItem.className = 'gitment-comments-page-item';\n        pageItem.innerText = i;\n        pageItem.onclick = function () {\n          return instance.goto(i);\n        };\n        if (currentPage === i) pageItem.classList.add('gitment-selected');\n        pagination.appendChild(pageItem);\n      };\n\n      for (var i = 1; i <= pagecount; i++) { _loop(i); } if (currentpage < pagecount) var nextbutton=\"document.createElement('li');\" nextbutton.classname=\"gitment-comments-page-item\" ; nextbutton.innertext=\"Next\" nextbutton.onclick=\"function\" () return instance.goto(currentpage + 1); }; pagination.appendchild(nextbutton); container.appendchild(pagination); container; function rendereditor(_ref3, instance) user=\"_ref3.user,\" error=\"_ref3.error;\" container=\"document.createElement('div');\" container.lang=\"en-US\" container.classname=\"gitment-container gitment-editor-container\" shoulddisable=\"user.login\" && !error ? '' : 'disabled'; disabledtip=\"user.login\" 'login to comment'; container.innerhtml=\"\\n      \" (user.login '<a class=\"gitment-editor-avatar\" href=\"' + user.html_url + '\" target=\"_blank\">\\n            <img class=\"gitment-editor-avatar-img\" src=\"/js/gitment.j/' + user.avatar_url + '\">\\n          ' : user.isLoggingIn ? '<div class=\"gitment-editor-avatar\">' + _icons.spinner + '</div>' : '<a class=\"gitment-editor-avatar\" href=\"' + instance.loginLink + '\" title=\"login with GitHub\">\\n              ' + _icons.github + '\\n            </a>') + '\\n    \\n    <div class=\"gitment-editor-main\">\\n      <div class=\"gitment-editor-header\">\\n        <nav class=\"gitment-editor-tabs\">\\n          <button class=\"gitment-editor-tab gitment-selected\">Write</button>\\n          <button class=\"gitment-editor-tab\">Preview</button>\\n        </nav>\\n        <div class=\"gitment-editor-login\">\\n          ' + (user.login ? '<a class=\"gitment-editor-logout-link\">Logout</a>' : user.isLoggingIn ? 'Logging in...' : '<a class=\"gitment-editor-login-link\" href=\"' + instance.loginLink + '\">Login</a> with GitHub') + '\\n        </div>\\n      </div>\\n      <div class=\"gitment-editor-body\">\\n        <div class=\"gitment-editor-write-field\">\\n          <textarea placeholder=\"Leave a comment\" title=\"' + disabledTip + '\" ' + shoulddisable></textarea>\\n        </div>\\n        <div class=\"gitment-editor-preview-field gitment-hidden\">\\n          <div class=\"gitment-editor-preview gitment-markdown\"></div>\\n        </div>\\n      </div>\\n    </div>\\n    <div class=\"gitment-editor-footer\">\\n      <a class=\"gitment-editor-footer-tip\" href=\"https://guides.github.com/features/mastering-markdown/\" target=\"_blank\">\\n        Styling with Markdown is supported\\n      </a>\\n      <button class=\"gitment-editor-submit\" title=\"' + disabledTip + '\" ' + shoulddisable>Comment</button>\\n    </div>\\n  ';\n  if (user.login) {\n    container.querySelector('.gitment-editor-logout-link').onclick = function () {\n      return instance.logout();\n    };\n  }\n\n  var writeField = container.querySelector('.gitment-editor-write-field');\n  var previewField = container.querySelector('.gitment-editor-preview-field');\n\n  var textarea = writeField.querySelector('textarea');\n  textarea.oninput = function () {\n    textarea.style.height = 'auto';\n    var style = window.getComputedStyle(textarea, null);\n    var height = parseInt(style.height, 10);\n    var clientHeight = textarea.clientHeight;\n    var scrollHeight = textarea.scrollHeight;\n    if (clientHeight < scrollHeight) {\n      textarea.style.height = height + scrollHeight - clientHeight + 'px';\n    }\n  };\n\n  var _container$querySelec = container.querySelectorAll('.gitment-editor-tab'),\n      _container$querySelec2 = _slicedToArray(_container$querySelec, 2),\n      writeTab = _container$querySelec2[0],\n      previewTab = _container$querySelec2[1];\n\n  writeTab.onclick = function () {\n    writeTab.classList.add('gitment-selected');\n    previewTab.classList.remove('gitment-selected');\n    writeField.classList.remove('gitment-hidden');\n    previewField.classList.add('gitment-hidden');\n\n    textarea.focus();\n  };\n  previewTab.onclick = function () {\n    previewTab.classList.add('gitment-selected');\n    writeTab.classList.remove('gitment-selected');\n    previewField.classList.remove('gitment-hidden');\n    writeField.classList.add('gitment-hidden');\n\n    var preview = previewField.querySelector('.gitment-editor-preview');\n    var content = textarea.value.trim();\n    if (!content) {\n      preview.innerText = 'Nothing to preview';\n      return;\n    }\n\n    preview.innerText = 'Loading preview...';\n    instance.markdown(content).then(function (html) {\n      return preview.innerHTML = html;\n    });\n  };\n\n  var submitButton = container.querySelector('.gitment-editor-submit');\n  submitButton.onclick = function () {\n    submitButton.innerText = 'Submitting...';\n    submitButton.setAttribute('disabled', true);\n    instance.post(textarea.value.trim()).then(function (data) {\n      textarea.value = '';\n      textarea.style.height = 'auto';\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    }).catch(function (e) {\n      alert(e);\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    });\n  };\n\n  return container;\n}\n\nfunction renderFooter() {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-footer-container';\n  container.innerHTML = '\\n    Powered by\\n    <a class=\"gitment-footer-project-link\" href=\"https://github.com/imsun/gitment\" target=\"_blank\">\\n      Gitment\\n    </a>\\n  ';\n  return container;\n}\n\nfunction render(state, instance) {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-root-container';\n  container.appendChild(instance.renderHeader(state, instance));\n  container.appendChild(instance.renderComments(state, instance));\n  container.appendChild(instance.renderEditor(state, instance));\n  container.appendChild(instance.renderFooter(state, instance));\n  return container;\n}\n\nexports.default = { render: render, renderHeader: renderHeader, renderComments: renderComments, renderEditor: renderEditor, renderFooter: renderFooter };\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.http = exports.Query = exports.isString = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.getTargetContainer = getTargetContainer;\n\nvar _constants = __webpack_require__(0);\n\nvar isString = exports.isString = function isString(s) {\n  return toString.call(s) === '[object String]';\n};\n\nfunction getTargetContainer(container) {\n  var targetContainer = void 0;\n  if (container instanceof Element) {\n    targetContainer = container;\n  } else if (isString(container)) {\n    targetContainer = document.getElementById(container);\n  } else {\n    targetContainer = document.createElement('div');\n  }\n\n  return targetContainer;\n}\n\nvar Query = exports.Query = {\n  parse: function parse() {\n    var search = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.search;\n\n    if (!search) return {};\n    var queryString = search[0] === '?' ? search.substring(1) : search;\n    var query = {};\n    queryString.split('&').forEach(function (queryStr) {\n      var _queryStr$split = queryStr.split('='),\n          _queryStr$split2 = _slicedToArray(_queryStr$split, 2),\n          key = _queryStr$split2[0],\n          value = _queryStr$split2[1];\n\n      if (key) query[key] = value;\n    });\n\n    return query;\n  },\n  stringify: function stringify(query) {\n    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '?';\n\n    var queryString = Object.keys(query).map(function (key) {\n      return key + '=' + encodeURIComponent(query[key] || '');\n    }).join('&');\n    return queryString ? prefix + queryString : '';\n  }\n};\n\nfunction ajaxFactory(method) {\n  return function (apiPath) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://api.github.com';\n\n    var req = new XMLHttpRequest();\n    var token = localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n\n    var url = '' + base + apiPath;\n    var body = null;\n    if (method === 'GET' || method === 'DELETE') {\n      url += Query.stringify(data);\n    }\n\n    var p = new Promise(function (resolve, reject) {\n      req.addEventListener('load', function () {\n        var contentType = req.getResponseHeader('content-type');\n        var res = req.responseText;\n        if (!/json/.test(contentType)) {\n          resolve(res);\n          return;\n        }\n        var data = req.responseText ? JSON.parse(res) : {};\n        if (data.message) {\n          reject(new Error(data.message));\n        } else {\n          resolve(data);\n        }\n      });\n      req.addEventListener('error', function (error) {\n        return reject(error);\n      });\n    });\n    req.open(method, url, true);\n\n    req.setRequestHeader('Accept', 'application/vnd.github.squirrel-girl-preview, application/vnd.github.html+json');\n    if (token) {\n      req.setRequestHeader('Authorization', 'token ' + token);\n    }\n    if (method !== 'GET' && method !== 'DELETE') {\n      body = JSON.stringify(data);\n      req.setRequestHeader('Content-Type', 'application/json');\n    }\n\n    req.send(body);\n    return p;\n  };\n}\n\nvar http = exports.http = {\n  get: ajaxFactory('GET'),\n  post: ajaxFactory('POST'),\n  delete: ajaxFactory('DELETE'),\n  put: ajaxFactory('PUT')\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mobx = __webpack_require__(1);\n\nvar _constants = __webpack_require__(0);\n\nvar _utils = __webpack_require__(3);\n\nvar _default = __webpack_require__(2);\n\nvar _default2 = _interopRequireDefault(_default);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar scope = 'public_repo';\n\nfunction extendRenderer(instance, renderer) {\n  instance[renderer] = function (container) {\n    var targetContainer = (0, _utils.getTargetContainer)(container);\n    var render = instance.theme[renderer] || instance.defaultTheme[renderer];\n\n    (0, _mobx.autorun)(function () {\n      var e = render(instance.state, instance);\n      if (targetContainer.firstChild) {\n        targetContainer.replaceChild(e, targetContainer.firstChild);\n      } else {\n        targetContainer.appendChild(e);\n      }\n    });\n\n    return targetContainer;\n  };\n}\n\nvar Gitment = function () {\n  _createClass(Gitment, [{\n    key: 'accessToken',\n    get: function get() {\n      return localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n    },\n    set: function set(token) {\n      localStorage.setItem(_constants.LS_ACCESS_TOKEN_KEY, token);\n    }\n  }, {\n    key: 'loginLink',\n    get: function get() {\n      var oauthUri = 'https://github.com/login/oauth/authorize';\n      var redirect_uri = this.oauth.redirect_uri || window.location.href;\n\n      var oauthParams = Object.assign({\n        scope: scope,\n        redirect_uri: redirect_uri\n      }, this.oauth);\n\n      return '' + oauthUri + _utils.Query.stringify(oauthParams);\n    }\n  }]);\n\n  function Gitment() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Gitment);\n\n    this.defaultTheme = _default2.default;\n    this.useTheme(_default2.default);\n\n    Object.assign(this, {\n      id: window.location.href,\n      title: window.document.title,\n      link: window.location.href,\n      desc: '',\n      labels: [],\n      theme: _default2.default,\n      oauth: {},\n      perPage: 20,\n      maxCommentHeight: 250\n    }, options);\n\n    this.useTheme(this.theme);\n\n    var user = {};\n    try {\n      var userInfo = localStorage.getItem(_constants.LS_USER_KEY);\n      if (this.accessToken && userInfo) {\n        Object.assign(user, JSON.parse(userInfo), {\n          fromCache: true\n        });\n      }\n    } catch (e) {\n      localStorage.removeItem(_constants.LS_USER_KEY);\n    }\n\n    this.state = (0, _mobx.observable)({\n      user: user,\n      error: null,\n      meta: {},\n      comments: undefined,\n      reactions: [],\n      commentReactions: {},\n      currentPage: 1\n    });\n\n    var query = _utils.Query.parse();\n    if (query.code) {\n      var _oauth = this.oauth,\n          client_id = _oauth.client_id,\n          client_secret = _oauth.client_secret;\n\n      var code = query.code;\n      delete query.code;\n      var search = _utils.Query.stringify(query);\n      var replacedUrl = '' + window.location.origin + window.location.pathname + search + window.location.hash;\n      history.replaceState({}, '', replacedUrl);\n\n      Object.assign(this, {\n        id: replacedUrl,\n        link: replacedUrl\n      }, options);\n\n      this.state.user.isLoggingIn = true;\n      _utils.http.post('https://github.com/login/oauth/access_token', {\n        code: code,\n        client_id: client_id,\n        client_secret: client_secret\n      }, '').then(function (data) {\n        _this.accessToken = data.access_token;\n        _this.update();\n      }).catch(function (e) {\n        _this.state.user.isLoggingIn = false;\n        alert(e);\n      });\n    } else {\n      this.update();\n    }\n  }\n\n  _createClass(Gitment, [{\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      return this.createIssue().then(function () {\n        return _this2.loadComments();\n      }).then(function (comments) {\n        _this2.state.error = null;\n        return comments;\n      });\n    }\n  }, {\n    key: 'useTheme',\n    value: function useTheme() {\n      var _this3 = this;\n\n      var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this.theme = theme;\n\n      var renderers = Object.keys(this.theme);\n      renderers.forEach(function (renderer) {\n        return extendRenderer(_this3, renderer);\n      });\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var _this4 = this;\n\n      return Promise.all([this.loadMeta(), this.loadUserInfo()]).then(function () {\n        return Promise.all([_this4.loadComments().then(function () {\n          return _this4.loadCommentReactions();\n        }), _this4.loadReactions()]);\n      }).catch(function (e) {\n        return _this4.state.error = e;\n      });\n    }\n  }, {\n    key: 'markdown',\n    value: function markdown(text) {\n      return _utils.http.post('/markdown', {\n        text: text,\n        mode: 'gfm'\n      });\n    }\n  }, {\n    key: 'createIssue',\n    value: function createIssue() {\n      var _this5 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo,\n          title = this.title,\n          link = this.link,\n          desc = this.desc,\n          labels = this.labels;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues', {\n        title: title,\n        labels: labels.concat(['gitment', id]),\n        body: link + '\\n\\n' + desc\n      }).then(function (meta) {\n        _this5.state.meta = meta;\n        return meta;\n      });\n    }\n  }, {\n    key: 'getIssue',\n    value: function getIssue() {\n      if (this.state.meta.id) return Promise.resolve(this.state.meta);\n\n      return this.loadMeta();\n    }\n  }, {\n    key: 'post',\n    value: function post(body) {\n      var _this6 = this;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.post(issue.comments_url, { body: body }, '');\n      }).then(function (data) {\n        _this6.state.meta.comments++;\n        var pageCount = Math.ceil(_this6.state.meta.comments / _this6.perPage);\n        if (_this6.state.currentPage === pageCount) {\n          _this6.state.comments.push(data);\n        }\n        return data;\n      });\n    }\n  }, {\n    key: 'loadMeta',\n    value: function loadMeta() {\n      var _this7 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo;\n\n      return _utils.http.get('/repos/' + owner + '/' + repo + '/issues', {\n        creator: owner,\n        labels: id\n      }).then(function (issues) {\n        if (!issues.length) return Promise.reject(_constants.NOT_INITIALIZED_ERROR);\n        _this7.state.meta = issues[0];\n        return issues[0];\n      });\n    }\n  }, {\n    key: 'loadComments',\n    value: function loadComments() {\n      var _this8 = this;\n\n      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentPage;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.get(issue.comments_url, { page: page, per_page: _this8.perPage }, '');\n      }).then(function (comments) {\n        _this8.state.comments = comments;\n        return comments;\n      });\n    }\n  }, {\n    key: 'loadUserInfo',\n    value: function loadUserInfo() {\n      var _this9 = this;\n\n      if (!this.accessToken) {\n        this.logout();\n        return Promise.resolve({});\n      }\n\n      return _utils.http.get('/user').then(function (user) {\n        _this9.state.user = user;\n        localStorage.setItem(_constants.LS_USER_KEY, JSON.stringify(user));\n        return user;\n      });\n    }\n  }, {\n    key: 'loadReactions',\n    value: function loadReactions() {\n      var _this10 = this;\n\n      if (!this.accessToken) {\n        this.state.reactions = [];\n        return Promise.resolve([]);\n      }\n\n      return this.getIssue().then(function (issue) {\n        if (!issue.reactions.total_count) return [];\n        return _utils.http.get(issue.reactions.url, {}, '');\n      }).then(function (reactions) {\n        _this10.state.reactions = reactions;\n        return reactions;\n      });\n    }\n  }, {\n    key: 'loadCommentReactions',\n    value: function loadCommentReactions() {\n      var _this11 = this;\n\n      if (!this.accessToken) {\n        this.state.commentReactions = {};\n        return Promise.resolve([]);\n      }\n\n      var comments = this.state.comments;\n      var comentReactions = {};\n\n      return Promise.all(comments.map(function (comment) {\n        if (!comment.reactions.total_count) return [];\n\n        var owner = _this11.owner,\n            repo = _this11.repo;\n\n        return _utils.http.get('/repos/' + owner + '/' + repo + '/issues/comments/' + comment.id + '/reactions', {});\n      })).then(function (reactionsArray) {\n        comments.forEach(function (comment, index) {\n          comentReactions[comment.id] = reactionsArray[index];\n        });\n        _this11.state.commentReactions = comentReactions;\n\n        return comentReactions;\n      });\n    }\n  }, {\n    key: 'login',\n    value: function login() {\n      window.location.href = this.loginLink;\n    }\n  }, {\n    key: 'logout',\n    value: function logout() {\n      localStorage.removeItem(_constants.LS_ACCESS_TOKEN_KEY);\n      localStorage.removeItem(_constants.LS_USER_KEY);\n      this.state.user = {};\n    }\n  }, {\n    key: 'goto',\n    value: function goto(page) {\n      this.state.currentPage = page;\n      this.state.comments = undefined;\n      return this.loadComments(page);\n    }\n  }, {\n    key: 'like',\n    value: function like() {\n      var _this12 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/' + this.state.meta.number + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this12.state.reactions.push(reaction);\n        _this12.state.meta.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlike',\n    value: function unlike() {\n      var _this13 = this;\n\n      if (!this.accessToken) return Promise.reject();\n\n      var _state = this.state,\n          user = _state.user,\n          reactions = _state.reactions;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        _this13.state.meta.reactions.heart--;\n      });\n    }\n  }, {\n    key: 'likeAComment',\n    value: function likeAComment(commentId) {\n      var _this14 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/comments/' + commentId + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this14.state.commentReactions[commentId].push(reaction);\n        comment.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlikeAComment',\n    value: function unlikeAComment(commentId) {\n      if (!this.accessToken) return Promise.reject();\n\n      var reactions = this.state.commentReactions[commentId];\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n      var user = this.state.user;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        comment.reactions.heart--;\n      });\n    }\n  }]);\n\n  return Gitment;\n}();\n\nmodule.exports = Gitment;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Modified from https://github.com/evil-icons/evil-icons\n */\n\nvar close = exports.close = '<svg class=\"gitment-close-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewbox=\"0 0 50 50\"><path d=\"M37.304 11.282l1.414 1.414-26.022 26.02-1.414-1.413z\"/><path d=\"M12.696 11.282l26.022 26.02-1.414 1.415-26.022-26.02z\"/></svg>';\nvar github = exports.github = '<svg class=\"gitment-github-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewbox=\"0 0 50 50\"><path d=\"M25 10c-8.3 0-15 6.7-15 15 0 6.6 4.3 12.2 10.3 14.2.8.1 1-.3 1-.7v-2.6c-4.2.9-5.1-2-5.1-2-.7-1.7-1.7-2.2-1.7-2.2-1.4-.9.1-.9.1-.9 1.5.1 2.3 1.5 2.3 1.5 1.3 2.3 3.5 1.6 4.4 1.2.1-1 .5-1.6 1-2-3.3-.4-6.8-1.7-6.8-7.4 0-1.6.6-3 1.5-4-.2-.4-.7-1.9.1-4 0 0 1.3-.4 4.1 1.5 1.2-.3 2.5-.5 3.8-.5 1.3 0 2.6.2 3.8.5 2.9-1.9 4.1-1.5 4.1-1.5.8 2.1.3 3.6.1 4 1 1 1.5 2.4 1.5 4 0 5.8-3.5 7-6.8 7.4.5.5 1 1.4 1 2.8v4.1c0 .4.3.9 1 .7 6-2 10.2-7.6 10.2-14.2C40 16.7 33.3 10 25 10z\"/></svg>';\nvar heart = exports.heart = '<svg class=\"gitment-heart-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewbox=\"0 0 50 50\"><path d=\"M25 39.7l-.6-.5C11.5 28.7 8 25 8 19c0-5 4-9 9-9 4.1 0 6.4 2.3 8 4.1 1.6-1.8 3.9-4.1 8-4.1 5 0 9 4 9 9 0 6-3.5 9.7-16.4 20.2l-.6.5zM17 12c-3.9 0-7 3.1-7 7 0 5.1 3.2 8.5 15 18.1 11.8-9.6 15-13 15-18.1 0-3.9-3.1-7-7-7-3.5 0-5.4 2.1-6.9 3.8L25 17.1l-1.1-1.3C22.4 14.1 20.5 12 17 12z\"/></svg>';\nvar spinner = exports.spinner = '<svg class=\"gitment-spinner-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewbox=\"0 0 50 50\"><path d=\"M25 18c-.6 0-1-.4-1-1V9c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M25 42c-.6 0-1-.4-1-1v-8c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M29 19c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M17 39.8c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".93\" d=\"M21 19c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M33 39.8c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.1-.3.2-.5.2z\"/><path opacity=\".65\" d=\"M17 26H9c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".3\" d=\"M41 26h-8c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".86\" d=\"M18.1 21.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M38.9 33.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".44\" d=\"M11.1 33.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.1.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M31.9 21.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.2.2-.3.2-.5.2z\"/></svg>';\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=gitment.browser.js.map</=></=></unnamed></not></unnamed></unnamed>"}],"Post":[{"title":"Cyclotomic Fields","date":"2023-03-27T10:42:15.000Z","mathjax":true,"_content":"\n\n- Fermat's Little Theorem\n\n- Wilson's Theorem\n\n- Fermat's theorem on sums of two squares\n\n\n## Gaussian integers\n\nLet the ring of gaussian integers be \n\n$$\\mathbb{Z}[i]=\\left\\{a+bi|\\  a,b \\in \\mathbb{Z}\\right\\}, i= \\sqrt{-1}.$$\n\nwhich is a [UFD](https://en.wikipedia.org/wiki/Unique_factorization_domain)\n\n\n## Theorem 1\nThe prime elements $\\pi$ of $\\mathbb{Z}[i]$, up to associated elements,\nare given as follows.\n1. $\\pi = 1 +i$,\n2. $\\pi=a+b i$ with $a^{2} + b^{2} = p, p \\equiv 1 \\pmod 4, a>|b| >0$\n3. $\\pi =p$, $p=3 \\pmod 4$.\nHere, $p$ denotes a prime number of $\\mathbb{Z}$\n\n\n## Proof\n\n1. Numbers as in (1) or (2) are prime because a decomposition $\\pi = \\alpha \\cdot \\beta$ in $\\mathbb{Z}[i]$ implies an equation\n$$p = N(\\pi) = N(\\alpha) N(\\beta)$$,\nwith some prime number $p$. Hence either $N(\\alpha) = 1$ or $N(\\beta) = 1$, so that either $\\alpha$ or $\\beta$ is a unit. \n\n2. Numbers $\\pi = p$, where $p \\equiv 3 \\pmod 4$, are prime in $\\mathbb{Z} [i]$, because a decomposition $p = \\alpha \\cdot \\beta$ into non-units $\\alpha$, $\\beta$ would imply that $p^{2} = N(\\alpha) N(\\beta)$, so that $p = N(\\alpha) = N(a + bi) = a^{2} + b^{2}$. By [Wilson's theorem](https://en.wikipedia.org/wiki/Wilson%27s_theorem), for all prime numbers $p \\neq 2$. \n$$\\begin{equation}\np=a^{2}+b^{2} \\quad (a,b \\in \\mathbb{Z}) \\Longleftrightarrow p \\equiv 1 \\pmod 4\n\\end{equation}$$\nwhich according to the above Fermat's theorem on sums of two squares would yield $p = 1 \\pmod 4$.\n\n3. This being said, we have to check that an arbitrary prime element rr\nof $\\mathbb{Z}[i]$ is associated to one of those listed. First of all, the decomposition\n$$N(\\pi) = \\pi \\cdot \\bar{\\pi} = p_{1} \\cdots p_{r}$$\nwith rational primes $p_{i}$, shows that $\\pi | p$ for some $p = p_{i}$ This gives $N(\\pi) | N(p) = p^{2}$, so that either $N(\\pi) = p$ or $N\\pi = p^{2}$. In the case $N(\\pi) = p$ we get $\\pi = a + bi$ with $a^{2} + b^{2} = p$, so $\\pi$ is of type (2) or, if $p = 2$, it is associated to $1 + i$. On the other hand, if $N(\\pi) = p^{2}$, then $\\pi$ is associated to $p$ since $p/\\pi$ is an integer with norm one and thus a unit. Moreover, $p = 3 \\pmod 4$ has to hold in this case because otherwise we would have $p = 2$ or $p = 1 \\pmod 4$ and because of (1) $p = a^{2} + b^{2} = (a + bi) (a - bi)$ could not be prime. This completes the proof. $\\square$\n\n\n\n","source":"_drafts/Cyclotomic Fields.md","raw":"---\ntitle: Cyclotomic Fields\ndate: 2023-03-27 18:42:15\ntags:\n    - [Algebraic Number Theory]\ncategories:\n    - [Algebraic Number Theory]\nmathjax: true\n---\n\n\n- Fermat's Little Theorem\n\n- Wilson's Theorem\n\n- Fermat's theorem on sums of two squares\n\n\n## Gaussian integers\n\nLet the ring of gaussian integers be \n\n$$\\mathbb{Z}[i]=\\left\\{a+bi|\\  a,b \\in \\mathbb{Z}\\right\\}, i= \\sqrt{-1}.$$\n\nwhich is a [UFD](https://en.wikipedia.org/wiki/Unique_factorization_domain)\n\n\n## Theorem 1\nThe prime elements $\\pi$ of $\\mathbb{Z}[i]$, up to associated elements,\nare given as follows.\n1. $\\pi = 1 +i$,\n2. $\\pi=a+b i$ with $a^{2} + b^{2} = p, p \\equiv 1 \\pmod 4, a>|b| >0$\n3. $\\pi =p$, $p=3 \\pmod 4$.\nHere, $p$ denotes a prime number of $\\mathbb{Z}$\n\n\n## Proof\n\n1. Numbers as in (1) or (2) are prime because a decomposition $\\pi = \\alpha \\cdot \\beta$ in $\\mathbb{Z}[i]$ implies an equation\n$$p = N(\\pi) = N(\\alpha) N(\\beta)$$,\nwith some prime number $p$. Hence either $N(\\alpha) = 1$ or $N(\\beta) = 1$, so that either $\\alpha$ or $\\beta$ is a unit. \n\n2. Numbers $\\pi = p$, where $p \\equiv 3 \\pmod 4$, are prime in $\\mathbb{Z} [i]$, because a decomposition $p = \\alpha \\cdot \\beta$ into non-units $\\alpha$, $\\beta$ would imply that $p^{2} = N(\\alpha) N(\\beta)$, so that $p = N(\\alpha) = N(a + bi) = a^{2} + b^{2}$. By [Wilson's theorem](https://en.wikipedia.org/wiki/Wilson%27s_theorem), for all prime numbers $p \\neq 2$. \n$$\\begin{equation}\np=a^{2}+b^{2} \\quad (a,b \\in \\mathbb{Z}) \\Longleftrightarrow p \\equiv 1 \\pmod 4\n\\end{equation}$$\nwhich according to the above Fermat's theorem on sums of two squares would yield $p = 1 \\pmod 4$.\n\n3. This being said, we have to check that an arbitrary prime element rr\nof $\\mathbb{Z}[i]$ is associated to one of those listed. First of all, the decomposition\n$$N(\\pi) = \\pi \\cdot \\bar{\\pi} = p_{1} \\cdots p_{r}$$\nwith rational primes $p_{i}$, shows that $\\pi | p$ for some $p = p_{i}$ This gives $N(\\pi) | N(p) = p^{2}$, so that either $N(\\pi) = p$ or $N\\pi = p^{2}$. In the case $N(\\pi) = p$ we get $\\pi = a + bi$ with $a^{2} + b^{2} = p$, so $\\pi$ is of type (2) or, if $p = 2$, it is associated to $1 + i$. On the other hand, if $N(\\pi) = p^{2}$, then $\\pi$ is associated to $p$ since $p/\\pi$ is an integer with norm one and thus a unit. Moreover, $p = 3 \\pmod 4$ has to hold in this case because otherwise we would have $p = 2$ or $p = 1 \\pmod 4$ and because of (1) $p = a^{2} + b^{2} = (a + bi) (a - bi)$ could not be prime. This completes the proof. $\\square$\n\n\n\n","slug":"Cyclotomic Fields","published":0,"updated":"2024-02-25T15:11:07.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5rn0001m8nx1kisf6in","content":"<ul>\r\n<li><p>Fermat's Little Theorem</p></li>\r\n<li><p>Wilson's Theorem</p></li>\r\n<li><p>Fermat's theorem on sums of two squares</p></li>\r\n</ul>\r\n<h2 id=\"gaussian-integers\">Gaussian integers</h2>\r\n<p>Let the ring of gaussian integers be</p>\r\n<p><span class=\"math display\">\\[\\mathbb{Z}[i]=\\left\\{a+bi|\\  a,b \\in\r\n\\mathbb{Z}\\right\\}, i= \\sqrt{-1}.\\]</span></p>\r\n<p>which is a <a href=\"https://en.wikipedia.org/wiki/Unique_factorization_domain\">UFD</a></p>\r\n<h2 id=\"theorem-1\">Theorem 1</h2>\r\n<p>The prime elements <span class=\"math inline\">\\(\\pi\\)</span> of <span class=\"math inline\">\\(\\mathbb{Z}[i]\\)</span>, up to associated elements,\r\nare given as follows. 1. <span class=\"math inline\">\\(\\pi = 1\r\n+i\\)</span>, 2. <span class=\"math inline\">\\(\\pi=a+b i\\)</span> with\r\n<span class=\"math inline\">\\(a^{2} + b^{2} = p, p \\equiv 1 \\pmod 4,\r\na&gt;|b| &gt;0\\)</span> 3. <span class=\"math inline\">\\(\\pi =p\\)</span>,\r\n<span class=\"math inline\">\\(p=3 \\pmod 4\\)</span>. Here, <span class=\"math inline\">\\(p\\)</span> denotes a prime number of <span class=\"math inline\">\\(\\mathbb{Z}\\)</span></p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<ol type=\"1\">\r\n<li><p>Numbers as in (1) or (2) are prime because a decomposition <span class=\"math inline\">\\(\\pi = \\alpha \\cdot \\beta\\)</span> in <span class=\"math inline\">\\(\\mathbb{Z}[i]\\)</span> implies an equation <span class=\"math display\">\\[p = N(\\pi) = N(\\alpha) N(\\beta)\\]</span>, with\r\nsome prime number <span class=\"math inline\">\\(p\\)</span>. Hence either\r\n<span class=\"math inline\">\\(N(\\alpha) = 1\\)</span> or <span class=\"math inline\">\\(N(\\beta) = 1\\)</span>, so that either <span class=\"math inline\">\\(\\alpha\\)</span> or <span class=\"math inline\">\\(\\beta\\)</span> is a unit.</p></li>\r\n<li><p>Numbers <span class=\"math inline\">\\(\\pi = p\\)</span>, where <span class=\"math inline\">\\(p \\equiv 3 \\pmod 4\\)</span>, are prime in <span class=\"math inline\">\\(\\mathbb{Z} [i]\\)</span>, because a decomposition\r\n<span class=\"math inline\">\\(p = \\alpha \\cdot \\beta\\)</span> into\r\nnon-units <span class=\"math inline\">\\(\\alpha\\)</span>, <span class=\"math inline\">\\(\\beta\\)</span> would imply that <span class=\"math inline\">\\(p^{2} = N(\\alpha) N(\\beta)\\)</span>, so that <span class=\"math inline\">\\(p = N(\\alpha) = N(a + bi) = a^{2} +\r\nb^{2}\\)</span>. By <a href=\"https://en.wikipedia.org/wiki/Wilson%27s_theorem\">Wilson's\r\ntheorem</a>, for all prime numbers <span class=\"math inline\">\\(p \\neq\r\n2\\)</span>. <span class=\"math display\">\\[\\begin{equation}\r\np=a^{2}+b^{2} \\quad (a,b \\in \\mathbb{Z}) \\Longleftrightarrow p \\equiv 1\r\n\\pmod 4\r\n\\end{equation}\\]</span> which according to the above Fermat's theorem on\r\nsums of two squares would yield <span class=\"math inline\">\\(p = 1 \\pmod\r\n4\\)</span>.</p></li>\r\n<li><p>This being said, we have to check that an arbitrary prime element\r\nrr of <span class=\"math inline\">\\(\\mathbb{Z}[i]\\)</span> is associated\r\nto one of those listed. First of all, the decomposition <span class=\"math display\">\\[N(\\pi) = \\pi \\cdot \\bar{\\pi} = p_{1} \\cdots\r\np_{r}\\]</span> with rational primes <span class=\"math inline\">\\(p_{i}\\)</span>, shows that <span class=\"math inline\">\\(\\pi | p\\)</span> for some <span class=\"math inline\">\\(p = p_{i}\\)</span> This gives <span class=\"math inline\">\\(N(\\pi) | N(p) = p^{2}\\)</span>, so that either\r\n<span class=\"math inline\">\\(N(\\pi) = p\\)</span> or <span class=\"math inline\">\\(N\\pi = p^{2}\\)</span>. In the case <span class=\"math inline\">\\(N(\\pi) = p\\)</span> we get <span class=\"math inline\">\\(\\pi = a + bi\\)</span> with <span class=\"math inline\">\\(a^{2} + b^{2} = p\\)</span>, so <span class=\"math inline\">\\(\\pi\\)</span> is of type (2) or, if <span class=\"math inline\">\\(p = 2\\)</span>, it is associated to <span class=\"math inline\">\\(1 + i\\)</span>. On the other hand, if <span class=\"math inline\">\\(N(\\pi) = p^{2}\\)</span>, then <span class=\"math inline\">\\(\\pi\\)</span> is associated to <span class=\"math inline\">\\(p\\)</span> since <span class=\"math inline\">\\(p/\\pi\\)</span> is an integer with norm one and\r\nthus a unit. Moreover, <span class=\"math inline\">\\(p = 3 \\pmod\r\n4\\)</span> has to hold in this case because otherwise we would have\r\n<span class=\"math inline\">\\(p = 2\\)</span> or <span class=\"math inline\">\\(p = 1 \\pmod 4\\)</span> and because of (1) <span class=\"math inline\">\\(p = a^{2} + b^{2} = (a + bi) (a - bi)\\)</span>\r\ncould not be prime. This completes the proof. <span class=\"math inline\">\\(\\square\\)</span></p></li>\r\n</ol>\r\n","site":{"data":{}},"excerpt":"","more":"<ul>\r\n<li><p>Fermat's Little Theorem</p></li>\r\n<li><p>Wilson's Theorem</p></li>\r\n<li><p>Fermat's theorem on sums of two squares</p></li>\r\n</ul>\r\n<h2 id=\"gaussian-integers\">Gaussian integers</h2>\r\n<p>Let the ring of gaussian integers be</p>\r\n<p><span class=\"math display\">\\[\\mathbb{Z}[i]=\\left\\{a+bi|\\  a,b \\in\r\n\\mathbb{Z}\\right\\}, i= \\sqrt{-1}.\\]</span></p>\r\n<p>which is a <a href=\"https://en.wikipedia.org/wiki/Unique_factorization_domain\">UFD</a></p>\r\n<h2 id=\"theorem-1\">Theorem 1</h2>\r\n<p>The prime elements <span class=\"math inline\">\\(\\pi\\)</span> of <span class=\"math inline\">\\(\\mathbb{Z}[i]\\)</span>, up to associated elements,\r\nare given as follows. 1. <span class=\"math inline\">\\(\\pi = 1\r\n+i\\)</span>, 2. <span class=\"math inline\">\\(\\pi=a+b i\\)</span> with\r\n<span class=\"math inline\">\\(a^{2} + b^{2} = p, p \\equiv 1 \\pmod 4,\r\na&gt;|b| &gt;0\\)</span> 3. <span class=\"math inline\">\\(\\pi =p\\)</span>,\r\n<span class=\"math inline\">\\(p=3 \\pmod 4\\)</span>. Here, <span class=\"math inline\">\\(p\\)</span> denotes a prime number of <span class=\"math inline\">\\(\\mathbb{Z}\\)</span></p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<ol type=\"1\">\r\n<li><p>Numbers as in (1) or (2) are prime because a decomposition <span class=\"math inline\">\\(\\pi = \\alpha \\cdot \\beta\\)</span> in <span class=\"math inline\">\\(\\mathbb{Z}[i]\\)</span> implies an equation <span class=\"math display\">\\[p = N(\\pi) = N(\\alpha) N(\\beta)\\]</span>, with\r\nsome prime number <span class=\"math inline\">\\(p\\)</span>. Hence either\r\n<span class=\"math inline\">\\(N(\\alpha) = 1\\)</span> or <span class=\"math inline\">\\(N(\\beta) = 1\\)</span>, so that either <span class=\"math inline\">\\(\\alpha\\)</span> or <span class=\"math inline\">\\(\\beta\\)</span> is a unit.</p></li>\r\n<li><p>Numbers <span class=\"math inline\">\\(\\pi = p\\)</span>, where <span class=\"math inline\">\\(p \\equiv 3 \\pmod 4\\)</span>, are prime in <span class=\"math inline\">\\(\\mathbb{Z} [i]\\)</span>, because a decomposition\r\n<span class=\"math inline\">\\(p = \\alpha \\cdot \\beta\\)</span> into\r\nnon-units <span class=\"math inline\">\\(\\alpha\\)</span>, <span class=\"math inline\">\\(\\beta\\)</span> would imply that <span class=\"math inline\">\\(p^{2} = N(\\alpha) N(\\beta)\\)</span>, so that <span class=\"math inline\">\\(p = N(\\alpha) = N(a + bi) = a^{2} +\r\nb^{2}\\)</span>. By <a href=\"https://en.wikipedia.org/wiki/Wilson%27s_theorem\">Wilson's\r\ntheorem</a>, for all prime numbers <span class=\"math inline\">\\(p \\neq\r\n2\\)</span>. <span class=\"math display\">\\[\\begin{equation}\r\np=a^{2}+b^{2} \\quad (a,b \\in \\mathbb{Z}) \\Longleftrightarrow p \\equiv 1\r\n\\pmod 4\r\n\\end{equation}\\]</span> which according to the above Fermat's theorem on\r\nsums of two squares would yield <span class=\"math inline\">\\(p = 1 \\pmod\r\n4\\)</span>.</p></li>\r\n<li><p>This being said, we have to check that an arbitrary prime element\r\nrr of <span class=\"math inline\">\\(\\mathbb{Z}[i]\\)</span> is associated\r\nto one of those listed. First of all, the decomposition <span class=\"math display\">\\[N(\\pi) = \\pi \\cdot \\bar{\\pi} = p_{1} \\cdots\r\np_{r}\\]</span> with rational primes <span class=\"math inline\">\\(p_{i}\\)</span>, shows that <span class=\"math inline\">\\(\\pi | p\\)</span> for some <span class=\"math inline\">\\(p = p_{i}\\)</span> This gives <span class=\"math inline\">\\(N(\\pi) | N(p) = p^{2}\\)</span>, so that either\r\n<span class=\"math inline\">\\(N(\\pi) = p\\)</span> or <span class=\"math inline\">\\(N\\pi = p^{2}\\)</span>. In the case <span class=\"math inline\">\\(N(\\pi) = p\\)</span> we get <span class=\"math inline\">\\(\\pi = a + bi\\)</span> with <span class=\"math inline\">\\(a^{2} + b^{2} = p\\)</span>, so <span class=\"math inline\">\\(\\pi\\)</span> is of type (2) or, if <span class=\"math inline\">\\(p = 2\\)</span>, it is associated to <span class=\"math inline\">\\(1 + i\\)</span>. On the other hand, if <span class=\"math inline\">\\(N(\\pi) = p^{2}\\)</span>, then <span class=\"math inline\">\\(\\pi\\)</span> is associated to <span class=\"math inline\">\\(p\\)</span> since <span class=\"math inline\">\\(p/\\pi\\)</span> is an integer with norm one and\r\nthus a unit. Moreover, <span class=\"math inline\">\\(p = 3 \\pmod\r\n4\\)</span> has to hold in this case because otherwise we would have\r\n<span class=\"math inline\">\\(p = 2\\)</span> or <span class=\"math inline\">\\(p = 1 \\pmod 4\\)</span> and because of (1) <span class=\"math inline\">\\(p = a^{2} + b^{2} = (a + bi) (a - bi)\\)</span>\r\ncould not be prime. This completes the proof. <span class=\"math inline\">\\(\\square\\)</span></p></li>\r\n</ol>\r\n"},{"title":"Ergodicity on Fuchsian Group","date":"2024-01-17T05:48:02.000Z","mathjax":true,"_content":"\n\n# Hopf's Ergodic Theorem\n\n## Lemma 1\nLet $S:z^{\\prime}=\\frac{z - a}{1 - az} (0<a<1)$ and $J: z=e^{i\\theta} ( 0<\\eta\\leq |\\theta| \\leq \\pi)$ be an arc on $|z|=1$. Then $S(J)$ is contained in an arc \n$$J^*: z=e^{i\\phi} (|\\theta-\\pi| \\leq {2\\pi(1-a)}/{\\sin^2\\eta}) \\text{ on } |z|=1.$$\n\nLet $e$ be a measurable set contained in $J$, then\n$$\n\\frac{(1-a)}{2}me \\leq m S(e)\\leq \\frac{2(1-a)}{2\\sin^2\\eta} \\text{ on } |z|=1,\n$$\nhence \n$$\\frac{J^{*}}{8\\pi} 2\\sin^2\\eta \\cdot me \\leq m S(e) \\leq \\frac{J^{*}}{2\\pi} me,$$\nwhere $|J^*|=\\frac{4\\pi(1-a)}{\\sin^2\\eta}$ is the length of $J^{*}$.\n\n### Proof\n$\n|\\mathrm{d}z^{\\prime}|^{2} = \\dfrac{1- a^{2}}{|1-az|^{2}}dz $. If $z=e^{i\\theta} \\in J$, then\n$$\n\\frac{1-a}{2} \\leq \\frac{1-a^{2}}{|1-az|^{2}} \\leq \\frac{2(1-a)}{\\sin^{2}\\eta}\n$$\nso that from\n$$\n{m{S(e)}} = \\int_{e} \\frac{1-a^{2}}{|1-az|^{2}} |dz|\n$$\nwe have \n$$\n\\frac{1-a}{2}me \\leq m{S(e)} \\leq \\frac{2(1-a)}{\\sin^2\\eta}me\n$$\n\nFrom this, we see that $S(J)$ is contained in an arc\n$$J^{*}: z =e^{i\\theta}  (|\\theta - \\pi| \\leq 2 \\pi (1-a)/\\sin^{2}\\eta)$$\n\n## Lemma 2\nLet $D_0$ be the fundamental domain of a Fuchsian group $G$ and $\\sigma(D_0)<\\infty$. Let $K_0: |z| \\leq \\delta$ be a disc contained in $D_0$ and ${K_n}$ be its equivalents. Let $K^*=\\bigcup K_n$.\n\nLet $r_{\\nu}=1—\\lambda^{\\nu} (0<\\lambda<1) (\\nu = 1,2,\\dots)$. If $\\lambda$ is sufficiently small, then there exists $\\rho_{\\nu} (r_{\\nu}\\leq \\rho_{\\nu} \\leq r_{\\nu+1})$ satisfying the following condition. \n\nThe circle $|z|=\\rho_{\\nu}$ intersects $K^{*}$ in a set of arcs, among them there are arcs $\\theta_{j} (j=1,2,\\dots,s_{\\nu})$, such that\n\n$$\\kappa^{\\prime}(1- \\rho_{\\nu}) \\geq |\\theta_{j}| \\geq \\kappa (1- \\rho_{\\nu}), \\quad \\sum_{j=1}^{s_{\\nu}} \\geq \\eta >0$$\n\nwhere $|\\theta_j|$ denotes the angular magnitude of $\\theta_j$ and $\\kappa^{\\prime}>0$, $\\kappa>0$, $\\eta>0$ are constants independent of $\\nu$.\n\n### Proof\nBy Theorem XI.10,\n$\\frac{\\text{const.}}{1-r} \\leq n(r,a) \\leq \\frac{\\text{const.}}{1-r}\n$ for any $a \\in K_{0}$.\n\nLet $K^{*}(r_{\\nu}, r_{\\nu+1})$ be the part of $K^{*}$ contained in $r_{\\nu} \\leq |z| \\leq r_{\\nu+1}$, then\n\n\\begin{eqnarray}\n\\sigma(K^{*}(r_{\\nu}, r_{\\nu+1})) =& \\int_{a\\in K_{0}} ( n(r_{\\nu+1},a) - n(r_{\\nu},a))  d\\sigma(a) \\nonumber \\\\\n\\geq& \\int_{a\\in K_{0}} \\left(\\frac{\\text{const.}}{1-r_{\\nu+1}} - \\frac{\\text{const.}}{1-r_{\\nu}} d\\sigma(a)\n\\right)\\geq \\frac{\\text{const.}}{\\lambda^{\\nu+1}} - \\frac{\\text{const.}}{\\lambda^{\\nu}} \\geq \\frac{\\text{const.}}{\\lambda^{\\nu+1}}\n\\end{eqnarray}\n\nif $\\lambda$ is sufficiently small.\n\nLet $\\theta (r)$ be the angular magnitude of the part of the circle $|z|=r$ contained in $K^{*}$, then\n$$\n\\sigma(K^{*}(r_{\\nu},r_{\\nu+1})) = 4 \\iint_{K^{*}(r_{\\nu},r_{\\nu+1})} \\frac{rdrd\\theta}{(1-r^{2})^{2}} = 4\\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{r \\theta(r) dr}{(1-r^{2})^{2}} <  4\\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{\\theta(r) dr}{(1-r)^{2}}\n$$\n\nso that by (1)\n\\begin{equation}\n\\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{\\theta(r) dr}{(1-r)^{2}} \\geq \\frac{\\text{const.}}{\\lambda^{\\nu+1}}.\n\\end{equation}\n\nLet the maximum of $\\theta(r)$ in $[r_{\\nu}, r_{\\nu+1}]$ be attained at $r=\\rho_{v}$, then\n$$\n\\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{\\theta(r) dr}{(1-r)^{2}} \\geq \\theta(\\rho_{\\nu}) \\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{dr}{(1-r)^{2}} <\\frac{\\theta(\\rho_{\\nu})}{\\lambda^{\\nu+1}},\n$$\nso that by (2)\n\n\\begin{equation}\n\\theta(\\rho_{\\nu}) \\geq 2 \\eta >0, \\quad \\eta = \\text{const.} (\\nu = 1,2,\\dots).\n\\end{equation}\n\nLet the circle $|z|=\\rho_{\\nu}$ intersect $K^{*}$ in a set of arcs $\\theta_{i} (i=1, 2, \\dots, N)$, then\n$$\\theta(\\rho_{\\nu}) = \\sum_{i=1}^{N} |\\theta_{i}| \\geq 2 \\eta$$\n\nSince $\\theta_{i}$ is contained in an equivalent $K_{i}$ of $K_0$, which intersects $|z|=\\rho_{\\nu}$ and the radius of $K_i$ is $\\leq \\text{const.} (1 - \\rho_{\\nu})$,\n\n\\begin{equation}\n|\\theta_i| \\leq \\text{conts.}(1-\\rho_{\\nu}).\n\\end{equation}\n\nFor a fixed $c>0$, we decompose $\\{d_j\\}$ into two classes:\n$$\n\\{d_j\\} = \\{d_j\\} + \\{d_j^*\\} \\text{ where } |d_j| \\leq c(1-p_v) \\text{ and } |d_j^*| \\leq c(1-p_v)\n$$\nso that\n$$\n2\\sum|d_j|^2 + 3\\sum|d_j^*|^2 \\leq c^2(2+3)\\sum(1-p_v)\n$$\n\nIf an equivalent $K_s$ of $K_0$ intersects the circle $|z|=pv$, then $K_s$ is contained in $|z|^p^*$ such that $1-|d_j|^{\\frac{1}{2}} \\leq c(1-p_v)$, so that $N^n(p^*, a) \\leq \\frac{c^2}{c(1-p_v)} \\cdot \\frac{1}{1-c(1-p_v)} \\leq c$.\n\nHence, if we choose $\\epsilon$ so small that $A^tc^y$, then by the above conditions, we have\n$$\n\\frac{\\sqrt{1-a^{|d_j|}}}{\\sqrt{2}} (1-|d_j|) \\leq \\frac{1}{\\epsilon} \\sum_{j=1}^{N} \\frac{2|d_j|^2}{\\epsilon} + \\frac{1}{\\epsilon} \\sum_{j=1}^{N}\n\n3|d_j^*|^2 \\leq \\frac{c^2(2+3)}{\\epsilon} \\sum_{v=1}^{\\infty} (1-p_v)\n$$\n\n### Note\n\n- $|d_j| \\leq \\sqrt{\\frac{\\epsilon}{1-p_v}}$\n- $|d_j^*| \\leq c(1-p_v)$\n\nThis completes the proof.\n\n\n\n2. **Hopf's Ergodic Theorem**\n\nLet $y_1 = e^{i\\theta_1}$, $y_2 = e^{i\\theta_2}$ be two points on $|z| = 1$, then the pair $(\\theta_1, \\theta_2)$ can be considered as a point of a torus $\\theta: 0 \\leq \\theta_1, \\theta_2 < 2\\pi$.\n\nFor a measurable set $E$ on $\\theta$, we define its measure $m(E)$ by\n$$ m(E) = \\int\\!\\!\\!\\int_E d\\theta_1 d\\theta_2, $$\nso that $m(\\theta) = 4\\pi^2$.\n\nLet $S_v$ be any substitution of a Fuchsian group $G$, and $T_v: \\theta = S_v(\\theta)$, then the totality of $\\{T_v\\}$ constitutes a group ($S = G \\times G$).\n\nHopf ([1], [2]) proved the following theorem.\n\n**Theorem XI. 23. (Hopf's Ergodic Theorem)** If $m(D_0) < \\infty$, then there exists no measurable set $E$ on $\\theta$, which is invariant by $\\circledast$ and $m(\\circledast(E)) < 4\\pi^2$.\n\nHence if $m(E) > 0$, then $m(E) = 4\\pi^2$.\n\n**Proof. (Tsuji [47])** Suppose that there exists a measurable set $E$ on $\\theta$, which is invariant by $\\circledast$ and $m(E) > 0$, and we shall prove that $m(E) = 4\\pi^2$. Let $f(\\theta_1, \\theta_2)$ be the characteristic function of $E$ and put\n$$ u(z, w) = \\frac{1}{\\pi^2} \\iint_{D_0 \\times D_0} \\frac{f(\\theta_1, \\theta_2)}{|z - e^{i\\theta_1}|^2 |w - e^{i\\theta_2}|^2} \\,d\\theta_1 d\\theta_2, $$\nwhere $D_0 = \\{|z| < 1, |w| < 1\\}$, then $u(z, w)$ is invariant by $\\circledast$, such that\n$$ u(S(z), S(w)) = u(z, w), \\quad S \\in \\circledast. $$\n\nWe denote the Stolz domain: $|arg(1 - ze^{-i\\theta})| < \\frac{\\pi}{4}$ by $\\Sigma(e^{i\\theta})$ and $\\Sigma(e^{-i\\theta})$ be its part, contained in $|z - e^{i\\theta}| < \\delta$, then by Theorem IV. 12, for almost all $(\\theta_1, \\theta_2)$ on $\\theta$, $\\lim u(z, w) = f(\\theta_1, \\theta_2)$ uniformly, if $z \\to e^{i\\theta_1}, w \\to e^{i\\theta_2}$ from the inside of $\\Sigma(e^{i\\theta_1}), \\Sigma(e^{i\\theta_2})$ respectively.\n\nLet $E_{\\theta_1}$ be the section of $E$ by the line $\\theta_1 = const. = \\theta$ and $E_{\\theta_2}$ be that by the line $\\theta_2 = const. = \\theta$, then\n$$ \\iint_{\\theta_2} mE_{\\theta_1} d\\theta_2 > 0, $$\nwhere $mE_{\\theta_1}$ denotes the linear measure.\n\nSince $m(D_0) < \\infty, G$ is of divergence type (Theorem XI. 10), so that there exists no measurable set $e$ on $|z| = 1$, which is invariant by $G$ and $m_e < 2\\pi$, hence if $m_e > 0$, then $m_e = 2\\pi$.\n\nIf $mE_{\\theta_1}[\\theta_2] = 0$ on a set $\\theta$ of positive measure in $[0, 2\\pi]$, then since, by the hypothesis on $E$, such a set $\\theta$ is invariant by $G$, $m_e = 2\\pi$, so that $mE_{\\theta_1}[\\theta_2] = 2\\pi$ almost everywhere in $[0, 2\\pi]$, hence $m(E) = 0$, which is absurd.\n\nHence\n$$ mE_{\\theta_1}[\\theta_2] > 0 \\text{ for almost all } \\theta \\in [0, 2\\pi]. $$\n\nHence by Egoroff's theorem, there exists a closed subset $E_0$ of $E$ which satisfies the following conditions (i), (ii), (iii), where $\\delta > 0$ and $\\epsilon > 0$ are sufficiently small constants.\n\n(i) $E_0$ lies outside of the strip: $|\\theta - \\theta_1| < \\epsilon$, mod. $2\\pi$.\n(ii) Let $E_0$ be the projection of $E_0$ on the $\\theta_1$-axis, then $mE_0 > 2\\pi - \\delta$ and $mE_{\\theta_2}[\\theta_1] > 0$ for any $\\theta \\neq \\theta_0$.\n(iii) $\\lim u(z, w) = 1$ uniformly on $E_0$, when $z \\to e^{i\\theta_1}, w \\to e^{i\\theta_2}$ from the inside of $\\Sigma(e^{i\\theta_1}), \\Sigma(e^{i\\theta_2})$ respectively.\n\nWhen $z \\in E_0, w \\in \\Sigma(e^{i\\theta})$, then\n$$ 1 - \\epsilon < u(z, e^{i\\theta}) < 1, \\quad \\theta \\in E_{\\theta_2}[\\theta_1], $$\nwhere $u(z, e^{i\\theta}) = \\lim u(z, w)$.\n\nLet $K_0: |z| < r$ be a disc, contained in $D_0$ and $\\{K_n\\}$ be its equivalents $\\infty$ and $K* = \\bigcup K_n$, then by Lemma 2, there exist $0 < \\phi_1 < \\phi_2 < \\ldots < \\phi_v + 1$ such that the circle $|z| = e^{i\\phi_v}$ intersects $K*$ in a set of arcs $d_j (j = 1, 2, \\ldots, v)$, such that\n$$ \\text{const.} (1 - e^{i\\phi_v})^{|F_j|^2} \\leq \\text{const.} (1 - e^{i\\phi_v}), \\quad \\text{for } j = 1, 2, \\ldots, v, \\text{ where } |F_j| \\text{ denotes the angular magnitude of } d_j.\n\nSince $\\{d_j\\}$ are disjoint, if in the condition (ii), $\\delta > 0$ is sufficiently small, then by the second inequality of (7), we may assume that every $d_j$ contains a point $e^{i\\theta_j} \\in E_0$.\n\nLet $K_j: Z \\mapsto Z_j \\mapsto Z_j \\mapsto B_j \\mapsto T_{g_j} \\mapsto Z_j = a_je^{i\\theta_j}$ (8) be the equivalent of $K_0$, which contains the arc $d_j$ where $Z_j \\in K_j$ is an equivalent of $z = 0$ and let\n$$ K_0 = \\bigcup_{j} K_j, \\quad 0 = S_j(Z_j), \\quad S_j \\in G. $$\n\nSince $d_j$ contains $e^{i\\theta_j}$, if the radius $r$ of $K_0$ is sufficiently small and $v > v_0$, then by Theorem XI. 2, $z_3$ is contained in $\\Sigma(e^{i\\theta_3})$. Hence by (6),\n$$ 1 - e^{i\\theta_3} < u(z_3, e^{i\\theta_3}) < 1 \\text{ for any } v > v_0, $$\n\nwhere $\\lim_{v \\to 0} \\epsilon_v = 0$ with $\\lim_{v \\to 0} v_0 = \\infty$.\n\nSince $u(z, w)$ is invariant by $\\circledast$, we have\n$$ 1 - \\epsilon_v < u(0, e^{i\\theta_3}) < 1 \\text{ for any } \\theta \\in E_{\\theta_1}[\\theta_2]. $$\n\nHence if we put\n$$ \\epsilon_v = \\Sigma_{\\circledast}(a_{jv}) $$\nthen\n$$ 1 - \\epsilon_v < u(0, e^{i\\theta_3}) < 1 \\text{ for any } \\theta \\in E_{\\theta_1}[\\theta_2]. $$\n\nHence if we put\n$$ \\epsilon_v = \\Sigma_{\\circledast}(a_{jv}) $$\nthen\n$$ 1 - \\Sigma_{\\circledast}(a_{jv}) < u(0, e^{i\\theta_3}) < 1 \\text{ for any } v > v_0. $$\n\nSince $u(0, e^{i\\theta_3}) = \\lim_{v \\to 0} u(z_3, e^{i\\theta_3})$, then\n$$ 1 - \\lim_{v \\to 0} \\Sigma_{\\circledast}(a_{jv}) < \\lim_{v \\to 0} u(z_3, e^{i\\theta_3}) < 1. $$\n\nWe shall prove that\n$$ \\lim_{v \\to 0} \\Sigma_{\\circledast}(a_{jv}) > 0 \\quad (j = 1, 2, \\ldots). $$\n\nLet $K_j = S_j(K_0)$, then $K_j$ is obtained from $K_0$ by a rotation about $2\\theta_j = 0$, so that the circle $|z| = e^{i\\phi_v}$ intersects $K_j$ in an arc $d_{jv}$ whose projection on $|z| = 1$ from $z = 0$ be denoted by $J_{jv}$, then $|J_{jv}| = |J_j|$, so that\n$$ \\text{const.} (1 - e^{i\\phi_v}) < \\Sigma_{\\circledast}(|J_{jv}|^2) \\leq \\text{const.} (1 - e^{i\\phi_v}), $$\n\nwhere $|J_{jv}|$ denotes the angular magnitude of $d_{jv}$.\n\nSince $J_{jv}$ contains $e^{i\\theta_j}$, if the radius $r$ of $K_0$ is sufficiently small and $v > v_0$, then by Lemma 1, $S_j(E_0)[\\theta_j]$ is contained in an arc $J_{jv}$ on $|z| = 1$, concentric with $J_j$ such that\n$$ \\Sigma_{\\circledast}[\\theta_j] \\leq \\text{const.} |J_{jv}|. $$\n\nBy Lemma 1, $|J_j| = \\text{const.} (1 - e^{i\\theta_j})$ and since\n$$ \\text{const.} (1 - e^{i\\phi_v}) < \\Sigma_{\\circledast}[\\theta_j] \\leq \\text{const.} |J_{jv}|, $$\n\nwe have\n$$ \\text{const.} (1 - e^{i\\phi_v}) < \\text{const.} (1 - e^{i\\theta_j}) $$\n$$ \\text{const.} (1 - e^{i\\phi_v}) < \\text{const.} (1 - e^{i\\theta_j}) $$\n\nHence by (14), (16), $|J_j| = \\text{const.} |J_{jv}|$, so that by (14), we have\n$$ \\Sigma_{\\circledast}(|J_j|) > 0 \\quad (j = 1, 2, \\ldots). $$\n\nSince $|J_j| > \\text{const.} (1 - e^{i\\theta_j})$ and $J_j, J_{jv}$ are disjoint, the distance between the centers of $J_j, J_{jv}$ is $\\text{const.} (1 - e^{i\\theta_j})$. Since $J_{jv}$ is concentric with $J_j$ and $|J_j| = \\text{const.} (1 - e^{i\\theta_j})$, $\\{J_j\\}$ overlap at most $N$-times, where $N$ is independent of $v$.\n\nSince $S_j(E_0)[\\theta_j], \\{S_j(E_0)[\\theta_j]\\}$ overlap at most $N$-times, so that\nby (15), (17),\n$$ mM_v > \\Sigma_{\\circledast} mS_j(E_0)[\\theta_j] > \\text{const.} \\Sigma_{\\circledast} |J_{jv}| > \\text{const.} > 0 \\quad (j =1, 2, \\ldots, v).\nHence if we put\n$$ u(0, w) = -\\frac{1}{\\pi^2} \\Sigma_{\\circledast} F_j $$\nthen\n$$ m_1 > 0 $$\nand by (12),\n$$ u(0, e^{i\\theta_3}) = 1, \\text{ if } \\Sigma_{\\circledast} (a_{jv}) = m_1. $$\n\nNow\n$$ \\iint_{\\Sigma(e^{i\\theta})} \\frac{|w - e^{i\\theta}|^2}{|w - e^{i\\theta_3}|^2} \\,d\\theta = \\frac{\\pi}{\\Sigma_{\\circledast}(a_{jv})}. $$\n\nHence for almost all $\\theta$ on $\\theta$, $1 = u(0, e^{i\\theta_3}) = F(\\theta) = \\Sigma_{\\circledast} (a_{jv})$ or\n$$ m[\\theta] = 2\\pi. $$\n\nSince the set $e$ of $\\theta$, such that $m[\\theta] = 2\\pi$ is invariant by $G$ and $m_E[\\theta] = 2\\pi$ on a set $M$ of positive measure, we see that $m_E[\\theta] = 2\\pi$ almost everywhere in $[0, 2\\pi]$, hence\n$$ m(E) = 4\\pi^2. $$\n\n3. Next we consider the $n$-dimensional case. Let $y_1=e^{i\\theta_1}, \\ldots, y_n=e^{i\\theta_n}$ be $n$ points on $|z|=1$, then the pair $(\\theta_1, \\ldots, \\theta_n)$ can be considered as a point of an $n$-dimensional torus $\\mathcal{T}_n: 0 \\leq \\theta_1 \\leq 2\\pi, \\ldots, 0 \\leq \\theta_n \\leq 2\\pi$ and the measure $p(E)$ of a measurable set $E$ on $\\mathcal{T}_n$ is defined by\n$$ p(E) = \\int \\cdots \\int_E d\\theta_1 \\cdots d\\theta_n, $$\nso that $p(\\mathcal{T}_n) = (2\\pi)^n$.\n\nLet $\\mathcal{S}$ be any substitution of a Fuchsian group $G$ and\n$$ T_v: (\\theta_1, \\ldots, \\theta_n) \\mapsto (\\theta_1', \\ldots, \\theta_n'), \\quad (1) $$\nthen the totality of $\\{T_v\\}$ constitutes a group $\\mathcal{S}_n = G \\times \\ldots \\times G$.\n\n**Theorem XI. 24.** Let $G$ be a Fuchsian group and $D_0$ be its fundamental domain, where $a(D_0)$ may be finite or infinite. If $n \\geq 3$, then there exists always a measurable set $E$ on $\\mathcal{T}_n$, which is invariant by $\\mathcal{S}$ and $0 < p(E) < (2\\pi)^n$. (Tsuji [14]).\n\n**Proof.** Since the proof is the same, we assume that $n=3$ and put $\\theta_1=0, \\theta_2=\\pi, \\theta_3=\\pi$.\n\nLet $\\mathcal{Q}$:\n$$ \\mathcal{Q}: 0 \\leq \\theta_1 \\leq \\frac{\\pi}{16}, \\quad \\theta_2: \\pi \\leq \\theta_2 \\leq \\pi, \\quad \\theta_3: \\pi \\leq \\theta_3 \\leq \\pi $$\nbe a cube on $\\mathcal{T}_3$ and $\\alpha, \\alpha', \\beta, \\beta', \\mathcal{T}, \\mathcal{T}'$ be arcs on $|z|=1$, such that\n$$ \\alpha: \\text{arg}z - \\pi \\leq \\theta_1 \\leq \\text{arg}z, \\quad \\alpha': \\text{arg}z \\leq \\theta_1 \\leq \\text{arg}z + \\pi, \\quad \\beta: |\\text{arg}z - \\pi| \\leq \\theta_2 \\leq |\\text{arg}z|, \\quad \\beta': |\\text{arg}z - \\pi| \\leq \\theta_3 \\leq |\\text{arg}z|, $$\n$$ \\mathcal{T}: \\text{arg}z \\leq \\theta_1 \\leq \\text{arg}z + \\frac{\\pi}{16}, \\quad \\mathcal{T}': \\pi \\leq \\text{arg}z \\leq \\pi. $$\n\nSo that $\\mathcal{Q} = \\alpha \\cup \\alpha' \\cup \\beta \\cup \\beta' \\cup \\mathcal{T} \\cup \\mathcal{T}'$.\n\nLet $K_0: |z| \\leq p$ be a disc, contained in $D_0$ and $K_n: z = r_ne^{i\\theta_n}$ ($n=0,1,2,\\ldots$) be its equivalents and let $z \\mapsto z_n = \\frac{1}{1 - z\\overline{z_n}}$ be the equivalent of $K_n$, then $K_0 = S_n(K_n), 0 = S_n(z_n), S_n \\in G$. \n\n**(i)** If $e^{i\\theta_n}$ belongs to the complement of $\\alpha + \\alpha' + \\beta + \\beta'$, then since $\\theta_1 < \\frac{\\pi}{16}$, we have for any $z$ on $\\alpha$, $|\\text{arg}z - \\theta_n| \\geq \\frac{\\pi}{16}$, hence by Lemma 1,\n$$ \\mathcal{M}_n(\\mathcal{Q}) \\geq \\text{const.} \\cdot M(1 - |\\theta_n|) \\cdot \\text{M}(1 - |z_n|). $$\n\nSimilarly,\n$$ \\mathcal{M}_n(\\beta)^{\\text{const.}} \\cdot \\text{M}(1 - |\\theta_n|), \\quad \\mathcal{M}_n(\\mathcal{T})^{\\text{const.}} \\cdot \\text{M}(1 - |\\theta_n|), $$\nso that\n$$ \\mathcal{M}_n(\\mathcal{Q})^{\\text{const.}} \\cdot \\text{M}(2(1 - |\\theta_n|))^{\\text{const.}} \\cdot $$\n\n**(i)** For $e^{i\\theta_n}$ in the complement of $\\alpha' + \\beta' + \\mathcal{T}'$, the following holds:\n$$ \\mathcal{M}_n(Q)^{\\text{const.}} \\cdot \\mathcal{M}(2(1 - |\\theta_n|))^{\\text{const.}} \\cdot \\mathcal{M}(1 - |z_n|)^{\\text{const.}}. $$\n\n**(ii)** Next, if $e^{i\\theta_n}$ belongs to $\\alpha' + \\beta' + \\mathcal{T}'$:\n$$ \\mathcal{M}_n(\\beta')^{\\text{const.}} \\cdot \\mathcal{M}(1 - |\\theta_n|). $$\nSimilarly,\n$$ \\mathcal{M}_n(\\mathcal{T}')^{\\text{const.}} \\cdot \\mathcal{M}(1 - |\\theta_n|), $$\nresulting in\n$$ \\mathcal{M}_n(Q)^{\\text{const.}} \\cdot \\mathcal{M}(2(1 - |\\theta_n|))^{\\text{const.}} \\cdot \\mathcal{M}(1 - |z_n|)^{\\text{const.}}. $$\n\nTherefore, in any case:\n$$ \\mathcal{M}_n(Q)^{\\text{const.}} \\cdot \\mathcal{M}(2(1 - |\\theta_n|))^{\\text{const.}} \\cdot \\mathcal{M}(1 - |z_n|)^{\\text{const.}}. $$\n\nSince $\\lim_{n \\to \\infty} |z_n - 1| = 0$ (Theorem XI. 8), for sufficiently small $\\varepsilon > 0$:\n$$ \\lim_{n \\to \\infty} \\mathcal{M}_n(Q)^{\\text{const.}} \\cdot \\mathcal{M}(2(1 - |\\theta_n|))^{\\text{const.}} \\cdot \\mathcal{M}(1 - |z_n|)^{\\text{const.}} = 0. $$\n\nHence, if $E = \\bigcap_{n=0}^\\infty T_n(Q)$, then $E$ is invariant by $\\mathcal{S}$, and $0 < p(E) < p(Q) = (2\\pi)^3$.\n\n\n\n\n\n","source":"_drafts/Ergodicity-on-Fuschian-Group.md","raw":"---\ntitle: Ergodicity on Fuchsian Group\ndate: 2024-01-17 13:48:02\ntags:\n    - [Sevaral Complex Variables]\ncategories:\n    - [Sevaral Complex Variables, Fuchsian Group]\nmathjax: true\n---\n\n\n# Hopf's Ergodic Theorem\n\n## Lemma 1\nLet $S:z^{\\prime}=\\frac{z - a}{1 - az} (0<a<1)$ and $J: z=e^{i\\theta} ( 0<\\eta\\leq |\\theta| \\leq \\pi)$ be an arc on $|z|=1$. Then $S(J)$ is contained in an arc \n$$J^*: z=e^{i\\phi} (|\\theta-\\pi| \\leq {2\\pi(1-a)}/{\\sin^2\\eta}) \\text{ on } |z|=1.$$\n\nLet $e$ be a measurable set contained in $J$, then\n$$\n\\frac{(1-a)}{2}me \\leq m S(e)\\leq \\frac{2(1-a)}{2\\sin^2\\eta} \\text{ on } |z|=1,\n$$\nhence \n$$\\frac{J^{*}}{8\\pi} 2\\sin^2\\eta \\cdot me \\leq m S(e) \\leq \\frac{J^{*}}{2\\pi} me,$$\nwhere $|J^*|=\\frac{4\\pi(1-a)}{\\sin^2\\eta}$ is the length of $J^{*}$.\n\n### Proof\n$\n|\\mathrm{d}z^{\\prime}|^{2} = \\dfrac{1- a^{2}}{|1-az|^{2}}dz $. If $z=e^{i\\theta} \\in J$, then\n$$\n\\frac{1-a}{2} \\leq \\frac{1-a^{2}}{|1-az|^{2}} \\leq \\frac{2(1-a)}{\\sin^{2}\\eta}\n$$\nso that from\n$$\n{m{S(e)}} = \\int_{e} \\frac{1-a^{2}}{|1-az|^{2}} |dz|\n$$\nwe have \n$$\n\\frac{1-a}{2}me \\leq m{S(e)} \\leq \\frac{2(1-a)}{\\sin^2\\eta}me\n$$\n\nFrom this, we see that $S(J)$ is contained in an arc\n$$J^{*}: z =e^{i\\theta}  (|\\theta - \\pi| \\leq 2 \\pi (1-a)/\\sin^{2}\\eta)$$\n\n## Lemma 2\nLet $D_0$ be the fundamental domain of a Fuchsian group $G$ and $\\sigma(D_0)<\\infty$. Let $K_0: |z| \\leq \\delta$ be a disc contained in $D_0$ and ${K_n}$ be its equivalents. Let $K^*=\\bigcup K_n$.\n\nLet $r_{\\nu}=1—\\lambda^{\\nu} (0<\\lambda<1) (\\nu = 1,2,\\dots)$. If $\\lambda$ is sufficiently small, then there exists $\\rho_{\\nu} (r_{\\nu}\\leq \\rho_{\\nu} \\leq r_{\\nu+1})$ satisfying the following condition. \n\nThe circle $|z|=\\rho_{\\nu}$ intersects $K^{*}$ in a set of arcs, among them there are arcs $\\theta_{j} (j=1,2,\\dots,s_{\\nu})$, such that\n\n$$\\kappa^{\\prime}(1- \\rho_{\\nu}) \\geq |\\theta_{j}| \\geq \\kappa (1- \\rho_{\\nu}), \\quad \\sum_{j=1}^{s_{\\nu}} \\geq \\eta >0$$\n\nwhere $|\\theta_j|$ denotes the angular magnitude of $\\theta_j$ and $\\kappa^{\\prime}>0$, $\\kappa>0$, $\\eta>0$ are constants independent of $\\nu$.\n\n### Proof\nBy Theorem XI.10,\n$\\frac{\\text{const.}}{1-r} \\leq n(r,a) \\leq \\frac{\\text{const.}}{1-r}\n$ for any $a \\in K_{0}$.\n\nLet $K^{*}(r_{\\nu}, r_{\\nu+1})$ be the part of $K^{*}$ contained in $r_{\\nu} \\leq |z| \\leq r_{\\nu+1}$, then\n\n\\begin{eqnarray}\n\\sigma(K^{*}(r_{\\nu}, r_{\\nu+1})) =& \\int_{a\\in K_{0}} ( n(r_{\\nu+1},a) - n(r_{\\nu},a))  d\\sigma(a) \\nonumber \\\\\n\\geq& \\int_{a\\in K_{0}} \\left(\\frac{\\text{const.}}{1-r_{\\nu+1}} - \\frac{\\text{const.}}{1-r_{\\nu}} d\\sigma(a)\n\\right)\\geq \\frac{\\text{const.}}{\\lambda^{\\nu+1}} - \\frac{\\text{const.}}{\\lambda^{\\nu}} \\geq \\frac{\\text{const.}}{\\lambda^{\\nu+1}}\n\\end{eqnarray}\n\nif $\\lambda$ is sufficiently small.\n\nLet $\\theta (r)$ be the angular magnitude of the part of the circle $|z|=r$ contained in $K^{*}$, then\n$$\n\\sigma(K^{*}(r_{\\nu},r_{\\nu+1})) = 4 \\iint_{K^{*}(r_{\\nu},r_{\\nu+1})} \\frac{rdrd\\theta}{(1-r^{2})^{2}} = 4\\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{r \\theta(r) dr}{(1-r^{2})^{2}} <  4\\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{\\theta(r) dr}{(1-r)^{2}}\n$$\n\nso that by (1)\n\\begin{equation}\n\\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{\\theta(r) dr}{(1-r)^{2}} \\geq \\frac{\\text{const.}}{\\lambda^{\\nu+1}}.\n\\end{equation}\n\nLet the maximum of $\\theta(r)$ in $[r_{\\nu}, r_{\\nu+1}]$ be attained at $r=\\rho_{v}$, then\n$$\n\\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{\\theta(r) dr}{(1-r)^{2}} \\geq \\theta(\\rho_{\\nu}) \\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{dr}{(1-r)^{2}} <\\frac{\\theta(\\rho_{\\nu})}{\\lambda^{\\nu+1}},\n$$\nso that by (2)\n\n\\begin{equation}\n\\theta(\\rho_{\\nu}) \\geq 2 \\eta >0, \\quad \\eta = \\text{const.} (\\nu = 1,2,\\dots).\n\\end{equation}\n\nLet the circle $|z|=\\rho_{\\nu}$ intersect $K^{*}$ in a set of arcs $\\theta_{i} (i=1, 2, \\dots, N)$, then\n$$\\theta(\\rho_{\\nu}) = \\sum_{i=1}^{N} |\\theta_{i}| \\geq 2 \\eta$$\n\nSince $\\theta_{i}$ is contained in an equivalent $K_{i}$ of $K_0$, which intersects $|z|=\\rho_{\\nu}$ and the radius of $K_i$ is $\\leq \\text{const.} (1 - \\rho_{\\nu})$,\n\n\\begin{equation}\n|\\theta_i| \\leq \\text{conts.}(1-\\rho_{\\nu}).\n\\end{equation}\n\nFor a fixed $c>0$, we decompose $\\{d_j\\}$ into two classes:\n$$\n\\{d_j\\} = \\{d_j\\} + \\{d_j^*\\} \\text{ where } |d_j| \\leq c(1-p_v) \\text{ and } |d_j^*| \\leq c(1-p_v)\n$$\nso that\n$$\n2\\sum|d_j|^2 + 3\\sum|d_j^*|^2 \\leq c^2(2+3)\\sum(1-p_v)\n$$\n\nIf an equivalent $K_s$ of $K_0$ intersects the circle $|z|=pv$, then $K_s$ is contained in $|z|^p^*$ such that $1-|d_j|^{\\frac{1}{2}} \\leq c(1-p_v)$, so that $N^n(p^*, a) \\leq \\frac{c^2}{c(1-p_v)} \\cdot \\frac{1}{1-c(1-p_v)} \\leq c$.\n\nHence, if we choose $\\epsilon$ so small that $A^tc^y$, then by the above conditions, we have\n$$\n\\frac{\\sqrt{1-a^{|d_j|}}}{\\sqrt{2}} (1-|d_j|) \\leq \\frac{1}{\\epsilon} \\sum_{j=1}^{N} \\frac{2|d_j|^2}{\\epsilon} + \\frac{1}{\\epsilon} \\sum_{j=1}^{N}\n\n3|d_j^*|^2 \\leq \\frac{c^2(2+3)}{\\epsilon} \\sum_{v=1}^{\\infty} (1-p_v)\n$$\n\n### Note\n\n- $|d_j| \\leq \\sqrt{\\frac{\\epsilon}{1-p_v}}$\n- $|d_j^*| \\leq c(1-p_v)$\n\nThis completes the proof.\n\n\n\n2. **Hopf's Ergodic Theorem**\n\nLet $y_1 = e^{i\\theta_1}$, $y_2 = e^{i\\theta_2}$ be two points on $|z| = 1$, then the pair $(\\theta_1, \\theta_2)$ can be considered as a point of a torus $\\theta: 0 \\leq \\theta_1, \\theta_2 < 2\\pi$.\n\nFor a measurable set $E$ on $\\theta$, we define its measure $m(E)$ by\n$$ m(E) = \\int\\!\\!\\!\\int_E d\\theta_1 d\\theta_2, $$\nso that $m(\\theta) = 4\\pi^2$.\n\nLet $S_v$ be any substitution of a Fuchsian group $G$, and $T_v: \\theta = S_v(\\theta)$, then the totality of $\\{T_v\\}$ constitutes a group ($S = G \\times G$).\n\nHopf ([1], [2]) proved the following theorem.\n\n**Theorem XI. 23. (Hopf's Ergodic Theorem)** If $m(D_0) < \\infty$, then there exists no measurable set $E$ on $\\theta$, which is invariant by $\\circledast$ and $m(\\circledast(E)) < 4\\pi^2$.\n\nHence if $m(E) > 0$, then $m(E) = 4\\pi^2$.\n\n**Proof. (Tsuji [47])** Suppose that there exists a measurable set $E$ on $\\theta$, which is invariant by $\\circledast$ and $m(E) > 0$, and we shall prove that $m(E) = 4\\pi^2$. Let $f(\\theta_1, \\theta_2)$ be the characteristic function of $E$ and put\n$$ u(z, w) = \\frac{1}{\\pi^2} \\iint_{D_0 \\times D_0} \\frac{f(\\theta_1, \\theta_2)}{|z - e^{i\\theta_1}|^2 |w - e^{i\\theta_2}|^2} \\,d\\theta_1 d\\theta_2, $$\nwhere $D_0 = \\{|z| < 1, |w| < 1\\}$, then $u(z, w)$ is invariant by $\\circledast$, such that\n$$ u(S(z), S(w)) = u(z, w), \\quad S \\in \\circledast. $$\n\nWe denote the Stolz domain: $|arg(1 - ze^{-i\\theta})| < \\frac{\\pi}{4}$ by $\\Sigma(e^{i\\theta})$ and $\\Sigma(e^{-i\\theta})$ be its part, contained in $|z - e^{i\\theta}| < \\delta$, then by Theorem IV. 12, for almost all $(\\theta_1, \\theta_2)$ on $\\theta$, $\\lim u(z, w) = f(\\theta_1, \\theta_2)$ uniformly, if $z \\to e^{i\\theta_1}, w \\to e^{i\\theta_2}$ from the inside of $\\Sigma(e^{i\\theta_1}), \\Sigma(e^{i\\theta_2})$ respectively.\n\nLet $E_{\\theta_1}$ be the section of $E$ by the line $\\theta_1 = const. = \\theta$ and $E_{\\theta_2}$ be that by the line $\\theta_2 = const. = \\theta$, then\n$$ \\iint_{\\theta_2} mE_{\\theta_1} d\\theta_2 > 0, $$\nwhere $mE_{\\theta_1}$ denotes the linear measure.\n\nSince $m(D_0) < \\infty, G$ is of divergence type (Theorem XI. 10), so that there exists no measurable set $e$ on $|z| = 1$, which is invariant by $G$ and $m_e < 2\\pi$, hence if $m_e > 0$, then $m_e = 2\\pi$.\n\nIf $mE_{\\theta_1}[\\theta_2] = 0$ on a set $\\theta$ of positive measure in $[0, 2\\pi]$, then since, by the hypothesis on $E$, such a set $\\theta$ is invariant by $G$, $m_e = 2\\pi$, so that $mE_{\\theta_1}[\\theta_2] = 2\\pi$ almost everywhere in $[0, 2\\pi]$, hence $m(E) = 0$, which is absurd.\n\nHence\n$$ mE_{\\theta_1}[\\theta_2] > 0 \\text{ for almost all } \\theta \\in [0, 2\\pi]. $$\n\nHence by Egoroff's theorem, there exists a closed subset $E_0$ of $E$ which satisfies the following conditions (i), (ii), (iii), where $\\delta > 0$ and $\\epsilon > 0$ are sufficiently small constants.\n\n(i) $E_0$ lies outside of the strip: $|\\theta - \\theta_1| < \\epsilon$, mod. $2\\pi$.\n(ii) Let $E_0$ be the projection of $E_0$ on the $\\theta_1$-axis, then $mE_0 > 2\\pi - \\delta$ and $mE_{\\theta_2}[\\theta_1] > 0$ for any $\\theta \\neq \\theta_0$.\n(iii) $\\lim u(z, w) = 1$ uniformly on $E_0$, when $z \\to e^{i\\theta_1}, w \\to e^{i\\theta_2}$ from the inside of $\\Sigma(e^{i\\theta_1}), \\Sigma(e^{i\\theta_2})$ respectively.\n\nWhen $z \\in E_0, w \\in \\Sigma(e^{i\\theta})$, then\n$$ 1 - \\epsilon < u(z, e^{i\\theta}) < 1, \\quad \\theta \\in E_{\\theta_2}[\\theta_1], $$\nwhere $u(z, e^{i\\theta}) = \\lim u(z, w)$.\n\nLet $K_0: |z| < r$ be a disc, contained in $D_0$ and $\\{K_n\\}$ be its equivalents $\\infty$ and $K* = \\bigcup K_n$, then by Lemma 2, there exist $0 < \\phi_1 < \\phi_2 < \\ldots < \\phi_v + 1$ such that the circle $|z| = e^{i\\phi_v}$ intersects $K*$ in a set of arcs $d_j (j = 1, 2, \\ldots, v)$, such that\n$$ \\text{const.} (1 - e^{i\\phi_v})^{|F_j|^2} \\leq \\text{const.} (1 - e^{i\\phi_v}), \\quad \\text{for } j = 1, 2, \\ldots, v, \\text{ where } |F_j| \\text{ denotes the angular magnitude of } d_j.\n\nSince $\\{d_j\\}$ are disjoint, if in the condition (ii), $\\delta > 0$ is sufficiently small, then by the second inequality of (7), we may assume that every $d_j$ contains a point $e^{i\\theta_j} \\in E_0$.\n\nLet $K_j: Z \\mapsto Z_j \\mapsto Z_j \\mapsto B_j \\mapsto T_{g_j} \\mapsto Z_j = a_je^{i\\theta_j}$ (8) be the equivalent of $K_0$, which contains the arc $d_j$ where $Z_j \\in K_j$ is an equivalent of $z = 0$ and let\n$$ K_0 = \\bigcup_{j} K_j, \\quad 0 = S_j(Z_j), \\quad S_j \\in G. $$\n\nSince $d_j$ contains $e^{i\\theta_j}$, if the radius $r$ of $K_0$ is sufficiently small and $v > v_0$, then by Theorem XI. 2, $z_3$ is contained in $\\Sigma(e^{i\\theta_3})$. Hence by (6),\n$$ 1 - e^{i\\theta_3} < u(z_3, e^{i\\theta_3}) < 1 \\text{ for any } v > v_0, $$\n\nwhere $\\lim_{v \\to 0} \\epsilon_v = 0$ with $\\lim_{v \\to 0} v_0 = \\infty$.\n\nSince $u(z, w)$ is invariant by $\\circledast$, we have\n$$ 1 - \\epsilon_v < u(0, e^{i\\theta_3}) < 1 \\text{ for any } \\theta \\in E_{\\theta_1}[\\theta_2]. $$\n\nHence if we put\n$$ \\epsilon_v = \\Sigma_{\\circledast}(a_{jv}) $$\nthen\n$$ 1 - \\epsilon_v < u(0, e^{i\\theta_3}) < 1 \\text{ for any } \\theta \\in E_{\\theta_1}[\\theta_2]. $$\n\nHence if we put\n$$ \\epsilon_v = \\Sigma_{\\circledast}(a_{jv}) $$\nthen\n$$ 1 - \\Sigma_{\\circledast}(a_{jv}) < u(0, e^{i\\theta_3}) < 1 \\text{ for any } v > v_0. $$\n\nSince $u(0, e^{i\\theta_3}) = \\lim_{v \\to 0} u(z_3, e^{i\\theta_3})$, then\n$$ 1 - \\lim_{v \\to 0} \\Sigma_{\\circledast}(a_{jv}) < \\lim_{v \\to 0} u(z_3, e^{i\\theta_3}) < 1. $$\n\nWe shall prove that\n$$ \\lim_{v \\to 0} \\Sigma_{\\circledast}(a_{jv}) > 0 \\quad (j = 1, 2, \\ldots). $$\n\nLet $K_j = S_j(K_0)$, then $K_j$ is obtained from $K_0$ by a rotation about $2\\theta_j = 0$, so that the circle $|z| = e^{i\\phi_v}$ intersects $K_j$ in an arc $d_{jv}$ whose projection on $|z| = 1$ from $z = 0$ be denoted by $J_{jv}$, then $|J_{jv}| = |J_j|$, so that\n$$ \\text{const.} (1 - e^{i\\phi_v}) < \\Sigma_{\\circledast}(|J_{jv}|^2) \\leq \\text{const.} (1 - e^{i\\phi_v}), $$\n\nwhere $|J_{jv}|$ denotes the angular magnitude of $d_{jv}$.\n\nSince $J_{jv}$ contains $e^{i\\theta_j}$, if the radius $r$ of $K_0$ is sufficiently small and $v > v_0$, then by Lemma 1, $S_j(E_0)[\\theta_j]$ is contained in an arc $J_{jv}$ on $|z| = 1$, concentric with $J_j$ such that\n$$ \\Sigma_{\\circledast}[\\theta_j] \\leq \\text{const.} |J_{jv}|. $$\n\nBy Lemma 1, $|J_j| = \\text{const.} (1 - e^{i\\theta_j})$ and since\n$$ \\text{const.} (1 - e^{i\\phi_v}) < \\Sigma_{\\circledast}[\\theta_j] \\leq \\text{const.} |J_{jv}|, $$\n\nwe have\n$$ \\text{const.} (1 - e^{i\\phi_v}) < \\text{const.} (1 - e^{i\\theta_j}) $$\n$$ \\text{const.} (1 - e^{i\\phi_v}) < \\text{const.} (1 - e^{i\\theta_j}) $$\n\nHence by (14), (16), $|J_j| = \\text{const.} |J_{jv}|$, so that by (14), we have\n$$ \\Sigma_{\\circledast}(|J_j|) > 0 \\quad (j = 1, 2, \\ldots). $$\n\nSince $|J_j| > \\text{const.} (1 - e^{i\\theta_j})$ and $J_j, J_{jv}$ are disjoint, the distance between the centers of $J_j, J_{jv}$ is $\\text{const.} (1 - e^{i\\theta_j})$. Since $J_{jv}$ is concentric with $J_j$ and $|J_j| = \\text{const.} (1 - e^{i\\theta_j})$, $\\{J_j\\}$ overlap at most $N$-times, where $N$ is independent of $v$.\n\nSince $S_j(E_0)[\\theta_j], \\{S_j(E_0)[\\theta_j]\\}$ overlap at most $N$-times, so that\nby (15), (17),\n$$ mM_v > \\Sigma_{\\circledast} mS_j(E_0)[\\theta_j] > \\text{const.} \\Sigma_{\\circledast} |J_{jv}| > \\text{const.} > 0 \\quad (j =1, 2, \\ldots, v).\nHence if we put\n$$ u(0, w) = -\\frac{1}{\\pi^2} \\Sigma_{\\circledast} F_j $$\nthen\n$$ m_1 > 0 $$\nand by (12),\n$$ u(0, e^{i\\theta_3}) = 1, \\text{ if } \\Sigma_{\\circledast} (a_{jv}) = m_1. $$\n\nNow\n$$ \\iint_{\\Sigma(e^{i\\theta})} \\frac{|w - e^{i\\theta}|^2}{|w - e^{i\\theta_3}|^2} \\,d\\theta = \\frac{\\pi}{\\Sigma_{\\circledast}(a_{jv})}. $$\n\nHence for almost all $\\theta$ on $\\theta$, $1 = u(0, e^{i\\theta_3}) = F(\\theta) = \\Sigma_{\\circledast} (a_{jv})$ or\n$$ m[\\theta] = 2\\pi. $$\n\nSince the set $e$ of $\\theta$, such that $m[\\theta] = 2\\pi$ is invariant by $G$ and $m_E[\\theta] = 2\\pi$ on a set $M$ of positive measure, we see that $m_E[\\theta] = 2\\pi$ almost everywhere in $[0, 2\\pi]$, hence\n$$ m(E) = 4\\pi^2. $$\n\n3. Next we consider the $n$-dimensional case. Let $y_1=e^{i\\theta_1}, \\ldots, y_n=e^{i\\theta_n}$ be $n$ points on $|z|=1$, then the pair $(\\theta_1, \\ldots, \\theta_n)$ can be considered as a point of an $n$-dimensional torus $\\mathcal{T}_n: 0 \\leq \\theta_1 \\leq 2\\pi, \\ldots, 0 \\leq \\theta_n \\leq 2\\pi$ and the measure $p(E)$ of a measurable set $E$ on $\\mathcal{T}_n$ is defined by\n$$ p(E) = \\int \\cdots \\int_E d\\theta_1 \\cdots d\\theta_n, $$\nso that $p(\\mathcal{T}_n) = (2\\pi)^n$.\n\nLet $\\mathcal{S}$ be any substitution of a Fuchsian group $G$ and\n$$ T_v: (\\theta_1, \\ldots, \\theta_n) \\mapsto (\\theta_1', \\ldots, \\theta_n'), \\quad (1) $$\nthen the totality of $\\{T_v\\}$ constitutes a group $\\mathcal{S}_n = G \\times \\ldots \\times G$.\n\n**Theorem XI. 24.** Let $G$ be a Fuchsian group and $D_0$ be its fundamental domain, where $a(D_0)$ may be finite or infinite. If $n \\geq 3$, then there exists always a measurable set $E$ on $\\mathcal{T}_n$, which is invariant by $\\mathcal{S}$ and $0 < p(E) < (2\\pi)^n$. (Tsuji [14]).\n\n**Proof.** Since the proof is the same, we assume that $n=3$ and put $\\theta_1=0, \\theta_2=\\pi, \\theta_3=\\pi$.\n\nLet $\\mathcal{Q}$:\n$$ \\mathcal{Q}: 0 \\leq \\theta_1 \\leq \\frac{\\pi}{16}, \\quad \\theta_2: \\pi \\leq \\theta_2 \\leq \\pi, \\quad \\theta_3: \\pi \\leq \\theta_3 \\leq \\pi $$\nbe a cube on $\\mathcal{T}_3$ and $\\alpha, \\alpha', \\beta, \\beta', \\mathcal{T}, \\mathcal{T}'$ be arcs on $|z|=1$, such that\n$$ \\alpha: \\text{arg}z - \\pi \\leq \\theta_1 \\leq \\text{arg}z, \\quad \\alpha': \\text{arg}z \\leq \\theta_1 \\leq \\text{arg}z + \\pi, \\quad \\beta: |\\text{arg}z - \\pi| \\leq \\theta_2 \\leq |\\text{arg}z|, \\quad \\beta': |\\text{arg}z - \\pi| \\leq \\theta_3 \\leq |\\text{arg}z|, $$\n$$ \\mathcal{T}: \\text{arg}z \\leq \\theta_1 \\leq \\text{arg}z + \\frac{\\pi}{16}, \\quad \\mathcal{T}': \\pi \\leq \\text{arg}z \\leq \\pi. $$\n\nSo that $\\mathcal{Q} = \\alpha \\cup \\alpha' \\cup \\beta \\cup \\beta' \\cup \\mathcal{T} \\cup \\mathcal{T}'$.\n\nLet $K_0: |z| \\leq p$ be a disc, contained in $D_0$ and $K_n: z = r_ne^{i\\theta_n}$ ($n=0,1,2,\\ldots$) be its equivalents and let $z \\mapsto z_n = \\frac{1}{1 - z\\overline{z_n}}$ be the equivalent of $K_n$, then $K_0 = S_n(K_n), 0 = S_n(z_n), S_n \\in G$. \n\n**(i)** If $e^{i\\theta_n}$ belongs to the complement of $\\alpha + \\alpha' + \\beta + \\beta'$, then since $\\theta_1 < \\frac{\\pi}{16}$, we have for any $z$ on $\\alpha$, $|\\text{arg}z - \\theta_n| \\geq \\frac{\\pi}{16}$, hence by Lemma 1,\n$$ \\mathcal{M}_n(\\mathcal{Q}) \\geq \\text{const.} \\cdot M(1 - |\\theta_n|) \\cdot \\text{M}(1 - |z_n|). $$\n\nSimilarly,\n$$ \\mathcal{M}_n(\\beta)^{\\text{const.}} \\cdot \\text{M}(1 - |\\theta_n|), \\quad \\mathcal{M}_n(\\mathcal{T})^{\\text{const.}} \\cdot \\text{M}(1 - |\\theta_n|), $$\nso that\n$$ \\mathcal{M}_n(\\mathcal{Q})^{\\text{const.}} \\cdot \\text{M}(2(1 - |\\theta_n|))^{\\text{const.}} \\cdot $$\n\n**(i)** For $e^{i\\theta_n}$ in the complement of $\\alpha' + \\beta' + \\mathcal{T}'$, the following holds:\n$$ \\mathcal{M}_n(Q)^{\\text{const.}} \\cdot \\mathcal{M}(2(1 - |\\theta_n|))^{\\text{const.}} \\cdot \\mathcal{M}(1 - |z_n|)^{\\text{const.}}. $$\n\n**(ii)** Next, if $e^{i\\theta_n}$ belongs to $\\alpha' + \\beta' + \\mathcal{T}'$:\n$$ \\mathcal{M}_n(\\beta')^{\\text{const.}} \\cdot \\mathcal{M}(1 - |\\theta_n|). $$\nSimilarly,\n$$ \\mathcal{M}_n(\\mathcal{T}')^{\\text{const.}} \\cdot \\mathcal{M}(1 - |\\theta_n|), $$\nresulting in\n$$ \\mathcal{M}_n(Q)^{\\text{const.}} \\cdot \\mathcal{M}(2(1 - |\\theta_n|))^{\\text{const.}} \\cdot \\mathcal{M}(1 - |z_n|)^{\\text{const.}}. $$\n\nTherefore, in any case:\n$$ \\mathcal{M}_n(Q)^{\\text{const.}} \\cdot \\mathcal{M}(2(1 - |\\theta_n|))^{\\text{const.}} \\cdot \\mathcal{M}(1 - |z_n|)^{\\text{const.}}. $$\n\nSince $\\lim_{n \\to \\infty} |z_n - 1| = 0$ (Theorem XI. 8), for sufficiently small $\\varepsilon > 0$:\n$$ \\lim_{n \\to \\infty} \\mathcal{M}_n(Q)^{\\text{const.}} \\cdot \\mathcal{M}(2(1 - |\\theta_n|))^{\\text{const.}} \\cdot \\mathcal{M}(1 - |z_n|)^{\\text{const.}} = 0. $$\n\nHence, if $E = \\bigcap_{n=0}^\\infty T_n(Q)$, then $E$ is invariant by $\\mathcal{S}$, and $0 < p(E) < p(Q) = (2\\pi)^3$.\n\n\n\n\n\n","slug":"Ergodicity-on-Fuschian-Group","published":0,"updated":"2024-02-25T15:11:07.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5rp0003m8nxc4cwbyec","content":"<h1 id=\"hopfs-ergodic-theorem\">Hopf's Ergodic Theorem</h1>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>Let <span class=\"math inline\">\\(S:z^{\\prime}=\\frac{z - a}{1 - az}\r\n(0&lt;a&lt;1)\\)</span> and <span class=\"math inline\">\\(J: z=e^{i\\theta}\r\n( 0&lt;\\eta\\leq |\\theta| \\leq \\pi)\\)</span> be an arc on <span class=\"math inline\">\\(|z|=1\\)</span>. Then <span class=\"math inline\">\\(S(J)\\)</span> is contained in an arc <span class=\"math display\">\\[J^*: z=e^{i\\phi} (|\\theta-\\pi| \\leq\r\n{2\\pi(1-a)}/{\\sin^2\\eta}) \\text{ on } |z|=1.\\]</span></p>\r\n<p>Let <span class=\"math inline\">\\(e\\)</span> be a measurable set\r\ncontained in <span class=\"math inline\">\\(J\\)</span>, then <span class=\"math display\">\\[\r\n\\frac{(1-a)}{2}me \\leq m S(e)\\leq \\frac{2(1-a)}{2\\sin^2\\eta} \\text{ on }\r\n|z|=1,\r\n\\]</span> hence <span class=\"math display\">\\[\\frac{J^{*}}{8\\pi}\r\n2\\sin^2\\eta \\cdot me \\leq m S(e) \\leq \\frac{J^{*}}{2\\pi} me,\\]</span>\r\nwhere <span class=\"math inline\">\\(|J^*|=\\frac{4\\pi(1-a)}{\\sin^2\\eta}\\)</span> is the\r\nlength of <span class=\"math inline\">\\(J^{*}\\)</span>.</p>\r\n<h3 id=\"proof\">Proof</h3>\r\n<p>$ |z<sup>{}|</sup>{2} = dz $. If <span class=\"math inline\">\\(z=e^{i\\theta} \\in J\\)</span>, then <span class=\"math display\">\\[\r\n\\frac{1-a}{2} \\leq \\frac{1-a^{2}}{|1-az|^{2}} \\leq\r\n\\frac{2(1-a)}{\\sin^{2}\\eta}\r\n\\]</span> so that from <span class=\"math display\">\\[\r\n{m{S(e)}} = \\int_{e} \\frac{1-a^{2}}{|1-az|^{2}} |dz|\r\n\\]</span> we have <span class=\"math display\">\\[\r\n\\frac{1-a}{2}me \\leq m{S(e)} \\leq \\frac{2(1-a)}{\\sin^2\\eta}me\r\n\\]</span></p>\r\n<p>From this, we see that <span class=\"math inline\">\\(S(J)\\)</span> is\r\ncontained in an arc <span class=\"math display\">\\[J^{*}: z\r\n=e^{i\\theta}  (|\\theta - \\pi| \\leq 2 \\pi\r\n(1-a)/\\sin^{2}\\eta)\\]</span></p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>Let <span class=\"math inline\">\\(D_0\\)</span> be the fundamental\r\ndomain of a Fuchsian group <span class=\"math inline\">\\(G\\)</span> and\r\n<span class=\"math inline\">\\(\\sigma(D_0)&lt;\\infty\\)</span>. Let <span class=\"math inline\">\\(K_0: |z| \\leq \\delta\\)</span> be a disc contained\r\nin <span class=\"math inline\">\\(D_0\\)</span> and <span class=\"math inline\">\\({K_n}\\)</span> be its equivalents. Let <span class=\"math inline\">\\(K^*=\\bigcup K_n\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(r_{\\nu}=1—\\lambda^{\\nu}\r\n(0&lt;\\lambda&lt;1) (\\nu = 1,2,\\dots)\\)</span>. If <span class=\"math inline\">\\(\\lambda\\)</span> is sufficiently small, then there\r\nexists <span class=\"math inline\">\\(\\rho_{\\nu} (r_{\\nu}\\leq \\rho_{\\nu}\r\n\\leq r_{\\nu+1})\\)</span> satisfying the following condition.</p>\r\n<p>The circle <span class=\"math inline\">\\(|z|=\\rho_{\\nu}\\)</span>\r\nintersects <span class=\"math inline\">\\(K^{*}\\)</span> in a set of arcs,\r\namong them there are arcs <span class=\"math inline\">\\(\\theta_{j}\r\n(j=1,2,\\dots,s_{\\nu})\\)</span>, such that</p>\r\n<p><span class=\"math display\">\\[\\kappa^{\\prime}(1- \\rho_{\\nu}) \\geq\r\n|\\theta_{j}| \\geq \\kappa (1- \\rho_{\\nu}), \\quad \\sum_{j=1}^{s_{\\nu}}\r\n\\geq \\eta &gt;0\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(|\\theta_j|\\)</span> denotes the\r\nangular magnitude of <span class=\"math inline\">\\(\\theta_j\\)</span> and\r\n<span class=\"math inline\">\\(\\kappa^{\\prime}&gt;0\\)</span>, <span class=\"math inline\">\\(\\kappa&gt;0\\)</span>, <span class=\"math inline\">\\(\\eta&gt;0\\)</span> are constants independent of\r\n<span class=\"math inline\">\\(\\nu\\)</span>.</p>\r\n<h3 id=\"proof-1\">Proof</h3>\r\n<p>By Theorem XI.10, <span class=\"math inline\">\\(\\frac{\\text{const.}}{1-r} \\leq n(r,a) \\leq\r\n\\frac{\\text{const.}}{1-r}\\)</span> for any <span class=\"math inline\">\\(a\r\n\\in K_{0}\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(K^{*}(r_{\\nu}, r_{\\nu+1})\\)</span> be\r\nthe part of <span class=\"math inline\">\\(K^{*}\\)</span> contained in\r\n<span class=\"math inline\">\\(r_{\\nu} \\leq |z| \\leq r_{\\nu+1}\\)</span>,\r\nthen</p>\r\n<p><span class=\"math display\">\\[\\begin{eqnarray}\r\n\\sigma(K^{*}(r_{\\nu}, r_{\\nu+1})) =&amp; \\int_{a\\in K_{0}} (\r\nn(r_{\\nu+1},a) - n(r_{\\nu},a))  d\\sigma(a) \\nonumber \\\\\r\n\\geq&amp; \\int_{a\\in K_{0}} \\left(\\frac{\\text{const.}}{1-r_{\\nu+1}} -\r\n\\frac{\\text{const.}}{1-r_{\\nu}} d\\sigma(a)\r\n\\right)\\geq \\frac{\\text{const.}}{\\lambda^{\\nu+1}} -\r\n\\frac{\\text{const.}}{\\lambda^{\\nu}} \\geq\r\n\\frac{\\text{const.}}{\\lambda^{\\nu+1}}\r\n\\end{eqnarray}\\]</span></p>\r\n<p>if <span class=\"math inline\">\\(\\lambda\\)</span> is sufficiently\r\nsmall.</p>\r\n<p>Let <span class=\"math inline\">\\(\\theta (r)\\)</span> be the angular\r\nmagnitude of the part of the circle <span class=\"math inline\">\\(|z|=r\\)</span> contained in <span class=\"math inline\">\\(K^{*}\\)</span>, then <span class=\"math display\">\\[\r\n\\sigma(K^{*}(r_{\\nu},r_{\\nu+1})) = 4 \\iint_{K^{*}(r_{\\nu},r_{\\nu+1})}\r\n\\frac{rdrd\\theta}{(1-r^{2})^{2}} = 4\\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{r\r\n\\theta(r) dr}{(1-r^{2})^{2}} &lt;  4\\int_{r_{\\nu}}^{r_{\\nu+1}}\r\n\\frac{\\theta(r) dr}{(1-r)^{2}}\r\n\\]</span></p>\r\n<p>so that by (1) <span class=\"math display\">\\[\\begin{equation}\r\n\\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{\\theta(r) dr}{(1-r)^{2}} \\geq\r\n\\frac{\\text{const.}}{\\lambda^{\\nu+1}}.\r\n\\end{equation}\\]</span></p>\r\n<p>Let the maximum of <span class=\"math inline\">\\(\\theta(r)\\)</span> in\r\n<span class=\"math inline\">\\([r_{\\nu}, r_{\\nu+1}]\\)</span> be attained at\r\n<span class=\"math inline\">\\(r=\\rho_{v}\\)</span>, then <span class=\"math display\">\\[\r\n\\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{\\theta(r) dr}{(1-r)^{2}} \\geq\r\n\\theta(\\rho_{\\nu}) \\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{dr}{(1-r)^{2}}\r\n&lt;\\frac{\\theta(\\rho_{\\nu})}{\\lambda^{\\nu+1}},\r\n\\]</span> so that by (2)</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\theta(\\rho_{\\nu}) \\geq 2 \\eta &gt;0, \\quad \\eta = \\text{const.} (\\nu =\r\n1,2,\\dots).\r\n\\end{equation}\\]</span></p>\r\n<p>Let the circle <span class=\"math inline\">\\(|z|=\\rho_{\\nu}\\)</span>\r\nintersect <span class=\"math inline\">\\(K^{*}\\)</span> in a set of arcs\r\n<span class=\"math inline\">\\(\\theta_{i} (i=1, 2, \\dots, N)\\)</span>, then\r\n<span class=\"math display\">\\[\\theta(\\rho_{\\nu}) = \\sum_{i=1}^{N}\r\n|\\theta_{i}| \\geq 2 \\eta\\]</span></p>\r\n<p>Since <span class=\"math inline\">\\(\\theta_{i}\\)</span> is contained in\r\nan equivalent <span class=\"math inline\">\\(K_{i}\\)</span> of <span class=\"math inline\">\\(K_0\\)</span>, which intersects <span class=\"math inline\">\\(|z|=\\rho_{\\nu}\\)</span> and the radius of <span class=\"math inline\">\\(K_i\\)</span> is <span class=\"math inline\">\\(\\leq\r\n\\text{const.} (1 - \\rho_{\\nu})\\)</span>,</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n|\\theta_i| \\leq \\text{conts.}(1-\\rho_{\\nu}).\r\n\\end{equation}\\]</span></p>\r\n<p>For a fixed <span class=\"math inline\">\\(c&gt;0\\)</span>, we decompose\r\n<span class=\"math inline\">\\(\\{d_j\\}\\)</span> into two classes: <span class=\"math display\">\\[\r\n\\{d_j\\} = \\{d_j\\} + \\{d_j^*\\} \\text{ where } |d_j| \\leq c(1-p_v) \\text{\r\nand } |d_j^*| \\leq c(1-p_v)\r\n\\]</span> so that <span class=\"math display\">\\[\r\n2\\sum|d_j|^2 + 3\\sum|d_j^*|^2 \\leq c^2(2+3)\\sum(1-p_v)\r\n\\]</span></p>\r\n<p>If an equivalent <span class=\"math inline\">\\(K_s\\)</span> of <span class=\"math inline\">\\(K_0\\)</span> intersects the circle <span class=\"math inline\">\\(|z|=pv\\)</span>, then <span class=\"math inline\">\\(K_s\\)</span> is contained in <span class=\"math inline\">\\(|z|^p^*\\)</span> such that <span class=\"math inline\">\\(1-|d_j|^{\\frac{1}{2}} \\leq c(1-p_v)\\)</span>, so\r\nthat <span class=\"math inline\">\\(N^n(p^*, a) \\leq \\frac{c^2}{c(1-p_v)}\r\n\\cdot \\frac{1}{1-c(1-p_v)} \\leq c\\)</span>.</p>\r\n<p>Hence, if we choose <span class=\"math inline\">\\(\\epsilon\\)</span> so\r\nsmall that <span class=\"math inline\">\\(A^tc^y\\)</span>, then by the\r\nabove conditions, we have $$ (1-|d_j|) <em>{j=1}^{N} +\r\n</em>{j=1}^{N}</p>\r\n<p>3|d_j^*|^2 _{v=1}^{} (1-p_v) $$</p>\r\n<h3 id=\"note\">Note</h3>\r\n<ul>\r\n<li><span class=\"math inline\">\\(|d_j| \\leq\r\n\\sqrt{\\frac{\\epsilon}{1-p_v}}\\)</span></li>\r\n<li><span class=\"math inline\">\\(|d_j^*| \\leq c(1-p_v)\\)</span></li>\r\n</ul>\r\n<p>This completes the proof.</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li><strong>Hopf's Ergodic Theorem</strong></li>\r\n</ol>\r\n<p>Let <span class=\"math inline\">\\(y_1 = e^{i\\theta_1}\\)</span>, <span class=\"math inline\">\\(y_2 = e^{i\\theta_2}\\)</span> be two points on\r\n<span class=\"math inline\">\\(|z| = 1\\)</span>, then the pair <span class=\"math inline\">\\((\\theta_1, \\theta_2)\\)</span> can be considered as\r\na point of a torus <span class=\"math inline\">\\(\\theta: 0 \\leq \\theta_1,\r\n\\theta_2 &lt; 2\\pi\\)</span>.</p>\r\n<p>For a measurable set <span class=\"math inline\">\\(E\\)</span> on <span class=\"math inline\">\\(\\theta\\)</span>, we define its measure <span class=\"math inline\">\\(m(E)\\)</span> by <span class=\"math display\">\\[\r\nm(E) = \\int\\!\\!\\!\\int_E d\\theta_1 d\\theta_2, \\]</span> so that <span class=\"math inline\">\\(m(\\theta) = 4\\pi^2\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(S_v\\)</span> be any substitution of a\r\nFuchsian group <span class=\"math inline\">\\(G\\)</span>, and <span class=\"math inline\">\\(T_v: \\theta = S_v(\\theta)\\)</span>, then the\r\ntotality of <span class=\"math inline\">\\(\\{T_v\\}\\)</span> constitutes a\r\ngroup (<span class=\"math inline\">\\(S = G \\times G\\)</span>).</p>\r\n<p>Hopf ([1], [2]) proved the following theorem.</p>\r\n<p><strong>Theorem XI. 23. (Hopf's Ergodic Theorem)</strong> If <span class=\"math inline\">\\(m(D_0) &lt; \\infty\\)</span>, then there exists no\r\nmeasurable set <span class=\"math inline\">\\(E\\)</span> on <span class=\"math inline\">\\(\\theta\\)</span>, which is invariant by <span class=\"math inline\">\\(\\circledast\\)</span> and <span class=\"math inline\">\\(m(\\circledast(E)) &lt; 4\\pi^2\\)</span>.</p>\r\n<p>Hence if <span class=\"math inline\">\\(m(E) &gt; 0\\)</span>, then <span class=\"math inline\">\\(m(E) = 4\\pi^2\\)</span>.</p>\r\n<p><strong>Proof. (Tsuji [47])</strong> Suppose that there exists a\r\nmeasurable set <span class=\"math inline\">\\(E\\)</span> on <span class=\"math inline\">\\(\\theta\\)</span>, which is invariant by <span class=\"math inline\">\\(\\circledast\\)</span> and <span class=\"math inline\">\\(m(E) &gt; 0\\)</span>, and we shall prove that\r\n<span class=\"math inline\">\\(m(E) = 4\\pi^2\\)</span>. Let <span class=\"math inline\">\\(f(\\theta_1, \\theta_2)\\)</span> be the\r\ncharacteristic function of <span class=\"math inline\">\\(E\\)</span> and\r\nput <span class=\"math display\">\\[ u(z, w) = \\frac{1}{\\pi^2} \\iint_{D_0\r\n\\times D_0} \\frac{f(\\theta_1, \\theta_2)}{|z - e^{i\\theta_1}|^2 |w -\r\ne^{i\\theta_2}|^2} \\,d\\theta_1 d\\theta_2, \\]</span> where <span class=\"math inline\">\\(D_0 = \\{|z| &lt; 1, |w| &lt; 1\\}\\)</span>, then\r\n<span class=\"math inline\">\\(u(z, w)\\)</span> is invariant by <span class=\"math inline\">\\(\\circledast\\)</span>, such that <span class=\"math display\">\\[ u(S(z), S(w)) = u(z, w), \\quad S \\in\r\n\\circledast. \\]</span></p>\r\n<p>We denote the Stolz domain: <span class=\"math inline\">\\(|arg(1 -\r\nze^{-i\\theta})| &lt; \\frac{\\pi}{4}\\)</span> by <span class=\"math inline\">\\(\\Sigma(e^{i\\theta})\\)</span> and <span class=\"math inline\">\\(\\Sigma(e^{-i\\theta})\\)</span> be its part,\r\ncontained in <span class=\"math inline\">\\(|z - e^{i\\theta}| &lt;\r\n\\delta\\)</span>, then by Theorem IV. 12, for almost all <span class=\"math inline\">\\((\\theta_1, \\theta_2)\\)</span> on <span class=\"math inline\">\\(\\theta\\)</span>, <span class=\"math inline\">\\(\\lim\r\nu(z, w) = f(\\theta_1, \\theta_2)\\)</span> uniformly, if <span class=\"math inline\">\\(z \\to e^{i\\theta_1}, w \\to e^{i\\theta_2}\\)</span>\r\nfrom the inside of <span class=\"math inline\">\\(\\Sigma(e^{i\\theta_1}),\r\n\\Sigma(e^{i\\theta_2})\\)</span> respectively.</p>\r\n<p>Let <span class=\"math inline\">\\(E_{\\theta_1}\\)</span> be the section\r\nof <span class=\"math inline\">\\(E\\)</span> by the line <span class=\"math inline\">\\(\\theta_1 = const. = \\theta\\)</span> and <span class=\"math inline\">\\(E_{\\theta_2}\\)</span> be that by the line <span class=\"math inline\">\\(\\theta_2 = const. = \\theta\\)</span>, then <span class=\"math display\">\\[ \\iint_{\\theta_2} mE_{\\theta_1} d\\theta_2 &gt; 0,\r\n\\]</span> where <span class=\"math inline\">\\(mE_{\\theta_1}\\)</span>\r\ndenotes the linear measure.</p>\r\n<p>Since <span class=\"math inline\">\\(m(D_0) &lt; \\infty, G\\)</span> is\r\nof divergence type (Theorem XI. 10), so that there exists no measurable\r\nset <span class=\"math inline\">\\(e\\)</span> on <span class=\"math inline\">\\(|z| = 1\\)</span>, which is invariant by <span class=\"math inline\">\\(G\\)</span> and <span class=\"math inline\">\\(m_e\r\n&lt; 2\\pi\\)</span>, hence if <span class=\"math inline\">\\(m_e &gt;\r\n0\\)</span>, then <span class=\"math inline\">\\(m_e = 2\\pi\\)</span>.</p>\r\n<p>If <span class=\"math inline\">\\(mE_{\\theta_1}[\\theta_2] = 0\\)</span>\r\non a set <span class=\"math inline\">\\(\\theta\\)</span> of positive measure\r\nin <span class=\"math inline\">\\([0, 2\\pi]\\)</span>, then since, by the\r\nhypothesis on <span class=\"math inline\">\\(E\\)</span>, such a set <span class=\"math inline\">\\(\\theta\\)</span> is invariant by <span class=\"math inline\">\\(G\\)</span>, <span class=\"math inline\">\\(m_e =\r\n2\\pi\\)</span>, so that <span class=\"math inline\">\\(mE_{\\theta_1}[\\theta_2] = 2\\pi\\)</span> almost\r\neverywhere in <span class=\"math inline\">\\([0, 2\\pi]\\)</span>, hence\r\n<span class=\"math inline\">\\(m(E) = 0\\)</span>, which is absurd.</p>\r\n<p>Hence <span class=\"math display\">\\[ mE_{\\theta_1}[\\theta_2] &gt; 0\r\n\\text{ for almost all } \\theta \\in [0, 2\\pi]. \\]</span></p>\r\n<p>Hence by Egoroff's theorem, there exists a closed subset <span class=\"math inline\">\\(E_0\\)</span> of <span class=\"math inline\">\\(E\\)</span> which satisfies the following\r\nconditions (i), (ii), (iii), where <span class=\"math inline\">\\(\\delta\r\n&gt; 0\\)</span> and <span class=\"math inline\">\\(\\epsilon &gt; 0\\)</span>\r\nare sufficiently small constants.</p>\r\n<ol type=\"i\">\r\n<li><span class=\"math inline\">\\(E_0\\)</span> lies outside of the strip:\r\n<span class=\"math inline\">\\(|\\theta - \\theta_1| &lt; \\epsilon\\)</span>,\r\nmod. <span class=\"math inline\">\\(2\\pi\\)</span>.</li>\r\n<li>Let <span class=\"math inline\">\\(E_0\\)</span> be the projection of\r\n<span class=\"math inline\">\\(E_0\\)</span> on the <span class=\"math inline\">\\(\\theta_1\\)</span>-axis, then <span class=\"math inline\">\\(mE_0 &gt; 2\\pi - \\delta\\)</span> and <span class=\"math inline\">\\(mE_{\\theta_2}[\\theta_1] &gt; 0\\)</span> for any\r\n<span class=\"math inline\">\\(\\theta \\neq \\theta_0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(\\lim u(z, w) = 1\\)</span> uniformly on\r\n<span class=\"math inline\">\\(E_0\\)</span>, when <span class=\"math inline\">\\(z \\to e^{i\\theta_1}, w \\to e^{i\\theta_2}\\)</span>\r\nfrom the inside of <span class=\"math inline\">\\(\\Sigma(e^{i\\theta_1}),\r\n\\Sigma(e^{i\\theta_2})\\)</span> respectively.</li>\r\n</ol>\r\n<p>When <span class=\"math inline\">\\(z \\in E_0, w \\in\r\n\\Sigma(e^{i\\theta})\\)</span>, then <span class=\"math display\">\\[ 1 -\r\n\\epsilon &lt; u(z, e^{i\\theta}) &lt; 1, \\quad \\theta \\in\r\nE_{\\theta_2}[\\theta_1], \\]</span> where <span class=\"math inline\">\\(u(z,\r\ne^{i\\theta}) = \\lim u(z, w)\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(K_0: |z| &lt; r\\)</span> be a disc,\r\ncontained in <span class=\"math inline\">\\(D_0\\)</span> and <span class=\"math inline\">\\(\\{K_n\\}\\)</span> be its equivalents <span class=\"math inline\">\\(\\infty\\)</span> and <span class=\"math inline\">\\(K*\r\n= \\bigcup K_n\\)</span>, then by Lemma 2, there exist <span class=\"math inline\">\\(0 &lt; \\phi_1 &lt; \\phi_2 &lt; \\ldots &lt; \\phi_v\r\n+ 1\\)</span> such that the circle <span class=\"math inline\">\\(|z| =\r\ne^{i\\phi_v}\\)</span> intersects <span class=\"math inline\">\\(K*\\)</span>\r\nin a set of arcs <span class=\"math inline\">\\(d_j (j = 1, 2, \\ldots,\r\nv)\\)</span>, such that $$ (1 - e^{i_v})<sup>{|F_j|</sup>2} (1 -\r\ne^{i_v}), j = 1, 2, , v, |F_j| d_j.</p>\r\n<p>Since <span class=\"math inline\">\\(\\{d_j\\}\\)</span> are disjoint, if\r\nin the condition (ii), <span class=\"math inline\">\\(\\delta &gt;\r\n0\\)</span> is sufficiently small, then by the second inequality of (7),\r\nwe may assume that every <span class=\"math inline\">\\(d_j\\)</span>\r\ncontains a point <span class=\"math inline\">\\(e^{i\\theta_j} \\in\r\nE_0\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(K_j: Z \\mapsto Z_j \\mapsto Z_j\r\n\\mapsto B_j \\mapsto T_{g_j} \\mapsto Z_j = a_je^{i\\theta_j}\\)</span> (8)\r\nbe the equivalent of <span class=\"math inline\">\\(K_0\\)</span>, which\r\ncontains the arc <span class=\"math inline\">\\(d_j\\)</span> where <span class=\"math inline\">\\(Z_j \\in K_j\\)</span> is an equivalent of <span class=\"math inline\">\\(z = 0\\)</span> and let <span class=\"math display\">\\[ K_0 = \\bigcup_{j} K_j, \\quad 0 = S_j(Z_j), \\quad\r\nS_j \\in G. \\]</span></p>\r\n<p>Since <span class=\"math inline\">\\(d_j\\)</span> contains <span class=\"math inline\">\\(e^{i\\theta_j}\\)</span>, if the radius <span class=\"math inline\">\\(r\\)</span> of <span class=\"math inline\">\\(K_0\\)</span> is sufficiently small and <span class=\"math inline\">\\(v &gt; v_0\\)</span>, then by Theorem XI. 2, <span class=\"math inline\">\\(z_3\\)</span> is contained in <span class=\"math inline\">\\(\\Sigma(e^{i\\theta_3})\\)</span>. Hence by (6),\r\n<span class=\"math display\">\\[ 1 - e^{i\\theta_3} &lt; u(z_3,\r\ne^{i\\theta_3}) &lt; 1 \\text{ for any } v &gt; v_0, \\]</span></p>\r\n<p>where <span class=\"math inline\">\\(\\lim_{v \\to 0} \\epsilon_v =\r\n0\\)</span> with <span class=\"math inline\">\\(\\lim_{v \\to 0} v_0 =\r\n\\infty\\)</span>.</p>\r\n<p>Since <span class=\"math inline\">\\(u(z, w)\\)</span> is invariant by\r\n<span class=\"math inline\">\\(\\circledast\\)</span>, we have <span class=\"math display\">\\[ 1 - \\epsilon_v &lt; u(0, e^{i\\theta_3}) &lt; 1\r\n\\text{ for any } \\theta \\in E_{\\theta_1}[\\theta_2]. \\]</span></p>\r\n<p>Hence if we put <span class=\"math display\">\\[ \\epsilon_v =\r\n\\Sigma_{\\circledast}(a_{jv}) \\]</span> then <span class=\"math display\">\\[ 1 - \\epsilon_v &lt; u(0, e^{i\\theta_3}) &lt; 1\r\n\\text{ for any } \\theta \\in E_{\\theta_1}[\\theta_2]. \\]</span></p>\r\n<p>Hence if we put <span class=\"math display\">\\[ \\epsilon_v =\r\n\\Sigma_{\\circledast}(a_{jv}) \\]</span> then <span class=\"math display\">\\[ 1 - \\Sigma_{\\circledast}(a_{jv}) &lt; u(0,\r\ne^{i\\theta_3}) &lt; 1 \\text{ for any } v &gt; v_0. \\]</span></p>\r\n<p>Since <span class=\"math inline\">\\(u(0, e^{i\\theta_3}) = \\lim_{v \\to\r\n0} u(z_3, e^{i\\theta_3})\\)</span>, then <span class=\"math display\">\\[ 1\r\n- \\lim_{v \\to 0} \\Sigma_{\\circledast}(a_{jv}) &lt; \\lim_{v \\to 0} u(z_3,\r\ne^{i\\theta_3}) &lt; 1. \\]</span></p>\r\n<p>We shall prove that <span class=\"math display\">\\[ \\lim_{v \\to 0}\r\n\\Sigma_{\\circledast}(a_{jv}) &gt; 0 \\quad (j = 1, 2, \\ldots).\r\n\\]</span></p>\r\n<p>Let <span class=\"math inline\">\\(K_j = S_j(K_0)\\)</span>, then <span class=\"math inline\">\\(K_j\\)</span> is obtained from <span class=\"math inline\">\\(K_0\\)</span> by a rotation about <span class=\"math inline\">\\(2\\theta_j = 0\\)</span>, so that the circle <span class=\"math inline\">\\(|z| = e^{i\\phi_v}\\)</span> intersects <span class=\"math inline\">\\(K_j\\)</span> in an arc <span class=\"math inline\">\\(d_{jv}\\)</span> whose projection on <span class=\"math inline\">\\(|z| = 1\\)</span> from <span class=\"math inline\">\\(z = 0\\)</span> be denoted by <span class=\"math inline\">\\(J_{jv}\\)</span>, then <span class=\"math inline\">\\(|J_{jv}| = |J_j|\\)</span>, so that <span class=\"math display\">\\[ \\text{const.} (1 - e^{i\\phi_v}) &lt;\r\n\\Sigma_{\\circledast}(|J_{jv}|^2) \\leq \\text{const.} (1 - e^{i\\phi_v}),\r\n\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(|J_{jv}|\\)</span> denotes the\r\nangular magnitude of <span class=\"math inline\">\\(d_{jv}\\)</span>.</p>\r\n<p>Since <span class=\"math inline\">\\(J_{jv}\\)</span> contains <span class=\"math inline\">\\(e^{i\\theta_j}\\)</span>, if the radius <span class=\"math inline\">\\(r\\)</span> of <span class=\"math inline\">\\(K_0\\)</span> is sufficiently small and <span class=\"math inline\">\\(v &gt; v_0\\)</span>, then by Lemma 1, <span class=\"math inline\">\\(S_j(E_0)[\\theta_j]\\)</span> is contained in an arc\r\n<span class=\"math inline\">\\(J_{jv}\\)</span> on <span class=\"math inline\">\\(|z| = 1\\)</span>, concentric with <span class=\"math inline\">\\(J_j\\)</span> such that <span class=\"math display\">\\[ \\Sigma_{\\circledast}[\\theta_j] \\leq\r\n\\text{const.} |J_{jv}|. \\]</span></p>\r\n<p>By Lemma 1, <span class=\"math inline\">\\(|J_j| = \\text{const.} (1 -\r\ne^{i\\theta_j})\\)</span> and since <span class=\"math display\">\\[\r\n\\text{const.} (1 - e^{i\\phi_v}) &lt; \\Sigma_{\\circledast}[\\theta_j] \\leq\r\n\\text{const.} |J_{jv}|, \\]</span></p>\r\n<p>we have <span class=\"math display\">\\[ \\text{const.} (1 - e^{i\\phi_v})\r\n&lt; \\text{const.} (1 - e^{i\\theta_j}) \\]</span> <span class=\"math display\">\\[ \\text{const.} (1 - e^{i\\phi_v}) &lt;\r\n\\text{const.} (1 - e^{i\\theta_j}) \\]</span></p>\r\n<p>Hence by (14), (16), <span class=\"math inline\">\\(|J_j| =\r\n\\text{const.} |J_{jv}|\\)</span>, so that by (14), we have <span class=\"math display\">\\[ \\Sigma_{\\circledast}(|J_j|) &gt; 0 \\quad (j = 1,\r\n2, \\ldots). \\]</span></p>\r\n<p>Since <span class=\"math inline\">\\(|J_j| &gt; \\text{const.} (1 -\r\ne^{i\\theta_j})\\)</span> and <span class=\"math inline\">\\(J_j,\r\nJ_{jv}\\)</span> are disjoint, the distance between the centers of <span class=\"math inline\">\\(J_j, J_{jv}\\)</span> is <span class=\"math inline\">\\(\\text{const.} (1 - e^{i\\theta_j})\\)</span>. Since\r\n<span class=\"math inline\">\\(J_{jv}\\)</span> is concentric with <span class=\"math inline\">\\(J_j\\)</span> and <span class=\"math inline\">\\(|J_j|\r\n= \\text{const.} (1 - e^{i\\theta_j})\\)</span>, <span class=\"math inline\">\\(\\{J_j\\}\\)</span> overlap at most <span class=\"math inline\">\\(N\\)</span>-times, where <span class=\"math inline\">\\(N\\)</span> is independent of <span class=\"math inline\">\\(v\\)</span>.</p>\r\n<p>Since <span class=\"math inline\">\\(S_j(E_0)[\\theta_j],\r\n\\{S_j(E_0)[\\theta_j]\\}\\)</span> overlap at most <span class=\"math inline\">\\(N\\)</span>-times, so that by (15), (17), <span class=\"math display\">\\[ mM_v &gt; \\Sigma_{\\circledast}\r\nmS_j(E_0)[\\theta_j] &gt; \\text{const.} \\Sigma_{\\circledast} |J_{jv}|\r\n&gt; \\text{const.} &gt; 0 \\quad (j =1, 2, \\ldots, v).\r\nHence if we put\r\n\\]</span> u(0, w) = - <em>{} F_j <span class=\"math display\">\\[\r\nthen\r\n\\]</span> m_1 &gt; 0 <span class=\"math display\">\\[\r\nand by (12),\r\n\\]</span> u(0, e^{i<em>3}) = 1, </em>{} (a</em>{jv}) = m_1. $$</p>\r\n<p>Now <span class=\"math display\">\\[ \\iint_{\\Sigma(e^{i\\theta})}\r\n\\frac{|w - e^{i\\theta}|^2}{|w - e^{i\\theta_3}|^2} \\,d\\theta =\r\n\\frac{\\pi}{\\Sigma_{\\circledast}(a_{jv})}. \\]</span></p>\r\n<p>Hence for almost all <span class=\"math inline\">\\(\\theta\\)</span> on\r\n<span class=\"math inline\">\\(\\theta\\)</span>, <span class=\"math inline\">\\(1 = u(0, e^{i\\theta_3}) = F(\\theta) =\r\n\\Sigma_{\\circledast} (a_{jv})\\)</span> or <span class=\"math display\">\\[\r\nm[\\theta] = 2\\pi. \\]</span></p>\r\n<p>Since the set <span class=\"math inline\">\\(e\\)</span> of <span class=\"math inline\">\\(\\theta\\)</span>, such that <span class=\"math inline\">\\(m[\\theta] = 2\\pi\\)</span> is invariant by <span class=\"math inline\">\\(G\\)</span> and <span class=\"math inline\">\\(m_E[\\theta] = 2\\pi\\)</span> on a set <span class=\"math inline\">\\(M\\)</span> of positive measure, we see that <span class=\"math inline\">\\(m_E[\\theta] = 2\\pi\\)</span> almost everywhere in\r\n<span class=\"math inline\">\\([0, 2\\pi]\\)</span>, hence <span class=\"math display\">\\[ m(E) = 4\\pi^2. \\]</span></p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>Next we consider the <span class=\"math inline\">\\(n\\)</span>-dimensional case. Let <span class=\"math inline\">\\(y_1=e^{i\\theta_1}, \\ldots,\r\ny_n=e^{i\\theta_n}\\)</span> be <span class=\"math inline\">\\(n\\)</span>\r\npoints on <span class=\"math inline\">\\(|z|=1\\)</span>, then the pair\r\n<span class=\"math inline\">\\((\\theta_1, \\ldots, \\theta_n)\\)</span> can be\r\nconsidered as a point of an <span class=\"math inline\">\\(n\\)</span>-dimensional torus <span class=\"math inline\">\\(\\mathcal{T}_n: 0 \\leq \\theta_1 \\leq 2\\pi, \\ldots,\r\n0 \\leq \\theta_n \\leq 2\\pi\\)</span> and the measure <span class=\"math inline\">\\(p(E)\\)</span> of a measurable set <span class=\"math inline\">\\(E\\)</span> on <span class=\"math inline\">\\(\\mathcal{T}_n\\)</span> is defined by <span class=\"math display\">\\[ p(E) = \\int \\cdots \\int_E d\\theta_1 \\cdots\r\nd\\theta_n, \\]</span> so that <span class=\"math inline\">\\(p(\\mathcal{T}_n) = (2\\pi)^n\\)</span>.</li>\r\n</ol>\r\n<p>Let <span class=\"math inline\">\\(\\mathcal{S}\\)</span> be any\r\nsubstitution of a Fuchsian group <span class=\"math inline\">\\(G\\)</span>\r\nand <span class=\"math display\">\\[ T_v: (\\theta_1, \\ldots, \\theta_n)\r\n\\mapsto (\\theta_1&#39;, \\ldots, \\theta_n&#39;), \\quad (1) \\]</span> then\r\nthe totality of <span class=\"math inline\">\\(\\{T_v\\}\\)</span> constitutes\r\na group <span class=\"math inline\">\\(\\mathcal{S}_n = G \\times \\ldots\r\n\\times G\\)</span>.</p>\r\n<p><strong>Theorem XI. 24.</strong> Let <span class=\"math inline\">\\(G\\)</span> be a Fuchsian group and <span class=\"math inline\">\\(D_0\\)</span> be its fundamental domain, where\r\n<span class=\"math inline\">\\(a(D_0)\\)</span> may be finite or infinite.\r\nIf <span class=\"math inline\">\\(n \\geq 3\\)</span>, then there exists\r\nalways a measurable set <span class=\"math inline\">\\(E\\)</span> on <span class=\"math inline\">\\(\\mathcal{T}_n\\)</span>, which is invariant by\r\n<span class=\"math inline\">\\(\\mathcal{S}\\)</span> and <span class=\"math inline\">\\(0 &lt; p(E) &lt; (2\\pi)^n\\)</span>. (Tsuji\r\n[14]).</p>\r\n<p><strong>Proof.</strong> Since the proof is the same, we assume that\r\n<span class=\"math inline\">\\(n=3\\)</span> and put <span class=\"math inline\">\\(\\theta_1=0, \\theta_2=\\pi,\r\n\\theta_3=\\pi\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(\\mathcal{Q}\\)</span>: <span class=\"math display\">\\[ \\mathcal{Q}: 0 \\leq \\theta_1 \\leq\r\n\\frac{\\pi}{16}, \\quad \\theta_2: \\pi \\leq \\theta_2 \\leq \\pi, \\quad\r\n\\theta_3: \\pi \\leq \\theta_3 \\leq \\pi \\]</span> be a cube on <span class=\"math inline\">\\(\\mathcal{T}_3\\)</span> and <span class=\"math inline\">\\(\\alpha, \\alpha&#39;, \\beta, \\beta&#39;,\r\n\\mathcal{T}, \\mathcal{T}&#39;\\)</span> be arcs on <span class=\"math inline\">\\(|z|=1\\)</span>, such that <span class=\"math display\">\\[ \\alpha: \\text{arg}z - \\pi \\leq \\theta_1 \\leq\r\n\\text{arg}z, \\quad \\alpha&#39;: \\text{arg}z \\leq \\theta_1 \\leq\r\n\\text{arg}z + \\pi, \\quad \\beta: |\\text{arg}z - \\pi| \\leq \\theta_2 \\leq\r\n|\\text{arg}z|, \\quad \\beta&#39;: |\\text{arg}z - \\pi| \\leq \\theta_3 \\leq\r\n|\\text{arg}z|, \\]</span> <span class=\"math display\">\\[ \\mathcal{T}:\r\n\\text{arg}z \\leq \\theta_1 \\leq \\text{arg}z + \\frac{\\pi}{16}, \\quad\r\n\\mathcal{T}&#39;: \\pi \\leq \\text{arg}z \\leq \\pi. \\]</span></p>\r\n<p>So that <span class=\"math inline\">\\(\\mathcal{Q} = \\alpha \\cup\r\n\\alpha&#39; \\cup \\beta \\cup \\beta&#39; \\cup \\mathcal{T} \\cup\r\n\\mathcal{T}&#39;\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(K_0: |z| \\leq p\\)</span> be a disc,\r\ncontained in <span class=\"math inline\">\\(D_0\\)</span> and <span class=\"math inline\">\\(K_n: z = r_ne^{i\\theta_n}\\)</span> (<span class=\"math inline\">\\(n=0,1,2,\\ldots\\)</span>) be its equivalents and\r\nlet <span class=\"math inline\">\\(z \\mapsto z_n = \\frac{1}{1 -\r\nz\\overline{z_n}}\\)</span> be the equivalent of <span class=\"math inline\">\\(K_n\\)</span>, then <span class=\"math inline\">\\(K_0\r\n= S_n(K_n), 0 = S_n(z_n), S_n \\in G\\)</span>.</p>\r\n<p><strong>(i)</strong> If <span class=\"math inline\">\\(e^{i\\theta_n}\\)</span> belongs to the complement\r\nof <span class=\"math inline\">\\(\\alpha + \\alpha&#39; + \\beta +\r\n\\beta&#39;\\)</span>, then since <span class=\"math inline\">\\(\\theta_1\r\n&lt; \\frac{\\pi}{16}\\)</span>, we have for any <span class=\"math inline\">\\(z\\)</span> on <span class=\"math inline\">\\(\\alpha\\)</span>, <span class=\"math inline\">\\(|\\text{arg}z - \\theta_n| \\geq\r\n\\frac{\\pi}{16}\\)</span>, hence by Lemma 1, <span class=\"math display\">\\[\r\n\\mathcal{M}_n(\\mathcal{Q}) \\geq \\text{const.} \\cdot M(1 - |\\theta_n|)\r\n\\cdot \\text{M}(1 - |z_n|). \\]</span></p>\r\n<p>Similarly, <span class=\"math display\">\\[\r\n\\mathcal{M}_n(\\beta)^{\\text{const.}} \\cdot \\text{M}(1 - |\\theta_n|),\r\n\\quad \\mathcal{M}_n(\\mathcal{T})^{\\text{const.}} \\cdot \\text{M}(1 -\r\n|\\theta_n|), \\]</span> so that <span class=\"math display\">\\[\r\n\\mathcal{M}_n(\\mathcal{Q})^{\\text{const.}} \\cdot \\text{M}(2(1 -\r\n|\\theta_n|))^{\\text{const.}} \\cdot \\]</span></p>\r\n<p><strong>(i)</strong> For <span class=\"math inline\">\\(e^{i\\theta_n}\\)</span> in the complement of <span class=\"math inline\">\\(\\alpha&#39; + \\beta&#39; +\r\n\\mathcal{T}&#39;\\)</span>, the following holds: <span class=\"math display\">\\[ \\mathcal{M}_n(Q)^{\\text{const.}} \\cdot\r\n\\mathcal{M}(2(1 - |\\theta_n|))^{\\text{const.}} \\cdot \\mathcal{M}(1 -\r\n|z_n|)^{\\text{const.}}. \\]</span></p>\r\n<p><strong>(ii)</strong> Next, if <span class=\"math inline\">\\(e^{i\\theta_n}\\)</span> belongs to <span class=\"math inline\">\\(\\alpha&#39; + \\beta&#39; +\r\n\\mathcal{T}&#39;\\)</span>: <span class=\"math display\">\\[\r\n\\mathcal{M}_n(\\beta&#39;)^{\\text{const.}} \\cdot \\mathcal{M}(1 -\r\n|\\theta_n|). \\]</span> Similarly, <span class=\"math display\">\\[\r\n\\mathcal{M}_n(\\mathcal{T}&#39;)^{\\text{const.}} \\cdot \\mathcal{M}(1 -\r\n|\\theta_n|), \\]</span> resulting in <span class=\"math display\">\\[\r\n\\mathcal{M}_n(Q)^{\\text{const.}} \\cdot \\mathcal{M}(2(1 -\r\n|\\theta_n|))^{\\text{const.}} \\cdot \\mathcal{M}(1 -\r\n|z_n|)^{\\text{const.}}. \\]</span></p>\r\n<p>Therefore, in any case: <span class=\"math display\">\\[\r\n\\mathcal{M}_n(Q)^{\\text{const.}} \\cdot \\mathcal{M}(2(1 -\r\n|\\theta_n|))^{\\text{const.}} \\cdot \\mathcal{M}(1 -\r\n|z_n|)^{\\text{const.}}. \\]</span></p>\r\n<p>Since <span class=\"math inline\">\\(\\lim_{n \\to \\infty} |z_n - 1| =\r\n0\\)</span> (Theorem XI. 8), for sufficiently small <span class=\"math inline\">\\(\\varepsilon &gt; 0\\)</span>: <span class=\"math display\">\\[ \\lim_{n \\to \\infty}\r\n\\mathcal{M}_n(Q)^{\\text{const.}} \\cdot \\mathcal{M}(2(1 -\r\n|\\theta_n|))^{\\text{const.}} \\cdot \\mathcal{M}(1 -\r\n|z_n|)^{\\text{const.}} = 0. \\]</span></p>\r\n<p>Hence, if <span class=\"math inline\">\\(E = \\bigcap_{n=0}^\\infty\r\nT_n(Q)\\)</span>, then <span class=\"math inline\">\\(E\\)</span> is\r\ninvariant by <span class=\"math inline\">\\(\\mathcal{S}\\)</span>, and <span class=\"math inline\">\\(0 &lt; p(E) &lt; p(Q) = (2\\pi)^3\\)</span>.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"hopfs-ergodic-theorem\">Hopf's Ergodic Theorem</h1>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>Let <span class=\"math inline\">\\(S:z^{\\prime}=\\frac{z - a}{1 - az}\r\n(0&lt;a&lt;1)\\)</span> and <span class=\"math inline\">\\(J: z=e^{i\\theta}\r\n( 0&lt;\\eta\\leq |\\theta| \\leq \\pi)\\)</span> be an arc on <span class=\"math inline\">\\(|z|=1\\)</span>. Then <span class=\"math inline\">\\(S(J)\\)</span> is contained in an arc <span class=\"math display\">\\[J^*: z=e^{i\\phi} (|\\theta-\\pi| \\leq\r\n{2\\pi(1-a)}/{\\sin^2\\eta}) \\text{ on } |z|=1.\\]</span></p>\r\n<p>Let <span class=\"math inline\">\\(e\\)</span> be a measurable set\r\ncontained in <span class=\"math inline\">\\(J\\)</span>, then <span class=\"math display\">\\[\r\n\\frac{(1-a)}{2}me \\leq m S(e)\\leq \\frac{2(1-a)}{2\\sin^2\\eta} \\text{ on }\r\n|z|=1,\r\n\\]</span> hence <span class=\"math display\">\\[\\frac{J^{*}}{8\\pi}\r\n2\\sin^2\\eta \\cdot me \\leq m S(e) \\leq \\frac{J^{*}}{2\\pi} me,\\]</span>\r\nwhere <span class=\"math inline\">\\(|J^*|=\\frac{4\\pi(1-a)}{\\sin^2\\eta}\\)</span> is the\r\nlength of <span class=\"math inline\">\\(J^{*}\\)</span>.</p>\r\n<h3 id=\"proof\">Proof</h3>\r\n<p>$ |z<sup>{}|</sup>{2} = dz $. If <span class=\"math inline\">\\(z=e^{i\\theta} \\in J\\)</span>, then <span class=\"math display\">\\[\r\n\\frac{1-a}{2} \\leq \\frac{1-a^{2}}{|1-az|^{2}} \\leq\r\n\\frac{2(1-a)}{\\sin^{2}\\eta}\r\n\\]</span> so that from <span class=\"math display\">\\[\r\n{m{S(e)}} = \\int_{e} \\frac{1-a^{2}}{|1-az|^{2}} |dz|\r\n\\]</span> we have <span class=\"math display\">\\[\r\n\\frac{1-a}{2}me \\leq m{S(e)} \\leq \\frac{2(1-a)}{\\sin^2\\eta}me\r\n\\]</span></p>\r\n<p>From this, we see that <span class=\"math inline\">\\(S(J)\\)</span> is\r\ncontained in an arc <span class=\"math display\">\\[J^{*}: z\r\n=e^{i\\theta}  (|\\theta - \\pi| \\leq 2 \\pi\r\n(1-a)/\\sin^{2}\\eta)\\]</span></p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>Let <span class=\"math inline\">\\(D_0\\)</span> be the fundamental\r\ndomain of a Fuchsian group <span class=\"math inline\">\\(G\\)</span> and\r\n<span class=\"math inline\">\\(\\sigma(D_0)&lt;\\infty\\)</span>. Let <span class=\"math inline\">\\(K_0: |z| \\leq \\delta\\)</span> be a disc contained\r\nin <span class=\"math inline\">\\(D_0\\)</span> and <span class=\"math inline\">\\({K_n}\\)</span> be its equivalents. Let <span class=\"math inline\">\\(K^*=\\bigcup K_n\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(r_{\\nu}=1—\\lambda^{\\nu}\r\n(0&lt;\\lambda&lt;1) (\\nu = 1,2,\\dots)\\)</span>. If <span class=\"math inline\">\\(\\lambda\\)</span> is sufficiently small, then there\r\nexists <span class=\"math inline\">\\(\\rho_{\\nu} (r_{\\nu}\\leq \\rho_{\\nu}\r\n\\leq r_{\\nu+1})\\)</span> satisfying the following condition.</p>\r\n<p>The circle <span class=\"math inline\">\\(|z|=\\rho_{\\nu}\\)</span>\r\nintersects <span class=\"math inline\">\\(K^{*}\\)</span> in a set of arcs,\r\namong them there are arcs <span class=\"math inline\">\\(\\theta_{j}\r\n(j=1,2,\\dots,s_{\\nu})\\)</span>, such that</p>\r\n<p><span class=\"math display\">\\[\\kappa^{\\prime}(1- \\rho_{\\nu}) \\geq\r\n|\\theta_{j}| \\geq \\kappa (1- \\rho_{\\nu}), \\quad \\sum_{j=1}^{s_{\\nu}}\r\n\\geq \\eta &gt;0\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(|\\theta_j|\\)</span> denotes the\r\nangular magnitude of <span class=\"math inline\">\\(\\theta_j\\)</span> and\r\n<span class=\"math inline\">\\(\\kappa^{\\prime}&gt;0\\)</span>, <span class=\"math inline\">\\(\\kappa&gt;0\\)</span>, <span class=\"math inline\">\\(\\eta&gt;0\\)</span> are constants independent of\r\n<span class=\"math inline\">\\(\\nu\\)</span>.</p>\r\n<h3 id=\"proof-1\">Proof</h3>\r\n<p>By Theorem XI.10, <span class=\"math inline\">\\(\\frac{\\text{const.}}{1-r} \\leq n(r,a) \\leq\r\n\\frac{\\text{const.}}{1-r}\\)</span> for any <span class=\"math inline\">\\(a\r\n\\in K_{0}\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(K^{*}(r_{\\nu}, r_{\\nu+1})\\)</span> be\r\nthe part of <span class=\"math inline\">\\(K^{*}\\)</span> contained in\r\n<span class=\"math inline\">\\(r_{\\nu} \\leq |z| \\leq r_{\\nu+1}\\)</span>,\r\nthen</p>\r\n<p><span class=\"math display\">\\[\\begin{eqnarray}\r\n\\sigma(K^{*}(r_{\\nu}, r_{\\nu+1})) =&amp; \\int_{a\\in K_{0}} (\r\nn(r_{\\nu+1},a) - n(r_{\\nu},a))  d\\sigma(a) \\nonumber \\\\\r\n\\geq&amp; \\int_{a\\in K_{0}} \\left(\\frac{\\text{const.}}{1-r_{\\nu+1}} -\r\n\\frac{\\text{const.}}{1-r_{\\nu}} d\\sigma(a)\r\n\\right)\\geq \\frac{\\text{const.}}{\\lambda^{\\nu+1}} -\r\n\\frac{\\text{const.}}{\\lambda^{\\nu}} \\geq\r\n\\frac{\\text{const.}}{\\lambda^{\\nu+1}}\r\n\\end{eqnarray}\\]</span></p>\r\n<p>if <span class=\"math inline\">\\(\\lambda\\)</span> is sufficiently\r\nsmall.</p>\r\n<p>Let <span class=\"math inline\">\\(\\theta (r)\\)</span> be the angular\r\nmagnitude of the part of the circle <span class=\"math inline\">\\(|z|=r\\)</span> contained in <span class=\"math inline\">\\(K^{*}\\)</span>, then <span class=\"math display\">\\[\r\n\\sigma(K^{*}(r_{\\nu},r_{\\nu+1})) = 4 \\iint_{K^{*}(r_{\\nu},r_{\\nu+1})}\r\n\\frac{rdrd\\theta}{(1-r^{2})^{2}} = 4\\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{r\r\n\\theta(r) dr}{(1-r^{2})^{2}} &lt;  4\\int_{r_{\\nu}}^{r_{\\nu+1}}\r\n\\frac{\\theta(r) dr}{(1-r)^{2}}\r\n\\]</span></p>\r\n<p>so that by (1) <span class=\"math display\">\\[\\begin{equation}\r\n\\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{\\theta(r) dr}{(1-r)^{2}} \\geq\r\n\\frac{\\text{const.}}{\\lambda^{\\nu+1}}.\r\n\\end{equation}\\]</span></p>\r\n<p>Let the maximum of <span class=\"math inline\">\\(\\theta(r)\\)</span> in\r\n<span class=\"math inline\">\\([r_{\\nu}, r_{\\nu+1}]\\)</span> be attained at\r\n<span class=\"math inline\">\\(r=\\rho_{v}\\)</span>, then <span class=\"math display\">\\[\r\n\\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{\\theta(r) dr}{(1-r)^{2}} \\geq\r\n\\theta(\\rho_{\\nu}) \\int_{r_{\\nu}}^{r_{\\nu+1}} \\frac{dr}{(1-r)^{2}}\r\n&lt;\\frac{\\theta(\\rho_{\\nu})}{\\lambda^{\\nu+1}},\r\n\\]</span> so that by (2)</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\theta(\\rho_{\\nu}) \\geq 2 \\eta &gt;0, \\quad \\eta = \\text{const.} (\\nu =\r\n1,2,\\dots).\r\n\\end{equation}\\]</span></p>\r\n<p>Let the circle <span class=\"math inline\">\\(|z|=\\rho_{\\nu}\\)</span>\r\nintersect <span class=\"math inline\">\\(K^{*}\\)</span> in a set of arcs\r\n<span class=\"math inline\">\\(\\theta_{i} (i=1, 2, \\dots, N)\\)</span>, then\r\n<span class=\"math display\">\\[\\theta(\\rho_{\\nu}) = \\sum_{i=1}^{N}\r\n|\\theta_{i}| \\geq 2 \\eta\\]</span></p>\r\n<p>Since <span class=\"math inline\">\\(\\theta_{i}\\)</span> is contained in\r\nan equivalent <span class=\"math inline\">\\(K_{i}\\)</span> of <span class=\"math inline\">\\(K_0\\)</span>, which intersects <span class=\"math inline\">\\(|z|=\\rho_{\\nu}\\)</span> and the radius of <span class=\"math inline\">\\(K_i\\)</span> is <span class=\"math inline\">\\(\\leq\r\n\\text{const.} (1 - \\rho_{\\nu})\\)</span>,</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n|\\theta_i| \\leq \\text{conts.}(1-\\rho_{\\nu}).\r\n\\end{equation}\\]</span></p>\r\n<p>For a fixed <span class=\"math inline\">\\(c&gt;0\\)</span>, we decompose\r\n<span class=\"math inline\">\\(\\{d_j\\}\\)</span> into two classes: <span class=\"math display\">\\[\r\n\\{d_j\\} = \\{d_j\\} + \\{d_j^*\\} \\text{ where } |d_j| \\leq c(1-p_v) \\text{\r\nand } |d_j^*| \\leq c(1-p_v)\r\n\\]</span> so that <span class=\"math display\">\\[\r\n2\\sum|d_j|^2 + 3\\sum|d_j^*|^2 \\leq c^2(2+3)\\sum(1-p_v)\r\n\\]</span></p>\r\n<p>If an equivalent <span class=\"math inline\">\\(K_s\\)</span> of <span class=\"math inline\">\\(K_0\\)</span> intersects the circle <span class=\"math inline\">\\(|z|=pv\\)</span>, then <span class=\"math inline\">\\(K_s\\)</span> is contained in <span class=\"math inline\">\\(|z|^p^*\\)</span> such that <span class=\"math inline\">\\(1-|d_j|^{\\frac{1}{2}} \\leq c(1-p_v)\\)</span>, so\r\nthat <span class=\"math inline\">\\(N^n(p^*, a) \\leq \\frac{c^2}{c(1-p_v)}\r\n\\cdot \\frac{1}{1-c(1-p_v)} \\leq c\\)</span>.</p>\r\n<p>Hence, if we choose <span class=\"math inline\">\\(\\epsilon\\)</span> so\r\nsmall that <span class=\"math inline\">\\(A^tc^y\\)</span>, then by the\r\nabove conditions, we have $$ (1-|d_j|) <em>{j=1}^{N} +\r\n</em>{j=1}^{N}</p>\r\n<p>3|d_j^*|^2 _{v=1}^{} (1-p_v) $$</p>\r\n<h3 id=\"note\">Note</h3>\r\n<ul>\r\n<li><span class=\"math inline\">\\(|d_j| \\leq\r\n\\sqrt{\\frac{\\epsilon}{1-p_v}}\\)</span></li>\r\n<li><span class=\"math inline\">\\(|d_j^*| \\leq c(1-p_v)\\)</span></li>\r\n</ul>\r\n<p>This completes the proof.</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li><strong>Hopf's Ergodic Theorem</strong></li>\r\n</ol>\r\n<p>Let <span class=\"math inline\">\\(y_1 = e^{i\\theta_1}\\)</span>, <span class=\"math inline\">\\(y_2 = e^{i\\theta_2}\\)</span> be two points on\r\n<span class=\"math inline\">\\(|z| = 1\\)</span>, then the pair <span class=\"math inline\">\\((\\theta_1, \\theta_2)\\)</span> can be considered as\r\na point of a torus <span class=\"math inline\">\\(\\theta: 0 \\leq \\theta_1,\r\n\\theta_2 &lt; 2\\pi\\)</span>.</p>\r\n<p>For a measurable set <span class=\"math inline\">\\(E\\)</span> on <span class=\"math inline\">\\(\\theta\\)</span>, we define its measure <span class=\"math inline\">\\(m(E)\\)</span> by <span class=\"math display\">\\[\r\nm(E) = \\int\\!\\!\\!\\int_E d\\theta_1 d\\theta_2, \\]</span> so that <span class=\"math inline\">\\(m(\\theta) = 4\\pi^2\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(S_v\\)</span> be any substitution of a\r\nFuchsian group <span class=\"math inline\">\\(G\\)</span>, and <span class=\"math inline\">\\(T_v: \\theta = S_v(\\theta)\\)</span>, then the\r\ntotality of <span class=\"math inline\">\\(\\{T_v\\}\\)</span> constitutes a\r\ngroup (<span class=\"math inline\">\\(S = G \\times G\\)</span>).</p>\r\n<p>Hopf ([1], [2]) proved the following theorem.</p>\r\n<p><strong>Theorem XI. 23. (Hopf's Ergodic Theorem)</strong> If <span class=\"math inline\">\\(m(D_0) &lt; \\infty\\)</span>, then there exists no\r\nmeasurable set <span class=\"math inline\">\\(E\\)</span> on <span class=\"math inline\">\\(\\theta\\)</span>, which is invariant by <span class=\"math inline\">\\(\\circledast\\)</span> and <span class=\"math inline\">\\(m(\\circledast(E)) &lt; 4\\pi^2\\)</span>.</p>\r\n<p>Hence if <span class=\"math inline\">\\(m(E) &gt; 0\\)</span>, then <span class=\"math inline\">\\(m(E) = 4\\pi^2\\)</span>.</p>\r\n<p><strong>Proof. (Tsuji [47])</strong> Suppose that there exists a\r\nmeasurable set <span class=\"math inline\">\\(E\\)</span> on <span class=\"math inline\">\\(\\theta\\)</span>, which is invariant by <span class=\"math inline\">\\(\\circledast\\)</span> and <span class=\"math inline\">\\(m(E) &gt; 0\\)</span>, and we shall prove that\r\n<span class=\"math inline\">\\(m(E) = 4\\pi^2\\)</span>. Let <span class=\"math inline\">\\(f(\\theta_1, \\theta_2)\\)</span> be the\r\ncharacteristic function of <span class=\"math inline\">\\(E\\)</span> and\r\nput <span class=\"math display\">\\[ u(z, w) = \\frac{1}{\\pi^2} \\iint_{D_0\r\n\\times D_0} \\frac{f(\\theta_1, \\theta_2)}{|z - e^{i\\theta_1}|^2 |w -\r\ne^{i\\theta_2}|^2} \\,d\\theta_1 d\\theta_2, \\]</span> where <span class=\"math inline\">\\(D_0 = \\{|z| &lt; 1, |w| &lt; 1\\}\\)</span>, then\r\n<span class=\"math inline\">\\(u(z, w)\\)</span> is invariant by <span class=\"math inline\">\\(\\circledast\\)</span>, such that <span class=\"math display\">\\[ u(S(z), S(w)) = u(z, w), \\quad S \\in\r\n\\circledast. \\]</span></p>\r\n<p>We denote the Stolz domain: <span class=\"math inline\">\\(|arg(1 -\r\nze^{-i\\theta})| &lt; \\frac{\\pi}{4}\\)</span> by <span class=\"math inline\">\\(\\Sigma(e^{i\\theta})\\)</span> and <span class=\"math inline\">\\(\\Sigma(e^{-i\\theta})\\)</span> be its part,\r\ncontained in <span class=\"math inline\">\\(|z - e^{i\\theta}| &lt;\r\n\\delta\\)</span>, then by Theorem IV. 12, for almost all <span class=\"math inline\">\\((\\theta_1, \\theta_2)\\)</span> on <span class=\"math inline\">\\(\\theta\\)</span>, <span class=\"math inline\">\\(\\lim\r\nu(z, w) = f(\\theta_1, \\theta_2)\\)</span> uniformly, if <span class=\"math inline\">\\(z \\to e^{i\\theta_1}, w \\to e^{i\\theta_2}\\)</span>\r\nfrom the inside of <span class=\"math inline\">\\(\\Sigma(e^{i\\theta_1}),\r\n\\Sigma(e^{i\\theta_2})\\)</span> respectively.</p>\r\n<p>Let <span class=\"math inline\">\\(E_{\\theta_1}\\)</span> be the section\r\nof <span class=\"math inline\">\\(E\\)</span> by the line <span class=\"math inline\">\\(\\theta_1 = const. = \\theta\\)</span> and <span class=\"math inline\">\\(E_{\\theta_2}\\)</span> be that by the line <span class=\"math inline\">\\(\\theta_2 = const. = \\theta\\)</span>, then <span class=\"math display\">\\[ \\iint_{\\theta_2} mE_{\\theta_1} d\\theta_2 &gt; 0,\r\n\\]</span> where <span class=\"math inline\">\\(mE_{\\theta_1}\\)</span>\r\ndenotes the linear measure.</p>\r\n<p>Since <span class=\"math inline\">\\(m(D_0) &lt; \\infty, G\\)</span> is\r\nof divergence type (Theorem XI. 10), so that there exists no measurable\r\nset <span class=\"math inline\">\\(e\\)</span> on <span class=\"math inline\">\\(|z| = 1\\)</span>, which is invariant by <span class=\"math inline\">\\(G\\)</span> and <span class=\"math inline\">\\(m_e\r\n&lt; 2\\pi\\)</span>, hence if <span class=\"math inline\">\\(m_e &gt;\r\n0\\)</span>, then <span class=\"math inline\">\\(m_e = 2\\pi\\)</span>.</p>\r\n<p>If <span class=\"math inline\">\\(mE_{\\theta_1}[\\theta_2] = 0\\)</span>\r\non a set <span class=\"math inline\">\\(\\theta\\)</span> of positive measure\r\nin <span class=\"math inline\">\\([0, 2\\pi]\\)</span>, then since, by the\r\nhypothesis on <span class=\"math inline\">\\(E\\)</span>, such a set <span class=\"math inline\">\\(\\theta\\)</span> is invariant by <span class=\"math inline\">\\(G\\)</span>, <span class=\"math inline\">\\(m_e =\r\n2\\pi\\)</span>, so that <span class=\"math inline\">\\(mE_{\\theta_1}[\\theta_2] = 2\\pi\\)</span> almost\r\neverywhere in <span class=\"math inline\">\\([0, 2\\pi]\\)</span>, hence\r\n<span class=\"math inline\">\\(m(E) = 0\\)</span>, which is absurd.</p>\r\n<p>Hence <span class=\"math display\">\\[ mE_{\\theta_1}[\\theta_2] &gt; 0\r\n\\text{ for almost all } \\theta \\in [0, 2\\pi]. \\]</span></p>\r\n<p>Hence by Egoroff's theorem, there exists a closed subset <span class=\"math inline\">\\(E_0\\)</span> of <span class=\"math inline\">\\(E\\)</span> which satisfies the following\r\nconditions (i), (ii), (iii), where <span class=\"math inline\">\\(\\delta\r\n&gt; 0\\)</span> and <span class=\"math inline\">\\(\\epsilon &gt; 0\\)</span>\r\nare sufficiently small constants.</p>\r\n<ol type=\"i\">\r\n<li><span class=\"math inline\">\\(E_0\\)</span> lies outside of the strip:\r\n<span class=\"math inline\">\\(|\\theta - \\theta_1| &lt; \\epsilon\\)</span>,\r\nmod. <span class=\"math inline\">\\(2\\pi\\)</span>.</li>\r\n<li>Let <span class=\"math inline\">\\(E_0\\)</span> be the projection of\r\n<span class=\"math inline\">\\(E_0\\)</span> on the <span class=\"math inline\">\\(\\theta_1\\)</span>-axis, then <span class=\"math inline\">\\(mE_0 &gt; 2\\pi - \\delta\\)</span> and <span class=\"math inline\">\\(mE_{\\theta_2}[\\theta_1] &gt; 0\\)</span> for any\r\n<span class=\"math inline\">\\(\\theta \\neq \\theta_0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(\\lim u(z, w) = 1\\)</span> uniformly on\r\n<span class=\"math inline\">\\(E_0\\)</span>, when <span class=\"math inline\">\\(z \\to e^{i\\theta_1}, w \\to e^{i\\theta_2}\\)</span>\r\nfrom the inside of <span class=\"math inline\">\\(\\Sigma(e^{i\\theta_1}),\r\n\\Sigma(e^{i\\theta_2})\\)</span> respectively.</li>\r\n</ol>\r\n<p>When <span class=\"math inline\">\\(z \\in E_0, w \\in\r\n\\Sigma(e^{i\\theta})\\)</span>, then <span class=\"math display\">\\[ 1 -\r\n\\epsilon &lt; u(z, e^{i\\theta}) &lt; 1, \\quad \\theta \\in\r\nE_{\\theta_2}[\\theta_1], \\]</span> where <span class=\"math inline\">\\(u(z,\r\ne^{i\\theta}) = \\lim u(z, w)\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(K_0: |z| &lt; r\\)</span> be a disc,\r\ncontained in <span class=\"math inline\">\\(D_0\\)</span> and <span class=\"math inline\">\\(\\{K_n\\}\\)</span> be its equivalents <span class=\"math inline\">\\(\\infty\\)</span> and <span class=\"math inline\">\\(K*\r\n= \\bigcup K_n\\)</span>, then by Lemma 2, there exist <span class=\"math inline\">\\(0 &lt; \\phi_1 &lt; \\phi_2 &lt; \\ldots &lt; \\phi_v\r\n+ 1\\)</span> such that the circle <span class=\"math inline\">\\(|z| =\r\ne^{i\\phi_v}\\)</span> intersects <span class=\"math inline\">\\(K*\\)</span>\r\nin a set of arcs <span class=\"math inline\">\\(d_j (j = 1, 2, \\ldots,\r\nv)\\)</span>, such that $$ (1 - e^{i_v})<sup>{|F_j|</sup>2} (1 -\r\ne^{i_v}), j = 1, 2, , v, |F_j| d_j.</p>\r\n<p>Since <span class=\"math inline\">\\(\\{d_j\\}\\)</span> are disjoint, if\r\nin the condition (ii), <span class=\"math inline\">\\(\\delta &gt;\r\n0\\)</span> is sufficiently small, then by the second inequality of (7),\r\nwe may assume that every <span class=\"math inline\">\\(d_j\\)</span>\r\ncontains a point <span class=\"math inline\">\\(e^{i\\theta_j} \\in\r\nE_0\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(K_j: Z \\mapsto Z_j \\mapsto Z_j\r\n\\mapsto B_j \\mapsto T_{g_j} \\mapsto Z_j = a_je^{i\\theta_j}\\)</span> (8)\r\nbe the equivalent of <span class=\"math inline\">\\(K_0\\)</span>, which\r\ncontains the arc <span class=\"math inline\">\\(d_j\\)</span> where <span class=\"math inline\">\\(Z_j \\in K_j\\)</span> is an equivalent of <span class=\"math inline\">\\(z = 0\\)</span> and let <span class=\"math display\">\\[ K_0 = \\bigcup_{j} K_j, \\quad 0 = S_j(Z_j), \\quad\r\nS_j \\in G. \\]</span></p>\r\n<p>Since <span class=\"math inline\">\\(d_j\\)</span> contains <span class=\"math inline\">\\(e^{i\\theta_j}\\)</span>, if the radius <span class=\"math inline\">\\(r\\)</span> of <span class=\"math inline\">\\(K_0\\)</span> is sufficiently small and <span class=\"math inline\">\\(v &gt; v_0\\)</span>, then by Theorem XI. 2, <span class=\"math inline\">\\(z_3\\)</span> is contained in <span class=\"math inline\">\\(\\Sigma(e^{i\\theta_3})\\)</span>. Hence by (6),\r\n<span class=\"math display\">\\[ 1 - e^{i\\theta_3} &lt; u(z_3,\r\ne^{i\\theta_3}) &lt; 1 \\text{ for any } v &gt; v_0, \\]</span></p>\r\n<p>where <span class=\"math inline\">\\(\\lim_{v \\to 0} \\epsilon_v =\r\n0\\)</span> with <span class=\"math inline\">\\(\\lim_{v \\to 0} v_0 =\r\n\\infty\\)</span>.</p>\r\n<p>Since <span class=\"math inline\">\\(u(z, w)\\)</span> is invariant by\r\n<span class=\"math inline\">\\(\\circledast\\)</span>, we have <span class=\"math display\">\\[ 1 - \\epsilon_v &lt; u(0, e^{i\\theta_3}) &lt; 1\r\n\\text{ for any } \\theta \\in E_{\\theta_1}[\\theta_2]. \\]</span></p>\r\n<p>Hence if we put <span class=\"math display\">\\[ \\epsilon_v =\r\n\\Sigma_{\\circledast}(a_{jv}) \\]</span> then <span class=\"math display\">\\[ 1 - \\epsilon_v &lt; u(0, e^{i\\theta_3}) &lt; 1\r\n\\text{ for any } \\theta \\in E_{\\theta_1}[\\theta_2]. \\]</span></p>\r\n<p>Hence if we put <span class=\"math display\">\\[ \\epsilon_v =\r\n\\Sigma_{\\circledast}(a_{jv}) \\]</span> then <span class=\"math display\">\\[ 1 - \\Sigma_{\\circledast}(a_{jv}) &lt; u(0,\r\ne^{i\\theta_3}) &lt; 1 \\text{ for any } v &gt; v_0. \\]</span></p>\r\n<p>Since <span class=\"math inline\">\\(u(0, e^{i\\theta_3}) = \\lim_{v \\to\r\n0} u(z_3, e^{i\\theta_3})\\)</span>, then <span class=\"math display\">\\[ 1\r\n- \\lim_{v \\to 0} \\Sigma_{\\circledast}(a_{jv}) &lt; \\lim_{v \\to 0} u(z_3,\r\ne^{i\\theta_3}) &lt; 1. \\]</span></p>\r\n<p>We shall prove that <span class=\"math display\">\\[ \\lim_{v \\to 0}\r\n\\Sigma_{\\circledast}(a_{jv}) &gt; 0 \\quad (j = 1, 2, \\ldots).\r\n\\]</span></p>\r\n<p>Let <span class=\"math inline\">\\(K_j = S_j(K_0)\\)</span>, then <span class=\"math inline\">\\(K_j\\)</span> is obtained from <span class=\"math inline\">\\(K_0\\)</span> by a rotation about <span class=\"math inline\">\\(2\\theta_j = 0\\)</span>, so that the circle <span class=\"math inline\">\\(|z| = e^{i\\phi_v}\\)</span> intersects <span class=\"math inline\">\\(K_j\\)</span> in an arc <span class=\"math inline\">\\(d_{jv}\\)</span> whose projection on <span class=\"math inline\">\\(|z| = 1\\)</span> from <span class=\"math inline\">\\(z = 0\\)</span> be denoted by <span class=\"math inline\">\\(J_{jv}\\)</span>, then <span class=\"math inline\">\\(|J_{jv}| = |J_j|\\)</span>, so that <span class=\"math display\">\\[ \\text{const.} (1 - e^{i\\phi_v}) &lt;\r\n\\Sigma_{\\circledast}(|J_{jv}|^2) \\leq \\text{const.} (1 - e^{i\\phi_v}),\r\n\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(|J_{jv}|\\)</span> denotes the\r\nangular magnitude of <span class=\"math inline\">\\(d_{jv}\\)</span>.</p>\r\n<p>Since <span class=\"math inline\">\\(J_{jv}\\)</span> contains <span class=\"math inline\">\\(e^{i\\theta_j}\\)</span>, if the radius <span class=\"math inline\">\\(r\\)</span> of <span class=\"math inline\">\\(K_0\\)</span> is sufficiently small and <span class=\"math inline\">\\(v &gt; v_0\\)</span>, then by Lemma 1, <span class=\"math inline\">\\(S_j(E_0)[\\theta_j]\\)</span> is contained in an arc\r\n<span class=\"math inline\">\\(J_{jv}\\)</span> on <span class=\"math inline\">\\(|z| = 1\\)</span>, concentric with <span class=\"math inline\">\\(J_j\\)</span> such that <span class=\"math display\">\\[ \\Sigma_{\\circledast}[\\theta_j] \\leq\r\n\\text{const.} |J_{jv}|. \\]</span></p>\r\n<p>By Lemma 1, <span class=\"math inline\">\\(|J_j| = \\text{const.} (1 -\r\ne^{i\\theta_j})\\)</span> and since <span class=\"math display\">\\[\r\n\\text{const.} (1 - e^{i\\phi_v}) &lt; \\Sigma_{\\circledast}[\\theta_j] \\leq\r\n\\text{const.} |J_{jv}|, \\]</span></p>\r\n<p>we have <span class=\"math display\">\\[ \\text{const.} (1 - e^{i\\phi_v})\r\n&lt; \\text{const.} (1 - e^{i\\theta_j}) \\]</span> <span class=\"math display\">\\[ \\text{const.} (1 - e^{i\\phi_v}) &lt;\r\n\\text{const.} (1 - e^{i\\theta_j}) \\]</span></p>\r\n<p>Hence by (14), (16), <span class=\"math inline\">\\(|J_j| =\r\n\\text{const.} |J_{jv}|\\)</span>, so that by (14), we have <span class=\"math display\">\\[ \\Sigma_{\\circledast}(|J_j|) &gt; 0 \\quad (j = 1,\r\n2, \\ldots). \\]</span></p>\r\n<p>Since <span class=\"math inline\">\\(|J_j| &gt; \\text{const.} (1 -\r\ne^{i\\theta_j})\\)</span> and <span class=\"math inline\">\\(J_j,\r\nJ_{jv}\\)</span> are disjoint, the distance between the centers of <span class=\"math inline\">\\(J_j, J_{jv}\\)</span> is <span class=\"math inline\">\\(\\text{const.} (1 - e^{i\\theta_j})\\)</span>. Since\r\n<span class=\"math inline\">\\(J_{jv}\\)</span> is concentric with <span class=\"math inline\">\\(J_j\\)</span> and <span class=\"math inline\">\\(|J_j|\r\n= \\text{const.} (1 - e^{i\\theta_j})\\)</span>, <span class=\"math inline\">\\(\\{J_j\\}\\)</span> overlap at most <span class=\"math inline\">\\(N\\)</span>-times, where <span class=\"math inline\">\\(N\\)</span> is independent of <span class=\"math inline\">\\(v\\)</span>.</p>\r\n<p>Since <span class=\"math inline\">\\(S_j(E_0)[\\theta_j],\r\n\\{S_j(E_0)[\\theta_j]\\}\\)</span> overlap at most <span class=\"math inline\">\\(N\\)</span>-times, so that by (15), (17), <span class=\"math display\">\\[ mM_v &gt; \\Sigma_{\\circledast}\r\nmS_j(E_0)[\\theta_j] &gt; \\text{const.} \\Sigma_{\\circledast} |J_{jv}|\r\n&gt; \\text{const.} &gt; 0 \\quad (j =1, 2, \\ldots, v).\r\nHence if we put\r\n\\]</span> u(0, w) = - <em>{} F_j <span class=\"math display\">\\[\r\nthen\r\n\\]</span> m_1 &gt; 0 <span class=\"math display\">\\[\r\nand by (12),\r\n\\]</span> u(0, e^{i<em>3}) = 1, </em>{} (a</em>{jv}) = m_1. $$</p>\r\n<p>Now <span class=\"math display\">\\[ \\iint_{\\Sigma(e^{i\\theta})}\r\n\\frac{|w - e^{i\\theta}|^2}{|w - e^{i\\theta_3}|^2} \\,d\\theta =\r\n\\frac{\\pi}{\\Sigma_{\\circledast}(a_{jv})}. \\]</span></p>\r\n<p>Hence for almost all <span class=\"math inline\">\\(\\theta\\)</span> on\r\n<span class=\"math inline\">\\(\\theta\\)</span>, <span class=\"math inline\">\\(1 = u(0, e^{i\\theta_3}) = F(\\theta) =\r\n\\Sigma_{\\circledast} (a_{jv})\\)</span> or <span class=\"math display\">\\[\r\nm[\\theta] = 2\\pi. \\]</span></p>\r\n<p>Since the set <span class=\"math inline\">\\(e\\)</span> of <span class=\"math inline\">\\(\\theta\\)</span>, such that <span class=\"math inline\">\\(m[\\theta] = 2\\pi\\)</span> is invariant by <span class=\"math inline\">\\(G\\)</span> and <span class=\"math inline\">\\(m_E[\\theta] = 2\\pi\\)</span> on a set <span class=\"math inline\">\\(M\\)</span> of positive measure, we see that <span class=\"math inline\">\\(m_E[\\theta] = 2\\pi\\)</span> almost everywhere in\r\n<span class=\"math inline\">\\([0, 2\\pi]\\)</span>, hence <span class=\"math display\">\\[ m(E) = 4\\pi^2. \\]</span></p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>Next we consider the <span class=\"math inline\">\\(n\\)</span>-dimensional case. Let <span class=\"math inline\">\\(y_1=e^{i\\theta_1}, \\ldots,\r\ny_n=e^{i\\theta_n}\\)</span> be <span class=\"math inline\">\\(n\\)</span>\r\npoints on <span class=\"math inline\">\\(|z|=1\\)</span>, then the pair\r\n<span class=\"math inline\">\\((\\theta_1, \\ldots, \\theta_n)\\)</span> can be\r\nconsidered as a point of an <span class=\"math inline\">\\(n\\)</span>-dimensional torus <span class=\"math inline\">\\(\\mathcal{T}_n: 0 \\leq \\theta_1 \\leq 2\\pi, \\ldots,\r\n0 \\leq \\theta_n \\leq 2\\pi\\)</span> and the measure <span class=\"math inline\">\\(p(E)\\)</span> of a measurable set <span class=\"math inline\">\\(E\\)</span> on <span class=\"math inline\">\\(\\mathcal{T}_n\\)</span> is defined by <span class=\"math display\">\\[ p(E) = \\int \\cdots \\int_E d\\theta_1 \\cdots\r\nd\\theta_n, \\]</span> so that <span class=\"math inline\">\\(p(\\mathcal{T}_n) = (2\\pi)^n\\)</span>.</li>\r\n</ol>\r\n<p>Let <span class=\"math inline\">\\(\\mathcal{S}\\)</span> be any\r\nsubstitution of a Fuchsian group <span class=\"math inline\">\\(G\\)</span>\r\nand <span class=\"math display\">\\[ T_v: (\\theta_1, \\ldots, \\theta_n)\r\n\\mapsto (\\theta_1&#39;, \\ldots, \\theta_n&#39;), \\quad (1) \\]</span> then\r\nthe totality of <span class=\"math inline\">\\(\\{T_v\\}\\)</span> constitutes\r\na group <span class=\"math inline\">\\(\\mathcal{S}_n = G \\times \\ldots\r\n\\times G\\)</span>.</p>\r\n<p><strong>Theorem XI. 24.</strong> Let <span class=\"math inline\">\\(G\\)</span> be a Fuchsian group and <span class=\"math inline\">\\(D_0\\)</span> be its fundamental domain, where\r\n<span class=\"math inline\">\\(a(D_0)\\)</span> may be finite or infinite.\r\nIf <span class=\"math inline\">\\(n \\geq 3\\)</span>, then there exists\r\nalways a measurable set <span class=\"math inline\">\\(E\\)</span> on <span class=\"math inline\">\\(\\mathcal{T}_n\\)</span>, which is invariant by\r\n<span class=\"math inline\">\\(\\mathcal{S}\\)</span> and <span class=\"math inline\">\\(0 &lt; p(E) &lt; (2\\pi)^n\\)</span>. (Tsuji\r\n[14]).</p>\r\n<p><strong>Proof.</strong> Since the proof is the same, we assume that\r\n<span class=\"math inline\">\\(n=3\\)</span> and put <span class=\"math inline\">\\(\\theta_1=0, \\theta_2=\\pi,\r\n\\theta_3=\\pi\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(\\mathcal{Q}\\)</span>: <span class=\"math display\">\\[ \\mathcal{Q}: 0 \\leq \\theta_1 \\leq\r\n\\frac{\\pi}{16}, \\quad \\theta_2: \\pi \\leq \\theta_2 \\leq \\pi, \\quad\r\n\\theta_3: \\pi \\leq \\theta_3 \\leq \\pi \\]</span> be a cube on <span class=\"math inline\">\\(\\mathcal{T}_3\\)</span> and <span class=\"math inline\">\\(\\alpha, \\alpha&#39;, \\beta, \\beta&#39;,\r\n\\mathcal{T}, \\mathcal{T}&#39;\\)</span> be arcs on <span class=\"math inline\">\\(|z|=1\\)</span>, such that <span class=\"math display\">\\[ \\alpha: \\text{arg}z - \\pi \\leq \\theta_1 \\leq\r\n\\text{arg}z, \\quad \\alpha&#39;: \\text{arg}z \\leq \\theta_1 \\leq\r\n\\text{arg}z + \\pi, \\quad \\beta: |\\text{arg}z - \\pi| \\leq \\theta_2 \\leq\r\n|\\text{arg}z|, \\quad \\beta&#39;: |\\text{arg}z - \\pi| \\leq \\theta_3 \\leq\r\n|\\text{arg}z|, \\]</span> <span class=\"math display\">\\[ \\mathcal{T}:\r\n\\text{arg}z \\leq \\theta_1 \\leq \\text{arg}z + \\frac{\\pi}{16}, \\quad\r\n\\mathcal{T}&#39;: \\pi \\leq \\text{arg}z \\leq \\pi. \\]</span></p>\r\n<p>So that <span class=\"math inline\">\\(\\mathcal{Q} = \\alpha \\cup\r\n\\alpha&#39; \\cup \\beta \\cup \\beta&#39; \\cup \\mathcal{T} \\cup\r\n\\mathcal{T}&#39;\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(K_0: |z| \\leq p\\)</span> be a disc,\r\ncontained in <span class=\"math inline\">\\(D_0\\)</span> and <span class=\"math inline\">\\(K_n: z = r_ne^{i\\theta_n}\\)</span> (<span class=\"math inline\">\\(n=0,1,2,\\ldots\\)</span>) be its equivalents and\r\nlet <span class=\"math inline\">\\(z \\mapsto z_n = \\frac{1}{1 -\r\nz\\overline{z_n}}\\)</span> be the equivalent of <span class=\"math inline\">\\(K_n\\)</span>, then <span class=\"math inline\">\\(K_0\r\n= S_n(K_n), 0 = S_n(z_n), S_n \\in G\\)</span>.</p>\r\n<p><strong>(i)</strong> If <span class=\"math inline\">\\(e^{i\\theta_n}\\)</span> belongs to the complement\r\nof <span class=\"math inline\">\\(\\alpha + \\alpha&#39; + \\beta +\r\n\\beta&#39;\\)</span>, then since <span class=\"math inline\">\\(\\theta_1\r\n&lt; \\frac{\\pi}{16}\\)</span>, we have for any <span class=\"math inline\">\\(z\\)</span> on <span class=\"math inline\">\\(\\alpha\\)</span>, <span class=\"math inline\">\\(|\\text{arg}z - \\theta_n| \\geq\r\n\\frac{\\pi}{16}\\)</span>, hence by Lemma 1, <span class=\"math display\">\\[\r\n\\mathcal{M}_n(\\mathcal{Q}) \\geq \\text{const.} \\cdot M(1 - |\\theta_n|)\r\n\\cdot \\text{M}(1 - |z_n|). \\]</span></p>\r\n<p>Similarly, <span class=\"math display\">\\[\r\n\\mathcal{M}_n(\\beta)^{\\text{const.}} \\cdot \\text{M}(1 - |\\theta_n|),\r\n\\quad \\mathcal{M}_n(\\mathcal{T})^{\\text{const.}} \\cdot \\text{M}(1 -\r\n|\\theta_n|), \\]</span> so that <span class=\"math display\">\\[\r\n\\mathcal{M}_n(\\mathcal{Q})^{\\text{const.}} \\cdot \\text{M}(2(1 -\r\n|\\theta_n|))^{\\text{const.}} \\cdot \\]</span></p>\r\n<p><strong>(i)</strong> For <span class=\"math inline\">\\(e^{i\\theta_n}\\)</span> in the complement of <span class=\"math inline\">\\(\\alpha&#39; + \\beta&#39; +\r\n\\mathcal{T}&#39;\\)</span>, the following holds: <span class=\"math display\">\\[ \\mathcal{M}_n(Q)^{\\text{const.}} \\cdot\r\n\\mathcal{M}(2(1 - |\\theta_n|))^{\\text{const.}} \\cdot \\mathcal{M}(1 -\r\n|z_n|)^{\\text{const.}}. \\]</span></p>\r\n<p><strong>(ii)</strong> Next, if <span class=\"math inline\">\\(e^{i\\theta_n}\\)</span> belongs to <span class=\"math inline\">\\(\\alpha&#39; + \\beta&#39; +\r\n\\mathcal{T}&#39;\\)</span>: <span class=\"math display\">\\[\r\n\\mathcal{M}_n(\\beta&#39;)^{\\text{const.}} \\cdot \\mathcal{M}(1 -\r\n|\\theta_n|). \\]</span> Similarly, <span class=\"math display\">\\[\r\n\\mathcal{M}_n(\\mathcal{T}&#39;)^{\\text{const.}} \\cdot \\mathcal{M}(1 -\r\n|\\theta_n|), \\]</span> resulting in <span class=\"math display\">\\[\r\n\\mathcal{M}_n(Q)^{\\text{const.}} \\cdot \\mathcal{M}(2(1 -\r\n|\\theta_n|))^{\\text{const.}} \\cdot \\mathcal{M}(1 -\r\n|z_n|)^{\\text{const.}}. \\]</span></p>\r\n<p>Therefore, in any case: <span class=\"math display\">\\[\r\n\\mathcal{M}_n(Q)^{\\text{const.}} \\cdot \\mathcal{M}(2(1 -\r\n|\\theta_n|))^{\\text{const.}} \\cdot \\mathcal{M}(1 -\r\n|z_n|)^{\\text{const.}}. \\]</span></p>\r\n<p>Since <span class=\"math inline\">\\(\\lim_{n \\to \\infty} |z_n - 1| =\r\n0\\)</span> (Theorem XI. 8), for sufficiently small <span class=\"math inline\">\\(\\varepsilon &gt; 0\\)</span>: <span class=\"math display\">\\[ \\lim_{n \\to \\infty}\r\n\\mathcal{M}_n(Q)^{\\text{const.}} \\cdot \\mathcal{M}(2(1 -\r\n|\\theta_n|))^{\\text{const.}} \\cdot \\mathcal{M}(1 -\r\n|z_n|)^{\\text{const.}} = 0. \\]</span></p>\r\n<p>Hence, if <span class=\"math inline\">\\(E = \\bigcap_{n=0}^\\infty\r\nT_n(Q)\\)</span>, then <span class=\"math inline\">\\(E\\)</span> is\r\ninvariant by <span class=\"math inline\">\\(\\mathcal{S}\\)</span>, and <span class=\"math inline\">\\(0 &lt; p(E) &lt; p(Q) = (2\\pi)^3\\)</span>.</p>\r\n"},{"title":"Kronecker's Jugendtraum","mathjax":true,"_content":"\nKronecker's Jugendtraum (or Hilbert's 12th problem) is to find abelian extensions of arbitrary number fields by adjoining `special' values of transcendental \n\nKronecker once proved that all the Galois extensions of the rationals $\\mathbb{Q}$ with Abelian Galois groups are subfields of cyclotomic fields $\\mathbb{Q}(\\mu_n)$, where $\\mu_n$ is the group of $n$-th roots of unity.\n\n\nKronecher wrote in a letter to Dedekind:\n\n*Es handelt sich um meinen liebsten Jugendtraum, n\\\"amlich um den Nachweis, dass die Abel'schen Gleichungen mit Quadratwurzeln rationaler Zahlen durch die Transformations-Gleichungen elliptischer Functionen mit singularen Moduln grade so ersch\\\"opft werden, wie die ganzzahligen Abel'schen Gleichungen durch die Kreisteilungsgleichungen.*\n\n\n\n## Explicit Class Field Theory\n\n### Theorem 1(Kronecker–Weber)\n$$\\mathbb{Q}^{ab} = \\bigcup_{ n\\geq 1} \\mathbb{Q}(e^{2\\pi i /n}).$$\n\n### Theorem 2\n\nLet $F$ be a quadratic imaginary field. Let $E$ denote an elliptic curve with complex multiplication by the ring of integers $\\mathcal{O}_{F}$ and let $w$ denote the Weber function. We have\n\n$$F^{ab} = \\bigcup_{ n\\geq 1} F(j(E), w(E[n])).$$\n\n\n\n*Example:* the abelian extension $\\mathbf {Q} (i,{\\sqrt[{4}]{1+2i}})/\\mathbf {Q} (i)$ is not generated by singular moduli and roots of unity.\n\n\n[1] [bananaspace](https://www.bananaspace.org/wiki/Kronecker_%E9%9D%92%E6%98%A5%E4%B9%8B%E6%A2%A6)\n\n[2] [wikipedia](https://en.wikipedia.org/wiki/Hilbert%27s_twelfth_problem)","source":"_drafts/Hilbert12.md","raw":"---\ntitle: Kronecker's Jugendtraum\ntags:\n    - [Hilbert's 23 Problems, Algebraic Number Theory]\ncategories:\n    - [Hilbert's 12th Problem, Commutative Algebra, Algebraic Number Theory, Algebraic Geometry]\nmathjax: true\n---\n\nKronecker's Jugendtraum (or Hilbert's 12th problem) is to find abelian extensions of arbitrary number fields by adjoining `special' values of transcendental \n\nKronecker once proved that all the Galois extensions of the rationals $\\mathbb{Q}$ with Abelian Galois groups are subfields of cyclotomic fields $\\mathbb{Q}(\\mu_n)$, where $\\mu_n$ is the group of $n$-th roots of unity.\n\n\nKronecher wrote in a letter to Dedekind:\n\n*Es handelt sich um meinen liebsten Jugendtraum, n\\\"amlich um den Nachweis, dass die Abel'schen Gleichungen mit Quadratwurzeln rationaler Zahlen durch die Transformations-Gleichungen elliptischer Functionen mit singularen Moduln grade so ersch\\\"opft werden, wie die ganzzahligen Abel'schen Gleichungen durch die Kreisteilungsgleichungen.*\n\n\n\n## Explicit Class Field Theory\n\n### Theorem 1(Kronecker–Weber)\n$$\\mathbb{Q}^{ab} = \\bigcup_{ n\\geq 1} \\mathbb{Q}(e^{2\\pi i /n}).$$\n\n### Theorem 2\n\nLet $F$ be a quadratic imaginary field. Let $E$ denote an elliptic curve with complex multiplication by the ring of integers $\\mathcal{O}_{F}$ and let $w$ denote the Weber function. We have\n\n$$F^{ab} = \\bigcup_{ n\\geq 1} F(j(E), w(E[n])).$$\n\n\n\n*Example:* the abelian extension $\\mathbf {Q} (i,{\\sqrt[{4}]{1+2i}})/\\mathbf {Q} (i)$ is not generated by singular moduli and roots of unity.\n\n\n[1] [bananaspace](https://www.bananaspace.org/wiki/Kronecker_%E9%9D%92%E6%98%A5%E4%B9%8B%E6%A2%A6)\n\n[2] [wikipedia](https://en.wikipedia.org/wiki/Hilbert%27s_twelfth_problem)","slug":"Hilbert12","published":0,"date":"2024-02-25T15:11:07.048Z","updated":"2024-02-25T15:11:07.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5rr0006m8nxbad6crzj","content":"<p>Kronecker's Jugendtraum (or Hilbert's 12th problem) is to find\r\nabelian extensions of arbitrary number fields by adjoining `special'\r\nvalues of transcendental</p>\r\n<p>Kronecker once proved that all the Galois extensions of the rationals\r\n<span class=\"math inline\">\\(\\mathbb{Q}\\)</span> with Abelian Galois\r\ngroups are subfields of cyclotomic fields <span class=\"math inline\">\\(\\mathbb{Q}(\\mu_n)\\)</span>, where <span class=\"math inline\">\\(\\mu_n\\)</span> is the group of <span class=\"math inline\">\\(n\\)</span>-th roots of unity.</p>\r\n<p>Kronecher wrote in a letter to Dedekind:</p>\r\n<p><em>Es handelt sich um meinen liebsten Jugendtraum, n\"amlich um den\r\nNachweis, dass die Abel'schen Gleichungen mit Quadratwurzeln rationaler\r\nZahlen durch die Transformations-Gleichungen elliptischer Functionen mit\r\nsingularen Moduln grade so ersch\"opft werden, wie die ganzzahligen\r\nAbel'schen Gleichungen durch die Kreisteilungsgleichungen.</em></p>\r\n<h2 id=\"explicit-class-field-theory\">Explicit Class Field Theory</h2>\r\n<h3 id=\"theorem-1kroneckerweber\">Theorem 1(Kronecker–Weber)</h3>\r\n<p><span class=\"math display\">\\[\\mathbb{Q}^{ab} = \\bigcup_{ n\\geq 1}\r\n\\mathbb{Q}(e^{2\\pi i /n}).\\]</span></p>\r\n<h3 id=\"theorem-2\">Theorem 2</h3>\r\n<p>Let <span class=\"math inline\">\\(F\\)</span> be a quadratic imaginary\r\nfield. Let <span class=\"math inline\">\\(E\\)</span> denote an elliptic\r\ncurve with complex multiplication by the ring of integers <span class=\"math inline\">\\(\\mathcal{O}_{F}\\)</span> and let <span class=\"math inline\">\\(w\\)</span> denote the Weber function. We have</p>\r\n<p><span class=\"math display\">\\[F^{ab} = \\bigcup_{ n\\geq 1} F(j(E),\r\nw(E[n])).\\]</span></p>\r\n<p><em>Example:</em> the abelian extension <span class=\"math inline\">\\(\\mathbf {Q} (i,{\\sqrt[{4}]{1+2i}})/\\mathbf {Q}\r\n(i)\\)</span> is not generated by singular moduli and roots of unity.</p>\r\n<p>[1] <a href=\"https://www.bananaspace.org/wiki/Kronecker_%E9%9D%92%E6%98%A5%E4%B9%8B%E6%A2%A6\">bananaspace</a></p>\r\n<p>[2] <a href=\"https://en.wikipedia.org/wiki/Hilbert%27s_twelfth_problem\">wikipedia</a></p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>Kronecker's Jugendtraum (or Hilbert's 12th problem) is to find\r\nabelian extensions of arbitrary number fields by adjoining `special'\r\nvalues of transcendental</p>\r\n<p>Kronecker once proved that all the Galois extensions of the rationals\r\n<span class=\"math inline\">\\(\\mathbb{Q}\\)</span> with Abelian Galois\r\ngroups are subfields of cyclotomic fields <span class=\"math inline\">\\(\\mathbb{Q}(\\mu_n)\\)</span>, where <span class=\"math inline\">\\(\\mu_n\\)</span> is the group of <span class=\"math inline\">\\(n\\)</span>-th roots of unity.</p>\r\n<p>Kronecher wrote in a letter to Dedekind:</p>\r\n<p><em>Es handelt sich um meinen liebsten Jugendtraum, n\"amlich um den\r\nNachweis, dass die Abel'schen Gleichungen mit Quadratwurzeln rationaler\r\nZahlen durch die Transformations-Gleichungen elliptischer Functionen mit\r\nsingularen Moduln grade so ersch\"opft werden, wie die ganzzahligen\r\nAbel'schen Gleichungen durch die Kreisteilungsgleichungen.</em></p>\r\n<h2 id=\"explicit-class-field-theory\">Explicit Class Field Theory</h2>\r\n<h3 id=\"theorem-1kroneckerweber\">Theorem 1(Kronecker–Weber)</h3>\r\n<p><span class=\"math display\">\\[\\mathbb{Q}^{ab} = \\bigcup_{ n\\geq 1}\r\n\\mathbb{Q}(e^{2\\pi i /n}).\\]</span></p>\r\n<h3 id=\"theorem-2\">Theorem 2</h3>\r\n<p>Let <span class=\"math inline\">\\(F\\)</span> be a quadratic imaginary\r\nfield. Let <span class=\"math inline\">\\(E\\)</span> denote an elliptic\r\ncurve with complex multiplication by the ring of integers <span class=\"math inline\">\\(\\mathcal{O}_{F}\\)</span> and let <span class=\"math inline\">\\(w\\)</span> denote the Weber function. We have</p>\r\n<p><span class=\"math display\">\\[F^{ab} = \\bigcup_{ n\\geq 1} F(j(E),\r\nw(E[n])).\\]</span></p>\r\n<p><em>Example:</em> the abelian extension <span class=\"math inline\">\\(\\mathbf {Q} (i,{\\sqrt[{4}]{1+2i}})/\\mathbf {Q}\r\n(i)\\)</span> is not generated by singular moduli and roots of unity.</p>\r\n<p>[1] <a href=\"https://www.bananaspace.org/wiki/Kronecker_%E9%9D%92%E6%98%A5%E4%B9%8B%E6%A2%A6\">bananaspace</a></p>\r\n<p>[2] <a href=\"https://en.wikipedia.org/wiki/Hilbert%27s_twelfth_problem\">wikipedia</a></p>\r\n"},{"title":"75 Problems in the Foundation of Mathematics","date":"2023-09-22T14:10:39.000Z","mathjax":true,"_content":"\n\n1) Lorsqu'un ensemble de points $P$ est une image biunivoque et continue (mais pas n\\'ecessairement bicontinue) d'un ensemble $Q$ et lorsque $Q$ est une image biunivoque et continue de $P$, lest ensembles $P$ et $Q$ sont-ils n\\'ecessairement homeomorphes?\n\nProbl\\'eme de M. W. Sierpinski.\n\n2) Un continu (born\\'e) plan, topologiquement homog\\`ene, est-il n\\'ecessairement hom\\'eomorphe \\`a une circonf\\'erence?\n\n(Un ensemble $E$ est dit *topologiquement homog\\'ene*, lorsqu'il existe pour tout couple de points $a,b$ de $E$ une transformation biunivoque et bicontinue de $E$ en lui-m\\'eme qui transforme $a$ en $b$)\n\nProbl\\'eme de MM. B. Knaster et C. Kuratowski.\n\n3) Un ensemble ordonn\\'e (lin\\'eairement) sans sauts ni lacunes et tel que tout ensemble de ses intervalles (contenant plus qu'un \\'el\\'ement) n'empi\\'etant pas les uns sur les autres est au plus d\\'enombrable, est-il n\\'ecessairement un continu lin\\'eaire (ordinaire)?\n\nProbl\\'eme de M. M. Souslin.\n\n4) Existe-t-il une d\\'ecomposition d'un intervalle en $\\aleph_{1}$ ensembles (non vides) mesurables $B$ et sans point commun deux \\`a deux?\n\nProbl\\'eme de M. W. Sierpinski.\n\n5) Existe-t-il un ensemble lin\\'eaire ind\\'enombrable $E$ tel que tout ensemble lin\\'eaire hom\\'eomorphe \\`a $E$ soit de mesure lebesguienne nulle? Peut-on d\\'emontrer l'existence d'un tel ensemble, m\\'eme en admettant que $2^{\\aleph_{0}} = \\aleph_{1}$?\n\nProbl\\'eme de M. W. Sierpinski.\n\n6) Peut-on d\\'emoutrer sans l'hypoth\\'ese du continu ($2^{\\aleph_{0}} = \\aleph_{1}$) qu'une somme de $\\aleph_{1}$ ensembles de mesure lebesguienne nulle n'est pas n\\'ecessairement de mesure lebesquienne nulle? qu'une somme de $\\aleph_{1}$ ensembles de premi\\'ere cat\\'egorie n'est pas n\\'ecessairement de premi\\'ere cat\\'egorie? qu'un produit de $\\aleph_{1}$ ensembles ($A$) n'est pas n\\'ecessairement un ensemble $A$?\n\nProbl\\'eme de M. W. Sierpinski.\n\n7) Peut-on \\'etablir sans l'hypoth\\'ese du continu l'esistence d'un ensemble plan qui est de mesure (lebesguienne) nulle sur toute parall\\'ele \\`a l'axe d'abscisses et dont le compl\\'ementaire est de mesure nulle sur toute parall\\'ele \\`a l'axe d'ordonn\\'ees?\n\nProbl\\'eme de M. H. Steinhaus.\n\n8) Peut-on donner un exemple effectif d'un ensemble de nombres r\\'eels $E$ tel que toute somme, toute diff\\'erence, tout produit et tout quotient de deux nombres de $E$ (la division par 0 except\\'ee) appartienne \\`a $E$ et que $E$ soit ind\\'enombrable, mais distinct de l'ensemble de tous les nombres r\\'eels?\n\nProbl\\'eme de M. S. Mazurkiewicz.\n\n9) Quelle est la puissance des ensembles compl\\'ementaires aux ensembles ($A$)?\n\nProbl\\'eme de M. N. Lusin.\n\n\n*Remarque*. Les ensembles ($A$) lin\\'eaires sont des projections orthogonales (sur une froite) des ensembles plans mesurables $B$. M. Lusin a d\\'emontr\\'e que la puissance d'un ensemble ind\\'enombrable compl\\'ementaire \\`a un ensemble ($A$) est $\\aleph_{1}$ ou $2^{\\aleph_{0}}$, mais on ne sait pas si elle peut \\^etre en r\\'ealit\\'e $\\aleph_{1}$ (dans le cas o\\'u $2^{\\aleph_{0}} > \\aleph_{1}$)\n\n10) Existe-t-il une fonction de deuxi\\'eme classe qui n'est pas une limite de fonctions presque partout continues? Peut-on donner un exemple effectif d'une fonction qui n'est pas une limite de fonctions ponctuellement discontinues?\n\nProbl\\'eme de MM. T. Feosztyn et W. Sierpinski.\n\n11) Existe il une classe ($\\mathcal{L}$) de M. Fr\\'echet (c'est-\\`a dire une classe dans laquelle la limite est d\\'efinie) de puissance sup\\'erieure \\`a celle du continu, telle que tout ensemble non d\\'enombrable d'\\'el\\'ements de cette classe contient au moins un \\'el\\'ement de condensation?\n\nProbl\\'eme de M. W. Sierpinski.\n\n12) Un ensemble ordonn\\'e (lin\\'eairement) dont tous les sousensembles bien ordonn\\'es (croissants et d\\'croissants) sont au plus d\\'enombrables, a-t-il n\\'ecessairement une puissance non sup\\'erieure \\`a celle du continu?\n\nProbl\\'eme de M. W. Sierpinski.\n\n13) Existe-il un ensemble plan ferm\\'e qui ne soit pas somme de deux ensembles ferm\\'es sans points communs, mais qui est une somme d'une infinit\\'e d\\'enombrable d'ensembles ferm\\'es sans points communs deux \\`a deux.\n\nProbl\\'eme de M. W. Sierpinski.\n\n14) Un continu dans l'espace \\`a $m$ dimensions qui est hom\\'eomorphe de tout continu qu'il contient, est il n\\'ecessairement un arc simple (c'est-\\`a-dire une image biunivoque et continu de l'intervalle 0-1)?\n\nProbl\\'eme de M. Mazurkiewicz.\n\n15) Existe-il un continu dont tout sous continu est ind\\'ecomposable? (Un continu est dit ind\\'ecomposable lorsqu'il n'est pas une somme de deux continus diff\\'erents de lui.)\n\nProbl\\'eme de MM. Knaster et Kuratowski.\n\n16) Existe il un continu (non born\\'e) qui est une somme de ses vrais sous continus satur\\'es n'ayant deux \\`a deux aucun point commun?\n\n(On dit qu'un vrai sous-continu $K$ de $C$ est *satur\\'e*, lorsqu'il n'existe aucun continu diff\\'erent de $K$ et de $C$ qui contienne $K$ et qui soit contenu dans $C$.)\n\nProbl\\'eme de M. Kuratowski.\n\n17) Quelle est la puissance de l'ensemble de toutes les valeurs que ne prend pas une fonction de classe 1 de M. Baire?\n\n(Ce probl\\'eme est \\'equivalent au probl\\'eme 9 de M. Lusin, t. I. p.224. Il suffirait de r\\'esoudre ce probl\\'eme pour les fonctions admettant une infinit\\'e d'enombrable de points de discontinuit\\'e.)\n\n18) Un ensemble (lin\\'eaire) de puissance inf\\'erieure \\`a celle du continu, est-il n\\'ecessairement d\\'e la premi\\'ere cath\\'egorie de M. Baire?\n\nProbl\\'eme de M. Ruziewicz.\n\n19) Existe-t-il dans chaque ensemble biconnexe $B$ un point $p$ tel que l'ensemble $B - (p)$ ne contient aucun ensemble connexe?\n\n*Remarque*. D'apre\\'es un th\\'eor\\'eme de M. Kline (ce volume, p.238), il ne peut exister dans un ensemble connexe $B$ plus d'un point $p$ jouissant de la propri\\'et\\'e en question. On sait, d'autre part, que, si un tel point existe, l'ensemble $B$ est biconnexe, c.-\\`a-d. il n'est pas somme de duex ensembles connexes disjoints cont\\'enant plus d'un point (cf. Knaster et Kuratowski, *Fund. Math.* II, p,214.)\n\nProbl\\'eme de M. Kuratowski.\n\n20) Soit $f(E)$ une fonction d\\'efinie por tout ensemble $E$ mesurable ($L$) d'un espace euclidien \\`a $m \\geq 3$ dimensions et satisfaisant aux conditions suivantes:\n\n1. $f(E)\\geq 0$.\n2. $f(E_{0}) = 1$ pur un certain ensemble $E_{0}$ de mesure 1.\n3. $f(E_{1} +E_{2}) = f(E_{1}) + f(E_{2})$, si $E_{1} E_{2} = 0$.\n4. $f(E_{1}) = f(E_{2})$, si $E_{1}$ et $E_{2}$ sont superposables.\n\nLa fonction $f(E)$ coincide-t-elle n\\'ecessairement avec la mesure lebesguienne de l'ensemble $E$?\n\n(Pour $m=1$ et $m=2$ la r\\'eponse est n\\'egative, comme l'a prouv\\'e M. Banach dans un m\\'emoire qui sera publi\\'e dans le tome IV de ce jounal.)\n\nProbl\\'eme de M. Ruziewicz.\n\n21) A \\'etant un ensemble de nombres r\\'eels qui n'est de I cat\\'egorie dans aucun intervalle, existe-il une d\\'ecomposition: $A = B + C$, $B \\times C = 0$ telle que ni $B$ ni $C$ ne soient de I cat\\'egorie dans aucun intervalle?\n\n*Remarque*. On en pourrait donner la solution affirmative dans l'hypoth\\'ese suppl\\'ementaire que $A$ poss\\'ede la propri\\'et\\'e de Baire (au sens etabli dans ce volume), p.319. M. Sierpinski en a signal\\'e d'autre part, la solution affirmative dans l'hypoth\\'ese du continu, $\\aleph_{1} = 2^{\\aleph_{0}}$.\n\nProblem of M. Kuratowski.\n\n22) Appellons l'ensemle (lin\\'eaire) $E$ *parfaitement mesurable*, si tout ensemble hom\\'eomorphe \\`a $E$ est mesurable au sens de Lebesgue. Quelle est la puissance de la classe des ensembles parfaitement mesurables? Un ensemble compl'ementaire \\`a un ensemble parf. mesurable est-il toujours parf. mesurable?\n\nProblem of M. Urysohn.\n\n23) Esiste-t-il une fonction d'une variable r\\'eelle $f(x)$ pantachiquement dicontinue et telle qu'on ait pour tout $x$ r\\'eel\n\n$$\\lim \\frac{f(x+h) - f(x-h)}{2h} = 0?$$\n\nProblem of M. Steinhaus.\n\n24) Une fonction satisfaisan \\`a la condition de Baire, est-elle n\\'ecessairement mesurable ($L$)? Quelle est la puissance de toutes les fonctions d'une variable r'eelle satisfaisant \\`a la condition de Baire? (On dit qu'une fonction $f(x)$ satisfait \\`a la condition de Baire, si elle continue sur tout ensemble parfait quand on n\\'eglige les ensembles de premi\\'ere cat\\'egorie par rapport \\`a cet ensemble parfait.)\n\nProblem of M. Sierpinski.\n\n25) Un ensemble plan, tel que toute droite le rencontre en deux (et seulement deux) points, peut-il \\^etre mesurable ($B$)? (L'existence d'un tel ensemble a \\'et\\'e d\\'emontr\\'e, \\`a l'aide du th\\'eor\\'eme de M. Zermelo, par MM. Mazurkiewicz[^1] (en 1914) et Rosenthal[^2] (en 1922))\n\n\n[^1] Comptes Rendus de lu Soc. des Sciences de Varsovic, t. VII, p.382.\n\n[^2] Sitzungaber d. Bayer. Akad. d. Wiss., math-phys. K1, 1922, p. 223.\n\n26) Une fonction de classe 3 de M. Baire, est-elle toujours une superposition de trois fonctions de classe 1, c'est-\\`a-dire existe-t-il pour toute fonction $f(x)$ de classe 3 trois fonctions $\\varphi(x)$, $\\psi(x)$ et $\\vartheta(x)$ de classe, telles qu'on a pour tout $x$ r\\'eel\n\n$$f(x) = \\varphi\\{\\psi[\\vartheta(x)]\\}$$\n\nProbl\\'eme de M. Lusin.\n\n27) L'ensemble $D(E)$ des distances des points d'un ensemble lin\\'eaire $E$ mesurable $(B)$, est-il toujours mesurable ($B$)? ( $D(E)$ est done l'ensemble de tous les nombres $|x-y|$, o\\'u $x$ et $y$ appartiennent \\`a $E$. On peut d\\'emontrer l'existence des ensembles $E$ mesurables ($L$), tels que $D(E)$ est non mesurable ($L$).) \n\nProbl\\'eme de M. Sierpinski.\n\n28) $E$ \\'etant un ensemble plan mesurable ($B$), d\\'esignons par $N(E)$ l'ensemble de tous les nombres r\\'eels $a$, tels que la droite $x = a$ rencontre $E$ en une infinit\\'e non-d\\'enombrable de points. L'ensemble $N(E)$, est il n\\'ecessairement un ensemble ($A$), ou, plus simplement, est-il mesurable ($L$)? (On peut d\\'emontrer que l'ensemble de tous les nombres r\\'eels $a$, tels que la droite $x = a$ rencontre l'ensemble $E$ (mesurable $B$) en une infinit\\'e de points est toujouts un ensemble $A$.)\n\nProbl\\'eme de M. Sierpinski.\n\n29) Soit $F$ un ensemble plan, p. ex. ferm\\'e (ou, plus g\\'en\\'eralement, mesurable)- Un point $x$ de $F$ sera dit *lin\\'eairment accessible* s'il sxiste un segment rectiligne $\\overline{xp}$ tel que tous ses points (le point $x$ except\\'e) soient \\'etrangers \\`a $F$. Peut-on d\\'emontrer que l'ensemble $A$ de tous les points lin\\'eairement accessibles de $F$ est toujours mesurable ($L$)?\n\nProbl\\'eme de M. Urysohn.\n\n30) $f(x)$ \\'etant une fonction donn\\'ee quelconque (mesurable ou non), quelle est la mesure de l'ensomble de tous les points $x$, tels que\n\n$$\\lim\\limits_{h\\to 0} \\left|\\frac{f(x+h) - f(x)}{h}\\right| = \\infty$$\n\nProbl\\'eme de M. Ruziewicz.\n\n31) Le th\\'eor\\'eme: \"$\\mathsf{m} = 2\\cdot \\mathsf{m}$ quel soit le nombre cardinal *transfini* $\\mathsf{m}$\" est il \\'equivalent \\`a *l'axiome du choix*?\n\nCf. ma Note \"*Sur quelques th\\'eor\\'emes qui \\'equivalent \\`a l'axiome du choix*\" dans ce volume, p. 147.\n\nProbl\\'eme de M. Tajtelbaum-Tarski.\n\n32) Un ensemble plan ferm\\'e, don tout point est lin\\'eairement accessible, est-il n\\'ecessairement de mesure superficielle nulle?\n\nProbl\\'eme de M. Banach.\n\nUn point $x$ de $F$ est dit lin\\'eairement accessible s'il existe un segment rectiligne $\\overline{xp}$ tel que tous ses points (le point $x$ excepr\\'e) soient \\'etrangers \\`a $F$. M. Urysohn a d\\'emontr\\'e que l'ensemble de tous les points lin\\'eairement accessibles d'un ensemble plan ferm\\'e est toujouts un ensemble ($A$) de M. Souslin, mais peut ne pas \\^etre mesurable ($B$). Or on ne sait pas si l'ensemble de tous les points lin\\'eairement accessibles d'un ensemble plan $G_{\\delta}$ est mesurable ($L$) (Cf. Probl\\'eme 29, *Fund. Math.* t. V, p. 337).\n\n33) Une image biunivoque et continue (dans un sens) d'un ensemble compl\\'emeutaire \\`a un ensemble ($A$) de M. Souslin, est elle de m\\^eme nature?\n\nProbl\\'eme de Sierpi\\'nski.\n\n34) Appelons un ensemble (lin\\`eaire) mesurable ($B$) de classe $\\alpha$ *irr\\'eductible* s'il n'est de classe $<\\alpha$ dans aucun intervalle. Quelle est la puissance de l'ensemble de tous les types topologiques d'ensumbles irr\\'eductibles de classe $\\alpha$?\n\nAppelons un ensemble ($A$) irr\\'eductible, s'il n'est mesurable ($B$) dans aucun intervalle. Quelle est la puissance de tous les types topologiques des ensembles ($A$) irr\\'eductibles?\n\nProbl\\'eme de MM. Alexandroff et Urysohn.\n\n35) Appelons l'ensemble (lin\\'eaire) $E$ *parfaitement mesurable au sens \\'etroit*, si toute image univoque et continue de $E$ est mesurable au sens de Lebsgue. Un ensemble compl\\'ementaire \\`a un ensemble parfaitement mesurable au sens \\'etroit, est-il toujours de m\\^eme nature?\n\nCf. Probl\\'eme 22 de P. Urysohn (*Fund. Math.* t. IV, p. 368), r\\'esolu par M. Lavrentieff (*Fund. Math.* t. VI, p. 159).\n\nProbl\\'eme de M. O. Nikodym.\n\n36) D'apr\\'es M. Souslin, si $E$ est un ensemble ($A$) et $H$ un ensemble compl\\'ementaire \\`a un ensemble ($A$), et si $E \\subset H$, il existe un ensemble $Q$, mesurable ($B$), tel que $E\\subset Q \\subset H$[^3]. Cette proposition, admet-elle une r\\'eciproque, c'est-\\`a-dire, *$E$ \\'etant un ensemble compl\\'ementaire \\`a un ensemble ($A$) et $H$ ------ un ensemble ($A$), tel que $E \\subset H$, existe-til tujours un ensemble $Q$ mesurable ($B$), tel que $E \\subset Q \\subset H$?*\n\nProbl\\'eme de M. Sierpi\\'nski.\n\n[^3] Voir p. e. N. Lusin et W. Sierpi\\'nski *Journ. de Math.* t. II (1923) p. 60; aussi *Bull. Acad. Cracovie* 1918 p. 40.\n\n37) Un continu de Jordan (born\\'e) qui ne renferme qucune courbe simple ferm\\'ee est-il hom\\'eomorphe \\`a un de ses (vrais) sous-continus?\n\nProbl\\'eme de M. Zarankiewicz.\n\n38) Un carr\\'e et un cercle dont les aires sont \\'egales peuvent-ils \\^etre d\\'ecompos\\'es en un nombre fini de sous-ensembles disjoints repectivement congruents?\n\nProbl\\'eme de M. Tarski.\n\n39) Existe-il un ensemble ferm\\'e *plan* pour lequel l'ensemble des points lin\\'eairement accessibles soit non-mesurable ($B$)? (Dans l'espace le probl\\'eme est r\\'esolu par affirmative).\n\nProbl\\'eme de M. O. Nikodym.\n\n40) $E$ \\'etant un ensemble plan $G_{\\delta}$, l'ensemble de tous les nombres r\\'eels $a$, tels que la droite $x =a$ rencontre l'ensemble $E$ dans un et un seul point, est-il n\\'ecessairement compl\\'ementaire d'un ensemble ($A$) de M. Souslin?\n\nProbl\\'eme de M. Sierpi\\'nski.\n\n41) $E_{1}, E_{2}, E_{3}, \\dots$ \\'etant une suite d\\'enombrable d'ensembles lin\\'eaires dont chacun est une projection d'un ensemble plan compl\\'ementaire \\`a un ensemble ($A$) de M. Souslin, l'ensemble $E_{1}E_{2} E_{3} \\dots $ est il de m\\^eme nature?\n\nProbl\\'eme de M. Sierpi\\'nski.\n\n42) Existe-t-il dans tout continu $A$ un continu $B$ tel que l'ensemble $A-B$ soit connexe?\n\nProbl\\'eme de MM. Knaster et Zarankiewicz.\n\n\n43) $D$ d\\'esignant un ensemble ferm\\'e hom\\'eomorphe d'un ensemble plan et situ\\'e dans l'espace euclidien \\`a 3 dimensions, est-ce que tout point de $D$ est *accessible* dans cet espace?\n\n(Un point $d$ de $D$ est dit *accessible* dans $E$, lorsqu'il existe un continu $C \\subset E$ tel que $(d) = CD$).\n\nProbl\\'eme de M. Knaster.\n\n\n46) Es wird gefragt die logischen Relationen zwischen den verschiedenen Homogenit\\\"atsbegriffen aufzutellen, insoweit sie sich beziehen auf im kleinen kompakten Mengen. Insbesondere auch wenn die Mengen als ausammenh\\\"angend und (oder) im kleinen zusammenh\\\"angend vorausgesetzt werden.\n\n(Vgl. D. van Dantzig, \\\"ber topologisch homogene Kontinua, dieser Band, S. 102, 103).\n\nProbl\\'eme de M. van Dantzig.\n\n47) Ist eine jed (zusammenh\\\"angende, unberandete) $n$-dimensionale Mannigfaltigkeit involutorisch homogen?\n\n(Vgl. D. van Dantzig, l. e. S. 104, ^7.)\n\nProbl\\'eme de M. van Dantzig.\n\n48) Nennen wir eine topologische Gruppe *monothetisch*, falls eine unendliche zyklische Gruppe in ihr dicht liegt (in welchem Falle sie kommutativ ist und additiv geschrieben weden kann), und *komplett*, falls eine jede Folge $x_{\\nu}$, die dem Konvergenzkriterium Cauchy's $\\lim (x_{\\nu} - x_{\\mu} = 0$ gen\\\"ugt, ein Limeselement in der Gruppe besitzt, so wird gefragt, ob eine monothetische Gruppe komplett sein kann ohne kompakt zu sein.\n\n(Vgl. l. c. S. 116 ^{29}a)) \n\nProbl\\'eme de M. van Dantzig.\n\n49) Soient $X$ et $Y$ deux continus P\\'eaniens (= images continues de l'intervalle) et $Z$ leur produit topologique (= l'espace de tous les couples $z = (x,y)$ o\\'u $\\lim z_{n}=z$ lorsque $\\lim x_{n} = x$ et $\\lim y_{n} = y$).\n\n1^0. Si le continu $X$, ainsi que $Y$, poss\\'ede la propri\\'et\\'e que dans chaque transformation continue de ce continu en un sous-ensemble il existe un point invariant, est-il vrai que $Z$ poss\\'ede la m\\^eme propri\\'et\\'e?\n\n2^0. Si le continu $X$, ainsi que $Y$, est uni-coh\\'erent (= dans chaque d\\'ecomposition de ce continu en deus sous-continus la partie commune de ces sous-continus est connexe), est-il vrai que $Z$ est unicoh\\'erent?\n\nProbl\\'eme de M. Kuratowski.\n\n50) Ist der topologische Kreis die einzige homogene im kleinen zusammenh\\\"angende Kurve? (Kurve = eindimensionaler zusammen-h\\\"angender kompakter Raum. Homogen hei$\\beta$t ein Raum, der zu je zwei seiner Punkte $p$ und $q$ eine topologische Selbstabbildung besitzt die $p$ in $q$ \\\"uberf\\\"uhrt). In der Ebene ist der Kreis die einzige homogene im kleinen zusammenh\\\"angende Kurve.\n\n(Vgl. Mazurkiewicz, Fund. Math. V, S. 137).\n\nProbl\\'eme de M. K. Menger.\n\n51) Gibt es beliebig oder gar unendlich viele kompakte eindimensionale R\\\"aume, die zu je zweien eindimentional unvergleichbar sind? Dabei m\\\"ogen zwei R\\\"aume $R$ und $R^{\\prime}$ eindimentional unvergleichbar hei$\\beta$en, wenn keine eindimensionale Teilmenge von $R$, (bzw. von $R^{\\prime}$) hom\\\"oomorph ist mit einer Teilmenge von $R^{\\prime}$ (bzw. von $R^{\\prime}$). Beispielsweise sind eindimensional unvergleichbar eine Strecke und ein Kontinuum ohne Teilbogen. (Wenn es $n$, bzw. $\\aleph_{0}$ paarweise eindimensional unvergleichbare Kurven gibt, so existieren kompakte eindimensionale R\\\"aume, welche mindestens $2^{n} +1$, bze. $2^{\\aleph_{0}}$ monotone, $F_{\\sigma}$-additive, toppologische, kompaktifizierbare Systeme von Teilmengen enthalten).\n\n\n(Vgl. Monatshefte f. Math. u. Phys. 36, S. 207).\n\nProbl\\'eme de M. K. Menger.\n\n52) Existe-il un continu dont tout autre continu soit une image continue?\n\nProbl\\'eme de M. H. Hahn.\n\n\n53)\ta) Ist jeder absolute Retrakt in endlich viele absolute Retrakte mit beliebig kleinen Durchmessern zerlegbar?\n\nb) Lasst sieh jede $R$-Menge in endlich viele absolu#e Retrakte zerlegen?\n\n(Die Definition von absoluten Retrakten und von $R$-Mengen ist z. B. in meiner Note aus Fund. Math. XIX, S. 222 angegeben).\n\n54)\tIst jedes Teilkontinuum $C$ des eaklidieelien $n$-dimensionalen Raumes $R_{n}$, welches $R_{n}$ zerschneidet und welches eich durch beliebig kleine Transformationen (d. h. durch eine stetige Abbildung, welehe jeden Punkt von $C$ in einen beliebig nahe liegenden Punkt von $R_{n}$ tiberfiibrt) in eine mit ihm punktfremde Teilmenge von R. \\\"uberf\\\"uhren lasst, eine ($n-1$)-dimensionale Mannigfaltigkeit?\n\n55)\tL\\\"asst sich jedes in $R_{3}$ liegende und $R_{3}$ zerschneidende Streckenbild in eich stetig und fixpunktfrei abbilden?\n\nProbl\\'emes de M. K. Borsuk.\n\n56) Soient $A$ et $B$ deux espaces topologiques et $A^{2}$ et $B^{2}$ respectivement leur carr\\'es (a. \\`a. d. $A^{2}$ p. ex. se compose de tous tes couples ($a_{1}$, $a_{2}$) extraite de $A$).\n\nEst-il vrai que si $A^{2}$ et $B^{2}$ sont hom'eomorphes. $A$ et $B$ le sont aussi?\n\nEn ess de relronae positire, on en d\\'eduit que, $C$ \\'etant un ensemble qui n'est\nhom\\'eomorphe \\`a aucun, $C^{n}$, $n>1$, les ensembles $C^{m}$ et $C^{n}$ ne sont non plus hom\\'eomorphes pour $m\\neq n$; cela fournit dans le eas o\\`u $C$ est un intervalle 1e th\\'eor\\'eme de \"l'invariance de la dimension\" de M. Brouwer.\n\nProbl\\'eme de M. S. Ulam.\n\n57) Existe-il un continu de dimension infinie qui n'en contient aucun de dimension finie?\n\nProbl'eme de M. S. Mazurkiewicz.\n \n58)\tGibt es in einer Menge $E$ von der M\\\"achtigkeit $\\aleph_{1}$ ein abz\\\"ahlbares System von Teilmengen $A_{1}, A_{2},\\dots$ derart, dass man in der Gestalt\n$$X = \\overline{\\lim} A_{p_{n}}$$\n($p_{1}, p_{2},,\\dots$ Teilfolge der nat\\\"urlichen Zahlen, $\\overline{\\lim}$ bedeutet dag Barel-sche *ensemble limite complet*) alle Teilmengen $X$ von $E$ erh\\\"alt?\n\n(Es handelt sich, die Verneinung ohne Benutzung der Kontinuumhypethese zu beweisen).\n\nProbl\\'me de M. F. Hausdorff.\n\n59)\tUne fonction jouissant de la propri\\'et\\'e de Baire (c'est-\\`a-dire continue sur tout ensemble parfait, lorsqu'on n\\'eglige un ensemble de\t$1^{re}$ cat\\'egorie relativement \\`a cet ensemble) d'une fonction jouiseant de la propri\\'et\\'e de Baire, est-elle de la m\\^eme nature?\n\nProbl\\'eme de M. W. Sierpi\\'nski.\n\n60)\tSoit $\\rho$ l'ensemble de toutes les transformations hom\\'eomorphes du plan cart\\'esien en lui-m\\^eme, de la forme:\n$$x^{\\prime} = x, \\quad y^{\\prime} =f(x,y)$$\net\n$$x^{\\prime}=g(x,y), \\quad\ty^{\\prime}=y.$$\n\nD\\'esignons par $\\sigma$ le groupe form\\'e par toutes les superpositions finies de toutes les transformations appartenant \\`a $\\rho$. Une transformation hom\\'eomorphe arbitraire du plan en lui-m\\^eme se laisse-telle toujours approcher par celles du groupe $\\sigma$?\n\nUn probl\\'eme analogue subsiste pour les espaces \\`a $n>2$ dimensions.\nProbl\\'eme de M. S. Ulam.\n\n61)\tSoit $E$ un ensemble plan $G_{\\delta}$ (plus g\\'en\\'eralement: un ensemble borelien) dont tontes les intersections avec les droites parall\\'eles \\`a l'axe des $y$ sont des ensembles ferm\\'es (plus g\\'en\\'eralement: des $F_{\\sigma}$). La projection de $E$ sur l'axe des $x$ est-elle toujours un ensemble\nborelien?\t\n\nProbl\\'eme de M. E. Szpilrajsn.\n\n62)\tDie (reelle) Funktion $f(x)$ der reellen Variablen $x$ heisse *symmetrisch-stetig* wenn f\\\"ur jedes $x$\n$$\\lim\\limits_{h \\to 0} [f(x+h) - f(x - h)] = O.$$\nKann die Menge der Unstetigkeitsstellen einer solchen Funktion unabz\\\"ahlbar sein? Kann sie eine beliebig vorgeschriebene Menge $F_{\\sigma}$ sei? (Dass sie eine beliebig vorgeschriebene abz\\\"ahlbare Menge sein\nkann, ist leicht einzusehen.)\n\nProbl\\'eme de M. F. Hausdorff.\n\n63)\tDeux espaces compacts $A$ et $B$ ont le *m\\^eme type d'homotopie*, lorsqu'il existe une transformation continue $f$ de $A$ en $B$ et une transformation continue $f$ de $A$ en $B$ et une transformation continue $\\varphi$ de $B$ en $A$, telles que les transformations superpos\\'ees $\\varphi f$ et $f\\varphi$ (consid\\'er\\'ees respectivement comme des trans-formations de $A$ en $A$ et de $B$ en $B$) soient homotopes \\`a l'identit\\'e. Deux vari\\'et\\'es ferm\\'ees de m\\^eme type d'homotopie sont-elles toujours hom\\'eomorphes?\n\nProbl\\'eme de M. W. Hurewicz.\n\n64)\tGibt es im $R^{n}$ zwei orientierbare Mannigfaltigkeiten $M_{1}^{k}$ und $M_{2}^{k}$, deren Komplement\\\"arr\\\"aume $R^{n} - M_{1}^{k}$ und $R^{n} - M_{2}^{k}$ hom\\\"oomorph und deren Homologieringe nicht isomorph sind?\n\n65)\tSoient $B_{0}, B_{1}, B_{2}, \\dots, B_{\\omega}, \\dots, B_{\\alpha}, \\dots$ des classes boreliennes d'ensembles, form\\'ees en partant d'une classe quelconque d'ensembles abstraits. On sait que $B_{\\alpha} = B_{\\alpha+}$. entra\\^ine $B_{\\alpha}= B_{\\beta}$ pour tout $\\beta>\\alpha$; soit $\\alpha_{0}$ le premier nombre $\\alpha$ satisfaisant \\`a cette condition. Quels sont les nombres $\\nu$ pour lesquels il existe des classes $B_{0}$ telles que l'on ait $\\alpha_{0} = \\nu$? (Cf. Fund. Math. t. XV, p. 284).\n\nProbl\\'emes de M. A. Ko1mogoroff.\n\n66) La propri\\'et\\'e $LC$ *faible* entra\\^ine-t-elle la propri\\'et\\'e $LC$ forte pour tout espace m\\'etrique compact? M\\^eme question pour les pro-pri\\'et\\'es $HLC$. (Pour les d\\'efinitions voir Anaals of Mathematics, vol. 85, p. 119-129 et Duke Mathematical Journal, vol. 1, p. 1-18).\n\nProbl\\'eme de M. S. Lefschetz.\n\n67)\tLa propri\\'et\\'e ($C$) des ensembles lin\\'eaires est elle invariante par rapport aux transformations hom\\'eomorphes et, plus g\\'en\\'erale-ment, par rapport aux transformations continues? (On dit qu'un ensemble $E$ poss\\'ede la *propri\\'et\\'e* ($C$), lorsqu'il existe pour chaque suite $\\{a_{n}\\}$ de nombres positifs une d\\'ecomposition $E=E_{1}+E_{2} + \\dots $ telle que le diam\\'etre de $E_{n}$ ne d'epasse pas $a_{n}$ pour $n=1, 2,\\dots$. Cf. Fund. Math, t. XI, p. 304; t. XV, p. 126; t. XXII, p. 310.)\n\nProbl\\'eme de M. W. Sierpi\\'nski.\n\n68)\tTai et $E_{1}$ \\'etant deux ensembles lin\\'eaires toujours de premi\\'ere cat\\'egorie (c. \\`a d. de premi\\'ere cat\\'egorie sur tout ensemble parfait), l'ensemble $E_{1} \\times E_{2}$. (c. \\`a\td. l'ensemble de tous les points $(x, y)$ du plan o\\'u $x \\in E_{1}$ et $y \\in E_{2}$) est-il de m\\^eme nature?\n\nProbl\\'eme de M. E. Szpilrajn.\n\n69) Lorsqu'une conrbe de Jordan (dans un espace \\`a trois dimensions) poss\\'ede en  chaque point une tangente d\\'etermin\\'ee, existe-t-il n\\'ecessairement une repr\\esentation param\\'etrique de cette courbe exprimant les coordonn\\'ees cart\\'esiennes d'un point de cette courbe comme fonctions d\\'erivables d'un param\\'etre (et cela sans que les trois d\\'erive\\'ees s'annulent en m\\^eme temps)?\n\nEn cas de r\\'epinse n\\'egative, la question est repos\\'ee en admenttant un ensemble de mesure nulle de valeues du param\\'etre o\\'u les conditions impos\\'ees ne sont pas toutes deux v\\'erifi\\'ees.\n\nProbl\\'eme de M. M. Fr\\'echet.\n\n70) Existe-t-il un ensemble lin\\'eaire $E$ tel que chaque ensemmble analytique lin\\'eaire est une image biunivoque et continue (dans un sens) de $E$?\n\nProbl\\'eme de M. W. Sierpi\\'nski.\n\n71) Existe-t-il une suite infinie $S$ de fonctions d'une variable r\\'eelle (mesurables ou non), telle que toute fonction d'une variable r\\'eelle dde classe $2$ Baire soit limite d'une suit extraite de $S$?\n\n(D'apr\\'es M. C. Burstin une telle suite $S$ ne peut \\^etre compos\\'ee uniquement de fonctions mesurables[^4])\n\nProbl\\'eme de M. W. Sierpi\\'nski.\n\n[^4] Monatshefte f. Math. u. Phys. 28 (1917), p. 107.\n\n72) Existe-t-il dans l'espace cart\\'esien \\`a $n$ dimensions ($n>1$) un ensemble toujours de premi\\'ere cat\\'egorie (c. \\`a d. de premi\\'ere cat\\'egorie sur chaque ensemble parfait) et qui soit de dimension positive?\n\n(M. W. Hurewicz a d\\'emontr\\'e \\`a l'aide de l'hypoth\\'ese du continu qu'il existe dans l'espace de Hilbert un ensemble ind\\'enombrable $H$ dont chaque sous-ensemble ind\\'enombrable est de dimension infinie[^5]). M. F. Hausdorff a remarqu\\'e l'ensemble $H$ est toujours de premi\\'ere cat\\'egorie. Cela r\\'esulte ais\\'ement du fait que chaque espace m\\'etrique s\\'eparable $M$ est somme d'un ensemble de dimension $0$ et d'un ensemble de premi\\'ere cat\\'egorie dans $M$. -- *Il existe donc, so $2^{\\aleph} = \\aleph_{1}$, dons l'espace de Hilbert un ensemble toujours de premi\\'erie cat\\'egorie et de dimension positive*).\n\nProbl\\'eme de M. E. Szpilrajn.\n\n[^5] Fund. Math. 19 (1932), p.8.\n\n\n73) Soient, dans l'espace euclidien \\`a trois dimensions, $E$ une image hom\\'eomorphe de la sph'ere solide $S$ et $L$ un segment rectiligne dont l'int'erieur est contenu dans l'int'erieur, et les extr'emeit'es dans la fronti'ere de $E$. Existe-t-il toujours une hom\\'eomorphie transformant $E$ en $S$ de facon que $L$ soit transorm\\'e en diam\\'etre de $S$?\n\nProbl\\'eme de M. K. Borsuk.\n\n74) Soit $\\mathbf{B}(\\mathbf{F})$ la plus petite famille d'ensembles contenant la famille donn\\'ee $\\mathbf{F}$ et close par rapoort aux op\\'erations $\\sigma$ et $\\delta$ (addition et multiplication d\\'enombrables). Existe-t-il une famille d\\'enombrable $\\mathbf{D}$ d'ensembles, telle que tous les ensembles analytiques lin\\'eaires appartiennent \\`a $\\mathbf{B}(\\mathbf{D})$?\n\nProbl\\'eme de M. S. Ulam.\n\n\n75) Existe-t-il un ensemble infini $E$ (p.e. l'ensemble de tous les nombres naturels) et une fonction $f(X)$ qui fait correspondre \\`a tout sous-ensemble $X$ de $E$ un sous-ensemble $f(X)$ de $E$, de sorte que:\n\n1$^\\circ$ $X \\subset f(X)$ pour $X \\subset E$,\n2$^\\circ$ $f(X+Y) = f(X) + f(Y)$ pour $X \\subset E$, $Y \\subset E$,\n3$^\\circ$ il existe pour tout ensemble $Y \\subset E$ au moins un ensemble $X \\subset E$, tel que $Y = f(X)$,\n4$^\\circ$ il existe au moins un ensemble $X_{0} \\subset E$, tel que $f(X_{0}) \\neq X_{0}$.\n\nSi l'on remplace la condition relative \\`a $f(X+Y)$ par la condition plus faible que $f(X) \\subset f(Y)$ pur $X \\subset Y \\subset E$, la r\\'eponse positive est \\'evidente. \n\nProbl\\'eme de M. E. \\v{C}ech.\n\n\n\n\n\n## Probl\\'emes r\\e'solus.\n\nProbl. 1) Lorsque un ensemble de points $P$ est une image biunvoque et continue (dans un sens) de $Q$ et $Q$ est une image biunivoque et continue de $P$, peut-on affirmer que les ensembles $P$ et $Q$ sont hom\\'eomorphes?\n\nSolution *n\\'egative* de M. Kuratowski, *Fund. Math.* t. II, pp. 158-160\n\n4) Existe-il une d\\'ecomposition d'un intervalle en $\\aleph_{1}$ ensembles mesurables ($B$), non-vides et sans points communs deux \\`a deux?\n\nSolution *affirmative* de MM. Lusin et Sierpinski, *Comptes Rendus*, t. 175, p.357 (note du 21 ao\\^ut 1922).\n\n6, troisi\\'eme partie) Peut-on d\\'emontrer qu'un produit de $\\aleph_{1}$ ensembles ($A$) n'est pas n\\'ecessairement un ensemble ($A$)?\n\nSolution *affirmative* de MM. Lusin et Sierpinski, *Journ, de Math*. 1923 (Les auteurs d\\'efinissent un ensemble qui est compl\\'ementaire d'un ensemble ($A$) n'est pas n\\'ecessairement un ensemble ($A$))\n\n8) Peut-on donner un exemple effectif d'un ensemble de nombres r\\'eels $E$, tel que toute somme, toute diff\\'erence, tout produit et tout quotient de deux nombres de $E$ (except\\'e la division par 0) appartienne \\`a $E_{1}$ et que $E$ soit non-d\\'enombrable, distinct de l'ensemble de tous les nombres r\\'eels?\n\nSolution *affirmative* de M. Souslin, *Fund. Math.* IV, p.311.\n\n10, premi\\'ere partie) Existe-il une fonction de deuxi\\'eme classe qui ne soit pas la limite de fonctions preque partout discontinues?\n\nSolution *affirmative* de M. Zalcwasser.\n\n12) Un ensemble ordonn\\'e dont tous les sous-ensembles bien ordonn\\'es (croissants on d\\'ecroissants) sont au plus d\\'enombraibles, a-t-il n\\'ecessairement une puissance non sup\\'erieure \\`a celle du continu?\n\nSolution *affirmative* de M. Urysohn, *Fund. Math.* V (h paraitre).\n\n15) Existe-il un continu dont tout sous-continu est ind\\'ecomposable?\n\nSolution *affirmative* de M. Knaster, *Fund. Math.* III pp. 247-286.\n\n16) Existe-il continu qui est une somme de ses vrais sous-continues satur\\'es disjoints?\n\nSolution *affirmative* de M. Knaster et Kuratowski, *Fund. Math.* V (\\`a paraitre).\n\n\n\n\n","source":"_drafts/75 Probelms (French).md","raw":"---\ntitle: 75 Problems in the Foundation of Mathematics\ndate: 2023-09-22 22:10:39\ntags:\n    - [Set Theory]\ncategories:\n    - [Set Theory]\nmathjax: true\n---\n\n\n1) Lorsqu'un ensemble de points $P$ est une image biunivoque et continue (mais pas n\\'ecessairement bicontinue) d'un ensemble $Q$ et lorsque $Q$ est une image biunivoque et continue de $P$, lest ensembles $P$ et $Q$ sont-ils n\\'ecessairement homeomorphes?\n\nProbl\\'eme de M. W. Sierpinski.\n\n2) Un continu (born\\'e) plan, topologiquement homog\\`ene, est-il n\\'ecessairement hom\\'eomorphe \\`a une circonf\\'erence?\n\n(Un ensemble $E$ est dit *topologiquement homog\\'ene*, lorsqu'il existe pour tout couple de points $a,b$ de $E$ une transformation biunivoque et bicontinue de $E$ en lui-m\\'eme qui transforme $a$ en $b$)\n\nProbl\\'eme de MM. B. Knaster et C. Kuratowski.\n\n3) Un ensemble ordonn\\'e (lin\\'eairement) sans sauts ni lacunes et tel que tout ensemble de ses intervalles (contenant plus qu'un \\'el\\'ement) n'empi\\'etant pas les uns sur les autres est au plus d\\'enombrable, est-il n\\'ecessairement un continu lin\\'eaire (ordinaire)?\n\nProbl\\'eme de M. M. Souslin.\n\n4) Existe-t-il une d\\'ecomposition d'un intervalle en $\\aleph_{1}$ ensembles (non vides) mesurables $B$ et sans point commun deux \\`a deux?\n\nProbl\\'eme de M. W. Sierpinski.\n\n5) Existe-t-il un ensemble lin\\'eaire ind\\'enombrable $E$ tel que tout ensemble lin\\'eaire hom\\'eomorphe \\`a $E$ soit de mesure lebesguienne nulle? Peut-on d\\'emontrer l'existence d'un tel ensemble, m\\'eme en admettant que $2^{\\aleph_{0}} = \\aleph_{1}$?\n\nProbl\\'eme de M. W. Sierpinski.\n\n6) Peut-on d\\'emoutrer sans l'hypoth\\'ese du continu ($2^{\\aleph_{0}} = \\aleph_{1}$) qu'une somme de $\\aleph_{1}$ ensembles de mesure lebesguienne nulle n'est pas n\\'ecessairement de mesure lebesquienne nulle? qu'une somme de $\\aleph_{1}$ ensembles de premi\\'ere cat\\'egorie n'est pas n\\'ecessairement de premi\\'ere cat\\'egorie? qu'un produit de $\\aleph_{1}$ ensembles ($A$) n'est pas n\\'ecessairement un ensemble $A$?\n\nProbl\\'eme de M. W. Sierpinski.\n\n7) Peut-on \\'etablir sans l'hypoth\\'ese du continu l'esistence d'un ensemble plan qui est de mesure (lebesguienne) nulle sur toute parall\\'ele \\`a l'axe d'abscisses et dont le compl\\'ementaire est de mesure nulle sur toute parall\\'ele \\`a l'axe d'ordonn\\'ees?\n\nProbl\\'eme de M. H. Steinhaus.\n\n8) Peut-on donner un exemple effectif d'un ensemble de nombres r\\'eels $E$ tel que toute somme, toute diff\\'erence, tout produit et tout quotient de deux nombres de $E$ (la division par 0 except\\'ee) appartienne \\`a $E$ et que $E$ soit ind\\'enombrable, mais distinct de l'ensemble de tous les nombres r\\'eels?\n\nProbl\\'eme de M. S. Mazurkiewicz.\n\n9) Quelle est la puissance des ensembles compl\\'ementaires aux ensembles ($A$)?\n\nProbl\\'eme de M. N. Lusin.\n\n\n*Remarque*. Les ensembles ($A$) lin\\'eaires sont des projections orthogonales (sur une froite) des ensembles plans mesurables $B$. M. Lusin a d\\'emontr\\'e que la puissance d'un ensemble ind\\'enombrable compl\\'ementaire \\`a un ensemble ($A$) est $\\aleph_{1}$ ou $2^{\\aleph_{0}}$, mais on ne sait pas si elle peut \\^etre en r\\'ealit\\'e $\\aleph_{1}$ (dans le cas o\\'u $2^{\\aleph_{0}} > \\aleph_{1}$)\n\n10) Existe-t-il une fonction de deuxi\\'eme classe qui n'est pas une limite de fonctions presque partout continues? Peut-on donner un exemple effectif d'une fonction qui n'est pas une limite de fonctions ponctuellement discontinues?\n\nProbl\\'eme de MM. T. Feosztyn et W. Sierpinski.\n\n11) Existe il une classe ($\\mathcal{L}$) de M. Fr\\'echet (c'est-\\`a dire une classe dans laquelle la limite est d\\'efinie) de puissance sup\\'erieure \\`a celle du continu, telle que tout ensemble non d\\'enombrable d'\\'el\\'ements de cette classe contient au moins un \\'el\\'ement de condensation?\n\nProbl\\'eme de M. W. Sierpinski.\n\n12) Un ensemble ordonn\\'e (lin\\'eairement) dont tous les sousensembles bien ordonn\\'es (croissants et d\\'croissants) sont au plus d\\'enombrables, a-t-il n\\'ecessairement une puissance non sup\\'erieure \\`a celle du continu?\n\nProbl\\'eme de M. W. Sierpinski.\n\n13) Existe-il un ensemble plan ferm\\'e qui ne soit pas somme de deux ensembles ferm\\'es sans points communs, mais qui est une somme d'une infinit\\'e d\\'enombrable d'ensembles ferm\\'es sans points communs deux \\`a deux.\n\nProbl\\'eme de M. W. Sierpinski.\n\n14) Un continu dans l'espace \\`a $m$ dimensions qui est hom\\'eomorphe de tout continu qu'il contient, est il n\\'ecessairement un arc simple (c'est-\\`a-dire une image biunivoque et continu de l'intervalle 0-1)?\n\nProbl\\'eme de M. Mazurkiewicz.\n\n15) Existe-il un continu dont tout sous continu est ind\\'ecomposable? (Un continu est dit ind\\'ecomposable lorsqu'il n'est pas une somme de deux continus diff\\'erents de lui.)\n\nProbl\\'eme de MM. Knaster et Kuratowski.\n\n16) Existe il un continu (non born\\'e) qui est une somme de ses vrais sous continus satur\\'es n'ayant deux \\`a deux aucun point commun?\n\n(On dit qu'un vrai sous-continu $K$ de $C$ est *satur\\'e*, lorsqu'il n'existe aucun continu diff\\'erent de $K$ et de $C$ qui contienne $K$ et qui soit contenu dans $C$.)\n\nProbl\\'eme de M. Kuratowski.\n\n17) Quelle est la puissance de l'ensemble de toutes les valeurs que ne prend pas une fonction de classe 1 de M. Baire?\n\n(Ce probl\\'eme est \\'equivalent au probl\\'eme 9 de M. Lusin, t. I. p.224. Il suffirait de r\\'esoudre ce probl\\'eme pour les fonctions admettant une infinit\\'e d'enombrable de points de discontinuit\\'e.)\n\n18) Un ensemble (lin\\'eaire) de puissance inf\\'erieure \\`a celle du continu, est-il n\\'ecessairement d\\'e la premi\\'ere cath\\'egorie de M. Baire?\n\nProbl\\'eme de M. Ruziewicz.\n\n19) Existe-t-il dans chaque ensemble biconnexe $B$ un point $p$ tel que l'ensemble $B - (p)$ ne contient aucun ensemble connexe?\n\n*Remarque*. D'apre\\'es un th\\'eor\\'eme de M. Kline (ce volume, p.238), il ne peut exister dans un ensemble connexe $B$ plus d'un point $p$ jouissant de la propri\\'et\\'e en question. On sait, d'autre part, que, si un tel point existe, l'ensemble $B$ est biconnexe, c.-\\`a-d. il n'est pas somme de duex ensembles connexes disjoints cont\\'enant plus d'un point (cf. Knaster et Kuratowski, *Fund. Math.* II, p,214.)\n\nProbl\\'eme de M. Kuratowski.\n\n20) Soit $f(E)$ une fonction d\\'efinie por tout ensemble $E$ mesurable ($L$) d'un espace euclidien \\`a $m \\geq 3$ dimensions et satisfaisant aux conditions suivantes:\n\n1. $f(E)\\geq 0$.\n2. $f(E_{0}) = 1$ pur un certain ensemble $E_{0}$ de mesure 1.\n3. $f(E_{1} +E_{2}) = f(E_{1}) + f(E_{2})$, si $E_{1} E_{2} = 0$.\n4. $f(E_{1}) = f(E_{2})$, si $E_{1}$ et $E_{2}$ sont superposables.\n\nLa fonction $f(E)$ coincide-t-elle n\\'ecessairement avec la mesure lebesguienne de l'ensemble $E$?\n\n(Pour $m=1$ et $m=2$ la r\\'eponse est n\\'egative, comme l'a prouv\\'e M. Banach dans un m\\'emoire qui sera publi\\'e dans le tome IV de ce jounal.)\n\nProbl\\'eme de M. Ruziewicz.\n\n21) A \\'etant un ensemble de nombres r\\'eels qui n'est de I cat\\'egorie dans aucun intervalle, existe-il une d\\'ecomposition: $A = B + C$, $B \\times C = 0$ telle que ni $B$ ni $C$ ne soient de I cat\\'egorie dans aucun intervalle?\n\n*Remarque*. On en pourrait donner la solution affirmative dans l'hypoth\\'ese suppl\\'ementaire que $A$ poss\\'ede la propri\\'et\\'e de Baire (au sens etabli dans ce volume), p.319. M. Sierpinski en a signal\\'e d'autre part, la solution affirmative dans l'hypoth\\'ese du continu, $\\aleph_{1} = 2^{\\aleph_{0}}$.\n\nProblem of M. Kuratowski.\n\n22) Appellons l'ensemle (lin\\'eaire) $E$ *parfaitement mesurable*, si tout ensemble hom\\'eomorphe \\`a $E$ est mesurable au sens de Lebesgue. Quelle est la puissance de la classe des ensembles parfaitement mesurables? Un ensemble compl'ementaire \\`a un ensemble parf. mesurable est-il toujours parf. mesurable?\n\nProblem of M. Urysohn.\n\n23) Esiste-t-il une fonction d'une variable r\\'eelle $f(x)$ pantachiquement dicontinue et telle qu'on ait pour tout $x$ r\\'eel\n\n$$\\lim \\frac{f(x+h) - f(x-h)}{2h} = 0?$$\n\nProblem of M. Steinhaus.\n\n24) Une fonction satisfaisan \\`a la condition de Baire, est-elle n\\'ecessairement mesurable ($L$)? Quelle est la puissance de toutes les fonctions d'une variable r'eelle satisfaisant \\`a la condition de Baire? (On dit qu'une fonction $f(x)$ satisfait \\`a la condition de Baire, si elle continue sur tout ensemble parfait quand on n\\'eglige les ensembles de premi\\'ere cat\\'egorie par rapport \\`a cet ensemble parfait.)\n\nProblem of M. Sierpinski.\n\n25) Un ensemble plan, tel que toute droite le rencontre en deux (et seulement deux) points, peut-il \\^etre mesurable ($B$)? (L'existence d'un tel ensemble a \\'et\\'e d\\'emontr\\'e, \\`a l'aide du th\\'eor\\'eme de M. Zermelo, par MM. Mazurkiewicz[^1] (en 1914) et Rosenthal[^2] (en 1922))\n\n\n[^1] Comptes Rendus de lu Soc. des Sciences de Varsovic, t. VII, p.382.\n\n[^2] Sitzungaber d. Bayer. Akad. d. Wiss., math-phys. K1, 1922, p. 223.\n\n26) Une fonction de classe 3 de M. Baire, est-elle toujours une superposition de trois fonctions de classe 1, c'est-\\`a-dire existe-t-il pour toute fonction $f(x)$ de classe 3 trois fonctions $\\varphi(x)$, $\\psi(x)$ et $\\vartheta(x)$ de classe, telles qu'on a pour tout $x$ r\\'eel\n\n$$f(x) = \\varphi\\{\\psi[\\vartheta(x)]\\}$$\n\nProbl\\'eme de M. Lusin.\n\n27) L'ensemble $D(E)$ des distances des points d'un ensemble lin\\'eaire $E$ mesurable $(B)$, est-il toujours mesurable ($B$)? ( $D(E)$ est done l'ensemble de tous les nombres $|x-y|$, o\\'u $x$ et $y$ appartiennent \\`a $E$. On peut d\\'emontrer l'existence des ensembles $E$ mesurables ($L$), tels que $D(E)$ est non mesurable ($L$).) \n\nProbl\\'eme de M. Sierpinski.\n\n28) $E$ \\'etant un ensemble plan mesurable ($B$), d\\'esignons par $N(E)$ l'ensemble de tous les nombres r\\'eels $a$, tels que la droite $x = a$ rencontre $E$ en une infinit\\'e non-d\\'enombrable de points. L'ensemble $N(E)$, est il n\\'ecessairement un ensemble ($A$), ou, plus simplement, est-il mesurable ($L$)? (On peut d\\'emontrer que l'ensemble de tous les nombres r\\'eels $a$, tels que la droite $x = a$ rencontre l'ensemble $E$ (mesurable $B$) en une infinit\\'e de points est toujouts un ensemble $A$.)\n\nProbl\\'eme de M. Sierpinski.\n\n29) Soit $F$ un ensemble plan, p. ex. ferm\\'e (ou, plus g\\'en\\'eralement, mesurable)- Un point $x$ de $F$ sera dit *lin\\'eairment accessible* s'il sxiste un segment rectiligne $\\overline{xp}$ tel que tous ses points (le point $x$ except\\'e) soient \\'etrangers \\`a $F$. Peut-on d\\'emontrer que l'ensemble $A$ de tous les points lin\\'eairement accessibles de $F$ est toujours mesurable ($L$)?\n\nProbl\\'eme de M. Urysohn.\n\n30) $f(x)$ \\'etant une fonction donn\\'ee quelconque (mesurable ou non), quelle est la mesure de l'ensomble de tous les points $x$, tels que\n\n$$\\lim\\limits_{h\\to 0} \\left|\\frac{f(x+h) - f(x)}{h}\\right| = \\infty$$\n\nProbl\\'eme de M. Ruziewicz.\n\n31) Le th\\'eor\\'eme: \"$\\mathsf{m} = 2\\cdot \\mathsf{m}$ quel soit le nombre cardinal *transfini* $\\mathsf{m}$\" est il \\'equivalent \\`a *l'axiome du choix*?\n\nCf. ma Note \"*Sur quelques th\\'eor\\'emes qui \\'equivalent \\`a l'axiome du choix*\" dans ce volume, p. 147.\n\nProbl\\'eme de M. Tajtelbaum-Tarski.\n\n32) Un ensemble plan ferm\\'e, don tout point est lin\\'eairement accessible, est-il n\\'ecessairement de mesure superficielle nulle?\n\nProbl\\'eme de M. Banach.\n\nUn point $x$ de $F$ est dit lin\\'eairement accessible s'il existe un segment rectiligne $\\overline{xp}$ tel que tous ses points (le point $x$ excepr\\'e) soient \\'etrangers \\`a $F$. M. Urysohn a d\\'emontr\\'e que l'ensemble de tous les points lin\\'eairement accessibles d'un ensemble plan ferm\\'e est toujouts un ensemble ($A$) de M. Souslin, mais peut ne pas \\^etre mesurable ($B$). Or on ne sait pas si l'ensemble de tous les points lin\\'eairement accessibles d'un ensemble plan $G_{\\delta}$ est mesurable ($L$) (Cf. Probl\\'eme 29, *Fund. Math.* t. V, p. 337).\n\n33) Une image biunivoque et continue (dans un sens) d'un ensemble compl\\'emeutaire \\`a un ensemble ($A$) de M. Souslin, est elle de m\\^eme nature?\n\nProbl\\'eme de Sierpi\\'nski.\n\n34) Appelons un ensemble (lin\\`eaire) mesurable ($B$) de classe $\\alpha$ *irr\\'eductible* s'il n'est de classe $<\\alpha$ dans aucun intervalle. Quelle est la puissance de l'ensemble de tous les types topologiques d'ensumbles irr\\'eductibles de classe $\\alpha$?\n\nAppelons un ensemble ($A$) irr\\'eductible, s'il n'est mesurable ($B$) dans aucun intervalle. Quelle est la puissance de tous les types topologiques des ensembles ($A$) irr\\'eductibles?\n\nProbl\\'eme de MM. Alexandroff et Urysohn.\n\n35) Appelons l'ensemble (lin\\'eaire) $E$ *parfaitement mesurable au sens \\'etroit*, si toute image univoque et continue de $E$ est mesurable au sens de Lebsgue. Un ensemble compl\\'ementaire \\`a un ensemble parfaitement mesurable au sens \\'etroit, est-il toujours de m\\^eme nature?\n\nCf. Probl\\'eme 22 de P. Urysohn (*Fund. Math.* t. IV, p. 368), r\\'esolu par M. Lavrentieff (*Fund. Math.* t. VI, p. 159).\n\nProbl\\'eme de M. O. Nikodym.\n\n36) D'apr\\'es M. Souslin, si $E$ est un ensemble ($A$) et $H$ un ensemble compl\\'ementaire \\`a un ensemble ($A$), et si $E \\subset H$, il existe un ensemble $Q$, mesurable ($B$), tel que $E\\subset Q \\subset H$[^3]. Cette proposition, admet-elle une r\\'eciproque, c'est-\\`a-dire, *$E$ \\'etant un ensemble compl\\'ementaire \\`a un ensemble ($A$) et $H$ ------ un ensemble ($A$), tel que $E \\subset H$, existe-til tujours un ensemble $Q$ mesurable ($B$), tel que $E \\subset Q \\subset H$?*\n\nProbl\\'eme de M. Sierpi\\'nski.\n\n[^3] Voir p. e. N. Lusin et W. Sierpi\\'nski *Journ. de Math.* t. II (1923) p. 60; aussi *Bull. Acad. Cracovie* 1918 p. 40.\n\n37) Un continu de Jordan (born\\'e) qui ne renferme qucune courbe simple ferm\\'ee est-il hom\\'eomorphe \\`a un de ses (vrais) sous-continus?\n\nProbl\\'eme de M. Zarankiewicz.\n\n38) Un carr\\'e et un cercle dont les aires sont \\'egales peuvent-ils \\^etre d\\'ecompos\\'es en un nombre fini de sous-ensembles disjoints repectivement congruents?\n\nProbl\\'eme de M. Tarski.\n\n39) Existe-il un ensemble ferm\\'e *plan* pour lequel l'ensemble des points lin\\'eairement accessibles soit non-mesurable ($B$)? (Dans l'espace le probl\\'eme est r\\'esolu par affirmative).\n\nProbl\\'eme de M. O. Nikodym.\n\n40) $E$ \\'etant un ensemble plan $G_{\\delta}$, l'ensemble de tous les nombres r\\'eels $a$, tels que la droite $x =a$ rencontre l'ensemble $E$ dans un et un seul point, est-il n\\'ecessairement compl\\'ementaire d'un ensemble ($A$) de M. Souslin?\n\nProbl\\'eme de M. Sierpi\\'nski.\n\n41) $E_{1}, E_{2}, E_{3}, \\dots$ \\'etant une suite d\\'enombrable d'ensembles lin\\'eaires dont chacun est une projection d'un ensemble plan compl\\'ementaire \\`a un ensemble ($A$) de M. Souslin, l'ensemble $E_{1}E_{2} E_{3} \\dots $ est il de m\\^eme nature?\n\nProbl\\'eme de M. Sierpi\\'nski.\n\n42) Existe-t-il dans tout continu $A$ un continu $B$ tel que l'ensemble $A-B$ soit connexe?\n\nProbl\\'eme de MM. Knaster et Zarankiewicz.\n\n\n43) $D$ d\\'esignant un ensemble ferm\\'e hom\\'eomorphe d'un ensemble plan et situ\\'e dans l'espace euclidien \\`a 3 dimensions, est-ce que tout point de $D$ est *accessible* dans cet espace?\n\n(Un point $d$ de $D$ est dit *accessible* dans $E$, lorsqu'il existe un continu $C \\subset E$ tel que $(d) = CD$).\n\nProbl\\'eme de M. Knaster.\n\n\n46) Es wird gefragt die logischen Relationen zwischen den verschiedenen Homogenit\\\"atsbegriffen aufzutellen, insoweit sie sich beziehen auf im kleinen kompakten Mengen. Insbesondere auch wenn die Mengen als ausammenh\\\"angend und (oder) im kleinen zusammenh\\\"angend vorausgesetzt werden.\n\n(Vgl. D. van Dantzig, \\\"ber topologisch homogene Kontinua, dieser Band, S. 102, 103).\n\nProbl\\'eme de M. van Dantzig.\n\n47) Ist eine jed (zusammenh\\\"angende, unberandete) $n$-dimensionale Mannigfaltigkeit involutorisch homogen?\n\n(Vgl. D. van Dantzig, l. e. S. 104, ^7.)\n\nProbl\\'eme de M. van Dantzig.\n\n48) Nennen wir eine topologische Gruppe *monothetisch*, falls eine unendliche zyklische Gruppe in ihr dicht liegt (in welchem Falle sie kommutativ ist und additiv geschrieben weden kann), und *komplett*, falls eine jede Folge $x_{\\nu}$, die dem Konvergenzkriterium Cauchy's $\\lim (x_{\\nu} - x_{\\mu} = 0$ gen\\\"ugt, ein Limeselement in der Gruppe besitzt, so wird gefragt, ob eine monothetische Gruppe komplett sein kann ohne kompakt zu sein.\n\n(Vgl. l. c. S. 116 ^{29}a)) \n\nProbl\\'eme de M. van Dantzig.\n\n49) Soient $X$ et $Y$ deux continus P\\'eaniens (= images continues de l'intervalle) et $Z$ leur produit topologique (= l'espace de tous les couples $z = (x,y)$ o\\'u $\\lim z_{n}=z$ lorsque $\\lim x_{n} = x$ et $\\lim y_{n} = y$).\n\n1^0. Si le continu $X$, ainsi que $Y$, poss\\'ede la propri\\'et\\'e que dans chaque transformation continue de ce continu en un sous-ensemble il existe un point invariant, est-il vrai que $Z$ poss\\'ede la m\\^eme propri\\'et\\'e?\n\n2^0. Si le continu $X$, ainsi que $Y$, est uni-coh\\'erent (= dans chaque d\\'ecomposition de ce continu en deus sous-continus la partie commune de ces sous-continus est connexe), est-il vrai que $Z$ est unicoh\\'erent?\n\nProbl\\'eme de M. Kuratowski.\n\n50) Ist der topologische Kreis die einzige homogene im kleinen zusammenh\\\"angende Kurve? (Kurve = eindimensionaler zusammen-h\\\"angender kompakter Raum. Homogen hei$\\beta$t ein Raum, der zu je zwei seiner Punkte $p$ und $q$ eine topologische Selbstabbildung besitzt die $p$ in $q$ \\\"uberf\\\"uhrt). In der Ebene ist der Kreis die einzige homogene im kleinen zusammenh\\\"angende Kurve.\n\n(Vgl. Mazurkiewicz, Fund. Math. V, S. 137).\n\nProbl\\'eme de M. K. Menger.\n\n51) Gibt es beliebig oder gar unendlich viele kompakte eindimensionale R\\\"aume, die zu je zweien eindimentional unvergleichbar sind? Dabei m\\\"ogen zwei R\\\"aume $R$ und $R^{\\prime}$ eindimentional unvergleichbar hei$\\beta$en, wenn keine eindimensionale Teilmenge von $R$, (bzw. von $R^{\\prime}$) hom\\\"oomorph ist mit einer Teilmenge von $R^{\\prime}$ (bzw. von $R^{\\prime}$). Beispielsweise sind eindimensional unvergleichbar eine Strecke und ein Kontinuum ohne Teilbogen. (Wenn es $n$, bzw. $\\aleph_{0}$ paarweise eindimensional unvergleichbare Kurven gibt, so existieren kompakte eindimensionale R\\\"aume, welche mindestens $2^{n} +1$, bze. $2^{\\aleph_{0}}$ monotone, $F_{\\sigma}$-additive, toppologische, kompaktifizierbare Systeme von Teilmengen enthalten).\n\n\n(Vgl. Monatshefte f. Math. u. Phys. 36, S. 207).\n\nProbl\\'eme de M. K. Menger.\n\n52) Existe-il un continu dont tout autre continu soit une image continue?\n\nProbl\\'eme de M. H. Hahn.\n\n\n53)\ta) Ist jeder absolute Retrakt in endlich viele absolute Retrakte mit beliebig kleinen Durchmessern zerlegbar?\n\nb) Lasst sieh jede $R$-Menge in endlich viele absolu#e Retrakte zerlegen?\n\n(Die Definition von absoluten Retrakten und von $R$-Mengen ist z. B. in meiner Note aus Fund. Math. XIX, S. 222 angegeben).\n\n54)\tIst jedes Teilkontinuum $C$ des eaklidieelien $n$-dimensionalen Raumes $R_{n}$, welches $R_{n}$ zerschneidet und welches eich durch beliebig kleine Transformationen (d. h. durch eine stetige Abbildung, welehe jeden Punkt von $C$ in einen beliebig nahe liegenden Punkt von $R_{n}$ tiberfiibrt) in eine mit ihm punktfremde Teilmenge von R. \\\"uberf\\\"uhren lasst, eine ($n-1$)-dimensionale Mannigfaltigkeit?\n\n55)\tL\\\"asst sich jedes in $R_{3}$ liegende und $R_{3}$ zerschneidende Streckenbild in eich stetig und fixpunktfrei abbilden?\n\nProbl\\'emes de M. K. Borsuk.\n\n56) Soient $A$ et $B$ deux espaces topologiques et $A^{2}$ et $B^{2}$ respectivement leur carr\\'es (a. \\`a. d. $A^{2}$ p. ex. se compose de tous tes couples ($a_{1}$, $a_{2}$) extraite de $A$).\n\nEst-il vrai que si $A^{2}$ et $B^{2}$ sont hom'eomorphes. $A$ et $B$ le sont aussi?\n\nEn ess de relronae positire, on en d\\'eduit que, $C$ \\'etant un ensemble qui n'est\nhom\\'eomorphe \\`a aucun, $C^{n}$, $n>1$, les ensembles $C^{m}$ et $C^{n}$ ne sont non plus hom\\'eomorphes pour $m\\neq n$; cela fournit dans le eas o\\`u $C$ est un intervalle 1e th\\'eor\\'eme de \"l'invariance de la dimension\" de M. Brouwer.\n\nProbl\\'eme de M. S. Ulam.\n\n57) Existe-il un continu de dimension infinie qui n'en contient aucun de dimension finie?\n\nProbl'eme de M. S. Mazurkiewicz.\n \n58)\tGibt es in einer Menge $E$ von der M\\\"achtigkeit $\\aleph_{1}$ ein abz\\\"ahlbares System von Teilmengen $A_{1}, A_{2},\\dots$ derart, dass man in der Gestalt\n$$X = \\overline{\\lim} A_{p_{n}}$$\n($p_{1}, p_{2},,\\dots$ Teilfolge der nat\\\"urlichen Zahlen, $\\overline{\\lim}$ bedeutet dag Barel-sche *ensemble limite complet*) alle Teilmengen $X$ von $E$ erh\\\"alt?\n\n(Es handelt sich, die Verneinung ohne Benutzung der Kontinuumhypethese zu beweisen).\n\nProbl\\'me de M. F. Hausdorff.\n\n59)\tUne fonction jouissant de la propri\\'et\\'e de Baire (c'est-\\`a-dire continue sur tout ensemble parfait, lorsqu'on n\\'eglige un ensemble de\t$1^{re}$ cat\\'egorie relativement \\`a cet ensemble) d'une fonction jouiseant de la propri\\'et\\'e de Baire, est-elle de la m\\^eme nature?\n\nProbl\\'eme de M. W. Sierpi\\'nski.\n\n60)\tSoit $\\rho$ l'ensemble de toutes les transformations hom\\'eomorphes du plan cart\\'esien en lui-m\\^eme, de la forme:\n$$x^{\\prime} = x, \\quad y^{\\prime} =f(x,y)$$\net\n$$x^{\\prime}=g(x,y), \\quad\ty^{\\prime}=y.$$\n\nD\\'esignons par $\\sigma$ le groupe form\\'e par toutes les superpositions finies de toutes les transformations appartenant \\`a $\\rho$. Une transformation hom\\'eomorphe arbitraire du plan en lui-m\\^eme se laisse-telle toujours approcher par celles du groupe $\\sigma$?\n\nUn probl\\'eme analogue subsiste pour les espaces \\`a $n>2$ dimensions.\nProbl\\'eme de M. S. Ulam.\n\n61)\tSoit $E$ un ensemble plan $G_{\\delta}$ (plus g\\'en\\'eralement: un ensemble borelien) dont tontes les intersections avec les droites parall\\'eles \\`a l'axe des $y$ sont des ensembles ferm\\'es (plus g\\'en\\'eralement: des $F_{\\sigma}$). La projection de $E$ sur l'axe des $x$ est-elle toujours un ensemble\nborelien?\t\n\nProbl\\'eme de M. E. Szpilrajsn.\n\n62)\tDie (reelle) Funktion $f(x)$ der reellen Variablen $x$ heisse *symmetrisch-stetig* wenn f\\\"ur jedes $x$\n$$\\lim\\limits_{h \\to 0} [f(x+h) - f(x - h)] = O.$$\nKann die Menge der Unstetigkeitsstellen einer solchen Funktion unabz\\\"ahlbar sein? Kann sie eine beliebig vorgeschriebene Menge $F_{\\sigma}$ sei? (Dass sie eine beliebig vorgeschriebene abz\\\"ahlbare Menge sein\nkann, ist leicht einzusehen.)\n\nProbl\\'eme de M. F. Hausdorff.\n\n63)\tDeux espaces compacts $A$ et $B$ ont le *m\\^eme type d'homotopie*, lorsqu'il existe une transformation continue $f$ de $A$ en $B$ et une transformation continue $f$ de $A$ en $B$ et une transformation continue $\\varphi$ de $B$ en $A$, telles que les transformations superpos\\'ees $\\varphi f$ et $f\\varphi$ (consid\\'er\\'ees respectivement comme des trans-formations de $A$ en $A$ et de $B$ en $B$) soient homotopes \\`a l'identit\\'e. Deux vari\\'et\\'es ferm\\'ees de m\\^eme type d'homotopie sont-elles toujours hom\\'eomorphes?\n\nProbl\\'eme de M. W. Hurewicz.\n\n64)\tGibt es im $R^{n}$ zwei orientierbare Mannigfaltigkeiten $M_{1}^{k}$ und $M_{2}^{k}$, deren Komplement\\\"arr\\\"aume $R^{n} - M_{1}^{k}$ und $R^{n} - M_{2}^{k}$ hom\\\"oomorph und deren Homologieringe nicht isomorph sind?\n\n65)\tSoient $B_{0}, B_{1}, B_{2}, \\dots, B_{\\omega}, \\dots, B_{\\alpha}, \\dots$ des classes boreliennes d'ensembles, form\\'ees en partant d'une classe quelconque d'ensembles abstraits. On sait que $B_{\\alpha} = B_{\\alpha+}$. entra\\^ine $B_{\\alpha}= B_{\\beta}$ pour tout $\\beta>\\alpha$; soit $\\alpha_{0}$ le premier nombre $\\alpha$ satisfaisant \\`a cette condition. Quels sont les nombres $\\nu$ pour lesquels il existe des classes $B_{0}$ telles que l'on ait $\\alpha_{0} = \\nu$? (Cf. Fund. Math. t. XV, p. 284).\n\nProbl\\'emes de M. A. Ko1mogoroff.\n\n66) La propri\\'et\\'e $LC$ *faible* entra\\^ine-t-elle la propri\\'et\\'e $LC$ forte pour tout espace m\\'etrique compact? M\\^eme question pour les pro-pri\\'et\\'es $HLC$. (Pour les d\\'efinitions voir Anaals of Mathematics, vol. 85, p. 119-129 et Duke Mathematical Journal, vol. 1, p. 1-18).\n\nProbl\\'eme de M. S. Lefschetz.\n\n67)\tLa propri\\'et\\'e ($C$) des ensembles lin\\'eaires est elle invariante par rapport aux transformations hom\\'eomorphes et, plus g\\'en\\'erale-ment, par rapport aux transformations continues? (On dit qu'un ensemble $E$ poss\\'ede la *propri\\'et\\'e* ($C$), lorsqu'il existe pour chaque suite $\\{a_{n}\\}$ de nombres positifs une d\\'ecomposition $E=E_{1}+E_{2} + \\dots $ telle que le diam\\'etre de $E_{n}$ ne d'epasse pas $a_{n}$ pour $n=1, 2,\\dots$. Cf. Fund. Math, t. XI, p. 304; t. XV, p. 126; t. XXII, p. 310.)\n\nProbl\\'eme de M. W. Sierpi\\'nski.\n\n68)\tTai et $E_{1}$ \\'etant deux ensembles lin\\'eaires toujours de premi\\'ere cat\\'egorie (c. \\`a d. de premi\\'ere cat\\'egorie sur tout ensemble parfait), l'ensemble $E_{1} \\times E_{2}$. (c. \\`a\td. l'ensemble de tous les points $(x, y)$ du plan o\\'u $x \\in E_{1}$ et $y \\in E_{2}$) est-il de m\\^eme nature?\n\nProbl\\'eme de M. E. Szpilrajn.\n\n69) Lorsqu'une conrbe de Jordan (dans un espace \\`a trois dimensions) poss\\'ede en  chaque point une tangente d\\'etermin\\'ee, existe-t-il n\\'ecessairement une repr\\esentation param\\'etrique de cette courbe exprimant les coordonn\\'ees cart\\'esiennes d'un point de cette courbe comme fonctions d\\'erivables d'un param\\'etre (et cela sans que les trois d\\'erive\\'ees s'annulent en m\\^eme temps)?\n\nEn cas de r\\'epinse n\\'egative, la question est repos\\'ee en admenttant un ensemble de mesure nulle de valeues du param\\'etre o\\'u les conditions impos\\'ees ne sont pas toutes deux v\\'erifi\\'ees.\n\nProbl\\'eme de M. M. Fr\\'echet.\n\n70) Existe-t-il un ensemble lin\\'eaire $E$ tel que chaque ensemmble analytique lin\\'eaire est une image biunivoque et continue (dans un sens) de $E$?\n\nProbl\\'eme de M. W. Sierpi\\'nski.\n\n71) Existe-t-il une suite infinie $S$ de fonctions d'une variable r\\'eelle (mesurables ou non), telle que toute fonction d'une variable r\\'eelle dde classe $2$ Baire soit limite d'une suit extraite de $S$?\n\n(D'apr\\'es M. C. Burstin une telle suite $S$ ne peut \\^etre compos\\'ee uniquement de fonctions mesurables[^4])\n\nProbl\\'eme de M. W. Sierpi\\'nski.\n\n[^4] Monatshefte f. Math. u. Phys. 28 (1917), p. 107.\n\n72) Existe-t-il dans l'espace cart\\'esien \\`a $n$ dimensions ($n>1$) un ensemble toujours de premi\\'ere cat\\'egorie (c. \\`a d. de premi\\'ere cat\\'egorie sur chaque ensemble parfait) et qui soit de dimension positive?\n\n(M. W. Hurewicz a d\\'emontr\\'e \\`a l'aide de l'hypoth\\'ese du continu qu'il existe dans l'espace de Hilbert un ensemble ind\\'enombrable $H$ dont chaque sous-ensemble ind\\'enombrable est de dimension infinie[^5]). M. F. Hausdorff a remarqu\\'e l'ensemble $H$ est toujours de premi\\'ere cat\\'egorie. Cela r\\'esulte ais\\'ement du fait que chaque espace m\\'etrique s\\'eparable $M$ est somme d'un ensemble de dimension $0$ et d'un ensemble de premi\\'ere cat\\'egorie dans $M$. -- *Il existe donc, so $2^{\\aleph} = \\aleph_{1}$, dons l'espace de Hilbert un ensemble toujours de premi\\'erie cat\\'egorie et de dimension positive*).\n\nProbl\\'eme de M. E. Szpilrajn.\n\n[^5] Fund. Math. 19 (1932), p.8.\n\n\n73) Soient, dans l'espace euclidien \\`a trois dimensions, $E$ une image hom\\'eomorphe de la sph'ere solide $S$ et $L$ un segment rectiligne dont l'int'erieur est contenu dans l'int'erieur, et les extr'emeit'es dans la fronti'ere de $E$. Existe-t-il toujours une hom\\'eomorphie transformant $E$ en $S$ de facon que $L$ soit transorm\\'e en diam\\'etre de $S$?\n\nProbl\\'eme de M. K. Borsuk.\n\n74) Soit $\\mathbf{B}(\\mathbf{F})$ la plus petite famille d'ensembles contenant la famille donn\\'ee $\\mathbf{F}$ et close par rapoort aux op\\'erations $\\sigma$ et $\\delta$ (addition et multiplication d\\'enombrables). Existe-t-il une famille d\\'enombrable $\\mathbf{D}$ d'ensembles, telle que tous les ensembles analytiques lin\\'eaires appartiennent \\`a $\\mathbf{B}(\\mathbf{D})$?\n\nProbl\\'eme de M. S. Ulam.\n\n\n75) Existe-t-il un ensemble infini $E$ (p.e. l'ensemble de tous les nombres naturels) et une fonction $f(X)$ qui fait correspondre \\`a tout sous-ensemble $X$ de $E$ un sous-ensemble $f(X)$ de $E$, de sorte que:\n\n1$^\\circ$ $X \\subset f(X)$ pour $X \\subset E$,\n2$^\\circ$ $f(X+Y) = f(X) + f(Y)$ pour $X \\subset E$, $Y \\subset E$,\n3$^\\circ$ il existe pour tout ensemble $Y \\subset E$ au moins un ensemble $X \\subset E$, tel que $Y = f(X)$,\n4$^\\circ$ il existe au moins un ensemble $X_{0} \\subset E$, tel que $f(X_{0}) \\neq X_{0}$.\n\nSi l'on remplace la condition relative \\`a $f(X+Y)$ par la condition plus faible que $f(X) \\subset f(Y)$ pur $X \\subset Y \\subset E$, la r\\'eponse positive est \\'evidente. \n\nProbl\\'eme de M. E. \\v{C}ech.\n\n\n\n\n\n## Probl\\'emes r\\e'solus.\n\nProbl. 1) Lorsque un ensemble de points $P$ est une image biunvoque et continue (dans un sens) de $Q$ et $Q$ est une image biunivoque et continue de $P$, peut-on affirmer que les ensembles $P$ et $Q$ sont hom\\'eomorphes?\n\nSolution *n\\'egative* de M. Kuratowski, *Fund. Math.* t. II, pp. 158-160\n\n4) Existe-il une d\\'ecomposition d'un intervalle en $\\aleph_{1}$ ensembles mesurables ($B$), non-vides et sans points communs deux \\`a deux?\n\nSolution *affirmative* de MM. Lusin et Sierpinski, *Comptes Rendus*, t. 175, p.357 (note du 21 ao\\^ut 1922).\n\n6, troisi\\'eme partie) Peut-on d\\'emontrer qu'un produit de $\\aleph_{1}$ ensembles ($A$) n'est pas n\\'ecessairement un ensemble ($A$)?\n\nSolution *affirmative* de MM. Lusin et Sierpinski, *Journ, de Math*. 1923 (Les auteurs d\\'efinissent un ensemble qui est compl\\'ementaire d'un ensemble ($A$) n'est pas n\\'ecessairement un ensemble ($A$))\n\n8) Peut-on donner un exemple effectif d'un ensemble de nombres r\\'eels $E$, tel que toute somme, toute diff\\'erence, tout produit et tout quotient de deux nombres de $E$ (except\\'e la division par 0) appartienne \\`a $E_{1}$ et que $E$ soit non-d\\'enombrable, distinct de l'ensemble de tous les nombres r\\'eels?\n\nSolution *affirmative* de M. Souslin, *Fund. Math.* IV, p.311.\n\n10, premi\\'ere partie) Existe-il une fonction de deuxi\\'eme classe qui ne soit pas la limite de fonctions preque partout discontinues?\n\nSolution *affirmative* de M. Zalcwasser.\n\n12) Un ensemble ordonn\\'e dont tous les sous-ensembles bien ordonn\\'es (croissants on d\\'ecroissants) sont au plus d\\'enombraibles, a-t-il n\\'ecessairement une puissance non sup\\'erieure \\`a celle du continu?\n\nSolution *affirmative* de M. Urysohn, *Fund. Math.* V (h paraitre).\n\n15) Existe-il un continu dont tout sous-continu est ind\\'ecomposable?\n\nSolution *affirmative* de M. Knaster, *Fund. Math.* III pp. 247-286.\n\n16) Existe-il continu qui est une somme de ses vrais sous-continues satur\\'es disjoints?\n\nSolution *affirmative* de M. Knaster et Kuratowski, *Fund. Math.* V (\\`a paraitre).\n\n\n\n\n","slug":"75 Probelms (French)","published":0,"updated":"2024-11-27T06:18:57.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5rs0009m8nxc31d69nm","content":"<ol type=\"1\">\r\n<li>Lorsqu'un ensemble de points <span class=\"math inline\">\\(P\\)</span>\r\nest une image biunivoque et continue (mais pas n'ecessairement\r\nbicontinue) d'un ensemble <span class=\"math inline\">\\(Q\\)</span> et\r\nlorsque <span class=\"math inline\">\\(Q\\)</span> est une image biunivoque\r\net continue de <span class=\"math inline\">\\(P\\)</span>, lest ensembles\r\n<span class=\"math inline\">\\(P\\)</span> et <span class=\"math inline\">\\(Q\\)</span> sont-ils n'ecessairement\r\nhomeomorphes?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Un continu (born'e) plan, topologiquement homog`ene, est-il\r\nn'ecessairement hom'eomorphe `a une circonf'erence?</li>\r\n</ol>\r\n<p>(Un ensemble <span class=\"math inline\">\\(E\\)</span> est dit\r\n<em>topologiquement homog'ene</em>, lorsqu'il existe pour tout couple de\r\npoints <span class=\"math inline\">\\(a,b\\)</span> de <span class=\"math inline\">\\(E\\)</span> une transformation biunivoque et\r\nbicontinue de <span class=\"math inline\">\\(E\\)</span> en lui-m'eme qui\r\ntransforme <span class=\"math inline\">\\(a\\)</span> en <span class=\"math inline\">\\(b\\)</span>)</p>\r\n<p>Probl'eme de MM. B. Knaster et C. Kuratowski.</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>Un ensemble ordonn'e (lin'eairement) sans sauts ni lacunes et tel\r\nque tout ensemble de ses intervalles (contenant plus qu'un 'el'ement)\r\nn'empi'etant pas les uns sur les autres est au plus d'enombrable, est-il\r\nn'ecessairement un continu lin'eaire (ordinaire)?</li>\r\n</ol>\r\n<p>Probl'eme de M. M. Souslin.</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>Existe-t-il une d'ecomposition d'un intervalle en <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles (non vides)\r\nmesurables <span class=\"math inline\">\\(B\\)</span> et sans point commun\r\ndeux `a deux?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"5\" type=\"1\">\r\n<li>Existe-t-il un ensemble lin'eaire ind'enombrable <span class=\"math inline\">\\(E\\)</span> tel que tout ensemble lin'eaire\r\nhom'eomorphe `a <span class=\"math inline\">\\(E\\)</span> soit de mesure\r\nlebesguienne nulle? Peut-on d'emontrer l'existence d'un tel ensemble,\r\nm'eme en admettant que <span class=\"math inline\">\\(2^{\\aleph_{0}} =\r\n\\aleph_{1}\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"6\" type=\"1\">\r\n<li>Peut-on d'emoutrer sans l'hypoth'ese du continu (<span class=\"math inline\">\\(2^{\\aleph_{0}} = \\aleph_{1}\\)</span>) qu'une somme\r\nde <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles de mesure\r\nlebesguienne nulle n'est pas n'ecessairement de mesure lebesquienne\r\nnulle? qu'une somme de <span class=\"math inline\">\\(\\aleph_{1}\\)</span>\r\nensembles de premi'ere cat'egorie n'est pas n'ecessairement de premi'ere\r\ncat'egorie? qu'un produit de <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles (<span class=\"math inline\">\\(A\\)</span>) n'est pas n'ecessairement un ensemble\r\n<span class=\"math inline\">\\(A\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"7\" type=\"1\">\r\n<li>Peut-on 'etablir sans l'hypoth'ese du continu l'esistence d'un\r\nensemble plan qui est de mesure (lebesguienne) nulle sur toute\r\nparall'ele `a l'axe d'abscisses et dont le compl'ementaire est de mesure\r\nnulle sur toute parall'ele `a l'axe d'ordonn'ees?</li>\r\n</ol>\r\n<p>Probl'eme de M. H. Steinhaus.</p>\r\n<ol start=\"8\" type=\"1\">\r\n<li>Peut-on donner un exemple effectif d'un ensemble de nombres r'eels\r\n<span class=\"math inline\">\\(E\\)</span> tel que toute somme, toute\r\ndiff'erence, tout produit et tout quotient de deux nombres de <span class=\"math inline\">\\(E\\)</span> (la division par 0 except'ee)\r\nappartienne `a <span class=\"math inline\">\\(E\\)</span> et que <span class=\"math inline\">\\(E\\)</span> soit ind'enombrable, mais distinct de\r\nl'ensemble de tous les nombres r'eels?</li>\r\n</ol>\r\n<p>Probl'eme de M. S. Mazurkiewicz.</p>\r\n<ol start=\"9\" type=\"1\">\r\n<li>Quelle est la puissance des ensembles compl'ementaires aux ensembles\r\n(<span class=\"math inline\">\\(A\\)</span>)?</li>\r\n</ol>\r\n<p>Probl'eme de M. N. Lusin.</p>\r\n<p><em>Remarque</em>. Les ensembles (<span class=\"math inline\">\\(A\\)</span>) lin'eaires sont des projections\r\northogonales (sur une froite) des ensembles plans mesurables <span class=\"math inline\">\\(B\\)</span>. M. Lusin a d'emontr'e que la puissance\r\nd'un ensemble ind'enombrable compl'ementaire `a un ensemble (<span class=\"math inline\">\\(A\\)</span>) est <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ou <span class=\"math inline\">\\(2^{\\aleph_{0}}\\)</span>, mais on ne sait pas si\r\nelle peut ^etre en r'ealit'e <span class=\"math inline\">\\(\\aleph_{1}\\)</span> (dans le cas o'u <span class=\"math inline\">\\(2^{\\aleph_{0}} &gt; \\aleph_{1}\\)</span>)</p>\r\n<ol start=\"10\" type=\"1\">\r\n<li>Existe-t-il une fonction de deuxi'eme classe qui n'est pas une\r\nlimite de fonctions presque partout continues? Peut-on donner un exemple\r\neffectif d'une fonction qui n'est pas une limite de fonctions\r\nponctuellement discontinues?</li>\r\n</ol>\r\n<p>Probl'eme de MM. T. Feosztyn et W. Sierpinski.</p>\r\n<ol start=\"11\" type=\"1\">\r\n<li>Existe il une classe (<span class=\"math inline\">\\(\\mathcal{L}\\)</span>) de M. Fr'echet (c'est-`a\r\ndire une classe dans laquelle la limite est d'efinie) de puissance\r\nsup'erieure `a celle du continu, telle que tout ensemble non\r\nd'enombrable d''el'ements de cette classe contient au moins un 'el'ement\r\nde condensation?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"12\" type=\"1\">\r\n<li>Un ensemble ordonn'e (lin'eairement) dont tous les sousensembles\r\nbien ordonn'es (croissants et d'croissants) sont au plus d'enombrables,\r\na-t-il n'ecessairement une puissance non sup'erieure `a celle du\r\ncontinu?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"13\" type=\"1\">\r\n<li>Existe-il un ensemble plan ferm'e qui ne soit pas somme de deux\r\nensembles ferm'es sans points communs, mais qui est une somme d'une\r\ninfinit'e d'enombrable d'ensembles ferm'es sans points communs deux `a\r\ndeux.</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"14\" type=\"1\">\r\n<li>Un continu dans l'espace `a <span class=\"math inline\">\\(m\\)</span>\r\ndimensions qui est hom'eomorphe de tout continu qu'il contient, est il\r\nn'ecessairement un arc simple (c'est-`a-dire une image biunivoque et\r\ncontinu de l'intervalle 0-1)?</li>\r\n</ol>\r\n<p>Probl'eme de M. Mazurkiewicz.</p>\r\n<ol start=\"15\" type=\"1\">\r\n<li>Existe-il un continu dont tout sous continu est ind'ecomposable? (Un\r\ncontinu est dit ind'ecomposable lorsqu'il n'est pas une somme de deux\r\ncontinus diff'erents de lui.)</li>\r\n</ol>\r\n<p>Probl'eme de MM. Knaster et Kuratowski.</p>\r\n<ol start=\"16\" type=\"1\">\r\n<li>Existe il un continu (non born'e) qui est une somme de ses vrais\r\nsous continus satur'es n'ayant deux `a deux aucun point commun?</li>\r\n</ol>\r\n<p>(On dit qu'un vrai sous-continu <span class=\"math inline\">\\(K\\)</span> de <span class=\"math inline\">\\(C\\)</span> est <em>satur'e</em>, lorsqu'il\r\nn'existe aucun continu diff'erent de <span class=\"math inline\">\\(K\\)</span> et de <span class=\"math inline\">\\(C\\)</span> qui contienne <span class=\"math inline\">\\(K\\)</span> et qui soit contenu dans <span class=\"math inline\">\\(C\\)</span>.)</p>\r\n<p>Probl'eme de M. Kuratowski.</p>\r\n<ol start=\"17\" type=\"1\">\r\n<li>Quelle est la puissance de l'ensemble de toutes les valeurs que ne\r\nprend pas une fonction de classe 1 de M. Baire?</li>\r\n</ol>\r\n<p>(Ce probl'eme est 'equivalent au probl'eme 9 de M. Lusin, t. I.\r\np.224. Il suffirait de r'esoudre ce probl'eme pour les fonctions\r\nadmettant une infinit'e d'enombrable de points de discontinuit'e.)</p>\r\n<ol start=\"18\" type=\"1\">\r\n<li>Un ensemble (lin'eaire) de puissance inf'erieure `a celle du\r\ncontinu, est-il n'ecessairement d'e la premi'ere cath'egorie de M.\r\nBaire?</li>\r\n</ol>\r\n<p>Probl'eme de M. Ruziewicz.</p>\r\n<ol start=\"19\" type=\"1\">\r\n<li>Existe-t-il dans chaque ensemble biconnexe <span class=\"math inline\">\\(B\\)</span> un point <span class=\"math inline\">\\(p\\)</span> tel que l'ensemble <span class=\"math inline\">\\(B - (p)\\)</span> ne contient aucun ensemble\r\nconnexe?</li>\r\n</ol>\r\n<p><em>Remarque</em>. D'apre'es un th'eor'eme de M. Kline (ce volume,\r\np.238), il ne peut exister dans un ensemble connexe <span class=\"math inline\">\\(B\\)</span> plus d'un point <span class=\"math inline\">\\(p\\)</span> jouissant de la propri'et'e en\r\nquestion. On sait, d'autre part, que, si un tel point existe, l'ensemble\r\n<span class=\"math inline\">\\(B\\)</span> est biconnexe, c.-`a-d. il n'est\r\npas somme de duex ensembles connexes disjoints cont'enant plus d'un\r\npoint (cf. Knaster et Kuratowski, <em>Fund. Math.</em> II, p,214.)</p>\r\n<p>Probl'eme de M. Kuratowski.</p>\r\n<ol start=\"20\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(f(E)\\)</span> une fonction d'efinie\r\npor tout ensemble <span class=\"math inline\">\\(E\\)</span> mesurable\r\n(<span class=\"math inline\">\\(L\\)</span>) d'un espace euclidien `a <span class=\"math inline\">\\(m \\geq 3\\)</span> dimensions et satisfaisant aux\r\nconditions suivantes:</li>\r\n</ol>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(f(E)\\geq 0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(f(E_{0}) = 1\\)</span> pur un certain\r\nensemble <span class=\"math inline\">\\(E_{0}\\)</span> de mesure 1.</li>\r\n<li><span class=\"math inline\">\\(f(E_{1} +E_{2}) = f(E_{1}) +\r\nf(E_{2})\\)</span>, si <span class=\"math inline\">\\(E_{1} E_{2} =\r\n0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(f(E_{1}) = f(E_{2})\\)</span>, si <span class=\"math inline\">\\(E_{1}\\)</span> et <span class=\"math inline\">\\(E_{2}\\)</span> sont superposables.</li>\r\n</ol>\r\n<p>La fonction <span class=\"math inline\">\\(f(E)\\)</span> coincide-t-elle\r\nn'ecessairement avec la mesure lebesguienne de l'ensemble <span class=\"math inline\">\\(E\\)</span>?</p>\r\n<p>(Pour <span class=\"math inline\">\\(m=1\\)</span> et <span class=\"math inline\">\\(m=2\\)</span> la r'eponse est n'egative, comme l'a\r\nprouv'e M. Banach dans un m'emoire qui sera publi'e dans le tome IV de\r\nce jounal.)</p>\r\n<p>Probl'eme de M. Ruziewicz.</p>\r\n<ol start=\"21\" type=\"1\">\r\n<li>A 'etant un ensemble de nombres r'eels qui n'est de I cat'egorie\r\ndans aucun intervalle, existe-il une d'ecomposition: <span class=\"math inline\">\\(A = B + C\\)</span>, <span class=\"math inline\">\\(B\r\n\\times C = 0\\)</span> telle que ni <span class=\"math inline\">\\(B\\)</span> ni <span class=\"math inline\">\\(C\\)</span> ne soient de I cat'egorie dans aucun\r\nintervalle?</li>\r\n</ol>\r\n<p><em>Remarque</em>. On en pourrait donner la solution affirmative dans\r\nl'hypoth'ese suppl'ementaire que <span class=\"math inline\">\\(A\\)</span>\r\nposs'ede la propri'et'e de Baire (au sens etabli dans ce volume), p.319.\r\nM. Sierpinski en a signal'e d'autre part, la solution affirmative dans\r\nl'hypoth'ese du continu, <span class=\"math inline\">\\(\\aleph_{1} =\r\n2^{\\aleph_{0}}\\)</span>.</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"22\" type=\"1\">\r\n<li>Appellons l'ensemle (lin'eaire) <span class=\"math inline\">\\(E\\)</span> <em>parfaitement mesurable</em>, si\r\ntout ensemble hom'eomorphe `a <span class=\"math inline\">\\(E\\)</span> est\r\nmesurable au sens de Lebesgue. Quelle est la puissance de la classe des\r\nensembles parfaitement mesurables? Un ensemble compl'ementaire `a un\r\nensemble parf. mesurable est-il toujours parf. mesurable?</li>\r\n</ol>\r\n<p>Problem of M. Urysohn.</p>\r\n<ol start=\"23\" type=\"1\">\r\n<li>Esiste-t-il une fonction d'une variable r'eelle <span class=\"math inline\">\\(f(x)\\)</span> pantachiquement dicontinue et telle\r\nqu'on ait pour tout <span class=\"math inline\">\\(x\\)</span> r'eel</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\lim \\frac{f(x+h) - f(x-h)}{2h} =\r\n0?\\]</span></p>\r\n<p>Problem of M. Steinhaus.</p>\r\n<ol start=\"24\" type=\"1\">\r\n<li>Une fonction satisfaisan `a la condition de Baire, est-elle\r\nn'ecessairement mesurable (<span class=\"math inline\">\\(L\\)</span>)?\r\nQuelle est la puissance de toutes les fonctions d'une variable r'eelle\r\nsatisfaisant `a la condition de Baire? (On dit qu'une fonction <span class=\"math inline\">\\(f(x)\\)</span> satisfait `a la condition de Baire,\r\nsi elle continue sur tout ensemble parfait quand on n'eglige les\r\nensembles de premi'ere cat'egorie par rapport `a cet ensemble\r\nparfait.)</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"25\" type=\"1\">\r\n<li>Un ensemble plan, tel que toute droite le rencontre en deux (et\r\nseulement deux) points, peut-il ^etre mesurable (<span class=\"math inline\">\\(B\\)</span>)? (L'existence d'un tel ensemble a\r\n'et'e d'emontr'e, `a l'aide du th'eor'eme de M. Zermelo, par MM.\r\nMazurkiewicz[^1] (en 1914) et Rosenthal[^2] (en 1922))</li>\r\n</ol>\r\n<p>[^1] Comptes Rendus de lu Soc. des Sciences de Varsovic, t. VII,\r\np.382.</p>\r\n<p>[^2] Sitzungaber d. Bayer. Akad. d. Wiss., math-phys. K1, 1922, p.\r\n223.</p>\r\n<ol start=\"26\" type=\"1\">\r\n<li>Une fonction de classe 3 de M. Baire, est-elle toujours une\r\nsuperposition de trois fonctions de classe 1, c'est-`a-dire existe-t-il\r\npour toute fonction <span class=\"math inline\">\\(f(x)\\)</span> de classe\r\n3 trois fonctions <span class=\"math inline\">\\(\\varphi(x)\\)</span>, <span class=\"math inline\">\\(\\psi(x)\\)</span> et <span class=\"math inline\">\\(\\vartheta(x)\\)</span> de classe, telles qu'on a\r\npour tout <span class=\"math inline\">\\(x\\)</span> r'eel</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[f(x) =\r\n\\varphi\\{\\psi[\\vartheta(x)]\\}\\]</span></p>\r\n<p>Probl'eme de M. Lusin.</p>\r\n<ol start=\"27\" type=\"1\">\r\n<li>L'ensemble <span class=\"math inline\">\\(D(E)\\)</span> des distances\r\ndes points d'un ensemble lin'eaire <span class=\"math inline\">\\(E\\)</span> mesurable <span class=\"math inline\">\\((B)\\)</span>, est-il toujours mesurable (<span class=\"math inline\">\\(B\\)</span>)? ( <span class=\"math inline\">\\(D(E)\\)</span> est done l'ensemble de tous les\r\nnombres <span class=\"math inline\">\\(|x-y|\\)</span>, o'u <span class=\"math inline\">\\(x\\)</span> et <span class=\"math inline\">\\(y\\)</span> appartiennent `a <span class=\"math inline\">\\(E\\)</span>. On peut d'emontrer l'existence des\r\nensembles <span class=\"math inline\">\\(E\\)</span> mesurables (<span class=\"math inline\">\\(L\\)</span>), tels que <span class=\"math inline\">\\(D(E)\\)</span> est non mesurable (<span class=\"math inline\">\\(L\\)</span>).)</li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpinski.</p>\r\n<ol start=\"28\" type=\"1\">\r\n<li><span class=\"math inline\">\\(E\\)</span> 'etant un ensemble plan\r\nmesurable (<span class=\"math inline\">\\(B\\)</span>), d'esignons par <span class=\"math inline\">\\(N(E)\\)</span> l'ensemble de tous les nombres\r\nr'eels <span class=\"math inline\">\\(a\\)</span>, tels que la droite <span class=\"math inline\">\\(x = a\\)</span> rencontre <span class=\"math inline\">\\(E\\)</span> en une infinit'e non-d'enombrable de\r\npoints. L'ensemble <span class=\"math inline\">\\(N(E)\\)</span>, est il\r\nn'ecessairement un ensemble (<span class=\"math inline\">\\(A\\)</span>),\r\nou, plus simplement, est-il mesurable (<span class=\"math inline\">\\(L\\)</span>)? (On peut d'emontrer que l'ensemble de\r\ntous les nombres r'eels <span class=\"math inline\">\\(a\\)</span>, tels que\r\nla droite <span class=\"math inline\">\\(x = a\\)</span> rencontre\r\nl'ensemble <span class=\"math inline\">\\(E\\)</span> (mesurable <span class=\"math inline\">\\(B\\)</span>) en une infinit'e de points est\r\ntoujouts un ensemble <span class=\"math inline\">\\(A\\)</span>.)</li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpinski.</p>\r\n<ol start=\"29\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(F\\)</span> un ensemble plan, p. ex.\r\nferm'e (ou, plus g'en'eralement, mesurable)- Un point <span class=\"math inline\">\\(x\\)</span> de <span class=\"math inline\">\\(F\\)</span> sera dit <em>lin'eairment\r\naccessible</em> s'il sxiste un segment rectiligne <span class=\"math inline\">\\(\\overline{xp}\\)</span> tel que tous ses points (le\r\npoint <span class=\"math inline\">\\(x\\)</span> except'e) soient 'etrangers\r\n`a <span class=\"math inline\">\\(F\\)</span>. Peut-on d'emontrer que\r\nl'ensemble <span class=\"math inline\">\\(A\\)</span> de tous les points\r\nlin'eairement accessibles de <span class=\"math inline\">\\(F\\)</span> est\r\ntoujours mesurable (<span class=\"math inline\">\\(L\\)</span>)?</li>\r\n</ol>\r\n<p>Probl'eme de M. Urysohn.</p>\r\n<ol start=\"30\" type=\"1\">\r\n<li><span class=\"math inline\">\\(f(x)\\)</span> 'etant une fonction\r\ndonn'ee quelconque (mesurable ou non), quelle est la mesure de\r\nl'ensomble de tous les points <span class=\"math inline\">\\(x\\)</span>,\r\ntels que</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\lim\\limits_{h\\to 0} \\left|\\frac{f(x+h)\r\n- f(x)}{h}\\right| = \\infty\\]</span></p>\r\n<p>Probl'eme de M. Ruziewicz.</p>\r\n<ol start=\"31\" type=\"1\">\r\n<li>Le th'eor'eme: \"<span class=\"math inline\">\\(\\mathsf{m} = 2\\cdot\r\n\\mathsf{m}\\)</span> quel soit le nombre cardinal <em>transfini</em>\r\n<span class=\"math inline\">\\(\\mathsf{m}\\)</span>\" est il 'equivalent `a\r\n<em>l'axiome du choix</em>?</li>\r\n</ol>\r\n<p>Cf. ma Note \"<em>Sur quelques th'eor'emes qui 'equivalent `a l'axiome\r\ndu choix</em>\" dans ce volume, p. 147.</p>\r\n<p>Probl'eme de M. Tajtelbaum-Tarski.</p>\r\n<ol start=\"32\" type=\"1\">\r\n<li>Un ensemble plan ferm'e, don tout point est lin'eairement\r\naccessible, est-il n'ecessairement de mesure superficielle nulle?</li>\r\n</ol>\r\n<p>Probl'eme de M. Banach.</p>\r\n<p>Un point <span class=\"math inline\">\\(x\\)</span> de <span class=\"math inline\">\\(F\\)</span> est dit lin'eairement accessible s'il\r\nexiste un segment rectiligne <span class=\"math inline\">\\(\\overline{xp}\\)</span> tel que tous ses points (le\r\npoint <span class=\"math inline\">\\(x\\)</span> excepr'e) soient 'etrangers\r\n`a <span class=\"math inline\">\\(F\\)</span>. M. Urysohn a d'emontr'e que\r\nl'ensemble de tous les points lin'eairement accessibles d'un ensemble\r\nplan ferm'e est toujouts un ensemble (<span class=\"math inline\">\\(A\\)</span>) de M. Souslin, mais peut ne pas ^etre\r\nmesurable (<span class=\"math inline\">\\(B\\)</span>). Or on ne sait pas si\r\nl'ensemble de tous les points lin'eairement accessibles d'un ensemble\r\nplan <span class=\"math inline\">\\(G_{\\delta}\\)</span> est mesurable\r\n(<span class=\"math inline\">\\(L\\)</span>) (Cf. Probl'eme 29, <em>Fund.\r\nMath.</em> t. V, p. 337).</p>\r\n<ol start=\"33\" type=\"1\">\r\n<li>Une image biunivoque et continue (dans un sens) d'un ensemble\r\ncompl'emeutaire `a un ensemble (<span class=\"math inline\">\\(A\\)</span>)\r\nde M. Souslin, est elle de m^eme nature?</li>\r\n</ol>\r\n<p>Probl'eme de Sierpi'nski.</p>\r\n<ol start=\"34\" type=\"1\">\r\n<li>Appelons un ensemble (lin`eaire) mesurable (<span class=\"math inline\">\\(B\\)</span>) de classe <span class=\"math inline\">\\(\\alpha\\)</span> <em>irr'eductible</em> s'il n'est\r\nde classe <span class=\"math inline\">\\(&lt;\\alpha\\)</span> dans aucun\r\nintervalle. Quelle est la puissance de l'ensemble de tous les types\r\ntopologiques d'ensumbles irr'eductibles de classe <span class=\"math inline\">\\(\\alpha\\)</span>?</li>\r\n</ol>\r\n<p>Appelons un ensemble (<span class=\"math inline\">\\(A\\)</span>)\r\nirr'eductible, s'il n'est mesurable (<span class=\"math inline\">\\(B\\)</span>) dans aucun intervalle. Quelle est la\r\npuissance de tous les types topologiques des ensembles (<span class=\"math inline\">\\(A\\)</span>) irr'eductibles?</p>\r\n<p>Probl'eme de MM. Alexandroff et Urysohn.</p>\r\n<ol start=\"35\" type=\"1\">\r\n<li>Appelons l'ensemble (lin'eaire) <span class=\"math inline\">\\(E\\)</span> <em>parfaitement mesurable au sens\r\n'etroit</em>, si toute image univoque et continue de <span class=\"math inline\">\\(E\\)</span> est mesurable au sens de Lebsgue. Un\r\nensemble compl'ementaire `a un ensemble parfaitement mesurable au sens\r\n'etroit, est-il toujours de m^eme nature?</li>\r\n</ol>\r\n<p>Cf. Probl'eme 22 de P. Urysohn (<em>Fund. Math.</em> t. IV, p. 368),\r\nr'esolu par M. Lavrentieff (<em>Fund. Math.</em> t. VI, p. 159).</p>\r\n<p>Probl'eme de M. O. Nikodym.</p>\r\n<ol start=\"36\" type=\"1\">\r\n<li>D'apr'es M. Souslin, si <span class=\"math inline\">\\(E\\)</span> est\r\nun ensemble (<span class=\"math inline\">\\(A\\)</span>) et <span class=\"math inline\">\\(H\\)</span> un ensemble compl'ementaire `a un\r\nensemble (<span class=\"math inline\">\\(A\\)</span>), et si <span class=\"math inline\">\\(E \\subset H\\)</span>, il existe un ensemble <span class=\"math inline\">\\(Q\\)</span>, mesurable (<span class=\"math inline\">\\(B\\)</span>), tel que <span class=\"math inline\">\\(E\\subset Q \\subset H\\)</span>[^3]. Cette\r\nproposition, admet-elle une r'eciproque, c'est-`a-dire, <em><span class=\"math inline\">\\(E\\)</span> 'etant un ensemble compl'ementaire `a\r\nun ensemble (<span class=\"math inline\">\\(A\\)</span>) et <span class=\"math inline\">\\(H\\)</span> ------ un ensemble (<span class=\"math inline\">\\(A\\)</span>), tel que <span class=\"math inline\">\\(E\r\n\\subset H\\)</span>, existe-til tujours un ensemble <span class=\"math inline\">\\(Q\\)</span> mesurable (<span class=\"math inline\">\\(B\\)</span>), tel que <span class=\"math inline\">\\(E\r\n\\subset Q \\subset H\\)</span>?</em></li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpi'nski.</p>\r\n<p>[^3] Voir p. e. N. Lusin et W. Sierpi'nski <em>Journ. de Math.</em>\r\nt. II (1923) p. 60; aussi <em>Bull. Acad. Cracovie</em> 1918 p. 40.</p>\r\n<ol start=\"37\" type=\"1\">\r\n<li>Un continu de Jordan (born'e) qui ne renferme qucune courbe simple\r\nferm'ee est-il hom'eomorphe `a un de ses (vrais) sous-continus?</li>\r\n</ol>\r\n<p>Probl'eme de M. Zarankiewicz.</p>\r\n<ol start=\"38\" type=\"1\">\r\n<li>Un carr'e et un cercle dont les aires sont 'egales peuvent-ils ^etre\r\nd'ecompos'es en un nombre fini de sous-ensembles disjoints repectivement\r\ncongruents?</li>\r\n</ol>\r\n<p>Probl'eme de M. Tarski.</p>\r\n<ol start=\"39\" type=\"1\">\r\n<li>Existe-il un ensemble ferm'e <em>plan</em> pour lequel l'ensemble\r\ndes points lin'eairement accessibles soit non-mesurable (<span class=\"math inline\">\\(B\\)</span>)? (Dans l'espace le probl'eme est\r\nr'esolu par affirmative).</li>\r\n</ol>\r\n<p>Probl'eme de M. O. Nikodym.</p>\r\n<ol start=\"40\" type=\"1\">\r\n<li><span class=\"math inline\">\\(E\\)</span> 'etant un ensemble plan <span class=\"math inline\">\\(G_{\\delta}\\)</span>, l'ensemble de tous les\r\nnombres r'eels <span class=\"math inline\">\\(a\\)</span>, tels que la\r\ndroite <span class=\"math inline\">\\(x =a\\)</span> rencontre l'ensemble\r\n<span class=\"math inline\">\\(E\\)</span> dans un et un seul point, est-il\r\nn'ecessairement compl'ementaire d'un ensemble (<span class=\"math inline\">\\(A\\)</span>) de M. Souslin?</li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpi'nski.</p>\r\n<ol start=\"41\" type=\"1\">\r\n<li><span class=\"math inline\">\\(E_{1}, E_{2}, E_{3}, \\dots\\)</span>\r\n'etant une suite d'enombrable d'ensembles lin'eaires dont chacun est une\r\nprojection d'un ensemble plan compl'ementaire `a un ensemble (<span class=\"math inline\">\\(A\\)</span>) de M. Souslin, l'ensemble $E_{1}E_{2}\r\nE_{3} $ est il de m^eme nature?</li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpi'nski.</p>\r\n<ol start=\"42\" type=\"1\">\r\n<li>Existe-t-il dans tout continu <span class=\"math inline\">\\(A\\)</span>\r\nun continu <span class=\"math inline\">\\(B\\)</span> tel que l'ensemble\r\n<span class=\"math inline\">\\(A-B\\)</span> soit connexe?</li>\r\n</ol>\r\n<p>Probl'eme de MM. Knaster et Zarankiewicz.</p>\r\n<ol start=\"43\" type=\"1\">\r\n<li><span class=\"math inline\">\\(D\\)</span> d'esignant un ensemble ferm'e\r\nhom'eomorphe d'un ensemble plan et situ'e dans l'espace euclidien `a 3\r\ndimensions, est-ce que tout point de <span class=\"math inline\">\\(D\\)</span> est <em>accessible</em> dans cet\r\nespace?</li>\r\n</ol>\r\n<p>(Un point <span class=\"math inline\">\\(d\\)</span> de <span class=\"math inline\">\\(D\\)</span> est dit <em>accessible</em> dans <span class=\"math inline\">\\(E\\)</span>, lorsqu'il existe un continu <span class=\"math inline\">\\(C \\subset E\\)</span> tel que <span class=\"math inline\">\\((d) = CD\\)</span>).</p>\r\n<p>Probl'eme de M. Knaster.</p>\r\n<ol start=\"46\" type=\"1\">\r\n<li>Es wird gefragt die logischen Relationen zwischen den verschiedenen\r\nHomogenit\"atsbegriffen aufzutellen, insoweit sie sich beziehen auf im\r\nkleinen kompakten Mengen. Insbesondere auch wenn die Mengen als\r\nausammenh\"angend und (oder) im kleinen zusammenh\"angend vorausgesetzt\r\nwerden.</li>\r\n</ol>\r\n<p>(Vgl. D. van Dantzig, \"ber topologisch homogene Kontinua, dieser\r\nBand, S. 102, 103).</p>\r\n<p>Probl'eme de M. van Dantzig.</p>\r\n<ol start=\"47\" type=\"1\">\r\n<li>Ist eine jed (zusammenh\"angende, unberandete) <span class=\"math inline\">\\(n\\)</span>-dimensionale Mannigfaltigkeit\r\ninvolutorisch homogen?</li>\r\n</ol>\r\n<p>(Vgl. D. van Dantzig, l. e. S. 104, ^7.)</p>\r\n<p>Probl'eme de M. van Dantzig.</p>\r\n<ol start=\"48\" type=\"1\">\r\n<li>Nennen wir eine topologische Gruppe <em>monothetisch</em>, falls\r\neine unendliche zyklische Gruppe in ihr dicht liegt (in welchem Falle\r\nsie kommutativ ist und additiv geschrieben weden kann), und\r\n<em>komplett</em>, falls eine jede Folge <span class=\"math inline\">\\(x_{\\nu}\\)</span>, die dem Konvergenzkriterium\r\nCauchy's <span class=\"math inline\">\\(\\lim (x_{\\nu} - x_{\\mu} =\r\n0\\)</span> gen\"ugt, ein Limeselement in der Gruppe besitzt, so wird\r\ngefragt, ob eine monothetische Gruppe komplett sein kann ohne kompakt zu\r\nsein.</li>\r\n</ol>\r\n<p>(Vgl. l. c. S. 116 ^{29}a))</p>\r\n<p>Probl'eme de M. van Dantzig.</p>\r\n<ol start=\"49\" type=\"1\">\r\n<li>Soient <span class=\"math inline\">\\(X\\)</span> et <span class=\"math inline\">\\(Y\\)</span> deux continus P'eaniens (= images\r\ncontinues de l'intervalle) et <span class=\"math inline\">\\(Z\\)</span>\r\nleur produit topologique (= l'espace de tous les couples <span class=\"math inline\">\\(z = (x,y)\\)</span> o'u <span class=\"math inline\">\\(\\lim z_{n}=z\\)</span> lorsque <span class=\"math inline\">\\(\\lim x_{n} = x\\)</span> et <span class=\"math inline\">\\(\\lim y_{n} = y\\)</span>).</li>\r\n</ol>\r\n<p>1^0. Si le continu <span class=\"math inline\">\\(X\\)</span>, ainsi que\r\n<span class=\"math inline\">\\(Y\\)</span>, poss'ede la propri'et'e que dans\r\nchaque transformation continue de ce continu en un sous-ensemble il\r\nexiste un point invariant, est-il vrai que <span class=\"math inline\">\\(Z\\)</span> poss'ede la m^eme propri'et'e?</p>\r\n<p>2^0. Si le continu <span class=\"math inline\">\\(X\\)</span>, ainsi que\r\n<span class=\"math inline\">\\(Y\\)</span>, est uni-coh'erent (= dans chaque\r\nd'ecomposition de ce continu en deus sous-continus la partie commune de\r\nces sous-continus est connexe), est-il vrai que <span class=\"math inline\">\\(Z\\)</span> est unicoh'erent?</p>\r\n<p>Probl'eme de M. Kuratowski.</p>\r\n<ol start=\"50\" type=\"1\">\r\n<li>Ist der topologische Kreis die einzige homogene im kleinen\r\nzusammenh\"angende Kurve? (Kurve = eindimensionaler zusammen-h\"angender\r\nkompakter Raum. Homogen hei<span class=\"math inline\">\\(\\beta\\)</span>t\r\nein Raum, der zu je zwei seiner Punkte <span class=\"math inline\">\\(p\\)</span> und <span class=\"math inline\">\\(q\\)</span> eine topologische Selbstabbildung\r\nbesitzt die <span class=\"math inline\">\\(p\\)</span> in <span class=\"math inline\">\\(q\\)</span> \"uberf\"uhrt). In der Ebene ist der\r\nKreis die einzige homogene im kleinen zusammenh\"angende Kurve.</li>\r\n</ol>\r\n<p>(Vgl. Mazurkiewicz, Fund. Math. V, S. 137).</p>\r\n<p>Probl'eme de M. K. Menger.</p>\r\n<ol start=\"51\" type=\"1\">\r\n<li>Gibt es beliebig oder gar unendlich viele kompakte eindimensionale\r\nR\"aume, die zu je zweien eindimentional unvergleichbar sind? Dabei\r\nm\"ogen zwei R\"aume <span class=\"math inline\">\\(R\\)</span> und <span class=\"math inline\">\\(R^{\\prime}\\)</span> eindimentional unvergleichbar\r\nhei<span class=\"math inline\">\\(\\beta\\)</span>en, wenn keine\r\neindimensionale Teilmenge von <span class=\"math inline\">\\(R\\)</span>,\r\n(bzw. von <span class=\"math inline\">\\(R^{\\prime}\\)</span>) hom\"oomorph\r\nist mit einer Teilmenge von <span class=\"math inline\">\\(R^{\\prime}\\)</span> (bzw. von <span class=\"math inline\">\\(R^{\\prime}\\)</span>). Beispielsweise sind\r\neindimensional unvergleichbar eine Strecke und ein Kontinuum ohne\r\nTeilbogen. (Wenn es <span class=\"math inline\">\\(n\\)</span>, bzw. <span class=\"math inline\">\\(\\aleph_{0}\\)</span> paarweise eindimensional\r\nunvergleichbare Kurven gibt, so existieren kompakte eindimensionale\r\nR\"aume, welche mindestens <span class=\"math inline\">\\(2^{n} +1\\)</span>,\r\nbze. <span class=\"math inline\">\\(2^{\\aleph_{0}}\\)</span> monotone, <span class=\"math inline\">\\(F_{\\sigma}\\)</span>-additive, toppologische,\r\nkompaktifizierbare Systeme von Teilmengen enthalten).</li>\r\n</ol>\r\n<p>(Vgl. Monatshefte f. Math. u. Phys. 36, S. 207).</p>\r\n<p>Probl'eme de M. K. Menger.</p>\r\n<ol start=\"52\" type=\"1\">\r\n<li>Existe-il un continu dont tout autre continu soit une image\r\ncontinue?</li>\r\n</ol>\r\n<p>Probl'eme de M. H. Hahn.</p>\r\n<ol start=\"53\" type=\"1\">\r\n<li><ol type=\"a\">\r\n<li>Ist jeder absolute Retrakt in endlich viele absolute Retrakte mit\r\nbeliebig kleinen Durchmessern zerlegbar?</li>\r\n</ol></li>\r\n</ol>\r\n<ol start=\"2\" type=\"a\">\r\n<li>Lasst sieh jede <span class=\"math inline\">\\(R\\)</span>-Menge in\r\nendlich viele absolu#e Retrakte zerlegen?</li>\r\n</ol>\r\n<p>(Die Definition von absoluten Retrakten und von <span class=\"math inline\">\\(R\\)</span>-Mengen ist z. B. in meiner Note aus\r\nFund. Math. XIX, S. 222 angegeben).</p>\r\n<ol start=\"54\" type=\"1\">\r\n<li><p>Ist jedes Teilkontinuum <span class=\"math inline\">\\(C\\)</span>\r\ndes eaklidieelien <span class=\"math inline\">\\(n\\)</span>-dimensionalen\r\nRaumes <span class=\"math inline\">\\(R_{n}\\)</span>, welches <span class=\"math inline\">\\(R_{n}\\)</span> zerschneidet und welches eich durch\r\nbeliebig kleine Transformationen (d. h. durch eine stetige Abbildung,\r\nwelehe jeden Punkt von <span class=\"math inline\">\\(C\\)</span> in einen\r\nbeliebig nahe liegenden Punkt von <span class=\"math inline\">\\(R_{n}\\)</span> tiberfiibrt) in eine mit ihm\r\npunktfremde Teilmenge von R. \"uberf\"uhren lasst, eine (<span class=\"math inline\">\\(n-1\\)</span>)-dimensionale\r\nMannigfaltigkeit?</p></li>\r\n<li><p>L\"asst sich jedes in <span class=\"math inline\">\\(R_{3}\\)</span>\r\nliegende und <span class=\"math inline\">\\(R_{3}\\)</span> zerschneidende\r\nStreckenbild in eich stetig und fixpunktfrei abbilden?</p></li>\r\n</ol>\r\n<p>Probl'emes de M. K. Borsuk.</p>\r\n<ol start=\"56\" type=\"1\">\r\n<li>Soient <span class=\"math inline\">\\(A\\)</span> et <span class=\"math inline\">\\(B\\)</span> deux espaces topologiques et <span class=\"math inline\">\\(A^{2}\\)</span> et <span class=\"math inline\">\\(B^{2}\\)</span> respectivement leur carr'es (a. `a.\r\nd. <span class=\"math inline\">\\(A^{2}\\)</span> p. ex. se compose de tous\r\ntes couples (<span class=\"math inline\">\\(a_{1}\\)</span>, <span class=\"math inline\">\\(a_{2}\\)</span>) extraite de <span class=\"math inline\">\\(A\\)</span>).</li>\r\n</ol>\r\n<p>Est-il vrai que si <span class=\"math inline\">\\(A^{2}\\)</span> et\r\n<span class=\"math inline\">\\(B^{2}\\)</span> sont hom'eomorphes. <span class=\"math inline\">\\(A\\)</span> et <span class=\"math inline\">\\(B\\)</span> le sont aussi?</p>\r\n<p>En ess de relronae positire, on en d'eduit que, <span class=\"math inline\">\\(C\\)</span> 'etant un ensemble qui n'est\r\nhom'eomorphe `a aucun, <span class=\"math inline\">\\(C^{n}\\)</span>, <span class=\"math inline\">\\(n&gt;1\\)</span>, les ensembles <span class=\"math inline\">\\(C^{m}\\)</span> et <span class=\"math inline\">\\(C^{n}\\)</span> ne sont non plus hom'eomorphes pour\r\n<span class=\"math inline\">\\(m\\neq n\\)</span>; cela fournit dans le eas\r\no`u <span class=\"math inline\">\\(C\\)</span> est un intervalle 1e\r\nth'eor'eme de \"l'invariance de la dimension\" de M. Brouwer.</p>\r\n<p>Probl'eme de M. S. Ulam.</p>\r\n<ol start=\"57\" type=\"1\">\r\n<li>Existe-il un continu de dimension infinie qui n'en contient aucun de\r\ndimension finie?</li>\r\n</ol>\r\n<p>Probl'eme de M. S. Mazurkiewicz.</p>\r\n<ol start=\"58\" type=\"1\">\r\n<li>Gibt es in einer Menge <span class=\"math inline\">\\(E\\)</span> von\r\nder M\"achtigkeit <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ein\r\nabz\"ahlbares System von Teilmengen <span class=\"math inline\">\\(A_{1},\r\nA_{2},\\dots\\)</span> derart, dass man in der Gestalt <span class=\"math display\">\\[X = \\overline{\\lim} A_{p_{n}}\\]</span> (<span class=\"math inline\">\\(p_{1}, p_{2},,\\dots\\)</span> Teilfolge der\r\nnat\"urlichen Zahlen, <span class=\"math inline\">\\(\\overline{\\lim}\\)</span> bedeutet dag Barel-sche\r\n<em>ensemble limite complet</em>) alle Teilmengen <span class=\"math inline\">\\(X\\)</span> von <span class=\"math inline\">\\(E\\)</span> erh\"alt?</li>\r\n</ol>\r\n<p>(Es handelt sich, die Verneinung ohne Benutzung der\r\nKontinuumhypethese zu beweisen).</p>\r\n<p>Probl'me de M. F. Hausdorff.</p>\r\n<ol start=\"59\" type=\"1\">\r\n<li>Une fonction jouissant de la propri'et'e de Baire (c'est-`a-dire\r\ncontinue sur tout ensemble parfait, lorsqu'on n'eglige un ensemble de\r\n<span class=\"math inline\">\\(1^{re}\\)</span> cat'egorie relativement `a\r\ncet ensemble) d'une fonction jouiseant de la propri'et'e de Baire,\r\nest-elle de la m^eme nature?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpi'nski.</p>\r\n<ol start=\"60\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(\\rho\\)</span> l'ensemble de toutes\r\nles transformations hom'eomorphes du plan cart'esien en lui-m^eme, de la\r\nforme: <span class=\"math display\">\\[x^{\\prime} = x, \\quad y^{\\prime}\r\n=f(x,y)\\]</span> et <span class=\"math display\">\\[x^{\\prime}=g(x,y),\r\n\\quad  y^{\\prime}=y.\\]</span></li>\r\n</ol>\r\n<p>D'esignons par <span class=\"math inline\">\\(\\sigma\\)</span> le groupe\r\nform'e par toutes les superpositions finies de toutes les\r\ntransformations appartenant `a <span class=\"math inline\">\\(\\rho\\)</span>. Une transformation hom'eomorphe\r\narbitraire du plan en lui-m^eme se laisse-telle toujours approcher par\r\ncelles du groupe <span class=\"math inline\">\\(\\sigma\\)</span>?</p>\r\n<p>Un probl'eme analogue subsiste pour les espaces `a <span class=\"math inline\">\\(n&gt;2\\)</span> dimensions. Probl'eme de M. S.\r\nUlam.</p>\r\n<ol start=\"61\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(E\\)</span> un ensemble plan <span class=\"math inline\">\\(G_{\\delta}\\)</span> (plus g'en'eralement: un\r\nensemble borelien) dont tontes les intersections avec les droites\r\nparall'eles `a l'axe des <span class=\"math inline\">\\(y\\)</span> sont des\r\nensembles ferm'es (plus g'en'eralement: des <span class=\"math inline\">\\(F_{\\sigma}\\)</span>). La projection de <span class=\"math inline\">\\(E\\)</span> sur l'axe des <span class=\"math inline\">\\(x\\)</span> est-elle toujours un ensemble\r\nborelien?</li>\r\n</ol>\r\n<p>Probl'eme de M. E. Szpilrajsn.</p>\r\n<ol start=\"62\" type=\"1\">\r\n<li>Die (reelle) Funktion <span class=\"math inline\">\\(f(x)\\)</span> der\r\nreellen Variablen <span class=\"math inline\">\\(x\\)</span> heisse\r\n<em>symmetrisch-stetig</em> wenn f\"ur jedes <span class=\"math inline\">\\(x\\)</span> <span class=\"math display\">\\[\\lim\\limits_{h \\to 0} [f(x+h) - f(x - h)] =\r\nO.\\]</span> Kann die Menge der Unstetigkeitsstellen einer solchen\r\nFunktion unabz\"ahlbar sein? Kann sie eine beliebig vorgeschriebene Menge\r\n<span class=\"math inline\">\\(F_{\\sigma}\\)</span> sei? (Dass sie eine\r\nbeliebig vorgeschriebene abz\"ahlbare Menge sein kann, ist leicht\r\neinzusehen.)</li>\r\n</ol>\r\n<p>Probl'eme de M. F. Hausdorff.</p>\r\n<ol start=\"63\" type=\"1\">\r\n<li>Deux espaces compacts <span class=\"math inline\">\\(A\\)</span> et\r\n<span class=\"math inline\">\\(B\\)</span> ont le <em>m^eme type\r\nd'homotopie</em>, lorsqu'il existe une transformation continue <span class=\"math inline\">\\(f\\)</span> de <span class=\"math inline\">\\(A\\)</span> en <span class=\"math inline\">\\(B\\)</span> et une transformation continue <span class=\"math inline\">\\(f\\)</span> de <span class=\"math inline\">\\(A\\)</span> en <span class=\"math inline\">\\(B\\)</span> et une transformation continue <span class=\"math inline\">\\(\\varphi\\)</span> de <span class=\"math inline\">\\(B\\)</span> en <span class=\"math inline\">\\(A\\)</span>, telles que les transformations\r\nsuperpos'ees <span class=\"math inline\">\\(\\varphi f\\)</span> et <span class=\"math inline\">\\(f\\varphi\\)</span> (consid'er'ees respectivement\r\ncomme des trans-formations de <span class=\"math inline\">\\(A\\)</span> en\r\n<span class=\"math inline\">\\(A\\)</span> et de <span class=\"math inline\">\\(B\\)</span> en <span class=\"math inline\">\\(B\\)</span>) soient homotopes `a l'identit'e. Deux\r\nvari'et'es ferm'ees de m^eme type d'homotopie sont-elles toujours\r\nhom'eomorphes?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Hurewicz.</p>\r\n<ol start=\"64\" type=\"1\">\r\n<li><p>Gibt es im <span class=\"math inline\">\\(R^{n}\\)</span> zwei\r\norientierbare Mannigfaltigkeiten <span class=\"math inline\">\\(M_{1}^{k}\\)</span> und <span class=\"math inline\">\\(M_{2}^{k}\\)</span>, deren Komplement\"arr\"aume\r\n<span class=\"math inline\">\\(R^{n} - M_{1}^{k}\\)</span> und <span class=\"math inline\">\\(R^{n} - M_{2}^{k}\\)</span> hom\"oomorph und deren\r\nHomologieringe nicht isomorph sind?</p></li>\r\n<li><p>Soient <span class=\"math inline\">\\(B_{0}, B_{1}, B_{2}, \\dots,\r\nB_{\\omega}, \\dots, B_{\\alpha}, \\dots\\)</span> des classes boreliennes\r\nd'ensembles, form'ees en partant d'une classe quelconque d'ensembles\r\nabstraits. On sait que <span class=\"math inline\">\\(B_{\\alpha} =\r\nB_{\\alpha+}\\)</span>. entra^ine <span class=\"math inline\">\\(B_{\\alpha}=\r\nB_{\\beta}\\)</span> pour tout <span class=\"math inline\">\\(\\beta&gt;\\alpha\\)</span>; soit <span class=\"math inline\">\\(\\alpha_{0}\\)</span> le premier nombre <span class=\"math inline\">\\(\\alpha\\)</span> satisfaisant `a cette condition.\r\nQuels sont les nombres <span class=\"math inline\">\\(\\nu\\)</span> pour\r\nlesquels il existe des classes <span class=\"math inline\">\\(B_{0}\\)</span> telles que l'on ait <span class=\"math inline\">\\(\\alpha_{0} = \\nu\\)</span>? (Cf. Fund. Math. t. XV,\r\np. 284).</p></li>\r\n</ol>\r\n<p>Probl'emes de M. A. Ko1mogoroff.</p>\r\n<ol start=\"66\" type=\"1\">\r\n<li>La propri'et'e <span class=\"math inline\">\\(LC\\)</span>\r\n<em>faible</em> entra^ine-t-elle la propri'et'e <span class=\"math inline\">\\(LC\\)</span> forte pour tout espace m'etrique\r\ncompact? M^eme question pour les pro-pri'et'es <span class=\"math inline\">\\(HLC\\)</span>. (Pour les d'efinitions voir Anaals\r\nof Mathematics, vol. 85, p. 119-129 et Duke Mathematical Journal, vol.\r\n1, p. 1-18).</li>\r\n</ol>\r\n<p>Probl'eme de M. S. Lefschetz.</p>\r\n<ol start=\"67\" type=\"1\">\r\n<li>La propri'et'e (<span class=\"math inline\">\\(C\\)</span>) des\r\nensembles lin'eaires est elle invariante par rapport aux transformations\r\nhom'eomorphes et, plus g'en'erale-ment, par rapport aux transformations\r\ncontinues? (On dit qu'un ensemble <span class=\"math inline\">\\(E\\)</span>\r\nposs'ede la <em>propri'et'e</em> (<span class=\"math inline\">\\(C\\)</span>), lorsqu'il existe pour chaque suite\r\n<span class=\"math inline\">\\(\\{a_{n}\\}\\)</span> de nombres positifs une\r\nd'ecomposition $E=E_{1}+E_{2} + $ telle que le diam'etre de <span class=\"math inline\">\\(E_{n}\\)</span> ne d'epasse pas <span class=\"math inline\">\\(a_{n}\\)</span> pour <span class=\"math inline\">\\(n=1, 2,\\dots\\)</span>. Cf. Fund. Math, t. XI, p.\r\n304; t. XV, p. 126; t. XXII, p. 310.)</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpi'nski.</p>\r\n<ol start=\"68\" type=\"1\">\r\n<li>Tai et <span class=\"math inline\">\\(E_{1}\\)</span> 'etant deux\r\nensembles lin'eaires toujours de premi'ere cat'egorie (c. `a d. de\r\npremi'ere cat'egorie sur tout ensemble parfait), l'ensemble <span class=\"math inline\">\\(E_{1} \\times E_{2}\\)</span>. (c. `a d. l'ensemble\r\nde tous les points <span class=\"math inline\">\\((x, y)\\)</span> du plan\r\no'u <span class=\"math inline\">\\(x \\in E_{1}\\)</span> et <span class=\"math inline\">\\(y \\in E_{2}\\)</span>) est-il de m^eme nature?</li>\r\n</ol>\r\n<p>Probl'eme de M. E. Szpilrajn.</p>\r\n<ol start=\"69\" type=\"1\">\r\n<li>Lorsqu'une conrbe de Jordan (dans un espace `a trois dimensions)\r\nposs'ede en chaque point une tangente d'etermin'ee, existe-t-il\r\nn'ecessairement une reprparam'etrique de cette courbe exprimant les\r\ncoordonn'ees cart'esiennes d'un point de cette courbe comme fonctions\r\nd'erivables d'un param'etre (et cela sans que les trois d'erive'ees\r\ns'annulent en m^eme temps)?</li>\r\n</ol>\r\n<p>En cas de r'epinse n'egative, la question est repos'ee en admenttant\r\nun ensemble de mesure nulle de valeues du param'etre o'u les conditions\r\nimpos'ees ne sont pas toutes deux v'erifi'ees.</p>\r\n<p>Probl'eme de M. M. Fr'echet.</p>\r\n<ol start=\"70\" type=\"1\">\r\n<li>Existe-t-il un ensemble lin'eaire <span class=\"math inline\">\\(E\\)</span> tel que chaque ensemmble analytique\r\nlin'eaire est une image biunivoque et continue (dans un sens) de <span class=\"math inline\">\\(E\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpi'nski.</p>\r\n<ol start=\"71\" type=\"1\">\r\n<li>Existe-t-il une suite infinie <span class=\"math inline\">\\(S\\)</span>\r\nde fonctions d'une variable r'eelle (mesurables ou non), telle que toute\r\nfonction d'une variable r'eelle dde classe <span class=\"math inline\">\\(2\\)</span> Baire soit limite d'une suit extraite\r\nde <span class=\"math inline\">\\(S\\)</span>?</li>\r\n</ol>\r\n<p>(D'apr'es M. C. Burstin une telle suite <span class=\"math inline\">\\(S\\)</span> ne peut ^etre compos'ee uniquement de\r\nfonctions mesurables[^4])</p>\r\n<p>Probl'eme de M. W. Sierpi'nski.</p>\r\n<p>[^4] Monatshefte f. Math. u. Phys. 28 (1917), p. 107.</p>\r\n<ol start=\"72\" type=\"1\">\r\n<li>Existe-t-il dans l'espace cart'esien `a <span class=\"math inline\">\\(n\\)</span> dimensions (<span class=\"math inline\">\\(n&gt;1\\)</span>) un ensemble toujours de premi'ere\r\ncat'egorie (c. `a d. de premi'ere cat'egorie sur chaque ensemble\r\nparfait) et qui soit de dimension positive?</li>\r\n</ol>\r\n<p>(M. W. Hurewicz a d'emontr'e `a l'aide de l'hypoth'ese du continu\r\nqu'il existe dans l'espace de Hilbert un ensemble ind'enombrable <span class=\"math inline\">\\(H\\)</span> dont chaque sous-ensemble\r\nind'enombrable est de dimension infinie[^5]). M. F. Hausdorff a\r\nremarqu'e l'ensemble <span class=\"math inline\">\\(H\\)</span> est toujours\r\nde premi'ere cat'egorie. Cela r'esulte ais'ement du fait que chaque\r\nespace m'etrique s'eparable <span class=\"math inline\">\\(M\\)</span> est\r\nsomme d'un ensemble de dimension <span class=\"math inline\">\\(0\\)</span>\r\net d'un ensemble de premi'ere cat'egorie dans <span class=\"math inline\">\\(M\\)</span>. -- <em>Il existe donc, so <span class=\"math inline\">\\(2^{\\aleph} = \\aleph_{1}\\)</span>, dons l'espace de\r\nHilbert un ensemble toujours de premi'erie cat'egorie et de dimension\r\npositive</em>).</p>\r\n<p>Probl'eme de M. E. Szpilrajn.</p>\r\n<p>[^5] Fund. Math. 19 (1932), p.8.</p>\r\n<ol start=\"73\" type=\"1\">\r\n<li>Soient, dans l'espace euclidien `a trois dimensions, <span class=\"math inline\">\\(E\\)</span> une image hom'eomorphe de la sph'ere\r\nsolide <span class=\"math inline\">\\(S\\)</span> et <span class=\"math inline\">\\(L\\)</span> un segment rectiligne dont l'int'erieur\r\nest contenu dans l'int'erieur, et les extr'emeit'es dans la fronti'ere\r\nde <span class=\"math inline\">\\(E\\)</span>. Existe-t-il toujours une\r\nhom'eomorphie transformant <span class=\"math inline\">\\(E\\)</span> en\r\n<span class=\"math inline\">\\(S\\)</span> de facon que <span class=\"math inline\">\\(L\\)</span> soit transorm'e en diam'etre de <span class=\"math inline\">\\(S\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. K. Borsuk.</p>\r\n<ol start=\"74\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(\\mathbf{B}(\\mathbf{F})\\)</span> la\r\nplus petite famille d'ensembles contenant la famille donn'ee <span class=\"math inline\">\\(\\mathbf{F}\\)</span> et close par rapoort aux\r\nop'erations <span class=\"math inline\">\\(\\sigma\\)</span> et <span class=\"math inline\">\\(\\delta\\)</span> (addition et multiplication\r\nd'enombrables). Existe-t-il une famille d'enombrable <span class=\"math inline\">\\(\\mathbf{D}\\)</span> d'ensembles, telle que tous\r\nles ensembles analytiques lin'eaires appartiennent `a <span class=\"math inline\">\\(\\mathbf{B}(\\mathbf{D})\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. S. Ulam.</p>\r\n<ol start=\"75\" type=\"1\">\r\n<li>Existe-t-il un ensemble infini <span class=\"math inline\">\\(E\\)</span> (p.e. l'ensemble de tous les nombres\r\nnaturels) et une fonction <span class=\"math inline\">\\(f(X)\\)</span> qui\r\nfait correspondre `a tout sous-ensemble <span class=\"math inline\">\\(X\\)</span> de <span class=\"math inline\">\\(E\\)</span> un sous-ensemble <span class=\"math inline\">\\(f(X)\\)</span> de <span class=\"math inline\">\\(E\\)</span>, de sorte que:</li>\r\n</ol>\r\n<p>1<span class=\"math inline\">\\(^\\circ\\)</span> <span class=\"math inline\">\\(X \\subset f(X)\\)</span> pour <span class=\"math inline\">\\(X \\subset E\\)</span>, 2<span class=\"math inline\">\\(^\\circ\\)</span> <span class=\"math inline\">\\(f(X+Y)\r\n= f(X) + f(Y)\\)</span> pour <span class=\"math inline\">\\(X \\subset\r\nE\\)</span>, <span class=\"math inline\">\\(Y \\subset E\\)</span>, 3<span class=\"math inline\">\\(^\\circ\\)</span> il existe pour tout ensemble <span class=\"math inline\">\\(Y \\subset E\\)</span> au moins un ensemble <span class=\"math inline\">\\(X \\subset E\\)</span>, tel que <span class=\"math inline\">\\(Y = f(X)\\)</span>, 4<span class=\"math inline\">\\(^\\circ\\)</span> il existe au moins un ensemble\r\n<span class=\"math inline\">\\(X_{0} \\subset E\\)</span>, tel que <span class=\"math inline\">\\(f(X_{0}) \\neq X_{0}\\)</span>.</p>\r\n<p>Si l'on remplace la condition relative `a <span class=\"math inline\">\\(f(X+Y)\\)</span> par la condition plus faible que\r\n<span class=\"math inline\">\\(f(X) \\subset f(Y)\\)</span> pur <span class=\"math inline\">\\(X \\subset Y \\subset E\\)</span>, la r'eponse\r\npositive est 'evidente.</p>\r\n<p>Probl'eme de M. E. ech.</p>\r\n<h2 id=\"problemes-rsolus.\">Probl'emes r'solus.</h2>\r\n<p>Probl. 1) Lorsque un ensemble de points <span class=\"math inline\">\\(P\\)</span> est une image biunvoque et continue\r\n(dans un sens) de <span class=\"math inline\">\\(Q\\)</span> et <span class=\"math inline\">\\(Q\\)</span> est une image biunivoque et continue de\r\n<span class=\"math inline\">\\(P\\)</span>, peut-on affirmer que les\r\nensembles <span class=\"math inline\">\\(P\\)</span> et <span class=\"math inline\">\\(Q\\)</span> sont hom'eomorphes?</p>\r\n<p>Solution <em>n'egative</em> de M. Kuratowski, <em>Fund. Math.</em> t.\r\nII, pp. 158-160</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>Existe-il une d'ecomposition d'un intervalle en <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles mesurables (<span class=\"math inline\">\\(B\\)</span>), non-vides et sans points communs deux\r\n`a deux?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de MM. Lusin et Sierpinski, <em>Comptes\r\nRendus</em>, t. 175, p.357 (note du 21 ao^ut 1922).</p>\r\n<p>6, troisi'eme partie) Peut-on d'emontrer qu'un produit de <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles (<span class=\"math inline\">\\(A\\)</span>) n'est pas n'ecessairement un ensemble\r\n(<span class=\"math inline\">\\(A\\)</span>)?</p>\r\n<p>Solution <em>affirmative</em> de MM. Lusin et Sierpinski, <em>Journ,\r\nde Math</em>. 1923 (Les auteurs d'efinissent un ensemble qui est\r\ncompl'ementaire d'un ensemble (<span class=\"math inline\">\\(A\\)</span>)\r\nn'est pas n'ecessairement un ensemble (<span class=\"math inline\">\\(A\\)</span>))</p>\r\n<ol start=\"8\" type=\"1\">\r\n<li>Peut-on donner un exemple effectif d'un ensemble de nombres r'eels\r\n<span class=\"math inline\">\\(E\\)</span>, tel que toute somme, toute\r\ndiff'erence, tout produit et tout quotient de deux nombres de <span class=\"math inline\">\\(E\\)</span> (except'e la division par 0)\r\nappartienne `a <span class=\"math inline\">\\(E_{1}\\)</span> et que <span class=\"math inline\">\\(E\\)</span> soit non-d'enombrable, distinct de\r\nl'ensemble de tous les nombres r'eels?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de M. Souslin, <em>Fund. Math.</em> IV,\r\np.311.</p>\r\n<p>10, premi'ere partie) Existe-il une fonction de deuxi'eme classe qui\r\nne soit pas la limite de fonctions preque partout discontinues?</p>\r\n<p>Solution <em>affirmative</em> de M. Zalcwasser.</p>\r\n<ol start=\"12\" type=\"1\">\r\n<li>Un ensemble ordonn'e dont tous les sous-ensembles bien ordonn'es\r\n(croissants on d'ecroissants) sont au plus d'enombraibles, a-t-il\r\nn'ecessairement une puissance non sup'erieure `a celle du continu?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de M. Urysohn, <em>Fund. Math.</em> V\r\n(h paraitre).</p>\r\n<ol start=\"15\" type=\"1\">\r\n<li>Existe-il un continu dont tout sous-continu est\r\nind'ecomposable?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de M. Knaster, <em>Fund. Math.</em> III\r\npp. 247-286.</p>\r\n<ol start=\"16\" type=\"1\">\r\n<li>Existe-il continu qui est une somme de ses vrais sous-continues\r\nsatur'es disjoints?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de M. Knaster et Kuratowski, <em>Fund.\r\nMath.</em> V (`a paraitre).</p>\r\n","site":{"data":{}},"excerpt":"","more":"<ol type=\"1\">\r\n<li>Lorsqu'un ensemble de points <span class=\"math inline\">\\(P\\)</span>\r\nest une image biunivoque et continue (mais pas n'ecessairement\r\nbicontinue) d'un ensemble <span class=\"math inline\">\\(Q\\)</span> et\r\nlorsque <span class=\"math inline\">\\(Q\\)</span> est une image biunivoque\r\net continue de <span class=\"math inline\">\\(P\\)</span>, lest ensembles\r\n<span class=\"math inline\">\\(P\\)</span> et <span class=\"math inline\">\\(Q\\)</span> sont-ils n'ecessairement\r\nhomeomorphes?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Un continu (born'e) plan, topologiquement homog`ene, est-il\r\nn'ecessairement hom'eomorphe `a une circonf'erence?</li>\r\n</ol>\r\n<p>(Un ensemble <span class=\"math inline\">\\(E\\)</span> est dit\r\n<em>topologiquement homog'ene</em>, lorsqu'il existe pour tout couple de\r\npoints <span class=\"math inline\">\\(a,b\\)</span> de <span class=\"math inline\">\\(E\\)</span> une transformation biunivoque et\r\nbicontinue de <span class=\"math inline\">\\(E\\)</span> en lui-m'eme qui\r\ntransforme <span class=\"math inline\">\\(a\\)</span> en <span class=\"math inline\">\\(b\\)</span>)</p>\r\n<p>Probl'eme de MM. B. Knaster et C. Kuratowski.</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>Un ensemble ordonn'e (lin'eairement) sans sauts ni lacunes et tel\r\nque tout ensemble de ses intervalles (contenant plus qu'un 'el'ement)\r\nn'empi'etant pas les uns sur les autres est au plus d'enombrable, est-il\r\nn'ecessairement un continu lin'eaire (ordinaire)?</li>\r\n</ol>\r\n<p>Probl'eme de M. M. Souslin.</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>Existe-t-il une d'ecomposition d'un intervalle en <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles (non vides)\r\nmesurables <span class=\"math inline\">\\(B\\)</span> et sans point commun\r\ndeux `a deux?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"5\" type=\"1\">\r\n<li>Existe-t-il un ensemble lin'eaire ind'enombrable <span class=\"math inline\">\\(E\\)</span> tel que tout ensemble lin'eaire\r\nhom'eomorphe `a <span class=\"math inline\">\\(E\\)</span> soit de mesure\r\nlebesguienne nulle? Peut-on d'emontrer l'existence d'un tel ensemble,\r\nm'eme en admettant que <span class=\"math inline\">\\(2^{\\aleph_{0}} =\r\n\\aleph_{1}\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"6\" type=\"1\">\r\n<li>Peut-on d'emoutrer sans l'hypoth'ese du continu (<span class=\"math inline\">\\(2^{\\aleph_{0}} = \\aleph_{1}\\)</span>) qu'une somme\r\nde <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles de mesure\r\nlebesguienne nulle n'est pas n'ecessairement de mesure lebesquienne\r\nnulle? qu'une somme de <span class=\"math inline\">\\(\\aleph_{1}\\)</span>\r\nensembles de premi'ere cat'egorie n'est pas n'ecessairement de premi'ere\r\ncat'egorie? qu'un produit de <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles (<span class=\"math inline\">\\(A\\)</span>) n'est pas n'ecessairement un ensemble\r\n<span class=\"math inline\">\\(A\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"7\" type=\"1\">\r\n<li>Peut-on 'etablir sans l'hypoth'ese du continu l'esistence d'un\r\nensemble plan qui est de mesure (lebesguienne) nulle sur toute\r\nparall'ele `a l'axe d'abscisses et dont le compl'ementaire est de mesure\r\nnulle sur toute parall'ele `a l'axe d'ordonn'ees?</li>\r\n</ol>\r\n<p>Probl'eme de M. H. Steinhaus.</p>\r\n<ol start=\"8\" type=\"1\">\r\n<li>Peut-on donner un exemple effectif d'un ensemble de nombres r'eels\r\n<span class=\"math inline\">\\(E\\)</span> tel que toute somme, toute\r\ndiff'erence, tout produit et tout quotient de deux nombres de <span class=\"math inline\">\\(E\\)</span> (la division par 0 except'ee)\r\nappartienne `a <span class=\"math inline\">\\(E\\)</span> et que <span class=\"math inline\">\\(E\\)</span> soit ind'enombrable, mais distinct de\r\nl'ensemble de tous les nombres r'eels?</li>\r\n</ol>\r\n<p>Probl'eme de M. S. Mazurkiewicz.</p>\r\n<ol start=\"9\" type=\"1\">\r\n<li>Quelle est la puissance des ensembles compl'ementaires aux ensembles\r\n(<span class=\"math inline\">\\(A\\)</span>)?</li>\r\n</ol>\r\n<p>Probl'eme de M. N. Lusin.</p>\r\n<p><em>Remarque</em>. Les ensembles (<span class=\"math inline\">\\(A\\)</span>) lin'eaires sont des projections\r\northogonales (sur une froite) des ensembles plans mesurables <span class=\"math inline\">\\(B\\)</span>. M. Lusin a d'emontr'e que la puissance\r\nd'un ensemble ind'enombrable compl'ementaire `a un ensemble (<span class=\"math inline\">\\(A\\)</span>) est <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ou <span class=\"math inline\">\\(2^{\\aleph_{0}}\\)</span>, mais on ne sait pas si\r\nelle peut ^etre en r'ealit'e <span class=\"math inline\">\\(\\aleph_{1}\\)</span> (dans le cas o'u <span class=\"math inline\">\\(2^{\\aleph_{0}} &gt; \\aleph_{1}\\)</span>)</p>\r\n<ol start=\"10\" type=\"1\">\r\n<li>Existe-t-il une fonction de deuxi'eme classe qui n'est pas une\r\nlimite de fonctions presque partout continues? Peut-on donner un exemple\r\neffectif d'une fonction qui n'est pas une limite de fonctions\r\nponctuellement discontinues?</li>\r\n</ol>\r\n<p>Probl'eme de MM. T. Feosztyn et W. Sierpinski.</p>\r\n<ol start=\"11\" type=\"1\">\r\n<li>Existe il une classe (<span class=\"math inline\">\\(\\mathcal{L}\\)</span>) de M. Fr'echet (c'est-`a\r\ndire une classe dans laquelle la limite est d'efinie) de puissance\r\nsup'erieure `a celle du continu, telle que tout ensemble non\r\nd'enombrable d''el'ements de cette classe contient au moins un 'el'ement\r\nde condensation?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"12\" type=\"1\">\r\n<li>Un ensemble ordonn'e (lin'eairement) dont tous les sousensembles\r\nbien ordonn'es (croissants et d'croissants) sont au plus d'enombrables,\r\na-t-il n'ecessairement une puissance non sup'erieure `a celle du\r\ncontinu?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"13\" type=\"1\">\r\n<li>Existe-il un ensemble plan ferm'e qui ne soit pas somme de deux\r\nensembles ferm'es sans points communs, mais qui est une somme d'une\r\ninfinit'e d'enombrable d'ensembles ferm'es sans points communs deux `a\r\ndeux.</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpinski.</p>\r\n<ol start=\"14\" type=\"1\">\r\n<li>Un continu dans l'espace `a <span class=\"math inline\">\\(m\\)</span>\r\ndimensions qui est hom'eomorphe de tout continu qu'il contient, est il\r\nn'ecessairement un arc simple (c'est-`a-dire une image biunivoque et\r\ncontinu de l'intervalle 0-1)?</li>\r\n</ol>\r\n<p>Probl'eme de M. Mazurkiewicz.</p>\r\n<ol start=\"15\" type=\"1\">\r\n<li>Existe-il un continu dont tout sous continu est ind'ecomposable? (Un\r\ncontinu est dit ind'ecomposable lorsqu'il n'est pas une somme de deux\r\ncontinus diff'erents de lui.)</li>\r\n</ol>\r\n<p>Probl'eme de MM. Knaster et Kuratowski.</p>\r\n<ol start=\"16\" type=\"1\">\r\n<li>Existe il un continu (non born'e) qui est une somme de ses vrais\r\nsous continus satur'es n'ayant deux `a deux aucun point commun?</li>\r\n</ol>\r\n<p>(On dit qu'un vrai sous-continu <span class=\"math inline\">\\(K\\)</span> de <span class=\"math inline\">\\(C\\)</span> est <em>satur'e</em>, lorsqu'il\r\nn'existe aucun continu diff'erent de <span class=\"math inline\">\\(K\\)</span> et de <span class=\"math inline\">\\(C\\)</span> qui contienne <span class=\"math inline\">\\(K\\)</span> et qui soit contenu dans <span class=\"math inline\">\\(C\\)</span>.)</p>\r\n<p>Probl'eme de M. Kuratowski.</p>\r\n<ol start=\"17\" type=\"1\">\r\n<li>Quelle est la puissance de l'ensemble de toutes les valeurs que ne\r\nprend pas une fonction de classe 1 de M. Baire?</li>\r\n</ol>\r\n<p>(Ce probl'eme est 'equivalent au probl'eme 9 de M. Lusin, t. I.\r\np.224. Il suffirait de r'esoudre ce probl'eme pour les fonctions\r\nadmettant une infinit'e d'enombrable de points de discontinuit'e.)</p>\r\n<ol start=\"18\" type=\"1\">\r\n<li>Un ensemble (lin'eaire) de puissance inf'erieure `a celle du\r\ncontinu, est-il n'ecessairement d'e la premi'ere cath'egorie de M.\r\nBaire?</li>\r\n</ol>\r\n<p>Probl'eme de M. Ruziewicz.</p>\r\n<ol start=\"19\" type=\"1\">\r\n<li>Existe-t-il dans chaque ensemble biconnexe <span class=\"math inline\">\\(B\\)</span> un point <span class=\"math inline\">\\(p\\)</span> tel que l'ensemble <span class=\"math inline\">\\(B - (p)\\)</span> ne contient aucun ensemble\r\nconnexe?</li>\r\n</ol>\r\n<p><em>Remarque</em>. D'apre'es un th'eor'eme de M. Kline (ce volume,\r\np.238), il ne peut exister dans un ensemble connexe <span class=\"math inline\">\\(B\\)</span> plus d'un point <span class=\"math inline\">\\(p\\)</span> jouissant de la propri'et'e en\r\nquestion. On sait, d'autre part, que, si un tel point existe, l'ensemble\r\n<span class=\"math inline\">\\(B\\)</span> est biconnexe, c.-`a-d. il n'est\r\npas somme de duex ensembles connexes disjoints cont'enant plus d'un\r\npoint (cf. Knaster et Kuratowski, <em>Fund. Math.</em> II, p,214.)</p>\r\n<p>Probl'eme de M. Kuratowski.</p>\r\n<ol start=\"20\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(f(E)\\)</span> une fonction d'efinie\r\npor tout ensemble <span class=\"math inline\">\\(E\\)</span> mesurable\r\n(<span class=\"math inline\">\\(L\\)</span>) d'un espace euclidien `a <span class=\"math inline\">\\(m \\geq 3\\)</span> dimensions et satisfaisant aux\r\nconditions suivantes:</li>\r\n</ol>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(f(E)\\geq 0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(f(E_{0}) = 1\\)</span> pur un certain\r\nensemble <span class=\"math inline\">\\(E_{0}\\)</span> de mesure 1.</li>\r\n<li><span class=\"math inline\">\\(f(E_{1} +E_{2}) = f(E_{1}) +\r\nf(E_{2})\\)</span>, si <span class=\"math inline\">\\(E_{1} E_{2} =\r\n0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(f(E_{1}) = f(E_{2})\\)</span>, si <span class=\"math inline\">\\(E_{1}\\)</span> et <span class=\"math inline\">\\(E_{2}\\)</span> sont superposables.</li>\r\n</ol>\r\n<p>La fonction <span class=\"math inline\">\\(f(E)\\)</span> coincide-t-elle\r\nn'ecessairement avec la mesure lebesguienne de l'ensemble <span class=\"math inline\">\\(E\\)</span>?</p>\r\n<p>(Pour <span class=\"math inline\">\\(m=1\\)</span> et <span class=\"math inline\">\\(m=2\\)</span> la r'eponse est n'egative, comme l'a\r\nprouv'e M. Banach dans un m'emoire qui sera publi'e dans le tome IV de\r\nce jounal.)</p>\r\n<p>Probl'eme de M. Ruziewicz.</p>\r\n<ol start=\"21\" type=\"1\">\r\n<li>A 'etant un ensemble de nombres r'eels qui n'est de I cat'egorie\r\ndans aucun intervalle, existe-il une d'ecomposition: <span class=\"math inline\">\\(A = B + C\\)</span>, <span class=\"math inline\">\\(B\r\n\\times C = 0\\)</span> telle que ni <span class=\"math inline\">\\(B\\)</span> ni <span class=\"math inline\">\\(C\\)</span> ne soient de I cat'egorie dans aucun\r\nintervalle?</li>\r\n</ol>\r\n<p><em>Remarque</em>. On en pourrait donner la solution affirmative dans\r\nl'hypoth'ese suppl'ementaire que <span class=\"math inline\">\\(A\\)</span>\r\nposs'ede la propri'et'e de Baire (au sens etabli dans ce volume), p.319.\r\nM. Sierpinski en a signal'e d'autre part, la solution affirmative dans\r\nl'hypoth'ese du continu, <span class=\"math inline\">\\(\\aleph_{1} =\r\n2^{\\aleph_{0}}\\)</span>.</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"22\" type=\"1\">\r\n<li>Appellons l'ensemle (lin'eaire) <span class=\"math inline\">\\(E\\)</span> <em>parfaitement mesurable</em>, si\r\ntout ensemble hom'eomorphe `a <span class=\"math inline\">\\(E\\)</span> est\r\nmesurable au sens de Lebesgue. Quelle est la puissance de la classe des\r\nensembles parfaitement mesurables? Un ensemble compl'ementaire `a un\r\nensemble parf. mesurable est-il toujours parf. mesurable?</li>\r\n</ol>\r\n<p>Problem of M. Urysohn.</p>\r\n<ol start=\"23\" type=\"1\">\r\n<li>Esiste-t-il une fonction d'une variable r'eelle <span class=\"math inline\">\\(f(x)\\)</span> pantachiquement dicontinue et telle\r\nqu'on ait pour tout <span class=\"math inline\">\\(x\\)</span> r'eel</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\lim \\frac{f(x+h) - f(x-h)}{2h} =\r\n0?\\]</span></p>\r\n<p>Problem of M. Steinhaus.</p>\r\n<ol start=\"24\" type=\"1\">\r\n<li>Une fonction satisfaisan `a la condition de Baire, est-elle\r\nn'ecessairement mesurable (<span class=\"math inline\">\\(L\\)</span>)?\r\nQuelle est la puissance de toutes les fonctions d'une variable r'eelle\r\nsatisfaisant `a la condition de Baire? (On dit qu'une fonction <span class=\"math inline\">\\(f(x)\\)</span> satisfait `a la condition de Baire,\r\nsi elle continue sur tout ensemble parfait quand on n'eglige les\r\nensembles de premi'ere cat'egorie par rapport `a cet ensemble\r\nparfait.)</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"25\" type=\"1\">\r\n<li>Un ensemble plan, tel que toute droite le rencontre en deux (et\r\nseulement deux) points, peut-il ^etre mesurable (<span class=\"math inline\">\\(B\\)</span>)? (L'existence d'un tel ensemble a\r\n'et'e d'emontr'e, `a l'aide du th'eor'eme de M. Zermelo, par MM.\r\nMazurkiewicz[^1] (en 1914) et Rosenthal[^2] (en 1922))</li>\r\n</ol>\r\n<p>[^1] Comptes Rendus de lu Soc. des Sciences de Varsovic, t. VII,\r\np.382.</p>\r\n<p>[^2] Sitzungaber d. Bayer. Akad. d. Wiss., math-phys. K1, 1922, p.\r\n223.</p>\r\n<ol start=\"26\" type=\"1\">\r\n<li>Une fonction de classe 3 de M. Baire, est-elle toujours une\r\nsuperposition de trois fonctions de classe 1, c'est-`a-dire existe-t-il\r\npour toute fonction <span class=\"math inline\">\\(f(x)\\)</span> de classe\r\n3 trois fonctions <span class=\"math inline\">\\(\\varphi(x)\\)</span>, <span class=\"math inline\">\\(\\psi(x)\\)</span> et <span class=\"math inline\">\\(\\vartheta(x)\\)</span> de classe, telles qu'on a\r\npour tout <span class=\"math inline\">\\(x\\)</span> r'eel</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[f(x) =\r\n\\varphi\\{\\psi[\\vartheta(x)]\\}\\]</span></p>\r\n<p>Probl'eme de M. Lusin.</p>\r\n<ol start=\"27\" type=\"1\">\r\n<li>L'ensemble <span class=\"math inline\">\\(D(E)\\)</span> des distances\r\ndes points d'un ensemble lin'eaire <span class=\"math inline\">\\(E\\)</span> mesurable <span class=\"math inline\">\\((B)\\)</span>, est-il toujours mesurable (<span class=\"math inline\">\\(B\\)</span>)? ( <span class=\"math inline\">\\(D(E)\\)</span> est done l'ensemble de tous les\r\nnombres <span class=\"math inline\">\\(|x-y|\\)</span>, o'u <span class=\"math inline\">\\(x\\)</span> et <span class=\"math inline\">\\(y\\)</span> appartiennent `a <span class=\"math inline\">\\(E\\)</span>. On peut d'emontrer l'existence des\r\nensembles <span class=\"math inline\">\\(E\\)</span> mesurables (<span class=\"math inline\">\\(L\\)</span>), tels que <span class=\"math inline\">\\(D(E)\\)</span> est non mesurable (<span class=\"math inline\">\\(L\\)</span>).)</li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpinski.</p>\r\n<ol start=\"28\" type=\"1\">\r\n<li><span class=\"math inline\">\\(E\\)</span> 'etant un ensemble plan\r\nmesurable (<span class=\"math inline\">\\(B\\)</span>), d'esignons par <span class=\"math inline\">\\(N(E)\\)</span> l'ensemble de tous les nombres\r\nr'eels <span class=\"math inline\">\\(a\\)</span>, tels que la droite <span class=\"math inline\">\\(x = a\\)</span> rencontre <span class=\"math inline\">\\(E\\)</span> en une infinit'e non-d'enombrable de\r\npoints. L'ensemble <span class=\"math inline\">\\(N(E)\\)</span>, est il\r\nn'ecessairement un ensemble (<span class=\"math inline\">\\(A\\)</span>),\r\nou, plus simplement, est-il mesurable (<span class=\"math inline\">\\(L\\)</span>)? (On peut d'emontrer que l'ensemble de\r\ntous les nombres r'eels <span class=\"math inline\">\\(a\\)</span>, tels que\r\nla droite <span class=\"math inline\">\\(x = a\\)</span> rencontre\r\nl'ensemble <span class=\"math inline\">\\(E\\)</span> (mesurable <span class=\"math inline\">\\(B\\)</span>) en une infinit'e de points est\r\ntoujouts un ensemble <span class=\"math inline\">\\(A\\)</span>.)</li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpinski.</p>\r\n<ol start=\"29\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(F\\)</span> un ensemble plan, p. ex.\r\nferm'e (ou, plus g'en'eralement, mesurable)- Un point <span class=\"math inline\">\\(x\\)</span> de <span class=\"math inline\">\\(F\\)</span> sera dit <em>lin'eairment\r\naccessible</em> s'il sxiste un segment rectiligne <span class=\"math inline\">\\(\\overline{xp}\\)</span> tel que tous ses points (le\r\npoint <span class=\"math inline\">\\(x\\)</span> except'e) soient 'etrangers\r\n`a <span class=\"math inline\">\\(F\\)</span>. Peut-on d'emontrer que\r\nl'ensemble <span class=\"math inline\">\\(A\\)</span> de tous les points\r\nlin'eairement accessibles de <span class=\"math inline\">\\(F\\)</span> est\r\ntoujours mesurable (<span class=\"math inline\">\\(L\\)</span>)?</li>\r\n</ol>\r\n<p>Probl'eme de M. Urysohn.</p>\r\n<ol start=\"30\" type=\"1\">\r\n<li><span class=\"math inline\">\\(f(x)\\)</span> 'etant une fonction\r\ndonn'ee quelconque (mesurable ou non), quelle est la mesure de\r\nl'ensomble de tous les points <span class=\"math inline\">\\(x\\)</span>,\r\ntels que</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\lim\\limits_{h\\to 0} \\left|\\frac{f(x+h)\r\n- f(x)}{h}\\right| = \\infty\\]</span></p>\r\n<p>Probl'eme de M. Ruziewicz.</p>\r\n<ol start=\"31\" type=\"1\">\r\n<li>Le th'eor'eme: \"<span class=\"math inline\">\\(\\mathsf{m} = 2\\cdot\r\n\\mathsf{m}\\)</span> quel soit le nombre cardinal <em>transfini</em>\r\n<span class=\"math inline\">\\(\\mathsf{m}\\)</span>\" est il 'equivalent `a\r\n<em>l'axiome du choix</em>?</li>\r\n</ol>\r\n<p>Cf. ma Note \"<em>Sur quelques th'eor'emes qui 'equivalent `a l'axiome\r\ndu choix</em>\" dans ce volume, p. 147.</p>\r\n<p>Probl'eme de M. Tajtelbaum-Tarski.</p>\r\n<ol start=\"32\" type=\"1\">\r\n<li>Un ensemble plan ferm'e, don tout point est lin'eairement\r\naccessible, est-il n'ecessairement de mesure superficielle nulle?</li>\r\n</ol>\r\n<p>Probl'eme de M. Banach.</p>\r\n<p>Un point <span class=\"math inline\">\\(x\\)</span> de <span class=\"math inline\">\\(F\\)</span> est dit lin'eairement accessible s'il\r\nexiste un segment rectiligne <span class=\"math inline\">\\(\\overline{xp}\\)</span> tel que tous ses points (le\r\npoint <span class=\"math inline\">\\(x\\)</span> excepr'e) soient 'etrangers\r\n`a <span class=\"math inline\">\\(F\\)</span>. M. Urysohn a d'emontr'e que\r\nl'ensemble de tous les points lin'eairement accessibles d'un ensemble\r\nplan ferm'e est toujouts un ensemble (<span class=\"math inline\">\\(A\\)</span>) de M. Souslin, mais peut ne pas ^etre\r\nmesurable (<span class=\"math inline\">\\(B\\)</span>). Or on ne sait pas si\r\nl'ensemble de tous les points lin'eairement accessibles d'un ensemble\r\nplan <span class=\"math inline\">\\(G_{\\delta}\\)</span> est mesurable\r\n(<span class=\"math inline\">\\(L\\)</span>) (Cf. Probl'eme 29, <em>Fund.\r\nMath.</em> t. V, p. 337).</p>\r\n<ol start=\"33\" type=\"1\">\r\n<li>Une image biunivoque et continue (dans un sens) d'un ensemble\r\ncompl'emeutaire `a un ensemble (<span class=\"math inline\">\\(A\\)</span>)\r\nde M. Souslin, est elle de m^eme nature?</li>\r\n</ol>\r\n<p>Probl'eme de Sierpi'nski.</p>\r\n<ol start=\"34\" type=\"1\">\r\n<li>Appelons un ensemble (lin`eaire) mesurable (<span class=\"math inline\">\\(B\\)</span>) de classe <span class=\"math inline\">\\(\\alpha\\)</span> <em>irr'eductible</em> s'il n'est\r\nde classe <span class=\"math inline\">\\(&lt;\\alpha\\)</span> dans aucun\r\nintervalle. Quelle est la puissance de l'ensemble de tous les types\r\ntopologiques d'ensumbles irr'eductibles de classe <span class=\"math inline\">\\(\\alpha\\)</span>?</li>\r\n</ol>\r\n<p>Appelons un ensemble (<span class=\"math inline\">\\(A\\)</span>)\r\nirr'eductible, s'il n'est mesurable (<span class=\"math inline\">\\(B\\)</span>) dans aucun intervalle. Quelle est la\r\npuissance de tous les types topologiques des ensembles (<span class=\"math inline\">\\(A\\)</span>) irr'eductibles?</p>\r\n<p>Probl'eme de MM. Alexandroff et Urysohn.</p>\r\n<ol start=\"35\" type=\"1\">\r\n<li>Appelons l'ensemble (lin'eaire) <span class=\"math inline\">\\(E\\)</span> <em>parfaitement mesurable au sens\r\n'etroit</em>, si toute image univoque et continue de <span class=\"math inline\">\\(E\\)</span> est mesurable au sens de Lebsgue. Un\r\nensemble compl'ementaire `a un ensemble parfaitement mesurable au sens\r\n'etroit, est-il toujours de m^eme nature?</li>\r\n</ol>\r\n<p>Cf. Probl'eme 22 de P. Urysohn (<em>Fund. Math.</em> t. IV, p. 368),\r\nr'esolu par M. Lavrentieff (<em>Fund. Math.</em> t. VI, p. 159).</p>\r\n<p>Probl'eme de M. O. Nikodym.</p>\r\n<ol start=\"36\" type=\"1\">\r\n<li>D'apr'es M. Souslin, si <span class=\"math inline\">\\(E\\)</span> est\r\nun ensemble (<span class=\"math inline\">\\(A\\)</span>) et <span class=\"math inline\">\\(H\\)</span> un ensemble compl'ementaire `a un\r\nensemble (<span class=\"math inline\">\\(A\\)</span>), et si <span class=\"math inline\">\\(E \\subset H\\)</span>, il existe un ensemble <span class=\"math inline\">\\(Q\\)</span>, mesurable (<span class=\"math inline\">\\(B\\)</span>), tel que <span class=\"math inline\">\\(E\\subset Q \\subset H\\)</span>[^3]. Cette\r\nproposition, admet-elle une r'eciproque, c'est-`a-dire, <em><span class=\"math inline\">\\(E\\)</span> 'etant un ensemble compl'ementaire `a\r\nun ensemble (<span class=\"math inline\">\\(A\\)</span>) et <span class=\"math inline\">\\(H\\)</span> ------ un ensemble (<span class=\"math inline\">\\(A\\)</span>), tel que <span class=\"math inline\">\\(E\r\n\\subset H\\)</span>, existe-til tujours un ensemble <span class=\"math inline\">\\(Q\\)</span> mesurable (<span class=\"math inline\">\\(B\\)</span>), tel que <span class=\"math inline\">\\(E\r\n\\subset Q \\subset H\\)</span>?</em></li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpi'nski.</p>\r\n<p>[^3] Voir p. e. N. Lusin et W. Sierpi'nski <em>Journ. de Math.</em>\r\nt. II (1923) p. 60; aussi <em>Bull. Acad. Cracovie</em> 1918 p. 40.</p>\r\n<ol start=\"37\" type=\"1\">\r\n<li>Un continu de Jordan (born'e) qui ne renferme qucune courbe simple\r\nferm'ee est-il hom'eomorphe `a un de ses (vrais) sous-continus?</li>\r\n</ol>\r\n<p>Probl'eme de M. Zarankiewicz.</p>\r\n<ol start=\"38\" type=\"1\">\r\n<li>Un carr'e et un cercle dont les aires sont 'egales peuvent-ils ^etre\r\nd'ecompos'es en un nombre fini de sous-ensembles disjoints repectivement\r\ncongruents?</li>\r\n</ol>\r\n<p>Probl'eme de M. Tarski.</p>\r\n<ol start=\"39\" type=\"1\">\r\n<li>Existe-il un ensemble ferm'e <em>plan</em> pour lequel l'ensemble\r\ndes points lin'eairement accessibles soit non-mesurable (<span class=\"math inline\">\\(B\\)</span>)? (Dans l'espace le probl'eme est\r\nr'esolu par affirmative).</li>\r\n</ol>\r\n<p>Probl'eme de M. O. Nikodym.</p>\r\n<ol start=\"40\" type=\"1\">\r\n<li><span class=\"math inline\">\\(E\\)</span> 'etant un ensemble plan <span class=\"math inline\">\\(G_{\\delta}\\)</span>, l'ensemble de tous les\r\nnombres r'eels <span class=\"math inline\">\\(a\\)</span>, tels que la\r\ndroite <span class=\"math inline\">\\(x =a\\)</span> rencontre l'ensemble\r\n<span class=\"math inline\">\\(E\\)</span> dans un et un seul point, est-il\r\nn'ecessairement compl'ementaire d'un ensemble (<span class=\"math inline\">\\(A\\)</span>) de M. Souslin?</li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpi'nski.</p>\r\n<ol start=\"41\" type=\"1\">\r\n<li><span class=\"math inline\">\\(E_{1}, E_{2}, E_{3}, \\dots\\)</span>\r\n'etant une suite d'enombrable d'ensembles lin'eaires dont chacun est une\r\nprojection d'un ensemble plan compl'ementaire `a un ensemble (<span class=\"math inline\">\\(A\\)</span>) de M. Souslin, l'ensemble $E_{1}E_{2}\r\nE_{3} $ est il de m^eme nature?</li>\r\n</ol>\r\n<p>Probl'eme de M. Sierpi'nski.</p>\r\n<ol start=\"42\" type=\"1\">\r\n<li>Existe-t-il dans tout continu <span class=\"math inline\">\\(A\\)</span>\r\nun continu <span class=\"math inline\">\\(B\\)</span> tel que l'ensemble\r\n<span class=\"math inline\">\\(A-B\\)</span> soit connexe?</li>\r\n</ol>\r\n<p>Probl'eme de MM. Knaster et Zarankiewicz.</p>\r\n<ol start=\"43\" type=\"1\">\r\n<li><span class=\"math inline\">\\(D\\)</span> d'esignant un ensemble ferm'e\r\nhom'eomorphe d'un ensemble plan et situ'e dans l'espace euclidien `a 3\r\ndimensions, est-ce que tout point de <span class=\"math inline\">\\(D\\)</span> est <em>accessible</em> dans cet\r\nespace?</li>\r\n</ol>\r\n<p>(Un point <span class=\"math inline\">\\(d\\)</span> de <span class=\"math inline\">\\(D\\)</span> est dit <em>accessible</em> dans <span class=\"math inline\">\\(E\\)</span>, lorsqu'il existe un continu <span class=\"math inline\">\\(C \\subset E\\)</span> tel que <span class=\"math inline\">\\((d) = CD\\)</span>).</p>\r\n<p>Probl'eme de M. Knaster.</p>\r\n<ol start=\"46\" type=\"1\">\r\n<li>Es wird gefragt die logischen Relationen zwischen den verschiedenen\r\nHomogenit\"atsbegriffen aufzutellen, insoweit sie sich beziehen auf im\r\nkleinen kompakten Mengen. Insbesondere auch wenn die Mengen als\r\nausammenh\"angend und (oder) im kleinen zusammenh\"angend vorausgesetzt\r\nwerden.</li>\r\n</ol>\r\n<p>(Vgl. D. van Dantzig, \"ber topologisch homogene Kontinua, dieser\r\nBand, S. 102, 103).</p>\r\n<p>Probl'eme de M. van Dantzig.</p>\r\n<ol start=\"47\" type=\"1\">\r\n<li>Ist eine jed (zusammenh\"angende, unberandete) <span class=\"math inline\">\\(n\\)</span>-dimensionale Mannigfaltigkeit\r\ninvolutorisch homogen?</li>\r\n</ol>\r\n<p>(Vgl. D. van Dantzig, l. e. S. 104, ^7.)</p>\r\n<p>Probl'eme de M. van Dantzig.</p>\r\n<ol start=\"48\" type=\"1\">\r\n<li>Nennen wir eine topologische Gruppe <em>monothetisch</em>, falls\r\neine unendliche zyklische Gruppe in ihr dicht liegt (in welchem Falle\r\nsie kommutativ ist und additiv geschrieben weden kann), und\r\n<em>komplett</em>, falls eine jede Folge <span class=\"math inline\">\\(x_{\\nu}\\)</span>, die dem Konvergenzkriterium\r\nCauchy's <span class=\"math inline\">\\(\\lim (x_{\\nu} - x_{\\mu} =\r\n0\\)</span> gen\"ugt, ein Limeselement in der Gruppe besitzt, so wird\r\ngefragt, ob eine monothetische Gruppe komplett sein kann ohne kompakt zu\r\nsein.</li>\r\n</ol>\r\n<p>(Vgl. l. c. S. 116 ^{29}a))</p>\r\n<p>Probl'eme de M. van Dantzig.</p>\r\n<ol start=\"49\" type=\"1\">\r\n<li>Soient <span class=\"math inline\">\\(X\\)</span> et <span class=\"math inline\">\\(Y\\)</span> deux continus P'eaniens (= images\r\ncontinues de l'intervalle) et <span class=\"math inline\">\\(Z\\)</span>\r\nleur produit topologique (= l'espace de tous les couples <span class=\"math inline\">\\(z = (x,y)\\)</span> o'u <span class=\"math inline\">\\(\\lim z_{n}=z\\)</span> lorsque <span class=\"math inline\">\\(\\lim x_{n} = x\\)</span> et <span class=\"math inline\">\\(\\lim y_{n} = y\\)</span>).</li>\r\n</ol>\r\n<p>1^0. Si le continu <span class=\"math inline\">\\(X\\)</span>, ainsi que\r\n<span class=\"math inline\">\\(Y\\)</span>, poss'ede la propri'et'e que dans\r\nchaque transformation continue de ce continu en un sous-ensemble il\r\nexiste un point invariant, est-il vrai que <span class=\"math inline\">\\(Z\\)</span> poss'ede la m^eme propri'et'e?</p>\r\n<p>2^0. Si le continu <span class=\"math inline\">\\(X\\)</span>, ainsi que\r\n<span class=\"math inline\">\\(Y\\)</span>, est uni-coh'erent (= dans chaque\r\nd'ecomposition de ce continu en deus sous-continus la partie commune de\r\nces sous-continus est connexe), est-il vrai que <span class=\"math inline\">\\(Z\\)</span> est unicoh'erent?</p>\r\n<p>Probl'eme de M. Kuratowski.</p>\r\n<ol start=\"50\" type=\"1\">\r\n<li>Ist der topologische Kreis die einzige homogene im kleinen\r\nzusammenh\"angende Kurve? (Kurve = eindimensionaler zusammen-h\"angender\r\nkompakter Raum. Homogen hei<span class=\"math inline\">\\(\\beta\\)</span>t\r\nein Raum, der zu je zwei seiner Punkte <span class=\"math inline\">\\(p\\)</span> und <span class=\"math inline\">\\(q\\)</span> eine topologische Selbstabbildung\r\nbesitzt die <span class=\"math inline\">\\(p\\)</span> in <span class=\"math inline\">\\(q\\)</span> \"uberf\"uhrt). In der Ebene ist der\r\nKreis die einzige homogene im kleinen zusammenh\"angende Kurve.</li>\r\n</ol>\r\n<p>(Vgl. Mazurkiewicz, Fund. Math. V, S. 137).</p>\r\n<p>Probl'eme de M. K. Menger.</p>\r\n<ol start=\"51\" type=\"1\">\r\n<li>Gibt es beliebig oder gar unendlich viele kompakte eindimensionale\r\nR\"aume, die zu je zweien eindimentional unvergleichbar sind? Dabei\r\nm\"ogen zwei R\"aume <span class=\"math inline\">\\(R\\)</span> und <span class=\"math inline\">\\(R^{\\prime}\\)</span> eindimentional unvergleichbar\r\nhei<span class=\"math inline\">\\(\\beta\\)</span>en, wenn keine\r\neindimensionale Teilmenge von <span class=\"math inline\">\\(R\\)</span>,\r\n(bzw. von <span class=\"math inline\">\\(R^{\\prime}\\)</span>) hom\"oomorph\r\nist mit einer Teilmenge von <span class=\"math inline\">\\(R^{\\prime}\\)</span> (bzw. von <span class=\"math inline\">\\(R^{\\prime}\\)</span>). Beispielsweise sind\r\neindimensional unvergleichbar eine Strecke und ein Kontinuum ohne\r\nTeilbogen. (Wenn es <span class=\"math inline\">\\(n\\)</span>, bzw. <span class=\"math inline\">\\(\\aleph_{0}\\)</span> paarweise eindimensional\r\nunvergleichbare Kurven gibt, so existieren kompakte eindimensionale\r\nR\"aume, welche mindestens <span class=\"math inline\">\\(2^{n} +1\\)</span>,\r\nbze. <span class=\"math inline\">\\(2^{\\aleph_{0}}\\)</span> monotone, <span class=\"math inline\">\\(F_{\\sigma}\\)</span>-additive, toppologische,\r\nkompaktifizierbare Systeme von Teilmengen enthalten).</li>\r\n</ol>\r\n<p>(Vgl. Monatshefte f. Math. u. Phys. 36, S. 207).</p>\r\n<p>Probl'eme de M. K. Menger.</p>\r\n<ol start=\"52\" type=\"1\">\r\n<li>Existe-il un continu dont tout autre continu soit une image\r\ncontinue?</li>\r\n</ol>\r\n<p>Probl'eme de M. H. Hahn.</p>\r\n<ol start=\"53\" type=\"1\">\r\n<li><ol type=\"a\">\r\n<li>Ist jeder absolute Retrakt in endlich viele absolute Retrakte mit\r\nbeliebig kleinen Durchmessern zerlegbar?</li>\r\n</ol></li>\r\n</ol>\r\n<ol start=\"2\" type=\"a\">\r\n<li>Lasst sieh jede <span class=\"math inline\">\\(R\\)</span>-Menge in\r\nendlich viele absolu#e Retrakte zerlegen?</li>\r\n</ol>\r\n<p>(Die Definition von absoluten Retrakten und von <span class=\"math inline\">\\(R\\)</span>-Mengen ist z. B. in meiner Note aus\r\nFund. Math. XIX, S. 222 angegeben).</p>\r\n<ol start=\"54\" type=\"1\">\r\n<li><p>Ist jedes Teilkontinuum <span class=\"math inline\">\\(C\\)</span>\r\ndes eaklidieelien <span class=\"math inline\">\\(n\\)</span>-dimensionalen\r\nRaumes <span class=\"math inline\">\\(R_{n}\\)</span>, welches <span class=\"math inline\">\\(R_{n}\\)</span> zerschneidet und welches eich durch\r\nbeliebig kleine Transformationen (d. h. durch eine stetige Abbildung,\r\nwelehe jeden Punkt von <span class=\"math inline\">\\(C\\)</span> in einen\r\nbeliebig nahe liegenden Punkt von <span class=\"math inline\">\\(R_{n}\\)</span> tiberfiibrt) in eine mit ihm\r\npunktfremde Teilmenge von R. \"uberf\"uhren lasst, eine (<span class=\"math inline\">\\(n-1\\)</span>)-dimensionale\r\nMannigfaltigkeit?</p></li>\r\n<li><p>L\"asst sich jedes in <span class=\"math inline\">\\(R_{3}\\)</span>\r\nliegende und <span class=\"math inline\">\\(R_{3}\\)</span> zerschneidende\r\nStreckenbild in eich stetig und fixpunktfrei abbilden?</p></li>\r\n</ol>\r\n<p>Probl'emes de M. K. Borsuk.</p>\r\n<ol start=\"56\" type=\"1\">\r\n<li>Soient <span class=\"math inline\">\\(A\\)</span> et <span class=\"math inline\">\\(B\\)</span> deux espaces topologiques et <span class=\"math inline\">\\(A^{2}\\)</span> et <span class=\"math inline\">\\(B^{2}\\)</span> respectivement leur carr'es (a. `a.\r\nd. <span class=\"math inline\">\\(A^{2}\\)</span> p. ex. se compose de tous\r\ntes couples (<span class=\"math inline\">\\(a_{1}\\)</span>, <span class=\"math inline\">\\(a_{2}\\)</span>) extraite de <span class=\"math inline\">\\(A\\)</span>).</li>\r\n</ol>\r\n<p>Est-il vrai que si <span class=\"math inline\">\\(A^{2}\\)</span> et\r\n<span class=\"math inline\">\\(B^{2}\\)</span> sont hom'eomorphes. <span class=\"math inline\">\\(A\\)</span> et <span class=\"math inline\">\\(B\\)</span> le sont aussi?</p>\r\n<p>En ess de relronae positire, on en d'eduit que, <span class=\"math inline\">\\(C\\)</span> 'etant un ensemble qui n'est\r\nhom'eomorphe `a aucun, <span class=\"math inline\">\\(C^{n}\\)</span>, <span class=\"math inline\">\\(n&gt;1\\)</span>, les ensembles <span class=\"math inline\">\\(C^{m}\\)</span> et <span class=\"math inline\">\\(C^{n}\\)</span> ne sont non plus hom'eomorphes pour\r\n<span class=\"math inline\">\\(m\\neq n\\)</span>; cela fournit dans le eas\r\no`u <span class=\"math inline\">\\(C\\)</span> est un intervalle 1e\r\nth'eor'eme de \"l'invariance de la dimension\" de M. Brouwer.</p>\r\n<p>Probl'eme de M. S. Ulam.</p>\r\n<ol start=\"57\" type=\"1\">\r\n<li>Existe-il un continu de dimension infinie qui n'en contient aucun de\r\ndimension finie?</li>\r\n</ol>\r\n<p>Probl'eme de M. S. Mazurkiewicz.</p>\r\n<ol start=\"58\" type=\"1\">\r\n<li>Gibt es in einer Menge <span class=\"math inline\">\\(E\\)</span> von\r\nder M\"achtigkeit <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ein\r\nabz\"ahlbares System von Teilmengen <span class=\"math inline\">\\(A_{1},\r\nA_{2},\\dots\\)</span> derart, dass man in der Gestalt <span class=\"math display\">\\[X = \\overline{\\lim} A_{p_{n}}\\]</span> (<span class=\"math inline\">\\(p_{1}, p_{2},,\\dots\\)</span> Teilfolge der\r\nnat\"urlichen Zahlen, <span class=\"math inline\">\\(\\overline{\\lim}\\)</span> bedeutet dag Barel-sche\r\n<em>ensemble limite complet</em>) alle Teilmengen <span class=\"math inline\">\\(X\\)</span> von <span class=\"math inline\">\\(E\\)</span> erh\"alt?</li>\r\n</ol>\r\n<p>(Es handelt sich, die Verneinung ohne Benutzung der\r\nKontinuumhypethese zu beweisen).</p>\r\n<p>Probl'me de M. F. Hausdorff.</p>\r\n<ol start=\"59\" type=\"1\">\r\n<li>Une fonction jouissant de la propri'et'e de Baire (c'est-`a-dire\r\ncontinue sur tout ensemble parfait, lorsqu'on n'eglige un ensemble de\r\n<span class=\"math inline\">\\(1^{re}\\)</span> cat'egorie relativement `a\r\ncet ensemble) d'une fonction jouiseant de la propri'et'e de Baire,\r\nest-elle de la m^eme nature?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpi'nski.</p>\r\n<ol start=\"60\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(\\rho\\)</span> l'ensemble de toutes\r\nles transformations hom'eomorphes du plan cart'esien en lui-m^eme, de la\r\nforme: <span class=\"math display\">\\[x^{\\prime} = x, \\quad y^{\\prime}\r\n=f(x,y)\\]</span> et <span class=\"math display\">\\[x^{\\prime}=g(x,y),\r\n\\quad  y^{\\prime}=y.\\]</span></li>\r\n</ol>\r\n<p>D'esignons par <span class=\"math inline\">\\(\\sigma\\)</span> le groupe\r\nform'e par toutes les superpositions finies de toutes les\r\ntransformations appartenant `a <span class=\"math inline\">\\(\\rho\\)</span>. Une transformation hom'eomorphe\r\narbitraire du plan en lui-m^eme se laisse-telle toujours approcher par\r\ncelles du groupe <span class=\"math inline\">\\(\\sigma\\)</span>?</p>\r\n<p>Un probl'eme analogue subsiste pour les espaces `a <span class=\"math inline\">\\(n&gt;2\\)</span> dimensions. Probl'eme de M. S.\r\nUlam.</p>\r\n<ol start=\"61\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(E\\)</span> un ensemble plan <span class=\"math inline\">\\(G_{\\delta}\\)</span> (plus g'en'eralement: un\r\nensemble borelien) dont tontes les intersections avec les droites\r\nparall'eles `a l'axe des <span class=\"math inline\">\\(y\\)</span> sont des\r\nensembles ferm'es (plus g'en'eralement: des <span class=\"math inline\">\\(F_{\\sigma}\\)</span>). La projection de <span class=\"math inline\">\\(E\\)</span> sur l'axe des <span class=\"math inline\">\\(x\\)</span> est-elle toujours un ensemble\r\nborelien?</li>\r\n</ol>\r\n<p>Probl'eme de M. E. Szpilrajsn.</p>\r\n<ol start=\"62\" type=\"1\">\r\n<li>Die (reelle) Funktion <span class=\"math inline\">\\(f(x)\\)</span> der\r\nreellen Variablen <span class=\"math inline\">\\(x\\)</span> heisse\r\n<em>symmetrisch-stetig</em> wenn f\"ur jedes <span class=\"math inline\">\\(x\\)</span> <span class=\"math display\">\\[\\lim\\limits_{h \\to 0} [f(x+h) - f(x - h)] =\r\nO.\\]</span> Kann die Menge der Unstetigkeitsstellen einer solchen\r\nFunktion unabz\"ahlbar sein? Kann sie eine beliebig vorgeschriebene Menge\r\n<span class=\"math inline\">\\(F_{\\sigma}\\)</span> sei? (Dass sie eine\r\nbeliebig vorgeschriebene abz\"ahlbare Menge sein kann, ist leicht\r\neinzusehen.)</li>\r\n</ol>\r\n<p>Probl'eme de M. F. Hausdorff.</p>\r\n<ol start=\"63\" type=\"1\">\r\n<li>Deux espaces compacts <span class=\"math inline\">\\(A\\)</span> et\r\n<span class=\"math inline\">\\(B\\)</span> ont le <em>m^eme type\r\nd'homotopie</em>, lorsqu'il existe une transformation continue <span class=\"math inline\">\\(f\\)</span> de <span class=\"math inline\">\\(A\\)</span> en <span class=\"math inline\">\\(B\\)</span> et une transformation continue <span class=\"math inline\">\\(f\\)</span> de <span class=\"math inline\">\\(A\\)</span> en <span class=\"math inline\">\\(B\\)</span> et une transformation continue <span class=\"math inline\">\\(\\varphi\\)</span> de <span class=\"math inline\">\\(B\\)</span> en <span class=\"math inline\">\\(A\\)</span>, telles que les transformations\r\nsuperpos'ees <span class=\"math inline\">\\(\\varphi f\\)</span> et <span class=\"math inline\">\\(f\\varphi\\)</span> (consid'er'ees respectivement\r\ncomme des trans-formations de <span class=\"math inline\">\\(A\\)</span> en\r\n<span class=\"math inline\">\\(A\\)</span> et de <span class=\"math inline\">\\(B\\)</span> en <span class=\"math inline\">\\(B\\)</span>) soient homotopes `a l'identit'e. Deux\r\nvari'et'es ferm'ees de m^eme type d'homotopie sont-elles toujours\r\nhom'eomorphes?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Hurewicz.</p>\r\n<ol start=\"64\" type=\"1\">\r\n<li><p>Gibt es im <span class=\"math inline\">\\(R^{n}\\)</span> zwei\r\norientierbare Mannigfaltigkeiten <span class=\"math inline\">\\(M_{1}^{k}\\)</span> und <span class=\"math inline\">\\(M_{2}^{k}\\)</span>, deren Komplement\"arr\"aume\r\n<span class=\"math inline\">\\(R^{n} - M_{1}^{k}\\)</span> und <span class=\"math inline\">\\(R^{n} - M_{2}^{k}\\)</span> hom\"oomorph und deren\r\nHomologieringe nicht isomorph sind?</p></li>\r\n<li><p>Soient <span class=\"math inline\">\\(B_{0}, B_{1}, B_{2}, \\dots,\r\nB_{\\omega}, \\dots, B_{\\alpha}, \\dots\\)</span> des classes boreliennes\r\nd'ensembles, form'ees en partant d'une classe quelconque d'ensembles\r\nabstraits. On sait que <span class=\"math inline\">\\(B_{\\alpha} =\r\nB_{\\alpha+}\\)</span>. entra^ine <span class=\"math inline\">\\(B_{\\alpha}=\r\nB_{\\beta}\\)</span> pour tout <span class=\"math inline\">\\(\\beta&gt;\\alpha\\)</span>; soit <span class=\"math inline\">\\(\\alpha_{0}\\)</span> le premier nombre <span class=\"math inline\">\\(\\alpha\\)</span> satisfaisant `a cette condition.\r\nQuels sont les nombres <span class=\"math inline\">\\(\\nu\\)</span> pour\r\nlesquels il existe des classes <span class=\"math inline\">\\(B_{0}\\)</span> telles que l'on ait <span class=\"math inline\">\\(\\alpha_{0} = \\nu\\)</span>? (Cf. Fund. Math. t. XV,\r\np. 284).</p></li>\r\n</ol>\r\n<p>Probl'emes de M. A. Ko1mogoroff.</p>\r\n<ol start=\"66\" type=\"1\">\r\n<li>La propri'et'e <span class=\"math inline\">\\(LC\\)</span>\r\n<em>faible</em> entra^ine-t-elle la propri'et'e <span class=\"math inline\">\\(LC\\)</span> forte pour tout espace m'etrique\r\ncompact? M^eme question pour les pro-pri'et'es <span class=\"math inline\">\\(HLC\\)</span>. (Pour les d'efinitions voir Anaals\r\nof Mathematics, vol. 85, p. 119-129 et Duke Mathematical Journal, vol.\r\n1, p. 1-18).</li>\r\n</ol>\r\n<p>Probl'eme de M. S. Lefschetz.</p>\r\n<ol start=\"67\" type=\"1\">\r\n<li>La propri'et'e (<span class=\"math inline\">\\(C\\)</span>) des\r\nensembles lin'eaires est elle invariante par rapport aux transformations\r\nhom'eomorphes et, plus g'en'erale-ment, par rapport aux transformations\r\ncontinues? (On dit qu'un ensemble <span class=\"math inline\">\\(E\\)</span>\r\nposs'ede la <em>propri'et'e</em> (<span class=\"math inline\">\\(C\\)</span>), lorsqu'il existe pour chaque suite\r\n<span class=\"math inline\">\\(\\{a_{n}\\}\\)</span> de nombres positifs une\r\nd'ecomposition $E=E_{1}+E_{2} + $ telle que le diam'etre de <span class=\"math inline\">\\(E_{n}\\)</span> ne d'epasse pas <span class=\"math inline\">\\(a_{n}\\)</span> pour <span class=\"math inline\">\\(n=1, 2,\\dots\\)</span>. Cf. Fund. Math, t. XI, p.\r\n304; t. XV, p. 126; t. XXII, p. 310.)</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpi'nski.</p>\r\n<ol start=\"68\" type=\"1\">\r\n<li>Tai et <span class=\"math inline\">\\(E_{1}\\)</span> 'etant deux\r\nensembles lin'eaires toujours de premi'ere cat'egorie (c. `a d. de\r\npremi'ere cat'egorie sur tout ensemble parfait), l'ensemble <span class=\"math inline\">\\(E_{1} \\times E_{2}\\)</span>. (c. `a d. l'ensemble\r\nde tous les points <span class=\"math inline\">\\((x, y)\\)</span> du plan\r\no'u <span class=\"math inline\">\\(x \\in E_{1}\\)</span> et <span class=\"math inline\">\\(y \\in E_{2}\\)</span>) est-il de m^eme nature?</li>\r\n</ol>\r\n<p>Probl'eme de M. E. Szpilrajn.</p>\r\n<ol start=\"69\" type=\"1\">\r\n<li>Lorsqu'une conrbe de Jordan (dans un espace `a trois dimensions)\r\nposs'ede en chaque point une tangente d'etermin'ee, existe-t-il\r\nn'ecessairement une reprparam'etrique de cette courbe exprimant les\r\ncoordonn'ees cart'esiennes d'un point de cette courbe comme fonctions\r\nd'erivables d'un param'etre (et cela sans que les trois d'erive'ees\r\ns'annulent en m^eme temps)?</li>\r\n</ol>\r\n<p>En cas de r'epinse n'egative, la question est repos'ee en admenttant\r\nun ensemble de mesure nulle de valeues du param'etre o'u les conditions\r\nimpos'ees ne sont pas toutes deux v'erifi'ees.</p>\r\n<p>Probl'eme de M. M. Fr'echet.</p>\r\n<ol start=\"70\" type=\"1\">\r\n<li>Existe-t-il un ensemble lin'eaire <span class=\"math inline\">\\(E\\)</span> tel que chaque ensemmble analytique\r\nlin'eaire est une image biunivoque et continue (dans un sens) de <span class=\"math inline\">\\(E\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. W. Sierpi'nski.</p>\r\n<ol start=\"71\" type=\"1\">\r\n<li>Existe-t-il une suite infinie <span class=\"math inline\">\\(S\\)</span>\r\nde fonctions d'une variable r'eelle (mesurables ou non), telle que toute\r\nfonction d'une variable r'eelle dde classe <span class=\"math inline\">\\(2\\)</span> Baire soit limite d'une suit extraite\r\nde <span class=\"math inline\">\\(S\\)</span>?</li>\r\n</ol>\r\n<p>(D'apr'es M. C. Burstin une telle suite <span class=\"math inline\">\\(S\\)</span> ne peut ^etre compos'ee uniquement de\r\nfonctions mesurables[^4])</p>\r\n<p>Probl'eme de M. W. Sierpi'nski.</p>\r\n<p>[^4] Monatshefte f. Math. u. Phys. 28 (1917), p. 107.</p>\r\n<ol start=\"72\" type=\"1\">\r\n<li>Existe-t-il dans l'espace cart'esien `a <span class=\"math inline\">\\(n\\)</span> dimensions (<span class=\"math inline\">\\(n&gt;1\\)</span>) un ensemble toujours de premi'ere\r\ncat'egorie (c. `a d. de premi'ere cat'egorie sur chaque ensemble\r\nparfait) et qui soit de dimension positive?</li>\r\n</ol>\r\n<p>(M. W. Hurewicz a d'emontr'e `a l'aide de l'hypoth'ese du continu\r\nqu'il existe dans l'espace de Hilbert un ensemble ind'enombrable <span class=\"math inline\">\\(H\\)</span> dont chaque sous-ensemble\r\nind'enombrable est de dimension infinie[^5]). M. F. Hausdorff a\r\nremarqu'e l'ensemble <span class=\"math inline\">\\(H\\)</span> est toujours\r\nde premi'ere cat'egorie. Cela r'esulte ais'ement du fait que chaque\r\nespace m'etrique s'eparable <span class=\"math inline\">\\(M\\)</span> est\r\nsomme d'un ensemble de dimension <span class=\"math inline\">\\(0\\)</span>\r\net d'un ensemble de premi'ere cat'egorie dans <span class=\"math inline\">\\(M\\)</span>. -- <em>Il existe donc, so <span class=\"math inline\">\\(2^{\\aleph} = \\aleph_{1}\\)</span>, dons l'espace de\r\nHilbert un ensemble toujours de premi'erie cat'egorie et de dimension\r\npositive</em>).</p>\r\n<p>Probl'eme de M. E. Szpilrajn.</p>\r\n<p>[^5] Fund. Math. 19 (1932), p.8.</p>\r\n<ol start=\"73\" type=\"1\">\r\n<li>Soient, dans l'espace euclidien `a trois dimensions, <span class=\"math inline\">\\(E\\)</span> une image hom'eomorphe de la sph'ere\r\nsolide <span class=\"math inline\">\\(S\\)</span> et <span class=\"math inline\">\\(L\\)</span> un segment rectiligne dont l'int'erieur\r\nest contenu dans l'int'erieur, et les extr'emeit'es dans la fronti'ere\r\nde <span class=\"math inline\">\\(E\\)</span>. Existe-t-il toujours une\r\nhom'eomorphie transformant <span class=\"math inline\">\\(E\\)</span> en\r\n<span class=\"math inline\">\\(S\\)</span> de facon que <span class=\"math inline\">\\(L\\)</span> soit transorm'e en diam'etre de <span class=\"math inline\">\\(S\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. K. Borsuk.</p>\r\n<ol start=\"74\" type=\"1\">\r\n<li>Soit <span class=\"math inline\">\\(\\mathbf{B}(\\mathbf{F})\\)</span> la\r\nplus petite famille d'ensembles contenant la famille donn'ee <span class=\"math inline\">\\(\\mathbf{F}\\)</span> et close par rapoort aux\r\nop'erations <span class=\"math inline\">\\(\\sigma\\)</span> et <span class=\"math inline\">\\(\\delta\\)</span> (addition et multiplication\r\nd'enombrables). Existe-t-il une famille d'enombrable <span class=\"math inline\">\\(\\mathbf{D}\\)</span> d'ensembles, telle que tous\r\nles ensembles analytiques lin'eaires appartiennent `a <span class=\"math inline\">\\(\\mathbf{B}(\\mathbf{D})\\)</span>?</li>\r\n</ol>\r\n<p>Probl'eme de M. S. Ulam.</p>\r\n<ol start=\"75\" type=\"1\">\r\n<li>Existe-t-il un ensemble infini <span class=\"math inline\">\\(E\\)</span> (p.e. l'ensemble de tous les nombres\r\nnaturels) et une fonction <span class=\"math inline\">\\(f(X)\\)</span> qui\r\nfait correspondre `a tout sous-ensemble <span class=\"math inline\">\\(X\\)</span> de <span class=\"math inline\">\\(E\\)</span> un sous-ensemble <span class=\"math inline\">\\(f(X)\\)</span> de <span class=\"math inline\">\\(E\\)</span>, de sorte que:</li>\r\n</ol>\r\n<p>1<span class=\"math inline\">\\(^\\circ\\)</span> <span class=\"math inline\">\\(X \\subset f(X)\\)</span> pour <span class=\"math inline\">\\(X \\subset E\\)</span>, 2<span class=\"math inline\">\\(^\\circ\\)</span> <span class=\"math inline\">\\(f(X+Y)\r\n= f(X) + f(Y)\\)</span> pour <span class=\"math inline\">\\(X \\subset\r\nE\\)</span>, <span class=\"math inline\">\\(Y \\subset E\\)</span>, 3<span class=\"math inline\">\\(^\\circ\\)</span> il existe pour tout ensemble <span class=\"math inline\">\\(Y \\subset E\\)</span> au moins un ensemble <span class=\"math inline\">\\(X \\subset E\\)</span>, tel que <span class=\"math inline\">\\(Y = f(X)\\)</span>, 4<span class=\"math inline\">\\(^\\circ\\)</span> il existe au moins un ensemble\r\n<span class=\"math inline\">\\(X_{0} \\subset E\\)</span>, tel que <span class=\"math inline\">\\(f(X_{0}) \\neq X_{0}\\)</span>.</p>\r\n<p>Si l'on remplace la condition relative `a <span class=\"math inline\">\\(f(X+Y)\\)</span> par la condition plus faible que\r\n<span class=\"math inline\">\\(f(X) \\subset f(Y)\\)</span> pur <span class=\"math inline\">\\(X \\subset Y \\subset E\\)</span>, la r'eponse\r\npositive est 'evidente.</p>\r\n<p>Probl'eme de M. E. ech.</p>\r\n<h2 id=\"problemes-rsolus.\">Probl'emes r'solus.</h2>\r\n<p>Probl. 1) Lorsque un ensemble de points <span class=\"math inline\">\\(P\\)</span> est une image biunvoque et continue\r\n(dans un sens) de <span class=\"math inline\">\\(Q\\)</span> et <span class=\"math inline\">\\(Q\\)</span> est une image biunivoque et continue de\r\n<span class=\"math inline\">\\(P\\)</span>, peut-on affirmer que les\r\nensembles <span class=\"math inline\">\\(P\\)</span> et <span class=\"math inline\">\\(Q\\)</span> sont hom'eomorphes?</p>\r\n<p>Solution <em>n'egative</em> de M. Kuratowski, <em>Fund. Math.</em> t.\r\nII, pp. 158-160</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>Existe-il une d'ecomposition d'un intervalle en <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles mesurables (<span class=\"math inline\">\\(B\\)</span>), non-vides et sans points communs deux\r\n`a deux?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de MM. Lusin et Sierpinski, <em>Comptes\r\nRendus</em>, t. 175, p.357 (note du 21 ao^ut 1922).</p>\r\n<p>6, troisi'eme partie) Peut-on d'emontrer qu'un produit de <span class=\"math inline\">\\(\\aleph_{1}\\)</span> ensembles (<span class=\"math inline\">\\(A\\)</span>) n'est pas n'ecessairement un ensemble\r\n(<span class=\"math inline\">\\(A\\)</span>)?</p>\r\n<p>Solution <em>affirmative</em> de MM. Lusin et Sierpinski, <em>Journ,\r\nde Math</em>. 1923 (Les auteurs d'efinissent un ensemble qui est\r\ncompl'ementaire d'un ensemble (<span class=\"math inline\">\\(A\\)</span>)\r\nn'est pas n'ecessairement un ensemble (<span class=\"math inline\">\\(A\\)</span>))</p>\r\n<ol start=\"8\" type=\"1\">\r\n<li>Peut-on donner un exemple effectif d'un ensemble de nombres r'eels\r\n<span class=\"math inline\">\\(E\\)</span>, tel que toute somme, toute\r\ndiff'erence, tout produit et tout quotient de deux nombres de <span class=\"math inline\">\\(E\\)</span> (except'e la division par 0)\r\nappartienne `a <span class=\"math inline\">\\(E_{1}\\)</span> et que <span class=\"math inline\">\\(E\\)</span> soit non-d'enombrable, distinct de\r\nl'ensemble de tous les nombres r'eels?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de M. Souslin, <em>Fund. Math.</em> IV,\r\np.311.</p>\r\n<p>10, premi'ere partie) Existe-il une fonction de deuxi'eme classe qui\r\nne soit pas la limite de fonctions preque partout discontinues?</p>\r\n<p>Solution <em>affirmative</em> de M. Zalcwasser.</p>\r\n<ol start=\"12\" type=\"1\">\r\n<li>Un ensemble ordonn'e dont tous les sous-ensembles bien ordonn'es\r\n(croissants on d'ecroissants) sont au plus d'enombraibles, a-t-il\r\nn'ecessairement une puissance non sup'erieure `a celle du continu?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de M. Urysohn, <em>Fund. Math.</em> V\r\n(h paraitre).</p>\r\n<ol start=\"15\" type=\"1\">\r\n<li>Existe-il un continu dont tout sous-continu est\r\nind'ecomposable?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de M. Knaster, <em>Fund. Math.</em> III\r\npp. 247-286.</p>\r\n<ol start=\"16\" type=\"1\">\r\n<li>Existe-il continu qui est une somme de ses vrais sous-continues\r\nsatur'es disjoints?</li>\r\n</ol>\r\n<p>Solution <em>affirmative</em> de M. Knaster et Kuratowski, <em>Fund.\r\nMath.</em> V (`a paraitre).</p>\r\n"},{"title":"Dedekind Domain","date":"2023-04-01T16:00:45.000Z","_content":"","source":"_drafts/Dedekind Domain.md","raw":"---\ntitle: Dedekind Domain\ndate: 2023-04-02 00:00:45\ntags:\n---\n","slug":"Dedekind Domain","published":0,"updated":"2024-02-25T15:11:07.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5rt000bm8nxgpxf8a7k","content":"\r\n","site":{"data":{}},"excerpt":"","more":"\r\n"},{"title":"Divisor","date":"2023-03-27T10:42:10.000Z","_content":"","source":"_drafts/Divisor Theory.md","raw":"---\ntitle: Divisor\ndate: 2023-03-27 18:42:10\ntags: \n    - [Algebraic Geometry]\ncategories: \n    - [Algebraic Geometry]\n---\n","slug":"Divisor Theory","published":0,"updated":"2024-02-25T15:11:07.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5ru000gm8nx37fh750q","content":"\r\n","site":{"data":{}},"excerpt":"","more":"\r\n"},{"title":"Kronecker dream of youth","mathjax":true,"_content":"\nKronecker's Jugendtraum (or Hilbert's 12th problem) is to find abelian extensions of arbitrary number fields by adjoining `special' values of transcendental \nKronecker once proved that all the Galois extensions of the rationals $\\mathbb{Q}$ with Abelian Galois groups are subfields of cyclotomic fields $\\mathbb{Q}(\\mu_n)$, where $\\mu_n$ is the group of $n$-th roots of unity.\n\n\nKronecher wrote in a letter to Dedekind:\n\n*Es handelt sich um meinen liebsten Jugendtraum, n\\\"amlich um den Nachweis, dass die Abel'schen Gleichungen mit Quadratwurzeln rationaler Zahlen durch die Transformations-Gleichungen elliptischer Functionen mit singularen Moduln grade so ersch\\\"opft werden, wie die ganzzahligen Abel'schen Gleichungen durch die Kreisteilungsgleichungen.*\n\n","source":"_drafts/Kronecker-dream-of-youth.md","raw":"---\ntitle: Kronecker dream of youth\ntags:\n    - [Hilbert's 23 Problems, Algebraic Number Theory]\ncategories:\n    - [Hilbert's 12th Problem, Commutative Algebra, Algebraic Number Theory, Algebraic Geometry]\nmathjax: true\n---\n\nKronecker's Jugendtraum (or Hilbert's 12th problem) is to find abelian extensions of arbitrary number fields by adjoining `special' values of transcendental \nKronecker once proved that all the Galois extensions of the rationals $\\mathbb{Q}$ with Abelian Galois groups are subfields of cyclotomic fields $\\mathbb{Q}(\\mu_n)$, where $\\mu_n$ is the group of $n$-th roots of unity.\n\n\nKronecher wrote in a letter to Dedekind:\n\n*Es handelt sich um meinen liebsten Jugendtraum, n\\\"amlich um den Nachweis, dass die Abel'schen Gleichungen mit Quadratwurzeln rationaler Zahlen durch die Transformations-Gleichungen elliptischer Functionen mit singularen Moduln grade so ersch\\\"opft werden, wie die ganzzahligen Abel'schen Gleichungen durch die Kreisteilungsgleichungen.*\n\n","slug":"Kronecker-dream-of-youth","published":0,"date":"2024-02-25T15:11:07.048Z","updated":"2024-02-25T15:11:07.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5rv000im8nx7mwd9k08","content":"<p>Kronecker's Jugendtraum (or Hilbert's 12th problem) is to find\r\nabelian extensions of arbitrary number fields by adjoining `special'\r\nvalues of transcendental Kronecker once proved that all the Galois\r\nextensions of the rationals <span class=\"math inline\">\\(\\mathbb{Q}\\)</span> with Abelian Galois groups are\r\nsubfields of cyclotomic fields <span class=\"math inline\">\\(\\mathbb{Q}(\\mu_n)\\)</span>, where <span class=\"math inline\">\\(\\mu_n\\)</span> is the group of <span class=\"math inline\">\\(n\\)</span>-th roots of unity.</p>\r\n<p>Kronecher wrote in a letter to Dedekind:</p>\r\n<p><em>Es handelt sich um meinen liebsten Jugendtraum, n\"amlich um den\r\nNachweis, dass die Abel'schen Gleichungen mit Quadratwurzeln rationaler\r\nZahlen durch die Transformations-Gleichungen elliptischer Functionen mit\r\nsingularen Moduln grade so ersch\"opft werden, wie die ganzzahligen\r\nAbel'schen Gleichungen durch die Kreisteilungsgleichungen.</em></p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>Kronecker's Jugendtraum (or Hilbert's 12th problem) is to find\r\nabelian extensions of arbitrary number fields by adjoining `special'\r\nvalues of transcendental Kronecker once proved that all the Galois\r\nextensions of the rationals <span class=\"math inline\">\\(\\mathbb{Q}\\)</span> with Abelian Galois groups are\r\nsubfields of cyclotomic fields <span class=\"math inline\">\\(\\mathbb{Q}(\\mu_n)\\)</span>, where <span class=\"math inline\">\\(\\mu_n\\)</span> is the group of <span class=\"math inline\">\\(n\\)</span>-th roots of unity.</p>\r\n<p>Kronecher wrote in a letter to Dedekind:</p>\r\n<p><em>Es handelt sich um meinen liebsten Jugendtraum, n\"amlich um den\r\nNachweis, dass die Abel'schen Gleichungen mit Quadratwurzeln rationaler\r\nZahlen durch die Transformations-Gleichungen elliptischer Functionen mit\r\nsingularen Moduln grade so ersch\"opft werden, wie die ganzzahligen\r\nAbel'schen Gleichungen durch die Kreisteilungsgleichungen.</em></p>\r\n"},{"title":"Nevanlinna Theory (I)","date":"2023-03-27T10:40:09.000Z","mathjax":true,"_content":"\n# Elnleitung.\n\nMittels der Poisson-Jensenschen und der spezielleren Jensenschen Formel\nkann man nun den nachstehenden Satz beweisen, den wir wegen der grundlegenden Bedeutang desselben flit die ganze Theorie den ersten Hauptsatz nennen:\n\nZu jeder meromorphen Funktion $f(x)$ geh\\\"ort eine reelle Funktion $T(r)$ von folgenden Eigenschaften :\n\n\n1. $T(r)$ ist eine wachsende Funktion von $r$ and eine konvexe Funktion von $\\log r$.\n\n2. Wenn $z$ eine beliebige van $x$ unabMingige, endliche oder unendliche komplexe Zahl bezeichnet, so ist\n$$m(r;z) + N(r;z) = T(r) + O(1).$$\nDie auf der linken Seite der Beziehung (I) stehenden zwei Glieder sind\nnichtnegativ. Das erste Glied $m(r;z)$ ist der Mittelwert der Gr\\\"oße  $\\log^{+} \\left| \\frac{1}{f-z}\\right|$ auf dem Kreis $|x| = r$ und erh\\\"alt also wesentliche Boitr\\\"aige von denjenigen Bogen dieses Kreises, auf denen der Funktionenwert $f$ nahe an dem Wert $z$ liegt ; man k\\\"onnte daher sagen, daß $m(r;z)$ ein blaß f\\\"ur die St\\\"arke der mittleren Hfinvergenz der Funktion $f(x)$ gegen den Wert $z$ f\\\"ur $r \\to \\infty$ angibt. Das zweite Glied $N(r;z)$ bestimmt wiederum, wie dicht diejenigen Punkte liegen, in denen die Funktion den betreffenden Wert $z$ tats\\\"achlich annimmt.  Die Summe in $m(r;z) + N(r; z)$ k\\\"onnte man deshalb als die \"z-Komponente\" in der Variation der meromorpben Funktion f\\\"ur $|x| \\to \\infty$ on bezeichnen: sie charakterisiert sozusagen die St\\\"arke der Affinit\\\"at, welche die Fnnktion zn dem komplexen Wert $z$ besitzt. Der erste Haoptsatz dr\\\"uckt nnn ana, daß s\\\"amtliche z-Komponenten einer meromorphen Funktion gleich stark sind; je zwei von ihnen halten einander f\\\"ur $r \\to \\infty$ im Gleichgewicht, derart daß ihre Differenz f\\\"ur jedes $r$ beschr\\\"ankt ist. Diese schon an sich bemerkenswerte Symmetrieeigenschaft der meromorphen Funktionen iat f\\\"ur die ganze Theorie von fondamentaler Wichtigkeit.\n \n\n使用 Poisson-Jensen 公式和更具体的 Jensen 公式\n现在可以证明以下定理，我们称之为第一定律，因为它对整个理论具有根本重要性：\n\n每个亚纯函数 $f(x)$ 都有一个具有以下属性的实函数 $T(r)$：\n\n1. $T(r)$是$r$的增函数和$\\log r$的凸函数。\n\n\n2. 如果 $z$ 表示独立于 $x$ 的任何复数，有限或无限，则\n$$m(r;z) + N(r;z) = T(r) + O(1).$$\n关系 (I) 左边的两项是\n非负的。 第一项 $m(r;z)$ 是圆 $|x| = r $ 上的数量 $\\log^{+} \\left| \\frac{1}{f-z}\\right|$ 的平均值，并且因此，从该圆的那些弧上接收到显着的 Boitraige，在这些弧上函数值 $f$ 接近值 $z$；因此可以说 $m(r;z)$ 苍白表示平均同向度的强度函数 $f(x)$ 对值 $z$ 的 $r \\to \\infty$。第二项 $N(r; z)$ 反过来决定了这些点与函数实际假定相关值的距离有多近$z$。 因此，$m(r;z) + N(r;z)$ 中的和可以称为 $|x| 的亚纯函数变体中的“z 分量” \\to 表示 \\infty$ on：可以说，它表征了函数对复值 $z$ 的亲和力强度。 第一个前提声明亚纯函数的所有 z 分量都同样强； 他们中的任何两个在 $r \\to \\infty$ 中保持彼此平衡，使得它们对每个 $r$ 的差异是有界的。亚纯函数的这种已经显着的对称性在 f\\“只有整个理论根本的重要性。\n\n\n\n\nDieaer zweite Hauplsatz, wie wir ihn nennen, mann in folgender Weise ausgesprochen werden:\nEs seien $f(x)$ eine beliebige meromoryhe Futiklion, $T(r)$ lie eu ihr geh\\\"orige Fundamentalgr\\\"oße und $a, b, c$ drei non eitiander zerschiedene, endliche oder unendliche komplexe Sahlen. Dann besteht die Angleichung\n$$T (r) < N(r;a) + N(r; b) + N(r; c) - N_{1}(r) - S(r), \\tag{II}$$\nwo die Glieder $N_{1}$ und $S$ folgende Bedeiiftoiy haben :\n1. $N_{1}(r)$ wird durch die multiplen Stellen der Funktion gebildet nach folgender Vorschrift:\n\nldan bilde die Anzahl $n_{1}(r)$ der mehrachen Stellen von $f(x)$ in dem Abreise $|x|<r$ in der Weise, daß eine m-fache Stelle nur ($m - 1$)-mal gez\\\"ahlt wird; dann ist\n$$N_{1}(r) = \\int_{0}^{r} \\frac{n_{1}(t)}{t} dt.$$\n\n2. Das Restglied $S(f)$ gen\\\"ugt der Ungleichung\n$$S(r) < O\\left(\\log T(r)\\right)$$\naußer m\\\"oglicherweise, im Falle einer Funktion von unendliclier Ordnung, fur eine WerJmenge $r$ von endlichem Gesamtmaß.\n\n我们所说的第二定律可以这样说：\n设 $f(x)$ 为任意记忆函数，$T(r)$ 设属于它的基本量，$a、b、c$ 为三个非独立的有限或无限复数。 然后是对齐\n$$T (r) < N(r;a) + N(r; b) + N(r; c) - N_{1}(r) - S(r), \\tag{II}$$\n其中元素 $N_{1}$ 和 $S$ 具有以下含义：\n1. $N_{1}(r)$由函数的多位数字按照以下规则组成：\n\n然后在出发点$|x| < r$中形成$f(x)$的多位数字$n_{1}(r)$，使得第m个数字只有$m - 1 $ ) 次被计算；然后\n$$N_{1}(r) = \\int_{0}^{r} \\frac{n_{1}(t)}{t} dt.$$\n\n2.余数$S(f)$满足不等式\n$$S(r) < O\\left(\\log T(r)\\right)$$\n除非可能，在无限阶函数的情况下，对于有限总测度的值 $r$。\n\n\nEs sei $f(x)$ eine in der endlichen Ebene\nmeromorphe Funktion.  Bezeichnen $z_{1}, z_{2}, \\cdots, z_{q}$ untereinander verschiedene, endliche oder unendliehe Zahlen, so ist\n\n$$(q-2) T(r) <  \\sum_{\\nu =1}^{q} N(r;z_{\\nu})- N_{1}(r) + S(r)  \\tag{III}$$\n\nwo $N_{1}(r)$ in derselben Weise, wie in dent zweiten Hauptsatz (S.63), mittels der mehrfachen Stellen von $f(x)$ gebildet wird, und das Restglied $S(r)$ ebenfalls den in diesem Satze angegebenen Bedingungeu gen\\\"ugt.\n\n设 $f(x)$ 是有限平面中的亚纯函数。如果 $z_{1}, z_{2}, \\cdots, z_{q}$ 表示不同的有限或无限数，则\n\n$$(q-2) T(r) <  \\sum_{\\nu =1}^{q} N(r;z_{\\nu})- N_{1}(r) + S(r)  \\tag{III}$$\n\n其中 $N_{1}(r)$ 与第二定律 (p.63) 相同的方式通过 $f(x)$ 的多个位置形成，余数 $S(r)$ 也满足该定理中给出的条件\n\n\nIn der Ungleichung (III) ist die speziellere\n\n$$(q-2) T(r) <  \\sum_{\\nu =1}^{q} \\bar{N}(r;z_{\\nu}) + S(r)  \\tag{III$^{\\prime}$}$$\n\nenthalten, wo die  Bezeichnung N(t) die auf S.63 angegebene Bedeutung hat\n\n不等式(III)中比较特殊的一个\n\n$$(q-2) T(r) <  \\sum_{\\nu =1}^{q} \\bar{N}(r;z_{\\nu}) + S(r)  \\tag{III$^{\\prime}$}$$\n\n包括在符号 $N(t)$ 具有第 63 页给出的含义的地方","source":"_drafts/Nevanlinna Theory (German).md","raw":"---\ntitle: Nevanlinna Theory (I)\ndate: 2023-03-27 18:40:09\ntags:\n    - [Sevaral Complex Variables]\ncategories:\n    - [Sevaral Complex Variables, Nevanlinna Theory]\nmathjax: true\n---\n\n# Elnleitung.\n\nMittels der Poisson-Jensenschen und der spezielleren Jensenschen Formel\nkann man nun den nachstehenden Satz beweisen, den wir wegen der grundlegenden Bedeutang desselben flit die ganze Theorie den ersten Hauptsatz nennen:\n\nZu jeder meromorphen Funktion $f(x)$ geh\\\"ort eine reelle Funktion $T(r)$ von folgenden Eigenschaften :\n\n\n1. $T(r)$ ist eine wachsende Funktion von $r$ and eine konvexe Funktion von $\\log r$.\n\n2. Wenn $z$ eine beliebige van $x$ unabMingige, endliche oder unendliche komplexe Zahl bezeichnet, so ist\n$$m(r;z) + N(r;z) = T(r) + O(1).$$\nDie auf der linken Seite der Beziehung (I) stehenden zwei Glieder sind\nnichtnegativ. Das erste Glied $m(r;z)$ ist der Mittelwert der Gr\\\"oße  $\\log^{+} \\left| \\frac{1}{f-z}\\right|$ auf dem Kreis $|x| = r$ und erh\\\"alt also wesentliche Boitr\\\"aige von denjenigen Bogen dieses Kreises, auf denen der Funktionenwert $f$ nahe an dem Wert $z$ liegt ; man k\\\"onnte daher sagen, daß $m(r;z)$ ein blaß f\\\"ur die St\\\"arke der mittleren Hfinvergenz der Funktion $f(x)$ gegen den Wert $z$ f\\\"ur $r \\to \\infty$ angibt. Das zweite Glied $N(r;z)$ bestimmt wiederum, wie dicht diejenigen Punkte liegen, in denen die Funktion den betreffenden Wert $z$ tats\\\"achlich annimmt.  Die Summe in $m(r;z) + N(r; z)$ k\\\"onnte man deshalb als die \"z-Komponente\" in der Variation der meromorpben Funktion f\\\"ur $|x| \\to \\infty$ on bezeichnen: sie charakterisiert sozusagen die St\\\"arke der Affinit\\\"at, welche die Fnnktion zn dem komplexen Wert $z$ besitzt. Der erste Haoptsatz dr\\\"uckt nnn ana, daß s\\\"amtliche z-Komponenten einer meromorphen Funktion gleich stark sind; je zwei von ihnen halten einander f\\\"ur $r \\to \\infty$ im Gleichgewicht, derart daß ihre Differenz f\\\"ur jedes $r$ beschr\\\"ankt ist. Diese schon an sich bemerkenswerte Symmetrieeigenschaft der meromorphen Funktionen iat f\\\"ur die ganze Theorie von fondamentaler Wichtigkeit.\n \n\n使用 Poisson-Jensen 公式和更具体的 Jensen 公式\n现在可以证明以下定理，我们称之为第一定律，因为它对整个理论具有根本重要性：\n\n每个亚纯函数 $f(x)$ 都有一个具有以下属性的实函数 $T(r)$：\n\n1. $T(r)$是$r$的增函数和$\\log r$的凸函数。\n\n\n2. 如果 $z$ 表示独立于 $x$ 的任何复数，有限或无限，则\n$$m(r;z) + N(r;z) = T(r) + O(1).$$\n关系 (I) 左边的两项是\n非负的。 第一项 $m(r;z)$ 是圆 $|x| = r $ 上的数量 $\\log^{+} \\left| \\frac{1}{f-z}\\right|$ 的平均值，并且因此，从该圆的那些弧上接收到显着的 Boitraige，在这些弧上函数值 $f$ 接近值 $z$；因此可以说 $m(r;z)$ 苍白表示平均同向度的强度函数 $f(x)$ 对值 $z$ 的 $r \\to \\infty$。第二项 $N(r; z)$ 反过来决定了这些点与函数实际假定相关值的距离有多近$z$。 因此，$m(r;z) + N(r;z)$ 中的和可以称为 $|x| 的亚纯函数变体中的“z 分量” \\to 表示 \\infty$ on：可以说，它表征了函数对复值 $z$ 的亲和力强度。 第一个前提声明亚纯函数的所有 z 分量都同样强； 他们中的任何两个在 $r \\to \\infty$ 中保持彼此平衡，使得它们对每个 $r$ 的差异是有界的。亚纯函数的这种已经显着的对称性在 f\\“只有整个理论根本的重要性。\n\n\n\n\nDieaer zweite Hauplsatz, wie wir ihn nennen, mann in folgender Weise ausgesprochen werden:\nEs seien $f(x)$ eine beliebige meromoryhe Futiklion, $T(r)$ lie eu ihr geh\\\"orige Fundamentalgr\\\"oße und $a, b, c$ drei non eitiander zerschiedene, endliche oder unendliche komplexe Sahlen. Dann besteht die Angleichung\n$$T (r) < N(r;a) + N(r; b) + N(r; c) - N_{1}(r) - S(r), \\tag{II}$$\nwo die Glieder $N_{1}$ und $S$ folgende Bedeiiftoiy haben :\n1. $N_{1}(r)$ wird durch die multiplen Stellen der Funktion gebildet nach folgender Vorschrift:\n\nldan bilde die Anzahl $n_{1}(r)$ der mehrachen Stellen von $f(x)$ in dem Abreise $|x|<r$ in der Weise, daß eine m-fache Stelle nur ($m - 1$)-mal gez\\\"ahlt wird; dann ist\n$$N_{1}(r) = \\int_{0}^{r} \\frac{n_{1}(t)}{t} dt.$$\n\n2. Das Restglied $S(f)$ gen\\\"ugt der Ungleichung\n$$S(r) < O\\left(\\log T(r)\\right)$$\naußer m\\\"oglicherweise, im Falle einer Funktion von unendliclier Ordnung, fur eine WerJmenge $r$ von endlichem Gesamtmaß.\n\n我们所说的第二定律可以这样说：\n设 $f(x)$ 为任意记忆函数，$T(r)$ 设属于它的基本量，$a、b、c$ 为三个非独立的有限或无限复数。 然后是对齐\n$$T (r) < N(r;a) + N(r; b) + N(r; c) - N_{1}(r) - S(r), \\tag{II}$$\n其中元素 $N_{1}$ 和 $S$ 具有以下含义：\n1. $N_{1}(r)$由函数的多位数字按照以下规则组成：\n\n然后在出发点$|x| < r$中形成$f(x)$的多位数字$n_{1}(r)$，使得第m个数字只有$m - 1 $ ) 次被计算；然后\n$$N_{1}(r) = \\int_{0}^{r} \\frac{n_{1}(t)}{t} dt.$$\n\n2.余数$S(f)$满足不等式\n$$S(r) < O\\left(\\log T(r)\\right)$$\n除非可能，在无限阶函数的情况下，对于有限总测度的值 $r$。\n\n\nEs sei $f(x)$ eine in der endlichen Ebene\nmeromorphe Funktion.  Bezeichnen $z_{1}, z_{2}, \\cdots, z_{q}$ untereinander verschiedene, endliche oder unendliehe Zahlen, so ist\n\n$$(q-2) T(r) <  \\sum_{\\nu =1}^{q} N(r;z_{\\nu})- N_{1}(r) + S(r)  \\tag{III}$$\n\nwo $N_{1}(r)$ in derselben Weise, wie in dent zweiten Hauptsatz (S.63), mittels der mehrfachen Stellen von $f(x)$ gebildet wird, und das Restglied $S(r)$ ebenfalls den in diesem Satze angegebenen Bedingungeu gen\\\"ugt.\n\n设 $f(x)$ 是有限平面中的亚纯函数。如果 $z_{1}, z_{2}, \\cdots, z_{q}$ 表示不同的有限或无限数，则\n\n$$(q-2) T(r) <  \\sum_{\\nu =1}^{q} N(r;z_{\\nu})- N_{1}(r) + S(r)  \\tag{III}$$\n\n其中 $N_{1}(r)$ 与第二定律 (p.63) 相同的方式通过 $f(x)$ 的多个位置形成，余数 $S(r)$ 也满足该定理中给出的条件\n\n\nIn der Ungleichung (III) ist die speziellere\n\n$$(q-2) T(r) <  \\sum_{\\nu =1}^{q} \\bar{N}(r;z_{\\nu}) + S(r)  \\tag{III$^{\\prime}$}$$\n\nenthalten, wo die  Bezeichnung N(t) die auf S.63 angegebene Bedeutung hat\n\n不等式(III)中比较特殊的一个\n\n$$(q-2) T(r) <  \\sum_{\\nu =1}^{q} \\bar{N}(r;z_{\\nu}) + S(r)  \\tag{III$^{\\prime}$}$$\n\n包括在符号 $N(t)$ 具有第 63 页给出的含义的地方","slug":"Nevanlinna Theory (German)","published":0,"updated":"2024-02-25T15:11:07.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5rw000mm8nxaaux5d59","content":"<h1 id=\"elnleitung.\">Elnleitung.</h1>\r\n<p>Mittels der Poisson-Jensenschen und der spezielleren Jensenschen\r\nFormel kann man nun den nachstehenden Satz beweisen, den wir wegen der\r\ngrundlegenden Bedeutang desselben flit die ganze Theorie den ersten\r\nHauptsatz nennen:</p>\r\n<p>Zu jeder meromorphen Funktion <span class=\"math inline\">\\(f(x)\\)</span> geh\"ort eine reelle Funktion <span class=\"math inline\">\\(T(r)\\)</span> von folgenden Eigenschaften :</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(T(r)\\)</span> ist eine wachsende\r\nFunktion von <span class=\"math inline\">\\(r\\)</span> and eine konvexe\r\nFunktion von <span class=\"math inline\">\\(\\log r\\)</span>.</p></li>\r\n<li><p>Wenn <span class=\"math inline\">\\(z\\)</span> eine beliebige van\r\n<span class=\"math inline\">\\(x\\)</span> unabMingige, endliche oder\r\nunendliche komplexe Zahl bezeichnet, so ist <span class=\"math display\">\\[m(r;z) + N(r;z) = T(r) + O(1).\\]</span> Die auf\r\nder linken Seite der Beziehung (I) stehenden zwei Glieder sind\r\nnichtnegativ. Das erste Glied <span class=\"math inline\">\\(m(r;z)\\)</span> ist der Mittelwert der Gr\"oße\r\n<span class=\"math inline\">\\(\\log^{+} \\left|\r\n\\frac{1}{f-z}\\right|\\)</span> auf dem Kreis <span class=\"math inline\">\\(|x| = r\\)</span> und erh\"alt also wesentliche\r\nBoitr\"aige von denjenigen Bogen dieses Kreises, auf denen der\r\nFunktionenwert <span class=\"math inline\">\\(f\\)</span> nahe an dem Wert\r\n<span class=\"math inline\">\\(z\\)</span> liegt ; man k\"onnte daher sagen,\r\ndaß <span class=\"math inline\">\\(m(r;z)\\)</span> ein blaß f\"ur die\r\nSt\"arke der mittleren Hfinvergenz der Funktion <span class=\"math inline\">\\(f(x)\\)</span> gegen den Wert <span class=\"math inline\">\\(z\\)</span> f\"ur <span class=\"math inline\">\\(r \\to\r\n\\infty\\)</span> angibt. Das zweite Glied <span class=\"math inline\">\\(N(r;z)\\)</span> bestimmt wiederum, wie dicht\r\ndiejenigen Punkte liegen, in denen die Funktion den betreffenden Wert\r\n<span class=\"math inline\">\\(z\\)</span> tats\"achlich annimmt. Die Summe\r\nin <span class=\"math inline\">\\(m(r;z) + N(r; z)\\)</span> k\"onnte man\r\ndeshalb als die \"z-Komponente\" in der Variation der meromorpben Funktion\r\nf\"ur <span class=\"math inline\">\\(|x| \\to \\infty\\)</span> on bezeichnen:\r\nsie charakterisiert sozusagen die St\"arke der Affinit\"at, welche die\r\nFnnktion zn dem komplexen Wert <span class=\"math inline\">\\(z\\)</span>\r\nbesitzt. Der erste Haoptsatz dr\"uckt nnn ana, daß s\"amtliche\r\nz-Komponenten einer meromorphen Funktion gleich stark sind; je zwei von\r\nihnen halten einander f\"ur <span class=\"math inline\">\\(r \\to\r\n\\infty\\)</span> im Gleichgewicht, derart daß ihre Differenz f\"ur jedes\r\n<span class=\"math inline\">\\(r\\)</span> beschr\"ankt ist. Diese schon an\r\nsich bemerkenswerte Symmetrieeigenschaft der meromorphen Funktionen iat\r\nf\"ur die ganze Theorie von fondamentaler Wichtigkeit.</p></li>\r\n</ol>\r\n<p>使用 Poisson-Jensen 公式和更具体的 Jensen 公式\r\n现在可以证明以下定理，我们称之为第一定律，因为它对整个理论具有根本重要性：</p>\r\n<p>每个亚纯函数 <span class=\"math inline\">\\(f(x)\\)</span>\r\n都有一个具有以下属性的实函数 <span class=\"math inline\">\\(T(r)\\)</span>：</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(T(r)\\)</span>是<span class=\"math inline\">\\(r\\)</span>的增函数和<span class=\"math inline\">\\(\\log r\\)</span>的凸函数。</p></li>\r\n<li><p>如果 <span class=\"math inline\">\\(z\\)</span> 表示独立于 <span class=\"math inline\">\\(x\\)</span> 的任何复数，有限或无限，则 <span class=\"math display\">\\[m(r;z) + N(r;z) = T(r) + O(1).\\]</span> 关系 (I)\r\n左边的两项是 非负的。 第一项 <span class=\"math inline\">\\(m(r;z)\\)</span>\r\n是圆 $|x| = r $ 上的数量 <span class=\"math inline\">\\(\\log^{+} \\left|\r\n\\frac{1}{f-z}\\right|\\)</span>\r\n的平均值，并且因此，从该圆的那些弧上接收到显着的\r\nBoitraige，在这些弧上函数值 <span class=\"math inline\">\\(f\\)</span>\r\n接近值 <span class=\"math inline\">\\(z\\)</span>；因此可以说 <span class=\"math inline\">\\(m(r;z)\\)</span> 苍白表示平均同向度的强度函数 <span class=\"math inline\">\\(f(x)\\)</span> 对值 <span class=\"math inline\">\\(z\\)</span> 的 <span class=\"math inline\">\\(r \\to\r\n\\infty\\)</span>。第二项 <span class=\"math inline\">\\(N(r; z)\\)</span>\r\n反过来决定了这些点与函数实际假定相关值的距离有多近<span class=\"math inline\">\\(z\\)</span>。 因此，<span class=\"math inline\">\\(m(r;z) + N(r;z)\\)</span> 中的和可以称为 <span class=\"math inline\">\\(|x| 的亚纯函数变体中的“z 分量” \\to 表示\r\n\\infty\\)</span> on：可以说，它表征了函数对复值 <span class=\"math inline\">\\(z\\)</span> 的亲和力强度。\r\n第一个前提声明亚纯函数的所有 z 分量都同样强； 他们中的任何两个在 <span class=\"math inline\">\\(r \\to \\infty\\)</span>\r\n中保持彼此平衡，使得它们对每个 <span class=\"math inline\">\\(r\\)</span>\r\n的差异是有界的。亚纯函数的这种已经显着的对称性在\r\nf“只有整个理论根本的重要性。</p></li>\r\n</ol>\r\n<p>Dieaer zweite Hauplsatz, wie wir ihn nennen, mann in folgender Weise\r\nausgesprochen werden: Es seien <span class=\"math inline\">\\(f(x)\\)</span>\r\neine beliebige meromoryhe Futiklion, <span class=\"math inline\">\\(T(r)\\)</span> lie eu ihr geh\"orige\r\nFundamentalgr\"oße und <span class=\"math inline\">\\(a, b, c\\)</span> drei\r\nnon eitiander zerschiedene, endliche oder unendliche komplexe Sahlen.\r\nDann besteht die Angleichung <span class=\"math display\">\\[T (r) &lt;\r\nN(r;a) + N(r; b) + N(r; c) - N_{1}(r) - S(r), \\tag{II}\\]</span> wo die\r\nGlieder <span class=\"math inline\">\\(N_{1}\\)</span> und <span class=\"math inline\">\\(S\\)</span> folgende Bedeiiftoiy haben : 1. <span class=\"math inline\">\\(N_{1}(r)\\)</span> wird durch die multiplen Stellen\r\nder Funktion gebildet nach folgender Vorschrift:</p>\r\n<p>ldan bilde die Anzahl <span class=\"math inline\">\\(n_{1}(r)\\)</span>\r\nder mehrachen Stellen von <span class=\"math inline\">\\(f(x)\\)</span> in\r\ndem Abreise <span class=\"math inline\">\\(|x|&lt;r\\)</span> in der Weise,\r\ndaß eine m-fache Stelle nur (<span class=\"math inline\">\\(m -\r\n1\\)</span>)-mal gez\"ahlt wird; dann ist <span class=\"math display\">\\[N_{1}(r) = \\int_{0}^{r} \\frac{n_{1}(t)}{t}\r\ndt.\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Das Restglied <span class=\"math inline\">\\(S(f)\\)</span> gen\"ugt der\r\nUngleichung <span class=\"math display\">\\[S(r) &lt; O\\left(\\log\r\nT(r)\\right)\\]</span> außer m\"oglicherweise, im Falle einer Funktion von\r\nunendliclier Ordnung, fur eine WerJmenge <span class=\"math inline\">\\(r\\)</span> von endlichem Gesamtmaß.</li>\r\n</ol>\r\n<p>我们所说的第二定律可以这样说： 设 <span class=\"math inline\">\\(f(x)\\)</span> 为任意记忆函数，<span class=\"math inline\">\\(T(r)\\)</span> 设属于它的基本量，<span class=\"math inline\">\\(a、b、c\\)</span> 为三个非独立的有限或无限复数。\r\n然后是对齐 <span class=\"math display\">\\[T (r) &lt; N(r;a) + N(r; b) +\r\nN(r; c) - N_{1}(r) - S(r), \\tag{II}\\]</span> 其中元素 <span class=\"math inline\">\\(N_{1}\\)</span> 和 <span class=\"math inline\">\\(S\\)</span> 具有以下含义： 1. <span class=\"math inline\">\\(N_{1}(r)\\)</span>由函数的多位数字按照以下规则组成：</p>\r\n<p>然后在出发点<span class=\"math inline\">\\(|x| &lt;\r\nr\\)</span>中形成<span class=\"math inline\">\\(f(x)\\)</span>的多位数字<span class=\"math inline\">\\(n_{1}(r)\\)</span>，使得第m个数字只有$m - 1 $ )\r\n次被计算；然后 <span class=\"math display\">\\[N_{1}(r) = \\int_{0}^{r}\r\n\\frac{n_{1}(t)}{t} dt.\\]</span></p>\r\n<p>2.余数<span class=\"math inline\">\\(S(f)\\)</span>满足不等式 <span class=\"math display\">\\[S(r) &lt; O\\left(\\log T(r)\\right)\\]</span>\r\n除非可能，在无限阶函数的情况下，对于有限总测度的值 <span class=\"math inline\">\\(r\\)</span>。</p>\r\n<p>Es sei <span class=\"math inline\">\\(f(x)\\)</span> eine in der\r\nendlichen Ebene meromorphe Funktion. Bezeichnen <span class=\"math inline\">\\(z_{1}, z_{2}, \\cdots, z_{q}\\)</span> untereinander\r\nverschiedene, endliche oder unendliehe Zahlen, so ist</p>\r\n<p><span class=\"math display\">\\[(q-2) T(r) &lt;  \\sum_{\\nu =1}^{q}\r\nN(r;z_{\\nu})- N_{1}(r) + S(r)  \\tag{III}\\]</span></p>\r\n<p>wo <span class=\"math inline\">\\(N_{1}(r)\\)</span> in derselben Weise,\r\nwie in dent zweiten Hauptsatz (S.63), mittels der mehrfachen Stellen von\r\n<span class=\"math inline\">\\(f(x)\\)</span> gebildet wird, und das\r\nRestglied <span class=\"math inline\">\\(S(r)\\)</span> ebenfalls den in\r\ndiesem Satze angegebenen Bedingungeu gen\"ugt.</p>\r\n<p>设 <span class=\"math inline\">\\(f(x)\\)</span>\r\n是有限平面中的亚纯函数。如果 <span class=\"math inline\">\\(z_{1}, z_{2},\r\n\\cdots, z_{q}\\)</span> 表示不同的有限或无限数，则</p>\r\n<p><span class=\"math display\">\\[(q-2) T(r) &lt;  \\sum_{\\nu =1}^{q}\r\nN(r;z_{\\nu})- N_{1}(r) + S(r)  \\tag{III}\\]</span></p>\r\n<p>其中 <span class=\"math inline\">\\(N_{1}(r)\\)</span> 与第二定律 (p.63)\r\n相同的方式通过 <span class=\"math inline\">\\(f(x)\\)</span>\r\n的多个位置形成，余数 <span class=\"math inline\">\\(S(r)\\)</span>\r\n也满足该定理中给出的条件</p>\r\n<p>In der Ungleichung (III) ist die speziellere</p>\r\n<p><span class=\"math display\">\\[(q-2) T(r) &lt;  \\sum_{\\nu =1}^{q}\r\n\\bar{N}(r;z_{\\nu}) + S(r)  \\tag{III$^{\\prime}$}\\]</span></p>\r\n<p>enthalten, wo die Bezeichnung N(t) die auf S.63 angegebene Bedeutung\r\nhat</p>\r\n<p>不等式(III)中比较特殊的一个</p>\r\n<p><span class=\"math display\">\\[(q-2) T(r) &lt;  \\sum_{\\nu =1}^{q}\r\n\\bar{N}(r;z_{\\nu}) + S(r)  \\tag{III$^{\\prime}$}\\]</span></p>\r\n<p>包括在符号 <span class=\"math inline\">\\(N(t)\\)</span> 具有第 63\r\n页给出的含义的地方</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"elnleitung.\">Elnleitung.</h1>\r\n<p>Mittels der Poisson-Jensenschen und der spezielleren Jensenschen\r\nFormel kann man nun den nachstehenden Satz beweisen, den wir wegen der\r\ngrundlegenden Bedeutang desselben flit die ganze Theorie den ersten\r\nHauptsatz nennen:</p>\r\n<p>Zu jeder meromorphen Funktion <span class=\"math inline\">\\(f(x)\\)</span> geh\"ort eine reelle Funktion <span class=\"math inline\">\\(T(r)\\)</span> von folgenden Eigenschaften :</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(T(r)\\)</span> ist eine wachsende\r\nFunktion von <span class=\"math inline\">\\(r\\)</span> and eine konvexe\r\nFunktion von <span class=\"math inline\">\\(\\log r\\)</span>.</p></li>\r\n<li><p>Wenn <span class=\"math inline\">\\(z\\)</span> eine beliebige van\r\n<span class=\"math inline\">\\(x\\)</span> unabMingige, endliche oder\r\nunendliche komplexe Zahl bezeichnet, so ist <span class=\"math display\">\\[m(r;z) + N(r;z) = T(r) + O(1).\\]</span> Die auf\r\nder linken Seite der Beziehung (I) stehenden zwei Glieder sind\r\nnichtnegativ. Das erste Glied <span class=\"math inline\">\\(m(r;z)\\)</span> ist der Mittelwert der Gr\"oße\r\n<span class=\"math inline\">\\(\\log^{+} \\left|\r\n\\frac{1}{f-z}\\right|\\)</span> auf dem Kreis <span class=\"math inline\">\\(|x| = r\\)</span> und erh\"alt also wesentliche\r\nBoitr\"aige von denjenigen Bogen dieses Kreises, auf denen der\r\nFunktionenwert <span class=\"math inline\">\\(f\\)</span> nahe an dem Wert\r\n<span class=\"math inline\">\\(z\\)</span> liegt ; man k\"onnte daher sagen,\r\ndaß <span class=\"math inline\">\\(m(r;z)\\)</span> ein blaß f\"ur die\r\nSt\"arke der mittleren Hfinvergenz der Funktion <span class=\"math inline\">\\(f(x)\\)</span> gegen den Wert <span class=\"math inline\">\\(z\\)</span> f\"ur <span class=\"math inline\">\\(r \\to\r\n\\infty\\)</span> angibt. Das zweite Glied <span class=\"math inline\">\\(N(r;z)\\)</span> bestimmt wiederum, wie dicht\r\ndiejenigen Punkte liegen, in denen die Funktion den betreffenden Wert\r\n<span class=\"math inline\">\\(z\\)</span> tats\"achlich annimmt. Die Summe\r\nin <span class=\"math inline\">\\(m(r;z) + N(r; z)\\)</span> k\"onnte man\r\ndeshalb als die \"z-Komponente\" in der Variation der meromorpben Funktion\r\nf\"ur <span class=\"math inline\">\\(|x| \\to \\infty\\)</span> on bezeichnen:\r\nsie charakterisiert sozusagen die St\"arke der Affinit\"at, welche die\r\nFnnktion zn dem komplexen Wert <span class=\"math inline\">\\(z\\)</span>\r\nbesitzt. Der erste Haoptsatz dr\"uckt nnn ana, daß s\"amtliche\r\nz-Komponenten einer meromorphen Funktion gleich stark sind; je zwei von\r\nihnen halten einander f\"ur <span class=\"math inline\">\\(r \\to\r\n\\infty\\)</span> im Gleichgewicht, derart daß ihre Differenz f\"ur jedes\r\n<span class=\"math inline\">\\(r\\)</span> beschr\"ankt ist. Diese schon an\r\nsich bemerkenswerte Symmetrieeigenschaft der meromorphen Funktionen iat\r\nf\"ur die ganze Theorie von fondamentaler Wichtigkeit.</p></li>\r\n</ol>\r\n<p>使用 Poisson-Jensen 公式和更具体的 Jensen 公式\r\n现在可以证明以下定理，我们称之为第一定律，因为它对整个理论具有根本重要性：</p>\r\n<p>每个亚纯函数 <span class=\"math inline\">\\(f(x)\\)</span>\r\n都有一个具有以下属性的实函数 <span class=\"math inline\">\\(T(r)\\)</span>：</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(T(r)\\)</span>是<span class=\"math inline\">\\(r\\)</span>的增函数和<span class=\"math inline\">\\(\\log r\\)</span>的凸函数。</p></li>\r\n<li><p>如果 <span class=\"math inline\">\\(z\\)</span> 表示独立于 <span class=\"math inline\">\\(x\\)</span> 的任何复数，有限或无限，则 <span class=\"math display\">\\[m(r;z) + N(r;z) = T(r) + O(1).\\]</span> 关系 (I)\r\n左边的两项是 非负的。 第一项 <span class=\"math inline\">\\(m(r;z)\\)</span>\r\n是圆 $|x| = r $ 上的数量 <span class=\"math inline\">\\(\\log^{+} \\left|\r\n\\frac{1}{f-z}\\right|\\)</span>\r\n的平均值，并且因此，从该圆的那些弧上接收到显着的\r\nBoitraige，在这些弧上函数值 <span class=\"math inline\">\\(f\\)</span>\r\n接近值 <span class=\"math inline\">\\(z\\)</span>；因此可以说 <span class=\"math inline\">\\(m(r;z)\\)</span> 苍白表示平均同向度的强度函数 <span class=\"math inline\">\\(f(x)\\)</span> 对值 <span class=\"math inline\">\\(z\\)</span> 的 <span class=\"math inline\">\\(r \\to\r\n\\infty\\)</span>。第二项 <span class=\"math inline\">\\(N(r; z)\\)</span>\r\n反过来决定了这些点与函数实际假定相关值的距离有多近<span class=\"math inline\">\\(z\\)</span>。 因此，<span class=\"math inline\">\\(m(r;z) + N(r;z)\\)</span> 中的和可以称为 <span class=\"math inline\">\\(|x| 的亚纯函数变体中的“z 分量” \\to 表示\r\n\\infty\\)</span> on：可以说，它表征了函数对复值 <span class=\"math inline\">\\(z\\)</span> 的亲和力强度。\r\n第一个前提声明亚纯函数的所有 z 分量都同样强； 他们中的任何两个在 <span class=\"math inline\">\\(r \\to \\infty\\)</span>\r\n中保持彼此平衡，使得它们对每个 <span class=\"math inline\">\\(r\\)</span>\r\n的差异是有界的。亚纯函数的这种已经显着的对称性在\r\nf“只有整个理论根本的重要性。</p></li>\r\n</ol>\r\n<p>Dieaer zweite Hauplsatz, wie wir ihn nennen, mann in folgender Weise\r\nausgesprochen werden: Es seien <span class=\"math inline\">\\(f(x)\\)</span>\r\neine beliebige meromoryhe Futiklion, <span class=\"math inline\">\\(T(r)\\)</span> lie eu ihr geh\"orige\r\nFundamentalgr\"oße und <span class=\"math inline\">\\(a, b, c\\)</span> drei\r\nnon eitiander zerschiedene, endliche oder unendliche komplexe Sahlen.\r\nDann besteht die Angleichung <span class=\"math display\">\\[T (r) &lt;\r\nN(r;a) + N(r; b) + N(r; c) - N_{1}(r) - S(r), \\tag{II}\\]</span> wo die\r\nGlieder <span class=\"math inline\">\\(N_{1}\\)</span> und <span class=\"math inline\">\\(S\\)</span> folgende Bedeiiftoiy haben : 1. <span class=\"math inline\">\\(N_{1}(r)\\)</span> wird durch die multiplen Stellen\r\nder Funktion gebildet nach folgender Vorschrift:</p>\r\n<p>ldan bilde die Anzahl <span class=\"math inline\">\\(n_{1}(r)\\)</span>\r\nder mehrachen Stellen von <span class=\"math inline\">\\(f(x)\\)</span> in\r\ndem Abreise <span class=\"math inline\">\\(|x|&lt;r\\)</span> in der Weise,\r\ndaß eine m-fache Stelle nur (<span class=\"math inline\">\\(m -\r\n1\\)</span>)-mal gez\"ahlt wird; dann ist <span class=\"math display\">\\[N_{1}(r) = \\int_{0}^{r} \\frac{n_{1}(t)}{t}\r\ndt.\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Das Restglied <span class=\"math inline\">\\(S(f)\\)</span> gen\"ugt der\r\nUngleichung <span class=\"math display\">\\[S(r) &lt; O\\left(\\log\r\nT(r)\\right)\\]</span> außer m\"oglicherweise, im Falle einer Funktion von\r\nunendliclier Ordnung, fur eine WerJmenge <span class=\"math inline\">\\(r\\)</span> von endlichem Gesamtmaß.</li>\r\n</ol>\r\n<p>我们所说的第二定律可以这样说： 设 <span class=\"math inline\">\\(f(x)\\)</span> 为任意记忆函数，<span class=\"math inline\">\\(T(r)\\)</span> 设属于它的基本量，<span class=\"math inline\">\\(a、b、c\\)</span> 为三个非独立的有限或无限复数。\r\n然后是对齐 <span class=\"math display\">\\[T (r) &lt; N(r;a) + N(r; b) +\r\nN(r; c) - N_{1}(r) - S(r), \\tag{II}\\]</span> 其中元素 <span class=\"math inline\">\\(N_{1}\\)</span> 和 <span class=\"math inline\">\\(S\\)</span> 具有以下含义： 1. <span class=\"math inline\">\\(N_{1}(r)\\)</span>由函数的多位数字按照以下规则组成：</p>\r\n<p>然后在出发点<span class=\"math inline\">\\(|x| &lt;\r\nr\\)</span>中形成<span class=\"math inline\">\\(f(x)\\)</span>的多位数字<span class=\"math inline\">\\(n_{1}(r)\\)</span>，使得第m个数字只有$m - 1 $ )\r\n次被计算；然后 <span class=\"math display\">\\[N_{1}(r) = \\int_{0}^{r}\r\n\\frac{n_{1}(t)}{t} dt.\\]</span></p>\r\n<p>2.余数<span class=\"math inline\">\\(S(f)\\)</span>满足不等式 <span class=\"math display\">\\[S(r) &lt; O\\left(\\log T(r)\\right)\\]</span>\r\n除非可能，在无限阶函数的情况下，对于有限总测度的值 <span class=\"math inline\">\\(r\\)</span>。</p>\r\n<p>Es sei <span class=\"math inline\">\\(f(x)\\)</span> eine in der\r\nendlichen Ebene meromorphe Funktion. Bezeichnen <span class=\"math inline\">\\(z_{1}, z_{2}, \\cdots, z_{q}\\)</span> untereinander\r\nverschiedene, endliche oder unendliehe Zahlen, so ist</p>\r\n<p><span class=\"math display\">\\[(q-2) T(r) &lt;  \\sum_{\\nu =1}^{q}\r\nN(r;z_{\\nu})- N_{1}(r) + S(r)  \\tag{III}\\]</span></p>\r\n<p>wo <span class=\"math inline\">\\(N_{1}(r)\\)</span> in derselben Weise,\r\nwie in dent zweiten Hauptsatz (S.63), mittels der mehrfachen Stellen von\r\n<span class=\"math inline\">\\(f(x)\\)</span> gebildet wird, und das\r\nRestglied <span class=\"math inline\">\\(S(r)\\)</span> ebenfalls den in\r\ndiesem Satze angegebenen Bedingungeu gen\"ugt.</p>\r\n<p>设 <span class=\"math inline\">\\(f(x)\\)</span>\r\n是有限平面中的亚纯函数。如果 <span class=\"math inline\">\\(z_{1}, z_{2},\r\n\\cdots, z_{q}\\)</span> 表示不同的有限或无限数，则</p>\r\n<p><span class=\"math display\">\\[(q-2) T(r) &lt;  \\sum_{\\nu =1}^{q}\r\nN(r;z_{\\nu})- N_{1}(r) + S(r)  \\tag{III}\\]</span></p>\r\n<p>其中 <span class=\"math inline\">\\(N_{1}(r)\\)</span> 与第二定律 (p.63)\r\n相同的方式通过 <span class=\"math inline\">\\(f(x)\\)</span>\r\n的多个位置形成，余数 <span class=\"math inline\">\\(S(r)\\)</span>\r\n也满足该定理中给出的条件</p>\r\n<p>In der Ungleichung (III) ist die speziellere</p>\r\n<p><span class=\"math display\">\\[(q-2) T(r) &lt;  \\sum_{\\nu =1}^{q}\r\n\\bar{N}(r;z_{\\nu}) + S(r)  \\tag{III$^{\\prime}$}\\]</span></p>\r\n<p>enthalten, wo die Bezeichnung N(t) die auf S.63 angegebene Bedeutung\r\nhat</p>\r\n<p>不等式(III)中比较特殊的一个</p>\r\n<p><span class=\"math display\">\\[(q-2) T(r) &lt;  \\sum_{\\nu =1}^{q}\r\n\\bar{N}(r;z_{\\nu}) + S(r)  \\tag{III$^{\\prime}$}\\]</span></p>\r\n<p>包括在符号 <span class=\"math inline\">\\(N(t)\\)</span> 具有第 63\r\n页给出的含义的地方</p>\r\n"},{"title":"Nowicki Conjecture","date":"2023-04-01T08:22:43.000Z","mathjax":true,"_content":"Let $A[\\mathbf{x}] = A[x_{1}, \\cdots, x_{n}$] be the polynomial ring in n variables over an integral domain $A$, $D$ an $A$-[derivation](https://en.wikipedia.org/wiki/Derivation_(differential_algebra)) of $A[\\mathbf{x}]$ and denote \n$$D_{ij} := D(x_{i}) x_{j} - D(x_{j}) x_{i}, \\quad \\text{ for each } i, j \\in \\{1, \\cdots, n\\}.$$\n\n\n## Theorem 1 [Nowicki 1, Conjecture 6.9.10]\nAssume that $k[\\mathbf{y}] = k[y_{1}, \\cdots, y_{n}]$ is the polynomial ring in $n$ variables over a field $k$ of characteristic zero. If $\\Delta_{n}$ is the $k[\\mathbf{y}]$-derivation of $k[\\mathbf{y}][\\mathbf{x}]$ defined by $\\Delta_{n}(x_{i}) = y_{i}$ for $i = 1, \\cdots, n$, then $\\ker \\Delta_{n}$ is generated by $L^{\\Delta_{n}}_{ij}$ for $1 ≤ i < j ≤ n$ over $k[\\mathbf{y}]$.\n\n\n## Proof\n\nWe prove the conjecture by induction on $n$. The assertion is clear when $n = 1$. Assume that $n \\geq 2$, and let $S_{l}$ be the set of $L_{i,j} := L^{\\Delta_{n}}_{i,j}$ for $1 \\leq i < j \\leq l$ for each $l \\leq n$. By the assumption on induction, $\\ker \\Delta_{n-1}$ is generated by $S_{n-1}$ over $k[\\mathbf{y}^{\\prime}] := k[y_{1}, \\cdots , y_{n-1}]$, since $L^{\\Delta_{n-1}}_{i,j} = L^{\\Delta_{n}}_{i,j}$ for each $i, j$. As discussed in Section 1, the $k[\\mathbf{y}^{\\prime}]$-derivation $\\Delta_{n-1}$ naturally extends to a $k[\\mathbf{y}]$-derivation $(\\Delta_{n-1})_{k[\\mathbf{y}]}$ of $k[\\mathbf{y}][\\mathbf{x}^{\\prime}] := k[\\mathbf{y}][x_{1}, \\cdots, x_{n-1}]$. Then, $(\\Delta_{n-1})k[\\mathbf{y}] = \\Delta_{n}|_{k[\\mathbf{y}][\\mathbf{x}^{\\prime}]}$, so we have $\\ker(\\Delta_{n-1})k[\\mathbf{y}] = k[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n}$. Moreover,\n$\\ker(\\Delta_{n-1})k[\\mathbf{y}] = k[\\mathbf{y}] \\otimes_{k[\\mathbf{y}^{\\prime}]} \\ker \\Delta_{n-1}$, since $k[\\mathbf{y}]$ is flat over $k[\\mathbf{y}^{\\prime}]$. Thus, we get\n\n\n$$\\begin{equation}\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n} = k[\\mathbf{y}][S_{n-1}].\n\\end{equation}$$\n\n\n\nLet $\\mathbf{e}_{1}, \\cdots , \\mathbf{e}_{n}$ be the coordinate unit vectors of $\\mathbb{R}^{n}$, $M$ the $\\mathbb{Z}$-submodule of $(\\mathbb{Z}^{n})^{2}$ generated by $(\\mathbf{e}_{j} - \\mathbf{e}_{i}, \\mathbf{e}_{i} - \\mathbf{e}_{j})$ for $1 \\leq i < j \\leq n$, and $\\Gamma = (\\mathbb{Z}^{n})^{2}/M$. Then, $\\Gamma$-gradings are defined on $k[\\mathbf{y}][\\mathbf{x}]$ and $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}] := k[\\mathbf{y}][\\mathbf{x}][(y_{1} \\cdots y_{n})^{-1}]$ as follows. Here, a $k$-algebra $R$ is said to be $\\Gamma$-graded if there exists a $k$-vector subspace $R_{\\gamma}$ of $R$ for each $\\gamma \\in \\Gamma$ such that $R = \\oplus_{\\gamma \\in \\Gamma} R_{\\gamma}$ and $R_{\\gamma} R_{\\mu} \\subset R_{\\gamma + \\mu}$ for $\\gamma, \\mu \\in \\Gamma$. Let $\\mathbb{Z}_{\\geq 0}$ denote the set of nonnegative integers, and $\\mathbf{y}^{a} = y^{a_{1}} \\cdots y^{a_{n}}$ and $\\mathbf{x}_{b} = x^{b_{1}} \\cdots x^{b_{n}}$ for $a = (a_{1}, \\cdots , a_{n})$ and $b = (b_{1}, \\cdots , b_{n})$. For each $\\gamma \\in \\Gamma$, we define $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma}$ (resp. $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\gamma}$) to be the $k$-vector space generated by $\\mathbf{y}^{a}\\mathbf{x}^{b}$ for $a, b \\in (\\mathbb{Z}_{\\geq 0})^{n} (resp. $a \\in \\mathbb{Z}^{n}, b \\in (\\mathbb{Z}_{\\geq 0})^{n}$) such that the image of $(a, b)$ in $\\Gamma$ is equal to $\\gamma$. Then, $\\Gamma$-gradings are defined on $k[\\mathbf{y}][\\mathbf{x}]$ and $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]$. Note that $\\Delta_{n}(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma})$ is contained in $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma - \\delta}$ for each $\\gamma \\in \\Gamma$, where $\\delta$ is the image of $(-\\mathbb{e}_{n}, \\mathbb{e}_{n})$ in $\\Gamma$. From this, we know that\n\n$$\\ker \\Delta_{n} = \\bigoplus_{\\gamma \\in \\Gamma} k[\\mathbf{y}] [ \\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}$$\n\nHence, we are reduced to showing that each $0 \\neq \\varPhi \\in k[\\mathbf{y}][\\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}$ belongs to $k[\\mathbf{y}][S_{n}]$ for $\\gamma \\in \\Gamma$. We may find $a = (a_{1}, \\cdots , a_{n}) \\in \\mathbb{Z}^{n}$ and $l \\in \\mathbb{Z}_{\\geq 0}$ such that the image of $(a, l\\mathbf{e}_{n})$ in $\\Gamma$ is equal to $\\gamma$. Let $m$ be the $x_{n}$-degree of $\\varPhi$, where $0 \\leq m \\leq l$, and $\\phi \\in k[\\mathbf{y}][\\mathbf{x}^{\\prime}]$ the coefficient of $x_{n}^{m}$ in $\\varPhi$. Then, $\\phi$ belongs to $k[\\mathbf{y}][\\mathbf{x}]_{\\mu}$, where $\\mu$ is the image of $(a, (l −m)\\mathbf{e}_{n})$ in $\\Gamma$. Furthermore, $0 = \\Delta_{n}(\\varPhi) = \\Delta_{n}(\\varphi)x^{m}_{n} + m\\phi y_{n}x_{n}^{m-1} + \\Delta_{n}(\\varPhi - \\phi x^{m}_{n})$, and the $x_{n}$-degrees of $m\\phi y_{n}x_{n}^{m-1}$ and $\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})$ are at most $m - 1$. Hence, $\\Delta_{n}(\\phi) = 0$. Thus, $\\phi$ belongs to $k[\\mathbf{y}][S_{n-1}]$ by (1). Write $\\phi = \\sum_{b,\\mathbf{u}} r^{\\prime}_{b,\\mathbf{u}}y^{b}\\hat{y}^{-\\mathbf{u}}L^{\\mathbf{u}}$, where the sum is taken over $b \\in (\\mathbb{Z}_{\\geq 0})^{n}$ and $u = (u_{i,j})_{i,j}$ with $u_{i,j} \\in \\mathbb{Z}_{\\geq 0}$ for $1 \\leq i < j \\leq n - 1$, $r^{\\prime}_{b,\\mathbf{u}} \\in k$ for each $b$ and $\\mathbf{u}$, and \n\n$\\hat{y}^{-u} = \\prod_{1\\leq i < j \\leq n-1} (y_{i}y_{j})^{-u_{i,j}}, \\quad L^{\\mathbf{u}} = \\prod_{1 \\leq i<j\\leq n-1} L_{i,j}^{u_{i,j}}$ for each $\\mathbf{U}$.\n\nWe may assume that $r_{b,\\mathbf{u}}^{\\prime} = 0$ if $\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}$ is not in $k[\\mathbf{y}]$. Let $\\eta(b, \\mathbf{u})$ be the image of $(b - |\\mathbf{u}|\\mathbf{e}_{n}, |\\mathbf{u}|\\mathbf{e}_{n})$ in $\\Gamma$, where $|\\mathbf{u}| = \\sum_{i,j} u_{i,j}\n$. Then, $\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}L^{\\mathbf{u}}$ belongs to $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\eta(b,\\mathbf{u})}$ for each $b$ and $\\mathbf{u}$, since $(y_{i}y_{j})^{-1} L_{i,j}$ belongs to $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\delta}$ for each $i, j$.  Since $\\phi$ is in $k[\\mathbf{y}][\\mathbf{x}]_{\\mu}$, and $\\mu$ is the image of $(a, (l - m)\\mathbf{e}_{n})$, we may assume that $r_{b,\\mathbf{u}}^{\\prime} = 0$ unless $|u| = l - m$ and $b = a + (l - m)\\mathbf{e}_{n}$. For each $\\mathbf{u}$ with $r_{\\mathbf{u}} := r^{\\prime}_{a + (l-m) \\mathbf{e}_{n},\\mathbf{u}}\\neq 0$, write $\\mathbf{y}^{a}y_{n}^{l-m}\\hat{y}^{-\\mathbf{u}} =\ny_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} y_{n}^{s}$, where $\\rho_{i}(u) \\in \\mathbb{Z}_{\\geq 0}$ for $i = 1, \\cdots , n - 1$, and $s = a_{n} + l - m$. Then, we have $\\phi = y_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}$. Since $|u| = l - m$, it follows that\n\n$$\\begin{equation}\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\n\\end{equation}$$\n\nNow, we show that $\\varPhi$ belongs to $k[\\mathbf{y}][S_{n}]$ by contradiction. By replacing $\\varPhi$ if necessary, we may assume that $m$ is the minimum among the $x_{n}$-degrees of elements of $\\ker \\Delta_{n}\\backslash k[\\mathbf{y}][S_{n}]$. To obtain a contradiction, it suffices to deduce that\n\n$$\\begin{equation}\nm \\geq 2l - \\sum_{i=1}^{n-1} a_{i}\n\\end{equation}$$\n\n\nIn fact, (3) implies that $\\sum_{i=1}^{n-1}\n\\rho_{i}(\\mathbf{u}) \\geq m$ by (2), so we have $\\sum_{i=1}^{n-1}\\rho_{i}^{\\prime}(\\mathbf{u})  = m$ for some\nintegers $0 \\leq \\rho^{\\prime}_{i}(\\mathbf{u}) \\leq \\rho_{i}(\\mathbf{u})$ for $i = 1, \\cdots, n - 1$ for each $u$. Then,\n\n$$\\varPhi^{\\prime} := y_{n}^{s} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}） - \\rho_{i}^{\\prime}(\\mathbf{u})} L_{n,i}^{\\rho_{i}^{\\prime}(\\mathbf{u}）} = y_{n}^{s} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}） - \\rho_{i}^{\\prime}(\\mathbf{u}） } (y_{i}x_{n} x_{n}y_{i})^{\\rho_{i}^{\\prime}(\\mathbf{u}） }$$\n\n\nis an element of $k[\\mathbf{y}][S_{n}]$ having $x_{n}$-degree $m$, in which the coefficient of $x_{n}^{m}$ is equal to $\\phi$. Hence, the $x_{n}$-degree of $\\varPhi - \\varPhi^{\\prime}$ is less than $m$. Since $\\varPhi - \\varPhi^{\\prime}$ is an element of $\\ker \\Delta_{n} \\backslash k[\\mathbf{y}][S_{n}]$, this contradicts the minimality of $m$.\n\nWe establish that (3) holds for any nonzero homogeneous element $\\varPhi$ of $\\ker \\Delta_{n}$ by contradiction.\nTake $\\varPhi$ which does not satisfy (3) so that $m$ would be the minimum among the $x_{n}$-degrees of such polynomials. Then, $t:= 2l - \\sum_{i=1}^{n-1}a_{i} -m$ is positive, and $\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) = m - t$ for each $\\mathbf{u}$ by (2). Hence, the $x_{n}$-degree of\n\n$$\\varPhi_{1}:= \\sum_{\\mathbf{u}} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} L_{n,i}^{\\rho_{i}(\\mathbf{u})} = \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} (y_{i}x_{n} - y_{n}x_{i})^{\\rho_{i}(\\mathbf{u})}$$\n\n\nis $m - t$. The coefficient of $x_{n}^{n-t}$ in $y_{n}^{s}\\varPhi_{1}$ is equal to $\\phi$, so the coefficient of $x_{n}^{m}$ in $y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$ is equal to that in $y_{1}^{t}\\varPhi$. Consequently, the $x_{n}$-degree $m^{\\prime}$ of $\\varPhi_{2}:= y_{1}^{t}\\varPhi - y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$ is less than $m$. We claim that $\\varPhi_{2} = 0$. In fact, if $\\gamma^{\\prime}$ is the image of $(a + t\\mathbf{e}_{1}, l\\mathbf{e}_{n})$ in $\\Gamma$, and $(a^{\\prime}_{1}, \\cdots , a_{n}^{\\prime}\n) := a + t\\mathbf{e}_{1}$, then $\\varPhi_{2}$ belongs to $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma^{\\prime}} \\cap \\ker \\Delta_{n}$, and\n\n\n$$2l - \\sum_{i=1}^{n-1} a^{\\prime}_{i} = 2l - \\sum_{i=1}^{n-1} a_{i} - t = m > m^{\\prime}$$\n\n\nThis implies that $\\varPhi_{2} = 0$ by the minimality of $m$. Hence, $y_{1}^{t} \\varPhi= y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$. Thus, $\\varPhi_{1}$ is divisible by $y_{1}$, since neither are $y_{n}$ and $L_{n,1}$. Recall that the kernel of a locally nilpotent derivation $D$ of an integral domain $R$ containing $Q$ is factorially closed in $R$, that is, $D(f g) =\n0$ implies $D(f ) = D(g) = 0$ for each $f, g \\in R \\ \\{0\\}$ (cf. [2, Proposition 1.3.32 (iii)]). Note\nthat $\\Delta_{n}$ is locally nilpotent, $\\Delta_{n}(\\varPhi_{1}) = 0$, $\\varPhi_{1} \\neq 0$ and $\\Delta_{n}(x_{n}) \\neq 0$. Hence, $\\varPhi_{1}$ is not divisible by $x_{n}$. By substituting zero for $x_{n}$, we obtain from $\\varPhi_{1}$ a nonzero polynomial\n\n$$\\sum_{\\mathbf{u}}r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} (- y_{n} x_{i})^{\\rho_{i}(\\mathbf{u})} = ( - y_{n} )^{m-i} \\varPsi, \\text{ where } \\varPsi = \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} x_{i}^{\\rho_{i}(\\mathbf{u})}.$$\n\nThen, $\\varPhi \\neq 0$, and $\\varPhi$ is divisible by $y_{1}$, since so is $\\phi_{1}$. Define $\\sigma \\in \\text{Aut}_{k} k[\\mathbf{y}][\\mathbf{x}]$ by $\\sigma(x_{i}) =\ny_{i}$ and $\\sigma(y_{i}) = x_{i}$ for $i = 1, \\cdots, n$. Then, $\\sigma(\\varPhi)$ is divisible by $x_{1}$. On the other hand, $\\sigma(L_{i,j}) = L_{j,i}$ and $\\sigma(x_{i}) = y_{i}$ are in $\\ker \\Delta_{n}$ for each $i, j$, so $\\sigma(\\varPsi)$ belongs to $\\ker \\Delta_{n}$. Thus, we have $\\sigma(\\varPsi) = 0$, because $x_{1}$ is not in $\\ker \\Delta_[n]$ and $\\ker \\Delta_{n}$ is factorially closed in $k[\\mathbf{y}][\\mathbf{x}]$. This contradicts that $\\varPsi \\neq 0$. Therefore, (3) holds true. Thereby, we have proved that $\\varPhi$ belongs to $k[\\mathbf{y}][S_{n}]$. This completes the proof of the conjecture.\n\n\n\n# Reference\n\n[1] Nowicki, Andrzej. Polynomial derivations and their rings of constants. Toruń: Uniwersytet Mikolaja Kopernika, 1994.\n\n[2] Khoury, Joseph. Locally nilpotent derivations and their rings of constants. University of Ottawa (Canada), 2001.\n\n[3] Kuroda, Shigeru. \"A Simple Proof of Nowicki's Conjecture on the Kernel of an Elementary Derivation.\" Tokyo Journal of Mathematics 32.1 (2009): 247-251.\n\n[4] Drensky V, Makar-Limanov L. The conjecture of Nowicki on Weitzenböck derivations of polynomial algebras[J]. Journal of Algebra and Its Applications, 2009, 8(01): 41-51.\n\n[5] Drensky, Vesselin. \"Another proof of the Nowicki conjecture.\" Tokyo Journal of Mathematics 43.2 (2020): 537-542.\n\n","source":"_drafts/Nowicki Conjecture.md","raw":"---\ntitle: Nowicki Conjecture\ndate: 2023-04-01 16:22:43\ntags:\n    - [Notes]\ncategories:\n    - [Notes]\nmathjax: true\n---\nLet $A[\\mathbf{x}] = A[x_{1}, \\cdots, x_{n}$] be the polynomial ring in n variables over an integral domain $A$, $D$ an $A$-[derivation](https://en.wikipedia.org/wiki/Derivation_(differential_algebra)) of $A[\\mathbf{x}]$ and denote \n$$D_{ij} := D(x_{i}) x_{j} - D(x_{j}) x_{i}, \\quad \\text{ for each } i, j \\in \\{1, \\cdots, n\\}.$$\n\n\n## Theorem 1 [Nowicki 1, Conjecture 6.9.10]\nAssume that $k[\\mathbf{y}] = k[y_{1}, \\cdots, y_{n}]$ is the polynomial ring in $n$ variables over a field $k$ of characteristic zero. If $\\Delta_{n}$ is the $k[\\mathbf{y}]$-derivation of $k[\\mathbf{y}][\\mathbf{x}]$ defined by $\\Delta_{n}(x_{i}) = y_{i}$ for $i = 1, \\cdots, n$, then $\\ker \\Delta_{n}$ is generated by $L^{\\Delta_{n}}_{ij}$ for $1 ≤ i < j ≤ n$ over $k[\\mathbf{y}]$.\n\n\n## Proof\n\nWe prove the conjecture by induction on $n$. The assertion is clear when $n = 1$. Assume that $n \\geq 2$, and let $S_{l}$ be the set of $L_{i,j} := L^{\\Delta_{n}}_{i,j}$ for $1 \\leq i < j \\leq l$ for each $l \\leq n$. By the assumption on induction, $\\ker \\Delta_{n-1}$ is generated by $S_{n-1}$ over $k[\\mathbf{y}^{\\prime}] := k[y_{1}, \\cdots , y_{n-1}]$, since $L^{\\Delta_{n-1}}_{i,j} = L^{\\Delta_{n}}_{i,j}$ for each $i, j$. As discussed in Section 1, the $k[\\mathbf{y}^{\\prime}]$-derivation $\\Delta_{n-1}$ naturally extends to a $k[\\mathbf{y}]$-derivation $(\\Delta_{n-1})_{k[\\mathbf{y}]}$ of $k[\\mathbf{y}][\\mathbf{x}^{\\prime}] := k[\\mathbf{y}][x_{1}, \\cdots, x_{n-1}]$. Then, $(\\Delta_{n-1})k[\\mathbf{y}] = \\Delta_{n}|_{k[\\mathbf{y}][\\mathbf{x}^{\\prime}]}$, so we have $\\ker(\\Delta_{n-1})k[\\mathbf{y}] = k[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n}$. Moreover,\n$\\ker(\\Delta_{n-1})k[\\mathbf{y}] = k[\\mathbf{y}] \\otimes_{k[\\mathbf{y}^{\\prime}]} \\ker \\Delta_{n-1}$, since $k[\\mathbf{y}]$ is flat over $k[\\mathbf{y}^{\\prime}]$. Thus, we get\n\n\n$$\\begin{equation}\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n} = k[\\mathbf{y}][S_{n-1}].\n\\end{equation}$$\n\n\n\nLet $\\mathbf{e}_{1}, \\cdots , \\mathbf{e}_{n}$ be the coordinate unit vectors of $\\mathbb{R}^{n}$, $M$ the $\\mathbb{Z}$-submodule of $(\\mathbb{Z}^{n})^{2}$ generated by $(\\mathbf{e}_{j} - \\mathbf{e}_{i}, \\mathbf{e}_{i} - \\mathbf{e}_{j})$ for $1 \\leq i < j \\leq n$, and $\\Gamma = (\\mathbb{Z}^{n})^{2}/M$. Then, $\\Gamma$-gradings are defined on $k[\\mathbf{y}][\\mathbf{x}]$ and $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}] := k[\\mathbf{y}][\\mathbf{x}][(y_{1} \\cdots y_{n})^{-1}]$ as follows. Here, a $k$-algebra $R$ is said to be $\\Gamma$-graded if there exists a $k$-vector subspace $R_{\\gamma}$ of $R$ for each $\\gamma \\in \\Gamma$ such that $R = \\oplus_{\\gamma \\in \\Gamma} R_{\\gamma}$ and $R_{\\gamma} R_{\\mu} \\subset R_{\\gamma + \\mu}$ for $\\gamma, \\mu \\in \\Gamma$. Let $\\mathbb{Z}_{\\geq 0}$ denote the set of nonnegative integers, and $\\mathbf{y}^{a} = y^{a_{1}} \\cdots y^{a_{n}}$ and $\\mathbf{x}_{b} = x^{b_{1}} \\cdots x^{b_{n}}$ for $a = (a_{1}, \\cdots , a_{n})$ and $b = (b_{1}, \\cdots , b_{n})$. For each $\\gamma \\in \\Gamma$, we define $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma}$ (resp. $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\gamma}$) to be the $k$-vector space generated by $\\mathbf{y}^{a}\\mathbf{x}^{b}$ for $a, b \\in (\\mathbb{Z}_{\\geq 0})^{n} (resp. $a \\in \\mathbb{Z}^{n}, b \\in (\\mathbb{Z}_{\\geq 0})^{n}$) such that the image of $(a, b)$ in $\\Gamma$ is equal to $\\gamma$. Then, $\\Gamma$-gradings are defined on $k[\\mathbf{y}][\\mathbf{x}]$ and $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]$. Note that $\\Delta_{n}(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma})$ is contained in $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma - \\delta}$ for each $\\gamma \\in \\Gamma$, where $\\delta$ is the image of $(-\\mathbb{e}_{n}, \\mathbb{e}_{n})$ in $\\Gamma$. From this, we know that\n\n$$\\ker \\Delta_{n} = \\bigoplus_{\\gamma \\in \\Gamma} k[\\mathbf{y}] [ \\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}$$\n\nHence, we are reduced to showing that each $0 \\neq \\varPhi \\in k[\\mathbf{y}][\\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}$ belongs to $k[\\mathbf{y}][S_{n}]$ for $\\gamma \\in \\Gamma$. We may find $a = (a_{1}, \\cdots , a_{n}) \\in \\mathbb{Z}^{n}$ and $l \\in \\mathbb{Z}_{\\geq 0}$ such that the image of $(a, l\\mathbf{e}_{n})$ in $\\Gamma$ is equal to $\\gamma$. Let $m$ be the $x_{n}$-degree of $\\varPhi$, where $0 \\leq m \\leq l$, and $\\phi \\in k[\\mathbf{y}][\\mathbf{x}^{\\prime}]$ the coefficient of $x_{n}^{m}$ in $\\varPhi$. Then, $\\phi$ belongs to $k[\\mathbf{y}][\\mathbf{x}]_{\\mu}$, where $\\mu$ is the image of $(a, (l −m)\\mathbf{e}_{n})$ in $\\Gamma$. Furthermore, $0 = \\Delta_{n}(\\varPhi) = \\Delta_{n}(\\varphi)x^{m}_{n} + m\\phi y_{n}x_{n}^{m-1} + \\Delta_{n}(\\varPhi - \\phi x^{m}_{n})$, and the $x_{n}$-degrees of $m\\phi y_{n}x_{n}^{m-1}$ and $\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})$ are at most $m - 1$. Hence, $\\Delta_{n}(\\phi) = 0$. Thus, $\\phi$ belongs to $k[\\mathbf{y}][S_{n-1}]$ by (1). Write $\\phi = \\sum_{b,\\mathbf{u}} r^{\\prime}_{b,\\mathbf{u}}y^{b}\\hat{y}^{-\\mathbf{u}}L^{\\mathbf{u}}$, where the sum is taken over $b \\in (\\mathbb{Z}_{\\geq 0})^{n}$ and $u = (u_{i,j})_{i,j}$ with $u_{i,j} \\in \\mathbb{Z}_{\\geq 0}$ for $1 \\leq i < j \\leq n - 1$, $r^{\\prime}_{b,\\mathbf{u}} \\in k$ for each $b$ and $\\mathbf{u}$, and \n\n$\\hat{y}^{-u} = \\prod_{1\\leq i < j \\leq n-1} (y_{i}y_{j})^{-u_{i,j}}, \\quad L^{\\mathbf{u}} = \\prod_{1 \\leq i<j\\leq n-1} L_{i,j}^{u_{i,j}}$ for each $\\mathbf{U}$.\n\nWe may assume that $r_{b,\\mathbf{u}}^{\\prime} = 0$ if $\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}$ is not in $k[\\mathbf{y}]$. Let $\\eta(b, \\mathbf{u})$ be the image of $(b - |\\mathbf{u}|\\mathbf{e}_{n}, |\\mathbf{u}|\\mathbf{e}_{n})$ in $\\Gamma$, where $|\\mathbf{u}| = \\sum_{i,j} u_{i,j}\n$. Then, $\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}L^{\\mathbf{u}}$ belongs to $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\eta(b,\\mathbf{u})}$ for each $b$ and $\\mathbf{u}$, since $(y_{i}y_{j})^{-1} L_{i,j}$ belongs to $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\delta}$ for each $i, j$.  Since $\\phi$ is in $k[\\mathbf{y}][\\mathbf{x}]_{\\mu}$, and $\\mu$ is the image of $(a, (l - m)\\mathbf{e}_{n})$, we may assume that $r_{b,\\mathbf{u}}^{\\prime} = 0$ unless $|u| = l - m$ and $b = a + (l - m)\\mathbf{e}_{n}$. For each $\\mathbf{u}$ with $r_{\\mathbf{u}} := r^{\\prime}_{a + (l-m) \\mathbf{e}_{n},\\mathbf{u}}\\neq 0$, write $\\mathbf{y}^{a}y_{n}^{l-m}\\hat{y}^{-\\mathbf{u}} =\ny_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} y_{n}^{s}$, where $\\rho_{i}(u) \\in \\mathbb{Z}_{\\geq 0}$ for $i = 1, \\cdots , n - 1$, and $s = a_{n} + l - m$. Then, we have $\\phi = y_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}$. Since $|u| = l - m$, it follows that\n\n$$\\begin{equation}\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\n\\end{equation}$$\n\nNow, we show that $\\varPhi$ belongs to $k[\\mathbf{y}][S_{n}]$ by contradiction. By replacing $\\varPhi$ if necessary, we may assume that $m$ is the minimum among the $x_{n}$-degrees of elements of $\\ker \\Delta_{n}\\backslash k[\\mathbf{y}][S_{n}]$. To obtain a contradiction, it suffices to deduce that\n\n$$\\begin{equation}\nm \\geq 2l - \\sum_{i=1}^{n-1} a_{i}\n\\end{equation}$$\n\n\nIn fact, (3) implies that $\\sum_{i=1}^{n-1}\n\\rho_{i}(\\mathbf{u}) \\geq m$ by (2), so we have $\\sum_{i=1}^{n-1}\\rho_{i}^{\\prime}(\\mathbf{u})  = m$ for some\nintegers $0 \\leq \\rho^{\\prime}_{i}(\\mathbf{u}) \\leq \\rho_{i}(\\mathbf{u})$ for $i = 1, \\cdots, n - 1$ for each $u$. Then,\n\n$$\\varPhi^{\\prime} := y_{n}^{s} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}） - \\rho_{i}^{\\prime}(\\mathbf{u})} L_{n,i}^{\\rho_{i}^{\\prime}(\\mathbf{u}）} = y_{n}^{s} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}） - \\rho_{i}^{\\prime}(\\mathbf{u}） } (y_{i}x_{n} x_{n}y_{i})^{\\rho_{i}^{\\prime}(\\mathbf{u}） }$$\n\n\nis an element of $k[\\mathbf{y}][S_{n}]$ having $x_{n}$-degree $m$, in which the coefficient of $x_{n}^{m}$ is equal to $\\phi$. Hence, the $x_{n}$-degree of $\\varPhi - \\varPhi^{\\prime}$ is less than $m$. Since $\\varPhi - \\varPhi^{\\prime}$ is an element of $\\ker \\Delta_{n} \\backslash k[\\mathbf{y}][S_{n}]$, this contradicts the minimality of $m$.\n\nWe establish that (3) holds for any nonzero homogeneous element $\\varPhi$ of $\\ker \\Delta_{n}$ by contradiction.\nTake $\\varPhi$ which does not satisfy (3) so that $m$ would be the minimum among the $x_{n}$-degrees of such polynomials. Then, $t:= 2l - \\sum_{i=1}^{n-1}a_{i} -m$ is positive, and $\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) = m - t$ for each $\\mathbf{u}$ by (2). Hence, the $x_{n}$-degree of\n\n$$\\varPhi_{1}:= \\sum_{\\mathbf{u}} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} L_{n,i}^{\\rho_{i}(\\mathbf{u})} = \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} (y_{i}x_{n} - y_{n}x_{i})^{\\rho_{i}(\\mathbf{u})}$$\n\n\nis $m - t$. The coefficient of $x_{n}^{n-t}$ in $y_{n}^{s}\\varPhi_{1}$ is equal to $\\phi$, so the coefficient of $x_{n}^{m}$ in $y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$ is equal to that in $y_{1}^{t}\\varPhi$. Consequently, the $x_{n}$-degree $m^{\\prime}$ of $\\varPhi_{2}:= y_{1}^{t}\\varPhi - y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$ is less than $m$. We claim that $\\varPhi_{2} = 0$. In fact, if $\\gamma^{\\prime}$ is the image of $(a + t\\mathbf{e}_{1}, l\\mathbf{e}_{n})$ in $\\Gamma$, and $(a^{\\prime}_{1}, \\cdots , a_{n}^{\\prime}\n) := a + t\\mathbf{e}_{1}$, then $\\varPhi_{2}$ belongs to $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma^{\\prime}} \\cap \\ker \\Delta_{n}$, and\n\n\n$$2l - \\sum_{i=1}^{n-1} a^{\\prime}_{i} = 2l - \\sum_{i=1}^{n-1} a_{i} - t = m > m^{\\prime}$$\n\n\nThis implies that $\\varPhi_{2} = 0$ by the minimality of $m$. Hence, $y_{1}^{t} \\varPhi= y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$. Thus, $\\varPhi_{1}$ is divisible by $y_{1}$, since neither are $y_{n}$ and $L_{n,1}$. Recall that the kernel of a locally nilpotent derivation $D$ of an integral domain $R$ containing $Q$ is factorially closed in $R$, that is, $D(f g) =\n0$ implies $D(f ) = D(g) = 0$ for each $f, g \\in R \\ \\{0\\}$ (cf. [2, Proposition 1.3.32 (iii)]). Note\nthat $\\Delta_{n}$ is locally nilpotent, $\\Delta_{n}(\\varPhi_{1}) = 0$, $\\varPhi_{1} \\neq 0$ and $\\Delta_{n}(x_{n}) \\neq 0$. Hence, $\\varPhi_{1}$ is not divisible by $x_{n}$. By substituting zero for $x_{n}$, we obtain from $\\varPhi_{1}$ a nonzero polynomial\n\n$$\\sum_{\\mathbf{u}}r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} (- y_{n} x_{i})^{\\rho_{i}(\\mathbf{u})} = ( - y_{n} )^{m-i} \\varPsi, \\text{ where } \\varPsi = \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} x_{i}^{\\rho_{i}(\\mathbf{u})}.$$\n\nThen, $\\varPhi \\neq 0$, and $\\varPhi$ is divisible by $y_{1}$, since so is $\\phi_{1}$. Define $\\sigma \\in \\text{Aut}_{k} k[\\mathbf{y}][\\mathbf{x}]$ by $\\sigma(x_{i}) =\ny_{i}$ and $\\sigma(y_{i}) = x_{i}$ for $i = 1, \\cdots, n$. Then, $\\sigma(\\varPhi)$ is divisible by $x_{1}$. On the other hand, $\\sigma(L_{i,j}) = L_{j,i}$ and $\\sigma(x_{i}) = y_{i}$ are in $\\ker \\Delta_{n}$ for each $i, j$, so $\\sigma(\\varPsi)$ belongs to $\\ker \\Delta_{n}$. Thus, we have $\\sigma(\\varPsi) = 0$, because $x_{1}$ is not in $\\ker \\Delta_[n]$ and $\\ker \\Delta_{n}$ is factorially closed in $k[\\mathbf{y}][\\mathbf{x}]$. This contradicts that $\\varPsi \\neq 0$. Therefore, (3) holds true. Thereby, we have proved that $\\varPhi$ belongs to $k[\\mathbf{y}][S_{n}]$. This completes the proof of the conjecture.\n\n\n\n# Reference\n\n[1] Nowicki, Andrzej. Polynomial derivations and their rings of constants. Toruń: Uniwersytet Mikolaja Kopernika, 1994.\n\n[2] Khoury, Joseph. Locally nilpotent derivations and their rings of constants. University of Ottawa (Canada), 2001.\n\n[3] Kuroda, Shigeru. \"A Simple Proof of Nowicki's Conjecture on the Kernel of an Elementary Derivation.\" Tokyo Journal of Mathematics 32.1 (2009): 247-251.\n\n[4] Drensky V, Makar-Limanov L. The conjecture of Nowicki on Weitzenböck derivations of polynomial algebras[J]. Journal of Algebra and Its Applications, 2009, 8(01): 41-51.\n\n[5] Drensky, Vesselin. \"Another proof of the Nowicki conjecture.\" Tokyo Journal of Mathematics 43.2 (2020): 537-542.\n\n","slug":"Nowicki Conjecture","published":0,"updated":"2024-02-25T15:11:07.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5rx000qm8nx9p3a199r","content":"<p>Let <span class=\"math inline\">\\(A[\\mathbf{x}] = A[x_{1}, \\cdots,\r\nx_{n}\\)</span>] be the polynomial ring in n variables over an integral\r\ndomain <span class=\"math inline\">\\(A\\)</span>, <span class=\"math inline\">\\(D\\)</span> an <span class=\"math inline\">\\(A\\)</span>-<a href=\"https://en.wikipedia.org/wiki/Derivation_(differential_algebra)\">derivation</a>\r\nof <span class=\"math inline\">\\(A[\\mathbf{x}]\\)</span> and denote <span class=\"math display\">\\[D_{ij} := D(x_{i}) x_{j} - D(x_{j}) x_{i}, \\quad\r\n\\text{ for each } i, j \\in \\{1, \\cdots, n\\}.\\]</span></p>\r\n<h2 id=\"theorem-1-nowicki-1-conjecture-6.9.10\">Theorem 1 [Nowicki 1,\r\nConjecture 6.9.10]</h2>\r\n<p>Assume that <span class=\"math inline\">\\(k[\\mathbf{y}] = k[y_{1},\r\n\\cdots, y_{n}]\\)</span> is the polynomial ring in <span class=\"math inline\">\\(n\\)</span> variables over a field <span class=\"math inline\">\\(k\\)</span> of characteristic zero. If <span class=\"math inline\">\\(\\Delta_{n}\\)</span> is the <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>-derivation of <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span> defined by\r\n<span class=\"math inline\">\\(\\Delta_{n}(x_{i}) = y_{i}\\)</span> for <span class=\"math inline\">\\(i = 1, \\cdots, n\\)</span>, then <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> is generated by <span class=\"math inline\">\\(L^{\\Delta_{n}}_{ij}\\)</span> for <span class=\"math inline\">\\(1 ≤ i &lt; j ≤ n\\)</span> over <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>.</p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<p>We prove the conjecture by induction on <span class=\"math inline\">\\(n\\)</span>. The assertion is clear when <span class=\"math inline\">\\(n = 1\\)</span>. Assume that <span class=\"math inline\">\\(n \\geq 2\\)</span>, and let <span class=\"math inline\">\\(S_{l}\\)</span> be the set of <span class=\"math inline\">\\(L_{i,j} := L^{\\Delta_{n}}_{i,j}\\)</span> for <span class=\"math inline\">\\(1 \\leq i &lt; j \\leq l\\)</span> for each <span class=\"math inline\">\\(l \\leq n\\)</span>. By the assumption on induction,\r\n<span class=\"math inline\">\\(\\ker \\Delta_{n-1}\\)</span> is generated by\r\n<span class=\"math inline\">\\(S_{n-1}\\)</span> over <span class=\"math inline\">\\(k[\\mathbf{y}^{\\prime}] := k[y_{1}, \\cdots ,\r\ny_{n-1}]\\)</span>, since <span class=\"math inline\">\\(L^{\\Delta_{n-1}}_{i,j} =\r\nL^{\\Delta_{n}}_{i,j}\\)</span> for each <span class=\"math inline\">\\(i,\r\nj\\)</span>. As discussed in Section 1, the <span class=\"math inline\">\\(k[\\mathbf{y}^{\\prime}]\\)</span>-derivation <span class=\"math inline\">\\(\\Delta_{n-1}\\)</span> naturally extends to a <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>-derivation <span class=\"math inline\">\\((\\Delta_{n-1})_{k[\\mathbf{y}]}\\)</span> of <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}^{\\prime}] :=\r\nk[\\mathbf{y}][x_{1}, \\cdots, x_{n-1}]\\)</span>. Then, <span class=\"math inline\">\\((\\Delta_{n-1})k[\\mathbf{y}] =\r\n\\Delta_{n}|_{k[\\mathbf{y}][\\mathbf{x}^{\\prime}]}\\)</span>, so we have\r\n<span class=\"math inline\">\\(\\ker(\\Delta_{n-1})k[\\mathbf{y}] =\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n}\\)</span>.\r\nMoreover, <span class=\"math inline\">\\(\\ker(\\Delta_{n-1})k[\\mathbf{y}] =\r\nk[\\mathbf{y}] \\otimes_{k[\\mathbf{y}^{\\prime}]} \\ker\r\n\\Delta_{n-1}\\)</span>, since <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span> is flat over <span class=\"math inline\">\\(k[\\mathbf{y}^{\\prime}]\\)</span>. Thus, we get</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n} =\r\nk[\\mathbf{y}][S_{n-1}].\r\n\\end{equation}\\]</span></p>\r\n<p>Let <span class=\"math inline\">\\(\\mathbf{e}_{1}, \\cdots ,\r\n\\mathbf{e}_{n}\\)</span> be the coordinate unit vectors of <span class=\"math inline\">\\(\\mathbb{R}^{n}\\)</span>, <span class=\"math inline\">\\(M\\)</span> the <span class=\"math inline\">\\(\\mathbb{Z}\\)</span>-submodule of <span class=\"math inline\">\\((\\mathbb{Z}^{n})^{2}\\)</span> generated by <span class=\"math inline\">\\((\\mathbf{e}_{j} - \\mathbf{e}_{i}, \\mathbf{e}_{i} -\r\n\\mathbf{e}_{j})\\)</span> for <span class=\"math inline\">\\(1 \\leq i &lt; j\r\n\\leq n\\)</span>, and <span class=\"math inline\">\\(\\Gamma =\r\n(\\mathbb{Z}^{n})^{2}/M\\)</span>. Then, <span class=\"math inline\">\\(\\Gamma\\)</span>-gradings are defined on <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span> and <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}] :=\r\nk[\\mathbf{y}][\\mathbf{x}][(y_{1} \\cdots y_{n})^{-1}]\\)</span> as\r\nfollows. Here, a <span class=\"math inline\">\\(k\\)</span>-algebra <span class=\"math inline\">\\(R\\)</span> is said to be <span class=\"math inline\">\\(\\Gamma\\)</span>-graded if there exists a <span class=\"math inline\">\\(k\\)</span>-vector subspace <span class=\"math inline\">\\(R_{\\gamma}\\)</span> of <span class=\"math inline\">\\(R\\)</span> for each <span class=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span> such that <span class=\"math inline\">\\(R = \\oplus_{\\gamma \\in \\Gamma} R_{\\gamma}\\)</span>\r\nand <span class=\"math inline\">\\(R_{\\gamma} R_{\\mu} \\subset R_{\\gamma +\r\n\\mu}\\)</span> for <span class=\"math inline\">\\(\\gamma, \\mu \\in\r\n\\Gamma\\)</span>. Let <span class=\"math inline\">\\(\\mathbb{Z}_{\\geq\r\n0}\\)</span> denote the set of nonnegative integers, and <span class=\"math inline\">\\(\\mathbf{y}^{a} = y^{a_{1}} \\cdots\r\ny^{a_{n}}\\)</span> and <span class=\"math inline\">\\(\\mathbf{x}_{b} =\r\nx^{b_{1}} \\cdots x^{b_{n}}\\)</span> for <span class=\"math inline\">\\(a =\r\n(a_{1}, \\cdots , a_{n})\\)</span> and <span class=\"math inline\">\\(b =\r\n(b_{1}, \\cdots , b_{n})\\)</span>. For each <span class=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span>, we define <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma}\\)</span> (resp.\r\n<span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\gamma}\\)</span>) to be the <span class=\"math inline\">\\(k\\)</span>-vector space generated by <span class=\"math inline\">\\(\\mathbf{y}^{a}\\mathbf{x}^{b}\\)</span> for $a, b\r\n(_{})^{n} (resp. <span class=\"math inline\">\\(a \\in \\mathbb{Z}^{n}, b \\in\r\n(\\mathbb{Z}_{\\geq 0})^{n}\\)</span>) such that the image of <span class=\"math inline\">\\((a, b)\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span> is equal to <span class=\"math inline\">\\(\\gamma\\)</span>. Then, <span class=\"math inline\">\\(\\Gamma\\)</span>-gradings are defined on <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span> and <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]\\)</span>. Note\r\nthat <span class=\"math inline\">\\(\\Delta_{n}(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma})\\)</span>\r\nis contained in <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma -\r\n\\delta}\\)</span> for each <span class=\"math inline\">\\(\\gamma \\in\r\n\\Gamma\\)</span>, where <span class=\"math inline\">\\(\\delta\\)</span> is\r\nthe image of <span class=\"math inline\">\\((-\\mathbb{e}_{n},\r\n\\mathbb{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span>.\r\nFrom this, we know that</p>\r\n<p><span class=\"math display\">\\[\\ker \\Delta_{n} = \\bigoplus_{\\gamma \\in\r\n\\Gamma} k[\\mathbf{y}] [ \\mathbf{x}]_{\\gamma} \\cap \\ker\r\n\\Delta_{n}\\]</span></p>\r\n<p>Hence, we are reduced to showing that each <span class=\"math inline\">\\(0 \\neq \\varPhi \\in\r\nk[\\mathbf{y}][\\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}\\)</span> belongs\r\nto <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> for <span class=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span>. We may find <span class=\"math inline\">\\(a = (a_{1}, \\cdots , a_{n}) \\in\r\n\\mathbb{Z}^{n}\\)</span> and <span class=\"math inline\">\\(l \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> such that the image of <span class=\"math inline\">\\((a, l\\mathbf{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span> is equal to <span class=\"math inline\">\\(\\gamma\\)</span>. Let <span class=\"math inline\">\\(m\\)</span> be the <span class=\"math inline\">\\(x_{n}\\)</span>-degree of <span class=\"math inline\">\\(\\varPhi\\)</span>, where <span class=\"math inline\">\\(0 \\leq m \\leq l\\)</span>, and <span class=\"math inline\">\\(\\phi \\in\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}]\\)</span> the coefficient of <span class=\"math inline\">\\(x_{n}^{m}\\)</span> in <span class=\"math inline\">\\(\\varPhi\\)</span>. Then, <span class=\"math inline\">\\(\\phi\\)</span> belongs to <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\mu}\\)</span>, where\r\n<span class=\"math inline\">\\(\\mu\\)</span> is the image of <span class=\"math inline\">\\((a, (l −m)\\mathbf{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span>. Furthermore, <span class=\"math inline\">\\(0 = \\Delta_{n}(\\varPhi) =\r\n\\Delta_{n}(\\varphi)x^{m}_{n} + m\\phi y_{n}x_{n}^{m-1} +\r\n\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})\\)</span>, and the <span class=\"math inline\">\\(x_{n}\\)</span>-degrees of <span class=\"math inline\">\\(m\\phi y_{n}x_{n}^{m-1}\\)</span> and <span class=\"math inline\">\\(\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})\\)</span> are\r\nat most <span class=\"math inline\">\\(m - 1\\)</span>. Hence, <span class=\"math inline\">\\(\\Delta_{n}(\\phi) = 0\\)</span>. Thus, <span class=\"math inline\">\\(\\phi\\)</span> belongs to <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n-1}]\\)</span> by (1). Write\r\n<span class=\"math inline\">\\(\\phi = \\sum_{b,\\mathbf{u}}\r\nr^{\\prime}_{b,\\mathbf{u}}y^{b}\\hat{y}^{-\\mathbf{u}}L^{\\mathbf{u}}\\)</span>,\r\nwhere the sum is taken over <span class=\"math inline\">\\(b \\in\r\n(\\mathbb{Z}_{\\geq 0})^{n}\\)</span> and <span class=\"math inline\">\\(u =\r\n(u_{i,j})_{i,j}\\)</span> with <span class=\"math inline\">\\(u_{i,j} \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> for <span class=\"math inline\">\\(1 \\leq i\r\n&lt; j \\leq n - 1\\)</span>, <span class=\"math inline\">\\(r^{\\prime}_{b,\\mathbf{u}} \\in k\\)</span> for each\r\n<span class=\"math inline\">\\(b\\)</span> and <span class=\"math inline\">\\(\\mathbf{u}\\)</span>, and</p>\r\n<p><span class=\"math inline\">\\(\\hat{y}^{-u} = \\prod_{1\\leq i &lt; j \\leq\r\nn-1} (y_{i}y_{j})^{-u_{i,j}}, \\quad L^{\\mathbf{u}} = \\prod_{1 \\leq\r\ni&lt;j\\leq n-1} L_{i,j}^{u_{i,j}}\\)</span> for each <span class=\"math inline\">\\(\\mathbf{U}\\)</span>.</p>\r\n<p>We may assume that <span class=\"math inline\">\\(r_{b,\\mathbf{u}}^{\\prime} = 0\\)</span> if <span class=\"math inline\">\\(\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}\\)</span>\r\nis not in <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>. Let <span class=\"math inline\">\\(\\eta(b, \\mathbf{u})\\)</span> be the image of <span class=\"math inline\">\\((b - |\\mathbf{u}|\\mathbf{e}_{n},\r\n|\\mathbf{u}|\\mathbf{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span>, where <span class=\"math inline\">\\(|\\mathbf{u}| = \\sum_{i,j} u_{i,j}\\)</span>. Then,\r\n<span class=\"math inline\">\\(\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}L^{\\mathbf{u}}\\)</span>\r\nbelongs to <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\eta(b,\\mathbf{u})}\\)</span> for each <span class=\"math inline\">\\(b\\)</span> and <span class=\"math inline\">\\(\\mathbf{u}\\)</span>, since <span class=\"math inline\">\\((y_{i}y_{j})^{-1} L_{i,j}\\)</span> belongs to\r\n<span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\delta}\\)</span> for each <span class=\"math inline\">\\(i, j\\)</span>. Since <span class=\"math inline\">\\(\\phi\\)</span> is in <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\mu}\\)</span>, and\r\n<span class=\"math inline\">\\(\\mu\\)</span> is the image of <span class=\"math inline\">\\((a, (l - m)\\mathbf{e}_{n})\\)</span>, we may assume\r\nthat <span class=\"math inline\">\\(r_{b,\\mathbf{u}}^{\\prime} = 0\\)</span>\r\nunless <span class=\"math inline\">\\(|u| = l - m\\)</span> and <span class=\"math inline\">\\(b = a + (l - m)\\mathbf{e}_{n}\\)</span>. For each\r\n<span class=\"math inline\">\\(\\mathbf{u}\\)</span> with <span class=\"math inline\">\\(r_{\\mathbf{u}} := r^{\\prime}_{a + (l-m)\r\n\\mathbf{e}_{n},\\mathbf{u}}\\neq 0\\)</span>, write <span class=\"math inline\">\\(\\mathbf{y}^{a}y_{n}^{l-m}\\hat{y}^{-\\mathbf{u}} =\r\ny_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots y_{n-1}^{\\rho_{n-1}(\\mathbf{u})}\r\ny_{n}^{s}\\)</span>, where <span class=\"math inline\">\\(\\rho_{i}(u) \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> for <span class=\"math inline\">\\(i = 1,\r\n\\cdots , n - 1\\)</span>, and <span class=\"math inline\">\\(s = a_{n} + l -\r\nm\\)</span>. Then, we have <span class=\"math inline\">\\(\\phi =\r\ny_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})}\r\n\\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}\\)</span>. Since\r\n<span class=\"math inline\">\\(|u| = l - m\\)</span>, it follows that</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\r\n\\end{equation}\\]</span></p>\r\n<p>Now, we show that <span class=\"math inline\">\\(\\varPhi\\)</span>\r\nbelongs to <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> by\r\ncontradiction. By replacing <span class=\"math inline\">\\(\\varPhi\\)</span>\r\nif necessary, we may assume that <span class=\"math inline\">\\(m\\)</span>\r\nis the minimum among the <span class=\"math inline\">\\(x_{n}\\)</span>-degrees of elements of <span class=\"math inline\">\\(\\ker \\Delta_{n}\\backslash\r\nk[\\mathbf{y}][S_{n}]\\)</span>. To obtain a contradiction, it suffices to\r\ndeduce that</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm \\geq 2l - \\sum_{i=1}^{n-1} a_{i}\r\n\\end{equation}\\]</span></p>\r\n<p>In fact, (3) implies that <span class=\"math inline\">\\(\\sum_{i=1}^{n-1}\r\n\\rho_{i}(\\mathbf{u}) \\geq m\\)</span> by (2), so we have <span class=\"math inline\">\\(\\sum_{i=1}^{n-1}\\rho_{i}^{\\prime}(\\mathbf{u})  =\r\nm\\)</span> for some integers <span class=\"math inline\">\\(0 \\leq\r\n\\rho^{\\prime}_{i}(\\mathbf{u}) \\leq \\rho_{i}(\\mathbf{u})\\)</span> for\r\n<span class=\"math inline\">\\(i = 1, \\cdots, n - 1\\)</span> for each <span class=\"math inline\">\\(u\\)</span>. Then,</p>\r\n<p><span class=\"math display\">\\[\\varPhi^{\\prime} := y_{n}^{s}\r\n\\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\ny_{i}^{\\rho_{i}(\\mathbf{u}） - \\rho_{i}^{\\prime}(\\mathbf{u})}\r\nL_{n,i}^{\\rho_{i}^{\\prime}(\\mathbf{u}）} = y_{n}^{s} \\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}） -\r\n\\rho_{i}^{\\prime}(\\mathbf{u}） } (y_{i}x_{n}\r\nx_{n}y_{i})^{\\rho_{i}^{\\prime}(\\mathbf{u}） }\\]</span></p>\r\n<p>is an element of <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> having <span class=\"math inline\">\\(x_{n}\\)</span>-degree <span class=\"math inline\">\\(m\\)</span>, in which the coefficient of <span class=\"math inline\">\\(x_{n}^{m}\\)</span> is equal to <span class=\"math inline\">\\(\\phi\\)</span>. Hence, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree of <span class=\"math inline\">\\(\\varPhi - \\varPhi^{\\prime}\\)</span> is less than\r\n<span class=\"math inline\">\\(m\\)</span>. Since <span class=\"math inline\">\\(\\varPhi - \\varPhi^{\\prime}\\)</span> is an element\r\nof <span class=\"math inline\">\\(\\ker \\Delta_{n} \\backslash\r\nk[\\mathbf{y}][S_{n}]\\)</span>, this contradicts the minimality of <span class=\"math inline\">\\(m\\)</span>.</p>\r\n<p>We establish that (3) holds for any nonzero homogeneous element <span class=\"math inline\">\\(\\varPhi\\)</span> of <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> by contradiction. Take\r\n<span class=\"math inline\">\\(\\varPhi\\)</span> which does not satisfy (3)\r\nso that <span class=\"math inline\">\\(m\\)</span> would be the minimum\r\namong the <span class=\"math inline\">\\(x_{n}\\)</span>-degrees of such\r\npolynomials. Then, <span class=\"math inline\">\\(t:= 2l -\r\n\\sum_{i=1}^{n-1}a_{i} -m\\)</span> is positive, and <span class=\"math inline\">\\(\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) = m -\r\nt\\)</span> for each <span class=\"math inline\">\\(\\mathbf{u}\\)</span> by\r\n(2). Hence, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree of</p>\r\n<p><span class=\"math display\">\\[\\varPhi_{1}:= \\sum_{\\mathbf{u}}\r\n\\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\nL_{n,i}^{\\rho_{i}(\\mathbf{u})} = \\sum_{\\mathbf{u}} r_{\\mathbf{u}}\r\nL^{\\mathbf{u}} \\prod_{i=1}^{n-1} (y_{i}x_{n} -\r\ny_{n}x_{i})^{\\rho_{i}(\\mathbf{u})}\\]</span></p>\r\n<p>is <span class=\"math inline\">\\(m - t\\)</span>. The coefficient of\r\n<span class=\"math inline\">\\(x_{n}^{n-t}\\)</span> in <span class=\"math inline\">\\(y_{n}^{s}\\varPhi_{1}\\)</span> is equal to <span class=\"math inline\">\\(\\phi\\)</span>, so the coefficient of <span class=\"math inline\">\\(x_{n}^{m}\\)</span> in <span class=\"math inline\">\\(y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span> is equal\r\nto that in <span class=\"math inline\">\\(y_{1}^{t}\\varPhi\\)</span>.\r\nConsequently, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree\r\n<span class=\"math inline\">\\(m^{\\prime}\\)</span> of <span class=\"math inline\">\\(\\varPhi_{2}:= y_{1}^{t}\\varPhi -\r\ny_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span> is less than <span class=\"math inline\">\\(m\\)</span>. We claim that <span class=\"math inline\">\\(\\varPhi_{2} = 0\\)</span>. In fact, if <span class=\"math inline\">\\(\\gamma^{\\prime}\\)</span> is the image of <span class=\"math inline\">\\((a + t\\mathbf{e}_{1}, l\\mathbf{e}_{n})\\)</span> in\r\n<span class=\"math inline\">\\(\\Gamma\\)</span>, and <span class=\"math inline\">\\((a^{\\prime}_{1}, \\cdots , a_{n}^{\\prime}\r\n) := a + t\\mathbf{e}_{1}\\)</span>, then <span class=\"math inline\">\\(\\varPhi_{2}\\)</span> belongs to <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma^{\\prime}} \\cap\r\n\\ker \\Delta_{n}\\)</span>, and</p>\r\n<p><span class=\"math display\">\\[2l - \\sum_{i=1}^{n-1} a^{\\prime}_{i} =\r\n2l - \\sum_{i=1}^{n-1} a_{i} - t = m &gt; m^{\\prime}\\]</span></p>\r\n<p>This implies that <span class=\"math inline\">\\(\\varPhi_{2} =\r\n0\\)</span> by the minimality of <span class=\"math inline\">\\(m\\)</span>.\r\nHence, <span class=\"math inline\">\\(y_{1}^{t} \\varPhi=\r\ny_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span>. Thus, <span class=\"math inline\">\\(\\varPhi_{1}\\)</span> is divisible by <span class=\"math inline\">\\(y_{1}\\)</span>, since neither are <span class=\"math inline\">\\(y_{n}\\)</span> and <span class=\"math inline\">\\(L_{n,1}\\)</span>. Recall that the kernel of a\r\nlocally nilpotent derivation <span class=\"math inline\">\\(D\\)</span> of\r\nan integral domain <span class=\"math inline\">\\(R\\)</span> containing\r\n<span class=\"math inline\">\\(Q\\)</span> is factorially closed in <span class=\"math inline\">\\(R\\)</span>, that is, <span class=\"math inline\">\\(D(f g) =\r\n0\\)</span> implies <span class=\"math inline\">\\(D(f ) = D(g) = 0\\)</span>\r\nfor each <span class=\"math inline\">\\(f, g \\in R \\ \\{0\\}\\)</span> (cf.\r\n[2, Proposition 1.3.32 (iii)]). Note that <span class=\"math inline\">\\(\\Delta_{n}\\)</span> is locally nilpotent, <span class=\"math inline\">\\(\\Delta_{n}(\\varPhi_{1}) = 0\\)</span>, <span class=\"math inline\">\\(\\varPhi_{1} \\neq 0\\)</span> and <span class=\"math inline\">\\(\\Delta_{n}(x_{n}) \\neq 0\\)</span>. Hence, <span class=\"math inline\">\\(\\varPhi_{1}\\)</span> is not divisible by <span class=\"math inline\">\\(x_{n}\\)</span>. By substituting zero for <span class=\"math inline\">\\(x_{n}\\)</span>, we obtain from <span class=\"math inline\">\\(\\varPhi_{1}\\)</span> a nonzero polynomial</p>\r\n<p><span class=\"math display\">\\[\\sum_{\\mathbf{u}}r_{\\mathbf{u}}\r\nL^{\\mathbf{u}} \\prod_{i=1}^{n-1} (- y_{n} x_{i})^{\\rho_{i}(\\mathbf{u})}\r\n= ( - y_{n} )^{m-i} \\varPsi, \\text{ where } \\varPsi = \\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\nx_{i}^{\\rho_{i}(\\mathbf{u})}.\\]</span></p>\r\n<p>Then, <span class=\"math inline\">\\(\\varPhi \\neq 0\\)</span>, and <span class=\"math inline\">\\(\\varPhi\\)</span> is divisible by <span class=\"math inline\">\\(y_{1}\\)</span>, since so is <span class=\"math inline\">\\(\\phi_{1}\\)</span>. Define <span class=\"math inline\">\\(\\sigma \\in \\text{Aut}_{k}\r\nk[\\mathbf{y}][\\mathbf{x}]\\)</span> by <span class=\"math inline\">\\(\\sigma(x_{i}) =\r\ny_{i}\\)</span> and <span class=\"math inline\">\\(\\sigma(y_{i}) =\r\nx_{i}\\)</span> for <span class=\"math inline\">\\(i = 1, \\cdots,\r\nn\\)</span>. Then, <span class=\"math inline\">\\(\\sigma(\\varPhi)\\)</span>\r\nis divisible by <span class=\"math inline\">\\(x_{1}\\)</span>. On the other\r\nhand, <span class=\"math inline\">\\(\\sigma(L_{i,j}) = L_{j,i}\\)</span> and\r\n<span class=\"math inline\">\\(\\sigma(x_{i}) = y_{i}\\)</span> are in <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> for each <span class=\"math inline\">\\(i, j\\)</span>, so <span class=\"math inline\">\\(\\sigma(\\varPsi)\\)</span> belongs to <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span>. Thus, we have <span class=\"math inline\">\\(\\sigma(\\varPsi) = 0\\)</span>, because <span class=\"math inline\">\\(x_{1}\\)</span> is not in <span class=\"math inline\">\\(\\ker \\Delta_[n]\\)</span> and <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> is factorially closed in\r\n<span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span>. This\r\ncontradicts that <span class=\"math inline\">\\(\\varPsi \\neq 0\\)</span>.\r\nTherefore, (3) holds true. Thereby, we have proved that <span class=\"math inline\">\\(\\varPhi\\)</span> belongs to <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span>. This completes the\r\nproof of the conjecture.</p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Nowicki, Andrzej. Polynomial derivations and their rings of\r\nconstants. Toruń: Uniwersytet Mikolaja Kopernika, 1994.</p>\r\n<p>[2] Khoury, Joseph. Locally nilpotent derivations and their rings of\r\nconstants. University of Ottawa (Canada), 2001.</p>\r\n<p>[3] Kuroda, Shigeru. \"A Simple Proof of Nowicki's Conjecture on the\r\nKernel of an Elementary Derivation.\" Tokyo Journal of Mathematics 32.1\r\n(2009): 247-251.</p>\r\n<p>[4] Drensky V, Makar-Limanov L. The conjecture of Nowicki on\r\nWeitzenböck derivations of polynomial algebras[J]. Journal of Algebra\r\nand Its Applications, 2009, 8(01): 41-51.</p>\r\n<p>[5] Drensky, Vesselin. \"Another proof of the Nowicki conjecture.\"\r\nTokyo Journal of Mathematics 43.2 (2020): 537-542.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>Let <span class=\"math inline\">\\(A[\\mathbf{x}] = A[x_{1}, \\cdots,\r\nx_{n}\\)</span>] be the polynomial ring in n variables over an integral\r\ndomain <span class=\"math inline\">\\(A\\)</span>, <span class=\"math inline\">\\(D\\)</span> an <span class=\"math inline\">\\(A\\)</span>-<a href=\"https://en.wikipedia.org/wiki/Derivation_(differential_algebra)\">derivation</a>\r\nof <span class=\"math inline\">\\(A[\\mathbf{x}]\\)</span> and denote <span class=\"math display\">\\[D_{ij} := D(x_{i}) x_{j} - D(x_{j}) x_{i}, \\quad\r\n\\text{ for each } i, j \\in \\{1, \\cdots, n\\}.\\]</span></p>\r\n<h2 id=\"theorem-1-nowicki-1-conjecture-6.9.10\">Theorem 1 [Nowicki 1,\r\nConjecture 6.9.10]</h2>\r\n<p>Assume that <span class=\"math inline\">\\(k[\\mathbf{y}] = k[y_{1},\r\n\\cdots, y_{n}]\\)</span> is the polynomial ring in <span class=\"math inline\">\\(n\\)</span> variables over a field <span class=\"math inline\">\\(k\\)</span> of characteristic zero. If <span class=\"math inline\">\\(\\Delta_{n}\\)</span> is the <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>-derivation of <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span> defined by\r\n<span class=\"math inline\">\\(\\Delta_{n}(x_{i}) = y_{i}\\)</span> for <span class=\"math inline\">\\(i = 1, \\cdots, n\\)</span>, then <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> is generated by <span class=\"math inline\">\\(L^{\\Delta_{n}}_{ij}\\)</span> for <span class=\"math inline\">\\(1 ≤ i &lt; j ≤ n\\)</span> over <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>.</p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<p>We prove the conjecture by induction on <span class=\"math inline\">\\(n\\)</span>. The assertion is clear when <span class=\"math inline\">\\(n = 1\\)</span>. Assume that <span class=\"math inline\">\\(n \\geq 2\\)</span>, and let <span class=\"math inline\">\\(S_{l}\\)</span> be the set of <span class=\"math inline\">\\(L_{i,j} := L^{\\Delta_{n}}_{i,j}\\)</span> for <span class=\"math inline\">\\(1 \\leq i &lt; j \\leq l\\)</span> for each <span class=\"math inline\">\\(l \\leq n\\)</span>. By the assumption on induction,\r\n<span class=\"math inline\">\\(\\ker \\Delta_{n-1}\\)</span> is generated by\r\n<span class=\"math inline\">\\(S_{n-1}\\)</span> over <span class=\"math inline\">\\(k[\\mathbf{y}^{\\prime}] := k[y_{1}, \\cdots ,\r\ny_{n-1}]\\)</span>, since <span class=\"math inline\">\\(L^{\\Delta_{n-1}}_{i,j} =\r\nL^{\\Delta_{n}}_{i,j}\\)</span> for each <span class=\"math inline\">\\(i,\r\nj\\)</span>. As discussed in Section 1, the <span class=\"math inline\">\\(k[\\mathbf{y}^{\\prime}]\\)</span>-derivation <span class=\"math inline\">\\(\\Delta_{n-1}\\)</span> naturally extends to a <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>-derivation <span class=\"math inline\">\\((\\Delta_{n-1})_{k[\\mathbf{y}]}\\)</span> of <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}^{\\prime}] :=\r\nk[\\mathbf{y}][x_{1}, \\cdots, x_{n-1}]\\)</span>. Then, <span class=\"math inline\">\\((\\Delta_{n-1})k[\\mathbf{y}] =\r\n\\Delta_{n}|_{k[\\mathbf{y}][\\mathbf{x}^{\\prime}]}\\)</span>, so we have\r\n<span class=\"math inline\">\\(\\ker(\\Delta_{n-1})k[\\mathbf{y}] =\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n}\\)</span>.\r\nMoreover, <span class=\"math inline\">\\(\\ker(\\Delta_{n-1})k[\\mathbf{y}] =\r\nk[\\mathbf{y}] \\otimes_{k[\\mathbf{y}^{\\prime}]} \\ker\r\n\\Delta_{n-1}\\)</span>, since <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span> is flat over <span class=\"math inline\">\\(k[\\mathbf{y}^{\\prime}]\\)</span>. Thus, we get</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n} =\r\nk[\\mathbf{y}][S_{n-1}].\r\n\\end{equation}\\]</span></p>\r\n<p>Let <span class=\"math inline\">\\(\\mathbf{e}_{1}, \\cdots ,\r\n\\mathbf{e}_{n}\\)</span> be the coordinate unit vectors of <span class=\"math inline\">\\(\\mathbb{R}^{n}\\)</span>, <span class=\"math inline\">\\(M\\)</span> the <span class=\"math inline\">\\(\\mathbb{Z}\\)</span>-submodule of <span class=\"math inline\">\\((\\mathbb{Z}^{n})^{2}\\)</span> generated by <span class=\"math inline\">\\((\\mathbf{e}_{j} - \\mathbf{e}_{i}, \\mathbf{e}_{i} -\r\n\\mathbf{e}_{j})\\)</span> for <span class=\"math inline\">\\(1 \\leq i &lt; j\r\n\\leq n\\)</span>, and <span class=\"math inline\">\\(\\Gamma =\r\n(\\mathbb{Z}^{n})^{2}/M\\)</span>. Then, <span class=\"math inline\">\\(\\Gamma\\)</span>-gradings are defined on <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span> and <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}] :=\r\nk[\\mathbf{y}][\\mathbf{x}][(y_{1} \\cdots y_{n})^{-1}]\\)</span> as\r\nfollows. Here, a <span class=\"math inline\">\\(k\\)</span>-algebra <span class=\"math inline\">\\(R\\)</span> is said to be <span class=\"math inline\">\\(\\Gamma\\)</span>-graded if there exists a <span class=\"math inline\">\\(k\\)</span>-vector subspace <span class=\"math inline\">\\(R_{\\gamma}\\)</span> of <span class=\"math inline\">\\(R\\)</span> for each <span class=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span> such that <span class=\"math inline\">\\(R = \\oplus_{\\gamma \\in \\Gamma} R_{\\gamma}\\)</span>\r\nand <span class=\"math inline\">\\(R_{\\gamma} R_{\\mu} \\subset R_{\\gamma +\r\n\\mu}\\)</span> for <span class=\"math inline\">\\(\\gamma, \\mu \\in\r\n\\Gamma\\)</span>. Let <span class=\"math inline\">\\(\\mathbb{Z}_{\\geq\r\n0}\\)</span> denote the set of nonnegative integers, and <span class=\"math inline\">\\(\\mathbf{y}^{a} = y^{a_{1}} \\cdots\r\ny^{a_{n}}\\)</span> and <span class=\"math inline\">\\(\\mathbf{x}_{b} =\r\nx^{b_{1}} \\cdots x^{b_{n}}\\)</span> for <span class=\"math inline\">\\(a =\r\n(a_{1}, \\cdots , a_{n})\\)</span> and <span class=\"math inline\">\\(b =\r\n(b_{1}, \\cdots , b_{n})\\)</span>. For each <span class=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span>, we define <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma}\\)</span> (resp.\r\n<span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\gamma}\\)</span>) to be the <span class=\"math inline\">\\(k\\)</span>-vector space generated by <span class=\"math inline\">\\(\\mathbf{y}^{a}\\mathbf{x}^{b}\\)</span> for $a, b\r\n(_{})^{n} (resp. <span class=\"math inline\">\\(a \\in \\mathbb{Z}^{n}, b \\in\r\n(\\mathbb{Z}_{\\geq 0})^{n}\\)</span>) such that the image of <span class=\"math inline\">\\((a, b)\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span> is equal to <span class=\"math inline\">\\(\\gamma\\)</span>. Then, <span class=\"math inline\">\\(\\Gamma\\)</span>-gradings are defined on <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span> and <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]\\)</span>. Note\r\nthat <span class=\"math inline\">\\(\\Delta_{n}(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma})\\)</span>\r\nis contained in <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma -\r\n\\delta}\\)</span> for each <span class=\"math inline\">\\(\\gamma \\in\r\n\\Gamma\\)</span>, where <span class=\"math inline\">\\(\\delta\\)</span> is\r\nthe image of <span class=\"math inline\">\\((-\\mathbb{e}_{n},\r\n\\mathbb{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span>.\r\nFrom this, we know that</p>\r\n<p><span class=\"math display\">\\[\\ker \\Delta_{n} = \\bigoplus_{\\gamma \\in\r\n\\Gamma} k[\\mathbf{y}] [ \\mathbf{x}]_{\\gamma} \\cap \\ker\r\n\\Delta_{n}\\]</span></p>\r\n<p>Hence, we are reduced to showing that each <span class=\"math inline\">\\(0 \\neq \\varPhi \\in\r\nk[\\mathbf{y}][\\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}\\)</span> belongs\r\nto <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> for <span class=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span>. We may find <span class=\"math inline\">\\(a = (a_{1}, \\cdots , a_{n}) \\in\r\n\\mathbb{Z}^{n}\\)</span> and <span class=\"math inline\">\\(l \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> such that the image of <span class=\"math inline\">\\((a, l\\mathbf{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span> is equal to <span class=\"math inline\">\\(\\gamma\\)</span>. Let <span class=\"math inline\">\\(m\\)</span> be the <span class=\"math inline\">\\(x_{n}\\)</span>-degree of <span class=\"math inline\">\\(\\varPhi\\)</span>, where <span class=\"math inline\">\\(0 \\leq m \\leq l\\)</span>, and <span class=\"math inline\">\\(\\phi \\in\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}]\\)</span> the coefficient of <span class=\"math inline\">\\(x_{n}^{m}\\)</span> in <span class=\"math inline\">\\(\\varPhi\\)</span>. Then, <span class=\"math inline\">\\(\\phi\\)</span> belongs to <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\mu}\\)</span>, where\r\n<span class=\"math inline\">\\(\\mu\\)</span> is the image of <span class=\"math inline\">\\((a, (l −m)\\mathbf{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span>. Furthermore, <span class=\"math inline\">\\(0 = \\Delta_{n}(\\varPhi) =\r\n\\Delta_{n}(\\varphi)x^{m}_{n} + m\\phi y_{n}x_{n}^{m-1} +\r\n\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})\\)</span>, and the <span class=\"math inline\">\\(x_{n}\\)</span>-degrees of <span class=\"math inline\">\\(m\\phi y_{n}x_{n}^{m-1}\\)</span> and <span class=\"math inline\">\\(\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})\\)</span> are\r\nat most <span class=\"math inline\">\\(m - 1\\)</span>. Hence, <span class=\"math inline\">\\(\\Delta_{n}(\\phi) = 0\\)</span>. Thus, <span class=\"math inline\">\\(\\phi\\)</span> belongs to <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n-1}]\\)</span> by (1). Write\r\n<span class=\"math inline\">\\(\\phi = \\sum_{b,\\mathbf{u}}\r\nr^{\\prime}_{b,\\mathbf{u}}y^{b}\\hat{y}^{-\\mathbf{u}}L^{\\mathbf{u}}\\)</span>,\r\nwhere the sum is taken over <span class=\"math inline\">\\(b \\in\r\n(\\mathbb{Z}_{\\geq 0})^{n}\\)</span> and <span class=\"math inline\">\\(u =\r\n(u_{i,j})_{i,j}\\)</span> with <span class=\"math inline\">\\(u_{i,j} \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> for <span class=\"math inline\">\\(1 \\leq i\r\n&lt; j \\leq n - 1\\)</span>, <span class=\"math inline\">\\(r^{\\prime}_{b,\\mathbf{u}} \\in k\\)</span> for each\r\n<span class=\"math inline\">\\(b\\)</span> and <span class=\"math inline\">\\(\\mathbf{u}\\)</span>, and</p>\r\n<p><span class=\"math inline\">\\(\\hat{y}^{-u} = \\prod_{1\\leq i &lt; j \\leq\r\nn-1} (y_{i}y_{j})^{-u_{i,j}}, \\quad L^{\\mathbf{u}} = \\prod_{1 \\leq\r\ni&lt;j\\leq n-1} L_{i,j}^{u_{i,j}}\\)</span> for each <span class=\"math inline\">\\(\\mathbf{U}\\)</span>.</p>\r\n<p>We may assume that <span class=\"math inline\">\\(r_{b,\\mathbf{u}}^{\\prime} = 0\\)</span> if <span class=\"math inline\">\\(\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}\\)</span>\r\nis not in <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>. Let <span class=\"math inline\">\\(\\eta(b, \\mathbf{u})\\)</span> be the image of <span class=\"math inline\">\\((b - |\\mathbf{u}|\\mathbf{e}_{n},\r\n|\\mathbf{u}|\\mathbf{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span>, where <span class=\"math inline\">\\(|\\mathbf{u}| = \\sum_{i,j} u_{i,j}\\)</span>. Then,\r\n<span class=\"math inline\">\\(\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}L^{\\mathbf{u}}\\)</span>\r\nbelongs to <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\eta(b,\\mathbf{u})}\\)</span> for each <span class=\"math inline\">\\(b\\)</span> and <span class=\"math inline\">\\(\\mathbf{u}\\)</span>, since <span class=\"math inline\">\\((y_{i}y_{j})^{-1} L_{i,j}\\)</span> belongs to\r\n<span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\delta}\\)</span> for each <span class=\"math inline\">\\(i, j\\)</span>. Since <span class=\"math inline\">\\(\\phi\\)</span> is in <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\mu}\\)</span>, and\r\n<span class=\"math inline\">\\(\\mu\\)</span> is the image of <span class=\"math inline\">\\((a, (l - m)\\mathbf{e}_{n})\\)</span>, we may assume\r\nthat <span class=\"math inline\">\\(r_{b,\\mathbf{u}}^{\\prime} = 0\\)</span>\r\nunless <span class=\"math inline\">\\(|u| = l - m\\)</span> and <span class=\"math inline\">\\(b = a + (l - m)\\mathbf{e}_{n}\\)</span>. For each\r\n<span class=\"math inline\">\\(\\mathbf{u}\\)</span> with <span class=\"math inline\">\\(r_{\\mathbf{u}} := r^{\\prime}_{a + (l-m)\r\n\\mathbf{e}_{n},\\mathbf{u}}\\neq 0\\)</span>, write <span class=\"math inline\">\\(\\mathbf{y}^{a}y_{n}^{l-m}\\hat{y}^{-\\mathbf{u}} =\r\ny_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots y_{n-1}^{\\rho_{n-1}(\\mathbf{u})}\r\ny_{n}^{s}\\)</span>, where <span class=\"math inline\">\\(\\rho_{i}(u) \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> for <span class=\"math inline\">\\(i = 1,\r\n\\cdots , n - 1\\)</span>, and <span class=\"math inline\">\\(s = a_{n} + l -\r\nm\\)</span>. Then, we have <span class=\"math inline\">\\(\\phi =\r\ny_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})}\r\n\\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}\\)</span>. Since\r\n<span class=\"math inline\">\\(|u| = l - m\\)</span>, it follows that</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\r\n\\end{equation}\\]</span></p>\r\n<p>Now, we show that <span class=\"math inline\">\\(\\varPhi\\)</span>\r\nbelongs to <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> by\r\ncontradiction. By replacing <span class=\"math inline\">\\(\\varPhi\\)</span>\r\nif necessary, we may assume that <span class=\"math inline\">\\(m\\)</span>\r\nis the minimum among the <span class=\"math inline\">\\(x_{n}\\)</span>-degrees of elements of <span class=\"math inline\">\\(\\ker \\Delta_{n}\\backslash\r\nk[\\mathbf{y}][S_{n}]\\)</span>. To obtain a contradiction, it suffices to\r\ndeduce that</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm \\geq 2l - \\sum_{i=1}^{n-1} a_{i}\r\n\\end{equation}\\]</span></p>\r\n<p>In fact, (3) implies that <span class=\"math inline\">\\(\\sum_{i=1}^{n-1}\r\n\\rho_{i}(\\mathbf{u}) \\geq m\\)</span> by (2), so we have <span class=\"math inline\">\\(\\sum_{i=1}^{n-1}\\rho_{i}^{\\prime}(\\mathbf{u})  =\r\nm\\)</span> for some integers <span class=\"math inline\">\\(0 \\leq\r\n\\rho^{\\prime}_{i}(\\mathbf{u}) \\leq \\rho_{i}(\\mathbf{u})\\)</span> for\r\n<span class=\"math inline\">\\(i = 1, \\cdots, n - 1\\)</span> for each <span class=\"math inline\">\\(u\\)</span>. Then,</p>\r\n<p><span class=\"math display\">\\[\\varPhi^{\\prime} := y_{n}^{s}\r\n\\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\ny_{i}^{\\rho_{i}(\\mathbf{u}） - \\rho_{i}^{\\prime}(\\mathbf{u})}\r\nL_{n,i}^{\\rho_{i}^{\\prime}(\\mathbf{u}）} = y_{n}^{s} \\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}） -\r\n\\rho_{i}^{\\prime}(\\mathbf{u}） } (y_{i}x_{n}\r\nx_{n}y_{i})^{\\rho_{i}^{\\prime}(\\mathbf{u}） }\\]</span></p>\r\n<p>is an element of <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> having <span class=\"math inline\">\\(x_{n}\\)</span>-degree <span class=\"math inline\">\\(m\\)</span>, in which the coefficient of <span class=\"math inline\">\\(x_{n}^{m}\\)</span> is equal to <span class=\"math inline\">\\(\\phi\\)</span>. Hence, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree of <span class=\"math inline\">\\(\\varPhi - \\varPhi^{\\prime}\\)</span> is less than\r\n<span class=\"math inline\">\\(m\\)</span>. Since <span class=\"math inline\">\\(\\varPhi - \\varPhi^{\\prime}\\)</span> is an element\r\nof <span class=\"math inline\">\\(\\ker \\Delta_{n} \\backslash\r\nk[\\mathbf{y}][S_{n}]\\)</span>, this contradicts the minimality of <span class=\"math inline\">\\(m\\)</span>.</p>\r\n<p>We establish that (3) holds for any nonzero homogeneous element <span class=\"math inline\">\\(\\varPhi\\)</span> of <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> by contradiction. Take\r\n<span class=\"math inline\">\\(\\varPhi\\)</span> which does not satisfy (3)\r\nso that <span class=\"math inline\">\\(m\\)</span> would be the minimum\r\namong the <span class=\"math inline\">\\(x_{n}\\)</span>-degrees of such\r\npolynomials. Then, <span class=\"math inline\">\\(t:= 2l -\r\n\\sum_{i=1}^{n-1}a_{i} -m\\)</span> is positive, and <span class=\"math inline\">\\(\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) = m -\r\nt\\)</span> for each <span class=\"math inline\">\\(\\mathbf{u}\\)</span> by\r\n(2). Hence, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree of</p>\r\n<p><span class=\"math display\">\\[\\varPhi_{1}:= \\sum_{\\mathbf{u}}\r\n\\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\nL_{n,i}^{\\rho_{i}(\\mathbf{u})} = \\sum_{\\mathbf{u}} r_{\\mathbf{u}}\r\nL^{\\mathbf{u}} \\prod_{i=1}^{n-1} (y_{i}x_{n} -\r\ny_{n}x_{i})^{\\rho_{i}(\\mathbf{u})}\\]</span></p>\r\n<p>is <span class=\"math inline\">\\(m - t\\)</span>. The coefficient of\r\n<span class=\"math inline\">\\(x_{n}^{n-t}\\)</span> in <span class=\"math inline\">\\(y_{n}^{s}\\varPhi_{1}\\)</span> is equal to <span class=\"math inline\">\\(\\phi\\)</span>, so the coefficient of <span class=\"math inline\">\\(x_{n}^{m}\\)</span> in <span class=\"math inline\">\\(y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span> is equal\r\nto that in <span class=\"math inline\">\\(y_{1}^{t}\\varPhi\\)</span>.\r\nConsequently, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree\r\n<span class=\"math inline\">\\(m^{\\prime}\\)</span> of <span class=\"math inline\">\\(\\varPhi_{2}:= y_{1}^{t}\\varPhi -\r\ny_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span> is less than <span class=\"math inline\">\\(m\\)</span>. We claim that <span class=\"math inline\">\\(\\varPhi_{2} = 0\\)</span>. In fact, if <span class=\"math inline\">\\(\\gamma^{\\prime}\\)</span> is the image of <span class=\"math inline\">\\((a + t\\mathbf{e}_{1}, l\\mathbf{e}_{n})\\)</span> in\r\n<span class=\"math inline\">\\(\\Gamma\\)</span>, and <span class=\"math inline\">\\((a^{\\prime}_{1}, \\cdots , a_{n}^{\\prime}\r\n) := a + t\\mathbf{e}_{1}\\)</span>, then <span class=\"math inline\">\\(\\varPhi_{2}\\)</span> belongs to <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma^{\\prime}} \\cap\r\n\\ker \\Delta_{n}\\)</span>, and</p>\r\n<p><span class=\"math display\">\\[2l - \\sum_{i=1}^{n-1} a^{\\prime}_{i} =\r\n2l - \\sum_{i=1}^{n-1} a_{i} - t = m &gt; m^{\\prime}\\]</span></p>\r\n<p>This implies that <span class=\"math inline\">\\(\\varPhi_{2} =\r\n0\\)</span> by the minimality of <span class=\"math inline\">\\(m\\)</span>.\r\nHence, <span class=\"math inline\">\\(y_{1}^{t} \\varPhi=\r\ny_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span>. Thus, <span class=\"math inline\">\\(\\varPhi_{1}\\)</span> is divisible by <span class=\"math inline\">\\(y_{1}\\)</span>, since neither are <span class=\"math inline\">\\(y_{n}\\)</span> and <span class=\"math inline\">\\(L_{n,1}\\)</span>. Recall that the kernel of a\r\nlocally nilpotent derivation <span class=\"math inline\">\\(D\\)</span> of\r\nan integral domain <span class=\"math inline\">\\(R\\)</span> containing\r\n<span class=\"math inline\">\\(Q\\)</span> is factorially closed in <span class=\"math inline\">\\(R\\)</span>, that is, <span class=\"math inline\">\\(D(f g) =\r\n0\\)</span> implies <span class=\"math inline\">\\(D(f ) = D(g) = 0\\)</span>\r\nfor each <span class=\"math inline\">\\(f, g \\in R \\ \\{0\\}\\)</span> (cf.\r\n[2, Proposition 1.3.32 (iii)]). Note that <span class=\"math inline\">\\(\\Delta_{n}\\)</span> is locally nilpotent, <span class=\"math inline\">\\(\\Delta_{n}(\\varPhi_{1}) = 0\\)</span>, <span class=\"math inline\">\\(\\varPhi_{1} \\neq 0\\)</span> and <span class=\"math inline\">\\(\\Delta_{n}(x_{n}) \\neq 0\\)</span>. Hence, <span class=\"math inline\">\\(\\varPhi_{1}\\)</span> is not divisible by <span class=\"math inline\">\\(x_{n}\\)</span>. By substituting zero for <span class=\"math inline\">\\(x_{n}\\)</span>, we obtain from <span class=\"math inline\">\\(\\varPhi_{1}\\)</span> a nonzero polynomial</p>\r\n<p><span class=\"math display\">\\[\\sum_{\\mathbf{u}}r_{\\mathbf{u}}\r\nL^{\\mathbf{u}} \\prod_{i=1}^{n-1} (- y_{n} x_{i})^{\\rho_{i}(\\mathbf{u})}\r\n= ( - y_{n} )^{m-i} \\varPsi, \\text{ where } \\varPsi = \\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\nx_{i}^{\\rho_{i}(\\mathbf{u})}.\\]</span></p>\r\n<p>Then, <span class=\"math inline\">\\(\\varPhi \\neq 0\\)</span>, and <span class=\"math inline\">\\(\\varPhi\\)</span> is divisible by <span class=\"math inline\">\\(y_{1}\\)</span>, since so is <span class=\"math inline\">\\(\\phi_{1}\\)</span>. Define <span class=\"math inline\">\\(\\sigma \\in \\text{Aut}_{k}\r\nk[\\mathbf{y}][\\mathbf{x}]\\)</span> by <span class=\"math inline\">\\(\\sigma(x_{i}) =\r\ny_{i}\\)</span> and <span class=\"math inline\">\\(\\sigma(y_{i}) =\r\nx_{i}\\)</span> for <span class=\"math inline\">\\(i = 1, \\cdots,\r\nn\\)</span>. Then, <span class=\"math inline\">\\(\\sigma(\\varPhi)\\)</span>\r\nis divisible by <span class=\"math inline\">\\(x_{1}\\)</span>. On the other\r\nhand, <span class=\"math inline\">\\(\\sigma(L_{i,j}) = L_{j,i}\\)</span> and\r\n<span class=\"math inline\">\\(\\sigma(x_{i}) = y_{i}\\)</span> are in <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> for each <span class=\"math inline\">\\(i, j\\)</span>, so <span class=\"math inline\">\\(\\sigma(\\varPsi)\\)</span> belongs to <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span>. Thus, we have <span class=\"math inline\">\\(\\sigma(\\varPsi) = 0\\)</span>, because <span class=\"math inline\">\\(x_{1}\\)</span> is not in <span class=\"math inline\">\\(\\ker \\Delta_[n]\\)</span> and <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> is factorially closed in\r\n<span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span>. This\r\ncontradicts that <span class=\"math inline\">\\(\\varPsi \\neq 0\\)</span>.\r\nTherefore, (3) holds true. Thereby, we have proved that <span class=\"math inline\">\\(\\varPhi\\)</span> belongs to <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span>. This completes the\r\nproof of the conjecture.</p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Nowicki, Andrzej. Polynomial derivations and their rings of\r\nconstants. Toruń: Uniwersytet Mikolaja Kopernika, 1994.</p>\r\n<p>[2] Khoury, Joseph. Locally nilpotent derivations and their rings of\r\nconstants. University of Ottawa (Canada), 2001.</p>\r\n<p>[3] Kuroda, Shigeru. \"A Simple Proof of Nowicki's Conjecture on the\r\nKernel of an Elementary Derivation.\" Tokyo Journal of Mathematics 32.1\r\n(2009): 247-251.</p>\r\n<p>[4] Drensky V, Makar-Limanov L. The conjecture of Nowicki on\r\nWeitzenböck derivations of polynomial algebras[J]. Journal of Algebra\r\nand Its Applications, 2009, 8(01): 41-51.</p>\r\n<p>[5] Drensky, Vesselin. \"Another proof of the Nowicki conjecture.\"\r\nTokyo Journal of Mathematics 43.2 (2020): 537-542.</p>\r\n"},{"title":"Matiyasevich's theorem","mathjax":true,"_content":"\n\n","source":"_drafts/Matiyasevich-theorem.md","raw":"---\ntitle: Matiyasevich's theorem\ntags:\n    - [Hilbert's 23 Problems, Mathematical Logic]\ncategories:\n    - [Hilbert's 10th Problem, Mathematical Logic]\nmathjax: true\n---\n\n\n","slug":"Matiyasevich-theorem","published":0,"date":"2024-02-25T15:11:07.048Z","updated":"2024-02-25T15:11:07.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5rx000um8nx9tqj2r7h","content":"\r\n","site":{"data":{}},"excerpt":"","more":"\r\n"},{"title":"A Letter to Mr. Lei Yunhai","date":"2024-11-16T19:23:22.000Z","mathjax":true,"_content":"\n# My Journey with Mathematics\n\nIt was the summer of 2014. Holding my college entrance exam results in hand, I walked up to my high school homeroom teacher and math instructor, Mr. Lei Yunhai, and said, \"Mr. Lei, I want to study mathematics.\" A look of joy crossed his face, but after a brief pause, he replied, \"You might want to consider statistics.\" Back then, big data and artificial intelligence hadn't yet become the buzzwords they are today, and statistics wasn't a trendy discipline. Yet, in my youthful ignorance, I filled out my college application form with the words: *Applied Statistics.*\n\n# Planting the Seeds of Mathematics\n\nIn college, I met a remarkable professor, Mr. Wang Shutang, who taught us topology. His lectures were full of students who admire him and he was always peppered with his personal reflections on academic inquiry: \"Science requires a spirit of dedication. Mathematics is about distilling the essence of ideas from the works of our predecessors-separating the wheat from the chaff, eliminating the false to retain the true, abstracting and generalizing. It's crucial for science to cultivate keen intuition and a vision that transcends mere logic...\" \n\nUp until then, my perception of mathematics was tinged with a faint sense of mystique, shaped by the glowing tributes of Newton and Gauss. Professor Wang's words lit a fire in me. His philosophy resonated deeply, and the seed of a passion for research took root in my heart. Even today, I often wake from dreams recalling his wisdom. Looking back, I realize that my life's trajectory began intertwining with mathematics from that moment onward.\n\n# Seven Years of Numbers\n\nFour years later, I was admitted to graduate school to continue studying statistics. Seven years passed with a blink of eyes. Along the way, I made lifelong friends and developed a daily rhythm of mathematical research, spending my days immersed in calculating and problem-solving. \n\nTo me, there is no boundary between applied mathematics and pure mathematics. Applied mathematics provides rich examples, while pure mathematics advances theoretical understanding, creating a virtuous cycle. My work in statistics has always swung between tackling real-world challenges and revisiting theoretical foundations. Occasionally, I've fantasized about finding a single, all-encompassing solution to every problem, but I've learned that such shortcuts are illusory. \n\nI often lost myself in my studies, spending entire days in libraries and study rooms, sometimes forgetting to eat. My first paper was on the Karhunen-Lo\\'eve theorem, where I classified bivariate random fields and established four necessary and sufficient conditions for the non-uniform convergence of random orthogonal series. At the age of 24, I tasted the satisfaction of producing original research, gaining confidence in my ability to make progress in mathematics.\n\nMy continued engagement with real-world problems led me to observe that a bivariate random field corresponds naturally to a 2-tensor, or a random matrix. I proposed definitions for four classes of matrix normal distributions and submitted the findings to *Annals of Statistics.* My growing fascination with tensors led me to extend these results to general matrix rings, reducing the complexity of matrix multiplication to \\(O(n^{5/2})\\) which surpasses the classical \\(O(n^3)\\). These three papers marked my entry into mathematical research, but I know I owe much of my progress to Professor Wang's inspiring words.\n\n# Doctoral Research and Beyond\n\nMy doctoral thesis was titled *Generalized Additive Processes,* a topic steeped in abstraction. In essence, it sought to uncover qualitative shifts arising from the accumulation of quantitative similarities among examples. I observed that additive processes, including Markov processes, share a common feature: they all have a predictable compensator. This observation led to the definition of a generalized additive process as the sum of a predictable process and a martingale, naturally extending the work of Doob and Meyer.\n\nOnce the definition was in place, Br\\'emaud's 1972 conjecture followed almost effortlessly. This result, included in my thesis, yielded further intriguing corollaries, such as the existence of a cluster process that is not infinitely divisible. Some may wonder why a seemingly natural definition requires so much groundwork, but I believe that mathematics derives its strengths from such cumulative efforts. These scattered results coalesce into a cohesive whole, as mathematics relies not on itself to advance but on the synthesis of diverse ideas and perspectives.\n\nRecently, I've turned my attention to harmonic functions and representation theory, exploring their intricacies through practical examples. Unlike Professor Wang, whose philosophy laid my basis, I now pursue my own line of inquiry. Perhaps this is due to my encounters with Buddhism, which has taught me to be devout but not dogmatic. I balance my academic pursuits with hobbies like singing, running ten kilometers, swimming, and catching up with friends. These activities, along with my research, form the tapestry of my life.\n\n# A Vision for the Future\n\nNext year, I will graduate from the doctoral school. At that time, I hope to find a position that allows me to continue my research and translate books that perhaps inspire me. Above all, I aspire to learn from the people I admire. Some have passed on, but their spirit burns brightly, like a torch passed from one generation to the next. I don't seek to become a blazing fire myself; I'm content to be a blade of grass-weathering the winds and rains, but growing with each drop of nourishment.\n\n","source":"_posts/A Letter to Mr. Lei Yunhai.md","raw":"---\ntitle: A Letter to Mr. Lei Yunhai\ndate: 2024-11-17 03:23:22\ntags:\n    - [Miscellanies]\ncategories: \n    - [Miscellanies]\nmathjax: true\n---\n\n# My Journey with Mathematics\n\nIt was the summer of 2014. Holding my college entrance exam results in hand, I walked up to my high school homeroom teacher and math instructor, Mr. Lei Yunhai, and said, \"Mr. Lei, I want to study mathematics.\" A look of joy crossed his face, but after a brief pause, he replied, \"You might want to consider statistics.\" Back then, big data and artificial intelligence hadn't yet become the buzzwords they are today, and statistics wasn't a trendy discipline. Yet, in my youthful ignorance, I filled out my college application form with the words: *Applied Statistics.*\n\n# Planting the Seeds of Mathematics\n\nIn college, I met a remarkable professor, Mr. Wang Shutang, who taught us topology. His lectures were full of students who admire him and he was always peppered with his personal reflections on academic inquiry: \"Science requires a spirit of dedication. Mathematics is about distilling the essence of ideas from the works of our predecessors-separating the wheat from the chaff, eliminating the false to retain the true, abstracting and generalizing. It's crucial for science to cultivate keen intuition and a vision that transcends mere logic...\" \n\nUp until then, my perception of mathematics was tinged with a faint sense of mystique, shaped by the glowing tributes of Newton and Gauss. Professor Wang's words lit a fire in me. His philosophy resonated deeply, and the seed of a passion for research took root in my heart. Even today, I often wake from dreams recalling his wisdom. Looking back, I realize that my life's trajectory began intertwining with mathematics from that moment onward.\n\n# Seven Years of Numbers\n\nFour years later, I was admitted to graduate school to continue studying statistics. Seven years passed with a blink of eyes. Along the way, I made lifelong friends and developed a daily rhythm of mathematical research, spending my days immersed in calculating and problem-solving. \n\nTo me, there is no boundary between applied mathematics and pure mathematics. Applied mathematics provides rich examples, while pure mathematics advances theoretical understanding, creating a virtuous cycle. My work in statistics has always swung between tackling real-world challenges and revisiting theoretical foundations. Occasionally, I've fantasized about finding a single, all-encompassing solution to every problem, but I've learned that such shortcuts are illusory. \n\nI often lost myself in my studies, spending entire days in libraries and study rooms, sometimes forgetting to eat. My first paper was on the Karhunen-Lo\\'eve theorem, where I classified bivariate random fields and established four necessary and sufficient conditions for the non-uniform convergence of random orthogonal series. At the age of 24, I tasted the satisfaction of producing original research, gaining confidence in my ability to make progress in mathematics.\n\nMy continued engagement with real-world problems led me to observe that a bivariate random field corresponds naturally to a 2-tensor, or a random matrix. I proposed definitions for four classes of matrix normal distributions and submitted the findings to *Annals of Statistics.* My growing fascination with tensors led me to extend these results to general matrix rings, reducing the complexity of matrix multiplication to \\(O(n^{5/2})\\) which surpasses the classical \\(O(n^3)\\). These three papers marked my entry into mathematical research, but I know I owe much of my progress to Professor Wang's inspiring words.\n\n# Doctoral Research and Beyond\n\nMy doctoral thesis was titled *Generalized Additive Processes,* a topic steeped in abstraction. In essence, it sought to uncover qualitative shifts arising from the accumulation of quantitative similarities among examples. I observed that additive processes, including Markov processes, share a common feature: they all have a predictable compensator. This observation led to the definition of a generalized additive process as the sum of a predictable process and a martingale, naturally extending the work of Doob and Meyer.\n\nOnce the definition was in place, Br\\'emaud's 1972 conjecture followed almost effortlessly. This result, included in my thesis, yielded further intriguing corollaries, such as the existence of a cluster process that is not infinitely divisible. Some may wonder why a seemingly natural definition requires so much groundwork, but I believe that mathematics derives its strengths from such cumulative efforts. These scattered results coalesce into a cohesive whole, as mathematics relies not on itself to advance but on the synthesis of diverse ideas and perspectives.\n\nRecently, I've turned my attention to harmonic functions and representation theory, exploring their intricacies through practical examples. Unlike Professor Wang, whose philosophy laid my basis, I now pursue my own line of inquiry. Perhaps this is due to my encounters with Buddhism, which has taught me to be devout but not dogmatic. I balance my academic pursuits with hobbies like singing, running ten kilometers, swimming, and catching up with friends. These activities, along with my research, form the tapestry of my life.\n\n# A Vision for the Future\n\nNext year, I will graduate from the doctoral school. At that time, I hope to find a position that allows me to continue my research and translate books that perhaps inspire me. Above all, I aspire to learn from the people I admire. Some have passed on, but their spirit burns brightly, like a torch passed from one generation to the next. I don't seek to become a blazing fire myself; I'm content to be a blade of grass-weathering the winds and rains, but growing with each drop of nourishment.\n\n","slug":"A Letter to Mr. Lei Yunhai","published":1,"updated":"2025-01-01T05:08:12.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5ry000wm8nx6fn01ob0","content":"<h1 id=\"my-journey-with-mathematics\">My Journey with Mathematics</h1>\r\n<p>It was the summer of 2014. Holding my college entrance exam results\r\nin hand, I walked up to my high school homeroom teacher and math\r\ninstructor, Mr. Lei Yunhai, and said, \"Mr. Lei, I want to study\r\nmathematics.\" A look of joy crossed his face, but after a brief pause,\r\nhe replied, \"You might want to consider statistics.\" Back then, big data\r\nand artificial intelligence hadn't yet become the buzzwords they are\r\ntoday, and statistics wasn't a trendy discipline. Yet, in my youthful\r\nignorance, I filled out my college application form with the words:\r\n<em>Applied Statistics.</em></p>\r\n<h1 id=\"planting-the-seeds-of-mathematics\">Planting the Seeds of\r\nMathematics</h1>\r\n<p>In college, I met a remarkable professor, Mr. Wang Shutang, who\r\ntaught us topology. His lectures were full of students who admire him\r\nand he was always peppered with his personal reflections on academic\r\ninquiry: \"Science requires a spirit of dedication. Mathematics is about\r\ndistilling the essence of ideas from the works of our\r\npredecessors-separating the wheat from the chaff, eliminating the false\r\nto retain the true, abstracting and generalizing. It's crucial for\r\nscience to cultivate keen intuition and a vision that transcends mere\r\nlogic...\"</p>\r\n<p>Up until then, my perception of mathematics was tinged with a faint\r\nsense of mystique, shaped by the glowing tributes of Newton and Gauss.\r\nProfessor Wang's words lit a fire in me. His philosophy resonated\r\ndeeply, and the seed of a passion for research took root in my heart.\r\nEven today, I often wake from dreams recalling his wisdom. Looking back,\r\nI realize that my life's trajectory began intertwining with mathematics\r\nfrom that moment onward.</p>\r\n<h1 id=\"seven-years-of-numbers\">Seven Years of Numbers</h1>\r\n<p>Four years later, I was admitted to graduate school to continue\r\nstudying statistics. Seven years passed with a blink of eyes. Along the\r\nway, I made lifelong friends and developed a daily rhythm of\r\nmathematical research, spending my days immersed in calculating and\r\nproblem-solving.</p>\r\n<p>To me, there is no boundary between applied mathematics and pure\r\nmathematics. Applied mathematics provides rich examples, while pure\r\nmathematics advances theoretical understanding, creating a virtuous\r\ncycle. My work in statistics has always swung between tackling\r\nreal-world challenges and revisiting theoretical foundations.\r\nOccasionally, I've fantasized about finding a single, all-encompassing\r\nsolution to every problem, but I've learned that such shortcuts are\r\nillusory.</p>\r\n<p>I often lost myself in my studies, spending entire days in libraries\r\nand study rooms, sometimes forgetting to eat. My first paper was on the\r\nKarhunen-Lo'eve theorem, where I classified bivariate random fields and\r\nestablished four necessary and sufficient conditions for the non-uniform\r\nconvergence of random orthogonal series. At the age of 24, I tasted the\r\nsatisfaction of producing original research, gaining confidence in my\r\nability to make progress in mathematics.</p>\r\n<p>My continued engagement with real-world problems led me to observe\r\nthat a bivariate random field corresponds naturally to a 2-tensor, or a\r\nrandom matrix. I proposed definitions for four classes of matrix normal\r\ndistributions and submitted the findings to <em>Annals of\r\nStatistics.</em> My growing fascination with tensors led me to extend\r\nthese results to general matrix rings, reducing the complexity of matrix\r\nmultiplication to (O(n^{5/2})) which surpasses the classical (O(n^3)).\r\nThese three papers marked my entry into mathematical research, but I\r\nknow I owe much of my progress to Professor Wang's inspiring words.</p>\r\n<h1 id=\"doctoral-research-and-beyond\">Doctoral Research and Beyond</h1>\r\n<p>My doctoral thesis was titled <em>Generalized Additive\r\nProcesses,</em> a topic steeped in abstraction. In essence, it sought to\r\nuncover qualitative shifts arising from the accumulation of quantitative\r\nsimilarities among examples. I observed that additive processes,\r\nincluding Markov processes, share a common feature: they all have a\r\npredictable compensator. This observation led to the definition of a\r\ngeneralized additive process as the sum of a predictable process and a\r\nmartingale, naturally extending the work of Doob and Meyer.</p>\r\n<p>Once the definition was in place, Br'emaud's 1972 conjecture followed\r\nalmost effortlessly. This result, included in my thesis, yielded further\r\nintriguing corollaries, such as the existence of a cluster process that\r\nis not infinitely divisible. Some may wonder why a seemingly natural\r\ndefinition requires so much groundwork, but I believe that mathematics\r\nderives its strengths from such cumulative efforts. These scattered\r\nresults coalesce into a cohesive whole, as mathematics relies not on\r\nitself to advance but on the synthesis of diverse ideas and\r\nperspectives.</p>\r\n<p>Recently, I've turned my attention to harmonic functions and\r\nrepresentation theory, exploring their intricacies through practical\r\nexamples. Unlike Professor Wang, whose philosophy laid my basis, I now\r\npursue my own line of inquiry. Perhaps this is due to my encounters with\r\nBuddhism, which has taught me to be devout but not dogmatic. I balance\r\nmy academic pursuits with hobbies like singing, running ten kilometers,\r\nswimming, and catching up with friends. These activities, along with my\r\nresearch, form the tapestry of my life.</p>\r\n<h1 id=\"a-vision-for-the-future\">A Vision for the Future</h1>\r\n<p>Next year, I will graduate from the doctoral school. At that time, I\r\nhope to find a position that allows me to continue my research and\r\ntranslate books that perhaps inspire me. Above all, I aspire to learn\r\nfrom the people I admire. Some have passed on, but their spirit burns\r\nbrightly, like a torch passed from one generation to the next. I don't\r\nseek to become a blazing fire myself; I'm content to be a blade of\r\ngrass-weathering the winds and rains, but growing with each drop of\r\nnourishment.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"my-journey-with-mathematics\">My Journey with Mathematics</h1>\r\n<p>It was the summer of 2014. Holding my college entrance exam results\r\nin hand, I walked up to my high school homeroom teacher and math\r\ninstructor, Mr. Lei Yunhai, and said, \"Mr. Lei, I want to study\r\nmathematics.\" A look of joy crossed his face, but after a brief pause,\r\nhe replied, \"You might want to consider statistics.\" Back then, big data\r\nand artificial intelligence hadn't yet become the buzzwords they are\r\ntoday, and statistics wasn't a trendy discipline. Yet, in my youthful\r\nignorance, I filled out my college application form with the words:\r\n<em>Applied Statistics.</em></p>\r\n<h1 id=\"planting-the-seeds-of-mathematics\">Planting the Seeds of\r\nMathematics</h1>\r\n<p>In college, I met a remarkable professor, Mr. Wang Shutang, who\r\ntaught us topology. His lectures were full of students who admire him\r\nand he was always peppered with his personal reflections on academic\r\ninquiry: \"Science requires a spirit of dedication. Mathematics is about\r\ndistilling the essence of ideas from the works of our\r\npredecessors-separating the wheat from the chaff, eliminating the false\r\nto retain the true, abstracting and generalizing. It's crucial for\r\nscience to cultivate keen intuition and a vision that transcends mere\r\nlogic...\"</p>\r\n<p>Up until then, my perception of mathematics was tinged with a faint\r\nsense of mystique, shaped by the glowing tributes of Newton and Gauss.\r\nProfessor Wang's words lit a fire in me. His philosophy resonated\r\ndeeply, and the seed of a passion for research took root in my heart.\r\nEven today, I often wake from dreams recalling his wisdom. Looking back,\r\nI realize that my life's trajectory began intertwining with mathematics\r\nfrom that moment onward.</p>\r\n<h1 id=\"seven-years-of-numbers\">Seven Years of Numbers</h1>\r\n<p>Four years later, I was admitted to graduate school to continue\r\nstudying statistics. Seven years passed with a blink of eyes. Along the\r\nway, I made lifelong friends and developed a daily rhythm of\r\nmathematical research, spending my days immersed in calculating and\r\nproblem-solving.</p>\r\n<p>To me, there is no boundary between applied mathematics and pure\r\nmathematics. Applied mathematics provides rich examples, while pure\r\nmathematics advances theoretical understanding, creating a virtuous\r\ncycle. My work in statistics has always swung between tackling\r\nreal-world challenges and revisiting theoretical foundations.\r\nOccasionally, I've fantasized about finding a single, all-encompassing\r\nsolution to every problem, but I've learned that such shortcuts are\r\nillusory.</p>\r\n<p>I often lost myself in my studies, spending entire days in libraries\r\nand study rooms, sometimes forgetting to eat. My first paper was on the\r\nKarhunen-Lo'eve theorem, where I classified bivariate random fields and\r\nestablished four necessary and sufficient conditions for the non-uniform\r\nconvergence of random orthogonal series. At the age of 24, I tasted the\r\nsatisfaction of producing original research, gaining confidence in my\r\nability to make progress in mathematics.</p>\r\n<p>My continued engagement with real-world problems led me to observe\r\nthat a bivariate random field corresponds naturally to a 2-tensor, or a\r\nrandom matrix. I proposed definitions for four classes of matrix normal\r\ndistributions and submitted the findings to <em>Annals of\r\nStatistics.</em> My growing fascination with tensors led me to extend\r\nthese results to general matrix rings, reducing the complexity of matrix\r\nmultiplication to (O(n^{5/2})) which surpasses the classical (O(n^3)).\r\nThese three papers marked my entry into mathematical research, but I\r\nknow I owe much of my progress to Professor Wang's inspiring words.</p>\r\n<h1 id=\"doctoral-research-and-beyond\">Doctoral Research and Beyond</h1>\r\n<p>My doctoral thesis was titled <em>Generalized Additive\r\nProcesses,</em> a topic steeped in abstraction. In essence, it sought to\r\nuncover qualitative shifts arising from the accumulation of quantitative\r\nsimilarities among examples. I observed that additive processes,\r\nincluding Markov processes, share a common feature: they all have a\r\npredictable compensator. This observation led to the definition of a\r\ngeneralized additive process as the sum of a predictable process and a\r\nmartingale, naturally extending the work of Doob and Meyer.</p>\r\n<p>Once the definition was in place, Br'emaud's 1972 conjecture followed\r\nalmost effortlessly. This result, included in my thesis, yielded further\r\nintriguing corollaries, such as the existence of a cluster process that\r\nis not infinitely divisible. Some may wonder why a seemingly natural\r\ndefinition requires so much groundwork, but I believe that mathematics\r\nderives its strengths from such cumulative efforts. These scattered\r\nresults coalesce into a cohesive whole, as mathematics relies not on\r\nitself to advance but on the synthesis of diverse ideas and\r\nperspectives.</p>\r\n<p>Recently, I've turned my attention to harmonic functions and\r\nrepresentation theory, exploring their intricacies through practical\r\nexamples. Unlike Professor Wang, whose philosophy laid my basis, I now\r\npursue my own line of inquiry. Perhaps this is due to my encounters with\r\nBuddhism, which has taught me to be devout but not dogmatic. I balance\r\nmy academic pursuits with hobbies like singing, running ten kilometers,\r\nswimming, and catching up with friends. These activities, along with my\r\nresearch, form the tapestry of my life.</p>\r\n<h1 id=\"a-vision-for-the-future\">A Vision for the Future</h1>\r\n<p>Next year, I will graduate from the doctoral school. At that time, I\r\nhope to find a position that allows me to continue my research and\r\ntranslate books that perhaps inspire me. Above all, I aspire to learn\r\nfrom the people I admire. Some have passed on, but their spirit burns\r\nbrightly, like a torch passed from one generation to the next. I don't\r\nseek to become a blazing fire myself; I'm content to be a blade of\r\ngrass-weathering the winds and rains, but growing with each drop of\r\nnourishment.</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Wed Jan 01 2025 13:08:12 GMT+0800 (中国标准时间)","title":"A Letter to Mr. Lei Yunhai","path":"2024/11/17/A Letter to Mr. Lei Yunhai/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2024-11-16T19:23:22.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2024-11-16T19:23:22.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Miscellanies","tags":["Miscellanies"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"75 Problems in the Foundation of Mathematics","date":"2023-09-22T14:10:39.000Z","mathjax":true,"_content":"\n# Forewords\n\n\nThere are 75 open problems recorded in the Polish journal *Fundamenta Mathematicae* in volumes 1-34 from its inception, some of which have already been solved. These problems represent the development of the foundations of mathematics since the late 19th century when M. G. Cantor established naive set theory. The original text is in French and German, and the translated version is as follows.\n\n\n# Problems\n\n\n1) When is a set of points $P$ a one-to-one and continuous image (but not necessarily bi-continuous) of a set $Q$ and when is $Q$ a one-to-one and continuous image of $P$? Are the sets $P$ and $Q $ necessarily homeomorphic?\n\nProblem of M. W. Sierpinski. \n\n2) Is a (bounded) planar continuum, topologically homogeneous, necessarily homeomorphic to a circumference?\n\n(A set $E$ is said to be *topologically homogeneous*, when there exists for any pair of points $a, b$ of $E$ a one-to-one and bi-continuous transformation of $E$ into itself which transforms $a$ into $b$)\n\nProblem of MM. B. Knaster and C. Kuratowski.\n\n3) Is a set ordered (linearly) without jumps or gaps and such that any set of its intervals (containing more than one element) does not overlap with each other is at most innumerable, necessarily a (ordinary) linear continuum?\n\nProblem of M. M. Souslin.\n\n4) Is there a decomposition of an interval into $\\aleph_{1}$ (non-empty) sets without common points that are $B$ measurable?\n\nProblem of M. W. Sierpinski.\n\n5) Does there exist an uncountable linear set $E$ such that every linear set homeomorphic to $E$ has zero Lebesgue measure? Can we prove the existence of such a set assuming that $2^{\\aleph_{0}} = \\aleph_{1}$?\n\nProblem of M. W. Sierpinski.\n\n6) Can we find without the hypothesis of the continuum ($2^{\\aleph_{0}} = \\aleph_{1}$) that a sum of $\\aleph_{1}$ sets of zero Lebesgue measure is not necessarily zero Lebesgue measure? that a sum of $\\aleph_{1}$ sets of the first category is not necessarily of the first category? that a product of $\\aleph_{1}$ sets ($A$) is not necessarily a set ($A$)?\n\nProblem of M. W. Sierpinski.\n\n7) Can we establish without the hypothesis of the continuum the existence of a planar set which has zero (Lebesgue) measure on any direction parallel to the abscissa axis and whose complement has zero measure on any direction parallel to the ordinate axis?\n\nProblem of M. H. Steinhaus.\n\n8) Can we give an effective example of a set of real numbers $E$ such that any sum, difference, product or quotient of two numbers of $E$ (except division by 0) belongs to $E$ and that $E$ is uncountable, but distinct from the set of all real numbers?\n\nProblem of M. S. Mazurkiewicz.\n\n9) What is the power of sets complementary to sets ($A$)?\n\nProblem of M. N. Lusin.\n\n\n*Notice.* The linear sets ($A$) are orthogonal projections (on a line) of the measurable planar sets $B$. M. Lusin demonstrated that the power of an uncountable set complementary to a set ($A$) is $\\aleph_{1}$ or $2^{\\aleph_{0}}$, but we do not know if it can really be $\\aleph_{1}$ (in the case where $2^{\\aleph_{0}} > \\aleph_{1}$).\n\n10) Does there exist a second class function that is not a limit of almost everywhere continuous functions? Can we give an effective example of a function which is not a limit of piecewise continuous functions?\n\nProblem of MM. T. Feosztyn and W. Sierpinski.\n\n11) Does there exist a class ($\\mathcal{L}$) of M. Fr\\'echet (i.e. a class in which the limit is defined) of power greater than the continuum, such that any uncountable set of elements of this class contains at least one condensation element?\n\nProblem of M. W. Sierpinski.\n\n12) Does a (linearly) ordered set of which all well-ordered subsets (increasing and decreasing) are at most countable, necessarily have a power not greater than the continuum?\n\nProblem of M. W. Sierpinski.\n\n13) Does there exist a planar closed set which is not the sum of two closed sets without common points, but a sum of countable closed sets without common points.\n\nProblem of M. W. Sierpinski.\n\n14) Does a continuum in $m$-dimensional space which is homeomorphic to any continuum contain necessarily a simple arc (i.e. image of an one-to-one and continuous mapping of the interval $(0,1)$?\n\nProblem of M. Mazurkiewicz.\n\n15) Does there exist a continuum of which every everything under continuous mapping is indecomposable? (A continuum is said to be indecomposable when it is not a sum of two continua different from it.)\n\nProblem of MM. Knaster and Kuratowski.\n\n16) Does there exist a continuum (unbounded) which is a sum of its proper saturated sub-continuums where any two of them do not intersect?\n\n(We say that a real subcontinuum $K$ of $C$ is *saturated*, when there exists no continuum different from $K$ and $C$ which contains $K$ and which is contained in $C$.)\n\nProblem of M. Kuratowski.\n\n17) What is the power of the set of all values that a Baire class 1 function does not take? \n\n(This problem is equivalent to problem 9 of M. Lusin, t. I. p.224. It would be enough to solve this problem for functions admitting uncountable points of discontinuity.)\n\n18) Is a (linear) set of power less than the continuum necessarily of the first category of M. Baire?\n\nProblem of M. Ruziewicz.\n\n19) Does there exist in each biconnected set $B$ a point $p$ such that the set $B - (p)$ contains no connected set?\n\n*Notice.* According to a theorem of M. Kline (this volume, p.238), there cannot exist in a connected set $B$ more than one point $p$ enjoying the property in question. We know, on the other hand, that, if such a point exists, the set $B$ is biconnected, i.e. it is not the sum of two disjoint connected sets containing more than one point (cf. Knaster and Kuratowski, *Fund. Math.* II, p, 214.)\n\nProblem of M. Kuratowski.\n\n20) Let $f(E)$ be a function defined by any measurable ($L$) set $E$ of a Euclidean space of $m \\geq 3$ dimensions and satisfying the following conditions:\n\n1. $f(E) \\geq 0$.\n2. $f(E_{0}) = 1$ for a certain set $E_{0}$ of measure 1.\n3. $f(E_{1} +E_{2}) = f(E_{1}) + f(E_{2})$, if $E_{1} E_{2} = 0$.\n4. $f(E_{1}) = f(E_{2})$, if $E_{1}$ and $E_{2}$ are superposable.\n\nDoes the function $f(E)$ necessarily coincide with the Lebesgue measure of the set $E$?\n\n(For $m=1$ and $m=2$ the answer is negative, as M. Banach proved in a memoir which will be published in the volume IV of this journal.)\n\nProblem of M. Ruziewicz.\n\n21) Given a set of real numbers which is not of the first category in any interval, is there a decomposition: $A = B + C$, $B \\times C = 0$ such that neither $B$ nor $C$ are of the first category in any interval?\n\n*Notice.* We could give the affirmative answer in the hypothesis additional that $A$ has the Baire property (in the sense established in this volume), p.319 . M. Sierpinski also pointed out the affirmative answer in the hypothesis of the continuum, $\\aleph_{1} = 2^{\\aleph_{0}}$.\n\nProblem of M. Kuratowski.\n\n22) Let us call the (linear) set $E$ *perfectly measurable*, if every set homeomorphic to $E$ is measurable in the sense of Lebesgue. What is the power of the class of perfectly measurable sets? Is a complementary set to a perf. measurable set always perf. measurable?\n\nProblem of M. Urysohn.\n\n23) Does there exist a function of a real variable $ f(x)$ pantachically dicontinuous and such that we have for all real $x$\n\n$$\\lim_{h \\to 0} \\frac{f( x+h ) - f(x-h)}{2h} = 0?$$\n\nProblem of M. Steinhaus.\n\n24) Is a function satisfying Baire's condition necessarily measurable ($L$)? What is the power of all the functions of a real variable satisfying the Baire condition? (We say that a function $f(x)$ satisfies the Baire condition, if it is continuous on any perfect set when we neglect the sets of the first category has with respect to that perfect set.)\n\nProblem of M. Sierpinski.\n\n25) Can a planar set, such that any straight line meets it at two (and only two) points, be measurable ($B$)? (The existence of such a set has been demonstrated, using M. Zermelo's theorem, by MM. Mazurkiewicz[^1] (in 1914) and Rosenthal[^2] (in 1922))\n\n\n[^1]: Accounts of the Soc. of Varsovic Sciences , t. VII, p.382.\n\n[^2]: Sitzungaber d. Bayer. Akad. d. Wiss., math.-phys. K1, 1922, p. 223.\n\n26) Is a class 3 function of M. Baire always a superposition of three class 1 functions, that is to say, does it exist for any function $f(x)$ of class 3 three class 1 functions $\\varphi(x)$, $\\psi(x)$ and $\\vartheta(x)$, such that we have for all real $x$\n\n$$f(x) = \\varphi \\{\\psi[\\vartheta (x)]\\}$$\n\nProblem of M. Lusin.\n\n27) Is the set $D(E)$ of the distances of the points of a linear set $E$ that is ($B$) measurable always ($B$) measurable? ($D(E)$ is therefore the set of all numbers $|x - y|$, where $x$ and $y$ belong to $E$. We can prove the existence of set $E$ that are measurable ($L$), such that $D(E)$ is non-measurable ($L$).)\n\nProblem of M. Sierpinski. \n\n28) If $E$ is a ($B$ measurable) planar set, let us denote by $N(E)$ the set of all real numbers $a$, such that the line $x = a$ meets $E$ at a uncountable infinite number of points. Is the set $N(E)$ necessarily a set ($A$), or, more simply, is it measurable ($L$)? (It can be shown that the set of all real numbers $a$, such that the line $x = a$ meets the ($B$ measurable) set $E$ in an infinity number of points is always a set ($A$).)\n\nProblem of M. Sierpinski. \n\n29) Let $F$ be a planar set, p. ex. closed (or, more generally, measurable) - A point $x$ of $F$ will be said to be *linearly accessible* if there exists a rectilinear segment $\\overline{xp}$ such that all its points (except the point $x$) are outside $F$. Can it be shown that the set $A$ of all linearly accessible points of $F$ is always measurable ($L$)?\n\nProblem of M. Urysohn.\n\n30) If $f(x)$ is an arbitrarily given function (measurable or not), what is the measure of the sum of all points $x$, such that\n\n$$\\lim \\limits_{h\\to 0} \\left |\\frac{f( x+h ) - f(x)}{h}\\right| = \\infty $$\n\nProblem of M. Ruziewicz.\n\n31) Is the statement \"$\\mathsf{m} = 2\\cdot\\mathsf{m}$ for any *transfinite* cardinal number $\\mathsf {m}$\" equivalent to *the axiom of choice*?\n\nCf. my Note \"*On some theorems which are equivalent to the axiom of choice*\" in this volume, p. 147.\n\nProblem of M. Tajtelbaum-Tarski .\n\n32) Is a planar closed set, where every point is linearly accessible, necessarily of zero surface measure?\n\nProblem of M. Banach.\n\nA point $x$ of $F$ is said to be linearly accessible if there exists a rectilinear segment $\\overline{xp}$ such that all its points (except the point $x$) are outside $F$. M. Urysohn proved that the set of all linearly accessible points of a planar closed set is always a set ($A$) of M. Souslin, but may not be measurable ($B$). But we do not know if the set of all linearly accessible points of a planar $G_{\\delta}$ set is measurable ($L$) (Cf. Problem 29, *Fund. Math.* t. V, p. 337).\n\n33) Is the image of a one-to-one and continuous map (in one sense) of a set complementary to a set ($A$) of M. Souslin necessarily a homeomorphism?\n\nProblem of Sierpinski.\n\n34) Let us call a (linear) set ($B$) measurable of class $\\alpha$ *irreducible* if it is not of class $<\\alpha$ in any interval. What is the power of the set of all topological types of irreducible sets of class $\\alpha$?\n\nLet us call a set ($A$) *irreducible*, if it is not ($B$) measurable in any interval. What is the power of all the topological types of the sets ($A$) irreducible?\n\nProblem of MM. Alexandroff and Urysohn.\n\n35) Let us call the (linear) set $E$ *perfectly measurable in the narrow sense*, if every unambiguous and continuous image of $E$ is measurable in the sense of Lebesgue. Is a set complementary to a set perfectly measurable in the narrow sense always a homeomorphic image?\n\nCf. Problem 22 of P. Urysohn (*Fund. Math.* t. IV, p. 368), solved by M. Lavrentieff (*Fund. Math.* t. VI, p. 159).\n\nProbleme de M. O. Nikodym.\n\n36) According to M. Souslin, if $E$ is a set ($A$) and $H$ a complementary set to a set ($A$), and if $E \\subset H$, there exists a set $Q$, ($B$) measurable, such that $E\\subset Q \\subset H$[^3]. Does this proposition admit a reciprocal, that is to say, *if $E$ is a complementary set to a set ($A$) and $H$ ------ does a set ($A$), such that $E \\subset H$, exist always a ($B$) measurable set $Q$, such that $E \\subset Q \\subset H$?*\n\nProblem of M. Sierpinski.\n\n[^3]: See p. e. N. Lusin and W. Sierpinski *Journ. of Math.* t. II (1923) p. 60; also *Bull. Acad. Krakow* 1918 p. 40.\n\n37) Is a Jordan (bounded) continuum which contains only a simple closed curve homeomorphic to one of its (real) sub-continuums?\n\nProblem of M. Zarankiewicz.\n\n38) Can a square and a circle whose areas are equal be decomposed into a finite number of respectively congruent disjoint subsets?\n\nProblem of M. Tarski.\n\n39) Does there exist a planar closed set for which the set of linearly accessible points is non-measurable ($B$)? (In the space the problem is resolved in the affirmative sense).\n\nProblem of M. O. Nikodym.\n\n40) If $E$ is a planar $G_{\\delta}$ set, is the set of all real numbers $a$, such that the line $x=a$ meets the set $E$ in one and only one point, not necessarily complementary to a set ($A$) of M. Souslin?\n\nProblem of M. Sierpinski.\n\n41) If $E_{1}, E_{2}, E_{3}, \\dots$ are a sequence of countable linear sets each of which is a projection of a planar set complementary to a set ($A$) of M. Souslin, is the set $E_{1}E_{2} E_{3} \\dots $ of the same nature?\n\nProblem of M. Sierpinski.\n\n42) Does there exist in every continuum $A$ a continuum $B$ such that the set $A - B$ is connected?\n\nProblem of MM. Knaster and Zarankiewicz.\n\n\n43) Let $D$ denote a closed set homeomorphic to a planar set located in 3-dimensional Euclidean space, is every point of $D$ is *accessible* in this space?\n\n(A point $d$ of $D$ is said to be *accessible* in $E$, when there exists a continuum $C \\subset E$ such that $(d) = CD$).\n\nProblem of M. Knaster.\n\nUnfortunately, Problem 44 and 45 by MM. N. Lusin and H. Steinhaus which should have appeared in XI, p.308, were missing. \n\n46) It is asked to set up the logical relations between the various concepts of homogeneity, in so far as they refer to locally compact sets. In particular, even if the sets are considered to be connected and (or) locally connected.\n\n(See D. van Dantzig , \"On topologically homogeneous continua, volume 15, pp. 102, 103).\n\nProblem of M. van Dantzig.\n\n47) Is every (connected, unbounded) $n$-dimensional manifold involutory homogeneous?\n\n(Cf. D. van Dantzig, le p. 104, ^7.)\n\nProblem of M. van Dantzig.\n\n48) Let us call a topological group *monothetic* if an infinite cyclic group is dense in it (in which case it is commutative and can be written additively), and *complete* if every sequence $x_{\\nu} $, which satisfies the Cauchy's convergence criterion $\\lim (x_{\\nu} - x_{\\mu }) = 0$ has a limit element in the group, the question is whether a monothetic group can be complete without being compact.\n\n(See lc p. 116 {}^{29}a))\n\nProblem of M. van Dantzig.\n\n49) Let $X$ and $Y$ be two Peano continua (= continuous images of the interval) and $Z$ be their topological product (= the space of all pairs $z = (x,y) $ or $\\lim z_{n}=z$ when $\\lim x_{n} = x$ and $\\lim y_{n} = y$).\n\n1^0. If the continuum $X$, as well as $Y$, has the property that in each continuous transformation of this continuum into a subset there exists an invariant point, is it true that $Z$ has the same property?\n\n2^0. If the continuum $X$, as well as $Y$, is uni-consistent (= in each decomposition of this continuum into two sub-continuums the common part of these sub-continuums is connected), is it true that $Z$ is uni-coherent?\n\nProblem of M. Kuratowski.\n\n50) Is the topological circle the only homogeneous locally connected curve? (Curve = one-dimensional connected compact space. A space is called homogeneous, if for each of its two points $p$ and $q$ there exist a homeomorphism which sends $p$ to $q$ ). On the plane, the circle is the only homogeneous locally connected curve.\n\n(Cf. Mazurkiewicz, Fund. Math. V, p. 137).\n\nProblem with M. K. Menger.\n\n51) Are there any or even an infinite number of compact one-dimensional spaces, any two of which are incomparable in dimension one? Two spaces $R$ and $R^{\\prime}$ may be called one-dimensionally incomparable, if no one-dimensional subset of $R$, (or of $R^{\\prime}$) is homeomorphic with a subset of $R^{\\prime}$ (or of $R^{\\prime}$). For example, a line and a continuum without partial arcs are incomparable in one dimension. (If there are $n$, or $\\aleph_{0}$ in pairs of one-dimensionally incomparable curves, then there exist compact one-dimensional spaces which contains at least $2^{n} +1$, or $2^{\\aleph_{0}}$ monotone, $F_{\\sigma}$-additive, topological, compactifiable systems of subsets).\n\t\n(See Monthly Issues f. Math. and Phys. 36, p. 207).\n\nProblem of M. K. Menger.\n\n52) Does there exist a continuum of which every other continuum is a continuous image?\n\nProblem of M. H. Hahn.\n\n53) a. Can any absolute retract be decomposed into a finite number of absolute retracts with arbitrarily small diameters?\n\nb. Can any $R$ set be decomposed into a finite number of absolute retracts?\n\n(The definition of absolute retracts and $R$ sets is given, for example, in Fund. Math. XIX, p. 222).\n\n54) Is every partial continuum $C$ of the Euclidean $n$-dimensional space $R_{n}$, which intersects $R_{n}$ and which is transferred by arbitrarily small transformations (i.e. by a continuous mapping which sends every point from $C$ to an arbitrarily close point of $R_{n}$) into a subset of $R_{n}$ that is foreign to it, a ($n-1$) dimensional space?\n\n55) Can every route image lying in $R_{3}$ and intersecting $R_{3}$ be mapped continuously without fixed points?\n\nProblem of M. K. Borsuk.\n\n56) Let $A$ and $B$ be two topological spaces and $A^{2}$ and $B^{2}$ respectively their squares (a. \\`ad $A^{2}$ p. ex. consists of all your pairs ($a_{1}$, $a_{2}$) extracted from $A$).\n\nIs it true that if $A^{2}$ and $B^{2}$ are homeomorphic, are $A$ and $B$ too?\n\nIn case of a positive answer, we deduce that, if $C$ is a set which is not homeomorphic to none of $C^{n}$, $n>1$, the sets $C^{m}$ and $C^{n}$ are neither homeomorphic for $m \\neq n$; this provides in the case where $C$ is an interval of the theorem of \"invariance of the dimension\" of M. Brouwer.\n\nProblem of M. S. Ulam.\n\n57) Does there exist an infinite-dimensional continuum that does not contain any finite-dimensional continuum?\n\nProblems of M. S. Mazurkiewicz.\n\n\n58) Does there exist in a set $E$ of size $\\aleph_{1}$ a countable system of subsets $A_{1}, A_{2},\\dots$ such that one has the form\n$$X = \\overline{\\lim} A_{p_{n}}$$\nwhere ($p_{1}, p_{2},\\dots$ is a subsequence of the natural numbers, $\\overline{\\lim}$ means the Borel *complete limit set*) all subsets $X, A_{1}, A_{2},\\dots$ are received from $E$?\n\n(It is a question of proving the negation without using the continuum hypothesis).\n\nProblems with M. F. Hausdorff. \n\n59) A function with the Baire property (i.e. continuous on any perfect set, when we neglect a set of $1^{st}$ category relative to this set) of a function with the Baire property, is it of the same nature?\n\nProblem of M. W. Sierpinski.\n\n60) Let $\\rho$ be the set of all homeomorphic transformations of the Cartesian plane in itself, of the form:\n$$x^{\\prime} = x, \\quad y^{\\prime} =f( x,y )$$\nand\n$$x^{\\prime}=g( x,y ), \\quad \ty^{\\prime}=y.$$\n\nLet us denote by $\\sigma$ the group formed by all the finite superpositions of all the transformations belonging to $\\rho$. Can an arbitrary homeomorphic transformation of the plane in itself always be approached by those of the group $\\sigma$?\n\nAn analogous problem remains for $n>2$ dimensional spaces.\n\nProblem of M.S. Ulam.\n\n61) Let $E$ be a $G_{\\delta}$ set in the plane (more generally: a Borel set) all of whose intersections with the lines parallel to the $y$ axis are closed sets (more generally: $F_{\\sigma}$). Is the projection of $E$ on the $x$ axis always a Borel set?\t\n\nProblem of M. E. Szpilrajsn.\n\n62) The (real) function $f(x)$ of the real variable $x$ is called *symmetric-continuous* if for every $x$\n$$\\lim \\limits_{h \\to 0} [f( x+h ) - f(x - h)] = 0.$$\nCan the set of discontinuities of such a function be uncountable? Can it be an arbitrarily prescribed set $F_{\\sigma}$? (That they are an arbitrarily prescribed countable set is easy to see.)\n\nProblem of M. F. Hausdorff.\n\n63) Two compact spaces $A$ and $B$ have the *same homotopy type*, when there exists a continuous transformation $f$ from $A$ to $B$ and a continuous transformation $\\varphi$ from $B$ to $A$, such as the superpositions $\\varphi f$ and $f\\varphi$ (consider respectively as transformations of $A$ into $A$ and of $B$ into $B$) are homotopic to the identity. Are two closed varieties of the same homotopy type always homomorphic?\n\nProblem of M. W. Hurewicz.\n\n64) Do there exist two in $R^{n}$ orientable Manifolds $M_{1}^{k}$ and $M_{2}^{k}$, whose Complementary $R^{n} - M_{1}^{k}$ and $R^{n} - M_{2}^{k}$ are homomorphic and whose Homology rings are not isomorphic?\n\n65) Let $B_{0}, B_{1}, B_{2}, \\dots, B_{\\omega}, \\dots, B_{\\alpha}, \\dots$ be Borel classes of sets, formed in starting from any class of abstract sets. We know that $B_{\\alpha} = B_{\\alpha+}$. results in $B_{\\alpha}= B_{\\beta}$ for all $\\beta>\\alpha$; let $\\alpha_{0}$ be the first number $\\alpha$ satisfying this condition. What are the numbers $\\nu$ for which there exist classes $B_{0}$ such that we have $\\alpha_{0} = \\nu$? (Cf. Fund. Math. t. XV, p. 284).\n\nProblem of M. A. Kolmogoroff.\n\n66) Does the *weak* $LC$ property entail the strong $LC$ property for any compact metric space? Same question for $HLC$ properties . (For definitions see Annals of Mathematics , vol. 85, p. 119-129 and Duke Mathematical Journal, vol . 1, p. 1-18).\n\nProblem of M. S. Lefschetz.\n\n67) Is the property ($C$) of linear sets invariant with respect to homeomorphic transformations and, more generally, with respect to continuous transformations? (We say that a set $E$ has the *property ($C$)*, when there exists for each sequence $\\{a_{n}\\}$ of positive numbers a decomposition $E=E_{1}+E_{2} + \\dots $ such that the diameter of $E_{n}$ does not exceed $ a_{n}$ for $n= 1, 2,\\dots$. Cf. Fund. Math, volume XI, p. 304; volume XV, p. 126; volume XXII, p. 310.)\n\nProblem of M. W. Sierpinski.\n\n68) If $E_{1}$ and $ E_{2}$ are two linear sets always of first category (i.e. of first category on any perfect set), the set $E_{1} \\times E_{2}$. (i.e. the set of all points $(x, y)$ of the plane where $x \\in E_{1}$ and $y \\in E_{2}$) Is it of the same nature?\n\nProblem of M. E. Szpilrajn.\n\n69) When a Jordan curve (in a three-dimensional space) has a determinate tangent at each point, does there necessarily exist a parametric representation of this curve expressing the cartesian coordinates of a point of this curve as functions which can be derived from a parameter (and in this case the three derivatives cannot all cancel out at the same time)?\n\nIf the answer is negative, the question is asked again by admitting a set of zero measurement values of the parameter where the imposed conditions are not both satisfied.\n\nProblem of M. M. Fr\\'echet.\n\n70) Does there exist a linear set $ E$ such that each linear analytical set is a one-to-one and continuous (in one sense) image of $E$?\n\nProblem of M. W. Sierpinski.\n\n71) Does there exist an infinite sequence $S$ of functions of a real variable (measurable or not), such that any function of a real variable of class $2$ Baire is a limit of some sequence extracted from $S$?\n\n(According to M. C. Burstin such a sequence $S$ cannot be composed uniquely of measurable functions[^4])\n\nProblem M. W. Sierpinski.\n\n[^4]: Monatshefte f. Math. u. Phys. 28 (1917), p. 107.\n\n72) Does there exist in the $n$-dimensional Cartesian space ($n>1$) a set always of the first category (i.e. of first category on each perfect set) and which is of positive dimension?\n\n(M. W. Hurewicz demonstrated using the continuum hypothesis that there exists in Hilbert space an uncountable set $H$ of which each uncountable subset is of infinite dimension[^5]). M. F. Hausdorff noticed that the set $H$ is always of the first category. This follows easily from the fact that each separable metric space $M$ is the sum of a set of dimension $0$ and a set of first category in $M$. -- *There therefore exists, if $2^{\\aleph} = \\aleph_{1}$, in Hilbert space a set always of first category and of positive dimension*).\n\nProbleme de M. E. Szpilrajn.\n\n[^5]: Fund . Math. 19 (1932), p.8.\n\n\n73) Let, in three-dimensional Euclidean space, $E$ be a homeomorphic image of the solid sphere $S$ and $L$ be a rectilinear segment whose interior is contained in the interior, and the ends in the border of $E$ . Does there still exist a homeomorphism transforming $E$ into $S$ such that $L$ is transformed into the diameter of $S$?\n\nProblem of M. K. Borsuk.\n\n74) Let $\\mathbf {B}(\\mathbf {F})$ be the smallest family of sets containing the given family $ \\mathbf {F}$ and closed with respect to the operations $\\sigma$ and $\\delta$ (addition and multiplication of countable values). Is there a family of enumerable $\\mathbf{D}$ of sets, such that all linear analytic sets belong to $\\mathbf {B}(\\mathbf{D})$ ?\n\nProblem of M. S. Ulam.\n\n\n75) Is there an infinite set $E$ (e.g. the set of all natural numbers) and a function $f(X)$ which maps to any subset $X$ of $E $ a subset $f(X)$ of $E$, so that:\n\n1. $X \\subset f(X)$ for $X \\subset E$,\n2. $f(X+Y) = f(X) + f(Y)$ for $X \\subset E$, $Y \\subset E$,\n3. there exists for every set $Y \\subset E$ at least one set $X \\subset E$, such that $Y = f(X)$,\n4. there exists at least one set $X_{0} \\subset E$, such that $f(X_{0}) \\neq X_{0}$.\n\nIf we replace the relative condition to $f(X+Y)$ by the condition weaker than $f(X) \\subset f(Y)$ pure $X \\subset Y \\subset E$, the positive answer is obvious.\n\nProblem of M. E. $\\check{\\text{C}}$ech.\n\n\n\n\n\n# Problems resolved.\n\n1) When is a set of points $P$ a one-to-one and continuous image (in a sense) of $Q$ and $Q$ a one-to-one and continuous image of $P$, can we affirm that the sets $P$ and $Q$ are homeomorphic?\n\n*Negative* solution from M. Kuratowski, Fund. Math. t. II, pp. 158-160\n\n4) Is there a decomposition of an interval into $\\aleph_{1}$ measurable sets ($B$), each non-empty and without common points?\n\n*Affirmative* solution from MM. Lusin and Sierpinski, *Comptes Rendus*, t. 175, p.357 (note of August 21, 1922).\n\n6) Third part. Can it be shown that a product of $\\aleph_{1}$ sets ($A$) is not necessarily a set ($A$)?\n\n*Affirmative* solution from MM. Lusin and Sierpinski, *Journ, de Math*. 1923 (The authors define a set which is complementary to a set ($A$) is not necessarily a set ($A$).)\n\n8) Can we give an effective example of a set of real numbers $E$, such as any sum, difference, product or quotient of two numbers of $E$ (except division by 0) belongs to $E_{1}$ and that $E$ is uncountable, distinct from the set of all real numbers?\n\n*Affirmative* solution from M. Souslin, *Fund. Math.* IV, p.311.\n\n10) First part. Is there a second class function which is not the limit of almost everywhere discontinuous functions?\n\n*Affirmative* solution from M. Zalcwasser.\n\n12) Does an ordered set of which all well-ordered subsets (increasing or decreasing) are at most enumerable necessarily have a power no greater than that of the continuum?\n\n*Affirmative* solution from M. Urysohn, *Fund. Math.* V (to appear).\n\n15) Is there a continuum of which any subcontinuum is indecomposable?\n\n*Affirmative* solution from M. Knaster, *Fund. Math.* III pp. 247-286.\n\n16) Does there exist a continuum which is a sum of its proper disjoint saturated subcontinua?\n\n*Affirmative* solution by MM. Knaster and Kuratowski, *Fund. Math.* V.\n\n\n","source":"_posts/75 Problems.md","raw":"---\ntitle: 75 Problems in the Foundation of Mathematics\ndate: 2023-09-22 22:10:39\ntags:\n    - [Set Theory]\ncategories:\n    - [Set Theory]\nmathjax: true\n---\n\n# Forewords\n\n\nThere are 75 open problems recorded in the Polish journal *Fundamenta Mathematicae* in volumes 1-34 from its inception, some of which have already been solved. These problems represent the development of the foundations of mathematics since the late 19th century when M. G. Cantor established naive set theory. The original text is in French and German, and the translated version is as follows.\n\n\n# Problems\n\n\n1) When is a set of points $P$ a one-to-one and continuous image (but not necessarily bi-continuous) of a set $Q$ and when is $Q$ a one-to-one and continuous image of $P$? Are the sets $P$ and $Q $ necessarily homeomorphic?\n\nProblem of M. W. Sierpinski. \n\n2) Is a (bounded) planar continuum, topologically homogeneous, necessarily homeomorphic to a circumference?\n\n(A set $E$ is said to be *topologically homogeneous*, when there exists for any pair of points $a, b$ of $E$ a one-to-one and bi-continuous transformation of $E$ into itself which transforms $a$ into $b$)\n\nProblem of MM. B. Knaster and C. Kuratowski.\n\n3) Is a set ordered (linearly) without jumps or gaps and such that any set of its intervals (containing more than one element) does not overlap with each other is at most innumerable, necessarily a (ordinary) linear continuum?\n\nProblem of M. M. Souslin.\n\n4) Is there a decomposition of an interval into $\\aleph_{1}$ (non-empty) sets without common points that are $B$ measurable?\n\nProblem of M. W. Sierpinski.\n\n5) Does there exist an uncountable linear set $E$ such that every linear set homeomorphic to $E$ has zero Lebesgue measure? Can we prove the existence of such a set assuming that $2^{\\aleph_{0}} = \\aleph_{1}$?\n\nProblem of M. W. Sierpinski.\n\n6) Can we find without the hypothesis of the continuum ($2^{\\aleph_{0}} = \\aleph_{1}$) that a sum of $\\aleph_{1}$ sets of zero Lebesgue measure is not necessarily zero Lebesgue measure? that a sum of $\\aleph_{1}$ sets of the first category is not necessarily of the first category? that a product of $\\aleph_{1}$ sets ($A$) is not necessarily a set ($A$)?\n\nProblem of M. W. Sierpinski.\n\n7) Can we establish without the hypothesis of the continuum the existence of a planar set which has zero (Lebesgue) measure on any direction parallel to the abscissa axis and whose complement has zero measure on any direction parallel to the ordinate axis?\n\nProblem of M. H. Steinhaus.\n\n8) Can we give an effective example of a set of real numbers $E$ such that any sum, difference, product or quotient of two numbers of $E$ (except division by 0) belongs to $E$ and that $E$ is uncountable, but distinct from the set of all real numbers?\n\nProblem of M. S. Mazurkiewicz.\n\n9) What is the power of sets complementary to sets ($A$)?\n\nProblem of M. N. Lusin.\n\n\n*Notice.* The linear sets ($A$) are orthogonal projections (on a line) of the measurable planar sets $B$. M. Lusin demonstrated that the power of an uncountable set complementary to a set ($A$) is $\\aleph_{1}$ or $2^{\\aleph_{0}}$, but we do not know if it can really be $\\aleph_{1}$ (in the case where $2^{\\aleph_{0}} > \\aleph_{1}$).\n\n10) Does there exist a second class function that is not a limit of almost everywhere continuous functions? Can we give an effective example of a function which is not a limit of piecewise continuous functions?\n\nProblem of MM. T. Feosztyn and W. Sierpinski.\n\n11) Does there exist a class ($\\mathcal{L}$) of M. Fr\\'echet (i.e. a class in which the limit is defined) of power greater than the continuum, such that any uncountable set of elements of this class contains at least one condensation element?\n\nProblem of M. W. Sierpinski.\n\n12) Does a (linearly) ordered set of which all well-ordered subsets (increasing and decreasing) are at most countable, necessarily have a power not greater than the continuum?\n\nProblem of M. W. Sierpinski.\n\n13) Does there exist a planar closed set which is not the sum of two closed sets without common points, but a sum of countable closed sets without common points.\n\nProblem of M. W. Sierpinski.\n\n14) Does a continuum in $m$-dimensional space which is homeomorphic to any continuum contain necessarily a simple arc (i.e. image of an one-to-one and continuous mapping of the interval $(0,1)$?\n\nProblem of M. Mazurkiewicz.\n\n15) Does there exist a continuum of which every everything under continuous mapping is indecomposable? (A continuum is said to be indecomposable when it is not a sum of two continua different from it.)\n\nProblem of MM. Knaster and Kuratowski.\n\n16) Does there exist a continuum (unbounded) which is a sum of its proper saturated sub-continuums where any two of them do not intersect?\n\n(We say that a real subcontinuum $K$ of $C$ is *saturated*, when there exists no continuum different from $K$ and $C$ which contains $K$ and which is contained in $C$.)\n\nProblem of M. Kuratowski.\n\n17) What is the power of the set of all values that a Baire class 1 function does not take? \n\n(This problem is equivalent to problem 9 of M. Lusin, t. I. p.224. It would be enough to solve this problem for functions admitting uncountable points of discontinuity.)\n\n18) Is a (linear) set of power less than the continuum necessarily of the first category of M. Baire?\n\nProblem of M. Ruziewicz.\n\n19) Does there exist in each biconnected set $B$ a point $p$ such that the set $B - (p)$ contains no connected set?\n\n*Notice.* According to a theorem of M. Kline (this volume, p.238), there cannot exist in a connected set $B$ more than one point $p$ enjoying the property in question. We know, on the other hand, that, if such a point exists, the set $B$ is biconnected, i.e. it is not the sum of two disjoint connected sets containing more than one point (cf. Knaster and Kuratowski, *Fund. Math.* II, p, 214.)\n\nProblem of M. Kuratowski.\n\n20) Let $f(E)$ be a function defined by any measurable ($L$) set $E$ of a Euclidean space of $m \\geq 3$ dimensions and satisfying the following conditions:\n\n1. $f(E) \\geq 0$.\n2. $f(E_{0}) = 1$ for a certain set $E_{0}$ of measure 1.\n3. $f(E_{1} +E_{2}) = f(E_{1}) + f(E_{2})$, if $E_{1} E_{2} = 0$.\n4. $f(E_{1}) = f(E_{2})$, if $E_{1}$ and $E_{2}$ are superposable.\n\nDoes the function $f(E)$ necessarily coincide with the Lebesgue measure of the set $E$?\n\n(For $m=1$ and $m=2$ the answer is negative, as M. Banach proved in a memoir which will be published in the volume IV of this journal.)\n\nProblem of M. Ruziewicz.\n\n21) Given a set of real numbers which is not of the first category in any interval, is there a decomposition: $A = B + C$, $B \\times C = 0$ such that neither $B$ nor $C$ are of the first category in any interval?\n\n*Notice.* We could give the affirmative answer in the hypothesis additional that $A$ has the Baire property (in the sense established in this volume), p.319 . M. Sierpinski also pointed out the affirmative answer in the hypothesis of the continuum, $\\aleph_{1} = 2^{\\aleph_{0}}$.\n\nProblem of M. Kuratowski.\n\n22) Let us call the (linear) set $E$ *perfectly measurable*, if every set homeomorphic to $E$ is measurable in the sense of Lebesgue. What is the power of the class of perfectly measurable sets? Is a complementary set to a perf. measurable set always perf. measurable?\n\nProblem of M. Urysohn.\n\n23) Does there exist a function of a real variable $ f(x)$ pantachically dicontinuous and such that we have for all real $x$\n\n$$\\lim_{h \\to 0} \\frac{f( x+h ) - f(x-h)}{2h} = 0?$$\n\nProblem of M. Steinhaus.\n\n24) Is a function satisfying Baire's condition necessarily measurable ($L$)? What is the power of all the functions of a real variable satisfying the Baire condition? (We say that a function $f(x)$ satisfies the Baire condition, if it is continuous on any perfect set when we neglect the sets of the first category has with respect to that perfect set.)\n\nProblem of M. Sierpinski.\n\n25) Can a planar set, such that any straight line meets it at two (and only two) points, be measurable ($B$)? (The existence of such a set has been demonstrated, using M. Zermelo's theorem, by MM. Mazurkiewicz[^1] (in 1914) and Rosenthal[^2] (in 1922))\n\n\n[^1]: Accounts of the Soc. of Varsovic Sciences , t. VII, p.382.\n\n[^2]: Sitzungaber d. Bayer. Akad. d. Wiss., math.-phys. K1, 1922, p. 223.\n\n26) Is a class 3 function of M. Baire always a superposition of three class 1 functions, that is to say, does it exist for any function $f(x)$ of class 3 three class 1 functions $\\varphi(x)$, $\\psi(x)$ and $\\vartheta(x)$, such that we have for all real $x$\n\n$$f(x) = \\varphi \\{\\psi[\\vartheta (x)]\\}$$\n\nProblem of M. Lusin.\n\n27) Is the set $D(E)$ of the distances of the points of a linear set $E$ that is ($B$) measurable always ($B$) measurable? ($D(E)$ is therefore the set of all numbers $|x - y|$, where $x$ and $y$ belong to $E$. We can prove the existence of set $E$ that are measurable ($L$), such that $D(E)$ is non-measurable ($L$).)\n\nProblem of M. Sierpinski. \n\n28) If $E$ is a ($B$ measurable) planar set, let us denote by $N(E)$ the set of all real numbers $a$, such that the line $x = a$ meets $E$ at a uncountable infinite number of points. Is the set $N(E)$ necessarily a set ($A$), or, more simply, is it measurable ($L$)? (It can be shown that the set of all real numbers $a$, such that the line $x = a$ meets the ($B$ measurable) set $E$ in an infinity number of points is always a set ($A$).)\n\nProblem of M. Sierpinski. \n\n29) Let $F$ be a planar set, p. ex. closed (or, more generally, measurable) - A point $x$ of $F$ will be said to be *linearly accessible* if there exists a rectilinear segment $\\overline{xp}$ such that all its points (except the point $x$) are outside $F$. Can it be shown that the set $A$ of all linearly accessible points of $F$ is always measurable ($L$)?\n\nProblem of M. Urysohn.\n\n30) If $f(x)$ is an arbitrarily given function (measurable or not), what is the measure of the sum of all points $x$, such that\n\n$$\\lim \\limits_{h\\to 0} \\left |\\frac{f( x+h ) - f(x)}{h}\\right| = \\infty $$\n\nProblem of M. Ruziewicz.\n\n31) Is the statement \"$\\mathsf{m} = 2\\cdot\\mathsf{m}$ for any *transfinite* cardinal number $\\mathsf {m}$\" equivalent to *the axiom of choice*?\n\nCf. my Note \"*On some theorems which are equivalent to the axiom of choice*\" in this volume, p. 147.\n\nProblem of M. Tajtelbaum-Tarski .\n\n32) Is a planar closed set, where every point is linearly accessible, necessarily of zero surface measure?\n\nProblem of M. Banach.\n\nA point $x$ of $F$ is said to be linearly accessible if there exists a rectilinear segment $\\overline{xp}$ such that all its points (except the point $x$) are outside $F$. M. Urysohn proved that the set of all linearly accessible points of a planar closed set is always a set ($A$) of M. Souslin, but may not be measurable ($B$). But we do not know if the set of all linearly accessible points of a planar $G_{\\delta}$ set is measurable ($L$) (Cf. Problem 29, *Fund. Math.* t. V, p. 337).\n\n33) Is the image of a one-to-one and continuous map (in one sense) of a set complementary to a set ($A$) of M. Souslin necessarily a homeomorphism?\n\nProblem of Sierpinski.\n\n34) Let us call a (linear) set ($B$) measurable of class $\\alpha$ *irreducible* if it is not of class $<\\alpha$ in any interval. What is the power of the set of all topological types of irreducible sets of class $\\alpha$?\n\nLet us call a set ($A$) *irreducible*, if it is not ($B$) measurable in any interval. What is the power of all the topological types of the sets ($A$) irreducible?\n\nProblem of MM. Alexandroff and Urysohn.\n\n35) Let us call the (linear) set $E$ *perfectly measurable in the narrow sense*, if every unambiguous and continuous image of $E$ is measurable in the sense of Lebesgue. Is a set complementary to a set perfectly measurable in the narrow sense always a homeomorphic image?\n\nCf. Problem 22 of P. Urysohn (*Fund. Math.* t. IV, p. 368), solved by M. Lavrentieff (*Fund. Math.* t. VI, p. 159).\n\nProbleme de M. O. Nikodym.\n\n36) According to M. Souslin, if $E$ is a set ($A$) and $H$ a complementary set to a set ($A$), and if $E \\subset H$, there exists a set $Q$, ($B$) measurable, such that $E\\subset Q \\subset H$[^3]. Does this proposition admit a reciprocal, that is to say, *if $E$ is a complementary set to a set ($A$) and $H$ ------ does a set ($A$), such that $E \\subset H$, exist always a ($B$) measurable set $Q$, such that $E \\subset Q \\subset H$?*\n\nProblem of M. Sierpinski.\n\n[^3]: See p. e. N. Lusin and W. Sierpinski *Journ. of Math.* t. II (1923) p. 60; also *Bull. Acad. Krakow* 1918 p. 40.\n\n37) Is a Jordan (bounded) continuum which contains only a simple closed curve homeomorphic to one of its (real) sub-continuums?\n\nProblem of M. Zarankiewicz.\n\n38) Can a square and a circle whose areas are equal be decomposed into a finite number of respectively congruent disjoint subsets?\n\nProblem of M. Tarski.\n\n39) Does there exist a planar closed set for which the set of linearly accessible points is non-measurable ($B$)? (In the space the problem is resolved in the affirmative sense).\n\nProblem of M. O. Nikodym.\n\n40) If $E$ is a planar $G_{\\delta}$ set, is the set of all real numbers $a$, such that the line $x=a$ meets the set $E$ in one and only one point, not necessarily complementary to a set ($A$) of M. Souslin?\n\nProblem of M. Sierpinski.\n\n41) If $E_{1}, E_{2}, E_{3}, \\dots$ are a sequence of countable linear sets each of which is a projection of a planar set complementary to a set ($A$) of M. Souslin, is the set $E_{1}E_{2} E_{3} \\dots $ of the same nature?\n\nProblem of M. Sierpinski.\n\n42) Does there exist in every continuum $A$ a continuum $B$ such that the set $A - B$ is connected?\n\nProblem of MM. Knaster and Zarankiewicz.\n\n\n43) Let $D$ denote a closed set homeomorphic to a planar set located in 3-dimensional Euclidean space, is every point of $D$ is *accessible* in this space?\n\n(A point $d$ of $D$ is said to be *accessible* in $E$, when there exists a continuum $C \\subset E$ such that $(d) = CD$).\n\nProblem of M. Knaster.\n\nUnfortunately, Problem 44 and 45 by MM. N. Lusin and H. Steinhaus which should have appeared in XI, p.308, were missing. \n\n46) It is asked to set up the logical relations between the various concepts of homogeneity, in so far as they refer to locally compact sets. In particular, even if the sets are considered to be connected and (or) locally connected.\n\n(See D. van Dantzig , \"On topologically homogeneous continua, volume 15, pp. 102, 103).\n\nProblem of M. van Dantzig.\n\n47) Is every (connected, unbounded) $n$-dimensional manifold involutory homogeneous?\n\n(Cf. D. van Dantzig, le p. 104, ^7.)\n\nProblem of M. van Dantzig.\n\n48) Let us call a topological group *monothetic* if an infinite cyclic group is dense in it (in which case it is commutative and can be written additively), and *complete* if every sequence $x_{\\nu} $, which satisfies the Cauchy's convergence criterion $\\lim (x_{\\nu} - x_{\\mu }) = 0$ has a limit element in the group, the question is whether a monothetic group can be complete without being compact.\n\n(See lc p. 116 {}^{29}a))\n\nProblem of M. van Dantzig.\n\n49) Let $X$ and $Y$ be two Peano continua (= continuous images of the interval) and $Z$ be their topological product (= the space of all pairs $z = (x,y) $ or $\\lim z_{n}=z$ when $\\lim x_{n} = x$ and $\\lim y_{n} = y$).\n\n1^0. If the continuum $X$, as well as $Y$, has the property that in each continuous transformation of this continuum into a subset there exists an invariant point, is it true that $Z$ has the same property?\n\n2^0. If the continuum $X$, as well as $Y$, is uni-consistent (= in each decomposition of this continuum into two sub-continuums the common part of these sub-continuums is connected), is it true that $Z$ is uni-coherent?\n\nProblem of M. Kuratowski.\n\n50) Is the topological circle the only homogeneous locally connected curve? (Curve = one-dimensional connected compact space. A space is called homogeneous, if for each of its two points $p$ and $q$ there exist a homeomorphism which sends $p$ to $q$ ). On the plane, the circle is the only homogeneous locally connected curve.\n\n(Cf. Mazurkiewicz, Fund. Math. V, p. 137).\n\nProblem with M. K. Menger.\n\n51) Are there any or even an infinite number of compact one-dimensional spaces, any two of which are incomparable in dimension one? Two spaces $R$ and $R^{\\prime}$ may be called one-dimensionally incomparable, if no one-dimensional subset of $R$, (or of $R^{\\prime}$) is homeomorphic with a subset of $R^{\\prime}$ (or of $R^{\\prime}$). For example, a line and a continuum without partial arcs are incomparable in one dimension. (If there are $n$, or $\\aleph_{0}$ in pairs of one-dimensionally incomparable curves, then there exist compact one-dimensional spaces which contains at least $2^{n} +1$, or $2^{\\aleph_{0}}$ monotone, $F_{\\sigma}$-additive, topological, compactifiable systems of subsets).\n\t\n(See Monthly Issues f. Math. and Phys. 36, p. 207).\n\nProblem of M. K. Menger.\n\n52) Does there exist a continuum of which every other continuum is a continuous image?\n\nProblem of M. H. Hahn.\n\n53) a. Can any absolute retract be decomposed into a finite number of absolute retracts with arbitrarily small diameters?\n\nb. Can any $R$ set be decomposed into a finite number of absolute retracts?\n\n(The definition of absolute retracts and $R$ sets is given, for example, in Fund. Math. XIX, p. 222).\n\n54) Is every partial continuum $C$ of the Euclidean $n$-dimensional space $R_{n}$, which intersects $R_{n}$ and which is transferred by arbitrarily small transformations (i.e. by a continuous mapping which sends every point from $C$ to an arbitrarily close point of $R_{n}$) into a subset of $R_{n}$ that is foreign to it, a ($n-1$) dimensional space?\n\n55) Can every route image lying in $R_{3}$ and intersecting $R_{3}$ be mapped continuously without fixed points?\n\nProblem of M. K. Borsuk.\n\n56) Let $A$ and $B$ be two topological spaces and $A^{2}$ and $B^{2}$ respectively their squares (a. \\`ad $A^{2}$ p. ex. consists of all your pairs ($a_{1}$, $a_{2}$) extracted from $A$).\n\nIs it true that if $A^{2}$ and $B^{2}$ are homeomorphic, are $A$ and $B$ too?\n\nIn case of a positive answer, we deduce that, if $C$ is a set which is not homeomorphic to none of $C^{n}$, $n>1$, the sets $C^{m}$ and $C^{n}$ are neither homeomorphic for $m \\neq n$; this provides in the case where $C$ is an interval of the theorem of \"invariance of the dimension\" of M. Brouwer.\n\nProblem of M. S. Ulam.\n\n57) Does there exist an infinite-dimensional continuum that does not contain any finite-dimensional continuum?\n\nProblems of M. S. Mazurkiewicz.\n\n\n58) Does there exist in a set $E$ of size $\\aleph_{1}$ a countable system of subsets $A_{1}, A_{2},\\dots$ such that one has the form\n$$X = \\overline{\\lim} A_{p_{n}}$$\nwhere ($p_{1}, p_{2},\\dots$ is a subsequence of the natural numbers, $\\overline{\\lim}$ means the Borel *complete limit set*) all subsets $X, A_{1}, A_{2},\\dots$ are received from $E$?\n\n(It is a question of proving the negation without using the continuum hypothesis).\n\nProblems with M. F. Hausdorff. \n\n59) A function with the Baire property (i.e. continuous on any perfect set, when we neglect a set of $1^{st}$ category relative to this set) of a function with the Baire property, is it of the same nature?\n\nProblem of M. W. Sierpinski.\n\n60) Let $\\rho$ be the set of all homeomorphic transformations of the Cartesian plane in itself, of the form:\n$$x^{\\prime} = x, \\quad y^{\\prime} =f( x,y )$$\nand\n$$x^{\\prime}=g( x,y ), \\quad \ty^{\\prime}=y.$$\n\nLet us denote by $\\sigma$ the group formed by all the finite superpositions of all the transformations belonging to $\\rho$. Can an arbitrary homeomorphic transformation of the plane in itself always be approached by those of the group $\\sigma$?\n\nAn analogous problem remains for $n>2$ dimensional spaces.\n\nProblem of M.S. Ulam.\n\n61) Let $E$ be a $G_{\\delta}$ set in the plane (more generally: a Borel set) all of whose intersections with the lines parallel to the $y$ axis are closed sets (more generally: $F_{\\sigma}$). Is the projection of $E$ on the $x$ axis always a Borel set?\t\n\nProblem of M. E. Szpilrajsn.\n\n62) The (real) function $f(x)$ of the real variable $x$ is called *symmetric-continuous* if for every $x$\n$$\\lim \\limits_{h \\to 0} [f( x+h ) - f(x - h)] = 0.$$\nCan the set of discontinuities of such a function be uncountable? Can it be an arbitrarily prescribed set $F_{\\sigma}$? (That they are an arbitrarily prescribed countable set is easy to see.)\n\nProblem of M. F. Hausdorff.\n\n63) Two compact spaces $A$ and $B$ have the *same homotopy type*, when there exists a continuous transformation $f$ from $A$ to $B$ and a continuous transformation $\\varphi$ from $B$ to $A$, such as the superpositions $\\varphi f$ and $f\\varphi$ (consider respectively as transformations of $A$ into $A$ and of $B$ into $B$) are homotopic to the identity. Are two closed varieties of the same homotopy type always homomorphic?\n\nProblem of M. W. Hurewicz.\n\n64) Do there exist two in $R^{n}$ orientable Manifolds $M_{1}^{k}$ and $M_{2}^{k}$, whose Complementary $R^{n} - M_{1}^{k}$ and $R^{n} - M_{2}^{k}$ are homomorphic and whose Homology rings are not isomorphic?\n\n65) Let $B_{0}, B_{1}, B_{2}, \\dots, B_{\\omega}, \\dots, B_{\\alpha}, \\dots$ be Borel classes of sets, formed in starting from any class of abstract sets. We know that $B_{\\alpha} = B_{\\alpha+}$. results in $B_{\\alpha}= B_{\\beta}$ for all $\\beta>\\alpha$; let $\\alpha_{0}$ be the first number $\\alpha$ satisfying this condition. What are the numbers $\\nu$ for which there exist classes $B_{0}$ such that we have $\\alpha_{0} = \\nu$? (Cf. Fund. Math. t. XV, p. 284).\n\nProblem of M. A. Kolmogoroff.\n\n66) Does the *weak* $LC$ property entail the strong $LC$ property for any compact metric space? Same question for $HLC$ properties . (For definitions see Annals of Mathematics , vol. 85, p. 119-129 and Duke Mathematical Journal, vol . 1, p. 1-18).\n\nProblem of M. S. Lefschetz.\n\n67) Is the property ($C$) of linear sets invariant with respect to homeomorphic transformations and, more generally, with respect to continuous transformations? (We say that a set $E$ has the *property ($C$)*, when there exists for each sequence $\\{a_{n}\\}$ of positive numbers a decomposition $E=E_{1}+E_{2} + \\dots $ such that the diameter of $E_{n}$ does not exceed $ a_{n}$ for $n= 1, 2,\\dots$. Cf. Fund. Math, volume XI, p. 304; volume XV, p. 126; volume XXII, p. 310.)\n\nProblem of M. W. Sierpinski.\n\n68) If $E_{1}$ and $ E_{2}$ are two linear sets always of first category (i.e. of first category on any perfect set), the set $E_{1} \\times E_{2}$. (i.e. the set of all points $(x, y)$ of the plane where $x \\in E_{1}$ and $y \\in E_{2}$) Is it of the same nature?\n\nProblem of M. E. Szpilrajn.\n\n69) When a Jordan curve (in a three-dimensional space) has a determinate tangent at each point, does there necessarily exist a parametric representation of this curve expressing the cartesian coordinates of a point of this curve as functions which can be derived from a parameter (and in this case the three derivatives cannot all cancel out at the same time)?\n\nIf the answer is negative, the question is asked again by admitting a set of zero measurement values of the parameter where the imposed conditions are not both satisfied.\n\nProblem of M. M. Fr\\'echet.\n\n70) Does there exist a linear set $ E$ such that each linear analytical set is a one-to-one and continuous (in one sense) image of $E$?\n\nProblem of M. W. Sierpinski.\n\n71) Does there exist an infinite sequence $S$ of functions of a real variable (measurable or not), such that any function of a real variable of class $2$ Baire is a limit of some sequence extracted from $S$?\n\n(According to M. C. Burstin such a sequence $S$ cannot be composed uniquely of measurable functions[^4])\n\nProblem M. W. Sierpinski.\n\n[^4]: Monatshefte f. Math. u. Phys. 28 (1917), p. 107.\n\n72) Does there exist in the $n$-dimensional Cartesian space ($n>1$) a set always of the first category (i.e. of first category on each perfect set) and which is of positive dimension?\n\n(M. W. Hurewicz demonstrated using the continuum hypothesis that there exists in Hilbert space an uncountable set $H$ of which each uncountable subset is of infinite dimension[^5]). M. F. Hausdorff noticed that the set $H$ is always of the first category. This follows easily from the fact that each separable metric space $M$ is the sum of a set of dimension $0$ and a set of first category in $M$. -- *There therefore exists, if $2^{\\aleph} = \\aleph_{1}$, in Hilbert space a set always of first category and of positive dimension*).\n\nProbleme de M. E. Szpilrajn.\n\n[^5]: Fund . Math. 19 (1932), p.8.\n\n\n73) Let, in three-dimensional Euclidean space, $E$ be a homeomorphic image of the solid sphere $S$ and $L$ be a rectilinear segment whose interior is contained in the interior, and the ends in the border of $E$ . Does there still exist a homeomorphism transforming $E$ into $S$ such that $L$ is transformed into the diameter of $S$?\n\nProblem of M. K. Borsuk.\n\n74) Let $\\mathbf {B}(\\mathbf {F})$ be the smallest family of sets containing the given family $ \\mathbf {F}$ and closed with respect to the operations $\\sigma$ and $\\delta$ (addition and multiplication of countable values). Is there a family of enumerable $\\mathbf{D}$ of sets, such that all linear analytic sets belong to $\\mathbf {B}(\\mathbf{D})$ ?\n\nProblem of M. S. Ulam.\n\n\n75) Is there an infinite set $E$ (e.g. the set of all natural numbers) and a function $f(X)$ which maps to any subset $X$ of $E $ a subset $f(X)$ of $E$, so that:\n\n1. $X \\subset f(X)$ for $X \\subset E$,\n2. $f(X+Y) = f(X) + f(Y)$ for $X \\subset E$, $Y \\subset E$,\n3. there exists for every set $Y \\subset E$ at least one set $X \\subset E$, such that $Y = f(X)$,\n4. there exists at least one set $X_{0} \\subset E$, such that $f(X_{0}) \\neq X_{0}$.\n\nIf we replace the relative condition to $f(X+Y)$ by the condition weaker than $f(X) \\subset f(Y)$ pure $X \\subset Y \\subset E$, the positive answer is obvious.\n\nProblem of M. E. $\\check{\\text{C}}$ech.\n\n\n\n\n\n# Problems resolved.\n\n1) When is a set of points $P$ a one-to-one and continuous image (in a sense) of $Q$ and $Q$ a one-to-one and continuous image of $P$, can we affirm that the sets $P$ and $Q$ are homeomorphic?\n\n*Negative* solution from M. Kuratowski, Fund. Math. t. II, pp. 158-160\n\n4) Is there a decomposition of an interval into $\\aleph_{1}$ measurable sets ($B$), each non-empty and without common points?\n\n*Affirmative* solution from MM. Lusin and Sierpinski, *Comptes Rendus*, t. 175, p.357 (note of August 21, 1922).\n\n6) Third part. Can it be shown that a product of $\\aleph_{1}$ sets ($A$) is not necessarily a set ($A$)?\n\n*Affirmative* solution from MM. Lusin and Sierpinski, *Journ, de Math*. 1923 (The authors define a set which is complementary to a set ($A$) is not necessarily a set ($A$).)\n\n8) Can we give an effective example of a set of real numbers $E$, such as any sum, difference, product or quotient of two numbers of $E$ (except division by 0) belongs to $E_{1}$ and that $E$ is uncountable, distinct from the set of all real numbers?\n\n*Affirmative* solution from M. Souslin, *Fund. Math.* IV, p.311.\n\n10) First part. Is there a second class function which is not the limit of almost everywhere discontinuous functions?\n\n*Affirmative* solution from M. Zalcwasser.\n\n12) Does an ordered set of which all well-ordered subsets (increasing or decreasing) are at most enumerable necessarily have a power no greater than that of the continuum?\n\n*Affirmative* solution from M. Urysohn, *Fund. Math.* V (to appear).\n\n15) Is there a continuum of which any subcontinuum is indecomposable?\n\n*Affirmative* solution from M. Knaster, *Fund. Math.* III pp. 247-286.\n\n16) Does there exist a continuum which is a sum of its proper disjoint saturated subcontinua?\n\n*Affirmative* solution by MM. Knaster and Kuratowski, *Fund. Math.* V.\n\n\n","slug":"75 Problems","published":1,"updated":"2024-11-27T15:17:33.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5ry000ym8nx5u59dojq","content":"<h1 id=\"forewords\">Forewords</h1>\r\n<p>There are 75 open problems recorded in the Polish journal\r\n<em>Fundamenta Mathematicae</em> in volumes 1-34 from its inception,\r\nsome of which have already been solved. These problems represent the\r\ndevelopment of the foundations of mathematics since the late 19th\r\ncentury when M. G. Cantor established naive set theory. The original\r\ntext is in French and German, and the translated version is as\r\nfollows.</p>\r\n<h1 id=\"problems\">Problems</h1>\r\n<ol type=\"1\">\r\n<li>When is a set of points <span class=\"math inline\">\\(P\\)</span> a\r\none-to-one and continuous image (but not necessarily bi-continuous) of a\r\nset <span class=\"math inline\">\\(Q\\)</span> and when is <span class=\"math inline\">\\(Q\\)</span> a one-to-one and continuous image of\r\n<span class=\"math inline\">\\(P\\)</span>? Are the sets <span class=\"math inline\">\\(P\\)</span> and $Q $ necessarily homeomorphic?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Is a (bounded) planar continuum, topologically homogeneous,\r\nnecessarily homeomorphic to a circumference?</li>\r\n</ol>\r\n<p>(A set <span class=\"math inline\">\\(E\\)</span> is said to be\r\n<em>topologically homogeneous</em>, when there exists for any pair of\r\npoints <span class=\"math inline\">\\(a, b\\)</span> of <span class=\"math inline\">\\(E\\)</span> a one-to-one and bi-continuous\r\ntransformation of <span class=\"math inline\">\\(E\\)</span> into itself\r\nwhich transforms <span class=\"math inline\">\\(a\\)</span> into <span class=\"math inline\">\\(b\\)</span>)</p>\r\n<p>Problem of MM. B. Knaster and C. Kuratowski.</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>Is a set ordered (linearly) without jumps or gaps and such that any\r\nset of its intervals (containing more than one element) does not overlap\r\nwith each other is at most innumerable, necessarily a (ordinary) linear\r\ncontinuum?</li>\r\n</ol>\r\n<p>Problem of M. M. Souslin.</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>Is there a decomposition of an interval into <span class=\"math inline\">\\(\\aleph_{1}\\)</span> (non-empty) sets without\r\ncommon points that are <span class=\"math inline\">\\(B\\)</span>\r\nmeasurable?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"5\" type=\"1\">\r\n<li>Does there exist an uncountable linear set <span class=\"math inline\">\\(E\\)</span> such that every linear set homeomorphic\r\nto <span class=\"math inline\">\\(E\\)</span> has zero Lebesgue measure? Can\r\nwe prove the existence of such a set assuming that <span class=\"math inline\">\\(2^{\\aleph_{0}} = \\aleph_{1}\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"6\" type=\"1\">\r\n<li>Can we find without the hypothesis of the continuum (<span class=\"math inline\">\\(2^{\\aleph_{0}} = \\aleph_{1}\\)</span>) that a sum\r\nof <span class=\"math inline\">\\(\\aleph_{1}\\)</span> sets of zero Lebesgue\r\nmeasure is not necessarily zero Lebesgue measure? that a sum of <span class=\"math inline\">\\(\\aleph_{1}\\)</span> sets of the first category is\r\nnot necessarily of the first category? that a product of <span class=\"math inline\">\\(\\aleph_{1}\\)</span> sets (<span class=\"math inline\">\\(A\\)</span>) is not necessarily a set (<span class=\"math inline\">\\(A\\)</span>)?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"7\" type=\"1\">\r\n<li>Can we establish without the hypothesis of the continuum the\r\nexistence of a planar set which has zero (Lebesgue) measure on any\r\ndirection parallel to the abscissa axis and whose complement has zero\r\nmeasure on any direction parallel to the ordinate axis?</li>\r\n</ol>\r\n<p>Problem of M. H. Steinhaus.</p>\r\n<ol start=\"8\" type=\"1\">\r\n<li>Can we give an effective example of a set of real numbers <span class=\"math inline\">\\(E\\)</span> such that any sum, difference, product\r\nor quotient of two numbers of <span class=\"math inline\">\\(E\\)</span>\r\n(except division by 0) belongs to <span class=\"math inline\">\\(E\\)</span>\r\nand that <span class=\"math inline\">\\(E\\)</span> is uncountable, but\r\ndistinct from the set of all real numbers?</li>\r\n</ol>\r\n<p>Problem of M. S. Mazurkiewicz.</p>\r\n<ol start=\"9\" type=\"1\">\r\n<li>What is the power of sets complementary to sets (<span class=\"math inline\">\\(A\\)</span>)?</li>\r\n</ol>\r\n<p>Problem of M. N. Lusin.</p>\r\n<p><em>Notice.</em> The linear sets (<span class=\"math inline\">\\(A\\)</span>) are orthogonal projections (on a line)\r\nof the measurable planar sets <span class=\"math inline\">\\(B\\)</span>. M.\r\nLusin demonstrated that the power of an uncountable set complementary to\r\na set (<span class=\"math inline\">\\(A\\)</span>) is <span class=\"math inline\">\\(\\aleph_{1}\\)</span> or <span class=\"math inline\">\\(2^{\\aleph_{0}}\\)</span>, but we do not know if it\r\ncan really be <span class=\"math inline\">\\(\\aleph_{1}\\)</span> (in the\r\ncase where <span class=\"math inline\">\\(2^{\\aleph_{0}} &gt;\r\n\\aleph_{1}\\)</span>).</p>\r\n<ol start=\"10\" type=\"1\">\r\n<li>Does there exist a second class function that is not a limit of\r\nalmost everywhere continuous functions? Can we give an effective example\r\nof a function which is not a limit of piecewise continuous\r\nfunctions?</li>\r\n</ol>\r\n<p>Problem of MM. T. Feosztyn and W. Sierpinski.</p>\r\n<ol start=\"11\" type=\"1\">\r\n<li>Does there exist a class (<span class=\"math inline\">\\(\\mathcal{L}\\)</span>) of M. Fr'echet (i.e. a class\r\nin which the limit is defined) of power greater than the continuum, such\r\nthat any uncountable set of elements of this class contains at least one\r\ncondensation element?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"12\" type=\"1\">\r\n<li>Does a (linearly) ordered set of which all well-ordered subsets\r\n(increasing and decreasing) are at most countable, necessarily have a\r\npower not greater than the continuum?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"13\" type=\"1\">\r\n<li>Does there exist a planar closed set which is not the sum of two\r\nclosed sets without common points, but a sum of countable closed sets\r\nwithout common points.</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"14\" type=\"1\">\r\n<li>Does a continuum in <span class=\"math inline\">\\(m\\)</span>-dimensional space which is homeomorphic\r\nto any continuum contain necessarily a simple arc (i.e. image of an\r\none-to-one and continuous mapping of the interval <span class=\"math inline\">\\((0,1)\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. Mazurkiewicz.</p>\r\n<ol start=\"15\" type=\"1\">\r\n<li>Does there exist a continuum of which every everything under\r\ncontinuous mapping is indecomposable? (A continuum is said to be\r\nindecomposable when it is not a sum of two continua different from\r\nit.)</li>\r\n</ol>\r\n<p>Problem of MM. Knaster and Kuratowski.</p>\r\n<ol start=\"16\" type=\"1\">\r\n<li>Does there exist a continuum (unbounded) which is a sum of its\r\nproper saturated sub-continuums where any two of them do not\r\nintersect?</li>\r\n</ol>\r\n<p>(We say that a real subcontinuum <span class=\"math inline\">\\(K\\)</span> of <span class=\"math inline\">\\(C\\)</span> is <em>saturated</em>, when there\r\nexists no continuum different from <span class=\"math inline\">\\(K\\)</span> and <span class=\"math inline\">\\(C\\)</span> which contains <span class=\"math inline\">\\(K\\)</span> and which is contained in <span class=\"math inline\">\\(C\\)</span>.)</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"17\" type=\"1\">\r\n<li>What is the power of the set of all values that a Baire class 1\r\nfunction does not take?</li>\r\n</ol>\r\n<p>(This problem is equivalent to problem 9 of M. Lusin, t. I. p.224. It\r\nwould be enough to solve this problem for functions admitting\r\nuncountable points of discontinuity.)</p>\r\n<ol start=\"18\" type=\"1\">\r\n<li>Is a (linear) set of power less than the continuum necessarily of\r\nthe first category of M. Baire?</li>\r\n</ol>\r\n<p>Problem of M. Ruziewicz.</p>\r\n<ol start=\"19\" type=\"1\">\r\n<li>Does there exist in each biconnected set <span class=\"math inline\">\\(B\\)</span> a point <span class=\"math inline\">\\(p\\)</span> such that the set <span class=\"math inline\">\\(B - (p)\\)</span> contains no connected set?</li>\r\n</ol>\r\n<p><em>Notice.</em> According to a theorem of M. Kline (this volume,\r\np.238), there cannot exist in a connected set <span class=\"math inline\">\\(B\\)</span> more than one point <span class=\"math inline\">\\(p\\)</span> enjoying the property in question. We\r\nknow, on the other hand, that, if such a point exists, the set <span class=\"math inline\">\\(B\\)</span> is biconnected, i.e. it is not the sum\r\nof two disjoint connected sets containing more than one point (cf.\r\nKnaster and Kuratowski, <em>Fund. Math.</em> II, p, 214.)</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"20\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(f(E)\\)</span> be a function defined\r\nby any measurable (<span class=\"math inline\">\\(L\\)</span>) set <span class=\"math inline\">\\(E\\)</span> of a Euclidean space of <span class=\"math inline\">\\(m \\geq 3\\)</span> dimensions and satisfying the\r\nfollowing conditions:</li>\r\n</ol>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(f(E) \\geq 0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(f(E_{0}) = 1\\)</span> for a certain set\r\n<span class=\"math inline\">\\(E_{0}\\)</span> of measure 1.</li>\r\n<li><span class=\"math inline\">\\(f(E_{1} +E_{2}) = f(E_{1}) +\r\nf(E_{2})\\)</span>, if <span class=\"math inline\">\\(E_{1} E_{2} =\r\n0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(f(E_{1}) = f(E_{2})\\)</span>, if <span class=\"math inline\">\\(E_{1}\\)</span> and <span class=\"math inline\">\\(E_{2}\\)</span> are superposable.</li>\r\n</ol>\r\n<p>Does the function <span class=\"math inline\">\\(f(E)\\)</span>\r\nnecessarily coincide with the Lebesgue measure of the set <span class=\"math inline\">\\(E\\)</span>?</p>\r\n<p>(For <span class=\"math inline\">\\(m=1\\)</span> and <span class=\"math inline\">\\(m=2\\)</span> the answer is negative, as M. Banach\r\nproved in a memoir which will be published in the volume IV of this\r\njournal.)</p>\r\n<p>Problem of M. Ruziewicz.</p>\r\n<ol start=\"21\" type=\"1\">\r\n<li>Given a set of real numbers which is not of the first category in\r\nany interval, is there a decomposition: <span class=\"math inline\">\\(A =\r\nB + C\\)</span>, <span class=\"math inline\">\\(B \\times C = 0\\)</span> such\r\nthat neither <span class=\"math inline\">\\(B\\)</span> nor <span class=\"math inline\">\\(C\\)</span> are of the first category in any\r\ninterval?</li>\r\n</ol>\r\n<p><em>Notice.</em> We could give the affirmative answer in the\r\nhypothesis additional that <span class=\"math inline\">\\(A\\)</span> has\r\nthe Baire property (in the sense established in this volume), p.319 . M.\r\nSierpinski also pointed out the affirmative answer in the hypothesis of\r\nthe continuum, <span class=\"math inline\">\\(\\aleph_{1} =\r\n2^{\\aleph_{0}}\\)</span>.</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"22\" type=\"1\">\r\n<li>Let us call the (linear) set <span class=\"math inline\">\\(E\\)</span>\r\n<em>perfectly measurable</em>, if every set homeomorphic to <span class=\"math inline\">\\(E\\)</span> is measurable in the sense of Lebesgue.\r\nWhat is the power of the class of perfectly measurable sets? Is a\r\ncomplementary set to a perf. measurable set always perf.\r\nmeasurable?</li>\r\n</ol>\r\n<p>Problem of M. Urysohn.</p>\r\n<ol start=\"23\" type=\"1\">\r\n<li>Does there exist a function of a real variable $ f(x)$ pantachically\r\ndicontinuous and such that we have for all real <span class=\"math inline\">\\(x\\)</span></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\lim_{h \\to 0} \\frac{f( x+h ) -\r\nf(x-h)}{2h} = 0?\\]</span></p>\r\n<p>Problem of M. Steinhaus.</p>\r\n<ol start=\"24\" type=\"1\">\r\n<li>Is a function satisfying Baire's condition necessarily measurable\r\n(<span class=\"math inline\">\\(L\\)</span>)? What is the power of all the\r\nfunctions of a real variable satisfying the Baire condition? (We say\r\nthat a function <span class=\"math inline\">\\(f(x)\\)</span> satisfies the\r\nBaire condition, if it is continuous on any perfect set when we neglect\r\nthe sets of the first category has with respect to that perfect\r\nset.)</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"25\" type=\"1\">\r\n<li>Can a planar set, such that any straight line meets it at two (and\r\nonly two) points, be measurable (<span class=\"math inline\">\\(B\\)</span>)? (The existence of such a set has been\r\ndemonstrated, using M. Zermelo's theorem, by MM. Mazurkiewicz<a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a> (in 1914) and Rosenthal<a href=\"#fn2\" class=\"footnote-ref\" id=\"fnref2\" role=\"doc-noteref\"><sup>2</sup></a> (in 1922))</li>\r\n</ol>\r\n<ol start=\"26\" type=\"1\">\r\n<li>Is a class 3 function of M. Baire always a superposition of three\r\nclass 1 functions, that is to say, does it exist for any function <span class=\"math inline\">\\(f(x)\\)</span> of class 3 three class 1 functions\r\n<span class=\"math inline\">\\(\\varphi(x)\\)</span>, <span class=\"math inline\">\\(\\psi(x)\\)</span> and <span class=\"math inline\">\\(\\vartheta(x)\\)</span>, such that we have for all\r\nreal <span class=\"math inline\">\\(x\\)</span></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[f(x) = \\varphi \\{\\psi[\\vartheta\r\n(x)]\\}\\]</span></p>\r\n<p>Problem of M. Lusin.</p>\r\n<ol start=\"27\" type=\"1\">\r\n<li>Is the set <span class=\"math inline\">\\(D(E)\\)</span> of the\r\ndistances of the points of a linear set <span class=\"math inline\">\\(E\\)</span> that is (<span class=\"math inline\">\\(B\\)</span>) measurable always (<span class=\"math inline\">\\(B\\)</span>) measurable? (<span class=\"math inline\">\\(D(E)\\)</span> is therefore the set of all numbers\r\n<span class=\"math inline\">\\(|x - y|\\)</span>, where <span class=\"math inline\">\\(x\\)</span> and <span class=\"math inline\">\\(y\\)</span> belong to <span class=\"math inline\">\\(E\\)</span>. We can prove the existence of set\r\n<span class=\"math inline\">\\(E\\)</span> that are measurable (<span class=\"math inline\">\\(L\\)</span>), such that <span class=\"math inline\">\\(D(E)\\)</span> is non-measurable (<span class=\"math inline\">\\(L\\)</span>).)</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"28\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(E\\)</span> is a (<span class=\"math inline\">\\(B\\)</span> measurable) planar set, let us denote\r\nby <span class=\"math inline\">\\(N(E)\\)</span> the set of all real numbers\r\n<span class=\"math inline\">\\(a\\)</span>, such that the line <span class=\"math inline\">\\(x = a\\)</span> meets <span class=\"math inline\">\\(E\\)</span> at a uncountable infinite number of\r\npoints. Is the set <span class=\"math inline\">\\(N(E)\\)</span> necessarily\r\na set (<span class=\"math inline\">\\(A\\)</span>), or, more simply, is it\r\nmeasurable (<span class=\"math inline\">\\(L\\)</span>)? (It can be shown\r\nthat the set of all real numbers <span class=\"math inline\">\\(a\\)</span>,\r\nsuch that the line <span class=\"math inline\">\\(x = a\\)</span> meets the\r\n(<span class=\"math inline\">\\(B\\)</span> measurable) set <span class=\"math inline\">\\(E\\)</span> in an infinity number of points is\r\nalways a set (<span class=\"math inline\">\\(A\\)</span>).)</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"29\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(F\\)</span> be a planar set, p. ex.\r\nclosed (or, more generally, measurable) - A point <span class=\"math inline\">\\(x\\)</span> of <span class=\"math inline\">\\(F\\)</span> will be said to be <em>linearly\r\naccessible</em> if there exists a rectilinear segment <span class=\"math inline\">\\(\\overline{xp}\\)</span> such that all its points\r\n(except the point <span class=\"math inline\">\\(x\\)</span>) are outside\r\n<span class=\"math inline\">\\(F\\)</span>. Can it be shown that the set\r\n<span class=\"math inline\">\\(A\\)</span> of all linearly accessible points\r\nof <span class=\"math inline\">\\(F\\)</span> is always measurable (<span class=\"math inline\">\\(L\\)</span>)?</li>\r\n</ol>\r\n<p>Problem of M. Urysohn.</p>\r\n<ol start=\"30\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(f(x)\\)</span> is an arbitrarily given\r\nfunction (measurable or not), what is the measure of the sum of all\r\npoints <span class=\"math inline\">\\(x\\)</span>, such that</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\lim \\limits_{h\\to 0} \\left |\\frac{f(\r\nx+h ) - f(x)}{h}\\right| = \\infty \\]</span></p>\r\n<p>Problem of M. Ruziewicz.</p>\r\n<ol start=\"31\" type=\"1\">\r\n<li>Is the statement \"<span class=\"math inline\">\\(\\mathsf{m} =\r\n2\\cdot\\mathsf{m}\\)</span> for any <em>transfinite</em> cardinal number\r\n<span class=\"math inline\">\\(\\mathsf {m}\\)</span>\" equivalent to <em>the\r\naxiom of choice</em>?</li>\r\n</ol>\r\n<p>Cf. my Note \"<em>On some theorems which are equivalent to the axiom\r\nof choice</em>\" in this volume, p. 147.</p>\r\n<p>Problem of M. Tajtelbaum-Tarski .</p>\r\n<ol start=\"32\" type=\"1\">\r\n<li>Is a planar closed set, where every point is linearly accessible,\r\nnecessarily of zero surface measure?</li>\r\n</ol>\r\n<p>Problem of M. Banach.</p>\r\n<p>A point <span class=\"math inline\">\\(x\\)</span> of <span class=\"math inline\">\\(F\\)</span> is said to be linearly accessible if\r\nthere exists a rectilinear segment <span class=\"math inline\">\\(\\overline{xp}\\)</span> such that all its points\r\n(except the point <span class=\"math inline\">\\(x\\)</span>) are outside\r\n<span class=\"math inline\">\\(F\\)</span>. M. Urysohn proved that the set\r\nof all linearly accessible points of a planar closed set is always a set\r\n(<span class=\"math inline\">\\(A\\)</span>) of M. Souslin, but may not be\r\nmeasurable (<span class=\"math inline\">\\(B\\)</span>). But we do not know\r\nif the set of all linearly accessible points of a planar <span class=\"math inline\">\\(G_{\\delta}\\)</span> set is measurable (<span class=\"math inline\">\\(L\\)</span>) (Cf. Problem 29, <em>Fund. Math.</em>\r\nt. V, p. 337).</p>\r\n<ol start=\"33\" type=\"1\">\r\n<li>Is the image of a one-to-one and continuous map (in one sense) of a\r\nset complementary to a set (<span class=\"math inline\">\\(A\\)</span>) of\r\nM. Souslin necessarily a homeomorphism?</li>\r\n</ol>\r\n<p>Problem of Sierpinski.</p>\r\n<ol start=\"34\" type=\"1\">\r\n<li>Let us call a (linear) set (<span class=\"math inline\">\\(B\\)</span>)\r\nmeasurable of class <span class=\"math inline\">\\(\\alpha\\)</span>\r\n<em>irreducible</em> if it is not of class <span class=\"math inline\">\\(&lt;\\alpha\\)</span> in any interval. What is the\r\npower of the set of all topological types of irreducible sets of class\r\n<span class=\"math inline\">\\(\\alpha\\)</span>?</li>\r\n</ol>\r\n<p>Let us call a set (<span class=\"math inline\">\\(A\\)</span>)\r\n<em>irreducible</em>, if it is not (<span class=\"math inline\">\\(B\\)</span>) measurable in any interval. What is\r\nthe power of all the topological types of the sets (<span class=\"math inline\">\\(A\\)</span>) irreducible?</p>\r\n<p>Problem of MM. Alexandroff and Urysohn.</p>\r\n<ol start=\"35\" type=\"1\">\r\n<li>Let us call the (linear) set <span class=\"math inline\">\\(E\\)</span>\r\n<em>perfectly measurable in the narrow sense</em>, if every unambiguous\r\nand continuous image of <span class=\"math inline\">\\(E\\)</span> is\r\nmeasurable in the sense of Lebesgue. Is a set complementary to a set\r\nperfectly measurable in the narrow sense always a homeomorphic\r\nimage?</li>\r\n</ol>\r\n<p>Cf. Problem 22 of P. Urysohn (<em>Fund. Math.</em> t. IV, p. 368),\r\nsolved by M. Lavrentieff (<em>Fund. Math.</em> t. VI, p. 159).</p>\r\n<p>Probleme de M. O. Nikodym.</p>\r\n<ol start=\"36\" type=\"1\">\r\n<li>According to M. Souslin, if <span class=\"math inline\">\\(E\\)</span>\r\nis a set (<span class=\"math inline\">\\(A\\)</span>) and <span class=\"math inline\">\\(H\\)</span> a complementary set to a set (<span class=\"math inline\">\\(A\\)</span>), and if <span class=\"math inline\">\\(E\r\n\\subset H\\)</span>, there exists a set <span class=\"math inline\">\\(Q\\)</span>, (<span class=\"math inline\">\\(B\\)</span>) measurable, such that <span class=\"math inline\">\\(E\\subset Q \\subset H\\)</span><a href=\"#fn3\" class=\"footnote-ref\" id=\"fnref3\" role=\"doc-noteref\"><sup>3</sup></a>.\r\nDoes this proposition admit a reciprocal, that is to say, <em>if <span class=\"math inline\">\\(E\\)</span> is a complementary set to a set (<span class=\"math inline\">\\(A\\)</span>) and <span class=\"math inline\">\\(H\\)</span> ------ does a set (<span class=\"math inline\">\\(A\\)</span>), such that <span class=\"math inline\">\\(E \\subset H\\)</span>, exist always a (<span class=\"math inline\">\\(B\\)</span>) measurable set <span class=\"math inline\">\\(Q\\)</span>, such that <span class=\"math inline\">\\(E \\subset Q \\subset H\\)</span>?</em></li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"37\" type=\"1\">\r\n<li>Is a Jordan (bounded) continuum which contains only a simple closed\r\ncurve homeomorphic to one of its (real) sub-continuums?</li>\r\n</ol>\r\n<p>Problem of M. Zarankiewicz.</p>\r\n<ol start=\"38\" type=\"1\">\r\n<li>Can a square and a circle whose areas are equal be decomposed into a\r\nfinite number of respectively congruent disjoint subsets?</li>\r\n</ol>\r\n<p>Problem of M. Tarski.</p>\r\n<ol start=\"39\" type=\"1\">\r\n<li>Does there exist a planar closed set for which the set of linearly\r\naccessible points is non-measurable (<span class=\"math inline\">\\(B\\)</span>)? (In the space the problem is resolved\r\nin the affirmative sense).</li>\r\n</ol>\r\n<p>Problem of M. O. Nikodym.</p>\r\n<ol start=\"40\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(E\\)</span> is a planar <span class=\"math inline\">\\(G_{\\delta}\\)</span> set, is the set of all real\r\nnumbers <span class=\"math inline\">\\(a\\)</span>, such that the line <span class=\"math inline\">\\(x=a\\)</span> meets the set <span class=\"math inline\">\\(E\\)</span> in one and only one point, not\r\nnecessarily complementary to a set (<span class=\"math inline\">\\(A\\)</span>) of M. Souslin?</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"41\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(E_{1}, E_{2}, E_{3}, \\dots\\)</span>\r\nare a sequence of countable linear sets each of which is a projection of\r\na planar set complementary to a set (<span class=\"math inline\">\\(A\\)</span>) of M. Souslin, is the set $E_{1}E_{2}\r\nE_{3} $ of the same nature?</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"42\" type=\"1\">\r\n<li>Does there exist in every continuum <span class=\"math inline\">\\(A\\)</span> a continuum <span class=\"math inline\">\\(B\\)</span> such that the set <span class=\"math inline\">\\(A - B\\)</span> is connected?</li>\r\n</ol>\r\n<p>Problem of MM. Knaster and Zarankiewicz.</p>\r\n<ol start=\"43\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(D\\)</span> denote a closed set\r\nhomeomorphic to a planar set located in 3-dimensional Euclidean space,\r\nis every point of <span class=\"math inline\">\\(D\\)</span> is\r\n<em>accessible</em> in this space?</li>\r\n</ol>\r\n<p>(A point <span class=\"math inline\">\\(d\\)</span> of <span class=\"math inline\">\\(D\\)</span> is said to be <em>accessible</em> in\r\n<span class=\"math inline\">\\(E\\)</span>, when there exists a continuum\r\n<span class=\"math inline\">\\(C \\subset E\\)</span> such that <span class=\"math inline\">\\((d) = CD\\)</span>).</p>\r\n<p>Problem of M. Knaster.</p>\r\n<p>Unfortunately, Problem 44 and 45 by MM. N. Lusin and H. Steinhaus\r\nwhich should have appeared in XI, p.308, were missing.</p>\r\n<ol start=\"46\" type=\"1\">\r\n<li>It is asked to set up the logical relations between the various\r\nconcepts of homogeneity, in so far as they refer to locally compact\r\nsets. In particular, even if the sets are considered to be connected and\r\n(or) locally connected.</li>\r\n</ol>\r\n<p>(See D. van Dantzig , \"On topologically homogeneous continua, volume\r\n15, pp. 102, 103).</p>\r\n<p>Problem of M. van Dantzig.</p>\r\n<ol start=\"47\" type=\"1\">\r\n<li>Is every (connected, unbounded) <span class=\"math inline\">\\(n\\)</span>-dimensional manifold involutory\r\nhomogeneous?</li>\r\n</ol>\r\n<p>(Cf. D. van Dantzig, le p. 104, ^7.)</p>\r\n<p>Problem of M. van Dantzig.</p>\r\n<ol start=\"48\" type=\"1\">\r\n<li>Let us call a topological group <em>monothetic</em> if an infinite\r\ncyclic group is dense in it (in which case it is commutative and can be\r\nwritten additively), and <em>complete</em> if every sequence $x_{} $,\r\nwhich satisfies the Cauchy's convergence criterion <span class=\"math inline\">\\(\\lim (x_{\\nu} - x_{\\mu }) = 0\\)</span> has a limit\r\nelement in the group, the question is whether a monothetic group can be\r\ncomplete without being compact.</li>\r\n</ol>\r\n<p>(See lc p. 116 {}^{29}a))</p>\r\n<p>Problem of M. van Dantzig.</p>\r\n<ol start=\"49\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(X\\)</span> and <span class=\"math inline\">\\(Y\\)</span> be two Peano continua (= continuous\r\nimages of the interval) and <span class=\"math inline\">\\(Z\\)</span> be\r\ntheir topological product (= the space of all pairs $z = (x,y) $ or\r\n<span class=\"math inline\">\\(\\lim z_{n}=z\\)</span> when <span class=\"math inline\">\\(\\lim x_{n} = x\\)</span> and <span class=\"math inline\">\\(\\lim y_{n} = y\\)</span>).</li>\r\n</ol>\r\n<p>1^0. If the continuum <span class=\"math inline\">\\(X\\)</span>, as well\r\nas <span class=\"math inline\">\\(Y\\)</span>, has the property that in each\r\ncontinuous transformation of this continuum into a subset there exists\r\nan invariant point, is it true that <span class=\"math inline\">\\(Z\\)</span> has the same property?</p>\r\n<p>2^0. If the continuum <span class=\"math inline\">\\(X\\)</span>, as well\r\nas <span class=\"math inline\">\\(Y\\)</span>, is uni-consistent (= in each\r\ndecomposition of this continuum into two sub-continuums the common part\r\nof these sub-continuums is connected), is it true that <span class=\"math inline\">\\(Z\\)</span> is uni-coherent?</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"50\" type=\"1\">\r\n<li>Is the topological circle the only homogeneous locally connected\r\ncurve? (Curve = one-dimensional connected compact space. A space is\r\ncalled homogeneous, if for each of its two points <span class=\"math inline\">\\(p\\)</span> and <span class=\"math inline\">\\(q\\)</span> there exist a homeomorphism which sends\r\n<span class=\"math inline\">\\(p\\)</span> to <span class=\"math inline\">\\(q\\)</span> ). On the plane, the circle is the only\r\nhomogeneous locally connected curve.</li>\r\n</ol>\r\n<p>(Cf. Mazurkiewicz, Fund. Math. V, p. 137).</p>\r\n<p>Problem with M. K. Menger.</p>\r\n<ol start=\"51\" type=\"1\">\r\n<li>Are there any or even an infinite number of compact one-dimensional\r\nspaces, any two of which are incomparable in dimension one? Two spaces\r\n<span class=\"math inline\">\\(R\\)</span> and <span class=\"math inline\">\\(R^{\\prime}\\)</span> may be called\r\none-dimensionally incomparable, if no one-dimensional subset of <span class=\"math inline\">\\(R\\)</span>, (or of <span class=\"math inline\">\\(R^{\\prime}\\)</span>) is homeomorphic with a subset\r\nof <span class=\"math inline\">\\(R^{\\prime}\\)</span> (or of <span class=\"math inline\">\\(R^{\\prime}\\)</span>). For example, a line and a\r\ncontinuum without partial arcs are incomparable in one dimension. (If\r\nthere are <span class=\"math inline\">\\(n\\)</span>, or <span class=\"math inline\">\\(\\aleph_{0}\\)</span> in pairs of one-dimensionally\r\nincomparable curves, then there exist compact one-dimensional spaces\r\nwhich contains at least <span class=\"math inline\">\\(2^{n} +1\\)</span>,\r\nor <span class=\"math inline\">\\(2^{\\aleph_{0}}\\)</span> monotone, <span class=\"math inline\">\\(F_{\\sigma}\\)</span>-additive, topological,\r\ncompactifiable systems of subsets).</li>\r\n</ol>\r\n<p>(See Monthly Issues f. Math. and Phys. 36, p. 207).</p>\r\n<p>Problem of M. K. Menger.</p>\r\n<ol start=\"52\" type=\"1\">\r\n<li>Does there exist a continuum of which every other continuum is a\r\ncontinuous image?</li>\r\n</ol>\r\n<p>Problem of M. H. Hahn.</p>\r\n<ol start=\"53\" type=\"1\">\r\n<li><ol type=\"a\">\r\n<li>Can any absolute retract be decomposed into a finite number of\r\nabsolute retracts with arbitrarily small diameters?</li>\r\n</ol></li>\r\n</ol>\r\n<ol start=\"2\" type=\"a\">\r\n<li>Can any <span class=\"math inline\">\\(R\\)</span> set be decomposed\r\ninto a finite number of absolute retracts?</li>\r\n</ol>\r\n<p>(The definition of absolute retracts and <span class=\"math inline\">\\(R\\)</span> sets is given, for example, in Fund.\r\nMath. XIX, p. 222).</p>\r\n<ol start=\"54\" type=\"1\">\r\n<li><p>Is every partial continuum <span class=\"math inline\">\\(C\\)</span>\r\nof the Euclidean <span class=\"math inline\">\\(n\\)</span>-dimensional\r\nspace <span class=\"math inline\">\\(R_{n}\\)</span>, which intersects <span class=\"math inline\">\\(R_{n}\\)</span> and which is transferred by\r\narbitrarily small transformations (i.e. by a continuous mapping which\r\nsends every point from <span class=\"math inline\">\\(C\\)</span> to an\r\narbitrarily close point of <span class=\"math inline\">\\(R_{n}\\)</span>)\r\ninto a subset of <span class=\"math inline\">\\(R_{n}\\)</span> that is\r\nforeign to it, a (<span class=\"math inline\">\\(n-1\\)</span>) dimensional\r\nspace?</p></li>\r\n<li><p>Can every route image lying in <span class=\"math inline\">\\(R_{3}\\)</span> and intersecting <span class=\"math inline\">\\(R_{3}\\)</span> be mapped continuously without\r\nfixed points?</p></li>\r\n</ol>\r\n<p>Problem of M. K. Borsuk.</p>\r\n<ol start=\"56\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(A\\)</span> and <span class=\"math inline\">\\(B\\)</span> be two topological spaces and <span class=\"math inline\">\\(A^{2}\\)</span> and <span class=\"math inline\">\\(B^{2}\\)</span> respectively their squares (a. `ad\r\n<span class=\"math inline\">\\(A^{2}\\)</span> p. ex. consists of all your\r\npairs (<span class=\"math inline\">\\(a_{1}\\)</span>, <span class=\"math inline\">\\(a_{2}\\)</span>) extracted from <span class=\"math inline\">\\(A\\)</span>).</li>\r\n</ol>\r\n<p>Is it true that if <span class=\"math inline\">\\(A^{2}\\)</span> and\r\n<span class=\"math inline\">\\(B^{2}\\)</span> are homeomorphic, are <span class=\"math inline\">\\(A\\)</span> and <span class=\"math inline\">\\(B\\)</span> too?</p>\r\n<p>In case of a positive answer, we deduce that, if <span class=\"math inline\">\\(C\\)</span> is a set which is not homeomorphic to\r\nnone of <span class=\"math inline\">\\(C^{n}\\)</span>, <span class=\"math inline\">\\(n&gt;1\\)</span>, the sets <span class=\"math inline\">\\(C^{m}\\)</span> and <span class=\"math inline\">\\(C^{n}\\)</span> are neither homeomorphic for <span class=\"math inline\">\\(m \\neq n\\)</span>; this provides in the case where\r\n<span class=\"math inline\">\\(C\\)</span> is an interval of the theorem of\r\n\"invariance of the dimension\" of M. Brouwer.</p>\r\n<p>Problem of M. S. Ulam.</p>\r\n<ol start=\"57\" type=\"1\">\r\n<li>Does there exist an infinite-dimensional continuum that does not\r\ncontain any finite-dimensional continuum?</li>\r\n</ol>\r\n<p>Problems of M. S. Mazurkiewicz.</p>\r\n<ol start=\"58\" type=\"1\">\r\n<li>Does there exist in a set <span class=\"math inline\">\\(E\\)</span> of\r\nsize <span class=\"math inline\">\\(\\aleph_{1}\\)</span> a countable system\r\nof subsets <span class=\"math inline\">\\(A_{1}, A_{2},\\dots\\)</span> such\r\nthat one has the form <span class=\"math display\">\\[X = \\overline{\\lim}\r\nA_{p_{n}}\\]</span> where (<span class=\"math inline\">\\(p_{1},\r\np_{2},\\dots\\)</span> is a subsequence of the natural numbers, <span class=\"math inline\">\\(\\overline{\\lim}\\)</span> means the Borel\r\n<em>complete limit set</em>) all subsets <span class=\"math inline\">\\(X,\r\nA_{1}, A_{2},\\dots\\)</span> are received from <span class=\"math inline\">\\(E\\)</span>?</li>\r\n</ol>\r\n<p>(It is a question of proving the negation without using the continuum\r\nhypothesis).</p>\r\n<p>Problems with M. F. Hausdorff.</p>\r\n<ol start=\"59\" type=\"1\">\r\n<li>A function with the Baire property (i.e. continuous on any perfect\r\nset, when we neglect a set of <span class=\"math inline\">\\(1^{st}\\)</span> category relative to this set) of\r\na function with the Baire property, is it of the same nature?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"60\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(\\rho\\)</span> be the set of all\r\nhomeomorphic transformations of the Cartesian plane in itself, of the\r\nform: <span class=\"math display\">\\[x^{\\prime} = x, \\quad y^{\\prime} =f(\r\nx,y )\\]</span> and <span class=\"math display\">\\[x^{\\prime}=g( x,y ),\r\n\\quad    y^{\\prime}=y.\\]</span></li>\r\n</ol>\r\n<p>Let us denote by <span class=\"math inline\">\\(\\sigma\\)</span> the\r\ngroup formed by all the finite superpositions of all the transformations\r\nbelonging to <span class=\"math inline\">\\(\\rho\\)</span>. Can an arbitrary\r\nhomeomorphic transformation of the plane in itself always be approached\r\nby those of the group <span class=\"math inline\">\\(\\sigma\\)</span>?</p>\r\n<p>An analogous problem remains for <span class=\"math inline\">\\(n&gt;2\\)</span> dimensional spaces.</p>\r\n<p>Problem of M.S. Ulam.</p>\r\n<ol start=\"61\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(E\\)</span> be a <span class=\"math inline\">\\(G_{\\delta}\\)</span> set in the plane (more\r\ngenerally: a Borel set) all of whose intersections with the lines\r\nparallel to the <span class=\"math inline\">\\(y\\)</span> axis are closed\r\nsets (more generally: <span class=\"math inline\">\\(F_{\\sigma}\\)</span>).\r\nIs the projection of <span class=\"math inline\">\\(E\\)</span> on the <span class=\"math inline\">\\(x\\)</span> axis always a Borel set?</li>\r\n</ol>\r\n<p>Problem of M. E. Szpilrajsn.</p>\r\n<ol start=\"62\" type=\"1\">\r\n<li>The (real) function <span class=\"math inline\">\\(f(x)\\)</span> of the\r\nreal variable <span class=\"math inline\">\\(x\\)</span> is called\r\n<em>symmetric-continuous</em> if for every <span class=\"math inline\">\\(x\\)</span> <span class=\"math display\">\\[\\lim\r\n\\limits_{h \\to 0} [f( x+h ) - f(x - h)] = 0.\\]</span> Can the set of\r\ndiscontinuities of such a function be uncountable? Can it be an\r\narbitrarily prescribed set <span class=\"math inline\">\\(F_{\\sigma}\\)</span>? (That they are an arbitrarily\r\nprescribed countable set is easy to see.)</li>\r\n</ol>\r\n<p>Problem of M. F. Hausdorff.</p>\r\n<ol start=\"63\" type=\"1\">\r\n<li>Two compact spaces <span class=\"math inline\">\\(A\\)</span> and <span class=\"math inline\">\\(B\\)</span> have the <em>same homotopy type</em>,\r\nwhen there exists a continuous transformation <span class=\"math inline\">\\(f\\)</span> from <span class=\"math inline\">\\(A\\)</span> to <span class=\"math inline\">\\(B\\)</span> and a continuous transformation <span class=\"math inline\">\\(\\varphi\\)</span> from <span class=\"math inline\">\\(B\\)</span> to <span class=\"math inline\">\\(A\\)</span>, such as the superpositions <span class=\"math inline\">\\(\\varphi f\\)</span> and <span class=\"math inline\">\\(f\\varphi\\)</span> (consider respectively as\r\ntransformations of <span class=\"math inline\">\\(A\\)</span> into <span class=\"math inline\">\\(A\\)</span> and of <span class=\"math inline\">\\(B\\)</span> into <span class=\"math inline\">\\(B\\)</span>) are homotopic to the identity. Are two\r\nclosed varieties of the same homotopy type always homomorphic?</li>\r\n</ol>\r\n<p>Problem of M. W. Hurewicz.</p>\r\n<ol start=\"64\" type=\"1\">\r\n<li><p>Do there exist two in <span class=\"math inline\">\\(R^{n}\\)</span>\r\norientable Manifolds <span class=\"math inline\">\\(M_{1}^{k}\\)</span> and\r\n<span class=\"math inline\">\\(M_{2}^{k}\\)</span>, whose Complementary\r\n<span class=\"math inline\">\\(R^{n} - M_{1}^{k}\\)</span> and <span class=\"math inline\">\\(R^{n} - M_{2}^{k}\\)</span> are homomorphic and\r\nwhose Homology rings are not isomorphic?</p></li>\r\n<li><p>Let <span class=\"math inline\">\\(B_{0}, B_{1}, B_{2}, \\dots,\r\nB_{\\omega}, \\dots, B_{\\alpha}, \\dots\\)</span> be Borel classes of sets,\r\nformed in starting from any class of abstract sets. We know that <span class=\"math inline\">\\(B_{\\alpha} = B_{\\alpha+}\\)</span>. results in\r\n<span class=\"math inline\">\\(B_{\\alpha}= B_{\\beta}\\)</span> for all <span class=\"math inline\">\\(\\beta&gt;\\alpha\\)</span>; let <span class=\"math inline\">\\(\\alpha_{0}\\)</span> be the first number <span class=\"math inline\">\\(\\alpha\\)</span> satisfying this condition. What\r\nare the numbers <span class=\"math inline\">\\(\\nu\\)</span> for which there\r\nexist classes <span class=\"math inline\">\\(B_{0}\\)</span> such that we\r\nhave <span class=\"math inline\">\\(\\alpha_{0} = \\nu\\)</span>? (Cf. Fund.\r\nMath. t. XV, p. 284).</p></li>\r\n</ol>\r\n<p>Problem of M. A. Kolmogoroff.</p>\r\n<ol start=\"66\" type=\"1\">\r\n<li>Does the <em>weak</em> <span class=\"math inline\">\\(LC\\)</span>\r\nproperty entail the strong <span class=\"math inline\">\\(LC\\)</span>\r\nproperty for any compact metric space? Same question for <span class=\"math inline\">\\(HLC\\)</span> properties . (For definitions see\r\nAnnals of Mathematics , vol. 85, p. 119-129 and Duke Mathematical\r\nJournal, vol . 1, p. 1-18).</li>\r\n</ol>\r\n<p>Problem of M. S. Lefschetz.</p>\r\n<ol start=\"67\" type=\"1\">\r\n<li>Is the property (<span class=\"math inline\">\\(C\\)</span>) of linear\r\nsets invariant with respect to homeomorphic transformations and, more\r\ngenerally, with respect to continuous transformations? (We say that a\r\nset <span class=\"math inline\">\\(E\\)</span> has the <em>property (<span class=\"math inline\">\\(C\\)</span>)</em>, when there exists for each\r\nsequence <span class=\"math inline\">\\(\\{a_{n}\\}\\)</span> of positive\r\nnumbers a decomposition $E=E_{1}+E_{2} + $ such that the diameter of\r\n<span class=\"math inline\">\\(E_{n}\\)</span> does not exceed $ a_{n}$ for\r\n<span class=\"math inline\">\\(n= 1, 2,\\dots\\)</span>. Cf. Fund. Math,\r\nvolume XI, p. 304; volume XV, p. 126; volume XXII, p. 310.)</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"68\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(E_{1}\\)</span> and $ E_{2}$ are two\r\nlinear sets always of first category (i.e. of first category on any\r\nperfect set), the set <span class=\"math inline\">\\(E_{1} \\times\r\nE_{2}\\)</span>. (i.e. the set of all points <span class=\"math inline\">\\((x, y)\\)</span> of the plane where <span class=\"math inline\">\\(x \\in E_{1}\\)</span> and <span class=\"math inline\">\\(y \\in E_{2}\\)</span>) Is it of the same\r\nnature?</li>\r\n</ol>\r\n<p>Problem of M. E. Szpilrajn.</p>\r\n<ol start=\"69\" type=\"1\">\r\n<li>When a Jordan curve (in a three-dimensional space) has a determinate\r\ntangent at each point, does there necessarily exist a parametric\r\nrepresentation of this curve expressing the cartesian coordinates of a\r\npoint of this curve as functions which can be derived from a parameter\r\n(and in this case the three derivatives cannot all cancel out at the\r\nsame time)?</li>\r\n</ol>\r\n<p>If the answer is negative, the question is asked again by admitting a\r\nset of zero measurement values of the parameter where the imposed\r\nconditions are not both satisfied.</p>\r\n<p>Problem of M. M. Fr'echet.</p>\r\n<ol start=\"70\" type=\"1\">\r\n<li>Does there exist a linear set $ E$ such that each linear analytical\r\nset is a one-to-one and continuous (in one sense) image of <span class=\"math inline\">\\(E\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"71\" type=\"1\">\r\n<li>Does there exist an infinite sequence <span class=\"math inline\">\\(S\\)</span> of functions of a real variable\r\n(measurable or not), such that any function of a real variable of class\r\n<span class=\"math inline\">\\(2\\)</span> Baire is a limit of some sequence\r\nextracted from <span class=\"math inline\">\\(S\\)</span>?</li>\r\n</ol>\r\n<p>(According to M. C. Burstin such a sequence <span class=\"math inline\">\\(S\\)</span> cannot be composed uniquely of\r\nmeasurable functions<a href=\"#fn4\" class=\"footnote-ref\" id=\"fnref4\" role=\"doc-noteref\"><sup>4</sup></a>)</p>\r\n<p>Problem M. W. Sierpinski.</p>\r\n<ol start=\"72\" type=\"1\">\r\n<li>Does there exist in the <span class=\"math inline\">\\(n\\)</span>-dimensional Cartesian space (<span class=\"math inline\">\\(n&gt;1\\)</span>) a set always of the first\r\ncategory (i.e. of first category on each perfect set) and which is of\r\npositive dimension?</li>\r\n</ol>\r\n<p>(M. W. Hurewicz demonstrated using the continuum hypothesis that\r\nthere exists in Hilbert space an uncountable set <span class=\"math inline\">\\(H\\)</span> of which each uncountable subset is of\r\ninfinite dimension<a href=\"#fn5\" class=\"footnote-ref\" id=\"fnref5\" role=\"doc-noteref\"><sup>5</sup></a>). M. F. Hausdorff noticed that the\r\nset <span class=\"math inline\">\\(H\\)</span> is always of the first\r\ncategory. This follows easily from the fact that each separable metric\r\nspace <span class=\"math inline\">\\(M\\)</span> is the sum of a set of\r\ndimension <span class=\"math inline\">\\(0\\)</span> and a set of first\r\ncategory in <span class=\"math inline\">\\(M\\)</span>. -- <em>There\r\ntherefore exists, if <span class=\"math inline\">\\(2^{\\aleph} =\r\n\\aleph_{1}\\)</span>, in Hilbert space a set always of first category and\r\nof positive dimension</em>).</p>\r\n<p>Probleme de M. E. Szpilrajn.</p>\r\n<ol start=\"73\" type=\"1\">\r\n<li>Let, in three-dimensional Euclidean space, <span class=\"math inline\">\\(E\\)</span> be a homeomorphic image of the solid\r\nsphere <span class=\"math inline\">\\(S\\)</span> and <span class=\"math inline\">\\(L\\)</span> be a rectilinear segment whose interior\r\nis contained in the interior, and the ends in the border of <span class=\"math inline\">\\(E\\)</span> . Does there still exist a\r\nhomeomorphism transforming <span class=\"math inline\">\\(E\\)</span> into\r\n<span class=\"math inline\">\\(S\\)</span> such that <span class=\"math inline\">\\(L\\)</span> is transformed into the diameter of\r\n<span class=\"math inline\">\\(S\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. K. Borsuk.</p>\r\n<ol start=\"74\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(\\mathbf {B}(\\mathbf {F})\\)</span> be\r\nthe smallest family of sets containing the given family $ $ and closed\r\nwith respect to the operations <span class=\"math inline\">\\(\\sigma\\)</span> and <span class=\"math inline\">\\(\\delta\\)</span> (addition and multiplication of\r\ncountable values). Is there a family of enumerable <span class=\"math inline\">\\(\\mathbf{D}\\)</span> of sets, such that all linear\r\nanalytic sets belong to <span class=\"math inline\">\\(\\mathbf\r\n{B}(\\mathbf{D})\\)</span> ?</li>\r\n</ol>\r\n<p>Problem of M. S. Ulam.</p>\r\n<ol start=\"75\" type=\"1\">\r\n<li>Is there an infinite set <span class=\"math inline\">\\(E\\)</span>\r\n(e.g. the set of all natural numbers) and a function <span class=\"math inline\">\\(f(X)\\)</span> which maps to any subset <span class=\"math inline\">\\(X\\)</span> of $E $ a subset <span class=\"math inline\">\\(f(X)\\)</span> of <span class=\"math inline\">\\(E\\)</span>, so that:</li>\r\n</ol>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(X \\subset f(X)\\)</span> for <span class=\"math inline\">\\(X \\subset E\\)</span>,</li>\r\n<li><span class=\"math inline\">\\(f(X+Y) = f(X) + f(Y)\\)</span> for <span class=\"math inline\">\\(X \\subset E\\)</span>, <span class=\"math inline\">\\(Y \\subset E\\)</span>,</li>\r\n<li>there exists for every set <span class=\"math inline\">\\(Y \\subset\r\nE\\)</span> at least one set <span class=\"math inline\">\\(X \\subset\r\nE\\)</span>, such that <span class=\"math inline\">\\(Y =\r\nf(X)\\)</span>,</li>\r\n<li>there exists at least one set <span class=\"math inline\">\\(X_{0}\r\n\\subset E\\)</span>, such that <span class=\"math inline\">\\(f(X_{0}) \\neq\r\nX_{0}\\)</span>.</li>\r\n</ol>\r\n<p>If we replace the relative condition to <span class=\"math inline\">\\(f(X+Y)\\)</span> by the condition weaker than <span class=\"math inline\">\\(f(X) \\subset f(Y)\\)</span> pure <span class=\"math inline\">\\(X \\subset Y \\subset E\\)</span>, the positive\r\nanswer is obvious.</p>\r\n<p>Problem of M. E. <span class=\"math inline\">\\(\\check{\\text{C}}\\)</span>ech.</p>\r\n<h1 id=\"problems-resolved.\">Problems resolved.</h1>\r\n<ol type=\"1\">\r\n<li>When is a set of points <span class=\"math inline\">\\(P\\)</span> a\r\none-to-one and continuous image (in a sense) of <span class=\"math inline\">\\(Q\\)</span> and <span class=\"math inline\">\\(Q\\)</span> a one-to-one and continuous image of\r\n<span class=\"math inline\">\\(P\\)</span>, can we affirm that the sets\r\n<span class=\"math inline\">\\(P\\)</span> and <span class=\"math inline\">\\(Q\\)</span> are homeomorphic?</li>\r\n</ol>\r\n<p><em>Negative</em> solution from M. Kuratowski, Fund. Math. t. II, pp.\r\n158-160</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>Is there a decomposition of an interval into <span class=\"math inline\">\\(\\aleph_{1}\\)</span> measurable sets (<span class=\"math inline\">\\(B\\)</span>), each non-empty and without common\r\npoints?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from MM. Lusin and Sierpinski,\r\n<em>Comptes Rendus</em>, t. 175, p.357 (note of August 21, 1922).</p>\r\n<ol start=\"6\" type=\"1\">\r\n<li>Third part. Can it be shown that a product of <span class=\"math inline\">\\(\\aleph_{1}\\)</span> sets (<span class=\"math inline\">\\(A\\)</span>) is not necessarily a set (<span class=\"math inline\">\\(A\\)</span>)?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from MM. Lusin and Sierpinski,\r\n<em>Journ, de Math</em>. 1923 (The authors define a set which is\r\ncomplementary to a set (<span class=\"math inline\">\\(A\\)</span>) is not\r\nnecessarily a set (<span class=\"math inline\">\\(A\\)</span>).)</p>\r\n<ol start=\"8\" type=\"1\">\r\n<li>Can we give an effective example of a set of real numbers <span class=\"math inline\">\\(E\\)</span>, such as any sum, difference, product\r\nor quotient of two numbers of <span class=\"math inline\">\\(E\\)</span>\r\n(except division by 0) belongs to <span class=\"math inline\">\\(E_{1}\\)</span> and that <span class=\"math inline\">\\(E\\)</span> is uncountable, distinct from the set\r\nof all real numbers?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from M. Souslin, <em>Fund. Math.</em>\r\nIV, p.311.</p>\r\n<ol start=\"10\" type=\"1\">\r\n<li>First part. Is there a second class function which is not the limit\r\nof almost everywhere discontinuous functions?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from M. Zalcwasser.</p>\r\n<ol start=\"12\" type=\"1\">\r\n<li>Does an ordered set of which all well-ordered subsets (increasing or\r\ndecreasing) are at most enumerable necessarily have a power no greater\r\nthan that of the continuum?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from M. Urysohn, <em>Fund. Math.</em> V\r\n(to appear).</p>\r\n<ol start=\"15\" type=\"1\">\r\n<li>Is there a continuum of which any subcontinuum is\r\nindecomposable?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from M. Knaster, <em>Fund. Math.</em>\r\nIII pp. 247-286.</p>\r\n<ol start=\"16\" type=\"1\">\r\n<li>Does there exist a continuum which is a sum of its proper disjoint\r\nsaturated subcontinua?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution by MM. Knaster and Kuratowski,\r\n<em>Fund. Math.</em> V.</p>\r\n<section id=\"footnotes\" class=\"footnotes footnotes-end-of-document\" role=\"doc-endnotes\">\r\n<hr>\r\n<ol>\r\n<li id=\"fn1\"><p>Accounts of the Soc. of Varsovic Sciences , t. VII,\r\np.382.<a href=\"#fnref1\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn2\"><p>Sitzungaber d. Bayer. Akad. d. Wiss., math.-phys. K1,\r\n1922, p. 223.<a href=\"#fnref2\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn3\"><p>See p. e. N. Lusin and W. Sierpinski <em>Journ. of\r\nMath.</em> t. II (1923) p. 60; also <em>Bull. Acad. Krakow</em> 1918 p.\r\n40.<a href=\"#fnref3\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn4\"><p>Monatshefte f. Math. u. Phys. 28 (1917), p. 107.<a href=\"#fnref4\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn5\"><p>Fund . Math. 19 (1932), p.8.<a href=\"#fnref5\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n</ol>\r\n</section>\r\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"forewords\">Forewords</h1>\r\n<p>There are 75 open problems recorded in the Polish journal\r\n<em>Fundamenta Mathematicae</em> in volumes 1-34 from its inception,\r\nsome of which have already been solved. These problems represent the\r\ndevelopment of the foundations of mathematics since the late 19th\r\ncentury when M. G. Cantor established naive set theory. The original\r\ntext is in French and German, and the translated version is as\r\nfollows.</p>\r\n<h1 id=\"problems\">Problems</h1>\r\n<ol type=\"1\">\r\n<li>When is a set of points <span class=\"math inline\">\\(P\\)</span> a\r\none-to-one and continuous image (but not necessarily bi-continuous) of a\r\nset <span class=\"math inline\">\\(Q\\)</span> and when is <span class=\"math inline\">\\(Q\\)</span> a one-to-one and continuous image of\r\n<span class=\"math inline\">\\(P\\)</span>? Are the sets <span class=\"math inline\">\\(P\\)</span> and $Q $ necessarily homeomorphic?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>Is a (bounded) planar continuum, topologically homogeneous,\r\nnecessarily homeomorphic to a circumference?</li>\r\n</ol>\r\n<p>(A set <span class=\"math inline\">\\(E\\)</span> is said to be\r\n<em>topologically homogeneous</em>, when there exists for any pair of\r\npoints <span class=\"math inline\">\\(a, b\\)</span> of <span class=\"math inline\">\\(E\\)</span> a one-to-one and bi-continuous\r\ntransformation of <span class=\"math inline\">\\(E\\)</span> into itself\r\nwhich transforms <span class=\"math inline\">\\(a\\)</span> into <span class=\"math inline\">\\(b\\)</span>)</p>\r\n<p>Problem of MM. B. Knaster and C. Kuratowski.</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>Is a set ordered (linearly) without jumps or gaps and such that any\r\nset of its intervals (containing more than one element) does not overlap\r\nwith each other is at most innumerable, necessarily a (ordinary) linear\r\ncontinuum?</li>\r\n</ol>\r\n<p>Problem of M. M. Souslin.</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>Is there a decomposition of an interval into <span class=\"math inline\">\\(\\aleph_{1}\\)</span> (non-empty) sets without\r\ncommon points that are <span class=\"math inline\">\\(B\\)</span>\r\nmeasurable?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"5\" type=\"1\">\r\n<li>Does there exist an uncountable linear set <span class=\"math inline\">\\(E\\)</span> such that every linear set homeomorphic\r\nto <span class=\"math inline\">\\(E\\)</span> has zero Lebesgue measure? Can\r\nwe prove the existence of such a set assuming that <span class=\"math inline\">\\(2^{\\aleph_{0}} = \\aleph_{1}\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"6\" type=\"1\">\r\n<li>Can we find without the hypothesis of the continuum (<span class=\"math inline\">\\(2^{\\aleph_{0}} = \\aleph_{1}\\)</span>) that a sum\r\nof <span class=\"math inline\">\\(\\aleph_{1}\\)</span> sets of zero Lebesgue\r\nmeasure is not necessarily zero Lebesgue measure? that a sum of <span class=\"math inline\">\\(\\aleph_{1}\\)</span> sets of the first category is\r\nnot necessarily of the first category? that a product of <span class=\"math inline\">\\(\\aleph_{1}\\)</span> sets (<span class=\"math inline\">\\(A\\)</span>) is not necessarily a set (<span class=\"math inline\">\\(A\\)</span>)?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"7\" type=\"1\">\r\n<li>Can we establish without the hypothesis of the continuum the\r\nexistence of a planar set which has zero (Lebesgue) measure on any\r\ndirection parallel to the abscissa axis and whose complement has zero\r\nmeasure on any direction parallel to the ordinate axis?</li>\r\n</ol>\r\n<p>Problem of M. H. Steinhaus.</p>\r\n<ol start=\"8\" type=\"1\">\r\n<li>Can we give an effective example of a set of real numbers <span class=\"math inline\">\\(E\\)</span> such that any sum, difference, product\r\nor quotient of two numbers of <span class=\"math inline\">\\(E\\)</span>\r\n(except division by 0) belongs to <span class=\"math inline\">\\(E\\)</span>\r\nand that <span class=\"math inline\">\\(E\\)</span> is uncountable, but\r\ndistinct from the set of all real numbers?</li>\r\n</ol>\r\n<p>Problem of M. S. Mazurkiewicz.</p>\r\n<ol start=\"9\" type=\"1\">\r\n<li>What is the power of sets complementary to sets (<span class=\"math inline\">\\(A\\)</span>)?</li>\r\n</ol>\r\n<p>Problem of M. N. Lusin.</p>\r\n<p><em>Notice.</em> The linear sets (<span class=\"math inline\">\\(A\\)</span>) are orthogonal projections (on a line)\r\nof the measurable planar sets <span class=\"math inline\">\\(B\\)</span>. M.\r\nLusin demonstrated that the power of an uncountable set complementary to\r\na set (<span class=\"math inline\">\\(A\\)</span>) is <span class=\"math inline\">\\(\\aleph_{1}\\)</span> or <span class=\"math inline\">\\(2^{\\aleph_{0}}\\)</span>, but we do not know if it\r\ncan really be <span class=\"math inline\">\\(\\aleph_{1}\\)</span> (in the\r\ncase where <span class=\"math inline\">\\(2^{\\aleph_{0}} &gt;\r\n\\aleph_{1}\\)</span>).</p>\r\n<ol start=\"10\" type=\"1\">\r\n<li>Does there exist a second class function that is not a limit of\r\nalmost everywhere continuous functions? Can we give an effective example\r\nof a function which is not a limit of piecewise continuous\r\nfunctions?</li>\r\n</ol>\r\n<p>Problem of MM. T. Feosztyn and W. Sierpinski.</p>\r\n<ol start=\"11\" type=\"1\">\r\n<li>Does there exist a class (<span class=\"math inline\">\\(\\mathcal{L}\\)</span>) of M. Fr'echet (i.e. a class\r\nin which the limit is defined) of power greater than the continuum, such\r\nthat any uncountable set of elements of this class contains at least one\r\ncondensation element?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"12\" type=\"1\">\r\n<li>Does a (linearly) ordered set of which all well-ordered subsets\r\n(increasing and decreasing) are at most countable, necessarily have a\r\npower not greater than the continuum?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"13\" type=\"1\">\r\n<li>Does there exist a planar closed set which is not the sum of two\r\nclosed sets without common points, but a sum of countable closed sets\r\nwithout common points.</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"14\" type=\"1\">\r\n<li>Does a continuum in <span class=\"math inline\">\\(m\\)</span>-dimensional space which is homeomorphic\r\nto any continuum contain necessarily a simple arc (i.e. image of an\r\none-to-one and continuous mapping of the interval <span class=\"math inline\">\\((0,1)\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. Mazurkiewicz.</p>\r\n<ol start=\"15\" type=\"1\">\r\n<li>Does there exist a continuum of which every everything under\r\ncontinuous mapping is indecomposable? (A continuum is said to be\r\nindecomposable when it is not a sum of two continua different from\r\nit.)</li>\r\n</ol>\r\n<p>Problem of MM. Knaster and Kuratowski.</p>\r\n<ol start=\"16\" type=\"1\">\r\n<li>Does there exist a continuum (unbounded) which is a sum of its\r\nproper saturated sub-continuums where any two of them do not\r\nintersect?</li>\r\n</ol>\r\n<p>(We say that a real subcontinuum <span class=\"math inline\">\\(K\\)</span> of <span class=\"math inline\">\\(C\\)</span> is <em>saturated</em>, when there\r\nexists no continuum different from <span class=\"math inline\">\\(K\\)</span> and <span class=\"math inline\">\\(C\\)</span> which contains <span class=\"math inline\">\\(K\\)</span> and which is contained in <span class=\"math inline\">\\(C\\)</span>.)</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"17\" type=\"1\">\r\n<li>What is the power of the set of all values that a Baire class 1\r\nfunction does not take?</li>\r\n</ol>\r\n<p>(This problem is equivalent to problem 9 of M. Lusin, t. I. p.224. It\r\nwould be enough to solve this problem for functions admitting\r\nuncountable points of discontinuity.)</p>\r\n<ol start=\"18\" type=\"1\">\r\n<li>Is a (linear) set of power less than the continuum necessarily of\r\nthe first category of M. Baire?</li>\r\n</ol>\r\n<p>Problem of M. Ruziewicz.</p>\r\n<ol start=\"19\" type=\"1\">\r\n<li>Does there exist in each biconnected set <span class=\"math inline\">\\(B\\)</span> a point <span class=\"math inline\">\\(p\\)</span> such that the set <span class=\"math inline\">\\(B - (p)\\)</span> contains no connected set?</li>\r\n</ol>\r\n<p><em>Notice.</em> According to a theorem of M. Kline (this volume,\r\np.238), there cannot exist in a connected set <span class=\"math inline\">\\(B\\)</span> more than one point <span class=\"math inline\">\\(p\\)</span> enjoying the property in question. We\r\nknow, on the other hand, that, if such a point exists, the set <span class=\"math inline\">\\(B\\)</span> is biconnected, i.e. it is not the sum\r\nof two disjoint connected sets containing more than one point (cf.\r\nKnaster and Kuratowski, <em>Fund. Math.</em> II, p, 214.)</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"20\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(f(E)\\)</span> be a function defined\r\nby any measurable (<span class=\"math inline\">\\(L\\)</span>) set <span class=\"math inline\">\\(E\\)</span> of a Euclidean space of <span class=\"math inline\">\\(m \\geq 3\\)</span> dimensions and satisfying the\r\nfollowing conditions:</li>\r\n</ol>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(f(E) \\geq 0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(f(E_{0}) = 1\\)</span> for a certain set\r\n<span class=\"math inline\">\\(E_{0}\\)</span> of measure 1.</li>\r\n<li><span class=\"math inline\">\\(f(E_{1} +E_{2}) = f(E_{1}) +\r\nf(E_{2})\\)</span>, if <span class=\"math inline\">\\(E_{1} E_{2} =\r\n0\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(f(E_{1}) = f(E_{2})\\)</span>, if <span class=\"math inline\">\\(E_{1}\\)</span> and <span class=\"math inline\">\\(E_{2}\\)</span> are superposable.</li>\r\n</ol>\r\n<p>Does the function <span class=\"math inline\">\\(f(E)\\)</span>\r\nnecessarily coincide with the Lebesgue measure of the set <span class=\"math inline\">\\(E\\)</span>?</p>\r\n<p>(For <span class=\"math inline\">\\(m=1\\)</span> and <span class=\"math inline\">\\(m=2\\)</span> the answer is negative, as M. Banach\r\nproved in a memoir which will be published in the volume IV of this\r\njournal.)</p>\r\n<p>Problem of M. Ruziewicz.</p>\r\n<ol start=\"21\" type=\"1\">\r\n<li>Given a set of real numbers which is not of the first category in\r\nany interval, is there a decomposition: <span class=\"math inline\">\\(A =\r\nB + C\\)</span>, <span class=\"math inline\">\\(B \\times C = 0\\)</span> such\r\nthat neither <span class=\"math inline\">\\(B\\)</span> nor <span class=\"math inline\">\\(C\\)</span> are of the first category in any\r\ninterval?</li>\r\n</ol>\r\n<p><em>Notice.</em> We could give the affirmative answer in the\r\nhypothesis additional that <span class=\"math inline\">\\(A\\)</span> has\r\nthe Baire property (in the sense established in this volume), p.319 . M.\r\nSierpinski also pointed out the affirmative answer in the hypothesis of\r\nthe continuum, <span class=\"math inline\">\\(\\aleph_{1} =\r\n2^{\\aleph_{0}}\\)</span>.</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"22\" type=\"1\">\r\n<li>Let us call the (linear) set <span class=\"math inline\">\\(E\\)</span>\r\n<em>perfectly measurable</em>, if every set homeomorphic to <span class=\"math inline\">\\(E\\)</span> is measurable in the sense of Lebesgue.\r\nWhat is the power of the class of perfectly measurable sets? Is a\r\ncomplementary set to a perf. measurable set always perf.\r\nmeasurable?</li>\r\n</ol>\r\n<p>Problem of M. Urysohn.</p>\r\n<ol start=\"23\" type=\"1\">\r\n<li>Does there exist a function of a real variable $ f(x)$ pantachically\r\ndicontinuous and such that we have for all real <span class=\"math inline\">\\(x\\)</span></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\lim_{h \\to 0} \\frac{f( x+h ) -\r\nf(x-h)}{2h} = 0?\\]</span></p>\r\n<p>Problem of M. Steinhaus.</p>\r\n<ol start=\"24\" type=\"1\">\r\n<li>Is a function satisfying Baire's condition necessarily measurable\r\n(<span class=\"math inline\">\\(L\\)</span>)? What is the power of all the\r\nfunctions of a real variable satisfying the Baire condition? (We say\r\nthat a function <span class=\"math inline\">\\(f(x)\\)</span> satisfies the\r\nBaire condition, if it is continuous on any perfect set when we neglect\r\nthe sets of the first category has with respect to that perfect\r\nset.)</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"25\" type=\"1\">\r\n<li>Can a planar set, such that any straight line meets it at two (and\r\nonly two) points, be measurable (<span class=\"math inline\">\\(B\\)</span>)? (The existence of such a set has been\r\ndemonstrated, using M. Zermelo's theorem, by MM. Mazurkiewicz<a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a> (in 1914) and Rosenthal<a href=\"#fn2\" class=\"footnote-ref\" id=\"fnref2\" role=\"doc-noteref\"><sup>2</sup></a> (in 1922))</li>\r\n</ol>\r\n<ol start=\"26\" type=\"1\">\r\n<li>Is a class 3 function of M. Baire always a superposition of three\r\nclass 1 functions, that is to say, does it exist for any function <span class=\"math inline\">\\(f(x)\\)</span> of class 3 three class 1 functions\r\n<span class=\"math inline\">\\(\\varphi(x)\\)</span>, <span class=\"math inline\">\\(\\psi(x)\\)</span> and <span class=\"math inline\">\\(\\vartheta(x)\\)</span>, such that we have for all\r\nreal <span class=\"math inline\">\\(x\\)</span></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[f(x) = \\varphi \\{\\psi[\\vartheta\r\n(x)]\\}\\]</span></p>\r\n<p>Problem of M. Lusin.</p>\r\n<ol start=\"27\" type=\"1\">\r\n<li>Is the set <span class=\"math inline\">\\(D(E)\\)</span> of the\r\ndistances of the points of a linear set <span class=\"math inline\">\\(E\\)</span> that is (<span class=\"math inline\">\\(B\\)</span>) measurable always (<span class=\"math inline\">\\(B\\)</span>) measurable? (<span class=\"math inline\">\\(D(E)\\)</span> is therefore the set of all numbers\r\n<span class=\"math inline\">\\(|x - y|\\)</span>, where <span class=\"math inline\">\\(x\\)</span> and <span class=\"math inline\">\\(y\\)</span> belong to <span class=\"math inline\">\\(E\\)</span>. We can prove the existence of set\r\n<span class=\"math inline\">\\(E\\)</span> that are measurable (<span class=\"math inline\">\\(L\\)</span>), such that <span class=\"math inline\">\\(D(E)\\)</span> is non-measurable (<span class=\"math inline\">\\(L\\)</span>).)</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"28\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(E\\)</span> is a (<span class=\"math inline\">\\(B\\)</span> measurable) planar set, let us denote\r\nby <span class=\"math inline\">\\(N(E)\\)</span> the set of all real numbers\r\n<span class=\"math inline\">\\(a\\)</span>, such that the line <span class=\"math inline\">\\(x = a\\)</span> meets <span class=\"math inline\">\\(E\\)</span> at a uncountable infinite number of\r\npoints. Is the set <span class=\"math inline\">\\(N(E)\\)</span> necessarily\r\na set (<span class=\"math inline\">\\(A\\)</span>), or, more simply, is it\r\nmeasurable (<span class=\"math inline\">\\(L\\)</span>)? (It can be shown\r\nthat the set of all real numbers <span class=\"math inline\">\\(a\\)</span>,\r\nsuch that the line <span class=\"math inline\">\\(x = a\\)</span> meets the\r\n(<span class=\"math inline\">\\(B\\)</span> measurable) set <span class=\"math inline\">\\(E\\)</span> in an infinity number of points is\r\nalways a set (<span class=\"math inline\">\\(A\\)</span>).)</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"29\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(F\\)</span> be a planar set, p. ex.\r\nclosed (or, more generally, measurable) - A point <span class=\"math inline\">\\(x\\)</span> of <span class=\"math inline\">\\(F\\)</span> will be said to be <em>linearly\r\naccessible</em> if there exists a rectilinear segment <span class=\"math inline\">\\(\\overline{xp}\\)</span> such that all its points\r\n(except the point <span class=\"math inline\">\\(x\\)</span>) are outside\r\n<span class=\"math inline\">\\(F\\)</span>. Can it be shown that the set\r\n<span class=\"math inline\">\\(A\\)</span> of all linearly accessible points\r\nof <span class=\"math inline\">\\(F\\)</span> is always measurable (<span class=\"math inline\">\\(L\\)</span>)?</li>\r\n</ol>\r\n<p>Problem of M. Urysohn.</p>\r\n<ol start=\"30\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(f(x)\\)</span> is an arbitrarily given\r\nfunction (measurable or not), what is the measure of the sum of all\r\npoints <span class=\"math inline\">\\(x\\)</span>, such that</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\lim \\limits_{h\\to 0} \\left |\\frac{f(\r\nx+h ) - f(x)}{h}\\right| = \\infty \\]</span></p>\r\n<p>Problem of M. Ruziewicz.</p>\r\n<ol start=\"31\" type=\"1\">\r\n<li>Is the statement \"<span class=\"math inline\">\\(\\mathsf{m} =\r\n2\\cdot\\mathsf{m}\\)</span> for any <em>transfinite</em> cardinal number\r\n<span class=\"math inline\">\\(\\mathsf {m}\\)</span>\" equivalent to <em>the\r\naxiom of choice</em>?</li>\r\n</ol>\r\n<p>Cf. my Note \"<em>On some theorems which are equivalent to the axiom\r\nof choice</em>\" in this volume, p. 147.</p>\r\n<p>Problem of M. Tajtelbaum-Tarski .</p>\r\n<ol start=\"32\" type=\"1\">\r\n<li>Is a planar closed set, where every point is linearly accessible,\r\nnecessarily of zero surface measure?</li>\r\n</ol>\r\n<p>Problem of M. Banach.</p>\r\n<p>A point <span class=\"math inline\">\\(x\\)</span> of <span class=\"math inline\">\\(F\\)</span> is said to be linearly accessible if\r\nthere exists a rectilinear segment <span class=\"math inline\">\\(\\overline{xp}\\)</span> such that all its points\r\n(except the point <span class=\"math inline\">\\(x\\)</span>) are outside\r\n<span class=\"math inline\">\\(F\\)</span>. M. Urysohn proved that the set\r\nof all linearly accessible points of a planar closed set is always a set\r\n(<span class=\"math inline\">\\(A\\)</span>) of M. Souslin, but may not be\r\nmeasurable (<span class=\"math inline\">\\(B\\)</span>). But we do not know\r\nif the set of all linearly accessible points of a planar <span class=\"math inline\">\\(G_{\\delta}\\)</span> set is measurable (<span class=\"math inline\">\\(L\\)</span>) (Cf. Problem 29, <em>Fund. Math.</em>\r\nt. V, p. 337).</p>\r\n<ol start=\"33\" type=\"1\">\r\n<li>Is the image of a one-to-one and continuous map (in one sense) of a\r\nset complementary to a set (<span class=\"math inline\">\\(A\\)</span>) of\r\nM. Souslin necessarily a homeomorphism?</li>\r\n</ol>\r\n<p>Problem of Sierpinski.</p>\r\n<ol start=\"34\" type=\"1\">\r\n<li>Let us call a (linear) set (<span class=\"math inline\">\\(B\\)</span>)\r\nmeasurable of class <span class=\"math inline\">\\(\\alpha\\)</span>\r\n<em>irreducible</em> if it is not of class <span class=\"math inline\">\\(&lt;\\alpha\\)</span> in any interval. What is the\r\npower of the set of all topological types of irreducible sets of class\r\n<span class=\"math inline\">\\(\\alpha\\)</span>?</li>\r\n</ol>\r\n<p>Let us call a set (<span class=\"math inline\">\\(A\\)</span>)\r\n<em>irreducible</em>, if it is not (<span class=\"math inline\">\\(B\\)</span>) measurable in any interval. What is\r\nthe power of all the topological types of the sets (<span class=\"math inline\">\\(A\\)</span>) irreducible?</p>\r\n<p>Problem of MM. Alexandroff and Urysohn.</p>\r\n<ol start=\"35\" type=\"1\">\r\n<li>Let us call the (linear) set <span class=\"math inline\">\\(E\\)</span>\r\n<em>perfectly measurable in the narrow sense</em>, if every unambiguous\r\nand continuous image of <span class=\"math inline\">\\(E\\)</span> is\r\nmeasurable in the sense of Lebesgue. Is a set complementary to a set\r\nperfectly measurable in the narrow sense always a homeomorphic\r\nimage?</li>\r\n</ol>\r\n<p>Cf. Problem 22 of P. Urysohn (<em>Fund. Math.</em> t. IV, p. 368),\r\nsolved by M. Lavrentieff (<em>Fund. Math.</em> t. VI, p. 159).</p>\r\n<p>Probleme de M. O. Nikodym.</p>\r\n<ol start=\"36\" type=\"1\">\r\n<li>According to M. Souslin, if <span class=\"math inline\">\\(E\\)</span>\r\nis a set (<span class=\"math inline\">\\(A\\)</span>) and <span class=\"math inline\">\\(H\\)</span> a complementary set to a set (<span class=\"math inline\">\\(A\\)</span>), and if <span class=\"math inline\">\\(E\r\n\\subset H\\)</span>, there exists a set <span class=\"math inline\">\\(Q\\)</span>, (<span class=\"math inline\">\\(B\\)</span>) measurable, such that <span class=\"math inline\">\\(E\\subset Q \\subset H\\)</span><a href=\"#fn3\" class=\"footnote-ref\" id=\"fnref3\" role=\"doc-noteref\"><sup>3</sup></a>.\r\nDoes this proposition admit a reciprocal, that is to say, <em>if <span class=\"math inline\">\\(E\\)</span> is a complementary set to a set (<span class=\"math inline\">\\(A\\)</span>) and <span class=\"math inline\">\\(H\\)</span> ------ does a set (<span class=\"math inline\">\\(A\\)</span>), such that <span class=\"math inline\">\\(E \\subset H\\)</span>, exist always a (<span class=\"math inline\">\\(B\\)</span>) measurable set <span class=\"math inline\">\\(Q\\)</span>, such that <span class=\"math inline\">\\(E \\subset Q \\subset H\\)</span>?</em></li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"37\" type=\"1\">\r\n<li>Is a Jordan (bounded) continuum which contains only a simple closed\r\ncurve homeomorphic to one of its (real) sub-continuums?</li>\r\n</ol>\r\n<p>Problem of M. Zarankiewicz.</p>\r\n<ol start=\"38\" type=\"1\">\r\n<li>Can a square and a circle whose areas are equal be decomposed into a\r\nfinite number of respectively congruent disjoint subsets?</li>\r\n</ol>\r\n<p>Problem of M. Tarski.</p>\r\n<ol start=\"39\" type=\"1\">\r\n<li>Does there exist a planar closed set for which the set of linearly\r\naccessible points is non-measurable (<span class=\"math inline\">\\(B\\)</span>)? (In the space the problem is resolved\r\nin the affirmative sense).</li>\r\n</ol>\r\n<p>Problem of M. O. Nikodym.</p>\r\n<ol start=\"40\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(E\\)</span> is a planar <span class=\"math inline\">\\(G_{\\delta}\\)</span> set, is the set of all real\r\nnumbers <span class=\"math inline\">\\(a\\)</span>, such that the line <span class=\"math inline\">\\(x=a\\)</span> meets the set <span class=\"math inline\">\\(E\\)</span> in one and only one point, not\r\nnecessarily complementary to a set (<span class=\"math inline\">\\(A\\)</span>) of M. Souslin?</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"41\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(E_{1}, E_{2}, E_{3}, \\dots\\)</span>\r\nare a sequence of countable linear sets each of which is a projection of\r\na planar set complementary to a set (<span class=\"math inline\">\\(A\\)</span>) of M. Souslin, is the set $E_{1}E_{2}\r\nE_{3} $ of the same nature?</li>\r\n</ol>\r\n<p>Problem of M. Sierpinski.</p>\r\n<ol start=\"42\" type=\"1\">\r\n<li>Does there exist in every continuum <span class=\"math inline\">\\(A\\)</span> a continuum <span class=\"math inline\">\\(B\\)</span> such that the set <span class=\"math inline\">\\(A - B\\)</span> is connected?</li>\r\n</ol>\r\n<p>Problem of MM. Knaster and Zarankiewicz.</p>\r\n<ol start=\"43\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(D\\)</span> denote a closed set\r\nhomeomorphic to a planar set located in 3-dimensional Euclidean space,\r\nis every point of <span class=\"math inline\">\\(D\\)</span> is\r\n<em>accessible</em> in this space?</li>\r\n</ol>\r\n<p>(A point <span class=\"math inline\">\\(d\\)</span> of <span class=\"math inline\">\\(D\\)</span> is said to be <em>accessible</em> in\r\n<span class=\"math inline\">\\(E\\)</span>, when there exists a continuum\r\n<span class=\"math inline\">\\(C \\subset E\\)</span> such that <span class=\"math inline\">\\((d) = CD\\)</span>).</p>\r\n<p>Problem of M. Knaster.</p>\r\n<p>Unfortunately, Problem 44 and 45 by MM. N. Lusin and H. Steinhaus\r\nwhich should have appeared in XI, p.308, were missing.</p>\r\n<ol start=\"46\" type=\"1\">\r\n<li>It is asked to set up the logical relations between the various\r\nconcepts of homogeneity, in so far as they refer to locally compact\r\nsets. In particular, even if the sets are considered to be connected and\r\n(or) locally connected.</li>\r\n</ol>\r\n<p>(See D. van Dantzig , \"On topologically homogeneous continua, volume\r\n15, pp. 102, 103).</p>\r\n<p>Problem of M. van Dantzig.</p>\r\n<ol start=\"47\" type=\"1\">\r\n<li>Is every (connected, unbounded) <span class=\"math inline\">\\(n\\)</span>-dimensional manifold involutory\r\nhomogeneous?</li>\r\n</ol>\r\n<p>(Cf. D. van Dantzig, le p. 104, ^7.)</p>\r\n<p>Problem of M. van Dantzig.</p>\r\n<ol start=\"48\" type=\"1\">\r\n<li>Let us call a topological group <em>monothetic</em> if an infinite\r\ncyclic group is dense in it (in which case it is commutative and can be\r\nwritten additively), and <em>complete</em> if every sequence $x_{} $,\r\nwhich satisfies the Cauchy's convergence criterion <span class=\"math inline\">\\(\\lim (x_{\\nu} - x_{\\mu }) = 0\\)</span> has a limit\r\nelement in the group, the question is whether a monothetic group can be\r\ncomplete without being compact.</li>\r\n</ol>\r\n<p>(See lc p. 116 {}^{29}a))</p>\r\n<p>Problem of M. van Dantzig.</p>\r\n<ol start=\"49\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(X\\)</span> and <span class=\"math inline\">\\(Y\\)</span> be two Peano continua (= continuous\r\nimages of the interval) and <span class=\"math inline\">\\(Z\\)</span> be\r\ntheir topological product (= the space of all pairs $z = (x,y) $ or\r\n<span class=\"math inline\">\\(\\lim z_{n}=z\\)</span> when <span class=\"math inline\">\\(\\lim x_{n} = x\\)</span> and <span class=\"math inline\">\\(\\lim y_{n} = y\\)</span>).</li>\r\n</ol>\r\n<p>1^0. If the continuum <span class=\"math inline\">\\(X\\)</span>, as well\r\nas <span class=\"math inline\">\\(Y\\)</span>, has the property that in each\r\ncontinuous transformation of this continuum into a subset there exists\r\nan invariant point, is it true that <span class=\"math inline\">\\(Z\\)</span> has the same property?</p>\r\n<p>2^0. If the continuum <span class=\"math inline\">\\(X\\)</span>, as well\r\nas <span class=\"math inline\">\\(Y\\)</span>, is uni-consistent (= in each\r\ndecomposition of this continuum into two sub-continuums the common part\r\nof these sub-continuums is connected), is it true that <span class=\"math inline\">\\(Z\\)</span> is uni-coherent?</p>\r\n<p>Problem of M. Kuratowski.</p>\r\n<ol start=\"50\" type=\"1\">\r\n<li>Is the topological circle the only homogeneous locally connected\r\ncurve? (Curve = one-dimensional connected compact space. A space is\r\ncalled homogeneous, if for each of its two points <span class=\"math inline\">\\(p\\)</span> and <span class=\"math inline\">\\(q\\)</span> there exist a homeomorphism which sends\r\n<span class=\"math inline\">\\(p\\)</span> to <span class=\"math inline\">\\(q\\)</span> ). On the plane, the circle is the only\r\nhomogeneous locally connected curve.</li>\r\n</ol>\r\n<p>(Cf. Mazurkiewicz, Fund. Math. V, p. 137).</p>\r\n<p>Problem with M. K. Menger.</p>\r\n<ol start=\"51\" type=\"1\">\r\n<li>Are there any or even an infinite number of compact one-dimensional\r\nspaces, any two of which are incomparable in dimension one? Two spaces\r\n<span class=\"math inline\">\\(R\\)</span> and <span class=\"math inline\">\\(R^{\\prime}\\)</span> may be called\r\none-dimensionally incomparable, if no one-dimensional subset of <span class=\"math inline\">\\(R\\)</span>, (or of <span class=\"math inline\">\\(R^{\\prime}\\)</span>) is homeomorphic with a subset\r\nof <span class=\"math inline\">\\(R^{\\prime}\\)</span> (or of <span class=\"math inline\">\\(R^{\\prime}\\)</span>). For example, a line and a\r\ncontinuum without partial arcs are incomparable in one dimension. (If\r\nthere are <span class=\"math inline\">\\(n\\)</span>, or <span class=\"math inline\">\\(\\aleph_{0}\\)</span> in pairs of one-dimensionally\r\nincomparable curves, then there exist compact one-dimensional spaces\r\nwhich contains at least <span class=\"math inline\">\\(2^{n} +1\\)</span>,\r\nor <span class=\"math inline\">\\(2^{\\aleph_{0}}\\)</span> monotone, <span class=\"math inline\">\\(F_{\\sigma}\\)</span>-additive, topological,\r\ncompactifiable systems of subsets).</li>\r\n</ol>\r\n<p>(See Monthly Issues f. Math. and Phys. 36, p. 207).</p>\r\n<p>Problem of M. K. Menger.</p>\r\n<ol start=\"52\" type=\"1\">\r\n<li>Does there exist a continuum of which every other continuum is a\r\ncontinuous image?</li>\r\n</ol>\r\n<p>Problem of M. H. Hahn.</p>\r\n<ol start=\"53\" type=\"1\">\r\n<li><ol type=\"a\">\r\n<li>Can any absolute retract be decomposed into a finite number of\r\nabsolute retracts with arbitrarily small diameters?</li>\r\n</ol></li>\r\n</ol>\r\n<ol start=\"2\" type=\"a\">\r\n<li>Can any <span class=\"math inline\">\\(R\\)</span> set be decomposed\r\ninto a finite number of absolute retracts?</li>\r\n</ol>\r\n<p>(The definition of absolute retracts and <span class=\"math inline\">\\(R\\)</span> sets is given, for example, in Fund.\r\nMath. XIX, p. 222).</p>\r\n<ol start=\"54\" type=\"1\">\r\n<li><p>Is every partial continuum <span class=\"math inline\">\\(C\\)</span>\r\nof the Euclidean <span class=\"math inline\">\\(n\\)</span>-dimensional\r\nspace <span class=\"math inline\">\\(R_{n}\\)</span>, which intersects <span class=\"math inline\">\\(R_{n}\\)</span> and which is transferred by\r\narbitrarily small transformations (i.e. by a continuous mapping which\r\nsends every point from <span class=\"math inline\">\\(C\\)</span> to an\r\narbitrarily close point of <span class=\"math inline\">\\(R_{n}\\)</span>)\r\ninto a subset of <span class=\"math inline\">\\(R_{n}\\)</span> that is\r\nforeign to it, a (<span class=\"math inline\">\\(n-1\\)</span>) dimensional\r\nspace?</p></li>\r\n<li><p>Can every route image lying in <span class=\"math inline\">\\(R_{3}\\)</span> and intersecting <span class=\"math inline\">\\(R_{3}\\)</span> be mapped continuously without\r\nfixed points?</p></li>\r\n</ol>\r\n<p>Problem of M. K. Borsuk.</p>\r\n<ol start=\"56\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(A\\)</span> and <span class=\"math inline\">\\(B\\)</span> be two topological spaces and <span class=\"math inline\">\\(A^{2}\\)</span> and <span class=\"math inline\">\\(B^{2}\\)</span> respectively their squares (a. `ad\r\n<span class=\"math inline\">\\(A^{2}\\)</span> p. ex. consists of all your\r\npairs (<span class=\"math inline\">\\(a_{1}\\)</span>, <span class=\"math inline\">\\(a_{2}\\)</span>) extracted from <span class=\"math inline\">\\(A\\)</span>).</li>\r\n</ol>\r\n<p>Is it true that if <span class=\"math inline\">\\(A^{2}\\)</span> and\r\n<span class=\"math inline\">\\(B^{2}\\)</span> are homeomorphic, are <span class=\"math inline\">\\(A\\)</span> and <span class=\"math inline\">\\(B\\)</span> too?</p>\r\n<p>In case of a positive answer, we deduce that, if <span class=\"math inline\">\\(C\\)</span> is a set which is not homeomorphic to\r\nnone of <span class=\"math inline\">\\(C^{n}\\)</span>, <span class=\"math inline\">\\(n&gt;1\\)</span>, the sets <span class=\"math inline\">\\(C^{m}\\)</span> and <span class=\"math inline\">\\(C^{n}\\)</span> are neither homeomorphic for <span class=\"math inline\">\\(m \\neq n\\)</span>; this provides in the case where\r\n<span class=\"math inline\">\\(C\\)</span> is an interval of the theorem of\r\n\"invariance of the dimension\" of M. Brouwer.</p>\r\n<p>Problem of M. S. Ulam.</p>\r\n<ol start=\"57\" type=\"1\">\r\n<li>Does there exist an infinite-dimensional continuum that does not\r\ncontain any finite-dimensional continuum?</li>\r\n</ol>\r\n<p>Problems of M. S. Mazurkiewicz.</p>\r\n<ol start=\"58\" type=\"1\">\r\n<li>Does there exist in a set <span class=\"math inline\">\\(E\\)</span> of\r\nsize <span class=\"math inline\">\\(\\aleph_{1}\\)</span> a countable system\r\nof subsets <span class=\"math inline\">\\(A_{1}, A_{2},\\dots\\)</span> such\r\nthat one has the form <span class=\"math display\">\\[X = \\overline{\\lim}\r\nA_{p_{n}}\\]</span> where (<span class=\"math inline\">\\(p_{1},\r\np_{2},\\dots\\)</span> is a subsequence of the natural numbers, <span class=\"math inline\">\\(\\overline{\\lim}\\)</span> means the Borel\r\n<em>complete limit set</em>) all subsets <span class=\"math inline\">\\(X,\r\nA_{1}, A_{2},\\dots\\)</span> are received from <span class=\"math inline\">\\(E\\)</span>?</li>\r\n</ol>\r\n<p>(It is a question of proving the negation without using the continuum\r\nhypothesis).</p>\r\n<p>Problems with M. F. Hausdorff.</p>\r\n<ol start=\"59\" type=\"1\">\r\n<li>A function with the Baire property (i.e. continuous on any perfect\r\nset, when we neglect a set of <span class=\"math inline\">\\(1^{st}\\)</span> category relative to this set) of\r\na function with the Baire property, is it of the same nature?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"60\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(\\rho\\)</span> be the set of all\r\nhomeomorphic transformations of the Cartesian plane in itself, of the\r\nform: <span class=\"math display\">\\[x^{\\prime} = x, \\quad y^{\\prime} =f(\r\nx,y )\\]</span> and <span class=\"math display\">\\[x^{\\prime}=g( x,y ),\r\n\\quad    y^{\\prime}=y.\\]</span></li>\r\n</ol>\r\n<p>Let us denote by <span class=\"math inline\">\\(\\sigma\\)</span> the\r\ngroup formed by all the finite superpositions of all the transformations\r\nbelonging to <span class=\"math inline\">\\(\\rho\\)</span>. Can an arbitrary\r\nhomeomorphic transformation of the plane in itself always be approached\r\nby those of the group <span class=\"math inline\">\\(\\sigma\\)</span>?</p>\r\n<p>An analogous problem remains for <span class=\"math inline\">\\(n&gt;2\\)</span> dimensional spaces.</p>\r\n<p>Problem of M.S. Ulam.</p>\r\n<ol start=\"61\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(E\\)</span> be a <span class=\"math inline\">\\(G_{\\delta}\\)</span> set in the plane (more\r\ngenerally: a Borel set) all of whose intersections with the lines\r\nparallel to the <span class=\"math inline\">\\(y\\)</span> axis are closed\r\nsets (more generally: <span class=\"math inline\">\\(F_{\\sigma}\\)</span>).\r\nIs the projection of <span class=\"math inline\">\\(E\\)</span> on the <span class=\"math inline\">\\(x\\)</span> axis always a Borel set?</li>\r\n</ol>\r\n<p>Problem of M. E. Szpilrajsn.</p>\r\n<ol start=\"62\" type=\"1\">\r\n<li>The (real) function <span class=\"math inline\">\\(f(x)\\)</span> of the\r\nreal variable <span class=\"math inline\">\\(x\\)</span> is called\r\n<em>symmetric-continuous</em> if for every <span class=\"math inline\">\\(x\\)</span> <span class=\"math display\">\\[\\lim\r\n\\limits_{h \\to 0} [f( x+h ) - f(x - h)] = 0.\\]</span> Can the set of\r\ndiscontinuities of such a function be uncountable? Can it be an\r\narbitrarily prescribed set <span class=\"math inline\">\\(F_{\\sigma}\\)</span>? (That they are an arbitrarily\r\nprescribed countable set is easy to see.)</li>\r\n</ol>\r\n<p>Problem of M. F. Hausdorff.</p>\r\n<ol start=\"63\" type=\"1\">\r\n<li>Two compact spaces <span class=\"math inline\">\\(A\\)</span> and <span class=\"math inline\">\\(B\\)</span> have the <em>same homotopy type</em>,\r\nwhen there exists a continuous transformation <span class=\"math inline\">\\(f\\)</span> from <span class=\"math inline\">\\(A\\)</span> to <span class=\"math inline\">\\(B\\)</span> and a continuous transformation <span class=\"math inline\">\\(\\varphi\\)</span> from <span class=\"math inline\">\\(B\\)</span> to <span class=\"math inline\">\\(A\\)</span>, such as the superpositions <span class=\"math inline\">\\(\\varphi f\\)</span> and <span class=\"math inline\">\\(f\\varphi\\)</span> (consider respectively as\r\ntransformations of <span class=\"math inline\">\\(A\\)</span> into <span class=\"math inline\">\\(A\\)</span> and of <span class=\"math inline\">\\(B\\)</span> into <span class=\"math inline\">\\(B\\)</span>) are homotopic to the identity. Are two\r\nclosed varieties of the same homotopy type always homomorphic?</li>\r\n</ol>\r\n<p>Problem of M. W. Hurewicz.</p>\r\n<ol start=\"64\" type=\"1\">\r\n<li><p>Do there exist two in <span class=\"math inline\">\\(R^{n}\\)</span>\r\norientable Manifolds <span class=\"math inline\">\\(M_{1}^{k}\\)</span> and\r\n<span class=\"math inline\">\\(M_{2}^{k}\\)</span>, whose Complementary\r\n<span class=\"math inline\">\\(R^{n} - M_{1}^{k}\\)</span> and <span class=\"math inline\">\\(R^{n} - M_{2}^{k}\\)</span> are homomorphic and\r\nwhose Homology rings are not isomorphic?</p></li>\r\n<li><p>Let <span class=\"math inline\">\\(B_{0}, B_{1}, B_{2}, \\dots,\r\nB_{\\omega}, \\dots, B_{\\alpha}, \\dots\\)</span> be Borel classes of sets,\r\nformed in starting from any class of abstract sets. We know that <span class=\"math inline\">\\(B_{\\alpha} = B_{\\alpha+}\\)</span>. results in\r\n<span class=\"math inline\">\\(B_{\\alpha}= B_{\\beta}\\)</span> for all <span class=\"math inline\">\\(\\beta&gt;\\alpha\\)</span>; let <span class=\"math inline\">\\(\\alpha_{0}\\)</span> be the first number <span class=\"math inline\">\\(\\alpha\\)</span> satisfying this condition. What\r\nare the numbers <span class=\"math inline\">\\(\\nu\\)</span> for which there\r\nexist classes <span class=\"math inline\">\\(B_{0}\\)</span> such that we\r\nhave <span class=\"math inline\">\\(\\alpha_{0} = \\nu\\)</span>? (Cf. Fund.\r\nMath. t. XV, p. 284).</p></li>\r\n</ol>\r\n<p>Problem of M. A. Kolmogoroff.</p>\r\n<ol start=\"66\" type=\"1\">\r\n<li>Does the <em>weak</em> <span class=\"math inline\">\\(LC\\)</span>\r\nproperty entail the strong <span class=\"math inline\">\\(LC\\)</span>\r\nproperty for any compact metric space? Same question for <span class=\"math inline\">\\(HLC\\)</span> properties . (For definitions see\r\nAnnals of Mathematics , vol. 85, p. 119-129 and Duke Mathematical\r\nJournal, vol . 1, p. 1-18).</li>\r\n</ol>\r\n<p>Problem of M. S. Lefschetz.</p>\r\n<ol start=\"67\" type=\"1\">\r\n<li>Is the property (<span class=\"math inline\">\\(C\\)</span>) of linear\r\nsets invariant with respect to homeomorphic transformations and, more\r\ngenerally, with respect to continuous transformations? (We say that a\r\nset <span class=\"math inline\">\\(E\\)</span> has the <em>property (<span class=\"math inline\">\\(C\\)</span>)</em>, when there exists for each\r\nsequence <span class=\"math inline\">\\(\\{a_{n}\\}\\)</span> of positive\r\nnumbers a decomposition $E=E_{1}+E_{2} + $ such that the diameter of\r\n<span class=\"math inline\">\\(E_{n}\\)</span> does not exceed $ a_{n}$ for\r\n<span class=\"math inline\">\\(n= 1, 2,\\dots\\)</span>. Cf. Fund. Math,\r\nvolume XI, p. 304; volume XV, p. 126; volume XXII, p. 310.)</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"68\" type=\"1\">\r\n<li>If <span class=\"math inline\">\\(E_{1}\\)</span> and $ E_{2}$ are two\r\nlinear sets always of first category (i.e. of first category on any\r\nperfect set), the set <span class=\"math inline\">\\(E_{1} \\times\r\nE_{2}\\)</span>. (i.e. the set of all points <span class=\"math inline\">\\((x, y)\\)</span> of the plane where <span class=\"math inline\">\\(x \\in E_{1}\\)</span> and <span class=\"math inline\">\\(y \\in E_{2}\\)</span>) Is it of the same\r\nnature?</li>\r\n</ol>\r\n<p>Problem of M. E. Szpilrajn.</p>\r\n<ol start=\"69\" type=\"1\">\r\n<li>When a Jordan curve (in a three-dimensional space) has a determinate\r\ntangent at each point, does there necessarily exist a parametric\r\nrepresentation of this curve expressing the cartesian coordinates of a\r\npoint of this curve as functions which can be derived from a parameter\r\n(and in this case the three derivatives cannot all cancel out at the\r\nsame time)?</li>\r\n</ol>\r\n<p>If the answer is negative, the question is asked again by admitting a\r\nset of zero measurement values of the parameter where the imposed\r\nconditions are not both satisfied.</p>\r\n<p>Problem of M. M. Fr'echet.</p>\r\n<ol start=\"70\" type=\"1\">\r\n<li>Does there exist a linear set $ E$ such that each linear analytical\r\nset is a one-to-one and continuous (in one sense) image of <span class=\"math inline\">\\(E\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. W. Sierpinski.</p>\r\n<ol start=\"71\" type=\"1\">\r\n<li>Does there exist an infinite sequence <span class=\"math inline\">\\(S\\)</span> of functions of a real variable\r\n(measurable or not), such that any function of a real variable of class\r\n<span class=\"math inline\">\\(2\\)</span> Baire is a limit of some sequence\r\nextracted from <span class=\"math inline\">\\(S\\)</span>?</li>\r\n</ol>\r\n<p>(According to M. C. Burstin such a sequence <span class=\"math inline\">\\(S\\)</span> cannot be composed uniquely of\r\nmeasurable functions<a href=\"#fn4\" class=\"footnote-ref\" id=\"fnref4\" role=\"doc-noteref\"><sup>4</sup></a>)</p>\r\n<p>Problem M. W. Sierpinski.</p>\r\n<ol start=\"72\" type=\"1\">\r\n<li>Does there exist in the <span class=\"math inline\">\\(n\\)</span>-dimensional Cartesian space (<span class=\"math inline\">\\(n&gt;1\\)</span>) a set always of the first\r\ncategory (i.e. of first category on each perfect set) and which is of\r\npositive dimension?</li>\r\n</ol>\r\n<p>(M. W. Hurewicz demonstrated using the continuum hypothesis that\r\nthere exists in Hilbert space an uncountable set <span class=\"math inline\">\\(H\\)</span> of which each uncountable subset is of\r\ninfinite dimension<a href=\"#fn5\" class=\"footnote-ref\" id=\"fnref5\" role=\"doc-noteref\"><sup>5</sup></a>). M. F. Hausdorff noticed that the\r\nset <span class=\"math inline\">\\(H\\)</span> is always of the first\r\ncategory. This follows easily from the fact that each separable metric\r\nspace <span class=\"math inline\">\\(M\\)</span> is the sum of a set of\r\ndimension <span class=\"math inline\">\\(0\\)</span> and a set of first\r\ncategory in <span class=\"math inline\">\\(M\\)</span>. -- <em>There\r\ntherefore exists, if <span class=\"math inline\">\\(2^{\\aleph} =\r\n\\aleph_{1}\\)</span>, in Hilbert space a set always of first category and\r\nof positive dimension</em>).</p>\r\n<p>Probleme de M. E. Szpilrajn.</p>\r\n<ol start=\"73\" type=\"1\">\r\n<li>Let, in three-dimensional Euclidean space, <span class=\"math inline\">\\(E\\)</span> be a homeomorphic image of the solid\r\nsphere <span class=\"math inline\">\\(S\\)</span> and <span class=\"math inline\">\\(L\\)</span> be a rectilinear segment whose interior\r\nis contained in the interior, and the ends in the border of <span class=\"math inline\">\\(E\\)</span> . Does there still exist a\r\nhomeomorphism transforming <span class=\"math inline\">\\(E\\)</span> into\r\n<span class=\"math inline\">\\(S\\)</span> such that <span class=\"math inline\">\\(L\\)</span> is transformed into the diameter of\r\n<span class=\"math inline\">\\(S\\)</span>?</li>\r\n</ol>\r\n<p>Problem of M. K. Borsuk.</p>\r\n<ol start=\"74\" type=\"1\">\r\n<li>Let <span class=\"math inline\">\\(\\mathbf {B}(\\mathbf {F})\\)</span> be\r\nthe smallest family of sets containing the given family $ $ and closed\r\nwith respect to the operations <span class=\"math inline\">\\(\\sigma\\)</span> and <span class=\"math inline\">\\(\\delta\\)</span> (addition and multiplication of\r\ncountable values). Is there a family of enumerable <span class=\"math inline\">\\(\\mathbf{D}\\)</span> of sets, such that all linear\r\nanalytic sets belong to <span class=\"math inline\">\\(\\mathbf\r\n{B}(\\mathbf{D})\\)</span> ?</li>\r\n</ol>\r\n<p>Problem of M. S. Ulam.</p>\r\n<ol start=\"75\" type=\"1\">\r\n<li>Is there an infinite set <span class=\"math inline\">\\(E\\)</span>\r\n(e.g. the set of all natural numbers) and a function <span class=\"math inline\">\\(f(X)\\)</span> which maps to any subset <span class=\"math inline\">\\(X\\)</span> of $E $ a subset <span class=\"math inline\">\\(f(X)\\)</span> of <span class=\"math inline\">\\(E\\)</span>, so that:</li>\r\n</ol>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(X \\subset f(X)\\)</span> for <span class=\"math inline\">\\(X \\subset E\\)</span>,</li>\r\n<li><span class=\"math inline\">\\(f(X+Y) = f(X) + f(Y)\\)</span> for <span class=\"math inline\">\\(X \\subset E\\)</span>, <span class=\"math inline\">\\(Y \\subset E\\)</span>,</li>\r\n<li>there exists for every set <span class=\"math inline\">\\(Y \\subset\r\nE\\)</span> at least one set <span class=\"math inline\">\\(X \\subset\r\nE\\)</span>, such that <span class=\"math inline\">\\(Y =\r\nf(X)\\)</span>,</li>\r\n<li>there exists at least one set <span class=\"math inline\">\\(X_{0}\r\n\\subset E\\)</span>, such that <span class=\"math inline\">\\(f(X_{0}) \\neq\r\nX_{0}\\)</span>.</li>\r\n</ol>\r\n<p>If we replace the relative condition to <span class=\"math inline\">\\(f(X+Y)\\)</span> by the condition weaker than <span class=\"math inline\">\\(f(X) \\subset f(Y)\\)</span> pure <span class=\"math inline\">\\(X \\subset Y \\subset E\\)</span>, the positive\r\nanswer is obvious.</p>\r\n<p>Problem of M. E. <span class=\"math inline\">\\(\\check{\\text{C}}\\)</span>ech.</p>\r\n<h1 id=\"problems-resolved.\">Problems resolved.</h1>\r\n<ol type=\"1\">\r\n<li>When is a set of points <span class=\"math inline\">\\(P\\)</span> a\r\none-to-one and continuous image (in a sense) of <span class=\"math inline\">\\(Q\\)</span> and <span class=\"math inline\">\\(Q\\)</span> a one-to-one and continuous image of\r\n<span class=\"math inline\">\\(P\\)</span>, can we affirm that the sets\r\n<span class=\"math inline\">\\(P\\)</span> and <span class=\"math inline\">\\(Q\\)</span> are homeomorphic?</li>\r\n</ol>\r\n<p><em>Negative</em> solution from M. Kuratowski, Fund. Math. t. II, pp.\r\n158-160</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>Is there a decomposition of an interval into <span class=\"math inline\">\\(\\aleph_{1}\\)</span> measurable sets (<span class=\"math inline\">\\(B\\)</span>), each non-empty and without common\r\npoints?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from MM. Lusin and Sierpinski,\r\n<em>Comptes Rendus</em>, t. 175, p.357 (note of August 21, 1922).</p>\r\n<ol start=\"6\" type=\"1\">\r\n<li>Third part. Can it be shown that a product of <span class=\"math inline\">\\(\\aleph_{1}\\)</span> sets (<span class=\"math inline\">\\(A\\)</span>) is not necessarily a set (<span class=\"math inline\">\\(A\\)</span>)?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from MM. Lusin and Sierpinski,\r\n<em>Journ, de Math</em>. 1923 (The authors define a set which is\r\ncomplementary to a set (<span class=\"math inline\">\\(A\\)</span>) is not\r\nnecessarily a set (<span class=\"math inline\">\\(A\\)</span>).)</p>\r\n<ol start=\"8\" type=\"1\">\r\n<li>Can we give an effective example of a set of real numbers <span class=\"math inline\">\\(E\\)</span>, such as any sum, difference, product\r\nor quotient of two numbers of <span class=\"math inline\">\\(E\\)</span>\r\n(except division by 0) belongs to <span class=\"math inline\">\\(E_{1}\\)</span> and that <span class=\"math inline\">\\(E\\)</span> is uncountable, distinct from the set\r\nof all real numbers?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from M. Souslin, <em>Fund. Math.</em>\r\nIV, p.311.</p>\r\n<ol start=\"10\" type=\"1\">\r\n<li>First part. Is there a second class function which is not the limit\r\nof almost everywhere discontinuous functions?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from M. Zalcwasser.</p>\r\n<ol start=\"12\" type=\"1\">\r\n<li>Does an ordered set of which all well-ordered subsets (increasing or\r\ndecreasing) are at most enumerable necessarily have a power no greater\r\nthan that of the continuum?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from M. Urysohn, <em>Fund. Math.</em> V\r\n(to appear).</p>\r\n<ol start=\"15\" type=\"1\">\r\n<li>Is there a continuum of which any subcontinuum is\r\nindecomposable?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution from M. Knaster, <em>Fund. Math.</em>\r\nIII pp. 247-286.</p>\r\n<ol start=\"16\" type=\"1\">\r\n<li>Does there exist a continuum which is a sum of its proper disjoint\r\nsaturated subcontinua?</li>\r\n</ol>\r\n<p><em>Affirmative</em> solution by MM. Knaster and Kuratowski,\r\n<em>Fund. Math.</em> V.</p>\r\n<section id=\"footnotes\" class=\"footnotes footnotes-end-of-document\" role=\"doc-endnotes\">\r\n<hr>\r\n<ol>\r\n<li id=\"fn1\"><p>Accounts of the Soc. of Varsovic Sciences , t. VII,\r\np.382.<a href=\"#fnref1\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn2\"><p>Sitzungaber d. Bayer. Akad. d. Wiss., math.-phys. K1,\r\n1922, p. 223.<a href=\"#fnref2\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn3\"><p>See p. e. N. Lusin and W. Sierpinski <em>Journ. of\r\nMath.</em> t. II (1923) p. 60; also <em>Bull. Acad. Krakow</em> 1918 p.\r\n40.<a href=\"#fnref3\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn4\"><p>Monatshefte f. Math. u. Phys. 28 (1917), p. 107.<a href=\"#fnref4\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn5\"><p>Fund . Math. 19 (1932), p.8.<a href=\"#fnref5\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n</ol>\r\n</section>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Wed Nov 27 2024 23:17:33 GMT+0800 (中国标准时间)","title":"75 Problems in the Foundation of Mathematics","path":"2023/09/22/75 Problems/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-09-22T14:10:39.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-09-22T14:10:39.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Set Theory","tags":["Set Theory"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Cichon's Diagram","date":"2023-07-31T01:14:51.000Z","mathjax":true,"_content":"\n# Definitions\n\nLet $I$ be an ideal of a given infinite set $X$, that is, a partially ordered collection of subsets such that \n\n1. $\\emptyset \\in I$,\n\n2. $B \\in I$ if $B \\subseteq A$ for some $A \\in I$, and \n\n3. $A \\cup B \\in I$ if $A, B \\in I$.\n\nAssume $I$ contains all finite subsets of $X$. We define the following cardinal coefficients of I:\n\n- $\\operatorname{add} (I) = \\min \\{|A|: A \\subseteq I \\land \\bigcup A \\notin I\\}$.\\\nThe \"additivity\" of $I$ is the smallest number of sets from $I$ whose union is not in $I$ any more. As any ideal is closed under finite unions, this number is always at least $\\aleph_{0}$; if $I$ is a $\\sigma$-ideal, then $\\operatorname{add} (I) \\geq \\aleph_{1}$. \n- $\\operatorname{cov} (I) = \\min \\{|A|: A \\subseteq I \\land \\bigcup A = X\\}$.\\\nThe \"covering number\" of $I$ is the smallest number of sets from $I$ whose union is all of $X$. As $X$ itself is not in $I$, we must have $\\operatorname{add} (I)  \\leq  \\operatorname{cov} (I) $.\n- $\\operatorname{non} (I) = \\min \\{|A|: A \\subseteq X \\land A \\notin I\\}$.\\\nThe \"uniformity number\" of $I$ (sometimes also written $\\operatorname{unif} (I)$) is the size of the smallest set not in $I$. By our assumption on $I$, $\\operatorname{add} (I) \\leq \\operatorname{non} (I)$.\n- $\\operatorname{cof} (I) = \\{|\\mathsf{A}|: \\mathsf{A} \\subseteq I \\land (\\forall B \\in I)(\\exists A \\in \\mathsf{A})(B \\subseteq A)\\}$.\\\nThe \"cofinality\" of $I$ is the cofinality of the partial order $(I, \\subseteq)$. It is easy to see that we must have $\\operatorname{non} (I) \\leq \\operatorname{cof} (I)$ and $\\operatorname{cov} (I) \\leq \\operatorname{cof} (I)$.\n\nFurthermore, the \"bounding number\" or \"unboundedness number\" $\\mathsf{b}$ and the \"dominating number\" $\\mathsf{d}$ are defined as follows:\n\n- $\\mathsf{b} = \\min \\{|F|: F \\subseteq \\mathbb{N}^{\\mathbb{N}} \\land (\\forall g \\in \\mathbb{N}^{\\mathbb{N}}) (\\exists f \\in F) (\\exists^{\\infty}n \\in \\mathbb{N})(g(n)<f(n)) \\}$\n- $\\mathsf{d} = \\min \\{|F|: F \\subseteq \\mathbb{N}^{\\mathbb{N}} \\land (\\forall g \\in \\mathbb{N}^{\\mathbb{N}}) (\\exists f \\in F) (\\forall^{\\infty}n \\in \\mathbb{N})(g(n)<f(n)) \\}$\n\nwhere \"$\\exists^{\\infty} n \\in \\mathbb{N}$\" means: \"there are infinitely many natural numbers $n$ such that ...\", and \"$\\forall^{\\infty} n \\in \\mathbb{N}$\" means \"for all except finitely many natural numbers $n$ we have ...\".\n\n# Diagram\n\nLet $\\mathsf{B}$ be the $\\sigma$-ideal of those subsets of the real line that are meager (or \"of the first category\") in the euclidean topology, and let $\\mathsf{L}$ be the $\\sigma$-ideal of those subsets of the real line that are of Lebesgue measure zero. Then the following inequalities hold:\n\n$$\\require{AMScd} \n\\begin{CD}\n\\, @.\n\\operatorname{cov}(\\mathsf{L}) @>>> \\operatorname{non}(\\mathsf{B}) @>>> \\operatorname{cof}(\\mathsf{B}) @>>>\n\\operatorname{cof}(\\mathsf{L}) @>>> \n2^{\\aleph_{0}}\\\\\n@. @. @AAA @AAA @. @. \\\\ \n@. \\Bigg \\uparrow @. \\mathsf{b} @>>> \\mathsf{d} @. \\Bigg \\uparrow @. \\\\\n@. @. @AAA  @AAA @. @.\\\\\n\\aleph_{1} @>>>\n\\operatorname{add}(\\mathsf{L}) @>>> \\operatorname{add}(\\mathsf{B}) @>>> \\operatorname{cov}(\\mathsf{B}) @>>>\n\\operatorname{non}(\\mathsf{L}) @. \\,\n\\end{CD}$$\n\n\nWhere an arrow from $x$ to $y$ is to mean that \n$x \\leq y$. In addition, the following relations hold:\n\n$$\\begin{aligned} \\operatorname{add}({\\mathsf B}) = & \\min\\{\\operatorname{cov}({\\mathsf B}),{\\mathsf b}\\}, \\text{ and }\\\\\n\\operatorname{cof}({\\mathsf B}) = & \\max\\{\\operatorname{non}({\\mathsf B}),{\\mathsf d}\\}. \n\\end{aligned}$$\n\nIt turns out that the inequalities described by the diagram, together with the relations mentioned above, are all the relations between these cardinals that are provable in ZFC, in the following limited sense. Let $A$ be any assignment of the cardinals $\\aleph_{1}$ and $\\aleph_{2}$ to the $10$ cardinals in Cichoń's diagram. Then if $A$ is consistent with the diagram's relations, and if $A$ also satisfies the two additional relations, then $A$ can be realized in some model of ZFC.\n\nFor larger continuum sizes, the situation is less clear. It is consistent with ZFC that all of the Cichon's diagram cardinals are simultaneously different apart from $\\operatorname{add}(B)$ and $\\operatorname{cof}(B)$ (which are equal to other entries), but it remains open whether all combinations of the cardinal orderings consistent with the diagram are consistent.\n\n\n\n\n**Conjecture 1:** Suppose that $P$ is a closed subset of the real line such that $\\lambda(P) = 0$ and $\\lambda(P+P)>0$. Then there exists a set $A \\subseteq P$ such that $A+P$ is a Lebersgue nonmeasurable set. \n\n\n\n","source":"_posts/Cichon's Diagram.md","raw":"---\ntitle: Cichon's Diagram\ndate: 2023-07-31 09:14:51\ntags:\n    - [Set Theory]\ncategories:\n    - [Set Theory]\nmathjax: true\n---\n\n# Definitions\n\nLet $I$ be an ideal of a given infinite set $X$, that is, a partially ordered collection of subsets such that \n\n1. $\\emptyset \\in I$,\n\n2. $B \\in I$ if $B \\subseteq A$ for some $A \\in I$, and \n\n3. $A \\cup B \\in I$ if $A, B \\in I$.\n\nAssume $I$ contains all finite subsets of $X$. We define the following cardinal coefficients of I:\n\n- $\\operatorname{add} (I) = \\min \\{|A|: A \\subseteq I \\land \\bigcup A \\notin I\\}$.\\\nThe \"additivity\" of $I$ is the smallest number of sets from $I$ whose union is not in $I$ any more. As any ideal is closed under finite unions, this number is always at least $\\aleph_{0}$; if $I$ is a $\\sigma$-ideal, then $\\operatorname{add} (I) \\geq \\aleph_{1}$. \n- $\\operatorname{cov} (I) = \\min \\{|A|: A \\subseteq I \\land \\bigcup A = X\\}$.\\\nThe \"covering number\" of $I$ is the smallest number of sets from $I$ whose union is all of $X$. As $X$ itself is not in $I$, we must have $\\operatorname{add} (I)  \\leq  \\operatorname{cov} (I) $.\n- $\\operatorname{non} (I) = \\min \\{|A|: A \\subseteq X \\land A \\notin I\\}$.\\\nThe \"uniformity number\" of $I$ (sometimes also written $\\operatorname{unif} (I)$) is the size of the smallest set not in $I$. By our assumption on $I$, $\\operatorname{add} (I) \\leq \\operatorname{non} (I)$.\n- $\\operatorname{cof} (I) = \\{|\\mathsf{A}|: \\mathsf{A} \\subseteq I \\land (\\forall B \\in I)(\\exists A \\in \\mathsf{A})(B \\subseteq A)\\}$.\\\nThe \"cofinality\" of $I$ is the cofinality of the partial order $(I, \\subseteq)$. It is easy to see that we must have $\\operatorname{non} (I) \\leq \\operatorname{cof} (I)$ and $\\operatorname{cov} (I) \\leq \\operatorname{cof} (I)$.\n\nFurthermore, the \"bounding number\" or \"unboundedness number\" $\\mathsf{b}$ and the \"dominating number\" $\\mathsf{d}$ are defined as follows:\n\n- $\\mathsf{b} = \\min \\{|F|: F \\subseteq \\mathbb{N}^{\\mathbb{N}} \\land (\\forall g \\in \\mathbb{N}^{\\mathbb{N}}) (\\exists f \\in F) (\\exists^{\\infty}n \\in \\mathbb{N})(g(n)<f(n)) \\}$\n- $\\mathsf{d} = \\min \\{|F|: F \\subseteq \\mathbb{N}^{\\mathbb{N}} \\land (\\forall g \\in \\mathbb{N}^{\\mathbb{N}}) (\\exists f \\in F) (\\forall^{\\infty}n \\in \\mathbb{N})(g(n)<f(n)) \\}$\n\nwhere \"$\\exists^{\\infty} n \\in \\mathbb{N}$\" means: \"there are infinitely many natural numbers $n$ such that ...\", and \"$\\forall^{\\infty} n \\in \\mathbb{N}$\" means \"for all except finitely many natural numbers $n$ we have ...\".\n\n# Diagram\n\nLet $\\mathsf{B}$ be the $\\sigma$-ideal of those subsets of the real line that are meager (or \"of the first category\") in the euclidean topology, and let $\\mathsf{L}$ be the $\\sigma$-ideal of those subsets of the real line that are of Lebesgue measure zero. Then the following inequalities hold:\n\n$$\\require{AMScd} \n\\begin{CD}\n\\, @.\n\\operatorname{cov}(\\mathsf{L}) @>>> \\operatorname{non}(\\mathsf{B}) @>>> \\operatorname{cof}(\\mathsf{B}) @>>>\n\\operatorname{cof}(\\mathsf{L}) @>>> \n2^{\\aleph_{0}}\\\\\n@. @. @AAA @AAA @. @. \\\\ \n@. \\Bigg \\uparrow @. \\mathsf{b} @>>> \\mathsf{d} @. \\Bigg \\uparrow @. \\\\\n@. @. @AAA  @AAA @. @.\\\\\n\\aleph_{1} @>>>\n\\operatorname{add}(\\mathsf{L}) @>>> \\operatorname{add}(\\mathsf{B}) @>>> \\operatorname{cov}(\\mathsf{B}) @>>>\n\\operatorname{non}(\\mathsf{L}) @. \\,\n\\end{CD}$$\n\n\nWhere an arrow from $x$ to $y$ is to mean that \n$x \\leq y$. In addition, the following relations hold:\n\n$$\\begin{aligned} \\operatorname{add}({\\mathsf B}) = & \\min\\{\\operatorname{cov}({\\mathsf B}),{\\mathsf b}\\}, \\text{ and }\\\\\n\\operatorname{cof}({\\mathsf B}) = & \\max\\{\\operatorname{non}({\\mathsf B}),{\\mathsf d}\\}. \n\\end{aligned}$$\n\nIt turns out that the inequalities described by the diagram, together with the relations mentioned above, are all the relations between these cardinals that are provable in ZFC, in the following limited sense. Let $A$ be any assignment of the cardinals $\\aleph_{1}$ and $\\aleph_{2}$ to the $10$ cardinals in Cichoń's diagram. Then if $A$ is consistent with the diagram's relations, and if $A$ also satisfies the two additional relations, then $A$ can be realized in some model of ZFC.\n\nFor larger continuum sizes, the situation is less clear. It is consistent with ZFC that all of the Cichon's diagram cardinals are simultaneously different apart from $\\operatorname{add}(B)$ and $\\operatorname{cof}(B)$ (which are equal to other entries), but it remains open whether all combinations of the cardinal orderings consistent with the diagram are consistent.\n\n\n\n\n**Conjecture 1:** Suppose that $P$ is a closed subset of the real line such that $\\lambda(P) = 0$ and $\\lambda(P+P)>0$. Then there exists a set $A \\subseteq P$ such that $A+P$ is a Lebersgue nonmeasurable set. \n\n\n\n","slug":"Cichon's Diagram","published":1,"updated":"2024-02-25T15:11:07.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5rz0011m8nxf6lc372f","content":"<h1 id=\"definitions\">Definitions</h1>\r\n<p>Let <span class=\"math inline\">\\(I\\)</span> be an ideal of a given\r\ninfinite set <span class=\"math inline\">\\(X\\)</span>, that is, a\r\npartially ordered collection of subsets such that</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(\\emptyset \\in I\\)</span>,</p></li>\r\n<li><p><span class=\"math inline\">\\(B \\in I\\)</span> if <span class=\"math inline\">\\(B \\subseteq A\\)</span> for some <span class=\"math inline\">\\(A \\in I\\)</span>, and</p></li>\r\n<li><p><span class=\"math inline\">\\(A \\cup B \\in I\\)</span> if <span class=\"math inline\">\\(A, B \\in I\\)</span>.</p></li>\r\n</ol>\r\n<p>Assume <span class=\"math inline\">\\(I\\)</span> contains all finite\r\nsubsets of <span class=\"math inline\">\\(X\\)</span>. We define the\r\nfollowing cardinal coefficients of I:</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\operatorname{add} (I) = \\min \\{|A|: A\r\n\\subseteq I \\land \\bigcup A \\notin I\\}\\)</span>.<br>\r\nThe \"additivity\" of <span class=\"math inline\">\\(I\\)</span> is the\r\nsmallest number of sets from <span class=\"math inline\">\\(I\\)</span>\r\nwhose union is not in <span class=\"math inline\">\\(I\\)</span> any more.\r\nAs any ideal is closed under finite unions, this number is always at\r\nleast <span class=\"math inline\">\\(\\aleph_{0}\\)</span>; if <span class=\"math inline\">\\(I\\)</span> is a <span class=\"math inline\">\\(\\sigma\\)</span>-ideal, then <span class=\"math inline\">\\(\\operatorname{add} (I) \\geq\r\n\\aleph_{1}\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(\\operatorname{cov} (I) = \\min \\{|A|: A\r\n\\subseteq I \\land \\bigcup A = X\\}\\)</span>.<br>\r\nThe \"covering number\" of <span class=\"math inline\">\\(I\\)</span> is the\r\nsmallest number of sets from <span class=\"math inline\">\\(I\\)</span>\r\nwhose union is all of <span class=\"math inline\">\\(X\\)</span>. As <span class=\"math inline\">\\(X\\)</span> itself is not in <span class=\"math inline\">\\(I\\)</span>, we must have $ (I) (I) $.</li>\r\n<li><span class=\"math inline\">\\(\\operatorname{non} (I) = \\min \\{|A|: A\r\n\\subseteq X \\land A \\notin I\\}\\)</span>.<br>\r\nThe \"uniformity number\" of <span class=\"math inline\">\\(I\\)</span>\r\n(sometimes also written <span class=\"math inline\">\\(\\operatorname{unif}\r\n(I)\\)</span>) is the size of the smallest set not in <span class=\"math inline\">\\(I\\)</span>. By our assumption on <span class=\"math inline\">\\(I\\)</span>, <span class=\"math inline\">\\(\\operatorname{add} (I) \\leq \\operatorname{non}\r\n(I)\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(\\operatorname{cof} (I) = \\{|\\mathsf{A}|:\r\n\\mathsf{A} \\subseteq I \\land (\\forall B \\in I)(\\exists A \\in\r\n\\mathsf{A})(B \\subseteq A)\\}\\)</span>.<br>\r\nThe \"cofinality\" of <span class=\"math inline\">\\(I\\)</span> is the\r\ncofinality of the partial order <span class=\"math inline\">\\((I,\r\n\\subseteq)\\)</span>. It is easy to see that we must have <span class=\"math inline\">\\(\\operatorname{non} (I) \\leq \\operatorname{cof}\r\n(I)\\)</span> and <span class=\"math inline\">\\(\\operatorname{cov} (I) \\leq\r\n\\operatorname{cof} (I)\\)</span>.</li>\r\n</ul>\r\n<p>Furthermore, the \"bounding number\" or \"unboundedness number\" <span class=\"math inline\">\\(\\mathsf{b}\\)</span> and the \"dominating number\"\r\n<span class=\"math inline\">\\(\\mathsf{d}\\)</span> are defined as\r\nfollows:</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\mathsf{b} = \\min \\{|F|: F \\subseteq\r\n\\mathbb{N}^{\\mathbb{N}} \\land (\\forall g \\in \\mathbb{N}^{\\mathbb{N}})\r\n(\\exists f \\in F) (\\exists^{\\infty}n \\in \\mathbb{N})(g(n)&lt;f(n))\r\n\\}\\)</span></li>\r\n<li><span class=\"math inline\">\\(\\mathsf{d} = \\min \\{|F|: F \\subseteq\r\n\\mathbb{N}^{\\mathbb{N}} \\land (\\forall g \\in \\mathbb{N}^{\\mathbb{N}})\r\n(\\exists f \\in F) (\\forall^{\\infty}n \\in \\mathbb{N})(g(n)&lt;f(n))\r\n\\}\\)</span></li>\r\n</ul>\r\n<p>where \"<span class=\"math inline\">\\(\\exists^{\\infty} n \\in\r\n\\mathbb{N}\\)</span>\" means: \"there are infinitely many natural numbers\r\n<span class=\"math inline\">\\(n\\)</span> such that ...\", and \"<span class=\"math inline\">\\(\\forall^{\\infty} n \\in \\mathbb{N}\\)</span>\" means\r\n\"for all except finitely many natural numbers <span class=\"math inline\">\\(n\\)</span> we have ...\".</p>\r\n<h1 id=\"diagram\">Diagram</h1>\r\n<p>Let <span class=\"math inline\">\\(\\mathsf{B}\\)</span> be the <span class=\"math inline\">\\(\\sigma\\)</span>-ideal of those subsets of the real\r\nline that are meager (or \"of the first category\") in the euclidean\r\ntopology, and let <span class=\"math inline\">\\(\\mathsf{L}\\)</span> be the\r\n<span class=\"math inline\">\\(\\sigma\\)</span>-ideal of those subsets of\r\nthe real line that are of Lebesgue measure zero. Then the following\r\ninequalities hold:</p>\r\n<p><span class=\"math display\">\\[\\require{AMScd}\r\n\\begin{CD}\r\n\\, @.\r\n\\operatorname{cov}(\\mathsf{L}) @&gt;&gt;&gt;\r\n\\operatorname{non}(\\mathsf{B}) @&gt;&gt;&gt;\r\n\\operatorname{cof}(\\mathsf{B}) @&gt;&gt;&gt;\r\n\\operatorname{cof}(\\mathsf{L}) @&gt;&gt;&gt;\r\n2^{\\aleph_{0}}\\\\\r\n@. @. @AAA @AAA @. @. \\\\\r\n@. \\Bigg \\uparrow @. \\mathsf{b} @&gt;&gt;&gt; \\mathsf{d} @. \\Bigg\r\n\\uparrow @. \\\\\r\n@. @. @AAA  @AAA @. @.\\\\\r\n\\aleph_{1} @&gt;&gt;&gt;\r\n\\operatorname{add}(\\mathsf{L}) @&gt;&gt;&gt;\r\n\\operatorname{add}(\\mathsf{B}) @&gt;&gt;&gt;\r\n\\operatorname{cov}(\\mathsf{B}) @&gt;&gt;&gt;\r\n\\operatorname{non}(\\mathsf{L}) @. \\,\r\n\\end{CD}\\]</span></p>\r\n<p>Where an arrow from <span class=\"math inline\">\\(x\\)</span> to <span class=\"math inline\">\\(y\\)</span> is to mean that <span class=\"math inline\">\\(x \\leq y\\)</span>. In addition, the following\r\nrelations hold:</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n\\operatorname{add}({\\mathsf B}) = &amp;\r\n\\min\\{\\operatorname{cov}({\\mathsf B}),{\\mathsf b}\\}, \\text{ and }\\\\\r\n\\operatorname{cof}({\\mathsf B}) = &amp;\r\n\\max\\{\\operatorname{non}({\\mathsf B}),{\\mathsf d}\\}.\r\n\\end{aligned}\\]</span></p>\r\n<p>It turns out that the inequalities described by the diagram, together\r\nwith the relations mentioned above, are all the relations between these\r\ncardinals that are provable in ZFC, in the following limited sense. Let\r\n<span class=\"math inline\">\\(A\\)</span> be any assignment of the\r\ncardinals <span class=\"math inline\">\\(\\aleph_{1}\\)</span> and <span class=\"math inline\">\\(\\aleph_{2}\\)</span> to the <span class=\"math inline\">\\(10\\)</span> cardinals in Cichoń's diagram. Then if\r\n<span class=\"math inline\">\\(A\\)</span> is consistent with the diagram's\r\nrelations, and if <span class=\"math inline\">\\(A\\)</span> also satisfies\r\nthe two additional relations, then <span class=\"math inline\">\\(A\\)</span> can be realized in some model of\r\nZFC.</p>\r\n<p>For larger continuum sizes, the situation is less clear. It is\r\nconsistent with ZFC that all of the Cichon's diagram cardinals are\r\nsimultaneously different apart from <span class=\"math inline\">\\(\\operatorname{add}(B)\\)</span> and <span class=\"math inline\">\\(\\operatorname{cof}(B)\\)</span> (which are equal to\r\nother entries), but it remains open whether all combinations of the\r\ncardinal orderings consistent with the diagram are consistent.</p>\r\n<p><strong>Conjecture 1:</strong> Suppose that <span class=\"math inline\">\\(P\\)</span> is a closed subset of the real line\r\nsuch that <span class=\"math inline\">\\(\\lambda(P) = 0\\)</span> and <span class=\"math inline\">\\(\\lambda(P+P)&gt;0\\)</span>. Then there exists a\r\nset <span class=\"math inline\">\\(A \\subseteq P\\)</span> such that <span class=\"math inline\">\\(A+P\\)</span> is a Lebersgue nonmeasurable set.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"definitions\">Definitions</h1>\r\n<p>Let <span class=\"math inline\">\\(I\\)</span> be an ideal of a given\r\ninfinite set <span class=\"math inline\">\\(X\\)</span>, that is, a\r\npartially ordered collection of subsets such that</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(\\emptyset \\in I\\)</span>,</p></li>\r\n<li><p><span class=\"math inline\">\\(B \\in I\\)</span> if <span class=\"math inline\">\\(B \\subseteq A\\)</span> for some <span class=\"math inline\">\\(A \\in I\\)</span>, and</p></li>\r\n<li><p><span class=\"math inline\">\\(A \\cup B \\in I\\)</span> if <span class=\"math inline\">\\(A, B \\in I\\)</span>.</p></li>\r\n</ol>\r\n<p>Assume <span class=\"math inline\">\\(I\\)</span> contains all finite\r\nsubsets of <span class=\"math inline\">\\(X\\)</span>. We define the\r\nfollowing cardinal coefficients of I:</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\operatorname{add} (I) = \\min \\{|A|: A\r\n\\subseteq I \\land \\bigcup A \\notin I\\}\\)</span>.<br>\r\nThe \"additivity\" of <span class=\"math inline\">\\(I\\)</span> is the\r\nsmallest number of sets from <span class=\"math inline\">\\(I\\)</span>\r\nwhose union is not in <span class=\"math inline\">\\(I\\)</span> any more.\r\nAs any ideal is closed under finite unions, this number is always at\r\nleast <span class=\"math inline\">\\(\\aleph_{0}\\)</span>; if <span class=\"math inline\">\\(I\\)</span> is a <span class=\"math inline\">\\(\\sigma\\)</span>-ideal, then <span class=\"math inline\">\\(\\operatorname{add} (I) \\geq\r\n\\aleph_{1}\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(\\operatorname{cov} (I) = \\min \\{|A|: A\r\n\\subseteq I \\land \\bigcup A = X\\}\\)</span>.<br>\r\nThe \"covering number\" of <span class=\"math inline\">\\(I\\)</span> is the\r\nsmallest number of sets from <span class=\"math inline\">\\(I\\)</span>\r\nwhose union is all of <span class=\"math inline\">\\(X\\)</span>. As <span class=\"math inline\">\\(X\\)</span> itself is not in <span class=\"math inline\">\\(I\\)</span>, we must have $ (I) (I) $.</li>\r\n<li><span class=\"math inline\">\\(\\operatorname{non} (I) = \\min \\{|A|: A\r\n\\subseteq X \\land A \\notin I\\}\\)</span>.<br>\r\nThe \"uniformity number\" of <span class=\"math inline\">\\(I\\)</span>\r\n(sometimes also written <span class=\"math inline\">\\(\\operatorname{unif}\r\n(I)\\)</span>) is the size of the smallest set not in <span class=\"math inline\">\\(I\\)</span>. By our assumption on <span class=\"math inline\">\\(I\\)</span>, <span class=\"math inline\">\\(\\operatorname{add} (I) \\leq \\operatorname{non}\r\n(I)\\)</span>.</li>\r\n<li><span class=\"math inline\">\\(\\operatorname{cof} (I) = \\{|\\mathsf{A}|:\r\n\\mathsf{A} \\subseteq I \\land (\\forall B \\in I)(\\exists A \\in\r\n\\mathsf{A})(B \\subseteq A)\\}\\)</span>.<br>\r\nThe \"cofinality\" of <span class=\"math inline\">\\(I\\)</span> is the\r\ncofinality of the partial order <span class=\"math inline\">\\((I,\r\n\\subseteq)\\)</span>. It is easy to see that we must have <span class=\"math inline\">\\(\\operatorname{non} (I) \\leq \\operatorname{cof}\r\n(I)\\)</span> and <span class=\"math inline\">\\(\\operatorname{cov} (I) \\leq\r\n\\operatorname{cof} (I)\\)</span>.</li>\r\n</ul>\r\n<p>Furthermore, the \"bounding number\" or \"unboundedness number\" <span class=\"math inline\">\\(\\mathsf{b}\\)</span> and the \"dominating number\"\r\n<span class=\"math inline\">\\(\\mathsf{d}\\)</span> are defined as\r\nfollows:</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\mathsf{b} = \\min \\{|F|: F \\subseteq\r\n\\mathbb{N}^{\\mathbb{N}} \\land (\\forall g \\in \\mathbb{N}^{\\mathbb{N}})\r\n(\\exists f \\in F) (\\exists^{\\infty}n \\in \\mathbb{N})(g(n)&lt;f(n))\r\n\\}\\)</span></li>\r\n<li><span class=\"math inline\">\\(\\mathsf{d} = \\min \\{|F|: F \\subseteq\r\n\\mathbb{N}^{\\mathbb{N}} \\land (\\forall g \\in \\mathbb{N}^{\\mathbb{N}})\r\n(\\exists f \\in F) (\\forall^{\\infty}n \\in \\mathbb{N})(g(n)&lt;f(n))\r\n\\}\\)</span></li>\r\n</ul>\r\n<p>where \"<span class=\"math inline\">\\(\\exists^{\\infty} n \\in\r\n\\mathbb{N}\\)</span>\" means: \"there are infinitely many natural numbers\r\n<span class=\"math inline\">\\(n\\)</span> such that ...\", and \"<span class=\"math inline\">\\(\\forall^{\\infty} n \\in \\mathbb{N}\\)</span>\" means\r\n\"for all except finitely many natural numbers <span class=\"math inline\">\\(n\\)</span> we have ...\".</p>\r\n<h1 id=\"diagram\">Diagram</h1>\r\n<p>Let <span class=\"math inline\">\\(\\mathsf{B}\\)</span> be the <span class=\"math inline\">\\(\\sigma\\)</span>-ideal of those subsets of the real\r\nline that are meager (or \"of the first category\") in the euclidean\r\ntopology, and let <span class=\"math inline\">\\(\\mathsf{L}\\)</span> be the\r\n<span class=\"math inline\">\\(\\sigma\\)</span>-ideal of those subsets of\r\nthe real line that are of Lebesgue measure zero. Then the following\r\ninequalities hold:</p>\r\n<p><span class=\"math display\">\\[\\require{AMScd}\r\n\\begin{CD}\r\n\\, @.\r\n\\operatorname{cov}(\\mathsf{L}) @&gt;&gt;&gt;\r\n\\operatorname{non}(\\mathsf{B}) @&gt;&gt;&gt;\r\n\\operatorname{cof}(\\mathsf{B}) @&gt;&gt;&gt;\r\n\\operatorname{cof}(\\mathsf{L}) @&gt;&gt;&gt;\r\n2^{\\aleph_{0}}\\\\\r\n@. @. @AAA @AAA @. @. \\\\\r\n@. \\Bigg \\uparrow @. \\mathsf{b} @&gt;&gt;&gt; \\mathsf{d} @. \\Bigg\r\n\\uparrow @. \\\\\r\n@. @. @AAA  @AAA @. @.\\\\\r\n\\aleph_{1} @&gt;&gt;&gt;\r\n\\operatorname{add}(\\mathsf{L}) @&gt;&gt;&gt;\r\n\\operatorname{add}(\\mathsf{B}) @&gt;&gt;&gt;\r\n\\operatorname{cov}(\\mathsf{B}) @&gt;&gt;&gt;\r\n\\operatorname{non}(\\mathsf{L}) @. \\,\r\n\\end{CD}\\]</span></p>\r\n<p>Where an arrow from <span class=\"math inline\">\\(x\\)</span> to <span class=\"math inline\">\\(y\\)</span> is to mean that <span class=\"math inline\">\\(x \\leq y\\)</span>. In addition, the following\r\nrelations hold:</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n\\operatorname{add}({\\mathsf B}) = &amp;\r\n\\min\\{\\operatorname{cov}({\\mathsf B}),{\\mathsf b}\\}, \\text{ and }\\\\\r\n\\operatorname{cof}({\\mathsf B}) = &amp;\r\n\\max\\{\\operatorname{non}({\\mathsf B}),{\\mathsf d}\\}.\r\n\\end{aligned}\\]</span></p>\r\n<p>It turns out that the inequalities described by the diagram, together\r\nwith the relations mentioned above, are all the relations between these\r\ncardinals that are provable in ZFC, in the following limited sense. Let\r\n<span class=\"math inline\">\\(A\\)</span> be any assignment of the\r\ncardinals <span class=\"math inline\">\\(\\aleph_{1}\\)</span> and <span class=\"math inline\">\\(\\aleph_{2}\\)</span> to the <span class=\"math inline\">\\(10\\)</span> cardinals in Cichoń's diagram. Then if\r\n<span class=\"math inline\">\\(A\\)</span> is consistent with the diagram's\r\nrelations, and if <span class=\"math inline\">\\(A\\)</span> also satisfies\r\nthe two additional relations, then <span class=\"math inline\">\\(A\\)</span> can be realized in some model of\r\nZFC.</p>\r\n<p>For larger continuum sizes, the situation is less clear. It is\r\nconsistent with ZFC that all of the Cichon's diagram cardinals are\r\nsimultaneously different apart from <span class=\"math inline\">\\(\\operatorname{add}(B)\\)</span> and <span class=\"math inline\">\\(\\operatorname{cof}(B)\\)</span> (which are equal to\r\nother entries), but it remains open whether all combinations of the\r\ncardinal orderings consistent with the diagram are consistent.</p>\r\n<p><strong>Conjecture 1:</strong> Suppose that <span class=\"math inline\">\\(P\\)</span> is a closed subset of the real line\r\nsuch that <span class=\"math inline\">\\(\\lambda(P) = 0\\)</span> and <span class=\"math inline\">\\(\\lambda(P+P)&gt;0\\)</span>. Then there exists a\r\nset <span class=\"math inline\">\\(A \\subseteq P\\)</span> such that <span class=\"math inline\">\\(A+P\\)</span> is a Lebersgue nonmeasurable set.</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Feb 25 2024 23:11:07 GMT+0800 (中国标准时间)","title":"Cichon's Diagram","path":"2023/07/31/Cichon's Diagram/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-07-31T01:14:51.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-07-31T01:14:51.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Set Theory","tags":["Set Theory"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Henkin's Theorem","date":"2024-11-13T05:13:30.000Z","mathjax":true,"_content":"\n\n# Henkin's Theorem\n\nFor a consistent theory $\\Phi$ in first-order logic, there exists a model $\\mathcal{M}$ such that $\\mathcal{M}$ satisfies all the sentences in $\\Phi$, i.e., $\\mathcal{M} \\models \\Phi$. \n\nThis is equivalent to saying that if $\\Phi$ is consistent, then $\\Phi$ has a model. The theorem asserts that **consistency** and **satisfiability** are equivalent for first-order theories.\n\n## Key Concepts in the Proof:\n\n1. **Negation-Complete Theory**: A theory $\\Phi$ is **negation-complete** if for every formula $\\psi$, either $\\psi$ or $\\neg \\psi$ is a theorem of $\\Phi$. This property ensures that the theory makes a definitive decision about the truth value of every formula.\n\n2. **Witness Property**: A theory $\\Phi$ has the **witness property** if for every existential formula $\\exists x \\, \\psi(x)$, there is a constant $c$ such that $\\Phi$ proves $\\exists x \\, \\psi(x) \\rightarrow \\psi(c)$. This ensures that existential claims are satisfied by specific, named elements in the model.\n\nThese concepts are essential for the construction of a model that satisfies the theory. The proof of Henkin's theorem proceeds by extending the theory $\\Phi$ to make it **Henkin-complete**: consistent, negation-complete, and with the witness property.\n\n## Proof for the Countable Case\n\nFor a countable language $L$ (where both the set of symbols and the set of sentences are countable), we proceed by constructing a **Henkin-complete extension** of $\\Phi$, and then we use this extension to build a **term model**.\n\n### Step 1: Extend $\\Phi$ to a Henkin-Complete Theory $\\Phi'$\n\n1. **Enumerate All Formulas**: Since $L$ is countable, the set of all possible sentences in $L$ is also countable. We list these sentences as $\\psi_1, \\psi_2, \\psi_3, \\ldots$.\n\n2. **Add Witness Constants**: For each existential formula $\\exists x \\, \\psi(x)$ in $L$, introduce a new constant symbol $c_{\\exists x \\psi(x)}$, which will act as a \"witness\" for $\\exists x \\, \\psi(x)$ in our theory. Ensure these new constants do not already exist in $L$.\n\n3. **Construct the Extension $\\Phi'$**:\n   - Begin with $\\Phi_0 = \\Phi$.\n   - For each $\\psi_n$ in our enumeration, construct $\\Phi_{n+1}$ from $\\Phi_n$ as follows:\n     - If $\\Phi_n \\cup \\{ \\psi_n \\}$ is consistent, set $\\Phi_{n+1} = \\Phi_n \\cup \\{ \\psi_n \\}$.\n     - If $\\Phi_n \\cup \\{ \\neg \\psi_n \\}$ is consistent, set $\\Phi_{n+1} = \\Phi_n \\cup \\{ \\neg \\psi_n \\}$.\n   - This process yields an extended theory $\\Phi' = \\bigcup_{n=0}^\\infty \\Phi_n$.\n\n   By construction, $\\Phi'$ is consistent, negation-complete, and has the witness property for existential formulas. Thus, $\\Phi'$ is **Henkin-complete**.\n\n### Step 2: Construct the Term Model $\\mathcal{M}_{\\Phi'}$\n\n1. **Define the Domain**: The domain of $\\mathcal{M}_{\\Phi'}$ consists of equivalence classes of terms in $\\Phi'$, where two terms $t_1$ and $t_2$ are equivalent if $\\Phi' \\vdash t_1 = t_2$.\n\n2. **Interpret Symbols**:\n   - Each constant symbol $c$ is interpreted as its equivalence class in $\\mathcal{M}_{\\Phi'}$.\n   - Each function symbol $f$ is interpreted as a function on these equivalence classes as defined by $\\Phi'$.\n   - Each relation symbol $R$ is interpreted according to the formulas in $\\Phi'$ that specify its behavior.\n\n3. **Satisfaction**: By Henkin's construction, $\\mathcal{M}_{\\Phi'} \\models \\Phi'$, ensuring that $\\mathcal{M}_{\\Phi'} \\models \\Phi$, as $\\Phi \\subset \\Phi'$.\n\nThus, $\\mathcal{M}_{\\Phi'}$ is a model of $\\Phi$, completing the proof for the countable case.\n\n---\n\n## Proof for the General Case (Arbitrary Cardinality)\n\nFor languages $L$ of arbitrary cardinality, we modify the previous approach to handle uncountably many formulas and witness requirements.\n\n### Step 1: Construct a Henkin-Complete Extension $\\Phi'$ Using Zorn's Lemma\n\n1. **Partial Extensions and Consistency**: Consider the collection $\\mathcal{T}$ of all consistent extensions of $\\Phi$ that are closed under logical consequence. We partially order $\\mathcal{T}$ by set inclusion.\n\n2. **Apply Zorn's Lemma**: Since every chain of consistent extensions has an upper bound (the union of the chain), Zorn's Lemma ensures that $\\mathcal{T}$ has a maximal element, denoted $\\Phi'$, which is consistent and closed under logical consequence.\n\n3. **Henkin-Completeness of $\\Phi'$**:\n   - Since $\\Phi'$ is maximal, for each formula $\\psi$ in $L$, either $\\psi \\in \\Phi'$ or $\\neg \\psi \\in \\Phi'$, establishing **negation-completeness**.\n   - For each existential formula $\\exists x \\, \\psi(x)$, add a witness constant $c_{\\exists x \\psi(x)}$ and ensure that $\\exists x \\, \\psi(x) \\rightarrow \\psi(c_{\\exists x \\psi(x)}) \\in \\Phi'$. This property holds because we can extend consistently with witnesses at each step.\n\nThus, $\\Phi'$ is Henkin-complete.\n\n### Step 2: Construct the Term Model $\\mathcal{M}_{\\Phi'}$\n\nAs in the countable case, we define a term model $\\mathcal{M}_{\\Phi'}$ based on $\\Phi'$:\n\n1. **Domain**: The domain consists of equivalence classes of terms under the relation $t_1 \\sim t_2 \\iff \\Phi' \\vdash t_1 = t_2$.\n\n2. **Interpretation**:\n   - Constants, functions, and relations are interpreted naturally according to $\\Phi'$, making $\\mathcal{M}_{\\Phi'}$ a model of $\\Phi'$.\n\n3. **Satisfaction**: By construction, $\\mathcal{M}_{\\Phi'} \\models \\Phi'$, and since $\\Phi \\subset \\Phi'$, $\\mathcal{M}_{\\Phi'} \\models \\Phi$.\n\nThus, $\\mathcal{M}_{\\Phi'}$ serves as a model for $\\Phi$, concluding the proof for arbitrary cardinality.\n\n","source":"_posts/Henkin‘s Theorem.md","raw":"---\ntitle: Henkin's Theorem\ndate: 2024-11-13 13:13:30\ntags:\n    - [Notes]\n    - [Mathematical Logic]\ncategories:\n    - [Notes]\n    - [Mathematical Logic]\nmathjax: true\n---\n\n\n# Henkin's Theorem\n\nFor a consistent theory $\\Phi$ in first-order logic, there exists a model $\\mathcal{M}$ such that $\\mathcal{M}$ satisfies all the sentences in $\\Phi$, i.e., $\\mathcal{M} \\models \\Phi$. \n\nThis is equivalent to saying that if $\\Phi$ is consistent, then $\\Phi$ has a model. The theorem asserts that **consistency** and **satisfiability** are equivalent for first-order theories.\n\n## Key Concepts in the Proof:\n\n1. **Negation-Complete Theory**: A theory $\\Phi$ is **negation-complete** if for every formula $\\psi$, either $\\psi$ or $\\neg \\psi$ is a theorem of $\\Phi$. This property ensures that the theory makes a definitive decision about the truth value of every formula.\n\n2. **Witness Property**: A theory $\\Phi$ has the **witness property** if for every existential formula $\\exists x \\, \\psi(x)$, there is a constant $c$ such that $\\Phi$ proves $\\exists x \\, \\psi(x) \\rightarrow \\psi(c)$. This ensures that existential claims are satisfied by specific, named elements in the model.\n\nThese concepts are essential for the construction of a model that satisfies the theory. The proof of Henkin's theorem proceeds by extending the theory $\\Phi$ to make it **Henkin-complete**: consistent, negation-complete, and with the witness property.\n\n## Proof for the Countable Case\n\nFor a countable language $L$ (where both the set of symbols and the set of sentences are countable), we proceed by constructing a **Henkin-complete extension** of $\\Phi$, and then we use this extension to build a **term model**.\n\n### Step 1: Extend $\\Phi$ to a Henkin-Complete Theory $\\Phi'$\n\n1. **Enumerate All Formulas**: Since $L$ is countable, the set of all possible sentences in $L$ is also countable. We list these sentences as $\\psi_1, \\psi_2, \\psi_3, \\ldots$.\n\n2. **Add Witness Constants**: For each existential formula $\\exists x \\, \\psi(x)$ in $L$, introduce a new constant symbol $c_{\\exists x \\psi(x)}$, which will act as a \"witness\" for $\\exists x \\, \\psi(x)$ in our theory. Ensure these new constants do not already exist in $L$.\n\n3. **Construct the Extension $\\Phi'$**:\n   - Begin with $\\Phi_0 = \\Phi$.\n   - For each $\\psi_n$ in our enumeration, construct $\\Phi_{n+1}$ from $\\Phi_n$ as follows:\n     - If $\\Phi_n \\cup \\{ \\psi_n \\}$ is consistent, set $\\Phi_{n+1} = \\Phi_n \\cup \\{ \\psi_n \\}$.\n     - If $\\Phi_n \\cup \\{ \\neg \\psi_n \\}$ is consistent, set $\\Phi_{n+1} = \\Phi_n \\cup \\{ \\neg \\psi_n \\}$.\n   - This process yields an extended theory $\\Phi' = \\bigcup_{n=0}^\\infty \\Phi_n$.\n\n   By construction, $\\Phi'$ is consistent, negation-complete, and has the witness property for existential formulas. Thus, $\\Phi'$ is **Henkin-complete**.\n\n### Step 2: Construct the Term Model $\\mathcal{M}_{\\Phi'}$\n\n1. **Define the Domain**: The domain of $\\mathcal{M}_{\\Phi'}$ consists of equivalence classes of terms in $\\Phi'$, where two terms $t_1$ and $t_2$ are equivalent if $\\Phi' \\vdash t_1 = t_2$.\n\n2. **Interpret Symbols**:\n   - Each constant symbol $c$ is interpreted as its equivalence class in $\\mathcal{M}_{\\Phi'}$.\n   - Each function symbol $f$ is interpreted as a function on these equivalence classes as defined by $\\Phi'$.\n   - Each relation symbol $R$ is interpreted according to the formulas in $\\Phi'$ that specify its behavior.\n\n3. **Satisfaction**: By Henkin's construction, $\\mathcal{M}_{\\Phi'} \\models \\Phi'$, ensuring that $\\mathcal{M}_{\\Phi'} \\models \\Phi$, as $\\Phi \\subset \\Phi'$.\n\nThus, $\\mathcal{M}_{\\Phi'}$ is a model of $\\Phi$, completing the proof for the countable case.\n\n---\n\n## Proof for the General Case (Arbitrary Cardinality)\n\nFor languages $L$ of arbitrary cardinality, we modify the previous approach to handle uncountably many formulas and witness requirements.\n\n### Step 1: Construct a Henkin-Complete Extension $\\Phi'$ Using Zorn's Lemma\n\n1. **Partial Extensions and Consistency**: Consider the collection $\\mathcal{T}$ of all consistent extensions of $\\Phi$ that are closed under logical consequence. We partially order $\\mathcal{T}$ by set inclusion.\n\n2. **Apply Zorn's Lemma**: Since every chain of consistent extensions has an upper bound (the union of the chain), Zorn's Lemma ensures that $\\mathcal{T}$ has a maximal element, denoted $\\Phi'$, which is consistent and closed under logical consequence.\n\n3. **Henkin-Completeness of $\\Phi'$**:\n   - Since $\\Phi'$ is maximal, for each formula $\\psi$ in $L$, either $\\psi \\in \\Phi'$ or $\\neg \\psi \\in \\Phi'$, establishing **negation-completeness**.\n   - For each existential formula $\\exists x \\, \\psi(x)$, add a witness constant $c_{\\exists x \\psi(x)}$ and ensure that $\\exists x \\, \\psi(x) \\rightarrow \\psi(c_{\\exists x \\psi(x)}) \\in \\Phi'$. This property holds because we can extend consistently with witnesses at each step.\n\nThus, $\\Phi'$ is Henkin-complete.\n\n### Step 2: Construct the Term Model $\\mathcal{M}_{\\Phi'}$\n\nAs in the countable case, we define a term model $\\mathcal{M}_{\\Phi'}$ based on $\\Phi'$:\n\n1. **Domain**: The domain consists of equivalence classes of terms under the relation $t_1 \\sim t_2 \\iff \\Phi' \\vdash t_1 = t_2$.\n\n2. **Interpretation**:\n   - Constants, functions, and relations are interpreted naturally according to $\\Phi'$, making $\\mathcal{M}_{\\Phi'}$ a model of $\\Phi'$.\n\n3. **Satisfaction**: By construction, $\\mathcal{M}_{\\Phi'} \\models \\Phi'$, and since $\\Phi \\subset \\Phi'$, $\\mathcal{M}_{\\Phi'} \\models \\Phi$.\n\nThus, $\\mathcal{M}_{\\Phi'}$ serves as a model for $\\Phi$, concluding the proof for arbitrary cardinality.\n\n","slug":"Henkin‘s Theorem","published":1,"updated":"2024-11-13T05:39:05.660Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5rz0013m8nx9qrm1x4x","content":"<h1 id=\"henkins-theorem\">Henkin's Theorem</h1>\r\n<p>For a consistent theory <span class=\"math inline\">\\(\\Phi\\)</span> in\r\nfirst-order logic, there exists a model <span class=\"math inline\">\\(\\mathcal{M}\\)</span> such that <span class=\"math inline\">\\(\\mathcal{M}\\)</span> satisfies all the sentences\r\nin <span class=\"math inline\">\\(\\Phi\\)</span>, i.e., <span class=\"math inline\">\\(\\mathcal{M} \\models \\Phi\\)</span>.</p>\r\n<p>This is equivalent to saying that if <span class=\"math inline\">\\(\\Phi\\)</span> is consistent, then <span class=\"math inline\">\\(\\Phi\\)</span> has a model. The theorem asserts\r\nthat <strong>consistency</strong> and <strong>satisfiability</strong>\r\nare equivalent for first-order theories.</p>\r\n<h2 id=\"key-concepts-in-the-proof\">Key Concepts in the Proof:</h2>\r\n<ol type=\"1\">\r\n<li><p><strong>Negation-Complete Theory</strong>: A theory <span class=\"math inline\">\\(\\Phi\\)</span> is\r\n<strong>negation-complete</strong> if for every formula <span class=\"math inline\">\\(\\psi\\)</span>, either <span class=\"math inline\">\\(\\psi\\)</span> or <span class=\"math inline\">\\(\\neg\r\n\\psi\\)</span> is a theorem of <span class=\"math inline\">\\(\\Phi\\)</span>.\r\nThis property ensures that the theory makes a definitive decision about\r\nthe truth value of every formula.</p></li>\r\n<li><p><strong>Witness Property</strong>: A theory <span class=\"math inline\">\\(\\Phi\\)</span> has the <strong>witness\r\nproperty</strong> if for every existential formula <span class=\"math inline\">\\(\\exists x \\, \\psi(x)\\)</span>, there is a constant\r\n<span class=\"math inline\">\\(c\\)</span> such that <span class=\"math inline\">\\(\\Phi\\)</span> proves <span class=\"math inline\">\\(\\exists x \\, \\psi(x) \\rightarrow \\psi(c)\\)</span>.\r\nThis ensures that existential claims are satisfied by specific, named\r\nelements in the model.</p></li>\r\n</ol>\r\n<p>These concepts are essential for the construction of a model that\r\nsatisfies the theory. The proof of Henkin's theorem proceeds by\r\nextending the theory <span class=\"math inline\">\\(\\Phi\\)</span> to make\r\nit <strong>Henkin-complete</strong>: consistent, negation-complete, and\r\nwith the witness property.</p>\r\n<h2 id=\"proof-for-the-countable-case\">Proof for the Countable Case</h2>\r\n<p>For a countable language <span class=\"math inline\">\\(L\\)</span>\r\n(where both the set of symbols and the set of sentences are countable),\r\nwe proceed by constructing a <strong>Henkin-complete extension</strong>\r\nof <span class=\"math inline\">\\(\\Phi\\)</span>, and then we use this\r\nextension to build a <strong>term model</strong>.</p>\r\n<h3 id=\"step-1-extend-phi-to-a-henkin-complete-theory-phi\">Step 1:\r\nExtend <span class=\"math inline\">\\(\\Phi\\)</span> to a Henkin-Complete\r\nTheory <span class=\"math inline\">\\(\\Phi&#39;\\)</span></h3>\r\n<ol type=\"1\">\r\n<li><p><strong>Enumerate All Formulas</strong>: Since <span class=\"math inline\">\\(L\\)</span> is countable, the set of all possible\r\nsentences in <span class=\"math inline\">\\(L\\)</span> is also countable.\r\nWe list these sentences as <span class=\"math inline\">\\(\\psi_1, \\psi_2,\r\n\\psi_3, \\ldots\\)</span>.</p></li>\r\n<li><p><strong>Add Witness Constants</strong>: For each existential\r\nformula <span class=\"math inline\">\\(\\exists x \\, \\psi(x)\\)</span> in\r\n<span class=\"math inline\">\\(L\\)</span>, introduce a new constant symbol\r\n<span class=\"math inline\">\\(c_{\\exists x \\psi(x)}\\)</span>, which will\r\nact as a \"witness\" for <span class=\"math inline\">\\(\\exists x \\,\r\n\\psi(x)\\)</span> in our theory. Ensure these new constants do not\r\nalready exist in <span class=\"math inline\">\\(L\\)</span>.</p></li>\r\n<li><p><strong>Construct the Extension <span class=\"math inline\">\\(\\Phi&#39;\\)</span></strong>:</p>\r\n<ul>\r\n<li>Begin with <span class=\"math inline\">\\(\\Phi_0 = \\Phi\\)</span>.</li>\r\n<li>For each <span class=\"math inline\">\\(\\psi_n\\)</span> in our\r\nenumeration, construct <span class=\"math inline\">\\(\\Phi_{n+1}\\)</span>\r\nfrom <span class=\"math inline\">\\(\\Phi_n\\)</span> as follows:\r\n<ul>\r\n<li>If <span class=\"math inline\">\\(\\Phi_n \\cup \\{ \\psi_n \\}\\)</span> is\r\nconsistent, set <span class=\"math inline\">\\(\\Phi_{n+1} = \\Phi_n \\cup \\{\r\n\\psi_n \\}\\)</span>.</li>\r\n<li>If <span class=\"math inline\">\\(\\Phi_n \\cup \\{ \\neg \\psi_n\r\n\\}\\)</span> is consistent, set <span class=\"math inline\">\\(\\Phi_{n+1} =\r\n\\Phi_n \\cup \\{ \\neg \\psi_n \\}\\)</span>.</li>\r\n</ul></li>\r\n<li>This process yields an extended theory <span class=\"math inline\">\\(\\Phi&#39; = \\bigcup_{n=0}^\\infty\r\n\\Phi_n\\)</span>.</li>\r\n</ul>\r\n<p>By construction, <span class=\"math inline\">\\(\\Phi&#39;\\)</span> is\r\nconsistent, negation-complete, and has the witness property for\r\nexistential formulas. Thus, <span class=\"math inline\">\\(\\Phi&#39;\\)</span> is\r\n<strong>Henkin-complete</strong>.</p></li>\r\n</ol>\r\n<h3 id=\"step-2-construct-the-term-model-mathcalm_phi\">Step 2: Construct\r\nthe Term Model <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\\)</span></h3>\r\n<ol type=\"1\">\r\n<li><p><strong>Define the Domain</strong>: The domain of <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\\)</span> consists of\r\nequivalence classes of terms in <span class=\"math inline\">\\(\\Phi&#39;\\)</span>, where two terms <span class=\"math inline\">\\(t_1\\)</span> and <span class=\"math inline\">\\(t_2\\)</span> are equivalent if <span class=\"math inline\">\\(\\Phi&#39; \\vdash t_1 = t_2\\)</span>.</p></li>\r\n<li><p><strong>Interpret Symbols</strong>:</p>\r\n<ul>\r\n<li>Each constant symbol <span class=\"math inline\">\\(c\\)</span> is\r\ninterpreted as its equivalence class in <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\\)</span>.</li>\r\n<li>Each function symbol <span class=\"math inline\">\\(f\\)</span> is\r\ninterpreted as a function on these equivalence classes as defined by\r\n<span class=\"math inline\">\\(\\Phi&#39;\\)</span>.</li>\r\n<li>Each relation symbol <span class=\"math inline\">\\(R\\)</span> is\r\ninterpreted according to the formulas in <span class=\"math inline\">\\(\\Phi&#39;\\)</span> that specify its behavior.</li>\r\n</ul></li>\r\n<li><p><strong>Satisfaction</strong>: By Henkin's construction, <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;} \\models\r\n\\Phi&#39;\\)</span>, ensuring that <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;} \\models \\Phi\\)</span>, as\r\n<span class=\"math inline\">\\(\\Phi \\subset \\Phi&#39;\\)</span>.</p></li>\r\n</ol>\r\n<p>Thus, <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\\)</span> is\r\na model of <span class=\"math inline\">\\(\\Phi\\)</span>, completing the\r\nproof for the countable case.</p>\r\n<hr>\r\n<h2 id=\"proof-for-the-general-case-arbitrary-cardinality\">Proof for the\r\nGeneral Case (Arbitrary Cardinality)</h2>\r\n<p>For languages <span class=\"math inline\">\\(L\\)</span> of arbitrary\r\ncardinality, we modify the previous approach to handle uncountably many\r\nformulas and witness requirements.</p>\r\n<h3 id=\"step-1-construct-a-henkin-complete-extension-phi-using-zorns-lemma\">Step\r\n1: Construct a Henkin-Complete Extension <span class=\"math inline\">\\(\\Phi&#39;\\)</span> Using Zorn's Lemma</h3>\r\n<ol type=\"1\">\r\n<li><p><strong>Partial Extensions and Consistency</strong>: Consider the\r\ncollection <span class=\"math inline\">\\(\\mathcal{T}\\)</span> of all\r\nconsistent extensions of <span class=\"math inline\">\\(\\Phi\\)</span> that\r\nare closed under logical consequence. We partially order <span class=\"math inline\">\\(\\mathcal{T}\\)</span> by set inclusion.</p></li>\r\n<li><p><strong>Apply Zorn's Lemma</strong>: Since every chain of\r\nconsistent extensions has an upper bound (the union of the chain),\r\nZorn's Lemma ensures that <span class=\"math inline\">\\(\\mathcal{T}\\)</span> has a maximal element,\r\ndenoted <span class=\"math inline\">\\(\\Phi&#39;\\)</span>, which is\r\nconsistent and closed under logical consequence.</p></li>\r\n<li><p><strong>Henkin-Completeness of <span class=\"math inline\">\\(\\Phi&#39;\\)</span></strong>:</p>\r\n<ul>\r\n<li>Since <span class=\"math inline\">\\(\\Phi&#39;\\)</span> is maximal, for\r\neach formula <span class=\"math inline\">\\(\\psi\\)</span> in <span class=\"math inline\">\\(L\\)</span>, either <span class=\"math inline\">\\(\\psi \\in \\Phi&#39;\\)</span> or <span class=\"math inline\">\\(\\neg \\psi \\in \\Phi&#39;\\)</span>, establishing\r\n<strong>negation-completeness</strong>.</li>\r\n<li>For each existential formula <span class=\"math inline\">\\(\\exists x\r\n\\, \\psi(x)\\)</span>, add a witness constant <span class=\"math inline\">\\(c_{\\exists x \\psi(x)}\\)</span> and ensure that\r\n<span class=\"math inline\">\\(\\exists x \\, \\psi(x) \\rightarrow\r\n\\psi(c_{\\exists x \\psi(x)}) \\in \\Phi&#39;\\)</span>. This property holds\r\nbecause we can extend consistently with witnesses at each step.</li>\r\n</ul></li>\r\n</ol>\r\n<p>Thus, <span class=\"math inline\">\\(\\Phi&#39;\\)</span> is\r\nHenkin-complete.</p>\r\n<h3 id=\"step-2-construct-the-term-model-mathcalm_phi-1\">Step 2:\r\nConstruct the Term Model <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\\)</span></h3>\r\n<p>As in the countable case, we define a term model <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\\)</span> based on <span class=\"math inline\">\\(\\Phi&#39;\\)</span>:</p>\r\n<ol type=\"1\">\r\n<li><p><strong>Domain</strong>: The domain consists of equivalence\r\nclasses of terms under the relation <span class=\"math inline\">\\(t_1 \\sim\r\nt_2 \\iff \\Phi&#39; \\vdash t_1 = t_2\\)</span>.</p></li>\r\n<li><p><strong>Interpretation</strong>:</p>\r\n<ul>\r\n<li>Constants, functions, and relations are interpreted naturally\r\naccording to <span class=\"math inline\">\\(\\Phi&#39;\\)</span>, making\r\n<span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\\)</span> a model of\r\n<span class=\"math inline\">\\(\\Phi&#39;\\)</span>.</li>\r\n</ul></li>\r\n<li><p><strong>Satisfaction</strong>: By construction, <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;} \\models\r\n\\Phi&#39;\\)</span>, and since <span class=\"math inline\">\\(\\Phi \\subset\r\n\\Phi&#39;\\)</span>, <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\r\n\\models \\Phi\\)</span>.</p></li>\r\n</ol>\r\n<p>Thus, <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\\)</span>\r\nserves as a model for <span class=\"math inline\">\\(\\Phi\\)</span>,\r\nconcluding the proof for arbitrary cardinality.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"henkins-theorem\">Henkin's Theorem</h1>\r\n<p>For a consistent theory <span class=\"math inline\">\\(\\Phi\\)</span> in\r\nfirst-order logic, there exists a model <span class=\"math inline\">\\(\\mathcal{M}\\)</span> such that <span class=\"math inline\">\\(\\mathcal{M}\\)</span> satisfies all the sentences\r\nin <span class=\"math inline\">\\(\\Phi\\)</span>, i.e., <span class=\"math inline\">\\(\\mathcal{M} \\models \\Phi\\)</span>.</p>\r\n<p>This is equivalent to saying that if <span class=\"math inline\">\\(\\Phi\\)</span> is consistent, then <span class=\"math inline\">\\(\\Phi\\)</span> has a model. The theorem asserts\r\nthat <strong>consistency</strong> and <strong>satisfiability</strong>\r\nare equivalent for first-order theories.</p>\r\n<h2 id=\"key-concepts-in-the-proof\">Key Concepts in the Proof:</h2>\r\n<ol type=\"1\">\r\n<li><p><strong>Negation-Complete Theory</strong>: A theory <span class=\"math inline\">\\(\\Phi\\)</span> is\r\n<strong>negation-complete</strong> if for every formula <span class=\"math inline\">\\(\\psi\\)</span>, either <span class=\"math inline\">\\(\\psi\\)</span> or <span class=\"math inline\">\\(\\neg\r\n\\psi\\)</span> is a theorem of <span class=\"math inline\">\\(\\Phi\\)</span>.\r\nThis property ensures that the theory makes a definitive decision about\r\nthe truth value of every formula.</p></li>\r\n<li><p><strong>Witness Property</strong>: A theory <span class=\"math inline\">\\(\\Phi\\)</span> has the <strong>witness\r\nproperty</strong> if for every existential formula <span class=\"math inline\">\\(\\exists x \\, \\psi(x)\\)</span>, there is a constant\r\n<span class=\"math inline\">\\(c\\)</span> such that <span class=\"math inline\">\\(\\Phi\\)</span> proves <span class=\"math inline\">\\(\\exists x \\, \\psi(x) \\rightarrow \\psi(c)\\)</span>.\r\nThis ensures that existential claims are satisfied by specific, named\r\nelements in the model.</p></li>\r\n</ol>\r\n<p>These concepts are essential for the construction of a model that\r\nsatisfies the theory. The proof of Henkin's theorem proceeds by\r\nextending the theory <span class=\"math inline\">\\(\\Phi\\)</span> to make\r\nit <strong>Henkin-complete</strong>: consistent, negation-complete, and\r\nwith the witness property.</p>\r\n<h2 id=\"proof-for-the-countable-case\">Proof for the Countable Case</h2>\r\n<p>For a countable language <span class=\"math inline\">\\(L\\)</span>\r\n(where both the set of symbols and the set of sentences are countable),\r\nwe proceed by constructing a <strong>Henkin-complete extension</strong>\r\nof <span class=\"math inline\">\\(\\Phi\\)</span>, and then we use this\r\nextension to build a <strong>term model</strong>.</p>\r\n<h3 id=\"step-1-extend-phi-to-a-henkin-complete-theory-phi\">Step 1:\r\nExtend <span class=\"math inline\">\\(\\Phi\\)</span> to a Henkin-Complete\r\nTheory <span class=\"math inline\">\\(\\Phi&#39;\\)</span></h3>\r\n<ol type=\"1\">\r\n<li><p><strong>Enumerate All Formulas</strong>: Since <span class=\"math inline\">\\(L\\)</span> is countable, the set of all possible\r\nsentences in <span class=\"math inline\">\\(L\\)</span> is also countable.\r\nWe list these sentences as <span class=\"math inline\">\\(\\psi_1, \\psi_2,\r\n\\psi_3, \\ldots\\)</span>.</p></li>\r\n<li><p><strong>Add Witness Constants</strong>: For each existential\r\nformula <span class=\"math inline\">\\(\\exists x \\, \\psi(x)\\)</span> in\r\n<span class=\"math inline\">\\(L\\)</span>, introduce a new constant symbol\r\n<span class=\"math inline\">\\(c_{\\exists x \\psi(x)}\\)</span>, which will\r\nact as a \"witness\" for <span class=\"math inline\">\\(\\exists x \\,\r\n\\psi(x)\\)</span> in our theory. Ensure these new constants do not\r\nalready exist in <span class=\"math inline\">\\(L\\)</span>.</p></li>\r\n<li><p><strong>Construct the Extension <span class=\"math inline\">\\(\\Phi&#39;\\)</span></strong>:</p>\r\n<ul>\r\n<li>Begin with <span class=\"math inline\">\\(\\Phi_0 = \\Phi\\)</span>.</li>\r\n<li>For each <span class=\"math inline\">\\(\\psi_n\\)</span> in our\r\nenumeration, construct <span class=\"math inline\">\\(\\Phi_{n+1}\\)</span>\r\nfrom <span class=\"math inline\">\\(\\Phi_n\\)</span> as follows:\r\n<ul>\r\n<li>If <span class=\"math inline\">\\(\\Phi_n \\cup \\{ \\psi_n \\}\\)</span> is\r\nconsistent, set <span class=\"math inline\">\\(\\Phi_{n+1} = \\Phi_n \\cup \\{\r\n\\psi_n \\}\\)</span>.</li>\r\n<li>If <span class=\"math inline\">\\(\\Phi_n \\cup \\{ \\neg \\psi_n\r\n\\}\\)</span> is consistent, set <span class=\"math inline\">\\(\\Phi_{n+1} =\r\n\\Phi_n \\cup \\{ \\neg \\psi_n \\}\\)</span>.</li>\r\n</ul></li>\r\n<li>This process yields an extended theory <span class=\"math inline\">\\(\\Phi&#39; = \\bigcup_{n=0}^\\infty\r\n\\Phi_n\\)</span>.</li>\r\n</ul>\r\n<p>By construction, <span class=\"math inline\">\\(\\Phi&#39;\\)</span> is\r\nconsistent, negation-complete, and has the witness property for\r\nexistential formulas. Thus, <span class=\"math inline\">\\(\\Phi&#39;\\)</span> is\r\n<strong>Henkin-complete</strong>.</p></li>\r\n</ol>\r\n<h3 id=\"step-2-construct-the-term-model-mathcalm_phi\">Step 2: Construct\r\nthe Term Model <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\\)</span></h3>\r\n<ol type=\"1\">\r\n<li><p><strong>Define the Domain</strong>: The domain of <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\\)</span> consists of\r\nequivalence classes of terms in <span class=\"math inline\">\\(\\Phi&#39;\\)</span>, where two terms <span class=\"math inline\">\\(t_1\\)</span> and <span class=\"math inline\">\\(t_2\\)</span> are equivalent if <span class=\"math inline\">\\(\\Phi&#39; \\vdash t_1 = t_2\\)</span>.</p></li>\r\n<li><p><strong>Interpret Symbols</strong>:</p>\r\n<ul>\r\n<li>Each constant symbol <span class=\"math inline\">\\(c\\)</span> is\r\ninterpreted as its equivalence class in <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\\)</span>.</li>\r\n<li>Each function symbol <span class=\"math inline\">\\(f\\)</span> is\r\ninterpreted as a function on these equivalence classes as defined by\r\n<span class=\"math inline\">\\(\\Phi&#39;\\)</span>.</li>\r\n<li>Each relation symbol <span class=\"math inline\">\\(R\\)</span> is\r\ninterpreted according to the formulas in <span class=\"math inline\">\\(\\Phi&#39;\\)</span> that specify its behavior.</li>\r\n</ul></li>\r\n<li><p><strong>Satisfaction</strong>: By Henkin's construction, <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;} \\models\r\n\\Phi&#39;\\)</span>, ensuring that <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;} \\models \\Phi\\)</span>, as\r\n<span class=\"math inline\">\\(\\Phi \\subset \\Phi&#39;\\)</span>.</p></li>\r\n</ol>\r\n<p>Thus, <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\\)</span> is\r\na model of <span class=\"math inline\">\\(\\Phi\\)</span>, completing the\r\nproof for the countable case.</p>\r\n<hr>\r\n<h2 id=\"proof-for-the-general-case-arbitrary-cardinality\">Proof for the\r\nGeneral Case (Arbitrary Cardinality)</h2>\r\n<p>For languages <span class=\"math inline\">\\(L\\)</span> of arbitrary\r\ncardinality, we modify the previous approach to handle uncountably many\r\nformulas and witness requirements.</p>\r\n<h3 id=\"step-1-construct-a-henkin-complete-extension-phi-using-zorns-lemma\">Step\r\n1: Construct a Henkin-Complete Extension <span class=\"math inline\">\\(\\Phi&#39;\\)</span> Using Zorn's Lemma</h3>\r\n<ol type=\"1\">\r\n<li><p><strong>Partial Extensions and Consistency</strong>: Consider the\r\ncollection <span class=\"math inline\">\\(\\mathcal{T}\\)</span> of all\r\nconsistent extensions of <span class=\"math inline\">\\(\\Phi\\)</span> that\r\nare closed under logical consequence. We partially order <span class=\"math inline\">\\(\\mathcal{T}\\)</span> by set inclusion.</p></li>\r\n<li><p><strong>Apply Zorn's Lemma</strong>: Since every chain of\r\nconsistent extensions has an upper bound (the union of the chain),\r\nZorn's Lemma ensures that <span class=\"math inline\">\\(\\mathcal{T}\\)</span> has a maximal element,\r\ndenoted <span class=\"math inline\">\\(\\Phi&#39;\\)</span>, which is\r\nconsistent and closed under logical consequence.</p></li>\r\n<li><p><strong>Henkin-Completeness of <span class=\"math inline\">\\(\\Phi&#39;\\)</span></strong>:</p>\r\n<ul>\r\n<li>Since <span class=\"math inline\">\\(\\Phi&#39;\\)</span> is maximal, for\r\neach formula <span class=\"math inline\">\\(\\psi\\)</span> in <span class=\"math inline\">\\(L\\)</span>, either <span class=\"math inline\">\\(\\psi \\in \\Phi&#39;\\)</span> or <span class=\"math inline\">\\(\\neg \\psi \\in \\Phi&#39;\\)</span>, establishing\r\n<strong>negation-completeness</strong>.</li>\r\n<li>For each existential formula <span class=\"math inline\">\\(\\exists x\r\n\\, \\psi(x)\\)</span>, add a witness constant <span class=\"math inline\">\\(c_{\\exists x \\psi(x)}\\)</span> and ensure that\r\n<span class=\"math inline\">\\(\\exists x \\, \\psi(x) \\rightarrow\r\n\\psi(c_{\\exists x \\psi(x)}) \\in \\Phi&#39;\\)</span>. This property holds\r\nbecause we can extend consistently with witnesses at each step.</li>\r\n</ul></li>\r\n</ol>\r\n<p>Thus, <span class=\"math inline\">\\(\\Phi&#39;\\)</span> is\r\nHenkin-complete.</p>\r\n<h3 id=\"step-2-construct-the-term-model-mathcalm_phi-1\">Step 2:\r\nConstruct the Term Model <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\\)</span></h3>\r\n<p>As in the countable case, we define a term model <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\\)</span> based on <span class=\"math inline\">\\(\\Phi&#39;\\)</span>:</p>\r\n<ol type=\"1\">\r\n<li><p><strong>Domain</strong>: The domain consists of equivalence\r\nclasses of terms under the relation <span class=\"math inline\">\\(t_1 \\sim\r\nt_2 \\iff \\Phi&#39; \\vdash t_1 = t_2\\)</span>.</p></li>\r\n<li><p><strong>Interpretation</strong>:</p>\r\n<ul>\r\n<li>Constants, functions, and relations are interpreted naturally\r\naccording to <span class=\"math inline\">\\(\\Phi&#39;\\)</span>, making\r\n<span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\\)</span> a model of\r\n<span class=\"math inline\">\\(\\Phi&#39;\\)</span>.</li>\r\n</ul></li>\r\n<li><p><strong>Satisfaction</strong>: By construction, <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;} \\models\r\n\\Phi&#39;\\)</span>, and since <span class=\"math inline\">\\(\\Phi \\subset\r\n\\Phi&#39;\\)</span>, <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\r\n\\models \\Phi\\)</span>.</p></li>\r\n</ol>\r\n<p>Thus, <span class=\"math inline\">\\(\\mathcal{M}_{\\Phi&#39;}\\)</span>\r\nserves as a model for <span class=\"math inline\">\\(\\Phi\\)</span>,\r\nconcluding the proof for arbitrary cardinality.</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Wed Nov 13 2024 13:39:05 GMT+0800 (中国标准时间)","title":"Henkin's Theorem","path":"2024/11/13/Henkin‘s Theorem/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2024-11-13T05:13:30.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2024-11-13T05:13:30.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Notes > Mathematical Logic","tags":["Notes","Mathematical Logic"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Hilbert's 13th Problem","date":"2023-03-23T02:35:56.000Z","mathjax":true,"_content":"\n## Theorem 1\nFor any integer $n\\geq 2$ there are continuous real functions $\\psi^{p,q}(x)$ on the closed unit interval $E^{1} = [0,1]$ such that each continuous real function $f(x_{1},\\cdots,x_{n})$ on the $n$-dimensional unit cube $E^{n}$ is representable as \n\n$$f(x_{1},\\cdots,x_{n}) = \\sum_{q=1}^{2n+1} \\chi^{q} \\left[\\sum_{p=1}^{n} \\psi^{p,q}(x_{p})\\right]$$\n\nwhere $\\chi^{q}(y)$ are continuous real function.\n\n\n<br>\n\n**Step 1**: *Construction of the functions $\\psi^{pq}$*.\n\n\nConsider the closed intervals\n\n$$\\begin{aligned}\n& A_{k,i}^{q} = \\left[\\frac{1}{(9n)^{k}}\\left(i - 1 - \\frac{q}{3n}\\right), \\frac{1}{(9n)^{k}}\\left(i - \\frac{1}{3n} - \\frac{q}{3n}\\right)\\right],\\\\\n&\\qquad \\qquad \\qquad \\qquad 1\\leq i \\leq (9n)^{k} +1, 1\\leq q \\leq 2n +1, k= 1,2,\\cdots\n\\end{aligned}$$\n\nwith lengths $\\frac{1}{9n}^{k} ( 1 - \\frac{1}{3n})$ and \nAccordingly, for fixed $k$ and $q$ by passing $i$ to $i+1$ using a shift to the right over a distance $1/(9n)^{k}$. Accordingly, for fixed $k$ and $q$ the cubes\n\n$$S_{k,i_{1},\\cdots,i_{n}}^{q} = \\prod_{p=1}^{n} A_{k,i_{p}}^{q}$$ \n\nwith edges of lengths $\\frac{1}{(9n)^{k}}$ cover the unit cube $E^{n}$ to within the separating slits of widths $\\frac{1}{3n(9n)^{k}}$. It's easy to verify the following\n\n## Lemma 1\nThe system of all cubes $S_{k,i_{1},\\cdots,i_{n}}^{q}$ with constant $k$ and variable $q$ and $i_{1},\\cdots,i_{n}$ covers the unit cube $E^{n}$ so that each point belonging to $E^{n}$ is covered by at least $n+1$ times. $\\label{lem 1}$\n\n<br>\n\nUsing induction on $k$ we can prove the following \n\n## Lemma 2\nThere exist constants $\\lambda^{pq}_{k,i}$ and $\\epsilon_{k}$ such that \n\n1. $\\lambda^{pq}_{k,i} \\leq \\lambda^{pq}_{k,i+1} \\leq \\lambda^{pq}_{k,i} + 1/2^{k}$;\n\n2. $\\lambda^{pq}_{k,i} \\leq \\lambda^{pq}_{k+1,i^{\\prime}} \\leq \\lambda^{pq}_{k,i} + \\epsilon_{k+1} - \\epsilon_{k}$ if the closed intevals $A_{k,i}^{q}$ and $A_{k+1,i^{\\prime}}^{q}$ do not intersect;\n\n3. the closed interval $\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}} = \\left[\\sum_{p}\\lambda^{pq}_{k,i_{p}}, \\sum_{p}\\lambda^{pq}_{k,i_{p}} + n \\epsilon_{k}\\right]$ are pairwise disjoint for fixed $k$ and $q$.\n\nIt's easy to note that 1. and 3. imply\n\n4. $\\epsilon \\leq 1/2^{k}$.\n\n\n## Lemma 3\n\nFor fixed $p$ and $q$ the condition\n\n5. $\\lambda^{pq}_{k,i} \\leq \\psi^{pq}(x) \\leq \\lambda^{pq}_{k,i} + \\epsilon_{k}$ uniquely determine a continuous function $\\psi^{pq}$ on $E^{1}$.\n\nFrom 5. and 3. it follows that \n\n6. $\\sum_{p} \\psi^{pq} (x_{p}) \\in \\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}$ for $(x_{1}, \\cdots, x_{n}) \\in S_{k,i_{1},\\cdots,i_{n}}^{q}$.\n\n<br> \n\n**Step 2**: *Construction of the functions $\\chi^{q}$*.\n\nLet $\\chi_{0}^{q} \\equiv 0$, while for $r >0$, $\\chi_{r}^{q}$ will be defined by induction on $r$ simultaneously with the natural number $k_{r}$.\n\nDenote as below\n\n$$\\begin{aligned}f_{r}(x_{1},\\cdots,x_{n}) = & \\sum_{q=1}^{2n+1} \\chi_{r}^{q}\\left[\\sum_{p} \\psi^{pq}(x_{p})\\right]\\\\\nM_{r}= & \\sup_{E^{n}} \\left|f -f_{r}\\right|\\end{aligned}$$\n\n**Inductive step:** Assuming $\\chi_{r-1}^{q}$ and $k_{r-1}$ have already been determined. \n\n**Passing to step $r$:**\n\nSince the diameter of the cubes $S_{k,i_{1},\\cdots,i_{n}}^{q}$ tend to zero as $k \\to \\infty$, we can choose $k_{r}$ so large that the oscillation of the difference $f - f_{r-1}$ does not exceed $M_{r}/(2n+2)$ on any $S_{k_{r},i_{1},\\cdots,i_{n}}^{q}$. \n\n\nLet $\\xi_{k,i}^{q}$ be arbitrary points belonging to the corresponding closed intervals $A_{k,i}^{q}$. For the closed interval $\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}$ we put \n\n$$\\begin{aligned}\\chi_{r}^{q}(y) = & \\chi_{r-1}^{q}(y) + \\frac{1}{n+1} \\left[f(\\xi_{k,i_{1}}^{q}, \\cdots, \\xi_{k,i_{n}}^{q}) - f_{r}(\\xi_{k,i_{1}}^{q}, \\cdots, \\xi_{k,i_{n}}^{q})\\right]\\\\\n& \\left|\\chi_{r}^{q} (y) - \\chi_{r-1}(y)\\right| \\leq \\frac{1}{n+1} M_{r-1}\\end{aligned}$$\n\nOutside the closed intervals $\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}$ the function $\\chi_{r}^{q}$ is defined arbitrarily, with the preservation of the inequality above and continuity. \n\n\n$$\\begin{aligned}f(x_{1},\\cdots,x_{n}) - f_{r}(x_{1},\\cdots,x_{n}) = f(x_{1},\\cdots,x_{n}) - f_{r-1}(x_{1},\\cdots,x_{n})\\\\ \n- \\sum_{q=1}^{2n+1} \\left\\{\\chi_{r}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] - \\chi_{r-1}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right]\\right\\}\\end{aligned}$$\n\nWe represent the sum in above equation in the form $\\sum^{\\prime} + \\sum^{\\prime\\prime}$, where the sum $\\sum^{\\prime}$ extends over certain $n+1$ values of $q$ for which the point $(x_{1},\\cdots,x_{n})$ is contained in one of the cubes $S_{k_{r},i_{1},\\cdots,i_{n}}^{q}$ (by Lemma 1$\\ref{lem 1}$, such cubes exist) and the sum $\\sum^{\\prime\\prime}$ extends over the remaining $n$ values of $q$. Hence, for each term in $\\sum^{\\prime}$ we have\n\n$$\\begin{aligned}\n&\\chi_{r}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] - \\chi_{r-1}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] \\\\\n= \\frac{1}{n+1} &\\left[f(\\xi_{k,i_{1}}^{q}, \\cdots, \\xi_{k,i_{n}}^{q}) - f_{r-1}(\\xi_{k,i_{1}}^{q}, \\cdots, \\xi_{k,i_{n}}^{q})\\right] \\\\\n= \\frac{1}{n+1} & \\left[f(x_{1},\\cdots,x_{n}) - f_{r-1}(x_{1},\\cdots,x_{n})\\right] + \\frac{\\omega^{q}}{n+1}\n\\end{aligned}$$\n\nwhere \n\n$$|\\omega^{q}| \\leq \\frac{1}{2n+2}M_{r}$$\n\nwhich implies\n\n$$\\begin{aligned}|f - f_{r}| = \\left|\\frac{1}{n+1} \\sum^{\\prime}\\omega^{q} + \\sum^{\\prime \\prime} (\\chi_{r}^{q} - \\chi_{r-1}^{q})\\right| \\leq \\\\\n\\frac{1}{2n+2} M_{r-1} + \\frac{n}{n+1} M_{r-1} = \\frac{2n +1}{2n +2} M_{r-1} \\end{aligned}$$\n\nSince inequality holds at any point $(x_{1},\\cdots,x_{n}) \\in E^{n}$, it follows that the absolute values of the differences $\\chi^{q} - \\chi_{r}^{q}$ do not exceed the corresponding terms of the absolutely convergent series \n\n$$\\sum_{r} \\frac{1}{n+1} M_{r-1}$$\n\nTherefore the functions $\\chi_{r}^{q}$ converges uniformly to continuous limit functions $\\chi^{q}$ for $r\\to \\infty$.\n\n<br>\n\n# Reference:\n\n\n[1] Kolmogorov, A. N. (1957). On the representation of continuous functions of several variables by superposition of continuous functions of one variable and addition. (in Russian) In Doklady Akademii Nauk (Vol. 114, No. 5, pp. 953-956). Russian Academy of Sciences.\n\n[2] Arnold, V. I. (1957). On functions of three variables. (in Russian) Collected Works: Representations of Functions, Celestial Mechanics and KAM Theory, 1957–1965, 5-8.\n\n\n","source":"_posts/Hilbert13.md","raw":"---\ntitle: Hilbert's 13th Problem\ndate: 2023-03-23 10:35:56\ntags:\n    - [Notes]\n    - [Hilbert's 23 Problems]\ncategories:\n    - [Notes]\n    - [History of Mathematics, Hilbert's 23 Problems]\nmathjax: true\n---\n\n## Theorem 1\nFor any integer $n\\geq 2$ there are continuous real functions $\\psi^{p,q}(x)$ on the closed unit interval $E^{1} = [0,1]$ such that each continuous real function $f(x_{1},\\cdots,x_{n})$ on the $n$-dimensional unit cube $E^{n}$ is representable as \n\n$$f(x_{1},\\cdots,x_{n}) = \\sum_{q=1}^{2n+1} \\chi^{q} \\left[\\sum_{p=1}^{n} \\psi^{p,q}(x_{p})\\right]$$\n\nwhere $\\chi^{q}(y)$ are continuous real function.\n\n\n<br>\n\n**Step 1**: *Construction of the functions $\\psi^{pq}$*.\n\n\nConsider the closed intervals\n\n$$\\begin{aligned}\n& A_{k,i}^{q} = \\left[\\frac{1}{(9n)^{k}}\\left(i - 1 - \\frac{q}{3n}\\right), \\frac{1}{(9n)^{k}}\\left(i - \\frac{1}{3n} - \\frac{q}{3n}\\right)\\right],\\\\\n&\\qquad \\qquad \\qquad \\qquad 1\\leq i \\leq (9n)^{k} +1, 1\\leq q \\leq 2n +1, k= 1,2,\\cdots\n\\end{aligned}$$\n\nwith lengths $\\frac{1}{9n}^{k} ( 1 - \\frac{1}{3n})$ and \nAccordingly, for fixed $k$ and $q$ by passing $i$ to $i+1$ using a shift to the right over a distance $1/(9n)^{k}$. Accordingly, for fixed $k$ and $q$ the cubes\n\n$$S_{k,i_{1},\\cdots,i_{n}}^{q} = \\prod_{p=1}^{n} A_{k,i_{p}}^{q}$$ \n\nwith edges of lengths $\\frac{1}{(9n)^{k}}$ cover the unit cube $E^{n}$ to within the separating slits of widths $\\frac{1}{3n(9n)^{k}}$. It's easy to verify the following\n\n## Lemma 1\nThe system of all cubes $S_{k,i_{1},\\cdots,i_{n}}^{q}$ with constant $k$ and variable $q$ and $i_{1},\\cdots,i_{n}$ covers the unit cube $E^{n}$ so that each point belonging to $E^{n}$ is covered by at least $n+1$ times. $\\label{lem 1}$\n\n<br>\n\nUsing induction on $k$ we can prove the following \n\n## Lemma 2\nThere exist constants $\\lambda^{pq}_{k,i}$ and $\\epsilon_{k}$ such that \n\n1. $\\lambda^{pq}_{k,i} \\leq \\lambda^{pq}_{k,i+1} \\leq \\lambda^{pq}_{k,i} + 1/2^{k}$;\n\n2. $\\lambda^{pq}_{k,i} \\leq \\lambda^{pq}_{k+1,i^{\\prime}} \\leq \\lambda^{pq}_{k,i} + \\epsilon_{k+1} - \\epsilon_{k}$ if the closed intevals $A_{k,i}^{q}$ and $A_{k+1,i^{\\prime}}^{q}$ do not intersect;\n\n3. the closed interval $\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}} = \\left[\\sum_{p}\\lambda^{pq}_{k,i_{p}}, \\sum_{p}\\lambda^{pq}_{k,i_{p}} + n \\epsilon_{k}\\right]$ are pairwise disjoint for fixed $k$ and $q$.\n\nIt's easy to note that 1. and 3. imply\n\n4. $\\epsilon \\leq 1/2^{k}$.\n\n\n## Lemma 3\n\nFor fixed $p$ and $q$ the condition\n\n5. $\\lambda^{pq}_{k,i} \\leq \\psi^{pq}(x) \\leq \\lambda^{pq}_{k,i} + \\epsilon_{k}$ uniquely determine a continuous function $\\psi^{pq}$ on $E^{1}$.\n\nFrom 5. and 3. it follows that \n\n6. $\\sum_{p} \\psi^{pq} (x_{p}) \\in \\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}$ for $(x_{1}, \\cdots, x_{n}) \\in S_{k,i_{1},\\cdots,i_{n}}^{q}$.\n\n<br> \n\n**Step 2**: *Construction of the functions $\\chi^{q}$*.\n\nLet $\\chi_{0}^{q} \\equiv 0$, while for $r >0$, $\\chi_{r}^{q}$ will be defined by induction on $r$ simultaneously with the natural number $k_{r}$.\n\nDenote as below\n\n$$\\begin{aligned}f_{r}(x_{1},\\cdots,x_{n}) = & \\sum_{q=1}^{2n+1} \\chi_{r}^{q}\\left[\\sum_{p} \\psi^{pq}(x_{p})\\right]\\\\\nM_{r}= & \\sup_{E^{n}} \\left|f -f_{r}\\right|\\end{aligned}$$\n\n**Inductive step:** Assuming $\\chi_{r-1}^{q}$ and $k_{r-1}$ have already been determined. \n\n**Passing to step $r$:**\n\nSince the diameter of the cubes $S_{k,i_{1},\\cdots,i_{n}}^{q}$ tend to zero as $k \\to \\infty$, we can choose $k_{r}$ so large that the oscillation of the difference $f - f_{r-1}$ does not exceed $M_{r}/(2n+2)$ on any $S_{k_{r},i_{1},\\cdots,i_{n}}^{q}$. \n\n\nLet $\\xi_{k,i}^{q}$ be arbitrary points belonging to the corresponding closed intervals $A_{k,i}^{q}$. For the closed interval $\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}$ we put \n\n$$\\begin{aligned}\\chi_{r}^{q}(y) = & \\chi_{r-1}^{q}(y) + \\frac{1}{n+1} \\left[f(\\xi_{k,i_{1}}^{q}, \\cdots, \\xi_{k,i_{n}}^{q}) - f_{r}(\\xi_{k,i_{1}}^{q}, \\cdots, \\xi_{k,i_{n}}^{q})\\right]\\\\\n& \\left|\\chi_{r}^{q} (y) - \\chi_{r-1}(y)\\right| \\leq \\frac{1}{n+1} M_{r-1}\\end{aligned}$$\n\nOutside the closed intervals $\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}$ the function $\\chi_{r}^{q}$ is defined arbitrarily, with the preservation of the inequality above and continuity. \n\n\n$$\\begin{aligned}f(x_{1},\\cdots,x_{n}) - f_{r}(x_{1},\\cdots,x_{n}) = f(x_{1},\\cdots,x_{n}) - f_{r-1}(x_{1},\\cdots,x_{n})\\\\ \n- \\sum_{q=1}^{2n+1} \\left\\{\\chi_{r}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] - \\chi_{r-1}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right]\\right\\}\\end{aligned}$$\n\nWe represent the sum in above equation in the form $\\sum^{\\prime} + \\sum^{\\prime\\prime}$, where the sum $\\sum^{\\prime}$ extends over certain $n+1$ values of $q$ for which the point $(x_{1},\\cdots,x_{n})$ is contained in one of the cubes $S_{k_{r},i_{1},\\cdots,i_{n}}^{q}$ (by Lemma 1$\\ref{lem 1}$, such cubes exist) and the sum $\\sum^{\\prime\\prime}$ extends over the remaining $n$ values of $q$. Hence, for each term in $\\sum^{\\prime}$ we have\n\n$$\\begin{aligned}\n&\\chi_{r}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] - \\chi_{r-1}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] \\\\\n= \\frac{1}{n+1} &\\left[f(\\xi_{k,i_{1}}^{q}, \\cdots, \\xi_{k,i_{n}}^{q}) - f_{r-1}(\\xi_{k,i_{1}}^{q}, \\cdots, \\xi_{k,i_{n}}^{q})\\right] \\\\\n= \\frac{1}{n+1} & \\left[f(x_{1},\\cdots,x_{n}) - f_{r-1}(x_{1},\\cdots,x_{n})\\right] + \\frac{\\omega^{q}}{n+1}\n\\end{aligned}$$\n\nwhere \n\n$$|\\omega^{q}| \\leq \\frac{1}{2n+2}M_{r}$$\n\nwhich implies\n\n$$\\begin{aligned}|f - f_{r}| = \\left|\\frac{1}{n+1} \\sum^{\\prime}\\omega^{q} + \\sum^{\\prime \\prime} (\\chi_{r}^{q} - \\chi_{r-1}^{q})\\right| \\leq \\\\\n\\frac{1}{2n+2} M_{r-1} + \\frac{n}{n+1} M_{r-1} = \\frac{2n +1}{2n +2} M_{r-1} \\end{aligned}$$\n\nSince inequality holds at any point $(x_{1},\\cdots,x_{n}) \\in E^{n}$, it follows that the absolute values of the differences $\\chi^{q} - \\chi_{r}^{q}$ do not exceed the corresponding terms of the absolutely convergent series \n\n$$\\sum_{r} \\frac{1}{n+1} M_{r-1}$$\n\nTherefore the functions $\\chi_{r}^{q}$ converges uniformly to continuous limit functions $\\chi^{q}$ for $r\\to \\infty$.\n\n<br>\n\n# Reference:\n\n\n[1] Kolmogorov, A. N. (1957). On the representation of continuous functions of several variables by superposition of continuous functions of one variable and addition. (in Russian) In Doklady Akademii Nauk (Vol. 114, No. 5, pp. 953-956). Russian Academy of Sciences.\n\n[2] Arnold, V. I. (1957). On functions of three variables. (in Russian) Collected Works: Representations of Functions, Celestial Mechanics and KAM Theory, 1957–1965, 5-8.\n\n\n","slug":"Hilbert13","published":1,"updated":"2024-02-25T15:11:07.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5s00018m8nxfxxpdxlw","content":"<h2 id=\"theorem-1\">Theorem 1</h2>\r\n<p>For any integer <span class=\"math inline\">\\(n\\geq 2\\)</span> there\r\nare continuous real functions <span class=\"math inline\">\\(\\psi^{p,q}(x)\\)</span> on the closed unit interval\r\n<span class=\"math inline\">\\(E^{1} = [0,1]\\)</span> such that each\r\ncontinuous real function <span class=\"math inline\">\\(f(x_{1},\\cdots,x_{n})\\)</span> on the <span class=\"math inline\">\\(n\\)</span>-dimensional unit cube <span class=\"math inline\">\\(E^{n}\\)</span> is representable as</p>\r\n<p><span class=\"math display\">\\[f(x_{1},\\cdots,x_{n}) =\r\n\\sum_{q=1}^{2n+1} \\chi^{q} \\left[\\sum_{p=1}^{n}\r\n\\psi^{p,q}(x_{p})\\right]\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(\\chi^{q}(y)\\)</span> are continuous\r\nreal function.</p>\r\n<p><br></p>\r\n<p><strong>Step 1</strong>: <em>Construction of the functions <span class=\"math inline\">\\(\\psi^{pq}\\)</span></em>.</p>\r\n<p>Consider the closed intervals</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n&amp; A_{k,i}^{q} = \\left[\\frac{1}{(9n)^{k}}\\left(i - 1 -\r\n\\frac{q}{3n}\\right), \\frac{1}{(9n)^{k}}\\left(i - \\frac{1}{3n} -\r\n\\frac{q}{3n}\\right)\\right],\\\\\r\n&amp;\\qquad \\qquad \\qquad \\qquad 1\\leq i \\leq (9n)^{k} +1, 1\\leq q \\leq\r\n2n +1, k= 1,2,\\cdots\r\n\\end{aligned}\\]</span></p>\r\n<p>with lengths <span class=\"math inline\">\\(\\frac{1}{9n}^{k} ( 1 -\r\n\\frac{1}{3n})\\)</span> and Accordingly, for fixed <span class=\"math inline\">\\(k\\)</span> and <span class=\"math inline\">\\(q\\)</span> by passing <span class=\"math inline\">\\(i\\)</span> to <span class=\"math inline\">\\(i+1\\)</span> using a shift to the right over a\r\ndistance <span class=\"math inline\">\\(1/(9n)^{k}\\)</span>. Accordingly,\r\nfor fixed <span class=\"math inline\">\\(k\\)</span> and <span class=\"math inline\">\\(q\\)</span> the cubes</p>\r\n<p><span class=\"math display\">\\[S_{k,i_{1},\\cdots,i_{n}}^{q} =\r\n\\prod_{p=1}^{n} A_{k,i_{p}}^{q}\\]</span></p>\r\n<p>with edges of lengths <span class=\"math inline\">\\(\\frac{1}{(9n)^{k}}\\)</span> cover the unit cube\r\n<span class=\"math inline\">\\(E^{n}\\)</span> to within the separating\r\nslits of widths <span class=\"math inline\">\\(\\frac{1}{3n(9n)^{k}}\\)</span>. It's easy to verify\r\nthe following</p>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>The system of all cubes <span class=\"math inline\">\\(S_{k,i_{1},\\cdots,i_{n}}^{q}\\)</span> with\r\nconstant <span class=\"math inline\">\\(k\\)</span> and variable <span class=\"math inline\">\\(q\\)</span> and <span class=\"math inline\">\\(i_{1},\\cdots,i_{n}\\)</span> covers the unit cube\r\n<span class=\"math inline\">\\(E^{n}\\)</span> so that each point belonging\r\nto <span class=\"math inline\">\\(E^{n}\\)</span> is covered by at least\r\n<span class=\"math inline\">\\(n+1\\)</span> times. <span class=\"math inline\">\\(\\label{lem 1}\\)</span></p>\r\n<p><br></p>\r\n<p>Using induction on <span class=\"math inline\">\\(k\\)</span> we can\r\nprove the following</p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>There exist constants <span class=\"math inline\">\\(\\lambda^{pq}_{k,i}\\)</span> and <span class=\"math inline\">\\(\\epsilon_{k}\\)</span> such that</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(\\lambda^{pq}_{k,i} \\leq\r\n\\lambda^{pq}_{k,i+1} \\leq \\lambda^{pq}_{k,i} +\r\n1/2^{k}\\)</span>;</p></li>\r\n<li><p><span class=\"math inline\">\\(\\lambda^{pq}_{k,i} \\leq\r\n\\lambda^{pq}_{k+1,i^{\\prime}} \\leq \\lambda^{pq}_{k,i} + \\epsilon_{k+1} -\r\n\\epsilon_{k}\\)</span> if the closed intevals <span class=\"math inline\">\\(A_{k,i}^{q}\\)</span> and <span class=\"math inline\">\\(A_{k+1,i^{\\prime}}^{q}\\)</span> do not\r\nintersect;</p></li>\r\n<li><p>the closed interval <span class=\"math inline\">\\(\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}} =\r\n\\left[\\sum_{p}\\lambda^{pq}_{k,i_{p}}, \\sum_{p}\\lambda^{pq}_{k,i_{p}} + n\r\n\\epsilon_{k}\\right]\\)</span> are pairwise disjoint for fixed <span class=\"math inline\">\\(k\\)</span> and <span class=\"math inline\">\\(q\\)</span>.</p></li>\r\n</ol>\r\n<p>It's easy to note that 1. and 3. imply</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li><span class=\"math inline\">\\(\\epsilon \\leq 1/2^{k}\\)</span>.</li>\r\n</ol>\r\n<h2 id=\"lemma-3\">Lemma 3</h2>\r\n<p>For fixed <span class=\"math inline\">\\(p\\)</span> and <span class=\"math inline\">\\(q\\)</span> the condition</p>\r\n<ol start=\"5\" type=\"1\">\r\n<li><span class=\"math inline\">\\(\\lambda^{pq}_{k,i} \\leq \\psi^{pq}(x)\r\n\\leq \\lambda^{pq}_{k,i} + \\epsilon_{k}\\)</span> uniquely determine a\r\ncontinuous function <span class=\"math inline\">\\(\\psi^{pq}\\)</span> on\r\n<span class=\"math inline\">\\(E^{1}\\)</span>.</li>\r\n</ol>\r\n<p>From 5. and 3. it follows that</p>\r\n<ol start=\"6\" type=\"1\">\r\n<li><span class=\"math inline\">\\(\\sum_{p} \\psi^{pq} (x_{p}) \\in\r\n\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}\\)</span> for <span class=\"math inline\">\\((x_{1}, \\cdots, x_{n}) \\in\r\nS_{k,i_{1},\\cdots,i_{n}}^{q}\\)</span>.</li>\r\n</ol>\r\n<p><br></p>\r\n<p><strong>Step 2</strong>: <em>Construction of the functions <span class=\"math inline\">\\(\\chi^{q}\\)</span></em>.</p>\r\n<p>Let <span class=\"math inline\">\\(\\chi_{0}^{q} \\equiv 0\\)</span>, while\r\nfor <span class=\"math inline\">\\(r &gt;0\\)</span>, <span class=\"math inline\">\\(\\chi_{r}^{q}\\)</span> will be defined by induction\r\non <span class=\"math inline\">\\(r\\)</span> simultaneously with the\r\nnatural number <span class=\"math inline\">\\(k_{r}\\)</span>.</p>\r\n<p>Denote as below</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}f_{r}(x_{1},\\cdots,x_{n})\r\n= &amp; \\sum_{q=1}^{2n+1} \\chi_{r}^{q}\\left[\\sum_{p}\r\n\\psi^{pq}(x_{p})\\right]\\\\\r\nM_{r}= &amp; \\sup_{E^{n}} \\left|f\r\n-f_{r}\\right|\\end{aligned}\\]</span></p>\r\n<p><strong>Inductive step:</strong> Assuming <span class=\"math inline\">\\(\\chi_{r-1}^{q}\\)</span> and <span class=\"math inline\">\\(k_{r-1}\\)</span> have already been determined.</p>\r\n<p><strong>Passing to step <span class=\"math inline\">\\(r\\)</span>:</strong></p>\r\n<p>Since the diameter of the cubes <span class=\"math inline\">\\(S_{k,i_{1},\\cdots,i_{n}}^{q}\\)</span> tend to zero\r\nas <span class=\"math inline\">\\(k \\to \\infty\\)</span>, we can choose\r\n<span class=\"math inline\">\\(k_{r}\\)</span> so large that the oscillation\r\nof the difference <span class=\"math inline\">\\(f - f_{r-1}\\)</span> does\r\nnot exceed <span class=\"math inline\">\\(M_{r}/(2n+2)\\)</span> on any\r\n<span class=\"math inline\">\\(S_{k_{r},i_{1},\\cdots,i_{n}}^{q}\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(\\xi_{k,i}^{q}\\)</span> be arbitrary\r\npoints belonging to the corresponding closed intervals <span class=\"math inline\">\\(A_{k,i}^{q}\\)</span>. For the closed interval\r\n<span class=\"math inline\">\\(\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}\\)</span>\r\nwe put</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\\chi_{r}^{q}(y) = &amp;\r\n\\chi_{r-1}^{q}(y) + \\frac{1}{n+1} \\left[f(\\xi_{k,i_{1}}^{q}, \\cdots,\r\n\\xi_{k,i_{n}}^{q}) - f_{r}(\\xi_{k,i_{1}}^{q}, \\cdots,\r\n\\xi_{k,i_{n}}^{q})\\right]\\\\\r\n&amp; \\left|\\chi_{r}^{q} (y) - \\chi_{r-1}(y)\\right| \\leq \\frac{1}{n+1}\r\nM_{r-1}\\end{aligned}\\]</span></p>\r\n<p>Outside the closed intervals <span class=\"math inline\">\\(\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}\\)</span> the\r\nfunction <span class=\"math inline\">\\(\\chi_{r}^{q}\\)</span> is defined\r\narbitrarily, with the preservation of the inequality above and\r\ncontinuity.</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}f(x_{1},\\cdots,x_{n}) -\r\nf_{r}(x_{1},\\cdots,x_{n}) = f(x_{1},\\cdots,x_{n}) -\r\nf_{r-1}(x_{1},\\cdots,x_{n})\\\\\r\n- \\sum_{q=1}^{2n+1}\r\n\\left\\{\\chi_{r}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] -\r\n\\chi_{r-1}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right]\\right\\}\\end{aligned}\\]</span></p>\r\n<p>We represent the sum in above equation in the form <span class=\"math inline\">\\(\\sum^{\\prime} + \\sum^{\\prime\\prime}\\)</span>,\r\nwhere the sum <span class=\"math inline\">\\(\\sum^{\\prime}\\)</span> extends\r\nover certain <span class=\"math inline\">\\(n+1\\)</span> values of <span class=\"math inline\">\\(q\\)</span> for which the point <span class=\"math inline\">\\((x_{1},\\cdots,x_{n})\\)</span> is contained in one\r\nof the cubes <span class=\"math inline\">\\(S_{k_{r},i_{1},\\cdots,i_{n}}^{q}\\)</span> (by\r\nLemma 1<span class=\"math inline\">\\(\\ref{lem 1}\\)</span>, such cubes\r\nexist) and the sum <span class=\"math inline\">\\(\\sum^{\\prime\\prime}\\)</span> extends over the\r\nremaining <span class=\"math inline\">\\(n\\)</span> values of <span class=\"math inline\">\\(q\\)</span>. Hence, for each term in <span class=\"math inline\">\\(\\sum^{\\prime}\\)</span> we have</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n&amp;\\chi_{r}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] -\r\n\\chi_{r-1}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] \\\\\r\n= \\frac{1}{n+1} &amp;\\left[f(\\xi_{k,i_{1}}^{q}, \\cdots,\r\n\\xi_{k,i_{n}}^{q}) - f_{r-1}(\\xi_{k,i_{1}}^{q}, \\cdots,\r\n\\xi_{k,i_{n}}^{q})\\right] \\\\\r\n= \\frac{1}{n+1} &amp; \\left[f(x_{1},\\cdots,x_{n}) -\r\nf_{r-1}(x_{1},\\cdots,x_{n})\\right] + \\frac{\\omega^{q}}{n+1}\r\n\\end{aligned}\\]</span></p>\r\n<p>where</p>\r\n<p><span class=\"math display\">\\[|\\omega^{q}| \\leq\r\n\\frac{1}{2n+2}M_{r}\\]</span></p>\r\n<p>which implies</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}|f - f_{r}| =\r\n\\left|\\frac{1}{n+1} \\sum^{\\prime}\\omega^{q} + \\sum^{\\prime \\prime}\r\n(\\chi_{r}^{q} - \\chi_{r-1}^{q})\\right| \\leq \\\\\r\n\\frac{1}{2n+2} M_{r-1} + \\frac{n}{n+1} M_{r-1} = \\frac{2n +1}{2n +2}\r\nM_{r-1} \\end{aligned}\\]</span></p>\r\n<p>Since inequality holds at any point <span class=\"math inline\">\\((x_{1},\\cdots,x_{n}) \\in E^{n}\\)</span>, it\r\nfollows that the absolute values of the differences <span class=\"math inline\">\\(\\chi^{q} - \\chi_{r}^{q}\\)</span> do not exceed the\r\ncorresponding terms of the absolutely convergent series</p>\r\n<p><span class=\"math display\">\\[\\sum_{r} \\frac{1}{n+1}\r\nM_{r-1}\\]</span></p>\r\n<p>Therefore the functions <span class=\"math inline\">\\(\\chi_{r}^{q}\\)</span> converges uniformly to\r\ncontinuous limit functions <span class=\"math inline\">\\(\\chi^{q}\\)</span>\r\nfor <span class=\"math inline\">\\(r\\to \\infty\\)</span>.</p>\r\n<p><br></p>\r\n<h1 id=\"reference\">Reference:</h1>\r\n<p>[1] Kolmogorov, A. N. (1957). On the representation of continuous\r\nfunctions of several variables by superposition of continuous functions\r\nof one variable and addition. (in Russian) In Doklady Akademii Nauk\r\n(Vol. 114, No. 5, pp. 953-956). Russian Academy of Sciences.</p>\r\n<p>[2] Arnold, V. I. (1957). On functions of three variables. (in\r\nRussian) Collected Works: Representations of Functions, Celestial\r\nMechanics and KAM Theory, 1957–1965, 5-8.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"theorem-1\">Theorem 1</h2>\r\n<p>For any integer <span class=\"math inline\">\\(n\\geq 2\\)</span> there\r\nare continuous real functions <span class=\"math inline\">\\(\\psi^{p,q}(x)\\)</span> on the closed unit interval\r\n<span class=\"math inline\">\\(E^{1} = [0,1]\\)</span> such that each\r\ncontinuous real function <span class=\"math inline\">\\(f(x_{1},\\cdots,x_{n})\\)</span> on the <span class=\"math inline\">\\(n\\)</span>-dimensional unit cube <span class=\"math inline\">\\(E^{n}\\)</span> is representable as</p>\r\n<p><span class=\"math display\">\\[f(x_{1},\\cdots,x_{n}) =\r\n\\sum_{q=1}^{2n+1} \\chi^{q} \\left[\\sum_{p=1}^{n}\r\n\\psi^{p,q}(x_{p})\\right]\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(\\chi^{q}(y)\\)</span> are continuous\r\nreal function.</p>\r\n<p><br></p>\r\n<p><strong>Step 1</strong>: <em>Construction of the functions <span class=\"math inline\">\\(\\psi^{pq}\\)</span></em>.</p>\r\n<p>Consider the closed intervals</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n&amp; A_{k,i}^{q} = \\left[\\frac{1}{(9n)^{k}}\\left(i - 1 -\r\n\\frac{q}{3n}\\right), \\frac{1}{(9n)^{k}}\\left(i - \\frac{1}{3n} -\r\n\\frac{q}{3n}\\right)\\right],\\\\\r\n&amp;\\qquad \\qquad \\qquad \\qquad 1\\leq i \\leq (9n)^{k} +1, 1\\leq q \\leq\r\n2n +1, k= 1,2,\\cdots\r\n\\end{aligned}\\]</span></p>\r\n<p>with lengths <span class=\"math inline\">\\(\\frac{1}{9n}^{k} ( 1 -\r\n\\frac{1}{3n})\\)</span> and Accordingly, for fixed <span class=\"math inline\">\\(k\\)</span> and <span class=\"math inline\">\\(q\\)</span> by passing <span class=\"math inline\">\\(i\\)</span> to <span class=\"math inline\">\\(i+1\\)</span> using a shift to the right over a\r\ndistance <span class=\"math inline\">\\(1/(9n)^{k}\\)</span>. Accordingly,\r\nfor fixed <span class=\"math inline\">\\(k\\)</span> and <span class=\"math inline\">\\(q\\)</span> the cubes</p>\r\n<p><span class=\"math display\">\\[S_{k,i_{1},\\cdots,i_{n}}^{q} =\r\n\\prod_{p=1}^{n} A_{k,i_{p}}^{q}\\]</span></p>\r\n<p>with edges of lengths <span class=\"math inline\">\\(\\frac{1}{(9n)^{k}}\\)</span> cover the unit cube\r\n<span class=\"math inline\">\\(E^{n}\\)</span> to within the separating\r\nslits of widths <span class=\"math inline\">\\(\\frac{1}{3n(9n)^{k}}\\)</span>. It's easy to verify\r\nthe following</p>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>The system of all cubes <span class=\"math inline\">\\(S_{k,i_{1},\\cdots,i_{n}}^{q}\\)</span> with\r\nconstant <span class=\"math inline\">\\(k\\)</span> and variable <span class=\"math inline\">\\(q\\)</span> and <span class=\"math inline\">\\(i_{1},\\cdots,i_{n}\\)</span> covers the unit cube\r\n<span class=\"math inline\">\\(E^{n}\\)</span> so that each point belonging\r\nto <span class=\"math inline\">\\(E^{n}\\)</span> is covered by at least\r\n<span class=\"math inline\">\\(n+1\\)</span> times. <span class=\"math inline\">\\(\\label{lem 1}\\)</span></p>\r\n<p><br></p>\r\n<p>Using induction on <span class=\"math inline\">\\(k\\)</span> we can\r\nprove the following</p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>There exist constants <span class=\"math inline\">\\(\\lambda^{pq}_{k,i}\\)</span> and <span class=\"math inline\">\\(\\epsilon_{k}\\)</span> such that</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(\\lambda^{pq}_{k,i} \\leq\r\n\\lambda^{pq}_{k,i+1} \\leq \\lambda^{pq}_{k,i} +\r\n1/2^{k}\\)</span>;</p></li>\r\n<li><p><span class=\"math inline\">\\(\\lambda^{pq}_{k,i} \\leq\r\n\\lambda^{pq}_{k+1,i^{\\prime}} \\leq \\lambda^{pq}_{k,i} + \\epsilon_{k+1} -\r\n\\epsilon_{k}\\)</span> if the closed intevals <span class=\"math inline\">\\(A_{k,i}^{q}\\)</span> and <span class=\"math inline\">\\(A_{k+1,i^{\\prime}}^{q}\\)</span> do not\r\nintersect;</p></li>\r\n<li><p>the closed interval <span class=\"math inline\">\\(\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}} =\r\n\\left[\\sum_{p}\\lambda^{pq}_{k,i_{p}}, \\sum_{p}\\lambda^{pq}_{k,i_{p}} + n\r\n\\epsilon_{k}\\right]\\)</span> are pairwise disjoint for fixed <span class=\"math inline\">\\(k\\)</span> and <span class=\"math inline\">\\(q\\)</span>.</p></li>\r\n</ol>\r\n<p>It's easy to note that 1. and 3. imply</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li><span class=\"math inline\">\\(\\epsilon \\leq 1/2^{k}\\)</span>.</li>\r\n</ol>\r\n<h2 id=\"lemma-3\">Lemma 3</h2>\r\n<p>For fixed <span class=\"math inline\">\\(p\\)</span> and <span class=\"math inline\">\\(q\\)</span> the condition</p>\r\n<ol start=\"5\" type=\"1\">\r\n<li><span class=\"math inline\">\\(\\lambda^{pq}_{k,i} \\leq \\psi^{pq}(x)\r\n\\leq \\lambda^{pq}_{k,i} + \\epsilon_{k}\\)</span> uniquely determine a\r\ncontinuous function <span class=\"math inline\">\\(\\psi^{pq}\\)</span> on\r\n<span class=\"math inline\">\\(E^{1}\\)</span>.</li>\r\n</ol>\r\n<p>From 5. and 3. it follows that</p>\r\n<ol start=\"6\" type=\"1\">\r\n<li><span class=\"math inline\">\\(\\sum_{p} \\psi^{pq} (x_{p}) \\in\r\n\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}\\)</span> for <span class=\"math inline\">\\((x_{1}, \\cdots, x_{n}) \\in\r\nS_{k,i_{1},\\cdots,i_{n}}^{q}\\)</span>.</li>\r\n</ol>\r\n<p><br></p>\r\n<p><strong>Step 2</strong>: <em>Construction of the functions <span class=\"math inline\">\\(\\chi^{q}\\)</span></em>.</p>\r\n<p>Let <span class=\"math inline\">\\(\\chi_{0}^{q} \\equiv 0\\)</span>, while\r\nfor <span class=\"math inline\">\\(r &gt;0\\)</span>, <span class=\"math inline\">\\(\\chi_{r}^{q}\\)</span> will be defined by induction\r\non <span class=\"math inline\">\\(r\\)</span> simultaneously with the\r\nnatural number <span class=\"math inline\">\\(k_{r}\\)</span>.</p>\r\n<p>Denote as below</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}f_{r}(x_{1},\\cdots,x_{n})\r\n= &amp; \\sum_{q=1}^{2n+1} \\chi_{r}^{q}\\left[\\sum_{p}\r\n\\psi^{pq}(x_{p})\\right]\\\\\r\nM_{r}= &amp; \\sup_{E^{n}} \\left|f\r\n-f_{r}\\right|\\end{aligned}\\]</span></p>\r\n<p><strong>Inductive step:</strong> Assuming <span class=\"math inline\">\\(\\chi_{r-1}^{q}\\)</span> and <span class=\"math inline\">\\(k_{r-1}\\)</span> have already been determined.</p>\r\n<p><strong>Passing to step <span class=\"math inline\">\\(r\\)</span>:</strong></p>\r\n<p>Since the diameter of the cubes <span class=\"math inline\">\\(S_{k,i_{1},\\cdots,i_{n}}^{q}\\)</span> tend to zero\r\nas <span class=\"math inline\">\\(k \\to \\infty\\)</span>, we can choose\r\n<span class=\"math inline\">\\(k_{r}\\)</span> so large that the oscillation\r\nof the difference <span class=\"math inline\">\\(f - f_{r-1}\\)</span> does\r\nnot exceed <span class=\"math inline\">\\(M_{r}/(2n+2)\\)</span> on any\r\n<span class=\"math inline\">\\(S_{k_{r},i_{1},\\cdots,i_{n}}^{q}\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(\\xi_{k,i}^{q}\\)</span> be arbitrary\r\npoints belonging to the corresponding closed intervals <span class=\"math inline\">\\(A_{k,i}^{q}\\)</span>. For the closed interval\r\n<span class=\"math inline\">\\(\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}\\)</span>\r\nwe put</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\\chi_{r}^{q}(y) = &amp;\r\n\\chi_{r-1}^{q}(y) + \\frac{1}{n+1} \\left[f(\\xi_{k,i_{1}}^{q}, \\cdots,\r\n\\xi_{k,i_{n}}^{q}) - f_{r}(\\xi_{k,i_{1}}^{q}, \\cdots,\r\n\\xi_{k,i_{n}}^{q})\\right]\\\\\r\n&amp; \\left|\\chi_{r}^{q} (y) - \\chi_{r-1}(y)\\right| \\leq \\frac{1}{n+1}\r\nM_{r-1}\\end{aligned}\\]</span></p>\r\n<p>Outside the closed intervals <span class=\"math inline\">\\(\\Delta^{q}_{k,i_{1}, \\cdots, i_{n}}\\)</span> the\r\nfunction <span class=\"math inline\">\\(\\chi_{r}^{q}\\)</span> is defined\r\narbitrarily, with the preservation of the inequality above and\r\ncontinuity.</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}f(x_{1},\\cdots,x_{n}) -\r\nf_{r}(x_{1},\\cdots,x_{n}) = f(x_{1},\\cdots,x_{n}) -\r\nf_{r-1}(x_{1},\\cdots,x_{n})\\\\\r\n- \\sum_{q=1}^{2n+1}\r\n\\left\\{\\chi_{r}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] -\r\n\\chi_{r-1}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right]\\right\\}\\end{aligned}\\]</span></p>\r\n<p>We represent the sum in above equation in the form <span class=\"math inline\">\\(\\sum^{\\prime} + \\sum^{\\prime\\prime}\\)</span>,\r\nwhere the sum <span class=\"math inline\">\\(\\sum^{\\prime}\\)</span> extends\r\nover certain <span class=\"math inline\">\\(n+1\\)</span> values of <span class=\"math inline\">\\(q\\)</span> for which the point <span class=\"math inline\">\\((x_{1},\\cdots,x_{n})\\)</span> is contained in one\r\nof the cubes <span class=\"math inline\">\\(S_{k_{r},i_{1},\\cdots,i_{n}}^{q}\\)</span> (by\r\nLemma 1<span class=\"math inline\">\\(\\ref{lem 1}\\)</span>, such cubes\r\nexist) and the sum <span class=\"math inline\">\\(\\sum^{\\prime\\prime}\\)</span> extends over the\r\nremaining <span class=\"math inline\">\\(n\\)</span> values of <span class=\"math inline\">\\(q\\)</span>. Hence, for each term in <span class=\"math inline\">\\(\\sum^{\\prime}\\)</span> we have</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n&amp;\\chi_{r}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] -\r\n\\chi_{r-1}^{q}\\left[\\sum_{p}\\psi^{pq}(x_{p})\\right] \\\\\r\n= \\frac{1}{n+1} &amp;\\left[f(\\xi_{k,i_{1}}^{q}, \\cdots,\r\n\\xi_{k,i_{n}}^{q}) - f_{r-1}(\\xi_{k,i_{1}}^{q}, \\cdots,\r\n\\xi_{k,i_{n}}^{q})\\right] \\\\\r\n= \\frac{1}{n+1} &amp; \\left[f(x_{1},\\cdots,x_{n}) -\r\nf_{r-1}(x_{1},\\cdots,x_{n})\\right] + \\frac{\\omega^{q}}{n+1}\r\n\\end{aligned}\\]</span></p>\r\n<p>where</p>\r\n<p><span class=\"math display\">\\[|\\omega^{q}| \\leq\r\n\\frac{1}{2n+2}M_{r}\\]</span></p>\r\n<p>which implies</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}|f - f_{r}| =\r\n\\left|\\frac{1}{n+1} \\sum^{\\prime}\\omega^{q} + \\sum^{\\prime \\prime}\r\n(\\chi_{r}^{q} - \\chi_{r-1}^{q})\\right| \\leq \\\\\r\n\\frac{1}{2n+2} M_{r-1} + \\frac{n}{n+1} M_{r-1} = \\frac{2n +1}{2n +2}\r\nM_{r-1} \\end{aligned}\\]</span></p>\r\n<p>Since inequality holds at any point <span class=\"math inline\">\\((x_{1},\\cdots,x_{n}) \\in E^{n}\\)</span>, it\r\nfollows that the absolute values of the differences <span class=\"math inline\">\\(\\chi^{q} - \\chi_{r}^{q}\\)</span> do not exceed the\r\ncorresponding terms of the absolutely convergent series</p>\r\n<p><span class=\"math display\">\\[\\sum_{r} \\frac{1}{n+1}\r\nM_{r-1}\\]</span></p>\r\n<p>Therefore the functions <span class=\"math inline\">\\(\\chi_{r}^{q}\\)</span> converges uniformly to\r\ncontinuous limit functions <span class=\"math inline\">\\(\\chi^{q}\\)</span>\r\nfor <span class=\"math inline\">\\(r\\to \\infty\\)</span>.</p>\r\n<p><br></p>\r\n<h1 id=\"reference\">Reference:</h1>\r\n<p>[1] Kolmogorov, A. N. (1957). On the representation of continuous\r\nfunctions of several variables by superposition of continuous functions\r\nof one variable and addition. (in Russian) In Doklady Akademii Nauk\r\n(Vol. 114, No. 5, pp. 953-956). Russian Academy of Sciences.</p>\r\n<p>[2] Arnold, V. I. (1957). On functions of three variables. (in\r\nRussian) Collected Works: Representations of Functions, Celestial\r\nMechanics and KAM Theory, 1957–1965, 5-8.</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Feb 25 2024 23:11:07 GMT+0800 (中国标准时间)","title":"Hilbert's 13th Problem","path":"2023/03/23/Hilbert13/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-03-23T02:35:56.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-03-23T02:35:56.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Notes > History of Mathematics > Hilbert's 23 Problems","tags":["Notes","Hilbert's 23 Problems"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Hopf's Ergodic Theorem","date":"2024-01-17T05:48:02.000Z","mathjax":true,"_content":"\n# Hopf's Ergodic Theorem\n\nLet $y_1 = e^{i\\theta_1}$ and $y_2 = e^{i\\theta_2}$ be two points on $|z| = 1$. Then, the pair $(\\theta_1, \\theta_2)$ can be considered as a point of a torus $\\Theta: 0 \\leq \\theta_1, \\theta_2 < 2\\pi$.\n\nFor a measurable set $E$ on $\\Theta$, we define its measure $\\mu(E)$ by $\\mu(E) = \\int\\int d\\theta_1 d\\theta_2$, so that $\\mu(\\Theta) = 4\\pi^2$.\n\nIf $S_v$ is any substitution of a Fuchsian group $G$ and $T_v: \\Theta \\to S_v(\\Theta)$, then the totality of $\\{ T_v \\}$ constitute a group $S = G \\times G$.\n\n## Hopf's Ergodic Theorem (Theorem XI. 23.):\nIf $\\mu(\\Theta) < \\infty$, then there exists no measurable set $E$ on $\\Theta$ which is invariant by $S$, and $0 < \\mu(E) < 4\\pi^2$.\n\nHence, if $\\mu(E) > 0$, then $\\mu(E) = 4\\pi^2$.\n\n## Proof (Tsuji):\nSuppose that there exists a measurable set $E$ on $\\Theta$ which is invariant by $S$, and $\\mu(E) > 0$. We shall prove that $\\mu(E) = 4\\pi^{2}$.\n\nLet $f(\\theta_1, \\theta_2)$ be the characteristic function of $ E $ and put\n$$\nu(z, w) = \\frac{1}{4\\pi^2} \\iint_{\\Theta} f(\\theta_1, \\theta_2)\\frac{1- |z|^{2}}{|z - e^{i\\theta_1}|^2} \\frac{1- |w|^{2}}{|w - e^{i\\theta_2}|^2}d\\theta_1 d\\theta_2,\n$$\nwhere $\\Theta: |z| < 1, |w| < 1$.\n\nThen $u(z, w)$ is invariant by $S$ such that\n$$\nu(S(z), S(w)) = u(z, w), \\quad \\text{for } S \\in G. \\quad (2)\n$$\n\nWe denote the Stolz domain: $|\\arg(1 - ze^{-i\\theta})| < \\frac{\\pi}{4} $ by $ \\mathcal{E}(e^{i\\theta})$ and $\\mathcal{E}_+(\\theta)$ be its part contained in $|z - e^{i\\theta}| < \\delta$. Then by (Tsuji, Masatsugu. Potential theory in modern function theory. Maruzen, 1959.\nTheorem IV. 12)[3], for almost all $(\\theta_1, \\theta_2) $ on $ \\Theta $,\n$$\n\\lim u(z, w) = f(\\theta_1, \\theta_2) \\text{ uniformly, if } z \\to e^{i\\theta_1}, w \\to e^{i\\theta_2} \\text{ from the inside of } \\mathcal{E}_+(e^{i\\theta_1}), \\mathcal{E}_+(\\theta_2) \\text{ respectively}. \\quad (3)\n$$\n\n\nLet $E_{\\theta_1}$ be the section of $E$ by the line $\\theta = \\text{const.} = \\theta_1$ and $E_{\\theta_2}$ be that by the line $\\theta = \\text{const.} = \\theta_2$, then\n$$\n\\mu(E_{\\theta_1})\\mu(E_{\\theta_2}) > 0, \\quad (4)\n$$\nwhere $\\mu(\\cdot)$ denotes the linear measure.\n\nSince $\\mu(\\Theta) < \\infty$, $G$ is of divergence type (Tsuji, Masatsugu. Potential theory in modern function theory. Maruzen, 1959.\nTheorem XI. 10)[3], so that there exists no measurable set $e$ on $|z| = 1$ which is invariant by $G$ and $\\mu(e) < 2\\pi$. Hence, if $\\mu(E_{\\theta_1}) > 0$, then $\\mu(E_{\\theta_1}) = 2\\pi$.\n\n\nIf $\\mu(E_{\\theta_2}) = 0$ on a set $e$ of positive measure in $[0, 2\\pi)$, then since by the hypothesis on $E$, such a set $e$ is invariant by $G$, $\\mu(e) = 2\\pi$, so that $\\mu(E_{\\theta_2}) > 0$ almost everywhere in $[0, 2\\pi)$, hence $\\mu(E) = 4\\pi^2$, which is absurd.\n\nHence,\n$$\n\\mu(E_{\\theta_2}) > 0 \\text{ for almost all } \\theta_2 \\in [0, 2\\pi). \\quad (5)\n$$\n\nHence by Egoroff's theorem, there exists a closed subset $E_0$ of $E$ which satisfies the following conditions (i), (ii), (iii), where $\\delta > 0$ and $\\eta > 0$ are sufficiently small constants.\n\n(i) $E_0$ lies outside of the strip: $|\\theta_1 - \\theta_2| < \\eta \\mod 2\\pi$.\n(ii) Let $E_0^{\\prime}$ be the projection of $E_0$ on the $\\theta_1$-axis, then\n$$\n\\mu(E_0) > 2\\pi - \\delta \\quad \\text{and} \\quad \\mu(\\theta_1 \\notin [0, \\eta] \\cap E_0) > 0 \\text{ for any } \\theta_1 \\in [0, 2\\pi).\n$$\n(iii) $\\lim u(z, w) = 1$ uniformly on $ E_0 $, when $z \\to e^{i\\theta_1}, w \\to e^{i\\theta_2}$ from the inside of $\\mathcal{E}_+(\\theta_1), \\mathcal{E}_+(\\theta_2)$ respectively.\n\n\n(iv) When $z \\in E_0$ and $w \\in S_2\\mathcal{E}_+(\\theta_2)$, then\n$$\n1 - \\varepsilon < u(z, w) < 1 \\quad \\text{for sufficiently small } \\varepsilon > 0.\n$$\n\n(v) For any $y > 0$, let\n$$\nM_y = \\lim_{\\delta \\to 0} \\mu(E_0 \\cap \\{ \\theta_1 : \\mu(\\theta_1 \\notin [0, \\delta] \\cap E_0) > y \\}).\n$$\n\nWe shall prove that\n$$\nM_y = \\infty \\quad (y = 1, 2, \\ldots). \\quad (13)\n$$\n\nLet $K_j = S_j(K_0)$, then $K_j$ is obtained from $K_0$ by a rotation about $\\theta = 0$, so that the circle $|z| = \\rho_j$ intersects $K_j$ in an arc $J_j$ whose projection on $|z| = 1$ from $\\theta = 0$ is denoted by $\\mathcal{J}_j$ then $|\\mathcal{J}_j| = |\\mathcal{J}_0|$, so that\n$$\n\\text{const.}(1 - \\rho_j)^{|\\mathcal{J}_j|} \\leq |\\mathcal{J}_j| \\leq \\text{const.}(1 - \\rho_j), \\quad \\text{(14)}\n$$\nwhere $\\text{const.} > 0$.\n\nSince $w \\in E_0$, $\\mu(E_0 \\cap \\mathcal{J}_j) > 0$ by (ii) and by the condition (i), if $\\delta > 0$ is sufficiently small, then\n$$\n|\\theta_1 - \\theta_2| > \\eta \\mod 2\\pi, \\quad \\text{for } \\theta_1 \\in \\mathcal{J}_j, \\theta_2 \\in \\mathcal{J}_j \\cap [0, \\delta].\n$$\n\nHence, by (iv), for any $\\theta_2 \\in \\mathcal{J}_j \\cap [0, \\delta]$, we have\n$$\n1 - \\varepsilon < u(z, w) < 1 \\quad \\text{for } z \\in E_0, w \\in S_2\\mathcal{E}_+(\\theta_2).\n$$\n\nNow, let $K_j = \\bigcup_{i=1}^{N_j} K_{j,i}$, where $K_{j,i} = S_{j,i}(K_0)$ and $S_{j,i}$ are distinct elements of $G$ for $i = 1, 2, \\ldots, N_j$. By Lemma 2, there exist $0 < \\varphi_1 < \\varphi_2 < \\ldots < \\varphi_{N_j} < 2\\pi$ such that the circle $|z| = \\rho_j$ intersects $K_j$ in a set of arcs $J_{j,i}$ (for $ i = 1, 2, \\ldots, N_j $).\n\nBy (14), we have\n$$\n\\text{const.}(1 - \\rho_j)^{|\\mathcal{J}_{j,i}|} \\leq |\\mathcal{J}_{j,i}| \\leq \\text{const.}(1 - \\rho_j),\n$$\nwhere $|\\mathcal{J}_{j,i}|$ is the length of $J_{j,i}$.\n\nSince $E_0$ is invariant by $S$, $\\mu(E_0 \\cap \\mathcal{J}_{j,i}) > 0$ for each $i = 1, 2, \\ldots, N_j$.\n\nLet $\\delta > 0$ be sufficiently small, then by the conditions (i) and (ii), for $\\theta_1 \\in \\mathcal{J}_{j,i}$ and $\\theta_2 \\in \\mathcal{J}_{j,i} \\cap [0, \\delta]$, we have\n$$\n|\\theta_1 - \\theta_2| > \\eta \\mod 2\\pi.\n$$\n\nHence, by (iv), for any $\\theta_2 \\in \\mathcal{J}_{j,i} \\cap [0, \\delta]$, we have\n$$\n1 - \\varepsilon < u(z, w) < 1 \\quad \\text{for } z \\in E_0, w \\in S_{j,i}(\\mathcal{E}_+(\\theta_2)).\n$$\n\n\nNow, let $\\delta > 0$ be sufficiently small, so that $S_{j,i}(\\mathcal{E}_+(\\theta_2))$ is contained in a small neighborhood of $\\mathcal{E}_+(\\theta_2)$ for each $i = 1, 2, \\ldots, N_j$.\n\nLet $V_{j,i}$ be the union of these neighborhoods, i.e., $V_{j,i} = \\bigcup_{k=1}^{N_{j,i}} S_{j,i,k}(\\mathcal{E}_+(\\theta_2))$, where $S_{j,i,k}$ are distinct elements of $G$ for $k = 1, 2, \\ldots, N_{j,i}$.\n\nBy the conditions (iv) and (v), we have\n$$\n1 - \\varepsilon < u(z, w) < 1 \\quad \\text{for } z \\in E_0, w \\in V_{j,i}.\n$$\n\nNow, for any $y > 0$, let $M_{j,i,y}$ be the measure of the set $E_0 \\cap \\{ \\theta_1 : \\mu(\\theta_1 \\notin [0, \\delta] \\cap E_0) > y \\}$, then\n$$\nM_{j,y} = \\sum_{i=1}^{N_j} M_{j,i,y} = \\lim_{\\delta \\to 0} \\mu(E_0 \\cap \\{ \\theta_1 : \\mu(\\theta_1 \\notin [0, \\delta] \\cap E_0) > y \\}).\n$$\n\nSince $\\delta > 0$ is arbitrary, we can conclude that\n$$\nM_{j,y} = \\infty \\quad \\text{for any } y > 0. \\quad (16)\n$$\n\nNow, let $M_y = \\lim_{j \\to \\infty} M_{j,y}$, then by (16), we have\n$$\nM_y = \\infty \\quad \\text{for any } y > 0. \\quad (17)\n$$\n\nNext, we consider the set\n$$\nA_y = \\bigcup_{j=1}^{\\infty} \\left( E_0 \\cap \\{ \\theta_1 : \\mu(\\theta_1 \\notin [0, \\delta] \\cap E_0) > y \\} \\right).\n$$\n\nBy (17), we have\n$$\n\\mu(A_y) = \\infty \\quad \\text{for any } y > 0. \\quad (18)\n$$\n\nNow, let $B_y = \\bigcap_{n=1}^{\\infty} A_{1/n}$, then $B_y$ is a subset of $ E_0 $ where $\\mu(\\theta_1 \\notin [0, \\delta] \\cap E_0) = 0$ for any $\\delta > 0$.\n\nBy (iii), we have\n$$\n\\lim u(z, w) = 1 \\quad \\text{uniformly on } E_0, \\text{ when } z \\to e^{i\\theta_1}, w \\to e^{i\\theta_2} \\text{ from the inside of } \\mathcal{E}_+(\\theta_1), \\mathcal{E}_+(\\theta_2) \\text{ respectively}.\n$$\n\nThis implies that for any $\\epsilon > 0$, there exists a $\\delta > 0$ such that if $z \\in E_0$ and $w \\in \\mathcal{E}_+(\\theta_2)$ with $|\\theta_1 - \\theta_2| < \\delta$, then $|u(z, w) - 1| < \\epsilon$.\n\nNow, consider $\\epsilon = 1/2$, there exists $\\delta > 0$ such that if $z \\in E_0$ and $w \\in \\mathcal{E}_+(\\theta_2)$ with $|\\theta_1 - \\theta_2| < \\delta$, then $|u(z, w) - 1| < 1/2$.\n\nThis means that $u(z, w) > 1/2$, and hence $u(z, w) \\neq 0$, for all such $ z $ and $ w $.\n\nTherefore, $B_y$ is a subset of $E_0$ where $u(z, w) \\neq 0$ for all $z \\in B_y$ and $w \\in \\mathcal{E}_+(\\theta_2)$ with $|\\theta_1 - \\theta_2| < \\delta$.\n\nSince $B_y$ is a subset of $E_0$ and $E_0$ satisfies (iii), we can conclude that\n$$\n\\lim u(z, w) = 1 \\quad \\text{uniformly on } B_y,\n$$\nwhen $z \\to e^{i\\theta_1}$ and $w \\to e^{i\\theta_2}$ from the inside of $\\mathcal{E}_+(\\theta_1)$ and $\\mathcal{E}_+(\\theta_2)$ respectively.\n\nNow, consider $\\epsilon = 1/2$, there exists $N$ such that for all $n > N$, we have $1/n < \\epsilon$.\n\nThis implies that $B_y$ is a subset of $E_0$ where\n$$\n\\lim u(z, w) = 1 \\quad \\text{uniformly on } B_y,\n$$\nwhen $z \\to e^{i\\theta_1}$ and $w \\to e^{i\\theta_2}$ from the inside of $\\mathcal{E}_+(\\theta_1)$ and $\\mathcal{E}_+(\\theta_2)$ respectively, for all $\\theta_1, \\theta_2$.\n\nHence, $u(z, w) = 1$ on $B_y$ for all $z$ and $w$.\n\nNow, let $A$ be the complement of $B_y$ in $E_0$, then $\\mu(A) = 0$.\n\nThis implies that $u(z, w) = 1$ for almost all $z$ and $w$ in $E_0$.\n\nSince $E_0$ is invariant by $S$ and $u(z, w)$ is invariant by $S$ (as shown in (2)), we have\n$$\nu(S(z), S(w)) = u(z, w), \\quad \\text{for } S \\in G.\n$$\n\nThis means that $u(z, w) = 1$ for almost all $z$ and $w$ in $S_1 E_0$, where $S_1$ is an element of $G$.\n\nHence, by repeating this argument, we can conclude that $u(z, w) = 1$ for almost all $z$ and $w$ in $ G^n E_0 $, where $G^n$ is the $n$-th iterate of $G$.\n\nSince $\\mu(E_0) > 2\\pi - \\delta$, we can choose $n$ sufficiently large such that $\\mu(G^n E_0) > 0$.\n\nThis implies that $u(z, w) = 1$ for almost all $z$ and $w$ in a set of positive measure.\n\nBut this contradicts the fact that $\\lim u(z, w) = F(\\theta_1)$ for almost all $\\theta_1$ in $\\Theta$, as stated in (19).\n\nTherefore, our assumption that there exists a measurable set $E$ on $\\Theta$ which is invariant by $S$ and $\\mu(E) > 0$ must be false.\n\nHence, $\\mu(E) = 4\\pi^2$.\n\nThus, the proof of Hopf's ergodic theorem is complete.\n\n**Q.E.D.**\n\n\n\n\n[1] Hopf, E. Ergodentheorie. Berlin (1937).\n\n[2] Hedlund, G. A. A new proof for a metrically transitive system. Amer. J. Math. 62 (1940).\n\n","source":"_posts/Hopf ergodic theorem.md","raw":"---\ntitle: Hopf's Ergodic Theorem\ndate: 2024-01-17 13:48:02\ntags:\n    - [Sevaral Complex Variables]\ncategories:\n    - [Sevaral Complex Variables, Fuchsian Group]\nmathjax: true\n---\n\n# Hopf's Ergodic Theorem\n\nLet $y_1 = e^{i\\theta_1}$ and $y_2 = e^{i\\theta_2}$ be two points on $|z| = 1$. Then, the pair $(\\theta_1, \\theta_2)$ can be considered as a point of a torus $\\Theta: 0 \\leq \\theta_1, \\theta_2 < 2\\pi$.\n\nFor a measurable set $E$ on $\\Theta$, we define its measure $\\mu(E)$ by $\\mu(E) = \\int\\int d\\theta_1 d\\theta_2$, so that $\\mu(\\Theta) = 4\\pi^2$.\n\nIf $S_v$ is any substitution of a Fuchsian group $G$ and $T_v: \\Theta \\to S_v(\\Theta)$, then the totality of $\\{ T_v \\}$ constitute a group $S = G \\times G$.\n\n## Hopf's Ergodic Theorem (Theorem XI. 23.):\nIf $\\mu(\\Theta) < \\infty$, then there exists no measurable set $E$ on $\\Theta$ which is invariant by $S$, and $0 < \\mu(E) < 4\\pi^2$.\n\nHence, if $\\mu(E) > 0$, then $\\mu(E) = 4\\pi^2$.\n\n## Proof (Tsuji):\nSuppose that there exists a measurable set $E$ on $\\Theta$ which is invariant by $S$, and $\\mu(E) > 0$. We shall prove that $\\mu(E) = 4\\pi^{2}$.\n\nLet $f(\\theta_1, \\theta_2)$ be the characteristic function of $ E $ and put\n$$\nu(z, w) = \\frac{1}{4\\pi^2} \\iint_{\\Theta} f(\\theta_1, \\theta_2)\\frac{1- |z|^{2}}{|z - e^{i\\theta_1}|^2} \\frac{1- |w|^{2}}{|w - e^{i\\theta_2}|^2}d\\theta_1 d\\theta_2,\n$$\nwhere $\\Theta: |z| < 1, |w| < 1$.\n\nThen $u(z, w)$ is invariant by $S$ such that\n$$\nu(S(z), S(w)) = u(z, w), \\quad \\text{for } S \\in G. \\quad (2)\n$$\n\nWe denote the Stolz domain: $|\\arg(1 - ze^{-i\\theta})| < \\frac{\\pi}{4} $ by $ \\mathcal{E}(e^{i\\theta})$ and $\\mathcal{E}_+(\\theta)$ be its part contained in $|z - e^{i\\theta}| < \\delta$. Then by (Tsuji, Masatsugu. Potential theory in modern function theory. Maruzen, 1959.\nTheorem IV. 12)[3], for almost all $(\\theta_1, \\theta_2) $ on $ \\Theta $,\n$$\n\\lim u(z, w) = f(\\theta_1, \\theta_2) \\text{ uniformly, if } z \\to e^{i\\theta_1}, w \\to e^{i\\theta_2} \\text{ from the inside of } \\mathcal{E}_+(e^{i\\theta_1}), \\mathcal{E}_+(\\theta_2) \\text{ respectively}. \\quad (3)\n$$\n\n\nLet $E_{\\theta_1}$ be the section of $E$ by the line $\\theta = \\text{const.} = \\theta_1$ and $E_{\\theta_2}$ be that by the line $\\theta = \\text{const.} = \\theta_2$, then\n$$\n\\mu(E_{\\theta_1})\\mu(E_{\\theta_2}) > 0, \\quad (4)\n$$\nwhere $\\mu(\\cdot)$ denotes the linear measure.\n\nSince $\\mu(\\Theta) < \\infty$, $G$ is of divergence type (Tsuji, Masatsugu. Potential theory in modern function theory. Maruzen, 1959.\nTheorem XI. 10)[3], so that there exists no measurable set $e$ on $|z| = 1$ which is invariant by $G$ and $\\mu(e) < 2\\pi$. Hence, if $\\mu(E_{\\theta_1}) > 0$, then $\\mu(E_{\\theta_1}) = 2\\pi$.\n\n\nIf $\\mu(E_{\\theta_2}) = 0$ on a set $e$ of positive measure in $[0, 2\\pi)$, then since by the hypothesis on $E$, such a set $e$ is invariant by $G$, $\\mu(e) = 2\\pi$, so that $\\mu(E_{\\theta_2}) > 0$ almost everywhere in $[0, 2\\pi)$, hence $\\mu(E) = 4\\pi^2$, which is absurd.\n\nHence,\n$$\n\\mu(E_{\\theta_2}) > 0 \\text{ for almost all } \\theta_2 \\in [0, 2\\pi). \\quad (5)\n$$\n\nHence by Egoroff's theorem, there exists a closed subset $E_0$ of $E$ which satisfies the following conditions (i), (ii), (iii), where $\\delta > 0$ and $\\eta > 0$ are sufficiently small constants.\n\n(i) $E_0$ lies outside of the strip: $|\\theta_1 - \\theta_2| < \\eta \\mod 2\\pi$.\n(ii) Let $E_0^{\\prime}$ be the projection of $E_0$ on the $\\theta_1$-axis, then\n$$\n\\mu(E_0) > 2\\pi - \\delta \\quad \\text{and} \\quad \\mu(\\theta_1 \\notin [0, \\eta] \\cap E_0) > 0 \\text{ for any } \\theta_1 \\in [0, 2\\pi).\n$$\n(iii) $\\lim u(z, w) = 1$ uniformly on $ E_0 $, when $z \\to e^{i\\theta_1}, w \\to e^{i\\theta_2}$ from the inside of $\\mathcal{E}_+(\\theta_1), \\mathcal{E}_+(\\theta_2)$ respectively.\n\n\n(iv) When $z \\in E_0$ and $w \\in S_2\\mathcal{E}_+(\\theta_2)$, then\n$$\n1 - \\varepsilon < u(z, w) < 1 \\quad \\text{for sufficiently small } \\varepsilon > 0.\n$$\n\n(v) For any $y > 0$, let\n$$\nM_y = \\lim_{\\delta \\to 0} \\mu(E_0 \\cap \\{ \\theta_1 : \\mu(\\theta_1 \\notin [0, \\delta] \\cap E_0) > y \\}).\n$$\n\nWe shall prove that\n$$\nM_y = \\infty \\quad (y = 1, 2, \\ldots). \\quad (13)\n$$\n\nLet $K_j = S_j(K_0)$, then $K_j$ is obtained from $K_0$ by a rotation about $\\theta = 0$, so that the circle $|z| = \\rho_j$ intersects $K_j$ in an arc $J_j$ whose projection on $|z| = 1$ from $\\theta = 0$ is denoted by $\\mathcal{J}_j$ then $|\\mathcal{J}_j| = |\\mathcal{J}_0|$, so that\n$$\n\\text{const.}(1 - \\rho_j)^{|\\mathcal{J}_j|} \\leq |\\mathcal{J}_j| \\leq \\text{const.}(1 - \\rho_j), \\quad \\text{(14)}\n$$\nwhere $\\text{const.} > 0$.\n\nSince $w \\in E_0$, $\\mu(E_0 \\cap \\mathcal{J}_j) > 0$ by (ii) and by the condition (i), if $\\delta > 0$ is sufficiently small, then\n$$\n|\\theta_1 - \\theta_2| > \\eta \\mod 2\\pi, \\quad \\text{for } \\theta_1 \\in \\mathcal{J}_j, \\theta_2 \\in \\mathcal{J}_j \\cap [0, \\delta].\n$$\n\nHence, by (iv), for any $\\theta_2 \\in \\mathcal{J}_j \\cap [0, \\delta]$, we have\n$$\n1 - \\varepsilon < u(z, w) < 1 \\quad \\text{for } z \\in E_0, w \\in S_2\\mathcal{E}_+(\\theta_2).\n$$\n\nNow, let $K_j = \\bigcup_{i=1}^{N_j} K_{j,i}$, where $K_{j,i} = S_{j,i}(K_0)$ and $S_{j,i}$ are distinct elements of $G$ for $i = 1, 2, \\ldots, N_j$. By Lemma 2, there exist $0 < \\varphi_1 < \\varphi_2 < \\ldots < \\varphi_{N_j} < 2\\pi$ such that the circle $|z| = \\rho_j$ intersects $K_j$ in a set of arcs $J_{j,i}$ (for $ i = 1, 2, \\ldots, N_j $).\n\nBy (14), we have\n$$\n\\text{const.}(1 - \\rho_j)^{|\\mathcal{J}_{j,i}|} \\leq |\\mathcal{J}_{j,i}| \\leq \\text{const.}(1 - \\rho_j),\n$$\nwhere $|\\mathcal{J}_{j,i}|$ is the length of $J_{j,i}$.\n\nSince $E_0$ is invariant by $S$, $\\mu(E_0 \\cap \\mathcal{J}_{j,i}) > 0$ for each $i = 1, 2, \\ldots, N_j$.\n\nLet $\\delta > 0$ be sufficiently small, then by the conditions (i) and (ii), for $\\theta_1 \\in \\mathcal{J}_{j,i}$ and $\\theta_2 \\in \\mathcal{J}_{j,i} \\cap [0, \\delta]$, we have\n$$\n|\\theta_1 - \\theta_2| > \\eta \\mod 2\\pi.\n$$\n\nHence, by (iv), for any $\\theta_2 \\in \\mathcal{J}_{j,i} \\cap [0, \\delta]$, we have\n$$\n1 - \\varepsilon < u(z, w) < 1 \\quad \\text{for } z \\in E_0, w \\in S_{j,i}(\\mathcal{E}_+(\\theta_2)).\n$$\n\n\nNow, let $\\delta > 0$ be sufficiently small, so that $S_{j,i}(\\mathcal{E}_+(\\theta_2))$ is contained in a small neighborhood of $\\mathcal{E}_+(\\theta_2)$ for each $i = 1, 2, \\ldots, N_j$.\n\nLet $V_{j,i}$ be the union of these neighborhoods, i.e., $V_{j,i} = \\bigcup_{k=1}^{N_{j,i}} S_{j,i,k}(\\mathcal{E}_+(\\theta_2))$, where $S_{j,i,k}$ are distinct elements of $G$ for $k = 1, 2, \\ldots, N_{j,i}$.\n\nBy the conditions (iv) and (v), we have\n$$\n1 - \\varepsilon < u(z, w) < 1 \\quad \\text{for } z \\in E_0, w \\in V_{j,i}.\n$$\n\nNow, for any $y > 0$, let $M_{j,i,y}$ be the measure of the set $E_0 \\cap \\{ \\theta_1 : \\mu(\\theta_1 \\notin [0, \\delta] \\cap E_0) > y \\}$, then\n$$\nM_{j,y} = \\sum_{i=1}^{N_j} M_{j,i,y} = \\lim_{\\delta \\to 0} \\mu(E_0 \\cap \\{ \\theta_1 : \\mu(\\theta_1 \\notin [0, \\delta] \\cap E_0) > y \\}).\n$$\n\nSince $\\delta > 0$ is arbitrary, we can conclude that\n$$\nM_{j,y} = \\infty \\quad \\text{for any } y > 0. \\quad (16)\n$$\n\nNow, let $M_y = \\lim_{j \\to \\infty} M_{j,y}$, then by (16), we have\n$$\nM_y = \\infty \\quad \\text{for any } y > 0. \\quad (17)\n$$\n\nNext, we consider the set\n$$\nA_y = \\bigcup_{j=1}^{\\infty} \\left( E_0 \\cap \\{ \\theta_1 : \\mu(\\theta_1 \\notin [0, \\delta] \\cap E_0) > y \\} \\right).\n$$\n\nBy (17), we have\n$$\n\\mu(A_y) = \\infty \\quad \\text{for any } y > 0. \\quad (18)\n$$\n\nNow, let $B_y = \\bigcap_{n=1}^{\\infty} A_{1/n}$, then $B_y$ is a subset of $ E_0 $ where $\\mu(\\theta_1 \\notin [0, \\delta] \\cap E_0) = 0$ for any $\\delta > 0$.\n\nBy (iii), we have\n$$\n\\lim u(z, w) = 1 \\quad \\text{uniformly on } E_0, \\text{ when } z \\to e^{i\\theta_1}, w \\to e^{i\\theta_2} \\text{ from the inside of } \\mathcal{E}_+(\\theta_1), \\mathcal{E}_+(\\theta_2) \\text{ respectively}.\n$$\n\nThis implies that for any $\\epsilon > 0$, there exists a $\\delta > 0$ such that if $z \\in E_0$ and $w \\in \\mathcal{E}_+(\\theta_2)$ with $|\\theta_1 - \\theta_2| < \\delta$, then $|u(z, w) - 1| < \\epsilon$.\n\nNow, consider $\\epsilon = 1/2$, there exists $\\delta > 0$ such that if $z \\in E_0$ and $w \\in \\mathcal{E}_+(\\theta_2)$ with $|\\theta_1 - \\theta_2| < \\delta$, then $|u(z, w) - 1| < 1/2$.\n\nThis means that $u(z, w) > 1/2$, and hence $u(z, w) \\neq 0$, for all such $ z $ and $ w $.\n\nTherefore, $B_y$ is a subset of $E_0$ where $u(z, w) \\neq 0$ for all $z \\in B_y$ and $w \\in \\mathcal{E}_+(\\theta_2)$ with $|\\theta_1 - \\theta_2| < \\delta$.\n\nSince $B_y$ is a subset of $E_0$ and $E_0$ satisfies (iii), we can conclude that\n$$\n\\lim u(z, w) = 1 \\quad \\text{uniformly on } B_y,\n$$\nwhen $z \\to e^{i\\theta_1}$ and $w \\to e^{i\\theta_2}$ from the inside of $\\mathcal{E}_+(\\theta_1)$ and $\\mathcal{E}_+(\\theta_2)$ respectively.\n\nNow, consider $\\epsilon = 1/2$, there exists $N$ such that for all $n > N$, we have $1/n < \\epsilon$.\n\nThis implies that $B_y$ is a subset of $E_0$ where\n$$\n\\lim u(z, w) = 1 \\quad \\text{uniformly on } B_y,\n$$\nwhen $z \\to e^{i\\theta_1}$ and $w \\to e^{i\\theta_2}$ from the inside of $\\mathcal{E}_+(\\theta_1)$ and $\\mathcal{E}_+(\\theta_2)$ respectively, for all $\\theta_1, \\theta_2$.\n\nHence, $u(z, w) = 1$ on $B_y$ for all $z$ and $w$.\n\nNow, let $A$ be the complement of $B_y$ in $E_0$, then $\\mu(A) = 0$.\n\nThis implies that $u(z, w) = 1$ for almost all $z$ and $w$ in $E_0$.\n\nSince $E_0$ is invariant by $S$ and $u(z, w)$ is invariant by $S$ (as shown in (2)), we have\n$$\nu(S(z), S(w)) = u(z, w), \\quad \\text{for } S \\in G.\n$$\n\nThis means that $u(z, w) = 1$ for almost all $z$ and $w$ in $S_1 E_0$, where $S_1$ is an element of $G$.\n\nHence, by repeating this argument, we can conclude that $u(z, w) = 1$ for almost all $z$ and $w$ in $ G^n E_0 $, where $G^n$ is the $n$-th iterate of $G$.\n\nSince $\\mu(E_0) > 2\\pi - \\delta$, we can choose $n$ sufficiently large such that $\\mu(G^n E_0) > 0$.\n\nThis implies that $u(z, w) = 1$ for almost all $z$ and $w$ in a set of positive measure.\n\nBut this contradicts the fact that $\\lim u(z, w) = F(\\theta_1)$ for almost all $\\theta_1$ in $\\Theta$, as stated in (19).\n\nTherefore, our assumption that there exists a measurable set $E$ on $\\Theta$ which is invariant by $S$ and $\\mu(E) > 0$ must be false.\n\nHence, $\\mu(E) = 4\\pi^2$.\n\nThus, the proof of Hopf's ergodic theorem is complete.\n\n**Q.E.D.**\n\n\n\n\n[1] Hopf, E. Ergodentheorie. Berlin (1937).\n\n[2] Hedlund, G. A. A new proof for a metrically transitive system. Amer. J. Math. 62 (1940).\n\n","slug":"Hopf ergodic theorem","published":1,"updated":"2024-04-10T11:18:26.602Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5s1001am8nx1jo6b3qd","content":"<h1 id=\"hopfs-ergodic-theorem\">Hopf's Ergodic Theorem</h1>\r\n<p>Let <span class=\"math inline\">\\(y_1 = e^{i\\theta_1}\\)</span> and\r\n<span class=\"math inline\">\\(y_2 = e^{i\\theta_2}\\)</span> be two points\r\non <span class=\"math inline\">\\(|z| = 1\\)</span>. Then, the pair <span class=\"math inline\">\\((\\theta_1, \\theta_2)\\)</span> can be considered as\r\na point of a torus <span class=\"math inline\">\\(\\Theta: 0 \\leq \\theta_1,\r\n\\theta_2 &lt; 2\\pi\\)</span>.</p>\r\n<p>For a measurable set <span class=\"math inline\">\\(E\\)</span> on <span class=\"math inline\">\\(\\Theta\\)</span>, we define its measure <span class=\"math inline\">\\(\\mu(E)\\)</span> by <span class=\"math inline\">\\(\\mu(E) = \\int\\int d\\theta_1 d\\theta_2\\)</span>, so\r\nthat <span class=\"math inline\">\\(\\mu(\\Theta) = 4\\pi^2\\)</span>.</p>\r\n<p>If <span class=\"math inline\">\\(S_v\\)</span> is any substitution of a\r\nFuchsian group <span class=\"math inline\">\\(G\\)</span> and <span class=\"math inline\">\\(T_v: \\Theta \\to S_v(\\Theta)\\)</span>, then the\r\ntotality of <span class=\"math inline\">\\(\\{ T_v \\}\\)</span> constitute a\r\ngroup <span class=\"math inline\">\\(S = G \\times G\\)</span>.</p>\r\n<h2 id=\"hopfs-ergodic-theorem-theorem-xi.-23.\">Hopf's Ergodic Theorem\r\n(Theorem XI. 23.):</h2>\r\n<p>If <span class=\"math inline\">\\(\\mu(\\Theta) &lt; \\infty\\)</span>, then\r\nthere exists no measurable set <span class=\"math inline\">\\(E\\)</span> on\r\n<span class=\"math inline\">\\(\\Theta\\)</span> which is invariant by <span class=\"math inline\">\\(S\\)</span>, and <span class=\"math inline\">\\(0 &lt;\r\n\\mu(E) &lt; 4\\pi^2\\)</span>.</p>\r\n<p>Hence, if <span class=\"math inline\">\\(\\mu(E) &gt; 0\\)</span>, then\r\n<span class=\"math inline\">\\(\\mu(E) = 4\\pi^2\\)</span>.</p>\r\n<h2 id=\"proof-tsuji\">Proof (Tsuji):</h2>\r\n<p>Suppose that there exists a measurable set <span class=\"math inline\">\\(E\\)</span> on <span class=\"math inline\">\\(\\Theta\\)</span> which is invariant by <span class=\"math inline\">\\(S\\)</span>, and <span class=\"math inline\">\\(\\mu(E)\r\n&gt; 0\\)</span>. We shall prove that <span class=\"math inline\">\\(\\mu(E)\r\n= 4\\pi^{2}\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(f(\\theta_1, \\theta_2)\\)</span> be the\r\ncharacteristic function of $ E $ and put <span class=\"math display\">\\[\r\nu(z, w) = \\frac{1}{4\\pi^2} \\iint_{\\Theta} f(\\theta_1, \\theta_2)\\frac{1-\r\n|z|^{2}}{|z - e^{i\\theta_1}|^2} \\frac{1- |w|^{2}}{|w -\r\ne^{i\\theta_2}|^2}d\\theta_1 d\\theta_2,\r\n\\]</span> where <span class=\"math inline\">\\(\\Theta: |z| &lt; 1, |w| &lt;\r\n1\\)</span>.</p>\r\n<p>Then <span class=\"math inline\">\\(u(z, w)\\)</span> is invariant by\r\n<span class=\"math inline\">\\(S\\)</span> such that <span class=\"math display\">\\[\r\nu(S(z), S(w)) = u(z, w), \\quad \\text{for } S \\in G. \\quad (2)\r\n\\]</span></p>\r\n<p>We denote the Stolz domain: $|(1 - ze^{-i})| &lt; $ by $ (e^{i})$ and\r\n<span class=\"math inline\">\\(\\mathcal{E}_+(\\theta)\\)</span> be its part\r\ncontained in <span class=\"math inline\">\\(|z - e^{i\\theta}| &lt;\r\n\\delta\\)</span>. Then by (Tsuji, Masatsugu. Potential theory in modern\r\nfunction theory. Maruzen, 1959. Theorem IV. 12)[3], for almost all $(_1,\r\n_2) $ on $ <span class=\"math inline\">\\(,\\)</span>$ u(z, w) = f(_1, _2) z\r\ne^{i_1}, w e<sup>{i<em>2} </em>+(e</sup>{i<em>1}), </em>+(_2) . (3)\r\n$$</p>\r\n<p>Let <span class=\"math inline\">\\(E_{\\theta_1}\\)</span> be the section\r\nof <span class=\"math inline\">\\(E\\)</span> by the line <span class=\"math inline\">\\(\\theta = \\text{const.} = \\theta_1\\)</span> and\r\n<span class=\"math inline\">\\(E_{\\theta_2}\\)</span> be that by the line\r\n<span class=\"math inline\">\\(\\theta = \\text{const.} = \\theta_2\\)</span>,\r\nthen <span class=\"math display\">\\[\r\n\\mu(E_{\\theta_1})\\mu(E_{\\theta_2}) &gt; 0, \\quad (4)\r\n\\]</span> where <span class=\"math inline\">\\(\\mu(\\cdot)\\)</span> denotes\r\nthe linear measure.</p>\r\n<p>Since <span class=\"math inline\">\\(\\mu(\\Theta) &lt; \\infty\\)</span>,\r\n<span class=\"math inline\">\\(G\\)</span> is of divergence type (Tsuji,\r\nMasatsugu. Potential theory in modern function theory. Maruzen, 1959.\r\nTheorem XI. 10)[3], so that there exists no measurable set <span class=\"math inline\">\\(e\\)</span> on <span class=\"math inline\">\\(|z| =\r\n1\\)</span> which is invariant by <span class=\"math inline\">\\(G\\)</span>\r\nand <span class=\"math inline\">\\(\\mu(e) &lt; 2\\pi\\)</span>. Hence, if\r\n<span class=\"math inline\">\\(\\mu(E_{\\theta_1}) &gt; 0\\)</span>, then\r\n<span class=\"math inline\">\\(\\mu(E_{\\theta_1}) = 2\\pi\\)</span>.</p>\r\n<p>If <span class=\"math inline\">\\(\\mu(E_{\\theta_2}) = 0\\)</span> on a\r\nset <span class=\"math inline\">\\(e\\)</span> of positive measure in <span class=\"math inline\">\\([0, 2\\pi)\\)</span>, then since by the hypothesis\r\non <span class=\"math inline\">\\(E\\)</span>, such a set <span class=\"math inline\">\\(e\\)</span> is invariant by <span class=\"math inline\">\\(G\\)</span>, <span class=\"math inline\">\\(\\mu(e) =\r\n2\\pi\\)</span>, so that <span class=\"math inline\">\\(\\mu(E_{\\theta_2})\r\n&gt; 0\\)</span> almost everywhere in <span class=\"math inline\">\\([0,\r\n2\\pi)\\)</span>, hence <span class=\"math inline\">\\(\\mu(E) =\r\n4\\pi^2\\)</span>, which is absurd.</p>\r\n<p>Hence, <span class=\"math display\">\\[\r\n\\mu(E_{\\theta_2}) &gt; 0 \\text{ for almost all } \\theta_2 \\in [0, 2\\pi).\r\n\\quad (5)\r\n\\]</span></p>\r\n<p>Hence by Egoroff's theorem, there exists a closed subset <span class=\"math inline\">\\(E_0\\)</span> of <span class=\"math inline\">\\(E\\)</span> which satisfies the following\r\nconditions (i), (ii), (iii), where <span class=\"math inline\">\\(\\delta\r\n&gt; 0\\)</span> and <span class=\"math inline\">\\(\\eta &gt; 0\\)</span> are\r\nsufficiently small constants.</p>\r\n<ol type=\"i\">\r\n<li><p><span class=\"math inline\">\\(E_0\\)</span> lies outside of the\r\nstrip: <span class=\"math inline\">\\(|\\theta_1 - \\theta_2| &lt; \\eta \\mod\r\n2\\pi\\)</span>.</p></li>\r\n<li><p>Let <span class=\"math inline\">\\(E_0^{\\prime}\\)</span> be the\r\nprojection of <span class=\"math inline\">\\(E_0\\)</span> on the <span class=\"math inline\">\\(\\theta_1\\)</span>-axis, then <span class=\"math display\">\\[\r\n\\mu(E_0) &gt; 2\\pi - \\delta \\quad \\text{and} \\quad \\mu(\\theta_1 \\notin\r\n[0, \\eta] \\cap E_0) &gt; 0 \\text{ for any } \\theta_1 \\in [0, 2\\pi).\r\n\\]</span></p></li>\r\n<li><p><span class=\"math inline\">\\(\\lim u(z, w) = 1\\)</span> uniformly\r\non $ E_0 $, when <span class=\"math inline\">\\(z \\to e^{i\\theta_1}, w \\to\r\ne^{i\\theta_2}\\)</span> from the inside of <span class=\"math inline\">\\(\\mathcal{E}_+(\\theta_1),\r\n\\mathcal{E}_+(\\theta_2)\\)</span> respectively.</p></li>\r\n<li><p>When <span class=\"math inline\">\\(z \\in E_0\\)</span> and <span class=\"math inline\">\\(w \\in S_2\\mathcal{E}_+(\\theta_2)\\)</span>, then\r\n<span class=\"math display\">\\[\r\n1 - \\varepsilon &lt; u(z, w) &lt; 1 \\quad \\text{for sufficiently small }\r\n\\varepsilon &gt; 0.\r\n\\]</span></p></li>\r\n<li><p>For any <span class=\"math inline\">\\(y &gt; 0\\)</span>, let <span class=\"math display\">\\[\r\nM_y = \\lim_{\\delta \\to 0} \\mu(E_0 \\cap \\{ \\theta_1 : \\mu(\\theta_1 \\notin\r\n[0, \\delta] \\cap E_0) &gt; y \\}).\r\n\\]</span></p></li>\r\n</ol>\r\n<p>We shall prove that <span class=\"math display\">\\[\r\nM_y = \\infty \\quad (y = 1, 2, \\ldots). \\quad (13)\r\n\\]</span></p>\r\n<p>Let <span class=\"math inline\">\\(K_j = S_j(K_0)\\)</span>, then <span class=\"math inline\">\\(K_j\\)</span> is obtained from <span class=\"math inline\">\\(K_0\\)</span> by a rotation about <span class=\"math inline\">\\(\\theta = 0\\)</span>, so that the circle <span class=\"math inline\">\\(|z| = \\rho_j\\)</span> intersects <span class=\"math inline\">\\(K_j\\)</span> in an arc <span class=\"math inline\">\\(J_j\\)</span> whose projection on <span class=\"math inline\">\\(|z| = 1\\)</span> from <span class=\"math inline\">\\(\\theta = 0\\)</span> is denoted by <span class=\"math inline\">\\(\\mathcal{J}_j\\)</span> then <span class=\"math inline\">\\(|\\mathcal{J}_j| = |\\mathcal{J}_0|\\)</span>, so\r\nthat <span class=\"math display\">\\[\r\n\\text{const.}(1 - \\rho_j)^{|\\mathcal{J}_j|} \\leq |\\mathcal{J}_j| \\leq\r\n\\text{const.}(1 - \\rho_j), \\quad \\text{(14)}\r\n\\]</span> where <span class=\"math inline\">\\(\\text{const.} &gt;\r\n0\\)</span>.</p>\r\n<p>Since <span class=\"math inline\">\\(w \\in E_0\\)</span>, <span class=\"math inline\">\\(\\mu(E_0 \\cap \\mathcal{J}_j) &gt; 0\\)</span> by\r\n(ii) and by the condition (i), if <span class=\"math inline\">\\(\\delta\r\n&gt; 0\\)</span> is sufficiently small, then <span class=\"math display\">\\[\r\n|\\theta_1 - \\theta_2| &gt; \\eta \\mod 2\\pi, \\quad \\text{for } \\theta_1\r\n\\in \\mathcal{J}_j, \\theta_2 \\in \\mathcal{J}_j \\cap [0, \\delta].\r\n\\]</span></p>\r\n<p>Hence, by (iv), for any <span class=\"math inline\">\\(\\theta_2 \\in\r\n\\mathcal{J}_j \\cap [0, \\delta]\\)</span>, we have <span class=\"math display\">\\[\r\n1 - \\varepsilon &lt; u(z, w) &lt; 1 \\quad \\text{for } z \\in E_0, w \\in\r\nS_2\\mathcal{E}_+(\\theta_2).\r\n\\]</span></p>\r\n<p>Now, let <span class=\"math inline\">\\(K_j = \\bigcup_{i=1}^{N_j}\r\nK_{j,i}\\)</span>, where <span class=\"math inline\">\\(K_{j,i} =\r\nS_{j,i}(K_0)\\)</span> and <span class=\"math inline\">\\(S_{j,i}\\)</span>\r\nare distinct elements of <span class=\"math inline\">\\(G\\)</span> for\r\n<span class=\"math inline\">\\(i = 1, 2, \\ldots, N_j\\)</span>. By Lemma 2,\r\nthere exist <span class=\"math inline\">\\(0 &lt; \\varphi_1 &lt; \\varphi_2\r\n&lt; \\ldots &lt; \\varphi_{N_j} &lt; 2\\pi\\)</span> such that the circle\r\n<span class=\"math inline\">\\(|z| = \\rho_j\\)</span> intersects <span class=\"math inline\">\\(K_j\\)</span> in a set of arcs <span class=\"math inline\">\\(J_{j,i}\\)</span> (for $ i = 1, 2, , N_j $).</p>\r\n<p>By (14), we have <span class=\"math display\">\\[\r\n\\text{const.}(1 - \\rho_j)^{|\\mathcal{J}_{j,i}|} \\leq |\\mathcal{J}_{j,i}|\r\n\\leq \\text{const.}(1 - \\rho_j),\r\n\\]</span> where <span class=\"math inline\">\\(|\\mathcal{J}_{j,i}|\\)</span>\r\nis the length of <span class=\"math inline\">\\(J_{j,i}\\)</span>.</p>\r\n<p>Since <span class=\"math inline\">\\(E_0\\)</span> is invariant by <span class=\"math inline\">\\(S\\)</span>, <span class=\"math inline\">\\(\\mu(E_0\r\n\\cap \\mathcal{J}_{j,i}) &gt; 0\\)</span> for each <span class=\"math inline\">\\(i = 1, 2, \\ldots, N_j\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(\\delta &gt; 0\\)</span> be\r\nsufficiently small, then by the conditions (i) and (ii), for <span class=\"math inline\">\\(\\theta_1 \\in \\mathcal{J}_{j,i}\\)</span> and <span class=\"math inline\">\\(\\theta_2 \\in \\mathcal{J}_{j,i} \\cap [0,\r\n\\delta]\\)</span>, we have <span class=\"math display\">\\[\r\n|\\theta_1 - \\theta_2| &gt; \\eta \\mod 2\\pi.\r\n\\]</span></p>\r\n<p>Hence, by (iv), for any <span class=\"math inline\">\\(\\theta_2 \\in\r\n\\mathcal{J}_{j,i} \\cap [0, \\delta]\\)</span>, we have <span class=\"math display\">\\[\r\n1 - \\varepsilon &lt; u(z, w) &lt; 1 \\quad \\text{for } z \\in E_0, w \\in\r\nS_{j,i}(\\mathcal{E}_+(\\theta_2)).\r\n\\]</span></p>\r\n<p>Now, let <span class=\"math inline\">\\(\\delta &gt; 0\\)</span> be\r\nsufficiently small, so that <span class=\"math inline\">\\(S_{j,i}(\\mathcal{E}_+(\\theta_2))\\)</span> is\r\ncontained in a small neighborhood of <span class=\"math inline\">\\(\\mathcal{E}_+(\\theta_2)\\)</span> for each <span class=\"math inline\">\\(i = 1, 2, \\ldots, N_j\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(V_{j,i}\\)</span> be the union of\r\nthese neighborhoods, i.e., <span class=\"math inline\">\\(V_{j,i} =\r\n\\bigcup_{k=1}^{N_{j,i}} S_{j,i,k}(\\mathcal{E}_+(\\theta_2))\\)</span>,\r\nwhere <span class=\"math inline\">\\(S_{j,i,k}\\)</span> are distinct\r\nelements of <span class=\"math inline\">\\(G\\)</span> for <span class=\"math inline\">\\(k = 1, 2, \\ldots, N_{j,i}\\)</span>.</p>\r\n<p>By the conditions (iv) and (v), we have <span class=\"math display\">\\[\r\n1 - \\varepsilon &lt; u(z, w) &lt; 1 \\quad \\text{for } z \\in E_0, w \\in\r\nV_{j,i}.\r\n\\]</span></p>\r\n<p>Now, for any <span class=\"math inline\">\\(y &gt; 0\\)</span>, let <span class=\"math inline\">\\(M_{j,i,y}\\)</span> be the measure of the set <span class=\"math inline\">\\(E_0 \\cap \\{ \\theta_1 : \\mu(\\theta_1 \\notin [0,\r\n\\delta] \\cap E_0) &gt; y \\}\\)</span>, then <span class=\"math display\">\\[\r\nM_{j,y} = \\sum_{i=1}^{N_j} M_{j,i,y} = \\lim_{\\delta \\to 0} \\mu(E_0 \\cap\r\n\\{ \\theta_1 : \\mu(\\theta_1 \\notin [0, \\delta] \\cap E_0) &gt; y \\}).\r\n\\]</span></p>\r\n<p>Since <span class=\"math inline\">\\(\\delta &gt; 0\\)</span> is\r\narbitrary, we can conclude that <span class=\"math display\">\\[\r\nM_{j,y} = \\infty \\quad \\text{for any } y &gt; 0. \\quad (16)\r\n\\]</span></p>\r\n<p>Now, let <span class=\"math inline\">\\(M_y = \\lim_{j \\to \\infty}\r\nM_{j,y}\\)</span>, then by (16), we have <span class=\"math display\">\\[\r\nM_y = \\infty \\quad \\text{for any } y &gt; 0. \\quad (17)\r\n\\]</span></p>\r\n<p>Next, we consider the set <span class=\"math display\">\\[\r\nA_y = \\bigcup_{j=1}^{\\infty} \\left( E_0 \\cap \\{ \\theta_1 : \\mu(\\theta_1\r\n\\notin [0, \\delta] \\cap E_0) &gt; y \\} \\right).\r\n\\]</span></p>\r\n<p>By (17), we have <span class=\"math display\">\\[\r\n\\mu(A_y) = \\infty \\quad \\text{for any } y &gt; 0. \\quad (18)\r\n\\]</span></p>\r\n<p>Now, let <span class=\"math inline\">\\(B_y = \\bigcap_{n=1}^{\\infty}\r\nA_{1/n}\\)</span>, then <span class=\"math inline\">\\(B_y\\)</span> is a\r\nsubset of $ E_0 $ where <span class=\"math inline\">\\(\\mu(\\theta_1 \\notin\r\n[0, \\delta] \\cap E_0) = 0\\)</span> for any <span class=\"math inline\">\\(\\delta &gt; 0\\)</span>.</p>\r\n<p>By (iii), we have <span class=\"math display\">\\[\r\n\\lim u(z, w) = 1 \\quad \\text{uniformly on } E_0, \\text{ when } z \\to\r\ne^{i\\theta_1}, w \\to e^{i\\theta_2} \\text{ from the inside of }\r\n\\mathcal{E}_+(\\theta_1), \\mathcal{E}_+(\\theta_2) \\text{ respectively}.\r\n\\]</span></p>\r\n<p>This implies that for any <span class=\"math inline\">\\(\\epsilon &gt;\r\n0\\)</span>, there exists a <span class=\"math inline\">\\(\\delta &gt;\r\n0\\)</span> such that if <span class=\"math inline\">\\(z \\in E_0\\)</span>\r\nand <span class=\"math inline\">\\(w \\in \\mathcal{E}_+(\\theta_2)\\)</span>\r\nwith <span class=\"math inline\">\\(|\\theta_1 - \\theta_2| &lt;\r\n\\delta\\)</span>, then <span class=\"math inline\">\\(|u(z, w) - 1| &lt;\r\n\\epsilon\\)</span>.</p>\r\n<p>Now, consider <span class=\"math inline\">\\(\\epsilon = 1/2\\)</span>,\r\nthere exists <span class=\"math inline\">\\(\\delta &gt; 0\\)</span> such\r\nthat if <span class=\"math inline\">\\(z \\in E_0\\)</span> and <span class=\"math inline\">\\(w \\in \\mathcal{E}_+(\\theta_2)\\)</span> with <span class=\"math inline\">\\(|\\theta_1 - \\theta_2| &lt; \\delta\\)</span>, then\r\n<span class=\"math inline\">\\(|u(z, w) - 1| &lt; 1/2\\)</span>.</p>\r\n<p>This means that <span class=\"math inline\">\\(u(z, w) &gt;\r\n1/2\\)</span>, and hence <span class=\"math inline\">\\(u(z, w) \\neq\r\n0\\)</span>, for all such $ z $ and $ w $.</p>\r\n<p>Therefore, <span class=\"math inline\">\\(B_y\\)</span> is a subset of\r\n<span class=\"math inline\">\\(E_0\\)</span> where <span class=\"math inline\">\\(u(z, w) \\neq 0\\)</span> for all <span class=\"math inline\">\\(z \\in B_y\\)</span> and <span class=\"math inline\">\\(w \\in \\mathcal{E}_+(\\theta_2)\\)</span> with <span class=\"math inline\">\\(|\\theta_1 - \\theta_2| &lt; \\delta\\)</span>.</p>\r\n<p>Since <span class=\"math inline\">\\(B_y\\)</span> is a subset of <span class=\"math inline\">\\(E_0\\)</span> and <span class=\"math inline\">\\(E_0\\)</span> satisfies (iii), we can conclude that\r\n<span class=\"math display\">\\[\r\n\\lim u(z, w) = 1 \\quad \\text{uniformly on } B_y,\r\n\\]</span> when <span class=\"math inline\">\\(z \\to e^{i\\theta_1}\\)</span>\r\nand <span class=\"math inline\">\\(w \\to e^{i\\theta_2}\\)</span> from the\r\ninside of <span class=\"math inline\">\\(\\mathcal{E}_+(\\theta_1)\\)</span>\r\nand <span class=\"math inline\">\\(\\mathcal{E}_+(\\theta_2)\\)</span>\r\nrespectively.</p>\r\n<p>Now, consider <span class=\"math inline\">\\(\\epsilon = 1/2\\)</span>,\r\nthere exists <span class=\"math inline\">\\(N\\)</span> such that for all\r\n<span class=\"math inline\">\\(n &gt; N\\)</span>, we have <span class=\"math inline\">\\(1/n &lt; \\epsilon\\)</span>.</p>\r\n<p>This implies that <span class=\"math inline\">\\(B_y\\)</span> is a\r\nsubset of <span class=\"math inline\">\\(E_0\\)</span> where <span class=\"math display\">\\[\r\n\\lim u(z, w) = 1 \\quad \\text{uniformly on } B_y,\r\n\\]</span> when <span class=\"math inline\">\\(z \\to e^{i\\theta_1}\\)</span>\r\nand <span class=\"math inline\">\\(w \\to e^{i\\theta_2}\\)</span> from the\r\ninside of <span class=\"math inline\">\\(\\mathcal{E}_+(\\theta_1)\\)</span>\r\nand <span class=\"math inline\">\\(\\mathcal{E}_+(\\theta_2)\\)</span>\r\nrespectively, for all <span class=\"math inline\">\\(\\theta_1,\r\n\\theta_2\\)</span>.</p>\r\n<p>Hence, <span class=\"math inline\">\\(u(z, w) = 1\\)</span> on <span class=\"math inline\">\\(B_y\\)</span> for all <span class=\"math inline\">\\(z\\)</span> and <span class=\"math inline\">\\(w\\)</span>.</p>\r\n<p>Now, let <span class=\"math inline\">\\(A\\)</span> be the complement of\r\n<span class=\"math inline\">\\(B_y\\)</span> in <span class=\"math inline\">\\(E_0\\)</span>, then <span class=\"math inline\">\\(\\mu(A) = 0\\)</span>.</p>\r\n<p>This implies that <span class=\"math inline\">\\(u(z, w) = 1\\)</span>\r\nfor almost all <span class=\"math inline\">\\(z\\)</span> and <span class=\"math inline\">\\(w\\)</span> in <span class=\"math inline\">\\(E_0\\)</span>.</p>\r\n<p>Since <span class=\"math inline\">\\(E_0\\)</span> is invariant by <span class=\"math inline\">\\(S\\)</span> and <span class=\"math inline\">\\(u(z,\r\nw)\\)</span> is invariant by <span class=\"math inline\">\\(S\\)</span> (as\r\nshown in (2)), we have <span class=\"math display\">\\[\r\nu(S(z), S(w)) = u(z, w), \\quad \\text{for } S \\in G.\r\n\\]</span></p>\r\n<p>This means that <span class=\"math inline\">\\(u(z, w) = 1\\)</span> for\r\nalmost all <span class=\"math inline\">\\(z\\)</span> and <span class=\"math inline\">\\(w\\)</span> in <span class=\"math inline\">\\(S_1\r\nE_0\\)</span>, where <span class=\"math inline\">\\(S_1\\)</span> is an\r\nelement of <span class=\"math inline\">\\(G\\)</span>.</p>\r\n<p>Hence, by repeating this argument, we can conclude that <span class=\"math inline\">\\(u(z, w) = 1\\)</span> for almost all <span class=\"math inline\">\\(z\\)</span> and <span class=\"math inline\">\\(w\\)</span> in $ G^n E_0 $, where <span class=\"math inline\">\\(G^n\\)</span> is the <span class=\"math inline\">\\(n\\)</span>-th iterate of <span class=\"math inline\">\\(G\\)</span>.</p>\r\n<p>Since <span class=\"math inline\">\\(\\mu(E_0) &gt; 2\\pi -\r\n\\delta\\)</span>, we can choose <span class=\"math inline\">\\(n\\)</span>\r\nsufficiently large such that <span class=\"math inline\">\\(\\mu(G^n E_0)\r\n&gt; 0\\)</span>.</p>\r\n<p>This implies that <span class=\"math inline\">\\(u(z, w) = 1\\)</span>\r\nfor almost all <span class=\"math inline\">\\(z\\)</span> and <span class=\"math inline\">\\(w\\)</span> in a set of positive measure.</p>\r\n<p>But this contradicts the fact that <span class=\"math inline\">\\(\\lim\r\nu(z, w) = F(\\theta_1)\\)</span> for almost all <span class=\"math inline\">\\(\\theta_1\\)</span> in <span class=\"math inline\">\\(\\Theta\\)</span>, as stated in (19).</p>\r\n<p>Therefore, our assumption that there exists a measurable set <span class=\"math inline\">\\(E\\)</span> on <span class=\"math inline\">\\(\\Theta\\)</span> which is invariant by <span class=\"math inline\">\\(S\\)</span> and <span class=\"math inline\">\\(\\mu(E)\r\n&gt; 0\\)</span> must be false.</p>\r\n<p>Hence, <span class=\"math inline\">\\(\\mu(E) = 4\\pi^2\\)</span>.</p>\r\n<p>Thus, the proof of Hopf's ergodic theorem is complete.</p>\r\n<p><strong>Q.E.D.</strong></p>\r\n<p>[1] Hopf, E. Ergodentheorie. Berlin (1937).</p>\r\n<p>[2] Hedlund, G. A. A new proof for a metrically transitive system.\r\nAmer. J. Math. 62 (1940).</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"hopfs-ergodic-theorem\">Hopf's Ergodic Theorem</h1>\r\n<p>Let <span class=\"math inline\">\\(y_1 = e^{i\\theta_1}\\)</span> and\r\n<span class=\"math inline\">\\(y_2 = e^{i\\theta_2}\\)</span> be two points\r\non <span class=\"math inline\">\\(|z| = 1\\)</span>. Then, the pair <span class=\"math inline\">\\((\\theta_1, \\theta_2)\\)</span> can be considered as\r\na point of a torus <span class=\"math inline\">\\(\\Theta: 0 \\leq \\theta_1,\r\n\\theta_2 &lt; 2\\pi\\)</span>.</p>\r\n<p>For a measurable set <span class=\"math inline\">\\(E\\)</span> on <span class=\"math inline\">\\(\\Theta\\)</span>, we define its measure <span class=\"math inline\">\\(\\mu(E)\\)</span> by <span class=\"math inline\">\\(\\mu(E) = \\int\\int d\\theta_1 d\\theta_2\\)</span>, so\r\nthat <span class=\"math inline\">\\(\\mu(\\Theta) = 4\\pi^2\\)</span>.</p>\r\n<p>If <span class=\"math inline\">\\(S_v\\)</span> is any substitution of a\r\nFuchsian group <span class=\"math inline\">\\(G\\)</span> and <span class=\"math inline\">\\(T_v: \\Theta \\to S_v(\\Theta)\\)</span>, then the\r\ntotality of <span class=\"math inline\">\\(\\{ T_v \\}\\)</span> constitute a\r\ngroup <span class=\"math inline\">\\(S = G \\times G\\)</span>.</p>\r\n<h2 id=\"hopfs-ergodic-theorem-theorem-xi.-23.\">Hopf's Ergodic Theorem\r\n(Theorem XI. 23.):</h2>\r\n<p>If <span class=\"math inline\">\\(\\mu(\\Theta) &lt; \\infty\\)</span>, then\r\nthere exists no measurable set <span class=\"math inline\">\\(E\\)</span> on\r\n<span class=\"math inline\">\\(\\Theta\\)</span> which is invariant by <span class=\"math inline\">\\(S\\)</span>, and <span class=\"math inline\">\\(0 &lt;\r\n\\mu(E) &lt; 4\\pi^2\\)</span>.</p>\r\n<p>Hence, if <span class=\"math inline\">\\(\\mu(E) &gt; 0\\)</span>, then\r\n<span class=\"math inline\">\\(\\mu(E) = 4\\pi^2\\)</span>.</p>\r\n<h2 id=\"proof-tsuji\">Proof (Tsuji):</h2>\r\n<p>Suppose that there exists a measurable set <span class=\"math inline\">\\(E\\)</span> on <span class=\"math inline\">\\(\\Theta\\)</span> which is invariant by <span class=\"math inline\">\\(S\\)</span>, and <span class=\"math inline\">\\(\\mu(E)\r\n&gt; 0\\)</span>. We shall prove that <span class=\"math inline\">\\(\\mu(E)\r\n= 4\\pi^{2}\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(f(\\theta_1, \\theta_2)\\)</span> be the\r\ncharacteristic function of $ E $ and put <span class=\"math display\">\\[\r\nu(z, w) = \\frac{1}{4\\pi^2} \\iint_{\\Theta} f(\\theta_1, \\theta_2)\\frac{1-\r\n|z|^{2}}{|z - e^{i\\theta_1}|^2} \\frac{1- |w|^{2}}{|w -\r\ne^{i\\theta_2}|^2}d\\theta_1 d\\theta_2,\r\n\\]</span> where <span class=\"math inline\">\\(\\Theta: |z| &lt; 1, |w| &lt;\r\n1\\)</span>.</p>\r\n<p>Then <span class=\"math inline\">\\(u(z, w)\\)</span> is invariant by\r\n<span class=\"math inline\">\\(S\\)</span> such that <span class=\"math display\">\\[\r\nu(S(z), S(w)) = u(z, w), \\quad \\text{for } S \\in G. \\quad (2)\r\n\\]</span></p>\r\n<p>We denote the Stolz domain: $|(1 - ze^{-i})| &lt; $ by $ (e^{i})$ and\r\n<span class=\"math inline\">\\(\\mathcal{E}_+(\\theta)\\)</span> be its part\r\ncontained in <span class=\"math inline\">\\(|z - e^{i\\theta}| &lt;\r\n\\delta\\)</span>. Then by (Tsuji, Masatsugu. Potential theory in modern\r\nfunction theory. Maruzen, 1959. Theorem IV. 12)[3], for almost all $(_1,\r\n_2) $ on $ <span class=\"math inline\">\\(,\\)</span>$ u(z, w) = f(_1, _2) z\r\ne^{i_1}, w e<sup>{i<em>2} </em>+(e</sup>{i<em>1}), </em>+(_2) . (3)\r\n$$</p>\r\n<p>Let <span class=\"math inline\">\\(E_{\\theta_1}\\)</span> be the section\r\nof <span class=\"math inline\">\\(E\\)</span> by the line <span class=\"math inline\">\\(\\theta = \\text{const.} = \\theta_1\\)</span> and\r\n<span class=\"math inline\">\\(E_{\\theta_2}\\)</span> be that by the line\r\n<span class=\"math inline\">\\(\\theta = \\text{const.} = \\theta_2\\)</span>,\r\nthen <span class=\"math display\">\\[\r\n\\mu(E_{\\theta_1})\\mu(E_{\\theta_2}) &gt; 0, \\quad (4)\r\n\\]</span> where <span class=\"math inline\">\\(\\mu(\\cdot)\\)</span> denotes\r\nthe linear measure.</p>\r\n<p>Since <span class=\"math inline\">\\(\\mu(\\Theta) &lt; \\infty\\)</span>,\r\n<span class=\"math inline\">\\(G\\)</span> is of divergence type (Tsuji,\r\nMasatsugu. Potential theory in modern function theory. Maruzen, 1959.\r\nTheorem XI. 10)[3], so that there exists no measurable set <span class=\"math inline\">\\(e\\)</span> on <span class=\"math inline\">\\(|z| =\r\n1\\)</span> which is invariant by <span class=\"math inline\">\\(G\\)</span>\r\nand <span class=\"math inline\">\\(\\mu(e) &lt; 2\\pi\\)</span>. Hence, if\r\n<span class=\"math inline\">\\(\\mu(E_{\\theta_1}) &gt; 0\\)</span>, then\r\n<span class=\"math inline\">\\(\\mu(E_{\\theta_1}) = 2\\pi\\)</span>.</p>\r\n<p>If <span class=\"math inline\">\\(\\mu(E_{\\theta_2}) = 0\\)</span> on a\r\nset <span class=\"math inline\">\\(e\\)</span> of positive measure in <span class=\"math inline\">\\([0, 2\\pi)\\)</span>, then since by the hypothesis\r\non <span class=\"math inline\">\\(E\\)</span>, such a set <span class=\"math inline\">\\(e\\)</span> is invariant by <span class=\"math inline\">\\(G\\)</span>, <span class=\"math inline\">\\(\\mu(e) =\r\n2\\pi\\)</span>, so that <span class=\"math inline\">\\(\\mu(E_{\\theta_2})\r\n&gt; 0\\)</span> almost everywhere in <span class=\"math inline\">\\([0,\r\n2\\pi)\\)</span>, hence <span class=\"math inline\">\\(\\mu(E) =\r\n4\\pi^2\\)</span>, which is absurd.</p>\r\n<p>Hence, <span class=\"math display\">\\[\r\n\\mu(E_{\\theta_2}) &gt; 0 \\text{ for almost all } \\theta_2 \\in [0, 2\\pi).\r\n\\quad (5)\r\n\\]</span></p>\r\n<p>Hence by Egoroff's theorem, there exists a closed subset <span class=\"math inline\">\\(E_0\\)</span> of <span class=\"math inline\">\\(E\\)</span> which satisfies the following\r\nconditions (i), (ii), (iii), where <span class=\"math inline\">\\(\\delta\r\n&gt; 0\\)</span> and <span class=\"math inline\">\\(\\eta &gt; 0\\)</span> are\r\nsufficiently small constants.</p>\r\n<ol type=\"i\">\r\n<li><p><span class=\"math inline\">\\(E_0\\)</span> lies outside of the\r\nstrip: <span class=\"math inline\">\\(|\\theta_1 - \\theta_2| &lt; \\eta \\mod\r\n2\\pi\\)</span>.</p></li>\r\n<li><p>Let <span class=\"math inline\">\\(E_0^{\\prime}\\)</span> be the\r\nprojection of <span class=\"math inline\">\\(E_0\\)</span> on the <span class=\"math inline\">\\(\\theta_1\\)</span>-axis, then <span class=\"math display\">\\[\r\n\\mu(E_0) &gt; 2\\pi - \\delta \\quad \\text{and} \\quad \\mu(\\theta_1 \\notin\r\n[0, \\eta] \\cap E_0) &gt; 0 \\text{ for any } \\theta_1 \\in [0, 2\\pi).\r\n\\]</span></p></li>\r\n<li><p><span class=\"math inline\">\\(\\lim u(z, w) = 1\\)</span> uniformly\r\non $ E_0 $, when <span class=\"math inline\">\\(z \\to e^{i\\theta_1}, w \\to\r\ne^{i\\theta_2}\\)</span> from the inside of <span class=\"math inline\">\\(\\mathcal{E}_+(\\theta_1),\r\n\\mathcal{E}_+(\\theta_2)\\)</span> respectively.</p></li>\r\n<li><p>When <span class=\"math inline\">\\(z \\in E_0\\)</span> and <span class=\"math inline\">\\(w \\in S_2\\mathcal{E}_+(\\theta_2)\\)</span>, then\r\n<span class=\"math display\">\\[\r\n1 - \\varepsilon &lt; u(z, w) &lt; 1 \\quad \\text{for sufficiently small }\r\n\\varepsilon &gt; 0.\r\n\\]</span></p></li>\r\n<li><p>For any <span class=\"math inline\">\\(y &gt; 0\\)</span>, let <span class=\"math display\">\\[\r\nM_y = \\lim_{\\delta \\to 0} \\mu(E_0 \\cap \\{ \\theta_1 : \\mu(\\theta_1 \\notin\r\n[0, \\delta] \\cap E_0) &gt; y \\}).\r\n\\]</span></p></li>\r\n</ol>\r\n<p>We shall prove that <span class=\"math display\">\\[\r\nM_y = \\infty \\quad (y = 1, 2, \\ldots). \\quad (13)\r\n\\]</span></p>\r\n<p>Let <span class=\"math inline\">\\(K_j = S_j(K_0)\\)</span>, then <span class=\"math inline\">\\(K_j\\)</span> is obtained from <span class=\"math inline\">\\(K_0\\)</span> by a rotation about <span class=\"math inline\">\\(\\theta = 0\\)</span>, so that the circle <span class=\"math inline\">\\(|z| = \\rho_j\\)</span> intersects <span class=\"math inline\">\\(K_j\\)</span> in an arc <span class=\"math inline\">\\(J_j\\)</span> whose projection on <span class=\"math inline\">\\(|z| = 1\\)</span> from <span class=\"math inline\">\\(\\theta = 0\\)</span> is denoted by <span class=\"math inline\">\\(\\mathcal{J}_j\\)</span> then <span class=\"math inline\">\\(|\\mathcal{J}_j| = |\\mathcal{J}_0|\\)</span>, so\r\nthat <span class=\"math display\">\\[\r\n\\text{const.}(1 - \\rho_j)^{|\\mathcal{J}_j|} \\leq |\\mathcal{J}_j| \\leq\r\n\\text{const.}(1 - \\rho_j), \\quad \\text{(14)}\r\n\\]</span> where <span class=\"math inline\">\\(\\text{const.} &gt;\r\n0\\)</span>.</p>\r\n<p>Since <span class=\"math inline\">\\(w \\in E_0\\)</span>, <span class=\"math inline\">\\(\\mu(E_0 \\cap \\mathcal{J}_j) &gt; 0\\)</span> by\r\n(ii) and by the condition (i), if <span class=\"math inline\">\\(\\delta\r\n&gt; 0\\)</span> is sufficiently small, then <span class=\"math display\">\\[\r\n|\\theta_1 - \\theta_2| &gt; \\eta \\mod 2\\pi, \\quad \\text{for } \\theta_1\r\n\\in \\mathcal{J}_j, \\theta_2 \\in \\mathcal{J}_j \\cap [0, \\delta].\r\n\\]</span></p>\r\n<p>Hence, by (iv), for any <span class=\"math inline\">\\(\\theta_2 \\in\r\n\\mathcal{J}_j \\cap [0, \\delta]\\)</span>, we have <span class=\"math display\">\\[\r\n1 - \\varepsilon &lt; u(z, w) &lt; 1 \\quad \\text{for } z \\in E_0, w \\in\r\nS_2\\mathcal{E}_+(\\theta_2).\r\n\\]</span></p>\r\n<p>Now, let <span class=\"math inline\">\\(K_j = \\bigcup_{i=1}^{N_j}\r\nK_{j,i}\\)</span>, where <span class=\"math inline\">\\(K_{j,i} =\r\nS_{j,i}(K_0)\\)</span> and <span class=\"math inline\">\\(S_{j,i}\\)</span>\r\nare distinct elements of <span class=\"math inline\">\\(G\\)</span> for\r\n<span class=\"math inline\">\\(i = 1, 2, \\ldots, N_j\\)</span>. By Lemma 2,\r\nthere exist <span class=\"math inline\">\\(0 &lt; \\varphi_1 &lt; \\varphi_2\r\n&lt; \\ldots &lt; \\varphi_{N_j} &lt; 2\\pi\\)</span> such that the circle\r\n<span class=\"math inline\">\\(|z| = \\rho_j\\)</span> intersects <span class=\"math inline\">\\(K_j\\)</span> in a set of arcs <span class=\"math inline\">\\(J_{j,i}\\)</span> (for $ i = 1, 2, , N_j $).</p>\r\n<p>By (14), we have <span class=\"math display\">\\[\r\n\\text{const.}(1 - \\rho_j)^{|\\mathcal{J}_{j,i}|} \\leq |\\mathcal{J}_{j,i}|\r\n\\leq \\text{const.}(1 - \\rho_j),\r\n\\]</span> where <span class=\"math inline\">\\(|\\mathcal{J}_{j,i}|\\)</span>\r\nis the length of <span class=\"math inline\">\\(J_{j,i}\\)</span>.</p>\r\n<p>Since <span class=\"math inline\">\\(E_0\\)</span> is invariant by <span class=\"math inline\">\\(S\\)</span>, <span class=\"math inline\">\\(\\mu(E_0\r\n\\cap \\mathcal{J}_{j,i}) &gt; 0\\)</span> for each <span class=\"math inline\">\\(i = 1, 2, \\ldots, N_j\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(\\delta &gt; 0\\)</span> be\r\nsufficiently small, then by the conditions (i) and (ii), for <span class=\"math inline\">\\(\\theta_1 \\in \\mathcal{J}_{j,i}\\)</span> and <span class=\"math inline\">\\(\\theta_2 \\in \\mathcal{J}_{j,i} \\cap [0,\r\n\\delta]\\)</span>, we have <span class=\"math display\">\\[\r\n|\\theta_1 - \\theta_2| &gt; \\eta \\mod 2\\pi.\r\n\\]</span></p>\r\n<p>Hence, by (iv), for any <span class=\"math inline\">\\(\\theta_2 \\in\r\n\\mathcal{J}_{j,i} \\cap [0, \\delta]\\)</span>, we have <span class=\"math display\">\\[\r\n1 - \\varepsilon &lt; u(z, w) &lt; 1 \\quad \\text{for } z \\in E_0, w \\in\r\nS_{j,i}(\\mathcal{E}_+(\\theta_2)).\r\n\\]</span></p>\r\n<p>Now, let <span class=\"math inline\">\\(\\delta &gt; 0\\)</span> be\r\nsufficiently small, so that <span class=\"math inline\">\\(S_{j,i}(\\mathcal{E}_+(\\theta_2))\\)</span> is\r\ncontained in a small neighborhood of <span class=\"math inline\">\\(\\mathcal{E}_+(\\theta_2)\\)</span> for each <span class=\"math inline\">\\(i = 1, 2, \\ldots, N_j\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(V_{j,i}\\)</span> be the union of\r\nthese neighborhoods, i.e., <span class=\"math inline\">\\(V_{j,i} =\r\n\\bigcup_{k=1}^{N_{j,i}} S_{j,i,k}(\\mathcal{E}_+(\\theta_2))\\)</span>,\r\nwhere <span class=\"math inline\">\\(S_{j,i,k}\\)</span> are distinct\r\nelements of <span class=\"math inline\">\\(G\\)</span> for <span class=\"math inline\">\\(k = 1, 2, \\ldots, N_{j,i}\\)</span>.</p>\r\n<p>By the conditions (iv) and (v), we have <span class=\"math display\">\\[\r\n1 - \\varepsilon &lt; u(z, w) &lt; 1 \\quad \\text{for } z \\in E_0, w \\in\r\nV_{j,i}.\r\n\\]</span></p>\r\n<p>Now, for any <span class=\"math inline\">\\(y &gt; 0\\)</span>, let <span class=\"math inline\">\\(M_{j,i,y}\\)</span> be the measure of the set <span class=\"math inline\">\\(E_0 \\cap \\{ \\theta_1 : \\mu(\\theta_1 \\notin [0,\r\n\\delta] \\cap E_0) &gt; y \\}\\)</span>, then <span class=\"math display\">\\[\r\nM_{j,y} = \\sum_{i=1}^{N_j} M_{j,i,y} = \\lim_{\\delta \\to 0} \\mu(E_0 \\cap\r\n\\{ \\theta_1 : \\mu(\\theta_1 \\notin [0, \\delta] \\cap E_0) &gt; y \\}).\r\n\\]</span></p>\r\n<p>Since <span class=\"math inline\">\\(\\delta &gt; 0\\)</span> is\r\narbitrary, we can conclude that <span class=\"math display\">\\[\r\nM_{j,y} = \\infty \\quad \\text{for any } y &gt; 0. \\quad (16)\r\n\\]</span></p>\r\n<p>Now, let <span class=\"math inline\">\\(M_y = \\lim_{j \\to \\infty}\r\nM_{j,y}\\)</span>, then by (16), we have <span class=\"math display\">\\[\r\nM_y = \\infty \\quad \\text{for any } y &gt; 0. \\quad (17)\r\n\\]</span></p>\r\n<p>Next, we consider the set <span class=\"math display\">\\[\r\nA_y = \\bigcup_{j=1}^{\\infty} \\left( E_0 \\cap \\{ \\theta_1 : \\mu(\\theta_1\r\n\\notin [0, \\delta] \\cap E_0) &gt; y \\} \\right).\r\n\\]</span></p>\r\n<p>By (17), we have <span class=\"math display\">\\[\r\n\\mu(A_y) = \\infty \\quad \\text{for any } y &gt; 0. \\quad (18)\r\n\\]</span></p>\r\n<p>Now, let <span class=\"math inline\">\\(B_y = \\bigcap_{n=1}^{\\infty}\r\nA_{1/n}\\)</span>, then <span class=\"math inline\">\\(B_y\\)</span> is a\r\nsubset of $ E_0 $ where <span class=\"math inline\">\\(\\mu(\\theta_1 \\notin\r\n[0, \\delta] \\cap E_0) = 0\\)</span> for any <span class=\"math inline\">\\(\\delta &gt; 0\\)</span>.</p>\r\n<p>By (iii), we have <span class=\"math display\">\\[\r\n\\lim u(z, w) = 1 \\quad \\text{uniformly on } E_0, \\text{ when } z \\to\r\ne^{i\\theta_1}, w \\to e^{i\\theta_2} \\text{ from the inside of }\r\n\\mathcal{E}_+(\\theta_1), \\mathcal{E}_+(\\theta_2) \\text{ respectively}.\r\n\\]</span></p>\r\n<p>This implies that for any <span class=\"math inline\">\\(\\epsilon &gt;\r\n0\\)</span>, there exists a <span class=\"math inline\">\\(\\delta &gt;\r\n0\\)</span> such that if <span class=\"math inline\">\\(z \\in E_0\\)</span>\r\nand <span class=\"math inline\">\\(w \\in \\mathcal{E}_+(\\theta_2)\\)</span>\r\nwith <span class=\"math inline\">\\(|\\theta_1 - \\theta_2| &lt;\r\n\\delta\\)</span>, then <span class=\"math inline\">\\(|u(z, w) - 1| &lt;\r\n\\epsilon\\)</span>.</p>\r\n<p>Now, consider <span class=\"math inline\">\\(\\epsilon = 1/2\\)</span>,\r\nthere exists <span class=\"math inline\">\\(\\delta &gt; 0\\)</span> such\r\nthat if <span class=\"math inline\">\\(z \\in E_0\\)</span> and <span class=\"math inline\">\\(w \\in \\mathcal{E}_+(\\theta_2)\\)</span> with <span class=\"math inline\">\\(|\\theta_1 - \\theta_2| &lt; \\delta\\)</span>, then\r\n<span class=\"math inline\">\\(|u(z, w) - 1| &lt; 1/2\\)</span>.</p>\r\n<p>This means that <span class=\"math inline\">\\(u(z, w) &gt;\r\n1/2\\)</span>, and hence <span class=\"math inline\">\\(u(z, w) \\neq\r\n0\\)</span>, for all such $ z $ and $ w $.</p>\r\n<p>Therefore, <span class=\"math inline\">\\(B_y\\)</span> is a subset of\r\n<span class=\"math inline\">\\(E_0\\)</span> where <span class=\"math inline\">\\(u(z, w) \\neq 0\\)</span> for all <span class=\"math inline\">\\(z \\in B_y\\)</span> and <span class=\"math inline\">\\(w \\in \\mathcal{E}_+(\\theta_2)\\)</span> with <span class=\"math inline\">\\(|\\theta_1 - \\theta_2| &lt; \\delta\\)</span>.</p>\r\n<p>Since <span class=\"math inline\">\\(B_y\\)</span> is a subset of <span class=\"math inline\">\\(E_0\\)</span> and <span class=\"math inline\">\\(E_0\\)</span> satisfies (iii), we can conclude that\r\n<span class=\"math display\">\\[\r\n\\lim u(z, w) = 1 \\quad \\text{uniformly on } B_y,\r\n\\]</span> when <span class=\"math inline\">\\(z \\to e^{i\\theta_1}\\)</span>\r\nand <span class=\"math inline\">\\(w \\to e^{i\\theta_2}\\)</span> from the\r\ninside of <span class=\"math inline\">\\(\\mathcal{E}_+(\\theta_1)\\)</span>\r\nand <span class=\"math inline\">\\(\\mathcal{E}_+(\\theta_2)\\)</span>\r\nrespectively.</p>\r\n<p>Now, consider <span class=\"math inline\">\\(\\epsilon = 1/2\\)</span>,\r\nthere exists <span class=\"math inline\">\\(N\\)</span> such that for all\r\n<span class=\"math inline\">\\(n &gt; N\\)</span>, we have <span class=\"math inline\">\\(1/n &lt; \\epsilon\\)</span>.</p>\r\n<p>This implies that <span class=\"math inline\">\\(B_y\\)</span> is a\r\nsubset of <span class=\"math inline\">\\(E_0\\)</span> where <span class=\"math display\">\\[\r\n\\lim u(z, w) = 1 \\quad \\text{uniformly on } B_y,\r\n\\]</span> when <span class=\"math inline\">\\(z \\to e^{i\\theta_1}\\)</span>\r\nand <span class=\"math inline\">\\(w \\to e^{i\\theta_2}\\)</span> from the\r\ninside of <span class=\"math inline\">\\(\\mathcal{E}_+(\\theta_1)\\)</span>\r\nand <span class=\"math inline\">\\(\\mathcal{E}_+(\\theta_2)\\)</span>\r\nrespectively, for all <span class=\"math inline\">\\(\\theta_1,\r\n\\theta_2\\)</span>.</p>\r\n<p>Hence, <span class=\"math inline\">\\(u(z, w) = 1\\)</span> on <span class=\"math inline\">\\(B_y\\)</span> for all <span class=\"math inline\">\\(z\\)</span> and <span class=\"math inline\">\\(w\\)</span>.</p>\r\n<p>Now, let <span class=\"math inline\">\\(A\\)</span> be the complement of\r\n<span class=\"math inline\">\\(B_y\\)</span> in <span class=\"math inline\">\\(E_0\\)</span>, then <span class=\"math inline\">\\(\\mu(A) = 0\\)</span>.</p>\r\n<p>This implies that <span class=\"math inline\">\\(u(z, w) = 1\\)</span>\r\nfor almost all <span class=\"math inline\">\\(z\\)</span> and <span class=\"math inline\">\\(w\\)</span> in <span class=\"math inline\">\\(E_0\\)</span>.</p>\r\n<p>Since <span class=\"math inline\">\\(E_0\\)</span> is invariant by <span class=\"math inline\">\\(S\\)</span> and <span class=\"math inline\">\\(u(z,\r\nw)\\)</span> is invariant by <span class=\"math inline\">\\(S\\)</span> (as\r\nshown in (2)), we have <span class=\"math display\">\\[\r\nu(S(z), S(w)) = u(z, w), \\quad \\text{for } S \\in G.\r\n\\]</span></p>\r\n<p>This means that <span class=\"math inline\">\\(u(z, w) = 1\\)</span> for\r\nalmost all <span class=\"math inline\">\\(z\\)</span> and <span class=\"math inline\">\\(w\\)</span> in <span class=\"math inline\">\\(S_1\r\nE_0\\)</span>, where <span class=\"math inline\">\\(S_1\\)</span> is an\r\nelement of <span class=\"math inline\">\\(G\\)</span>.</p>\r\n<p>Hence, by repeating this argument, we can conclude that <span class=\"math inline\">\\(u(z, w) = 1\\)</span> for almost all <span class=\"math inline\">\\(z\\)</span> and <span class=\"math inline\">\\(w\\)</span> in $ G^n E_0 $, where <span class=\"math inline\">\\(G^n\\)</span> is the <span class=\"math inline\">\\(n\\)</span>-th iterate of <span class=\"math inline\">\\(G\\)</span>.</p>\r\n<p>Since <span class=\"math inline\">\\(\\mu(E_0) &gt; 2\\pi -\r\n\\delta\\)</span>, we can choose <span class=\"math inline\">\\(n\\)</span>\r\nsufficiently large such that <span class=\"math inline\">\\(\\mu(G^n E_0)\r\n&gt; 0\\)</span>.</p>\r\n<p>This implies that <span class=\"math inline\">\\(u(z, w) = 1\\)</span>\r\nfor almost all <span class=\"math inline\">\\(z\\)</span> and <span class=\"math inline\">\\(w\\)</span> in a set of positive measure.</p>\r\n<p>But this contradicts the fact that <span class=\"math inline\">\\(\\lim\r\nu(z, w) = F(\\theta_1)\\)</span> for almost all <span class=\"math inline\">\\(\\theta_1\\)</span> in <span class=\"math inline\">\\(\\Theta\\)</span>, as stated in (19).</p>\r\n<p>Therefore, our assumption that there exists a measurable set <span class=\"math inline\">\\(E\\)</span> on <span class=\"math inline\">\\(\\Theta\\)</span> which is invariant by <span class=\"math inline\">\\(S\\)</span> and <span class=\"math inline\">\\(\\mu(E)\r\n&gt; 0\\)</span> must be false.</p>\r\n<p>Hence, <span class=\"math inline\">\\(\\mu(E) = 4\\pi^2\\)</span>.</p>\r\n<p>Thus, the proof of Hopf's ergodic theorem is complete.</p>\r\n<p><strong>Q.E.D.</strong></p>\r\n<p>[1] Hopf, E. Ergodentheorie. Berlin (1937).</p>\r\n<p>[2] Hedlund, G. A. A new proof for a metrically transitive system.\r\nAmer. J. Math. 62 (1940).</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Wed Apr 10 2024 19:18:26 GMT+0800 (中国标准时间)","title":"Hopf's Ergodic Theorem","path":"2024/01/17/Hopf ergodic theorem/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2024-01-17T05:48:02.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2024-01-17T05:48:02.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Sevaral Complex Variables > Fuchsian Group","tags":["Sevaral Complex Variables"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Hilbert's Nullstellensatz","date":"2023-03-22T23:51:28.000Z","link":"","author":"Haoming Wang","mathjax":true,"top":true,"sticky":100,"toc":false,"_content":"\n\n\n## Theorem 1 (Weak form)\n\nLet $X$ be an affine algebraic variety in $k^{n}$, where $k$ is an algebraically closed field, and let $I(X)$ be the ideal of $X$ in the polynomial ring $k[t_{1}, \\cdots, t_{n}]$. If $I(X) \\neq (1)$ then $X$ is not empty. Every maximal ideal in the ring $k[t_{1}, \\cdots, t_{n}]$ is of the form $(t_{1} - a_{1},\\cdots,t_{n}- a_{n})$ where $a_{i}\\in k$.\n\n\n\n## Theorem 2 (Strong form)\n\nLet $k$ be an algebraically closed field, let $A$ denote the polynomial ring $k[t_{1}, \\cdots, t_{n}]$ and let $\\mathsf{a}$ be an ideal in $A$. Let $V$ be the variety in $k^{n}$ defined by the ideal $\\mathsf{a}$, so that $V$ is the set of all $x = (x_{1}, \\cdots, x_{n}) \\in k^{n}$ such that $f(x) = 0$ for all $f \\in \\mathsf{a}$. Let $I(V)$ be the ideal of $V$, i.e. the ideal of all polynomials $g \\in A$ such that $g(x) = 0$ for all $x \\in V$. Then $I(V) = r(\\mathsf{a})$.\n\n## Proof\n\nIt is clear that $r(a) \\subseteq I(V)$. Conversely, let $f \\notin r(\\mathsf{a})$, then there is a prime ideal $\\mathsf{p}$ containing $\\mathsf{a}$ such that $f\\notin \\mathsf{p}$. Let $\\bar{f}$ be the image of $f$ in $B = A/\\mathsf{p}$, let $C = B_{f} = B[1/\\bar{f}]$, and let $\\mathsf{m}$ be a maximal ideal of $C$. Since $C$ is a finitely generated, $k$-algebra we have $C/\\mathsf{m} \\cong k$, by (7.9)[1]. The images $x_{i}$ in $C/\\mathsf{m}$ of the generators $t_{i}$ of $A$ thus define a point $x = (x_{1} \\cdots, x_{n}) \\in k^{n}$, and the construction shows that $x \\in V$ and $f(x) \\neq 0$.\n\n\n\n## Corollary 1\nLet $k$ be a field and $B$ a finitely generated $k$-algebra. If $B$ is a\nfield then it is a finite algebraic extension of $k$.\n\n## Corollary 2\nLet $k$ be a field and let $B$ be a finitely generated $k$-algebra. Suppose that $B$ is a field. Then $B$ is a finite algebraic extension of k.\n\n## Corollary 3\nLet $k$ be afield, $A$ a finitely generated $k$-algebra. Let $\\mathsf{m}$ be a maximal ideal of $A$. Then the field $A/\\mathsf{m}$ is a finite algebraic extension of $k$. In particular, if $k$ is algebraically closed then $A/\\mathsf{m} \\cong k$.\n\n\n# Reference \n\n[1] Michael Atiyah. Introduction to commutative algebra. CRC Press, 2018.\n\n\n","source":"_posts/Hilbert's Nullstellensatz.md","raw":"---\ntitle: Hilbert's Nullstellensatz\ndate: 2023-03-23 07:51:28\nlink: \nauthor: Haoming Wang\ntags: \ncategories:\n   - [Commutative Algebra, Algebraic Geometry]\nmathjax: true\ntop: true\nsticky: 100\ntoc: false\n---\n\n\n\n## Theorem 1 (Weak form)\n\nLet $X$ be an affine algebraic variety in $k^{n}$, where $k$ is an algebraically closed field, and let $I(X)$ be the ideal of $X$ in the polynomial ring $k[t_{1}, \\cdots, t_{n}]$. If $I(X) \\neq (1)$ then $X$ is not empty. Every maximal ideal in the ring $k[t_{1}, \\cdots, t_{n}]$ is of the form $(t_{1} - a_{1},\\cdots,t_{n}- a_{n})$ where $a_{i}\\in k$.\n\n\n\n## Theorem 2 (Strong form)\n\nLet $k$ be an algebraically closed field, let $A$ denote the polynomial ring $k[t_{1}, \\cdots, t_{n}]$ and let $\\mathsf{a}$ be an ideal in $A$. Let $V$ be the variety in $k^{n}$ defined by the ideal $\\mathsf{a}$, so that $V$ is the set of all $x = (x_{1}, \\cdots, x_{n}) \\in k^{n}$ such that $f(x) = 0$ for all $f \\in \\mathsf{a}$. Let $I(V)$ be the ideal of $V$, i.e. the ideal of all polynomials $g \\in A$ such that $g(x) = 0$ for all $x \\in V$. Then $I(V) = r(\\mathsf{a})$.\n\n## Proof\n\nIt is clear that $r(a) \\subseteq I(V)$. Conversely, let $f \\notin r(\\mathsf{a})$, then there is a prime ideal $\\mathsf{p}$ containing $\\mathsf{a}$ such that $f\\notin \\mathsf{p}$. Let $\\bar{f}$ be the image of $f$ in $B = A/\\mathsf{p}$, let $C = B_{f} = B[1/\\bar{f}]$, and let $\\mathsf{m}$ be a maximal ideal of $C$. Since $C$ is a finitely generated, $k$-algebra we have $C/\\mathsf{m} \\cong k$, by (7.9)[1]. The images $x_{i}$ in $C/\\mathsf{m}$ of the generators $t_{i}$ of $A$ thus define a point $x = (x_{1} \\cdots, x_{n}) \\in k^{n}$, and the construction shows that $x \\in V$ and $f(x) \\neq 0$.\n\n\n\n## Corollary 1\nLet $k$ be a field and $B$ a finitely generated $k$-algebra. If $B$ is a\nfield then it is a finite algebraic extension of $k$.\n\n## Corollary 2\nLet $k$ be a field and let $B$ be a finitely generated $k$-algebra. Suppose that $B$ is a field. Then $B$ is a finite algebraic extension of k.\n\n## Corollary 3\nLet $k$ be afield, $A$ a finitely generated $k$-algebra. Let $\\mathsf{m}$ be a maximal ideal of $A$. Then the field $A/\\mathsf{m}$ is a finite algebraic extension of $k$. In particular, if $k$ is algebraically closed then $A/\\mathsf{m} \\cong k$.\n\n\n# Reference \n\n[1] Michael Atiyah. Introduction to commutative algebra. CRC Press, 2018.\n\n\n","slug":"Hilbert's Nullstellensatz","published":1,"updated":"2024-02-25T15:11:07.050Z","comments":1,"layout":"post","photos":[],"_id":"cmfwcr5s2001fm8nxcrj7dy0x","content":"<h2 id=\"theorem-1-weak-form\">Theorem 1 (Weak form)</h2>\r\n<p>Let <span class=\"math inline\">\\(X\\)</span> be an affine algebraic\r\nvariety in <span class=\"math inline\">\\(k^{n}\\)</span>, where <span class=\"math inline\">\\(k\\)</span> is an algebraically closed field, and\r\nlet <span class=\"math inline\">\\(I(X)\\)</span> be the ideal of <span class=\"math inline\">\\(X\\)</span> in the polynomial ring <span class=\"math inline\">\\(k[t_{1}, \\cdots, t_{n}]\\)</span>. If <span class=\"math inline\">\\(I(X) \\neq (1)\\)</span> then <span class=\"math inline\">\\(X\\)</span> is not empty. Every maximal ideal in\r\nthe ring <span class=\"math inline\">\\(k[t_{1}, \\cdots, t_{n}]\\)</span> is\r\nof the form <span class=\"math inline\">\\((t_{1} - a_{1},\\cdots,t_{n}-\r\na_{n})\\)</span> where <span class=\"math inline\">\\(a_{i}\\in\r\nk\\)</span>.</p>\r\n<h2 id=\"theorem-2-strong-form\">Theorem 2 (Strong form)</h2>\r\n<p>Let <span class=\"math inline\">\\(k\\)</span> be an algebraically closed\r\nfield, let <span class=\"math inline\">\\(A\\)</span> denote the polynomial\r\nring <span class=\"math inline\">\\(k[t_{1}, \\cdots, t_{n}]\\)</span> and\r\nlet <span class=\"math inline\">\\(\\mathsf{a}\\)</span> be an ideal in <span class=\"math inline\">\\(A\\)</span>. Let <span class=\"math inline\">\\(V\\)</span> be the variety in <span class=\"math inline\">\\(k^{n}\\)</span> defined by the ideal <span class=\"math inline\">\\(\\mathsf{a}\\)</span>, so that <span class=\"math inline\">\\(V\\)</span> is the set of all <span class=\"math inline\">\\(x = (x_{1}, \\cdots, x_{n}) \\in k^{n}\\)</span> such\r\nthat <span class=\"math inline\">\\(f(x) = 0\\)</span> for all <span class=\"math inline\">\\(f \\in \\mathsf{a}\\)</span>. Let <span class=\"math inline\">\\(I(V)\\)</span> be the ideal of <span class=\"math inline\">\\(V\\)</span>, i.e. the ideal of all polynomials\r\n<span class=\"math inline\">\\(g \\in A\\)</span> such that <span class=\"math inline\">\\(g(x) = 0\\)</span> for all <span class=\"math inline\">\\(x \\in V\\)</span>. Then <span class=\"math inline\">\\(I(V) = r(\\mathsf{a})\\)</span>.</p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<p>It is clear that <span class=\"math inline\">\\(r(a) \\subseteq\r\nI(V)\\)</span>. Conversely, let <span class=\"math inline\">\\(f \\notin\r\nr(\\mathsf{a})\\)</span>, then there is a prime ideal <span class=\"math inline\">\\(\\mathsf{p}\\)</span> containing <span class=\"math inline\">\\(\\mathsf{a}\\)</span> such that <span class=\"math inline\">\\(f\\notin \\mathsf{p}\\)</span>. Let <span class=\"math inline\">\\(\\bar{f}\\)</span> be the image of <span class=\"math inline\">\\(f\\)</span> in <span class=\"math inline\">\\(B =\r\nA/\\mathsf{p}\\)</span>, let <span class=\"math inline\">\\(C = B_{f} =\r\nB[1/\\bar{f}]\\)</span>, and let <span class=\"math inline\">\\(\\mathsf{m}\\)</span> be a maximal ideal of <span class=\"math inline\">\\(C\\)</span>. Since <span class=\"math inline\">\\(C\\)</span> is a finitely generated, <span class=\"math inline\">\\(k\\)</span>-algebra we have <span class=\"math inline\">\\(C/\\mathsf{m} \\cong k\\)</span>, by (7.9)[1]. The\r\nimages <span class=\"math inline\">\\(x_{i}\\)</span> in <span class=\"math inline\">\\(C/\\mathsf{m}\\)</span> of the generators <span class=\"math inline\">\\(t_{i}\\)</span> of <span class=\"math inline\">\\(A\\)</span> thus define a point <span class=\"math inline\">\\(x = (x_{1} \\cdots, x_{n}) \\in k^{n}\\)</span>, and\r\nthe construction shows that <span class=\"math inline\">\\(x \\in V\\)</span>\r\nand <span class=\"math inline\">\\(f(x) \\neq 0\\)</span>.</p>\r\n<h2 id=\"corollary-1\">Corollary 1</h2>\r\n<p>Let <span class=\"math inline\">\\(k\\)</span> be a field and <span class=\"math inline\">\\(B\\)</span> a finitely generated <span class=\"math inline\">\\(k\\)</span>-algebra. If <span class=\"math inline\">\\(B\\)</span> is a field then it is a finite\r\nalgebraic extension of <span class=\"math inline\">\\(k\\)</span>.</p>\r\n<h2 id=\"corollary-2\">Corollary 2</h2>\r\n<p>Let <span class=\"math inline\">\\(k\\)</span> be a field and let <span class=\"math inline\">\\(B\\)</span> be a finitely generated <span class=\"math inline\">\\(k\\)</span>-algebra. Suppose that <span class=\"math inline\">\\(B\\)</span> is a field. Then <span class=\"math inline\">\\(B\\)</span> is a finite algebraic extension of\r\nk.</p>\r\n<h2 id=\"corollary-3\">Corollary 3</h2>\r\n<p>Let <span class=\"math inline\">\\(k\\)</span> be afield, <span class=\"math inline\">\\(A\\)</span> a finitely generated <span class=\"math inline\">\\(k\\)</span>-algebra. Let <span class=\"math inline\">\\(\\mathsf{m}\\)</span> be a maximal ideal of <span class=\"math inline\">\\(A\\)</span>. Then the field <span class=\"math inline\">\\(A/\\mathsf{m}\\)</span> is a finite algebraic\r\nextension of <span class=\"math inline\">\\(k\\)</span>. In particular, if\r\n<span class=\"math inline\">\\(k\\)</span> is algebraically closed then\r\n<span class=\"math inline\">\\(A/\\mathsf{m} \\cong k\\)</span>.</p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Michael Atiyah. Introduction to commutative algebra. CRC Press,\r\n2018.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"theorem-1-weak-form\">Theorem 1 (Weak form)</h2>\r\n<p>Let <span class=\"math inline\">\\(X\\)</span> be an affine algebraic\r\nvariety in <span class=\"math inline\">\\(k^{n}\\)</span>, where <span class=\"math inline\">\\(k\\)</span> is an algebraically closed field, and\r\nlet <span class=\"math inline\">\\(I(X)\\)</span> be the ideal of <span class=\"math inline\">\\(X\\)</span> in the polynomial ring <span class=\"math inline\">\\(k[t_{1}, \\cdots, t_{n}]\\)</span>. If <span class=\"math inline\">\\(I(X) \\neq (1)\\)</span> then <span class=\"math inline\">\\(X\\)</span> is not empty. Every maximal ideal in\r\nthe ring <span class=\"math inline\">\\(k[t_{1}, \\cdots, t_{n}]\\)</span> is\r\nof the form <span class=\"math inline\">\\((t_{1} - a_{1},\\cdots,t_{n}-\r\na_{n})\\)</span> where <span class=\"math inline\">\\(a_{i}\\in\r\nk\\)</span>.</p>\r\n<h2 id=\"theorem-2-strong-form\">Theorem 2 (Strong form)</h2>\r\n<p>Let <span class=\"math inline\">\\(k\\)</span> be an algebraically closed\r\nfield, let <span class=\"math inline\">\\(A\\)</span> denote the polynomial\r\nring <span class=\"math inline\">\\(k[t_{1}, \\cdots, t_{n}]\\)</span> and\r\nlet <span class=\"math inline\">\\(\\mathsf{a}\\)</span> be an ideal in <span class=\"math inline\">\\(A\\)</span>. Let <span class=\"math inline\">\\(V\\)</span> be the variety in <span class=\"math inline\">\\(k^{n}\\)</span> defined by the ideal <span class=\"math inline\">\\(\\mathsf{a}\\)</span>, so that <span class=\"math inline\">\\(V\\)</span> is the set of all <span class=\"math inline\">\\(x = (x_{1}, \\cdots, x_{n}) \\in k^{n}\\)</span> such\r\nthat <span class=\"math inline\">\\(f(x) = 0\\)</span> for all <span class=\"math inline\">\\(f \\in \\mathsf{a}\\)</span>. Let <span class=\"math inline\">\\(I(V)\\)</span> be the ideal of <span class=\"math inline\">\\(V\\)</span>, i.e. the ideal of all polynomials\r\n<span class=\"math inline\">\\(g \\in A\\)</span> such that <span class=\"math inline\">\\(g(x) = 0\\)</span> for all <span class=\"math inline\">\\(x \\in V\\)</span>. Then <span class=\"math inline\">\\(I(V) = r(\\mathsf{a})\\)</span>.</p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<p>It is clear that <span class=\"math inline\">\\(r(a) \\subseteq\r\nI(V)\\)</span>. Conversely, let <span class=\"math inline\">\\(f \\notin\r\nr(\\mathsf{a})\\)</span>, then there is a prime ideal <span class=\"math inline\">\\(\\mathsf{p}\\)</span> containing <span class=\"math inline\">\\(\\mathsf{a}\\)</span> such that <span class=\"math inline\">\\(f\\notin \\mathsf{p}\\)</span>. Let <span class=\"math inline\">\\(\\bar{f}\\)</span> be the image of <span class=\"math inline\">\\(f\\)</span> in <span class=\"math inline\">\\(B =\r\nA/\\mathsf{p}\\)</span>, let <span class=\"math inline\">\\(C = B_{f} =\r\nB[1/\\bar{f}]\\)</span>, and let <span class=\"math inline\">\\(\\mathsf{m}\\)</span> be a maximal ideal of <span class=\"math inline\">\\(C\\)</span>. Since <span class=\"math inline\">\\(C\\)</span> is a finitely generated, <span class=\"math inline\">\\(k\\)</span>-algebra we have <span class=\"math inline\">\\(C/\\mathsf{m} \\cong k\\)</span>, by (7.9)[1]. The\r\nimages <span class=\"math inline\">\\(x_{i}\\)</span> in <span class=\"math inline\">\\(C/\\mathsf{m}\\)</span> of the generators <span class=\"math inline\">\\(t_{i}\\)</span> of <span class=\"math inline\">\\(A\\)</span> thus define a point <span class=\"math inline\">\\(x = (x_{1} \\cdots, x_{n}) \\in k^{n}\\)</span>, and\r\nthe construction shows that <span class=\"math inline\">\\(x \\in V\\)</span>\r\nand <span class=\"math inline\">\\(f(x) \\neq 0\\)</span>.</p>\r\n<h2 id=\"corollary-1\">Corollary 1</h2>\r\n<p>Let <span class=\"math inline\">\\(k\\)</span> be a field and <span class=\"math inline\">\\(B\\)</span> a finitely generated <span class=\"math inline\">\\(k\\)</span>-algebra. If <span class=\"math inline\">\\(B\\)</span> is a field then it is a finite\r\nalgebraic extension of <span class=\"math inline\">\\(k\\)</span>.</p>\r\n<h2 id=\"corollary-2\">Corollary 2</h2>\r\n<p>Let <span class=\"math inline\">\\(k\\)</span> be a field and let <span class=\"math inline\">\\(B\\)</span> be a finitely generated <span class=\"math inline\">\\(k\\)</span>-algebra. Suppose that <span class=\"math inline\">\\(B\\)</span> is a field. Then <span class=\"math inline\">\\(B\\)</span> is a finite algebraic extension of\r\nk.</p>\r\n<h2 id=\"corollary-3\">Corollary 3</h2>\r\n<p>Let <span class=\"math inline\">\\(k\\)</span> be afield, <span class=\"math inline\">\\(A\\)</span> a finitely generated <span class=\"math inline\">\\(k\\)</span>-algebra. Let <span class=\"math inline\">\\(\\mathsf{m}\\)</span> be a maximal ideal of <span class=\"math inline\">\\(A\\)</span>. Then the field <span class=\"math inline\">\\(A/\\mathsf{m}\\)</span> is a finite algebraic\r\nextension of <span class=\"math inline\">\\(k\\)</span>. In particular, if\r\n<span class=\"math inline\">\\(k\\)</span> is algebraically closed then\r\n<span class=\"math inline\">\\(A/\\mathsf{m} \\cong k\\)</span>.</p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Michael Atiyah. Introduction to commutative algebra. CRC Press,\r\n2018.</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Feb 25 2024 23:11:07 GMT+0800 (中国标准时间)","title":"Hilbert's Nullstellensatz","path":"2023/03/23/Hilbert's Nullstellensatz/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-03-22T23:51:28.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-03-22T23:51:28.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Commutative Algebra > Algebraic Geometry","tags":[],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Nevanlinna Theory (I)","date":"2023-03-27T10:40:09.000Z","mathjax":true,"_content":"\n## First Main Theorem\n\nFor any function $w(z)$ meromorphic in the disk\n$|z| < R < \\infty$, a function $T(r, w)$ can be defined for $0 < r < R$ so that \n\n1. $T(r)$ is an increasing function of $r$ and a convex function of $\\log r$.\n\n2. If $a$ denotes any complex number that is independent of $z$, finite or infinite, then is\n$$m(r, a) + N(r, a) = T (r) + O(1). \\tag{I}$$\nwhere the two terms on the left of relation (I) are\nnonnegative.\n\n\n## Lemma 1\nIf $\\alpha$ is a nonnegative number, let $$\\log^{+} \\alpha = \\begin{cases}\\log \\alpha, & \\alpha > 1\\\\\n0, & 0 < \\alpha \\leq 1\\end{cases}$$ be the larger of the numbers $\\log \\alpha$ and $0$; it follows that\n$$\n\\begin{aligned}\n\\log \\alpha = \\log^{+} \\alpha - \\log^{+} \\frac{1}{\\alpha}\\\\\n |\\log \\alpha| = \\log^{+} \\alpha + \\log^{+} \\frac{1}{\\alpha}\n\\end{aligned}\n$$\n\n\n## Lemma 2\nNotation as above lemma 1, and further, as is easily confirmed,\n$$\n\\begin{equation}\n\\begin{aligned}\n\\log^{+} \\alpha_{1}\\cdot \\alpha_{2}\\cdots \\alpha_{p} \\leq \\sum_{i=1}^{p} \\log^{+} {\\alpha_{i}}\\\\\n\\log^{+} \\sum_{i=1}^{p} {\\alpha_{i}} \\leq \\sum_{i=1}^{p} \\log^{+} \\alpha_{i} + \\log p\n\\end{aligned}\n\\end{equation}\n$$\n\n## Proof of Theorem 1\n\nIn [Jensen's formula](https://en.wikipedia.org/wiki/Jensen%27s_formula), we now set $\\log |w| = \\log^{+} |w| - \\log |\\frac{1}{w}|$ and for short write\n\n\n$$\\begin{aligned}N(r,a,w) =& \\int_{0}^{r} \\frac{n(t,a) - n(0,a)}{t} dt + n(0,a) \\log r\\\\\nm(r, a, w) =& \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\log^{+} \\left|\\frac{1}{w(re^{i\\varphi}) -a }\\right|d\\varphi\n\\end{aligned}$$\n\n$$\\begin{aligned}N(r,\\infty,w) =& \\int_{0}^{r} \\frac{n(t,\\infty) - n(0,\\infty)}{t} dt + n(0,\\infty) \\log r\\\\\nm(r, \\infty, w) =& \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\log^{+} \\left|w(re^{i\\varphi})\\right|d\\varphi\n\\end{aligned}$$\n\nwhere $n(r, a)$ is the number of roots of the equation $w- a =  0$ in the disk $|z|\\leq r$ \n\nJensen's formula then becomes\n\n$$m(r, w) + N(r, w) = m (r, \\frac{1}{w}) + N (r,\\frac{1}{w}) +\\log|c_{\\lambda}|$$\n\n\nwhere $c_{\\lambda}$ is the first nonvanishing coefficient in the Laurent expansion of $w-a$ at the origin $z = 0$. \n\nThe result is then\n\n$$m(r, w - a) + N(r, w - a) = m (r, \\frac{1}{w-a}) + N (r, \\frac{1}{w-a}) + \\text{const.}$$\n\nBut\n$N(r, w - a) = N(r, w)$\n\nand by Lemma 2\n\n$$\\left| m(r, w- a)- m(r, w) \\right| < \\log^{+} |a|+ \\log 2$$\n\nso we conclude from (2.3) that\n\n$$m(r, a) + N(r, a) = m(r, \\infty) + N(r,\\infty) + \\varphi(r, a),$$\n\nIn addition we set\n$T(r, w) = T(r) = m(r, \\infty) + N(r, \\infty)$,\nThis is the desired results. $\\square$\n\n## Second Main Theorem\n\n1. For $|z| < R < \\infty$ let $w(z)$ be a nonconstant\nmeromorphic function. If $w_{1}, \\cdots , w_{q} (q \\geq 1)$ are mutually distinct finite or infinite complex numbers, then for $0 \\leq r < R$\n\n$$\\sum m(r, \\omega_{\\nu}) < 2 T(r) - N_{1}(r) + S(r)$$\n\n2. the remainder term satisfies\nthe following conditions:\n\nIf $R = \\infty$, then\n$$S(r) = O \\left\\{\\log \\left[rT(r)\\right]\\right\\}$$\nwith at most the exception of a set of values $\\{r\\}$ of finite total measure\n\nIf $R = 1$, then\n\n$$S(r) = O \\left\\{\\frac{1}{1-r}T(r)\\right\\}$$\n\nwith at most the exception of a set of values $\\{r\\}$ for which the variation of $\\frac{1}{1-r}$ is fintte\n\n\n## Proof \n\nSuppose, therefore, that $w(z) = c_{0} + c_{k}z^{k} + \\cdots (c_{0}\\neq 0, c_{k} \\neq 0)$ is a function that is meromorphic for $|z| < R \\leq \\infty$, and let $a_{1}, \\cdots, a_{p}$ be a system of $p \\geq 2$ different finite complex numbers.\n\nWe first compare the proximity functions $m(r, w)$ and $m(r, w^{\\prime})$ with one another. By means of the elementary inequalities (Lemma 2 in (I)), one finds immediately that\n\n$$\\begin{equation}\nm(r,w) = m (r,w^{\\prime}\\frac{w}{w^{\\prime}}) \\leq m (r,w^{\\prime}) + m (r,\\frac{w}{w^{\\prime}})\n\\end{equation}$$\n\nTo estimate the mean value $m ( r, \\frac{1}{w^{\\prime}})$ , consider the sum\n\n$$f(z) = \\sum_{\\nu=1}^{p} \\frac{1}{w(z) - a_{\\nu}}$$\n\nWe have\n\n\n$$\\begin{equation}\nm(r,f) = m (r,fw^{\\prime}\\frac{1}{w^{\\prime}}) \\leq m (r,\\frac{1}{w^{\\prime}}) + m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}})\n\\end{equation}$$\n\n\nOn the other hand, for a given $\\mu$ ($\\mu = 1, \\cdots , p$)\n\n$$f = \\frac{1}{w - a_{\\mu}}\\left(1 + \\sum_{\\nu\\neq\\mu} \\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right)$$\n\nIf $\\delta = \\min (|a_{h} -\na_{k}|, 1) (h \\neq k)$, then at every point $z$ where\n\n$$\\begin{equation}\n\\left|w(z) - a_{\\mu}\\right| < \\frac{\\delta}{2p} \\left(\\leq \\frac{1}{2p}\\right) \n\\end{equation}$$\n\nfor $\\nu \\neq \\mu$\n$$\\left|w - a_{\\nu}\\right| \\geq \\left|a_{\\mu} - a_{\\nu}\\right| - \\left|w - a_{\\mu}\\right| > \\delta - \\frac{\\delta}{2p} \\geq \\frac{3\\delta}{4}$$\n\nand hence\n$$\\sum_{\\nu\\neq\\mu} \\left|\\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right| < (p-1) \\frac{2}{3p} < \\frac{2}{3}$$\n\nso that\n$$\\left|1 + \\sum_{\\nu\\neq\\mu} \\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right| > \\frac{1}{3}$$\n\nFrom this it follows that\n$$\\log^{+}\\left|f(z)\\right| > \\log^{+}\\left|\\frac{1}{w - a_{\\mu}}\\right| - \\log 3$$\n\nat every point z where condition (4) is satisfied.\n\nThe arcs determined on the circle by (4) are disjoint for different\nvalues of $p$, and therefore one concludes that\n\n$$\\begin{aligned}\nm(r,f) \\geq & \\frac{1}{2\\pi} \\sum_{\\mu =1}^{p} \\int_{|w - a_{\\mu}| < \\frac{\\delta}{2p}} \\log^{+} |f(re^{i\\varphi})| d \\varphi\\\\\n< & \\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| < \\frac{\\delta}{2p}} \\left(\\log^{+} \\left|\\frac{1}{w(re^{i\\varphi})- a_{\\mu}}\\right| - \\log 3\\right) d \\varphi \n\\end{aligned}$$\n\nFurther,\n$$\\begin{aligned}\n\\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| < \\frac{\\delta}{2p}} \\log^{+} \\left|\\frac{1}{w- a_{\\mu}}\\right| = & m(r,a_{\\mu}) - \\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| \\geq \\frac{\\delta}{2p}}\\log^{+} \\left|\\frac{1}{w- a_{\\mu}}\\right|\\\\\n\\geq & m(r,a_{\\mu}) - \\log \\frac{2p}{\\delta}\n\\end{aligned}$$\n\nand finally\n\n$$m(r,f) > \\sum_{1}^{p} m(r,a_{\\mu}) - p \\log\\frac{2p}{\\delta} - \\log 3$$\n\nor in conjunction with (2)\n\n$$\\begin{equation}\nm (r,\\frac{1}{w^{\\prime}}) > \\sum_{1}^{p} m(r,a_{\\mu}) - m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}}) - p \\log\\frac{2p}{\\delta} - \\log 3\n\\end{equation}$$\n\nIf the quantities $N(r, w^{\\prime})$ and $N(r, \\frac{1}{w^{\\prime}})$ are now added to both sides of inequalities (2) and (5), respectively, then using the first main\ntheorem\n\n$$T(r, w^{\\prime}) = T (r, \\frac{1}{w^{\\prime}}) + \\log |kc_{k}|$$\n\none obtains the following result, which is to be stated as a special lemma 1 :\n\nThe characteristic $T(r, w^{\\prime})$ for the derivative of the meromorphic function\nw(z) lies between the bounds\n$$m(r, w) + N(r, w^{\\prime}) + m (r,\\frac{w^{\\prime}}{w})$$\n\nand \n\n$$ \\sum_{1}^{p} m(r,\\frac{1}{w - a_{\\mu}}) + N (r,\\frac{1}{w^{\\prime}})  - m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}}) - p \\log\\frac{2p}{\\delta} - \\log 3$$\n\nIf we leave out T(r, w') and introduce\n\n$$N_{1}(r) = N(r,\\frac{1}{w^{\\prime}}) + \\left(2 N(r,w) - N (r,w^{\\prime})\\right)$$\n\nit becomes a version of this theorem. $\\square$\n\nThe estimation is rather lengthy, readers can refer to Hayman, W.[1, Chapter III] and Nevanlinna, Rolf [3, Chapter IX].\n\n\n**Remark:** The quantity $N_{1}(r)$ measures the number of multiple points of $w(z)$. It can be written in the form\n$$N_{1}(r) = \\int_{0}^{r} \\frac{n_{1}(t) - n_{1}(0)}{t} dt + n_{1}(0) \\log r,\n$$\nwhere $n_{1}(r)$ indicates the number of multiple points of $w(z)$ in the disk $|z| < r$, each $k$-fold point being counted $k -\n1$ times.\n\n**Vojta's conjecture:** Let $F$ be a number field, let $X/F$ be a non-singular algebraic variety, let $D$ be an effective divisor on $X$ with at worst normal crossings, let $H$ be an ample divisor on $X$, and let $K_{X}$ be a canonical divisor on $X$. Choose Weil height functions $h_{H}$ and $h_{K_{X}}$ and, for each absolute value $v$ on $F$, a local height function $\\lambda_{D,v}$. Fix a finite set of absolute values $S$ of $F$, and let $\\epsilon>0$. Then there is a constant $C$ and a non-empty Zariski open set $U\\subseteq X$, depending on all of the above choices, such that\n$$\\sum_{v\\in S}\\lambda_{D,v}(P)+h_{K_{X}}(P)\\leq \\epsilon h_{H}(P)+C \\quad {\\hbox{for all }}P\\in U(F).$$\n\n\n\n## Reference \n\n\n\n[1] Hayman, W. (1964). Meromorphic functions. Oxford University press.\n\n[2] Nevanlinna, Rolf (1925), \"Zur Theorie der Meromorphen Funktionen\", Acta Mathematica, 46 (1–2): 1–99, doi:10.1007/BF02543858, ISSN 0001-5962\n\n[3] Nevanlinna, Rolf (1970), Analytic functions, Die Grundlehren der mathematischen Wissenschaften, vol. 162, Berlin, New York: Springer-Verlag, MR 0279280\n\n\n\n\n","source":"_posts/Nevanlinna Theory.md","raw":"---\ntitle: Nevanlinna Theory (I)\ndate: 2023-03-27 18:40:09\ntags:\n    - [Sevaral Complex Variables]\ncategories:\n    - [Sevaral Complex Variables, Nevanlinna Theory]\nmathjax: true\n---\n\n## First Main Theorem\n\nFor any function $w(z)$ meromorphic in the disk\n$|z| < R < \\infty$, a function $T(r, w)$ can be defined for $0 < r < R$ so that \n\n1. $T(r)$ is an increasing function of $r$ and a convex function of $\\log r$.\n\n2. If $a$ denotes any complex number that is independent of $z$, finite or infinite, then is\n$$m(r, a) + N(r, a) = T (r) + O(1). \\tag{I}$$\nwhere the two terms on the left of relation (I) are\nnonnegative.\n\n\n## Lemma 1\nIf $\\alpha$ is a nonnegative number, let $$\\log^{+} \\alpha = \\begin{cases}\\log \\alpha, & \\alpha > 1\\\\\n0, & 0 < \\alpha \\leq 1\\end{cases}$$ be the larger of the numbers $\\log \\alpha$ and $0$; it follows that\n$$\n\\begin{aligned}\n\\log \\alpha = \\log^{+} \\alpha - \\log^{+} \\frac{1}{\\alpha}\\\\\n |\\log \\alpha| = \\log^{+} \\alpha + \\log^{+} \\frac{1}{\\alpha}\n\\end{aligned}\n$$\n\n\n## Lemma 2\nNotation as above lemma 1, and further, as is easily confirmed,\n$$\n\\begin{equation}\n\\begin{aligned}\n\\log^{+} \\alpha_{1}\\cdot \\alpha_{2}\\cdots \\alpha_{p} \\leq \\sum_{i=1}^{p} \\log^{+} {\\alpha_{i}}\\\\\n\\log^{+} \\sum_{i=1}^{p} {\\alpha_{i}} \\leq \\sum_{i=1}^{p} \\log^{+} \\alpha_{i} + \\log p\n\\end{aligned}\n\\end{equation}\n$$\n\n## Proof of Theorem 1\n\nIn [Jensen's formula](https://en.wikipedia.org/wiki/Jensen%27s_formula), we now set $\\log |w| = \\log^{+} |w| - \\log |\\frac{1}{w}|$ and for short write\n\n\n$$\\begin{aligned}N(r,a,w) =& \\int_{0}^{r} \\frac{n(t,a) - n(0,a)}{t} dt + n(0,a) \\log r\\\\\nm(r, a, w) =& \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\log^{+} \\left|\\frac{1}{w(re^{i\\varphi}) -a }\\right|d\\varphi\n\\end{aligned}$$\n\n$$\\begin{aligned}N(r,\\infty,w) =& \\int_{0}^{r} \\frac{n(t,\\infty) - n(0,\\infty)}{t} dt + n(0,\\infty) \\log r\\\\\nm(r, \\infty, w) =& \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\log^{+} \\left|w(re^{i\\varphi})\\right|d\\varphi\n\\end{aligned}$$\n\nwhere $n(r, a)$ is the number of roots of the equation $w- a =  0$ in the disk $|z|\\leq r$ \n\nJensen's formula then becomes\n\n$$m(r, w) + N(r, w) = m (r, \\frac{1}{w}) + N (r,\\frac{1}{w}) +\\log|c_{\\lambda}|$$\n\n\nwhere $c_{\\lambda}$ is the first nonvanishing coefficient in the Laurent expansion of $w-a$ at the origin $z = 0$. \n\nThe result is then\n\n$$m(r, w - a) + N(r, w - a) = m (r, \\frac{1}{w-a}) + N (r, \\frac{1}{w-a}) + \\text{const.}$$\n\nBut\n$N(r, w - a) = N(r, w)$\n\nand by Lemma 2\n\n$$\\left| m(r, w- a)- m(r, w) \\right| < \\log^{+} |a|+ \\log 2$$\n\nso we conclude from (2.3) that\n\n$$m(r, a) + N(r, a) = m(r, \\infty) + N(r,\\infty) + \\varphi(r, a),$$\n\nIn addition we set\n$T(r, w) = T(r) = m(r, \\infty) + N(r, \\infty)$,\nThis is the desired results. $\\square$\n\n## Second Main Theorem\n\n1. For $|z| < R < \\infty$ let $w(z)$ be a nonconstant\nmeromorphic function. If $w_{1}, \\cdots , w_{q} (q \\geq 1)$ are mutually distinct finite or infinite complex numbers, then for $0 \\leq r < R$\n\n$$\\sum m(r, \\omega_{\\nu}) < 2 T(r) - N_{1}(r) + S(r)$$\n\n2. the remainder term satisfies\nthe following conditions:\n\nIf $R = \\infty$, then\n$$S(r) = O \\left\\{\\log \\left[rT(r)\\right]\\right\\}$$\nwith at most the exception of a set of values $\\{r\\}$ of finite total measure\n\nIf $R = 1$, then\n\n$$S(r) = O \\left\\{\\frac{1}{1-r}T(r)\\right\\}$$\n\nwith at most the exception of a set of values $\\{r\\}$ for which the variation of $\\frac{1}{1-r}$ is fintte\n\n\n## Proof \n\nSuppose, therefore, that $w(z) = c_{0} + c_{k}z^{k} + \\cdots (c_{0}\\neq 0, c_{k} \\neq 0)$ is a function that is meromorphic for $|z| < R \\leq \\infty$, and let $a_{1}, \\cdots, a_{p}$ be a system of $p \\geq 2$ different finite complex numbers.\n\nWe first compare the proximity functions $m(r, w)$ and $m(r, w^{\\prime})$ with one another. By means of the elementary inequalities (Lemma 2 in (I)), one finds immediately that\n\n$$\\begin{equation}\nm(r,w) = m (r,w^{\\prime}\\frac{w}{w^{\\prime}}) \\leq m (r,w^{\\prime}) + m (r,\\frac{w}{w^{\\prime}})\n\\end{equation}$$\n\nTo estimate the mean value $m ( r, \\frac{1}{w^{\\prime}})$ , consider the sum\n\n$$f(z) = \\sum_{\\nu=1}^{p} \\frac{1}{w(z) - a_{\\nu}}$$\n\nWe have\n\n\n$$\\begin{equation}\nm(r,f) = m (r,fw^{\\prime}\\frac{1}{w^{\\prime}}) \\leq m (r,\\frac{1}{w^{\\prime}}) + m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}})\n\\end{equation}$$\n\n\nOn the other hand, for a given $\\mu$ ($\\mu = 1, \\cdots , p$)\n\n$$f = \\frac{1}{w - a_{\\mu}}\\left(1 + \\sum_{\\nu\\neq\\mu} \\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right)$$\n\nIf $\\delta = \\min (|a_{h} -\na_{k}|, 1) (h \\neq k)$, then at every point $z$ where\n\n$$\\begin{equation}\n\\left|w(z) - a_{\\mu}\\right| < \\frac{\\delta}{2p} \\left(\\leq \\frac{1}{2p}\\right) \n\\end{equation}$$\n\nfor $\\nu \\neq \\mu$\n$$\\left|w - a_{\\nu}\\right| \\geq \\left|a_{\\mu} - a_{\\nu}\\right| - \\left|w - a_{\\mu}\\right| > \\delta - \\frac{\\delta}{2p} \\geq \\frac{3\\delta}{4}$$\n\nand hence\n$$\\sum_{\\nu\\neq\\mu} \\left|\\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right| < (p-1) \\frac{2}{3p} < \\frac{2}{3}$$\n\nso that\n$$\\left|1 + \\sum_{\\nu\\neq\\mu} \\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right| > \\frac{1}{3}$$\n\nFrom this it follows that\n$$\\log^{+}\\left|f(z)\\right| > \\log^{+}\\left|\\frac{1}{w - a_{\\mu}}\\right| - \\log 3$$\n\nat every point z where condition (4) is satisfied.\n\nThe arcs determined on the circle by (4) are disjoint for different\nvalues of $p$, and therefore one concludes that\n\n$$\\begin{aligned}\nm(r,f) \\geq & \\frac{1}{2\\pi} \\sum_{\\mu =1}^{p} \\int_{|w - a_{\\mu}| < \\frac{\\delta}{2p}} \\log^{+} |f(re^{i\\varphi})| d \\varphi\\\\\n< & \\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| < \\frac{\\delta}{2p}} \\left(\\log^{+} \\left|\\frac{1}{w(re^{i\\varphi})- a_{\\mu}}\\right| - \\log 3\\right) d \\varphi \n\\end{aligned}$$\n\nFurther,\n$$\\begin{aligned}\n\\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| < \\frac{\\delta}{2p}} \\log^{+} \\left|\\frac{1}{w- a_{\\mu}}\\right| = & m(r,a_{\\mu}) - \\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| \\geq \\frac{\\delta}{2p}}\\log^{+} \\left|\\frac{1}{w- a_{\\mu}}\\right|\\\\\n\\geq & m(r,a_{\\mu}) - \\log \\frac{2p}{\\delta}\n\\end{aligned}$$\n\nand finally\n\n$$m(r,f) > \\sum_{1}^{p} m(r,a_{\\mu}) - p \\log\\frac{2p}{\\delta} - \\log 3$$\n\nor in conjunction with (2)\n\n$$\\begin{equation}\nm (r,\\frac{1}{w^{\\prime}}) > \\sum_{1}^{p} m(r,a_{\\mu}) - m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}}) - p \\log\\frac{2p}{\\delta} - \\log 3\n\\end{equation}$$\n\nIf the quantities $N(r, w^{\\prime})$ and $N(r, \\frac{1}{w^{\\prime}})$ are now added to both sides of inequalities (2) and (5), respectively, then using the first main\ntheorem\n\n$$T(r, w^{\\prime}) = T (r, \\frac{1}{w^{\\prime}}) + \\log |kc_{k}|$$\n\none obtains the following result, which is to be stated as a special lemma 1 :\n\nThe characteristic $T(r, w^{\\prime})$ for the derivative of the meromorphic function\nw(z) lies between the bounds\n$$m(r, w) + N(r, w^{\\prime}) + m (r,\\frac{w^{\\prime}}{w})$$\n\nand \n\n$$ \\sum_{1}^{p} m(r,\\frac{1}{w - a_{\\mu}}) + N (r,\\frac{1}{w^{\\prime}})  - m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}}) - p \\log\\frac{2p}{\\delta} - \\log 3$$\n\nIf we leave out T(r, w') and introduce\n\n$$N_{1}(r) = N(r,\\frac{1}{w^{\\prime}}) + \\left(2 N(r,w) - N (r,w^{\\prime})\\right)$$\n\nit becomes a version of this theorem. $\\square$\n\nThe estimation is rather lengthy, readers can refer to Hayman, W.[1, Chapter III] and Nevanlinna, Rolf [3, Chapter IX].\n\n\n**Remark:** The quantity $N_{1}(r)$ measures the number of multiple points of $w(z)$. It can be written in the form\n$$N_{1}(r) = \\int_{0}^{r} \\frac{n_{1}(t) - n_{1}(0)}{t} dt + n_{1}(0) \\log r,\n$$\nwhere $n_{1}(r)$ indicates the number of multiple points of $w(z)$ in the disk $|z| < r$, each $k$-fold point being counted $k -\n1$ times.\n\n**Vojta's conjecture:** Let $F$ be a number field, let $X/F$ be a non-singular algebraic variety, let $D$ be an effective divisor on $X$ with at worst normal crossings, let $H$ be an ample divisor on $X$, and let $K_{X}$ be a canonical divisor on $X$. Choose Weil height functions $h_{H}$ and $h_{K_{X}}$ and, for each absolute value $v$ on $F$, a local height function $\\lambda_{D,v}$. Fix a finite set of absolute values $S$ of $F$, and let $\\epsilon>0$. Then there is a constant $C$ and a non-empty Zariski open set $U\\subseteq X$, depending on all of the above choices, such that\n$$\\sum_{v\\in S}\\lambda_{D,v}(P)+h_{K_{X}}(P)\\leq \\epsilon h_{H}(P)+C \\quad {\\hbox{for all }}P\\in U(F).$$\n\n\n\n## Reference \n\n\n\n[1] Hayman, W. (1964). Meromorphic functions. Oxford University press.\n\n[2] Nevanlinna, Rolf (1925), \"Zur Theorie der Meromorphen Funktionen\", Acta Mathematica, 46 (1–2): 1–99, doi:10.1007/BF02543858, ISSN 0001-5962\n\n[3] Nevanlinna, Rolf (1970), Analytic functions, Die Grundlehren der mathematischen Wissenschaften, vol. 162, Berlin, New York: Springer-Verlag, MR 0279280\n\n\n\n\n","slug":"Nevanlinna Theory","published":1,"updated":"2024-02-25T15:11:07.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5s2001im8nx1qggbdnk","content":"<h2 id=\"first-main-theorem\">First Main Theorem</h2>\r\n<p>For any function <span class=\"math inline\">\\(w(z)\\)</span>\r\nmeromorphic in the disk <span class=\"math inline\">\\(|z| &lt; R &lt;\r\n\\infty\\)</span>, a function <span class=\"math inline\">\\(T(r, w)\\)</span>\r\ncan be defined for <span class=\"math inline\">\\(0 &lt; r &lt; R\\)</span>\r\nso that</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(T(r)\\)</span> is an increasing\r\nfunction of <span class=\"math inline\">\\(r\\)</span> and a convex function\r\nof <span class=\"math inline\">\\(\\log r\\)</span>.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(a\\)</span> denotes any complex\r\nnumber that is independent of <span class=\"math inline\">\\(z\\)</span>,\r\nfinite or infinite, then is <span class=\"math display\">\\[m(r, a) + N(r,\r\na) = T (r) + O(1). \\tag{I}\\]</span> where the two terms on the left of\r\nrelation (I) are nonnegative.</p></li>\r\n</ol>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>If <span class=\"math inline\">\\(\\alpha\\)</span> is a nonnegative\r\nnumber, let <span class=\"math display\">\\[\\log^{+} \\alpha =\r\n\\begin{cases}\\log \\alpha, &amp; \\alpha &gt; 1\\\\\r\n0, &amp; 0 &lt; \\alpha \\leq 1\\end{cases}\\]</span> be the larger of the\r\nnumbers <span class=\"math inline\">\\(\\log \\alpha\\)</span> and <span class=\"math inline\">\\(0\\)</span>; it follows that <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\log \\alpha = \\log^{+} \\alpha - \\log^{+} \\frac{1}{\\alpha}\\\\\r\n|\\log \\alpha| = \\log^{+} \\alpha + \\log^{+} \\frac{1}{\\alpha}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>Notation as above lemma 1, and further, as is easily confirmed, <span class=\"math display\">\\[\r\n\\begin{equation}\r\n\\begin{aligned}\r\n\\log^{+} \\alpha_{1}\\cdot \\alpha_{2}\\cdots \\alpha_{p} \\leq \\sum_{i=1}^{p}\r\n\\log^{+} {\\alpha_{i}}\\\\\r\n\\log^{+} \\sum_{i=1}^{p} {\\alpha_{i}} \\leq \\sum_{i=1}^{p} \\log^{+}\r\n\\alpha_{i} + \\log p\r\n\\end{aligned}\r\n\\end{equation}\r\n\\]</span></p>\r\n<h2 id=\"proof-of-theorem-1\">Proof of Theorem 1</h2>\r\n<p>In <a href=\"https://en.wikipedia.org/wiki/Jensen%27s_formula\">Jensen's\r\nformula</a>, we now set <span class=\"math inline\">\\(\\log |w| = \\log^{+}\r\n|w| - \\log |\\frac{1}{w}|\\)</span> and for short write</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}N(r,a,w) =&amp;\r\n\\int_{0}^{r} \\frac{n(t,a) - n(0,a)}{t} dt + n(0,a) \\log r\\\\\r\nm(r, a, w) =&amp; \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\log^{+}\r\n\\left|\\frac{1}{w(re^{i\\varphi}) -a }\\right|d\\varphi\r\n\\end{aligned}\\]</span></p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}N(r,\\infty,w) =&amp;\r\n\\int_{0}^{r} \\frac{n(t,\\infty) - n(0,\\infty)}{t} dt + n(0,\\infty) \\log\r\nr\\\\\r\nm(r, \\infty, w) =&amp; \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\log^{+}\r\n\\left|w(re^{i\\varphi})\\right|d\\varphi\r\n\\end{aligned}\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(n(r, a)\\)</span> is the number of\r\nroots of the equation <span class=\"math inline\">\\(w- a =  0\\)</span> in\r\nthe disk <span class=\"math inline\">\\(|z|\\leq r\\)</span></p>\r\n<p>Jensen's formula then becomes</p>\r\n<p><span class=\"math display\">\\[m(r, w) + N(r, w) = m (r, \\frac{1}{w}) +\r\nN (r,\\frac{1}{w}) +\\log|c_{\\lambda}|\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(c_{\\lambda}\\)</span> is the first\r\nnonvanishing coefficient in the Laurent expansion of <span class=\"math inline\">\\(w-a\\)</span> at the origin <span class=\"math inline\">\\(z = 0\\)</span>.</p>\r\n<p>The result is then</p>\r\n<p><span class=\"math display\">\\[m(r, w - a) + N(r, w - a) = m (r,\r\n\\frac{1}{w-a}) + N (r, \\frac{1}{w-a}) + \\text{const.}\\]</span></p>\r\n<p>But <span class=\"math inline\">\\(N(r, w - a) = N(r, w)\\)</span></p>\r\n<p>and by Lemma 2</p>\r\n<p><span class=\"math display\">\\[\\left| m(r, w- a)- m(r, w) \\right| &lt;\r\n\\log^{+} |a|+ \\log 2\\]</span></p>\r\n<p>so we conclude from (2.3) that</p>\r\n<p><span class=\"math display\">\\[m(r, a) + N(r, a) = m(r, \\infty) +\r\nN(r,\\infty) + \\varphi(r, a),\\]</span></p>\r\n<p>In addition we set <span class=\"math inline\">\\(T(r, w) = T(r) = m(r,\r\n\\infty) + N(r, \\infty)\\)</span>, This is the desired results. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"second-main-theorem\">Second Main Theorem</h2>\r\n<ol type=\"1\">\r\n<li>For <span class=\"math inline\">\\(|z| &lt; R &lt; \\infty\\)</span> let\r\n<span class=\"math inline\">\\(w(z)\\)</span> be a nonconstant meromorphic\r\nfunction. If <span class=\"math inline\">\\(w_{1}, \\cdots , w_{q} (q \\geq\r\n1)\\)</span> are mutually distinct finite or infinite complex numbers,\r\nthen for <span class=\"math inline\">\\(0 \\leq r &lt; R\\)</span></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\sum m(r, \\omega_{\\nu}) &lt; 2 T(r) -\r\nN_{1}(r) + S(r)\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>the remainder term satisfies the following conditions:</li>\r\n</ol>\r\n<p>If <span class=\"math inline\">\\(R = \\infty\\)</span>, then <span class=\"math display\">\\[S(r) = O \\left\\{\\log\r\n\\left[rT(r)\\right]\\right\\}\\]</span> with at most the exception of a set\r\nof values <span class=\"math inline\">\\(\\{r\\}\\)</span> of finite total\r\nmeasure</p>\r\n<p>If <span class=\"math inline\">\\(R = 1\\)</span>, then</p>\r\n<p><span class=\"math display\">\\[S(r) = O\r\n\\left\\{\\frac{1}{1-r}T(r)\\right\\}\\]</span></p>\r\n<p>with at most the exception of a set of values <span class=\"math inline\">\\(\\{r\\}\\)</span> for which the variation of <span class=\"math inline\">\\(\\frac{1}{1-r}\\)</span> is fintte</p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<p>Suppose, therefore, that <span class=\"math inline\">\\(w(z) = c_{0} +\r\nc_{k}z^{k} + \\cdots (c_{0}\\neq 0, c_{k} \\neq 0)\\)</span> is a function\r\nthat is meromorphic for <span class=\"math inline\">\\(|z| &lt; R \\leq\r\n\\infty\\)</span>, and let <span class=\"math inline\">\\(a_{1}, \\cdots,\r\na_{p}\\)</span> be a system of <span class=\"math inline\">\\(p \\geq\r\n2\\)</span> different finite complex numbers.</p>\r\n<p>We first compare the proximity functions <span class=\"math inline\">\\(m(r, w)\\)</span> and <span class=\"math inline\">\\(m(r, w^{\\prime})\\)</span> with one another. By\r\nmeans of the elementary inequalities (Lemma 2 in (I)), one finds\r\nimmediately that</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm(r,w) = m (r,w^{\\prime}\\frac{w}{w^{\\prime}}) \\leq m (r,w^{\\prime}) + m\r\n(r,\\frac{w}{w^{\\prime}})\r\n\\end{equation}\\]</span></p>\r\n<p>To estimate the mean value <span class=\"math inline\">\\(m ( r,\r\n\\frac{1}{w^{\\prime}})\\)</span> , consider the sum</p>\r\n<p><span class=\"math display\">\\[f(z) = \\sum_{\\nu=1}^{p} \\frac{1}{w(z) -\r\na_{\\nu}}\\]</span></p>\r\n<p>We have</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm(r,f) = m (r,fw^{\\prime}\\frac{1}{w^{\\prime}}) \\leq m\r\n(r,\\frac{1}{w^{\\prime}}) + m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}})\r\n\\end{equation}\\]</span></p>\r\n<p>On the other hand, for a given <span class=\"math inline\">\\(\\mu\\)</span> (<span class=\"math inline\">\\(\\mu = 1,\r\n\\cdots , p\\)</span>)</p>\r\n<p><span class=\"math display\">\\[f = \\frac{1}{w - a_{\\mu}}\\left(1 +\r\n\\sum_{\\nu\\neq\\mu} \\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right)\\]</span></p>\r\n<p>If <span class=\"math inline\">\\(\\delta = \\min (|a_{h} -\r\na_{k}|, 1) (h \\neq k)\\)</span>, then at every point <span class=\"math inline\">\\(z\\)</span> where</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\left|w(z) - a_{\\mu}\\right| &lt; \\frac{\\delta}{2p} \\left(\\leq\r\n\\frac{1}{2p}\\right)\r\n\\end{equation}\\]</span></p>\r\n<p>for <span class=\"math inline\">\\(\\nu \\neq \\mu\\)</span> <span class=\"math display\">\\[\\left|w - a_{\\nu}\\right| \\geq \\left|a_{\\mu} -\r\na_{\\nu}\\right| - \\left|w - a_{\\mu}\\right| &gt; \\delta -\r\n\\frac{\\delta}{2p} \\geq \\frac{3\\delta}{4}\\]</span></p>\r\n<p>and hence <span class=\"math display\">\\[\\sum_{\\nu\\neq\\mu}\r\n\\left|\\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right| &lt; (p-1) \\frac{2}{3p}\r\n&lt; \\frac{2}{3}\\]</span></p>\r\n<p>so that <span class=\"math display\">\\[\\left|1 + \\sum_{\\nu\\neq\\mu}\r\n\\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right| &gt; \\frac{1}{3}\\]</span></p>\r\n<p>From this it follows that <span class=\"math display\">\\[\\log^{+}\\left|f(z)\\right| &gt;\r\n\\log^{+}\\left|\\frac{1}{w - a_{\\mu}}\\right| - \\log 3\\]</span></p>\r\n<p>at every point z where condition (4) is satisfied.</p>\r\n<p>The arcs determined on the circle by (4) are disjoint for different\r\nvalues of <span class=\"math inline\">\\(p\\)</span>, and therefore one\r\nconcludes that</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\nm(r,f) \\geq &amp; \\frac{1}{2\\pi} \\sum_{\\mu =1}^{p} \\int_{|w - a_{\\mu}|\r\n&lt; \\frac{\\delta}{2p}} \\log^{+} |f(re^{i\\varphi})| d \\varphi\\\\\r\n&lt; &amp; \\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| &lt;\r\n\\frac{\\delta}{2p}} \\left(\\log^{+} \\left|\\frac{1}{w(re^{i\\varphi})-\r\na_{\\mu}}\\right| - \\log 3\\right) d \\varphi\r\n\\end{aligned}\\]</span></p>\r\n<p>Further, <span class=\"math display\">\\[\\begin{aligned}\r\n\\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| &lt; \\frac{\\delta}{2p}}\r\n\\log^{+} \\left|\\frac{1}{w- a_{\\mu}}\\right| = &amp; m(r,a_{\\mu}) -\r\n\\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| \\geq\r\n\\frac{\\delta}{2p}}\\log^{+} \\left|\\frac{1}{w- a_{\\mu}}\\right|\\\\\r\n\\geq &amp; m(r,a_{\\mu}) - \\log \\frac{2p}{\\delta}\r\n\\end{aligned}\\]</span></p>\r\n<p>and finally</p>\r\n<p><span class=\"math display\">\\[m(r,f) &gt; \\sum_{1}^{p} m(r,a_{\\mu}) -\r\np \\log\\frac{2p}{\\delta} - \\log 3\\]</span></p>\r\n<p>or in conjunction with (2)</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm (r,\\frac{1}{w^{\\prime}}) &gt; \\sum_{1}^{p} m(r,a_{\\mu}) - m\r\n(r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}}) - p \\log\\frac{2p}{\\delta} - \\log 3\r\n\\end{equation}\\]</span></p>\r\n<p>If the quantities <span class=\"math inline\">\\(N(r,\r\nw^{\\prime})\\)</span> and <span class=\"math inline\">\\(N(r,\r\n\\frac{1}{w^{\\prime}})\\)</span> are now added to both sides of\r\ninequalities (2) and (5), respectively, then using the first main\r\ntheorem</p>\r\n<p><span class=\"math display\">\\[T(r, w^{\\prime}) = T (r,\r\n\\frac{1}{w^{\\prime}}) + \\log |kc_{k}|\\]</span></p>\r\n<p>one obtains the following result, which is to be stated as a special\r\nlemma 1 :</p>\r\n<p>The characteristic <span class=\"math inline\">\\(T(r,\r\nw^{\\prime})\\)</span> for the derivative of the meromorphic function w(z)\r\nlies between the bounds <span class=\"math display\">\\[m(r, w) + N(r,\r\nw^{\\prime}) + m (r,\\frac{w^{\\prime}}{w})\\]</span></p>\r\n<p>and</p>\r\n<p><span class=\"math display\">\\[ \\sum_{1}^{p} m(r,\\frac{1}{w - a_{\\mu}})\r\n+ N (r,\\frac{1}{w^{\\prime}})  - m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}})\r\n- p \\log\\frac{2p}{\\delta} - \\log 3\\]</span></p>\r\n<p>If we leave out T(r, w') and introduce</p>\r\n<p><span class=\"math display\">\\[N_{1}(r) = N(r,\\frac{1}{w^{\\prime}}) +\r\n\\left(2 N(r,w) - N (r,w^{\\prime})\\right)\\]</span></p>\r\n<p>it becomes a version of this theorem. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<p>The estimation is rather lengthy, readers can refer to Hayman, W.[1,\r\nChapter III] and Nevanlinna, Rolf [3, Chapter IX].</p>\r\n<p><strong>Remark:</strong> The quantity <span class=\"math inline\">\\(N_{1}(r)\\)</span> measures the number of multiple\r\npoints of <span class=\"math inline\">\\(w(z)\\)</span>. It can be written\r\nin the form <span class=\"math display\">\\[N_{1}(r) = \\int_{0}^{r}\r\n\\frac{n_{1}(t) - n_{1}(0)}{t} dt + n_{1}(0) \\log r,\r\n\\]</span> where <span class=\"math inline\">\\(n_{1}(r)\\)</span> indicates\r\nthe number of multiple points of <span class=\"math inline\">\\(w(z)\\)</span> in the disk <span class=\"math inline\">\\(|z| &lt; r\\)</span>, each <span class=\"math inline\">\\(k\\)</span>-fold point being counted <span class=\"math inline\">\\(k -\r\n1\\)</span> times.</p>\r\n<p><strong>Vojta's conjecture:</strong> Let <span class=\"math inline\">\\(F\\)</span> be a number field, let <span class=\"math inline\">\\(X/F\\)</span> be a non-singular algebraic variety,\r\nlet <span class=\"math inline\">\\(D\\)</span> be an effective divisor on\r\n<span class=\"math inline\">\\(X\\)</span> with at worst normal crossings,\r\nlet <span class=\"math inline\">\\(H\\)</span> be an ample divisor on <span class=\"math inline\">\\(X\\)</span>, and let <span class=\"math inline\">\\(K_{X}\\)</span> be a canonical divisor on <span class=\"math inline\">\\(X\\)</span>. Choose Weil height functions <span class=\"math inline\">\\(h_{H}\\)</span> and <span class=\"math inline\">\\(h_{K_{X}}\\)</span> and, for each absolute value\r\n<span class=\"math inline\">\\(v\\)</span> on <span class=\"math inline\">\\(F\\)</span>, a local height function <span class=\"math inline\">\\(\\lambda_{D,v}\\)</span>. Fix a finite set of\r\nabsolute values <span class=\"math inline\">\\(S\\)</span> of <span class=\"math inline\">\\(F\\)</span>, and let <span class=\"math inline\">\\(\\epsilon&gt;0\\)</span>. Then there is a constant\r\n<span class=\"math inline\">\\(C\\)</span> and a non-empty Zariski open set\r\n<span class=\"math inline\">\\(U\\subseteq X\\)</span>, depending on all of\r\nthe above choices, such that <span class=\"math display\">\\[\\sum_{v\\in\r\nS}\\lambda_{D,v}(P)+h_{K_{X}}(P)\\leq \\epsilon h_{H}(P)+C \\quad {\\hbox{for\r\nall }}P\\in U(F).\\]</span></p>\r\n<h2 id=\"reference\">Reference</h2>\r\n<p>[1] Hayman, W. (1964). Meromorphic functions. Oxford University\r\npress.</p>\r\n<p>[2] Nevanlinna, Rolf (1925), \"Zur Theorie der Meromorphen\r\nFunktionen\", Acta Mathematica, 46 (1–2): 1–99, doi:10.1007/BF02543858,\r\nISSN 0001-5962</p>\r\n<p>[3] Nevanlinna, Rolf (1970), Analytic functions, Die Grundlehren der\r\nmathematischen Wissenschaften, vol. 162, Berlin, New York:\r\nSpringer-Verlag, MR 0279280</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"first-main-theorem\">First Main Theorem</h2>\r\n<p>For any function <span class=\"math inline\">\\(w(z)\\)</span>\r\nmeromorphic in the disk <span class=\"math inline\">\\(|z| &lt; R &lt;\r\n\\infty\\)</span>, a function <span class=\"math inline\">\\(T(r, w)\\)</span>\r\ncan be defined for <span class=\"math inline\">\\(0 &lt; r &lt; R\\)</span>\r\nso that</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(T(r)\\)</span> is an increasing\r\nfunction of <span class=\"math inline\">\\(r\\)</span> and a convex function\r\nof <span class=\"math inline\">\\(\\log r\\)</span>.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(a\\)</span> denotes any complex\r\nnumber that is independent of <span class=\"math inline\">\\(z\\)</span>,\r\nfinite or infinite, then is <span class=\"math display\">\\[m(r, a) + N(r,\r\na) = T (r) + O(1). \\tag{I}\\]</span> where the two terms on the left of\r\nrelation (I) are nonnegative.</p></li>\r\n</ol>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>If <span class=\"math inline\">\\(\\alpha\\)</span> is a nonnegative\r\nnumber, let <span class=\"math display\">\\[\\log^{+} \\alpha =\r\n\\begin{cases}\\log \\alpha, &amp; \\alpha &gt; 1\\\\\r\n0, &amp; 0 &lt; \\alpha \\leq 1\\end{cases}\\]</span> be the larger of the\r\nnumbers <span class=\"math inline\">\\(\\log \\alpha\\)</span> and <span class=\"math inline\">\\(0\\)</span>; it follows that <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\log \\alpha = \\log^{+} \\alpha - \\log^{+} \\frac{1}{\\alpha}\\\\\r\n|\\log \\alpha| = \\log^{+} \\alpha + \\log^{+} \\frac{1}{\\alpha}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>Notation as above lemma 1, and further, as is easily confirmed, <span class=\"math display\">\\[\r\n\\begin{equation}\r\n\\begin{aligned}\r\n\\log^{+} \\alpha_{1}\\cdot \\alpha_{2}\\cdots \\alpha_{p} \\leq \\sum_{i=1}^{p}\r\n\\log^{+} {\\alpha_{i}}\\\\\r\n\\log^{+} \\sum_{i=1}^{p} {\\alpha_{i}} \\leq \\sum_{i=1}^{p} \\log^{+}\r\n\\alpha_{i} + \\log p\r\n\\end{aligned}\r\n\\end{equation}\r\n\\]</span></p>\r\n<h2 id=\"proof-of-theorem-1\">Proof of Theorem 1</h2>\r\n<p>In <a href=\"https://en.wikipedia.org/wiki/Jensen%27s_formula\">Jensen's\r\nformula</a>, we now set <span class=\"math inline\">\\(\\log |w| = \\log^{+}\r\n|w| - \\log |\\frac{1}{w}|\\)</span> and for short write</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}N(r,a,w) =&amp;\r\n\\int_{0}^{r} \\frac{n(t,a) - n(0,a)}{t} dt + n(0,a) \\log r\\\\\r\nm(r, a, w) =&amp; \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\log^{+}\r\n\\left|\\frac{1}{w(re^{i\\varphi}) -a }\\right|d\\varphi\r\n\\end{aligned}\\]</span></p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}N(r,\\infty,w) =&amp;\r\n\\int_{0}^{r} \\frac{n(t,\\infty) - n(0,\\infty)}{t} dt + n(0,\\infty) \\log\r\nr\\\\\r\nm(r, \\infty, w) =&amp; \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\log^{+}\r\n\\left|w(re^{i\\varphi})\\right|d\\varphi\r\n\\end{aligned}\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(n(r, a)\\)</span> is the number of\r\nroots of the equation <span class=\"math inline\">\\(w- a =  0\\)</span> in\r\nthe disk <span class=\"math inline\">\\(|z|\\leq r\\)</span></p>\r\n<p>Jensen's formula then becomes</p>\r\n<p><span class=\"math display\">\\[m(r, w) + N(r, w) = m (r, \\frac{1}{w}) +\r\nN (r,\\frac{1}{w}) +\\log|c_{\\lambda}|\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(c_{\\lambda}\\)</span> is the first\r\nnonvanishing coefficient in the Laurent expansion of <span class=\"math inline\">\\(w-a\\)</span> at the origin <span class=\"math inline\">\\(z = 0\\)</span>.</p>\r\n<p>The result is then</p>\r\n<p><span class=\"math display\">\\[m(r, w - a) + N(r, w - a) = m (r,\r\n\\frac{1}{w-a}) + N (r, \\frac{1}{w-a}) + \\text{const.}\\]</span></p>\r\n<p>But <span class=\"math inline\">\\(N(r, w - a) = N(r, w)\\)</span></p>\r\n<p>and by Lemma 2</p>\r\n<p><span class=\"math display\">\\[\\left| m(r, w- a)- m(r, w) \\right| &lt;\r\n\\log^{+} |a|+ \\log 2\\]</span></p>\r\n<p>so we conclude from (2.3) that</p>\r\n<p><span class=\"math display\">\\[m(r, a) + N(r, a) = m(r, \\infty) +\r\nN(r,\\infty) + \\varphi(r, a),\\]</span></p>\r\n<p>In addition we set <span class=\"math inline\">\\(T(r, w) = T(r) = m(r,\r\n\\infty) + N(r, \\infty)\\)</span>, This is the desired results. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"second-main-theorem\">Second Main Theorem</h2>\r\n<ol type=\"1\">\r\n<li>For <span class=\"math inline\">\\(|z| &lt; R &lt; \\infty\\)</span> let\r\n<span class=\"math inline\">\\(w(z)\\)</span> be a nonconstant meromorphic\r\nfunction. If <span class=\"math inline\">\\(w_{1}, \\cdots , w_{q} (q \\geq\r\n1)\\)</span> are mutually distinct finite or infinite complex numbers,\r\nthen for <span class=\"math inline\">\\(0 \\leq r &lt; R\\)</span></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\sum m(r, \\omega_{\\nu}) &lt; 2 T(r) -\r\nN_{1}(r) + S(r)\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>the remainder term satisfies the following conditions:</li>\r\n</ol>\r\n<p>If <span class=\"math inline\">\\(R = \\infty\\)</span>, then <span class=\"math display\">\\[S(r) = O \\left\\{\\log\r\n\\left[rT(r)\\right]\\right\\}\\]</span> with at most the exception of a set\r\nof values <span class=\"math inline\">\\(\\{r\\}\\)</span> of finite total\r\nmeasure</p>\r\n<p>If <span class=\"math inline\">\\(R = 1\\)</span>, then</p>\r\n<p><span class=\"math display\">\\[S(r) = O\r\n\\left\\{\\frac{1}{1-r}T(r)\\right\\}\\]</span></p>\r\n<p>with at most the exception of a set of values <span class=\"math inline\">\\(\\{r\\}\\)</span> for which the variation of <span class=\"math inline\">\\(\\frac{1}{1-r}\\)</span> is fintte</p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<p>Suppose, therefore, that <span class=\"math inline\">\\(w(z) = c_{0} +\r\nc_{k}z^{k} + \\cdots (c_{0}\\neq 0, c_{k} \\neq 0)\\)</span> is a function\r\nthat is meromorphic for <span class=\"math inline\">\\(|z| &lt; R \\leq\r\n\\infty\\)</span>, and let <span class=\"math inline\">\\(a_{1}, \\cdots,\r\na_{p}\\)</span> be a system of <span class=\"math inline\">\\(p \\geq\r\n2\\)</span> different finite complex numbers.</p>\r\n<p>We first compare the proximity functions <span class=\"math inline\">\\(m(r, w)\\)</span> and <span class=\"math inline\">\\(m(r, w^{\\prime})\\)</span> with one another. By\r\nmeans of the elementary inequalities (Lemma 2 in (I)), one finds\r\nimmediately that</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm(r,w) = m (r,w^{\\prime}\\frac{w}{w^{\\prime}}) \\leq m (r,w^{\\prime}) + m\r\n(r,\\frac{w}{w^{\\prime}})\r\n\\end{equation}\\]</span></p>\r\n<p>To estimate the mean value <span class=\"math inline\">\\(m ( r,\r\n\\frac{1}{w^{\\prime}})\\)</span> , consider the sum</p>\r\n<p><span class=\"math display\">\\[f(z) = \\sum_{\\nu=1}^{p} \\frac{1}{w(z) -\r\na_{\\nu}}\\]</span></p>\r\n<p>We have</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm(r,f) = m (r,fw^{\\prime}\\frac{1}{w^{\\prime}}) \\leq m\r\n(r,\\frac{1}{w^{\\prime}}) + m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}})\r\n\\end{equation}\\]</span></p>\r\n<p>On the other hand, for a given <span class=\"math inline\">\\(\\mu\\)</span> (<span class=\"math inline\">\\(\\mu = 1,\r\n\\cdots , p\\)</span>)</p>\r\n<p><span class=\"math display\">\\[f = \\frac{1}{w - a_{\\mu}}\\left(1 +\r\n\\sum_{\\nu\\neq\\mu} \\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right)\\]</span></p>\r\n<p>If <span class=\"math inline\">\\(\\delta = \\min (|a_{h} -\r\na_{k}|, 1) (h \\neq k)\\)</span>, then at every point <span class=\"math inline\">\\(z\\)</span> where</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\left|w(z) - a_{\\mu}\\right| &lt; \\frac{\\delta}{2p} \\left(\\leq\r\n\\frac{1}{2p}\\right)\r\n\\end{equation}\\]</span></p>\r\n<p>for <span class=\"math inline\">\\(\\nu \\neq \\mu\\)</span> <span class=\"math display\">\\[\\left|w - a_{\\nu}\\right| \\geq \\left|a_{\\mu} -\r\na_{\\nu}\\right| - \\left|w - a_{\\mu}\\right| &gt; \\delta -\r\n\\frac{\\delta}{2p} \\geq \\frac{3\\delta}{4}\\]</span></p>\r\n<p>and hence <span class=\"math display\">\\[\\sum_{\\nu\\neq\\mu}\r\n\\left|\\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right| &lt; (p-1) \\frac{2}{3p}\r\n&lt; \\frac{2}{3}\\]</span></p>\r\n<p>so that <span class=\"math display\">\\[\\left|1 + \\sum_{\\nu\\neq\\mu}\r\n\\frac{w - a_{\\mu}}{w - a_{\\nu}}\\right| &gt; \\frac{1}{3}\\]</span></p>\r\n<p>From this it follows that <span class=\"math display\">\\[\\log^{+}\\left|f(z)\\right| &gt;\r\n\\log^{+}\\left|\\frac{1}{w - a_{\\mu}}\\right| - \\log 3\\]</span></p>\r\n<p>at every point z where condition (4) is satisfied.</p>\r\n<p>The arcs determined on the circle by (4) are disjoint for different\r\nvalues of <span class=\"math inline\">\\(p\\)</span>, and therefore one\r\nconcludes that</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\nm(r,f) \\geq &amp; \\frac{1}{2\\pi} \\sum_{\\mu =1}^{p} \\int_{|w - a_{\\mu}|\r\n&lt; \\frac{\\delta}{2p}} \\log^{+} |f(re^{i\\varphi})| d \\varphi\\\\\r\n&lt; &amp; \\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| &lt;\r\n\\frac{\\delta}{2p}} \\left(\\log^{+} \\left|\\frac{1}{w(re^{i\\varphi})-\r\na_{\\mu}}\\right| - \\log 3\\right) d \\varphi\r\n\\end{aligned}\\]</span></p>\r\n<p>Further, <span class=\"math display\">\\[\\begin{aligned}\r\n\\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| &lt; \\frac{\\delta}{2p}}\r\n\\log^{+} \\left|\\frac{1}{w- a_{\\mu}}\\right| = &amp; m(r,a_{\\mu}) -\r\n\\frac{1}{2\\pi} \\sum_{1}^{p} \\int_{|w - a_{\\mu}| \\geq\r\n\\frac{\\delta}{2p}}\\log^{+} \\left|\\frac{1}{w- a_{\\mu}}\\right|\\\\\r\n\\geq &amp; m(r,a_{\\mu}) - \\log \\frac{2p}{\\delta}\r\n\\end{aligned}\\]</span></p>\r\n<p>and finally</p>\r\n<p><span class=\"math display\">\\[m(r,f) &gt; \\sum_{1}^{p} m(r,a_{\\mu}) -\r\np \\log\\frac{2p}{\\delta} - \\log 3\\]</span></p>\r\n<p>or in conjunction with (2)</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm (r,\\frac{1}{w^{\\prime}}) &gt; \\sum_{1}^{p} m(r,a_{\\mu}) - m\r\n(r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}}) - p \\log\\frac{2p}{\\delta} - \\log 3\r\n\\end{equation}\\]</span></p>\r\n<p>If the quantities <span class=\"math inline\">\\(N(r,\r\nw^{\\prime})\\)</span> and <span class=\"math inline\">\\(N(r,\r\n\\frac{1}{w^{\\prime}})\\)</span> are now added to both sides of\r\ninequalities (2) and (5), respectively, then using the first main\r\ntheorem</p>\r\n<p><span class=\"math display\">\\[T(r, w^{\\prime}) = T (r,\r\n\\frac{1}{w^{\\prime}}) + \\log |kc_{k}|\\]</span></p>\r\n<p>one obtains the following result, which is to be stated as a special\r\nlemma 1 :</p>\r\n<p>The characteristic <span class=\"math inline\">\\(T(r,\r\nw^{\\prime})\\)</span> for the derivative of the meromorphic function w(z)\r\nlies between the bounds <span class=\"math display\">\\[m(r, w) + N(r,\r\nw^{\\prime}) + m (r,\\frac{w^{\\prime}}{w})\\]</span></p>\r\n<p>and</p>\r\n<p><span class=\"math display\">\\[ \\sum_{1}^{p} m(r,\\frac{1}{w - a_{\\mu}})\r\n+ N (r,\\frac{1}{w^{\\prime}})  - m (r,\\sum\\frac{w^{\\prime}}{w- a_{\\nu}})\r\n- p \\log\\frac{2p}{\\delta} - \\log 3\\]</span></p>\r\n<p>If we leave out T(r, w') and introduce</p>\r\n<p><span class=\"math display\">\\[N_{1}(r) = N(r,\\frac{1}{w^{\\prime}}) +\r\n\\left(2 N(r,w) - N (r,w^{\\prime})\\right)\\]</span></p>\r\n<p>it becomes a version of this theorem. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<p>The estimation is rather lengthy, readers can refer to Hayman, W.[1,\r\nChapter III] and Nevanlinna, Rolf [3, Chapter IX].</p>\r\n<p><strong>Remark:</strong> The quantity <span class=\"math inline\">\\(N_{1}(r)\\)</span> measures the number of multiple\r\npoints of <span class=\"math inline\">\\(w(z)\\)</span>. It can be written\r\nin the form <span class=\"math display\">\\[N_{1}(r) = \\int_{0}^{r}\r\n\\frac{n_{1}(t) - n_{1}(0)}{t} dt + n_{1}(0) \\log r,\r\n\\]</span> where <span class=\"math inline\">\\(n_{1}(r)\\)</span> indicates\r\nthe number of multiple points of <span class=\"math inline\">\\(w(z)\\)</span> in the disk <span class=\"math inline\">\\(|z| &lt; r\\)</span>, each <span class=\"math inline\">\\(k\\)</span>-fold point being counted <span class=\"math inline\">\\(k -\r\n1\\)</span> times.</p>\r\n<p><strong>Vojta's conjecture:</strong> Let <span class=\"math inline\">\\(F\\)</span> be a number field, let <span class=\"math inline\">\\(X/F\\)</span> be a non-singular algebraic variety,\r\nlet <span class=\"math inline\">\\(D\\)</span> be an effective divisor on\r\n<span class=\"math inline\">\\(X\\)</span> with at worst normal crossings,\r\nlet <span class=\"math inline\">\\(H\\)</span> be an ample divisor on <span class=\"math inline\">\\(X\\)</span>, and let <span class=\"math inline\">\\(K_{X}\\)</span> be a canonical divisor on <span class=\"math inline\">\\(X\\)</span>. Choose Weil height functions <span class=\"math inline\">\\(h_{H}\\)</span> and <span class=\"math inline\">\\(h_{K_{X}}\\)</span> and, for each absolute value\r\n<span class=\"math inline\">\\(v\\)</span> on <span class=\"math inline\">\\(F\\)</span>, a local height function <span class=\"math inline\">\\(\\lambda_{D,v}\\)</span>. Fix a finite set of\r\nabsolute values <span class=\"math inline\">\\(S\\)</span> of <span class=\"math inline\">\\(F\\)</span>, and let <span class=\"math inline\">\\(\\epsilon&gt;0\\)</span>. Then there is a constant\r\n<span class=\"math inline\">\\(C\\)</span> and a non-empty Zariski open set\r\n<span class=\"math inline\">\\(U\\subseteq X\\)</span>, depending on all of\r\nthe above choices, such that <span class=\"math display\">\\[\\sum_{v\\in\r\nS}\\lambda_{D,v}(P)+h_{K_{X}}(P)\\leq \\epsilon h_{H}(P)+C \\quad {\\hbox{for\r\nall }}P\\in U(F).\\]</span></p>\r\n<h2 id=\"reference\">Reference</h2>\r\n<p>[1] Hayman, W. (1964). Meromorphic functions. Oxford University\r\npress.</p>\r\n<p>[2] Nevanlinna, Rolf (1925), \"Zur Theorie der Meromorphen\r\nFunktionen\", Acta Mathematica, 46 (1–2): 1–99, doi:10.1007/BF02543858,\r\nISSN 0001-5962</p>\r\n<p>[3] Nevanlinna, Rolf (1970), Analytic functions, Die Grundlehren der\r\nmathematischen Wissenschaften, vol. 162, Berlin, New York:\r\nSpringer-Verlag, MR 0279280</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Feb 25 2024 23:11:07 GMT+0800 (中国标准时间)","title":"Nevanlinna Theory (I)","path":"2023/03/27/Nevanlinna Theory/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-03-27T10:40:09.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-03-27T10:40:09.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Sevaral Complex Variables > Nevanlinna Theory","tags":["Sevaral Complex Variables"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"P = NP","date":"2023-04-10T12:38:46.000Z","mathjax":true,"_content":"\n\n\nWe give the formal statement of \"P=NP\", which plays an important role  in computer science and complexity theory.\n\n\n\n## Definition 1\n\nA function $f:\\mathbb{N}^{k}\\rightarrow \\mathbb{N}$ is ***computable*** if and only if there is an effective procedure that, given any $k$-tuple $\\mathbf{x}$  of natural numbers, will produce the value $f(\\mathbf{x})$\n\n\n## Definition 2\n\nLet $\\Sigma$ be a finite alphabet (that is, a finite nonempty set) with at least two elements, and let $\\Sigma^{*}$ be the set of finite strings over $\\Sigma$. Then a ***language over $\\Sigma$*** is a subset $L$ of $\\Sigma^{*}$.\n\n\n## Definition 3\n\n\nA ***Turing machine $M$*** is a tuple $⟨\\Sigma, \\Gamma, Q, \\delta⟩$, where $\\Sigma, \\Gamma, Q$ are finite nonempty sets with $\\Sigma \\subseteq \\Gamma$ and $b \\in \\Gamma - \\Sigma$. The state set $Q$ contains three special states $q_{0}, q_{accept}, q_{reject}$. The transition function $\\delta$ satisfies \n$$\\delta: (Q − \\{q_{accept}, q_{reject}\\}) \\times \\Gamma \\to  Q \\times \\Gamma × \\{-1, 1\\}.$$\nIf $\\delta(q, s) = (q^{\\prime}, s^{\\prime}, h)$, the interpretation is that, if $M$ is in state $q$ scanning the symbol $s$, then $q^{\\prime}$ is the new state, $s^{\\prime}$ is the symbol printed, and the tape head moves left or right one square depending on whether h is -1 or 1.\n\n\nWe assume that the sets $Q$ and $\\Gamma$ are disjoint.\n\n\n## Definition 4\n\nA ***configuration*** of $M$ is a string $xqy$ with $x, y \\in \\Gamma^{*}$, $y$ not the empty string, and $q \\in Q$. If $C$ and $C^{\\prime}$ are configurations, then $C \\overset{M}{\\to} C^{\\prime}$ if $C = xqsy$ and $\\delta(q, s) = (q^{\\prime}, s^{\\prime}, h)$ and one of the following holds:\n\n- $C^{\\prime} = xs^{\\prime}q^{\\prime}y$ and $h = 1$ and $y$ is nonempty.\n\n- $C^{\\prime} = xs^{\\prime}q^{\\prime}b$ and $h = 1$ and $y$ is empty.\n\n- $C^{\\prime} = x^{\\prime}q^{\\prime}as^{\\prime}y$ and $h = -1$ and $x = x^{\\prime}a$ for some $a \\in \\Gamma$.\n\n- $C^{\\prime} = q^{\\prime}bs^{\\prime}y$ and $h = -1$ and $x$ is empty.\n\nA configuration $xqy$ is ***halting*** if $q \\in \\{q_{accept}, q_{reject}\\}$. Note that for each non-halting configuration $C$ there is a unique configuration $C^{\\prime}$ such that $C \\overset{M}{\\to} C^{\\prime}$. \n\n## Definition 5\n\nThe ***computation*** of $M$ on input $w \\in \\Sigma^{*}$ is the unique sequence $C_{0}, C_{1}, \\cdots$ of configurations such that $C_{0} = q_{0}w$ (or $C_{0} = q_{0}b$ if $w$ is empty) and $C_{i} \\overset{M}{\\to} C_{i+1}^{\\prime}$ for each $i$ with $C_{i+1}$ in the computation, and either the sequence is infinite or it ends in a halting configuration. If the computation is finite, then the number of steps is one less than the number of configurations; otherwise the number of steps is infinite. We say that $M$ ***accepts*** $w$ iff the computation is finite and the final configuration contains the state qaccept\n\n## Theorem 1 [Turing 1936]\nThere is no TM $M$ such that for all TMs $N$, if $M$ is run\nwith a code of $N$ on its tape, then the following hold:\n\n1. If $N$ eventually halts when run on the empty tape, then $M$ eventually halts with $1$ on the tape and the reading head on the square with the $1$.\n\n2. If $N$ does not eventually halt when run on the empty tape, then $M$ eventually halts with the tape completely empty.\n\n\n## Theorem 2\nThe set $HALT$ is not decidable, where\n$$HALT = \\left\\{M : M \\text{ is a Turing machine which halts on the empty tape }\\right\\}$$\n\n## Definition\n\nThe halting function is a function $h$ of two arguments\n\n$$h(m,n) = \\begin{cases}0, & \\text{ machine $m$, started\nwith input $n$, eventually halts }\\\\\n1, & \\text{  machine $m$, started\nwith input $n$, never halts }\n\\end{cases}$$\n\n\nBy definition of Turing computability, Halting problem is not decidable if and only if halting function $h$ is not Turing computable.\n\n## Lemma 1\n\nThe halting function h is not Turing computable.\n\n## Proof of Lemma 1\n\nBy way of background we need two special Turing machines.\n\n1. A copying machine $C$. Given a tape containing a block of $n$ strokes, and otherwise blank, if the machine is started scanning the leftmost stroke on the tape, it will eventually halt with the tape containing two blocks of $n$ strokes separated by a blank, and otherwise blank, with the machine scanning the leftmost stroke on the tape.\n\n2. A dithering machine $D$. Started on the leftmost of a block of $n$ strokes on an otherwise blank tape, $D$ eventually halts if $n > 1$, but never halts if $n = 1$.\n\nNow suppose we had a machine $H$ that computed the function $h$. We could combine the machines $C$ and $H$ as follows: if the states of $C$ are numbered $1$ through $p$, and the states of $H$ are numbered $1$ through $q$, renumber the latter states $p + 1$ through $r = p + q$, and write these renumbered instructions after the instructions\nfor $C$. Originally, $C$ tells us to halt by telling us to go into state $p + 1$, but in the new combined instructions, going into state $p + 1$ means not halting, but beginning the operations of machine $H$. So the new combined instructions will have us first go through the operations of $C$, and then, when $C$ would have halted, go through\nthe operations of $H$. The result is thus a machine $G$ that computes the function $g(n) = h(n, n)$.\n\nWe now combine this machine $G$ with the dithering machine $D$, renumbering the states of the latter as $r + 1$ and $r + 2$, and writing its instructions after those for $G$. The result will be a machine $M$ that goes through the operations of $G$ and then the operations of $D$. Thus if machine number $n$ halts when started on its own number, that is, if $h(n, n) = g(n) = 1$, then the machine $M$ does not halt when started on that number $n$, whereas if machine number $n$ does not halt when started on its own number, that is, if $h(n, n) = g(n) = 2$, then machine $M$ does halt when started on $n$.\nBut of course there can be no such machine as $M$. For what would it do if started with input its own number $m$? It would halt if and only if machine number $m$, which is to say itself, does not halt when started with input the number $m$. This contradiction shows there can be no such machine as $H$.\n\n\n## Lemma 2\n\nThere exist TMs $C$ and $D$ satisfying conditions in Lemma 1.\n\n## Proof of Lemma 2\n\nThe instruction set of $$ consists of:\n\n(1) The reading and writing head of the Turing machine moves to the right until it stops at the square where the second letter is $0$, and the letter in the square is changed to $1$. Thus, two strings composed of $1$ separated by one or some in the middle appear on the paper tape, which will continue to exist in the operation of the Turing machine after that. We call the left as input string and the right as carbon string. The corresponding instruction is\n\n$$(q_{1},s_{1},R,q_{1}), (q_{1},s_{0},R,q_{2}), (q_{2},s_{0},1,q_{2}).$$\n\n(2) Move Turing's read/write head left to the first square on the right of the input string:\n$$(q_{2},s_{1},L,q_{3}), (q_{3},s_{0},L,q_{3}).$$\n\n(3) Then determine whether the input string has more than one square. And\n\n(i). If there is more than one square in the input string, the read/write head returns to the first square to the right of the input string, rewrites the letter as $0$, then continues to the right until the first square to the right of the carbon string, rewrites the letter as $1$, then return to step (2). The corresponding instruction is:\n\n$$\\begin{aligned}\n(q_{3},s_{1},L,q_{4}), (q_{4},s_{1},R,q_{5}), (q_{5},s_{1},s_{0},q_{6}), (q_{5},s_{0},s_{0},q_{0}),\\\\\n(q_{6},s_{0},R,q_{6}), (q_{6},s_{1},s_{1},q_{7}), (q_{7},s_{1},R,q_{7}), (q_{7},s_{0},s_{1},q_{2}).\n\\end{aligned}$$\n\n(ii). If there is only one square in the input string, then the read/write head changes the letter in the $n-1$ square to the right as $1$, then returns to square $0$ and stops. The corresponding instruction is:\n\n$$\\begin{aligned}\n(q_{4},s_{0},R,q_{8}), (q_{8},s_{1},R,q_{9}), (q_{9},s_{0},s_{1},q_{9}), (q_{9},s_{1},L,q_{10}),\\\\\n(q_{10},s_{1},s_{0},q_{16}), (q_{10},s_{0},L,q_{11}), (q_{11},s_{1},L,q_{11}), (q_{11},s_{0},L,q_{0}).\n\\end{aligned}$$\n\nIt is easy to verify that a Turing machine composed of instructions (1), (2), and (3) is the replicating machine in question. As for Turing machine $D$, we simply set its instruction set to $(q_{1},s_{0},s_{0},q_{0}),(q_{1},s_{1},R,q_{1})$.$\\square$\n\n## Formal Statement P = NP\n\nWe say that $M$ accepts $w$ if this computation terminates in the accepting state. The language accepted by $M$, denoted $L(M)$, has associated alphabet $\\Sigma$ and is defined by\n\n\n$$ L(M) = \\{w \\in \\Sigma^{*} | M \\text{ accepts } w\\}.$$\n\nWe denote by $t_{M}(w)$ the number of steps in the computation of $M$ on input $w$. If this computation never halts, then $t_{M}(w) = \\infty$. For $n \\in \\mathbb{N}$ we denote by $T_{M}(n)$ the worst case run time of $M$; that is\n\n$$T_{M}(n) = \\max \\{ t_{M}(w) | w \\in \\Sigma^{n} \\},$$\n\nwhere $\\Sigma^{n}$ is the set of all strings over $\\Sigma$ of length $n$. We say that $M$ runs in polynomial time if there exists $k$ such that for all $n$, $T_{M}(n) \\leq n^{k} + k$. Now we define the class $\\mathbf{P}$ of languages by\n\n$$\\mathbf{P} = \\left\\{L | L = L(M) \\text{ for some Turing machine $M$ that runs\nin polynomial time}\\right\\}$$\n\nThe notation $\\mathbf{NP}$ stands for “nondeterministic polynomial time”.\n\n## Definition 6\n\nA ***checking relation*** is a binary relation $R \\subseteq \\Sigma^{*} \\times \\Sigma^{*}_{1}$ for some finite alphabets $\\Sigma$ and $\\Sigma_{1}$. We associate with each such relation $R$ a language $L_{R}$ over $\\Sigma \\cup \\Sigma_{1} \\cup \\{ \\# \\}$ defined by\n$$L_{R} = \\left\\{w \\# y | R(w, y)\\right\\}$$\nwhere the symbol $\\#$ is not in $\\Sigma$.\n\nWe say that $R$ is polynomial-time iff $L_{R} \\in \\mathbf{P}$. Now we define the class NP of languages by the condition that a language $L$ over $\\Sigma$ is in $\\mathbf{NP}$ iff there is $k \\in \\mathbb{N}$ and a polynomial-time checking relation $R$ such that for all $w \\in \\Sigma^{∗}$,\n$$w \\in L \\Longleftrightarrow \\exists y\\left(|y| \\leq |w|^{k} \\land R(w, y)\\right).$$\nwhere $|w|$ and $|y|$ denote the lengths of $w$ and $y$, respectively.\n\n\n<h2> Problem Statement: Dose P = NP? </h2>\n\n\n\n# Reference \n\n[1] Turing, A. M. (1938). On Computable Numbers, with an Application to the Entscheidungsproblem. Proceedings of the London Mathematical Society. Wiley. s2-42 (1): 230–265.\n\n\n\n","source":"_posts/P=NP.md","raw":"---\ntitle: \"P = NP\"\ndate: 2023-04-10 20:38:46\ntags:\n    - [Notes]\n    - [Mathematical Logic]\ncategories:\n    - [Notes]\n    - [Mathematical Logic]\nmathjax: true\n---\n\n\n\nWe give the formal statement of \"P=NP\", which plays an important role  in computer science and complexity theory.\n\n\n\n## Definition 1\n\nA function $f:\\mathbb{N}^{k}\\rightarrow \\mathbb{N}$ is ***computable*** if and only if there is an effective procedure that, given any $k$-tuple $\\mathbf{x}$  of natural numbers, will produce the value $f(\\mathbf{x})$\n\n\n## Definition 2\n\nLet $\\Sigma$ be a finite alphabet (that is, a finite nonempty set) with at least two elements, and let $\\Sigma^{*}$ be the set of finite strings over $\\Sigma$. Then a ***language over $\\Sigma$*** is a subset $L$ of $\\Sigma^{*}$.\n\n\n## Definition 3\n\n\nA ***Turing machine $M$*** is a tuple $⟨\\Sigma, \\Gamma, Q, \\delta⟩$, where $\\Sigma, \\Gamma, Q$ are finite nonempty sets with $\\Sigma \\subseteq \\Gamma$ and $b \\in \\Gamma - \\Sigma$. The state set $Q$ contains three special states $q_{0}, q_{accept}, q_{reject}$. The transition function $\\delta$ satisfies \n$$\\delta: (Q − \\{q_{accept}, q_{reject}\\}) \\times \\Gamma \\to  Q \\times \\Gamma × \\{-1, 1\\}.$$\nIf $\\delta(q, s) = (q^{\\prime}, s^{\\prime}, h)$, the interpretation is that, if $M$ is in state $q$ scanning the symbol $s$, then $q^{\\prime}$ is the new state, $s^{\\prime}$ is the symbol printed, and the tape head moves left or right one square depending on whether h is -1 or 1.\n\n\nWe assume that the sets $Q$ and $\\Gamma$ are disjoint.\n\n\n## Definition 4\n\nA ***configuration*** of $M$ is a string $xqy$ with $x, y \\in \\Gamma^{*}$, $y$ not the empty string, and $q \\in Q$. If $C$ and $C^{\\prime}$ are configurations, then $C \\overset{M}{\\to} C^{\\prime}$ if $C = xqsy$ and $\\delta(q, s) = (q^{\\prime}, s^{\\prime}, h)$ and one of the following holds:\n\n- $C^{\\prime} = xs^{\\prime}q^{\\prime}y$ and $h = 1$ and $y$ is nonempty.\n\n- $C^{\\prime} = xs^{\\prime}q^{\\prime}b$ and $h = 1$ and $y$ is empty.\n\n- $C^{\\prime} = x^{\\prime}q^{\\prime}as^{\\prime}y$ and $h = -1$ and $x = x^{\\prime}a$ for some $a \\in \\Gamma$.\n\n- $C^{\\prime} = q^{\\prime}bs^{\\prime}y$ and $h = -1$ and $x$ is empty.\n\nA configuration $xqy$ is ***halting*** if $q \\in \\{q_{accept}, q_{reject}\\}$. Note that for each non-halting configuration $C$ there is a unique configuration $C^{\\prime}$ such that $C \\overset{M}{\\to} C^{\\prime}$. \n\n## Definition 5\n\nThe ***computation*** of $M$ on input $w \\in \\Sigma^{*}$ is the unique sequence $C_{0}, C_{1}, \\cdots$ of configurations such that $C_{0} = q_{0}w$ (or $C_{0} = q_{0}b$ if $w$ is empty) and $C_{i} \\overset{M}{\\to} C_{i+1}^{\\prime}$ for each $i$ with $C_{i+1}$ in the computation, and either the sequence is infinite or it ends in a halting configuration. If the computation is finite, then the number of steps is one less than the number of configurations; otherwise the number of steps is infinite. We say that $M$ ***accepts*** $w$ iff the computation is finite and the final configuration contains the state qaccept\n\n## Theorem 1 [Turing 1936]\nThere is no TM $M$ such that for all TMs $N$, if $M$ is run\nwith a code of $N$ on its tape, then the following hold:\n\n1. If $N$ eventually halts when run on the empty tape, then $M$ eventually halts with $1$ on the tape and the reading head on the square with the $1$.\n\n2. If $N$ does not eventually halt when run on the empty tape, then $M$ eventually halts with the tape completely empty.\n\n\n## Theorem 2\nThe set $HALT$ is not decidable, where\n$$HALT = \\left\\{M : M \\text{ is a Turing machine which halts on the empty tape }\\right\\}$$\n\n## Definition\n\nThe halting function is a function $h$ of two arguments\n\n$$h(m,n) = \\begin{cases}0, & \\text{ machine $m$, started\nwith input $n$, eventually halts }\\\\\n1, & \\text{  machine $m$, started\nwith input $n$, never halts }\n\\end{cases}$$\n\n\nBy definition of Turing computability, Halting problem is not decidable if and only if halting function $h$ is not Turing computable.\n\n## Lemma 1\n\nThe halting function h is not Turing computable.\n\n## Proof of Lemma 1\n\nBy way of background we need two special Turing machines.\n\n1. A copying machine $C$. Given a tape containing a block of $n$ strokes, and otherwise blank, if the machine is started scanning the leftmost stroke on the tape, it will eventually halt with the tape containing two blocks of $n$ strokes separated by a blank, and otherwise blank, with the machine scanning the leftmost stroke on the tape.\n\n2. A dithering machine $D$. Started on the leftmost of a block of $n$ strokes on an otherwise blank tape, $D$ eventually halts if $n > 1$, but never halts if $n = 1$.\n\nNow suppose we had a machine $H$ that computed the function $h$. We could combine the machines $C$ and $H$ as follows: if the states of $C$ are numbered $1$ through $p$, and the states of $H$ are numbered $1$ through $q$, renumber the latter states $p + 1$ through $r = p + q$, and write these renumbered instructions after the instructions\nfor $C$. Originally, $C$ tells us to halt by telling us to go into state $p + 1$, but in the new combined instructions, going into state $p + 1$ means not halting, but beginning the operations of machine $H$. So the new combined instructions will have us first go through the operations of $C$, and then, when $C$ would have halted, go through\nthe operations of $H$. The result is thus a machine $G$ that computes the function $g(n) = h(n, n)$.\n\nWe now combine this machine $G$ with the dithering machine $D$, renumbering the states of the latter as $r + 1$ and $r + 2$, and writing its instructions after those for $G$. The result will be a machine $M$ that goes through the operations of $G$ and then the operations of $D$. Thus if machine number $n$ halts when started on its own number, that is, if $h(n, n) = g(n) = 1$, then the machine $M$ does not halt when started on that number $n$, whereas if machine number $n$ does not halt when started on its own number, that is, if $h(n, n) = g(n) = 2$, then machine $M$ does halt when started on $n$.\nBut of course there can be no such machine as $M$. For what would it do if started with input its own number $m$? It would halt if and only if machine number $m$, which is to say itself, does not halt when started with input the number $m$. This contradiction shows there can be no such machine as $H$.\n\n\n## Lemma 2\n\nThere exist TMs $C$ and $D$ satisfying conditions in Lemma 1.\n\n## Proof of Lemma 2\n\nThe instruction set of $$ consists of:\n\n(1) The reading and writing head of the Turing machine moves to the right until it stops at the square where the second letter is $0$, and the letter in the square is changed to $1$. Thus, two strings composed of $1$ separated by one or some in the middle appear on the paper tape, which will continue to exist in the operation of the Turing machine after that. We call the left as input string and the right as carbon string. The corresponding instruction is\n\n$$(q_{1},s_{1},R,q_{1}), (q_{1},s_{0},R,q_{2}), (q_{2},s_{0},1,q_{2}).$$\n\n(2) Move Turing's read/write head left to the first square on the right of the input string:\n$$(q_{2},s_{1},L,q_{3}), (q_{3},s_{0},L,q_{3}).$$\n\n(3) Then determine whether the input string has more than one square. And\n\n(i). If there is more than one square in the input string, the read/write head returns to the first square to the right of the input string, rewrites the letter as $0$, then continues to the right until the first square to the right of the carbon string, rewrites the letter as $1$, then return to step (2). The corresponding instruction is:\n\n$$\\begin{aligned}\n(q_{3},s_{1},L,q_{4}), (q_{4},s_{1},R,q_{5}), (q_{5},s_{1},s_{0},q_{6}), (q_{5},s_{0},s_{0},q_{0}),\\\\\n(q_{6},s_{0},R,q_{6}), (q_{6},s_{1},s_{1},q_{7}), (q_{7},s_{1},R,q_{7}), (q_{7},s_{0},s_{1},q_{2}).\n\\end{aligned}$$\n\n(ii). If there is only one square in the input string, then the read/write head changes the letter in the $n-1$ square to the right as $1$, then returns to square $0$ and stops. The corresponding instruction is:\n\n$$\\begin{aligned}\n(q_{4},s_{0},R,q_{8}), (q_{8},s_{1},R,q_{9}), (q_{9},s_{0},s_{1},q_{9}), (q_{9},s_{1},L,q_{10}),\\\\\n(q_{10},s_{1},s_{0},q_{16}), (q_{10},s_{0},L,q_{11}), (q_{11},s_{1},L,q_{11}), (q_{11},s_{0},L,q_{0}).\n\\end{aligned}$$\n\nIt is easy to verify that a Turing machine composed of instructions (1), (2), and (3) is the replicating machine in question. As for Turing machine $D$, we simply set its instruction set to $(q_{1},s_{0},s_{0},q_{0}),(q_{1},s_{1},R,q_{1})$.$\\square$\n\n## Formal Statement P = NP\n\nWe say that $M$ accepts $w$ if this computation terminates in the accepting state. The language accepted by $M$, denoted $L(M)$, has associated alphabet $\\Sigma$ and is defined by\n\n\n$$ L(M) = \\{w \\in \\Sigma^{*} | M \\text{ accepts } w\\}.$$\n\nWe denote by $t_{M}(w)$ the number of steps in the computation of $M$ on input $w$. If this computation never halts, then $t_{M}(w) = \\infty$. For $n \\in \\mathbb{N}$ we denote by $T_{M}(n)$ the worst case run time of $M$; that is\n\n$$T_{M}(n) = \\max \\{ t_{M}(w) | w \\in \\Sigma^{n} \\},$$\n\nwhere $\\Sigma^{n}$ is the set of all strings over $\\Sigma$ of length $n$. We say that $M$ runs in polynomial time if there exists $k$ such that for all $n$, $T_{M}(n) \\leq n^{k} + k$. Now we define the class $\\mathbf{P}$ of languages by\n\n$$\\mathbf{P} = \\left\\{L | L = L(M) \\text{ for some Turing machine $M$ that runs\nin polynomial time}\\right\\}$$\n\nThe notation $\\mathbf{NP}$ stands for “nondeterministic polynomial time”.\n\n## Definition 6\n\nA ***checking relation*** is a binary relation $R \\subseteq \\Sigma^{*} \\times \\Sigma^{*}_{1}$ for some finite alphabets $\\Sigma$ and $\\Sigma_{1}$. We associate with each such relation $R$ a language $L_{R}$ over $\\Sigma \\cup \\Sigma_{1} \\cup \\{ \\# \\}$ defined by\n$$L_{R} = \\left\\{w \\# y | R(w, y)\\right\\}$$\nwhere the symbol $\\#$ is not in $\\Sigma$.\n\nWe say that $R$ is polynomial-time iff $L_{R} \\in \\mathbf{P}$. Now we define the class NP of languages by the condition that a language $L$ over $\\Sigma$ is in $\\mathbf{NP}$ iff there is $k \\in \\mathbb{N}$ and a polynomial-time checking relation $R$ such that for all $w \\in \\Sigma^{∗}$,\n$$w \\in L \\Longleftrightarrow \\exists y\\left(|y| \\leq |w|^{k} \\land R(w, y)\\right).$$\nwhere $|w|$ and $|y|$ denote the lengths of $w$ and $y$, respectively.\n\n\n<h2> Problem Statement: Dose P = NP? </h2>\n\n\n\n# Reference \n\n[1] Turing, A. M. (1938). On Computable Numbers, with an Application to the Entscheidungsproblem. Proceedings of the London Mathematical Society. Wiley. s2-42 (1): 230–265.\n\n\n\n","slug":"P=NP","published":1,"updated":"2024-11-27T15:24:02.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5s3001mm8nx9my9d75h","content":"<p>We give the formal statement of \"P=NP\", which plays an important role\r\nin computer science and complexity theory.</p>\r\n<h2 id=\"definition-1\">Definition 1</h2>\r\n<p>A function <span class=\"math inline\">\\(f:\\mathbb{N}^{k}\\rightarrow\r\n\\mathbb{N}\\)</span> is <strong><em>computable</em></strong> if and only\r\nif there is an effective procedure that, given any <span class=\"math inline\">\\(k\\)</span>-tuple <span class=\"math inline\">\\(\\mathbf{x}\\)</span> of natural numbers, will\r\nproduce the value <span class=\"math inline\">\\(f(\\mathbf{x})\\)</span></p>\r\n<h2 id=\"definition-2\">Definition 2</h2>\r\n<p>Let <span class=\"math inline\">\\(\\Sigma\\)</span> be a finite alphabet\r\n(that is, a finite nonempty set) with at least two elements, and let\r\n<span class=\"math inline\">\\(\\Sigma^{*}\\)</span> be the set of finite\r\nstrings over <span class=\"math inline\">\\(\\Sigma\\)</span>. Then a\r\n<strong><em>language over <span class=\"math inline\">\\(\\Sigma\\)</span></em></strong> is a subset <span class=\"math inline\">\\(L\\)</span> of <span class=\"math inline\">\\(\\Sigma^{*}\\)</span>.</p>\r\n<h2 id=\"definition-3\">Definition 3</h2>\r\n<p>A <strong><em>Turing machine <span class=\"math inline\">\\(M\\)</span></em></strong> is a tuple <span class=\"math inline\">\\(⟨\\Sigma, \\Gamma, Q, \\delta⟩\\)</span>, where <span class=\"math inline\">\\(\\Sigma, \\Gamma, Q\\)</span> are finite nonempty\r\nsets with <span class=\"math inline\">\\(\\Sigma \\subseteq \\Gamma\\)</span>\r\nand <span class=\"math inline\">\\(b \\in \\Gamma - \\Sigma\\)</span>. The\r\nstate set <span class=\"math inline\">\\(Q\\)</span> contains three special\r\nstates <span class=\"math inline\">\\(q_{0}, q_{accept},\r\nq_{reject}\\)</span>. The transition function <span class=\"math inline\">\\(\\delta\\)</span> satisfies <span class=\"math display\">\\[\\delta: (Q − \\{q_{accept}, q_{reject}\\}) \\times\r\n\\Gamma \\to  Q \\times \\Gamma × \\{-1, 1\\}.\\]</span> If <span class=\"math inline\">\\(\\delta(q, s) = (q^{\\prime}, s^{\\prime},\r\nh)\\)</span>, the interpretation is that, if <span class=\"math inline\">\\(M\\)</span> is in state <span class=\"math inline\">\\(q\\)</span> scanning the symbol <span class=\"math inline\">\\(s\\)</span>, then <span class=\"math inline\">\\(q^{\\prime}\\)</span> is the new state, <span class=\"math inline\">\\(s^{\\prime}\\)</span> is the symbol printed, and the\r\ntape head moves left or right one square depending on whether h is -1 or\r\n1.</p>\r\n<p>We assume that the sets <span class=\"math inline\">\\(Q\\)</span> and\r\n<span class=\"math inline\">\\(\\Gamma\\)</span> are disjoint.</p>\r\n<h2 id=\"definition-4\">Definition 4</h2>\r\n<p>A <strong><em>configuration</em></strong> of <span class=\"math inline\">\\(M\\)</span> is a string <span class=\"math inline\">\\(xqy\\)</span> with <span class=\"math inline\">\\(x, y\r\n\\in \\Gamma^{*}\\)</span>, <span class=\"math inline\">\\(y\\)</span> not the\r\nempty string, and <span class=\"math inline\">\\(q \\in Q\\)</span>. If <span class=\"math inline\">\\(C\\)</span> and <span class=\"math inline\">\\(C^{\\prime}\\)</span> are configurations, then <span class=\"math inline\">\\(C \\overset{M}{\\to} C^{\\prime}\\)</span> if <span class=\"math inline\">\\(C = xqsy\\)</span> and <span class=\"math inline\">\\(\\delta(q, s) = (q^{\\prime}, s^{\\prime},\r\nh)\\)</span> and one of the following holds:</p>\r\n<ul>\r\n<li><p><span class=\"math inline\">\\(C^{\\prime} =\r\nxs^{\\prime}q^{\\prime}y\\)</span> and <span class=\"math inline\">\\(h =\r\n1\\)</span> and <span class=\"math inline\">\\(y\\)</span> is\r\nnonempty.</p></li>\r\n<li><p><span class=\"math inline\">\\(C^{\\prime} =\r\nxs^{\\prime}q^{\\prime}b\\)</span> and <span class=\"math inline\">\\(h =\r\n1\\)</span> and <span class=\"math inline\">\\(y\\)</span> is empty.</p></li>\r\n<li><p><span class=\"math inline\">\\(C^{\\prime} =\r\nx^{\\prime}q^{\\prime}as^{\\prime}y\\)</span> and <span class=\"math inline\">\\(h = -1\\)</span> and <span class=\"math inline\">\\(x\r\n= x^{\\prime}a\\)</span> for some <span class=\"math inline\">\\(a \\in\r\n\\Gamma\\)</span>.</p></li>\r\n<li><p><span class=\"math inline\">\\(C^{\\prime} =\r\nq^{\\prime}bs^{\\prime}y\\)</span> and <span class=\"math inline\">\\(h =\r\n-1\\)</span> and <span class=\"math inline\">\\(x\\)</span> is\r\nempty.</p></li>\r\n</ul>\r\n<p>A configuration <span class=\"math inline\">\\(xqy\\)</span> is\r\n<strong><em>halting</em></strong> if <span class=\"math inline\">\\(q \\in\r\n\\{q_{accept}, q_{reject}\\}\\)</span>. Note that for each non-halting\r\nconfiguration <span class=\"math inline\">\\(C\\)</span> there is a unique\r\nconfiguration <span class=\"math inline\">\\(C^{\\prime}\\)</span> such that\r\n<span class=\"math inline\">\\(C \\overset{M}{\\to} C^{\\prime}\\)</span>.</p>\r\n<h2 id=\"definition-5\">Definition 5</h2>\r\n<p>The <strong><em>computation</em></strong> of <span class=\"math inline\">\\(M\\)</span> on input <span class=\"math inline\">\\(w\r\n\\in \\Sigma^{*}\\)</span> is the unique sequence <span class=\"math inline\">\\(C_{0}, C_{1}, \\cdots\\)</span> of configurations\r\nsuch that <span class=\"math inline\">\\(C_{0} = q_{0}w\\)</span> (or <span class=\"math inline\">\\(C_{0} = q_{0}b\\)</span> if <span class=\"math inline\">\\(w\\)</span> is empty) and <span class=\"math inline\">\\(C_{i} \\overset{M}{\\to} C_{i+1}^{\\prime}\\)</span>\r\nfor each <span class=\"math inline\">\\(i\\)</span> with <span class=\"math inline\">\\(C_{i+1}\\)</span> in the computation, and either\r\nthe sequence is infinite or it ends in a halting configuration. If the\r\ncomputation is finite, then the number of steps is one less than the\r\nnumber of configurations; otherwise the number of steps is infinite. We\r\nsay that <span class=\"math inline\">\\(M\\)</span>\r\n<strong><em>accepts</em></strong> <span class=\"math inline\">\\(w\\)</span>\r\niff the computation is finite and the final configuration contains the\r\nstate qaccept</p>\r\n<h2 id=\"theorem-1-turing-1936\">Theorem 1 [Turing 1936]</h2>\r\n<p>There is no TM <span class=\"math inline\">\\(M\\)</span> such that for\r\nall TMs <span class=\"math inline\">\\(N\\)</span>, if <span class=\"math inline\">\\(M\\)</span> is run with a code of <span class=\"math inline\">\\(N\\)</span> on its tape, then the following\r\nhold:</p>\r\n<ol type=\"1\">\r\n<li><p>If <span class=\"math inline\">\\(N\\)</span> eventually halts when\r\nrun on the empty tape, then <span class=\"math inline\">\\(M\\)</span>\r\neventually halts with <span class=\"math inline\">\\(1\\)</span> on the tape\r\nand the reading head on the square with the <span class=\"math inline\">\\(1\\)</span>.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(N\\)</span> does not eventually\r\nhalt when run on the empty tape, then <span class=\"math inline\">\\(M\\)</span> eventually halts with the tape\r\ncompletely empty.</p></li>\r\n</ol>\r\n<h2 id=\"theorem-2\">Theorem 2</h2>\r\n<p>The set <span class=\"math inline\">\\(HALT\\)</span> is not decidable,\r\nwhere <span class=\"math display\">\\[HALT = \\left\\{M : M \\text{ is a\r\nTuring machine which halts on the empty tape }\\right\\}\\]</span></p>\r\n<h2 id=\"definition\">Definition</h2>\r\n<p>The halting function is a function <span class=\"math inline\">\\(h\\)</span> of two arguments</p>\r\n<p><span class=\"math display\">\\[h(m,n) = \\begin{cases}0, &amp; \\text{\r\nmachine $m$, started\r\nwith input $n$, eventually halts }\\\\\r\n1, &amp; \\text{  machine $m$, started\r\nwith input $n$, never halts }\r\n\\end{cases}\\]</span></p>\r\n<p>By definition of Turing computability, Halting problem is not\r\ndecidable if and only if halting function <span class=\"math inline\">\\(h\\)</span> is not Turing computable.</p>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>The halting function h is not Turing computable.</p>\r\n<h2 id=\"proof-of-lemma-1\">Proof of Lemma 1</h2>\r\n<p>By way of background we need two special Turing machines.</p>\r\n<ol type=\"1\">\r\n<li><p>A copying machine <span class=\"math inline\">\\(C\\)</span>. Given a\r\ntape containing a block of <span class=\"math inline\">\\(n\\)</span>\r\nstrokes, and otherwise blank, if the machine is started scanning the\r\nleftmost stroke on the tape, it will eventually halt with the tape\r\ncontaining two blocks of <span class=\"math inline\">\\(n\\)</span> strokes\r\nseparated by a blank, and otherwise blank, with the machine scanning the\r\nleftmost stroke on the tape.</p></li>\r\n<li><p>A dithering machine <span class=\"math inline\">\\(D\\)</span>.\r\nStarted on the leftmost of a block of <span class=\"math inline\">\\(n\\)</span> strokes on an otherwise blank tape,\r\n<span class=\"math inline\">\\(D\\)</span> eventually halts if <span class=\"math inline\">\\(n &gt; 1\\)</span>, but never halts if <span class=\"math inline\">\\(n = 1\\)</span>.</p></li>\r\n</ol>\r\n<p>Now suppose we had a machine <span class=\"math inline\">\\(H\\)</span>\r\nthat computed the function <span class=\"math inline\">\\(h\\)</span>. We\r\ncould combine the machines <span class=\"math inline\">\\(C\\)</span> and\r\n<span class=\"math inline\">\\(H\\)</span> as follows: if the states of\r\n<span class=\"math inline\">\\(C\\)</span> are numbered <span class=\"math inline\">\\(1\\)</span> through <span class=\"math inline\">\\(p\\)</span>, and the states of <span class=\"math inline\">\\(H\\)</span> are numbered <span class=\"math inline\">\\(1\\)</span> through <span class=\"math inline\">\\(q\\)</span>, renumber the latter states <span class=\"math inline\">\\(p + 1\\)</span> through <span class=\"math inline\">\\(r = p + q\\)</span>, and write these renumbered\r\ninstructions after the instructions for <span class=\"math inline\">\\(C\\)</span>. Originally, <span class=\"math inline\">\\(C\\)</span> tells us to halt by telling us to go\r\ninto state <span class=\"math inline\">\\(p + 1\\)</span>, but in the new\r\ncombined instructions, going into state <span class=\"math inline\">\\(p +\r\n1\\)</span> means not halting, but beginning the operations of machine\r\n<span class=\"math inline\">\\(H\\)</span>. So the new combined instructions\r\nwill have us first go through the operations of <span class=\"math inline\">\\(C\\)</span>, and then, when <span class=\"math inline\">\\(C\\)</span> would have halted, go through the\r\noperations of <span class=\"math inline\">\\(H\\)</span>. The result is thus\r\na machine <span class=\"math inline\">\\(G\\)</span> that computes the\r\nfunction <span class=\"math inline\">\\(g(n) = h(n, n)\\)</span>.</p>\r\n<p>We now combine this machine <span class=\"math inline\">\\(G\\)</span>\r\nwith the dithering machine <span class=\"math inline\">\\(D\\)</span>,\r\nrenumbering the states of the latter as <span class=\"math inline\">\\(r +\r\n1\\)</span> and <span class=\"math inline\">\\(r + 2\\)</span>, and writing\r\nits instructions after those for <span class=\"math inline\">\\(G\\)</span>.\r\nThe result will be a machine <span class=\"math inline\">\\(M\\)</span> that\r\ngoes through the operations of <span class=\"math inline\">\\(G\\)</span>\r\nand then the operations of <span class=\"math inline\">\\(D\\)</span>. Thus\r\nif machine number <span class=\"math inline\">\\(n\\)</span> halts when\r\nstarted on its own number, that is, if <span class=\"math inline\">\\(h(n,\r\nn) = g(n) = 1\\)</span>, then the machine <span class=\"math inline\">\\(M\\)</span> does not halt when started on that\r\nnumber <span class=\"math inline\">\\(n\\)</span>, whereas if machine number\r\n<span class=\"math inline\">\\(n\\)</span> does not halt when started on its\r\nown number, that is, if <span class=\"math inline\">\\(h(n, n) = g(n) =\r\n2\\)</span>, then machine <span class=\"math inline\">\\(M\\)</span> does\r\nhalt when started on <span class=\"math inline\">\\(n\\)</span>. But of\r\ncourse there can be no such machine as <span class=\"math inline\">\\(M\\)</span>. For what would it do if started with\r\ninput its own number <span class=\"math inline\">\\(m\\)</span>? It would\r\nhalt if and only if machine number <span class=\"math inline\">\\(m\\)</span>, which is to say itself, does not halt\r\nwhen started with input the number <span class=\"math inline\">\\(m\\)</span>. This contradiction shows there can be\r\nno such machine as <span class=\"math inline\">\\(H\\)</span>.</p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>There exist TMs <span class=\"math inline\">\\(C\\)</span> and <span class=\"math inline\">\\(D\\)</span> satisfying conditions in Lemma 1.</p>\r\n<h2 id=\"proof-of-lemma-2\">Proof of Lemma 2</h2>\r\n<p>The instruction set of $$ consists of:</p>\r\n<ol type=\"1\">\r\n<li>The reading and writing head of the Turing machine moves to the\r\nright until it stops at the square where the second letter is <span class=\"math inline\">\\(0\\)</span>, and the letter in the square is\r\nchanged to <span class=\"math inline\">\\(1\\)</span>. Thus, two strings\r\ncomposed of <span class=\"math inline\">\\(1\\)</span> separated by one or\r\nsome in the middle appear on the paper tape, which will continue to\r\nexist in the operation of the Turing machine after that. We call the\r\nleft as input string and the right as carbon string. The corresponding\r\ninstruction is</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[(q_{1},s_{1},R,q_{1}),\r\n(q_{1},s_{0},R,q_{2}), (q_{2},s_{0},1,q_{2}).\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li><p>Move Turing's read/write head left to the first square on the\r\nright of the input string: <span class=\"math display\">\\[(q_{2},s_{1},L,q_{3}),\r\n(q_{3},s_{0},L,q_{3}).\\]</span></p></li>\r\n<li><p>Then determine whether the input string has more than one square.\r\nAnd</p></li>\r\n</ol>\r\n<p>(i). If there is more than one square in the input string, the\r\nread/write head returns to the first square to the right of the input\r\nstring, rewrites the letter as <span class=\"math inline\">\\(0\\)</span>,\r\nthen continues to the right until the first square to the right of the\r\ncarbon string, rewrites the letter as <span class=\"math inline\">\\(1\\)</span>, then return to step (2). The\r\ncorresponding instruction is:</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n(q_{3},s_{1},L,q_{4}), (q_{4},s_{1},R,q_{5}), (q_{5},s_{1},s_{0},q_{6}),\r\n(q_{5},s_{0},s_{0},q_{0}),\\\\\r\n(q_{6},s_{0},R,q_{6}), (q_{6},s_{1},s_{1},q_{7}), (q_{7},s_{1},R,q_{7}),\r\n(q_{7},s_{0},s_{1},q_{2}).\r\n\\end{aligned}\\]</span></p>\r\n<p>(ii). If there is only one square in the input string, then the\r\nread/write head changes the letter in the <span class=\"math inline\">\\(n-1\\)</span> square to the right as <span class=\"math inline\">\\(1\\)</span>, then returns to square <span class=\"math inline\">\\(0\\)</span> and stops. The corresponding\r\ninstruction is:</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n(q_{4},s_{0},R,q_{8}), (q_{8},s_{1},R,q_{9}), (q_{9},s_{0},s_{1},q_{9}),\r\n(q_{9},s_{1},L,q_{10}),\\\\\r\n(q_{10},s_{1},s_{0},q_{16}), (q_{10},s_{0},L,q_{11}),\r\n(q_{11},s_{1},L,q_{11}), (q_{11},s_{0},L,q_{0}).\r\n\\end{aligned}\\]</span></p>\r\n<p>It is easy to verify that a Turing machine composed of instructions\r\n(1), (2), and (3) is the replicating machine in question. As for Turing\r\nmachine <span class=\"math inline\">\\(D\\)</span>, we simply set its\r\ninstruction set to <span class=\"math inline\">\\((q_{1},s_{0},s_{0},q_{0}),(q_{1},s_{1},R,q_{1})\\)</span>.<span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"formal-statement-p-np\">Formal Statement P = NP</h2>\r\n<p>We say that <span class=\"math inline\">\\(M\\)</span> accepts <span class=\"math inline\">\\(w\\)</span> if this computation terminates in the\r\naccepting state. The language accepted by <span class=\"math inline\">\\(M\\)</span>, denoted <span class=\"math inline\">\\(L(M)\\)</span>, has associated alphabet <span class=\"math inline\">\\(\\Sigma\\)</span> and is defined by</p>\r\n<p><span class=\"math display\">\\[ L(M) = \\{w \\in \\Sigma^{*} | M \\text{\r\naccepts } w\\}.\\]</span></p>\r\n<p>We denote by <span class=\"math inline\">\\(t_{M}(w)\\)</span> the number\r\nof steps in the computation of <span class=\"math inline\">\\(M\\)</span> on\r\ninput <span class=\"math inline\">\\(w\\)</span>. If this computation never\r\nhalts, then <span class=\"math inline\">\\(t_{M}(w) = \\infty\\)</span>. For\r\n<span class=\"math inline\">\\(n \\in \\mathbb{N}\\)</span> we denote by <span class=\"math inline\">\\(T_{M}(n)\\)</span> the worst case run time of <span class=\"math inline\">\\(M\\)</span>; that is</p>\r\n<p><span class=\"math display\">\\[T_{M}(n) = \\max \\{ t_{M}(w) | w \\in\r\n\\Sigma^{n} \\},\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(\\Sigma^{n}\\)</span> is the set of\r\nall strings over <span class=\"math inline\">\\(\\Sigma\\)</span> of length\r\n<span class=\"math inline\">\\(n\\)</span>. We say that <span class=\"math inline\">\\(M\\)</span> runs in polynomial time if there exists\r\n<span class=\"math inline\">\\(k\\)</span> such that for all <span class=\"math inline\">\\(n\\)</span>, <span class=\"math inline\">\\(T_{M}(n)\r\n\\leq n^{k} + k\\)</span>. Now we define the class <span class=\"math inline\">\\(\\mathbf{P}\\)</span> of languages by</p>\r\n<p><span class=\"math display\">\\[\\mathbf{P} = \\left\\{L | L = L(M) \\text{\r\nfor some Turing machine $M$ that runs\r\nin polynomial time}\\right\\}\\]</span></p>\r\n<p>The notation <span class=\"math inline\">\\(\\mathbf{NP}\\)</span> stands\r\nfor “nondeterministic polynomial time”.</p>\r\n<h2 id=\"definition-6\">Definition 6</h2>\r\n<p>A <strong><em>checking relation</em></strong> is a binary relation\r\n<span class=\"math inline\">\\(R \\subseteq \\Sigma^{*} \\times\r\n\\Sigma^{*}_{1}\\)</span> for some finite alphabets <span class=\"math inline\">\\(\\Sigma\\)</span> and <span class=\"math inline\">\\(\\Sigma_{1}\\)</span>. We associate with each such\r\nrelation <span class=\"math inline\">\\(R\\)</span> a language <span class=\"math inline\">\\(L_{R}\\)</span> over <span class=\"math inline\">\\(\\Sigma \\cup \\Sigma_{1} \\cup \\{ \\# \\}\\)</span>\r\ndefined by <span class=\"math display\">\\[L_{R} = \\left\\{w \\# y | R(w,\r\ny)\\right\\}\\]</span> where the symbol <span class=\"math inline\">\\(\\#\\)</span> is not in <span class=\"math inline\">\\(\\Sigma\\)</span>.</p>\r\n<p>We say that <span class=\"math inline\">\\(R\\)</span> is polynomial-time\r\niff <span class=\"math inline\">\\(L_{R} \\in \\mathbf{P}\\)</span>. Now we\r\ndefine the class NP of languages by the condition that a language <span class=\"math inline\">\\(L\\)</span> over <span class=\"math inline\">\\(\\Sigma\\)</span> is in <span class=\"math inline\">\\(\\mathbf{NP}\\)</span> iff there is <span class=\"math inline\">\\(k \\in \\mathbb{N}\\)</span> and a polynomial-time\r\nchecking relation <span class=\"math inline\">\\(R\\)</span> such that for\r\nall <span class=\"math inline\">\\(w \\in \\Sigma^{∗}\\)</span>, <span class=\"math display\">\\[w \\in L \\Longleftrightarrow \\exists y\\left(|y|\r\n\\leq |w|^{k} \\land R(w, y)\\right).\\]</span> where <span class=\"math inline\">\\(|w|\\)</span> and <span class=\"math inline\">\\(|y|\\)</span> denote the lengths of <span class=\"math inline\">\\(w\\)</span> and <span class=\"math inline\">\\(y\\)</span>, respectively.</p>\r\n<h2>\r\nProblem Statement: Dose P = NP?\r\n</h2>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Turing, A. M. (1938). On Computable Numbers, with an Application\r\nto the Entscheidungsproblem. Proceedings of the London Mathematical\r\nSociety. Wiley. s2-42 (1): 230–265.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>We give the formal statement of \"P=NP\", which plays an important role\r\nin computer science and complexity theory.</p>\r\n<h2 id=\"definition-1\">Definition 1</h2>\r\n<p>A function <span class=\"math inline\">\\(f:\\mathbb{N}^{k}\\rightarrow\r\n\\mathbb{N}\\)</span> is <strong><em>computable</em></strong> if and only\r\nif there is an effective procedure that, given any <span class=\"math inline\">\\(k\\)</span>-tuple <span class=\"math inline\">\\(\\mathbf{x}\\)</span> of natural numbers, will\r\nproduce the value <span class=\"math inline\">\\(f(\\mathbf{x})\\)</span></p>\r\n<h2 id=\"definition-2\">Definition 2</h2>\r\n<p>Let <span class=\"math inline\">\\(\\Sigma\\)</span> be a finite alphabet\r\n(that is, a finite nonempty set) with at least two elements, and let\r\n<span class=\"math inline\">\\(\\Sigma^{*}\\)</span> be the set of finite\r\nstrings over <span class=\"math inline\">\\(\\Sigma\\)</span>. Then a\r\n<strong><em>language over <span class=\"math inline\">\\(\\Sigma\\)</span></em></strong> is a subset <span class=\"math inline\">\\(L\\)</span> of <span class=\"math inline\">\\(\\Sigma^{*}\\)</span>.</p>\r\n<h2 id=\"definition-3\">Definition 3</h2>\r\n<p>A <strong><em>Turing machine <span class=\"math inline\">\\(M\\)</span></em></strong> is a tuple <span class=\"math inline\">\\(⟨\\Sigma, \\Gamma, Q, \\delta⟩\\)</span>, where <span class=\"math inline\">\\(\\Sigma, \\Gamma, Q\\)</span> are finite nonempty\r\nsets with <span class=\"math inline\">\\(\\Sigma \\subseteq \\Gamma\\)</span>\r\nand <span class=\"math inline\">\\(b \\in \\Gamma - \\Sigma\\)</span>. The\r\nstate set <span class=\"math inline\">\\(Q\\)</span> contains three special\r\nstates <span class=\"math inline\">\\(q_{0}, q_{accept},\r\nq_{reject}\\)</span>. The transition function <span class=\"math inline\">\\(\\delta\\)</span> satisfies <span class=\"math display\">\\[\\delta: (Q − \\{q_{accept}, q_{reject}\\}) \\times\r\n\\Gamma \\to  Q \\times \\Gamma × \\{-1, 1\\}.\\]</span> If <span class=\"math inline\">\\(\\delta(q, s) = (q^{\\prime}, s^{\\prime},\r\nh)\\)</span>, the interpretation is that, if <span class=\"math inline\">\\(M\\)</span> is in state <span class=\"math inline\">\\(q\\)</span> scanning the symbol <span class=\"math inline\">\\(s\\)</span>, then <span class=\"math inline\">\\(q^{\\prime}\\)</span> is the new state, <span class=\"math inline\">\\(s^{\\prime}\\)</span> is the symbol printed, and the\r\ntape head moves left or right one square depending on whether h is -1 or\r\n1.</p>\r\n<p>We assume that the sets <span class=\"math inline\">\\(Q\\)</span> and\r\n<span class=\"math inline\">\\(\\Gamma\\)</span> are disjoint.</p>\r\n<h2 id=\"definition-4\">Definition 4</h2>\r\n<p>A <strong><em>configuration</em></strong> of <span class=\"math inline\">\\(M\\)</span> is a string <span class=\"math inline\">\\(xqy\\)</span> with <span class=\"math inline\">\\(x, y\r\n\\in \\Gamma^{*}\\)</span>, <span class=\"math inline\">\\(y\\)</span> not the\r\nempty string, and <span class=\"math inline\">\\(q \\in Q\\)</span>. If <span class=\"math inline\">\\(C\\)</span> and <span class=\"math inline\">\\(C^{\\prime}\\)</span> are configurations, then <span class=\"math inline\">\\(C \\overset{M}{\\to} C^{\\prime}\\)</span> if <span class=\"math inline\">\\(C = xqsy\\)</span> and <span class=\"math inline\">\\(\\delta(q, s) = (q^{\\prime}, s^{\\prime},\r\nh)\\)</span> and one of the following holds:</p>\r\n<ul>\r\n<li><p><span class=\"math inline\">\\(C^{\\prime} =\r\nxs^{\\prime}q^{\\prime}y\\)</span> and <span class=\"math inline\">\\(h =\r\n1\\)</span> and <span class=\"math inline\">\\(y\\)</span> is\r\nnonempty.</p></li>\r\n<li><p><span class=\"math inline\">\\(C^{\\prime} =\r\nxs^{\\prime}q^{\\prime}b\\)</span> and <span class=\"math inline\">\\(h =\r\n1\\)</span> and <span class=\"math inline\">\\(y\\)</span> is empty.</p></li>\r\n<li><p><span class=\"math inline\">\\(C^{\\prime} =\r\nx^{\\prime}q^{\\prime}as^{\\prime}y\\)</span> and <span class=\"math inline\">\\(h = -1\\)</span> and <span class=\"math inline\">\\(x\r\n= x^{\\prime}a\\)</span> for some <span class=\"math inline\">\\(a \\in\r\n\\Gamma\\)</span>.</p></li>\r\n<li><p><span class=\"math inline\">\\(C^{\\prime} =\r\nq^{\\prime}bs^{\\prime}y\\)</span> and <span class=\"math inline\">\\(h =\r\n-1\\)</span> and <span class=\"math inline\">\\(x\\)</span> is\r\nempty.</p></li>\r\n</ul>\r\n<p>A configuration <span class=\"math inline\">\\(xqy\\)</span> is\r\n<strong><em>halting</em></strong> if <span class=\"math inline\">\\(q \\in\r\n\\{q_{accept}, q_{reject}\\}\\)</span>. Note that for each non-halting\r\nconfiguration <span class=\"math inline\">\\(C\\)</span> there is a unique\r\nconfiguration <span class=\"math inline\">\\(C^{\\prime}\\)</span> such that\r\n<span class=\"math inline\">\\(C \\overset{M}{\\to} C^{\\prime}\\)</span>.</p>\r\n<h2 id=\"definition-5\">Definition 5</h2>\r\n<p>The <strong><em>computation</em></strong> of <span class=\"math inline\">\\(M\\)</span> on input <span class=\"math inline\">\\(w\r\n\\in \\Sigma^{*}\\)</span> is the unique sequence <span class=\"math inline\">\\(C_{0}, C_{1}, \\cdots\\)</span> of configurations\r\nsuch that <span class=\"math inline\">\\(C_{0} = q_{0}w\\)</span> (or <span class=\"math inline\">\\(C_{0} = q_{0}b\\)</span> if <span class=\"math inline\">\\(w\\)</span> is empty) and <span class=\"math inline\">\\(C_{i} \\overset{M}{\\to} C_{i+1}^{\\prime}\\)</span>\r\nfor each <span class=\"math inline\">\\(i\\)</span> with <span class=\"math inline\">\\(C_{i+1}\\)</span> in the computation, and either\r\nthe sequence is infinite or it ends in a halting configuration. If the\r\ncomputation is finite, then the number of steps is one less than the\r\nnumber of configurations; otherwise the number of steps is infinite. We\r\nsay that <span class=\"math inline\">\\(M\\)</span>\r\n<strong><em>accepts</em></strong> <span class=\"math inline\">\\(w\\)</span>\r\niff the computation is finite and the final configuration contains the\r\nstate qaccept</p>\r\n<h2 id=\"theorem-1-turing-1936\">Theorem 1 [Turing 1936]</h2>\r\n<p>There is no TM <span class=\"math inline\">\\(M\\)</span> such that for\r\nall TMs <span class=\"math inline\">\\(N\\)</span>, if <span class=\"math inline\">\\(M\\)</span> is run with a code of <span class=\"math inline\">\\(N\\)</span> on its tape, then the following\r\nhold:</p>\r\n<ol type=\"1\">\r\n<li><p>If <span class=\"math inline\">\\(N\\)</span> eventually halts when\r\nrun on the empty tape, then <span class=\"math inline\">\\(M\\)</span>\r\neventually halts with <span class=\"math inline\">\\(1\\)</span> on the tape\r\nand the reading head on the square with the <span class=\"math inline\">\\(1\\)</span>.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(N\\)</span> does not eventually\r\nhalt when run on the empty tape, then <span class=\"math inline\">\\(M\\)</span> eventually halts with the tape\r\ncompletely empty.</p></li>\r\n</ol>\r\n<h2 id=\"theorem-2\">Theorem 2</h2>\r\n<p>The set <span class=\"math inline\">\\(HALT\\)</span> is not decidable,\r\nwhere <span class=\"math display\">\\[HALT = \\left\\{M : M \\text{ is a\r\nTuring machine which halts on the empty tape }\\right\\}\\]</span></p>\r\n<h2 id=\"definition\">Definition</h2>\r\n<p>The halting function is a function <span class=\"math inline\">\\(h\\)</span> of two arguments</p>\r\n<p><span class=\"math display\">\\[h(m,n) = \\begin{cases}0, &amp; \\text{\r\nmachine $m$, started\r\nwith input $n$, eventually halts }\\\\\r\n1, &amp; \\text{  machine $m$, started\r\nwith input $n$, never halts }\r\n\\end{cases}\\]</span></p>\r\n<p>By definition of Turing computability, Halting problem is not\r\ndecidable if and only if halting function <span class=\"math inline\">\\(h\\)</span> is not Turing computable.</p>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>The halting function h is not Turing computable.</p>\r\n<h2 id=\"proof-of-lemma-1\">Proof of Lemma 1</h2>\r\n<p>By way of background we need two special Turing machines.</p>\r\n<ol type=\"1\">\r\n<li><p>A copying machine <span class=\"math inline\">\\(C\\)</span>. Given a\r\ntape containing a block of <span class=\"math inline\">\\(n\\)</span>\r\nstrokes, and otherwise blank, if the machine is started scanning the\r\nleftmost stroke on the tape, it will eventually halt with the tape\r\ncontaining two blocks of <span class=\"math inline\">\\(n\\)</span> strokes\r\nseparated by a blank, and otherwise blank, with the machine scanning the\r\nleftmost stroke on the tape.</p></li>\r\n<li><p>A dithering machine <span class=\"math inline\">\\(D\\)</span>.\r\nStarted on the leftmost of a block of <span class=\"math inline\">\\(n\\)</span> strokes on an otherwise blank tape,\r\n<span class=\"math inline\">\\(D\\)</span> eventually halts if <span class=\"math inline\">\\(n &gt; 1\\)</span>, but never halts if <span class=\"math inline\">\\(n = 1\\)</span>.</p></li>\r\n</ol>\r\n<p>Now suppose we had a machine <span class=\"math inline\">\\(H\\)</span>\r\nthat computed the function <span class=\"math inline\">\\(h\\)</span>. We\r\ncould combine the machines <span class=\"math inline\">\\(C\\)</span> and\r\n<span class=\"math inline\">\\(H\\)</span> as follows: if the states of\r\n<span class=\"math inline\">\\(C\\)</span> are numbered <span class=\"math inline\">\\(1\\)</span> through <span class=\"math inline\">\\(p\\)</span>, and the states of <span class=\"math inline\">\\(H\\)</span> are numbered <span class=\"math inline\">\\(1\\)</span> through <span class=\"math inline\">\\(q\\)</span>, renumber the latter states <span class=\"math inline\">\\(p + 1\\)</span> through <span class=\"math inline\">\\(r = p + q\\)</span>, and write these renumbered\r\ninstructions after the instructions for <span class=\"math inline\">\\(C\\)</span>. Originally, <span class=\"math inline\">\\(C\\)</span> tells us to halt by telling us to go\r\ninto state <span class=\"math inline\">\\(p + 1\\)</span>, but in the new\r\ncombined instructions, going into state <span class=\"math inline\">\\(p +\r\n1\\)</span> means not halting, but beginning the operations of machine\r\n<span class=\"math inline\">\\(H\\)</span>. So the new combined instructions\r\nwill have us first go through the operations of <span class=\"math inline\">\\(C\\)</span>, and then, when <span class=\"math inline\">\\(C\\)</span> would have halted, go through the\r\noperations of <span class=\"math inline\">\\(H\\)</span>. The result is thus\r\na machine <span class=\"math inline\">\\(G\\)</span> that computes the\r\nfunction <span class=\"math inline\">\\(g(n) = h(n, n)\\)</span>.</p>\r\n<p>We now combine this machine <span class=\"math inline\">\\(G\\)</span>\r\nwith the dithering machine <span class=\"math inline\">\\(D\\)</span>,\r\nrenumbering the states of the latter as <span class=\"math inline\">\\(r +\r\n1\\)</span> and <span class=\"math inline\">\\(r + 2\\)</span>, and writing\r\nits instructions after those for <span class=\"math inline\">\\(G\\)</span>.\r\nThe result will be a machine <span class=\"math inline\">\\(M\\)</span> that\r\ngoes through the operations of <span class=\"math inline\">\\(G\\)</span>\r\nand then the operations of <span class=\"math inline\">\\(D\\)</span>. Thus\r\nif machine number <span class=\"math inline\">\\(n\\)</span> halts when\r\nstarted on its own number, that is, if <span class=\"math inline\">\\(h(n,\r\nn) = g(n) = 1\\)</span>, then the machine <span class=\"math inline\">\\(M\\)</span> does not halt when started on that\r\nnumber <span class=\"math inline\">\\(n\\)</span>, whereas if machine number\r\n<span class=\"math inline\">\\(n\\)</span> does not halt when started on its\r\nown number, that is, if <span class=\"math inline\">\\(h(n, n) = g(n) =\r\n2\\)</span>, then machine <span class=\"math inline\">\\(M\\)</span> does\r\nhalt when started on <span class=\"math inline\">\\(n\\)</span>. But of\r\ncourse there can be no such machine as <span class=\"math inline\">\\(M\\)</span>. For what would it do if started with\r\ninput its own number <span class=\"math inline\">\\(m\\)</span>? It would\r\nhalt if and only if machine number <span class=\"math inline\">\\(m\\)</span>, which is to say itself, does not halt\r\nwhen started with input the number <span class=\"math inline\">\\(m\\)</span>. This contradiction shows there can be\r\nno such machine as <span class=\"math inline\">\\(H\\)</span>.</p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>There exist TMs <span class=\"math inline\">\\(C\\)</span> and <span class=\"math inline\">\\(D\\)</span> satisfying conditions in Lemma 1.</p>\r\n<h2 id=\"proof-of-lemma-2\">Proof of Lemma 2</h2>\r\n<p>The instruction set of $$ consists of:</p>\r\n<ol type=\"1\">\r\n<li>The reading and writing head of the Turing machine moves to the\r\nright until it stops at the square where the second letter is <span class=\"math inline\">\\(0\\)</span>, and the letter in the square is\r\nchanged to <span class=\"math inline\">\\(1\\)</span>. Thus, two strings\r\ncomposed of <span class=\"math inline\">\\(1\\)</span> separated by one or\r\nsome in the middle appear on the paper tape, which will continue to\r\nexist in the operation of the Turing machine after that. We call the\r\nleft as input string and the right as carbon string. The corresponding\r\ninstruction is</li>\r\n</ol>\r\n<p><span class=\"math display\">\\[(q_{1},s_{1},R,q_{1}),\r\n(q_{1},s_{0},R,q_{2}), (q_{2},s_{0},1,q_{2}).\\]</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li><p>Move Turing's read/write head left to the first square on the\r\nright of the input string: <span class=\"math display\">\\[(q_{2},s_{1},L,q_{3}),\r\n(q_{3},s_{0},L,q_{3}).\\]</span></p></li>\r\n<li><p>Then determine whether the input string has more than one square.\r\nAnd</p></li>\r\n</ol>\r\n<p>(i). If there is more than one square in the input string, the\r\nread/write head returns to the first square to the right of the input\r\nstring, rewrites the letter as <span class=\"math inline\">\\(0\\)</span>,\r\nthen continues to the right until the first square to the right of the\r\ncarbon string, rewrites the letter as <span class=\"math inline\">\\(1\\)</span>, then return to step (2). The\r\ncorresponding instruction is:</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n(q_{3},s_{1},L,q_{4}), (q_{4},s_{1},R,q_{5}), (q_{5},s_{1},s_{0},q_{6}),\r\n(q_{5},s_{0},s_{0},q_{0}),\\\\\r\n(q_{6},s_{0},R,q_{6}), (q_{6},s_{1},s_{1},q_{7}), (q_{7},s_{1},R,q_{7}),\r\n(q_{7},s_{0},s_{1},q_{2}).\r\n\\end{aligned}\\]</span></p>\r\n<p>(ii). If there is only one square in the input string, then the\r\nread/write head changes the letter in the <span class=\"math inline\">\\(n-1\\)</span> square to the right as <span class=\"math inline\">\\(1\\)</span>, then returns to square <span class=\"math inline\">\\(0\\)</span> and stops. The corresponding\r\ninstruction is:</p>\r\n<p><span class=\"math display\">\\[\\begin{aligned}\r\n(q_{4},s_{0},R,q_{8}), (q_{8},s_{1},R,q_{9}), (q_{9},s_{0},s_{1},q_{9}),\r\n(q_{9},s_{1},L,q_{10}),\\\\\r\n(q_{10},s_{1},s_{0},q_{16}), (q_{10},s_{0},L,q_{11}),\r\n(q_{11},s_{1},L,q_{11}), (q_{11},s_{0},L,q_{0}).\r\n\\end{aligned}\\]</span></p>\r\n<p>It is easy to verify that a Turing machine composed of instructions\r\n(1), (2), and (3) is the replicating machine in question. As for Turing\r\nmachine <span class=\"math inline\">\\(D\\)</span>, we simply set its\r\ninstruction set to <span class=\"math inline\">\\((q_{1},s_{0},s_{0},q_{0}),(q_{1},s_{1},R,q_{1})\\)</span>.<span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"formal-statement-p-np\">Formal Statement P = NP</h2>\r\n<p>We say that <span class=\"math inline\">\\(M\\)</span> accepts <span class=\"math inline\">\\(w\\)</span> if this computation terminates in the\r\naccepting state. The language accepted by <span class=\"math inline\">\\(M\\)</span>, denoted <span class=\"math inline\">\\(L(M)\\)</span>, has associated alphabet <span class=\"math inline\">\\(\\Sigma\\)</span> and is defined by</p>\r\n<p><span class=\"math display\">\\[ L(M) = \\{w \\in \\Sigma^{*} | M \\text{\r\naccepts } w\\}.\\]</span></p>\r\n<p>We denote by <span class=\"math inline\">\\(t_{M}(w)\\)</span> the number\r\nof steps in the computation of <span class=\"math inline\">\\(M\\)</span> on\r\ninput <span class=\"math inline\">\\(w\\)</span>. If this computation never\r\nhalts, then <span class=\"math inline\">\\(t_{M}(w) = \\infty\\)</span>. For\r\n<span class=\"math inline\">\\(n \\in \\mathbb{N}\\)</span> we denote by <span class=\"math inline\">\\(T_{M}(n)\\)</span> the worst case run time of <span class=\"math inline\">\\(M\\)</span>; that is</p>\r\n<p><span class=\"math display\">\\[T_{M}(n) = \\max \\{ t_{M}(w) | w \\in\r\n\\Sigma^{n} \\},\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(\\Sigma^{n}\\)</span> is the set of\r\nall strings over <span class=\"math inline\">\\(\\Sigma\\)</span> of length\r\n<span class=\"math inline\">\\(n\\)</span>. We say that <span class=\"math inline\">\\(M\\)</span> runs in polynomial time if there exists\r\n<span class=\"math inline\">\\(k\\)</span> such that for all <span class=\"math inline\">\\(n\\)</span>, <span class=\"math inline\">\\(T_{M}(n)\r\n\\leq n^{k} + k\\)</span>. Now we define the class <span class=\"math inline\">\\(\\mathbf{P}\\)</span> of languages by</p>\r\n<p><span class=\"math display\">\\[\\mathbf{P} = \\left\\{L | L = L(M) \\text{\r\nfor some Turing machine $M$ that runs\r\nin polynomial time}\\right\\}\\]</span></p>\r\n<p>The notation <span class=\"math inline\">\\(\\mathbf{NP}\\)</span> stands\r\nfor “nondeterministic polynomial time”.</p>\r\n<h2 id=\"definition-6\">Definition 6</h2>\r\n<p>A <strong><em>checking relation</em></strong> is a binary relation\r\n<span class=\"math inline\">\\(R \\subseteq \\Sigma^{*} \\times\r\n\\Sigma^{*}_{1}\\)</span> for some finite alphabets <span class=\"math inline\">\\(\\Sigma\\)</span> and <span class=\"math inline\">\\(\\Sigma_{1}\\)</span>. We associate with each such\r\nrelation <span class=\"math inline\">\\(R\\)</span> a language <span class=\"math inline\">\\(L_{R}\\)</span> over <span class=\"math inline\">\\(\\Sigma \\cup \\Sigma_{1} \\cup \\{ \\# \\}\\)</span>\r\ndefined by <span class=\"math display\">\\[L_{R} = \\left\\{w \\# y | R(w,\r\ny)\\right\\}\\]</span> where the symbol <span class=\"math inline\">\\(\\#\\)</span> is not in <span class=\"math inline\">\\(\\Sigma\\)</span>.</p>\r\n<p>We say that <span class=\"math inline\">\\(R\\)</span> is polynomial-time\r\niff <span class=\"math inline\">\\(L_{R} \\in \\mathbf{P}\\)</span>. Now we\r\ndefine the class NP of languages by the condition that a language <span class=\"math inline\">\\(L\\)</span> over <span class=\"math inline\">\\(\\Sigma\\)</span> is in <span class=\"math inline\">\\(\\mathbf{NP}\\)</span> iff there is <span class=\"math inline\">\\(k \\in \\mathbb{N}\\)</span> and a polynomial-time\r\nchecking relation <span class=\"math inline\">\\(R\\)</span> such that for\r\nall <span class=\"math inline\">\\(w \\in \\Sigma^{∗}\\)</span>, <span class=\"math display\">\\[w \\in L \\Longleftrightarrow \\exists y\\left(|y|\r\n\\leq |w|^{k} \\land R(w, y)\\right).\\]</span> where <span class=\"math inline\">\\(|w|\\)</span> and <span class=\"math inline\">\\(|y|\\)</span> denote the lengths of <span class=\"math inline\">\\(w\\)</span> and <span class=\"math inline\">\\(y\\)</span>, respectively.</p>\r\n<h2>\r\nProblem Statement: Dose P = NP?\r\n</h2>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Turing, A. M. (1938). On Computable Numbers, with an Application\r\nto the Entscheidungsproblem. Proceedings of the London Mathematical\r\nSociety. Wiley. s2-42 (1): 230–265.</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Wed Nov 27 2024 23:24:02 GMT+0800 (中国标准时间)","title":"P = NP","path":"2023/04/10/P=NP/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-04-10T12:38:46.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-04-10T12:38:46.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Notes > Mathematical Logic","tags":["Notes","Mathematical Logic"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Nevanlinna Theory (II)","date":"2023-03-27T10:40:10.000Z","mathjax":true,"_content":"\n\n## Corollary 1 [Picard-Borel]\n\nFor a nonconstant meromorphic function there are at most two values of $a$ for which the counting function $N(r, a)$ [or $n(r, a)$] is of lower order (class, type) than the characteristic $T(r)$.\n\n## Theorem [deficiency sum]\n\nIf the function $w(z)$ is meromorphic for $z \\neq \\infty$, then the deficiency $\\delta(a)$ defined by \n\n$$\\delta(a) = \\varliminf\\limits_{r = \\infty} \\frac{m(r,a)}{T(r)} = 1 - \\varlimsup\\limits_{r = \\infty} \\frac{N(r,a)}{T(r)} $$\n\nvanishes for all but at most a countable set of values $a$. The sum of all deficiencies is at most equal to $2$:\n\n$$\\sum \\delta(a_{i}) \\leq 2$$\n\n\n\n## Corollary 2 [Picard]\nIf the curve $f(x, y) = 0$ is of genus $p > 1$, then there is no pair of meromorphic functions $x(t), y(t)$ such that $f(x(t), y(t)) = 0$.\n\n\n\n\n## Therorem [P\\'olya]\nSuppose that $f(z), g(z)$ are integral functions and that $\\phi(р) = g\\left(f(z)\\right)$ has finite order. Then either $f(z)$ is a polynomial or $g(z)$ has zero order.\n\n\n\nSuppose that f(z) and g(z) are transcendental, since otherwise there\nis nothing to prove. In this case it follows from (2.13) that\n\n$$T(r,\\phi) \\geq \\frac{1}{3}T(r^{n+1},g)$$\n\nfor all sufficiently large $r$, when $N$ is a fixed positive integer. Since $\\phi(z)$ has finite order $k$, say, we deduce that, for all sufficiently large $r$, we have by (2.13)\n\n$$T(r^{n+1},g) < 3r^{k+1}$$\n\nand setting $\\rho = r^{N+1}$ we deduce for all sufficiently large $\\rho$\n\n$$T(\\rho,g) < 3 \\rho^{(k+1)/(N+1)}$$\n\nSince $k$ is fixed and $N$ can be chosen as large as we please, $g(z)$ must have zero order. This proves Theorem 2.9. $\\square$\n\n# Reference\n\n\n[1] Nevanlinna R. Le théorème de Picard-Borel et la théorie des fonctions méromorphes[M]. Chelsea Publishing Company, Incorporated, 1929.\n\n\n","source":"_posts/Nevanlinna Theory2.md","raw":"---\ntitle: Nevanlinna Theory (II)\ndate: 2023-03-27 18:40:10\ntags:\n    - [Sevaral Complex Variables]\ncategories:\n    - [Sevaral Complex Variables, Nevanlinna Theory]\nmathjax: true\n---\n\n\n## Corollary 1 [Picard-Borel]\n\nFor a nonconstant meromorphic function there are at most two values of $a$ for which the counting function $N(r, a)$ [or $n(r, a)$] is of lower order (class, type) than the characteristic $T(r)$.\n\n## Theorem [deficiency sum]\n\nIf the function $w(z)$ is meromorphic for $z \\neq \\infty$, then the deficiency $\\delta(a)$ defined by \n\n$$\\delta(a) = \\varliminf\\limits_{r = \\infty} \\frac{m(r,a)}{T(r)} = 1 - \\varlimsup\\limits_{r = \\infty} \\frac{N(r,a)}{T(r)} $$\n\nvanishes for all but at most a countable set of values $a$. The sum of all deficiencies is at most equal to $2$:\n\n$$\\sum \\delta(a_{i}) \\leq 2$$\n\n\n\n## Corollary 2 [Picard]\nIf the curve $f(x, y) = 0$ is of genus $p > 1$, then there is no pair of meromorphic functions $x(t), y(t)$ such that $f(x(t), y(t)) = 0$.\n\n\n\n\n## Therorem [P\\'olya]\nSuppose that $f(z), g(z)$ are integral functions and that $\\phi(р) = g\\left(f(z)\\right)$ has finite order. Then either $f(z)$ is a polynomial or $g(z)$ has zero order.\n\n\n\nSuppose that f(z) and g(z) are transcendental, since otherwise there\nis nothing to prove. In this case it follows from (2.13) that\n\n$$T(r,\\phi) \\geq \\frac{1}{3}T(r^{n+1},g)$$\n\nfor all sufficiently large $r$, when $N$ is a fixed positive integer. Since $\\phi(z)$ has finite order $k$, say, we deduce that, for all sufficiently large $r$, we have by (2.13)\n\n$$T(r^{n+1},g) < 3r^{k+1}$$\n\nand setting $\\rho = r^{N+1}$ we deduce for all sufficiently large $\\rho$\n\n$$T(\\rho,g) < 3 \\rho^{(k+1)/(N+1)}$$\n\nSince $k$ is fixed and $N$ can be chosen as large as we please, $g(z)$ must have zero order. This proves Theorem 2.9. $\\square$\n\n# Reference\n\n\n[1] Nevanlinna R. Le théorème de Picard-Borel et la théorie des fonctions méromorphes[M]. Chelsea Publishing Company, Incorporated, 1929.\n\n\n","slug":"Nevanlinna Theory2","published":1,"updated":"2024-02-25T15:11:07.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5s3001pm8nx2p388tm4","content":"<h2 id=\"corollary-1-picard-borel\">Corollary 1 [Picard-Borel]</h2>\r\n<p>For a nonconstant meromorphic function there are at most two values\r\nof <span class=\"math inline\">\\(a\\)</span> for which the counting\r\nfunction <span class=\"math inline\">\\(N(r, a)\\)</span> [or <span class=\"math inline\">\\(n(r, a)\\)</span>] is of lower order (class, type)\r\nthan the characteristic <span class=\"math inline\">\\(T(r)\\)</span>.</p>\r\n<h2 id=\"theorem-deficiency-sum\">Theorem [deficiency sum]</h2>\r\n<p>If the function <span class=\"math inline\">\\(w(z)\\)</span> is\r\nmeromorphic for <span class=\"math inline\">\\(z \\neq \\infty\\)</span>, then\r\nthe deficiency <span class=\"math inline\">\\(\\delta(a)\\)</span> defined\r\nby</p>\r\n<p><span class=\"math display\">\\[\\delta(a) = \\varliminf\\limits_{r =\r\n\\infty} \\frac{m(r,a)}{T(r)} = 1 - \\varlimsup\\limits_{r = \\infty}\r\n\\frac{N(r,a)}{T(r)} \\]</span></p>\r\n<p>vanishes for all but at most a countable set of values <span class=\"math inline\">\\(a\\)</span>. The sum of all deficiencies is at most\r\nequal to <span class=\"math inline\">\\(2\\)</span>:</p>\r\n<p><span class=\"math display\">\\[\\sum \\delta(a_{i}) \\leq 2\\]</span></p>\r\n<h2 id=\"corollary-2-picard\">Corollary 2 [Picard]</h2>\r\n<p>If the curve <span class=\"math inline\">\\(f(x, y) = 0\\)</span> is of\r\ngenus <span class=\"math inline\">\\(p &gt; 1\\)</span>, then there is no\r\npair of meromorphic functions <span class=\"math inline\">\\(x(t),\r\ny(t)\\)</span> such that <span class=\"math inline\">\\(f(x(t), y(t)) =\r\n0\\)</span>.</p>\r\n<h2 id=\"therorem-polya\">Therorem [P'olya]</h2>\r\n<p>Suppose that <span class=\"math inline\">\\(f(z), g(z)\\)</span> are\r\nintegral functions and that <span class=\"math inline\">\\(\\phi(р) =\r\ng\\left(f(z)\\right)\\)</span> has finite order. Then either <span class=\"math inline\">\\(f(z)\\)</span> is a polynomial or <span class=\"math inline\">\\(g(z)\\)</span> has zero order.</p>\r\n<p>Suppose that f(z) and g(z) are transcendental, since otherwise there\r\nis nothing to prove. In this case it follows from (2.13) that</p>\r\n<p><span class=\"math display\">\\[T(r,\\phi) \\geq\r\n\\frac{1}{3}T(r^{n+1},g)\\]</span></p>\r\n<p>for all sufficiently large <span class=\"math inline\">\\(r\\)</span>,\r\nwhen <span class=\"math inline\">\\(N\\)</span> is a fixed positive integer.\r\nSince <span class=\"math inline\">\\(\\phi(z)\\)</span> has finite order\r\n<span class=\"math inline\">\\(k\\)</span>, say, we deduce that, for all\r\nsufficiently large <span class=\"math inline\">\\(r\\)</span>, we have by\r\n(2.13)</p>\r\n<p><span class=\"math display\">\\[T(r^{n+1},g) &lt; 3r^{k+1}\\]</span></p>\r\n<p>and setting <span class=\"math inline\">\\(\\rho = r^{N+1}\\)</span> we\r\ndeduce for all sufficiently large <span class=\"math inline\">\\(\\rho\\)</span></p>\r\n<p><span class=\"math display\">\\[T(\\rho,g) &lt; 3\r\n\\rho^{(k+1)/(N+1)}\\]</span></p>\r\n<p>Since <span class=\"math inline\">\\(k\\)</span> is fixed and <span class=\"math inline\">\\(N\\)</span> can be chosen as large as we please,\r\n<span class=\"math inline\">\\(g(z)\\)</span> must have zero order. This\r\nproves Theorem 2.9. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Nevanlinna R. Le théorème de Picard-Borel et la théorie des\r\nfonctions méromorphes[M]. Chelsea Publishing Company, Incorporated,\r\n1929.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"corollary-1-picard-borel\">Corollary 1 [Picard-Borel]</h2>\r\n<p>For a nonconstant meromorphic function there are at most two values\r\nof <span class=\"math inline\">\\(a\\)</span> for which the counting\r\nfunction <span class=\"math inline\">\\(N(r, a)\\)</span> [or <span class=\"math inline\">\\(n(r, a)\\)</span>] is of lower order (class, type)\r\nthan the characteristic <span class=\"math inline\">\\(T(r)\\)</span>.</p>\r\n<h2 id=\"theorem-deficiency-sum\">Theorem [deficiency sum]</h2>\r\n<p>If the function <span class=\"math inline\">\\(w(z)\\)</span> is\r\nmeromorphic for <span class=\"math inline\">\\(z \\neq \\infty\\)</span>, then\r\nthe deficiency <span class=\"math inline\">\\(\\delta(a)\\)</span> defined\r\nby</p>\r\n<p><span class=\"math display\">\\[\\delta(a) = \\varliminf\\limits_{r =\r\n\\infty} \\frac{m(r,a)}{T(r)} = 1 - \\varlimsup\\limits_{r = \\infty}\r\n\\frac{N(r,a)}{T(r)} \\]</span></p>\r\n<p>vanishes for all but at most a countable set of values <span class=\"math inline\">\\(a\\)</span>. The sum of all deficiencies is at most\r\nequal to <span class=\"math inline\">\\(2\\)</span>:</p>\r\n<p><span class=\"math display\">\\[\\sum \\delta(a_{i}) \\leq 2\\]</span></p>\r\n<h2 id=\"corollary-2-picard\">Corollary 2 [Picard]</h2>\r\n<p>If the curve <span class=\"math inline\">\\(f(x, y) = 0\\)</span> is of\r\ngenus <span class=\"math inline\">\\(p &gt; 1\\)</span>, then there is no\r\npair of meromorphic functions <span class=\"math inline\">\\(x(t),\r\ny(t)\\)</span> such that <span class=\"math inline\">\\(f(x(t), y(t)) =\r\n0\\)</span>.</p>\r\n<h2 id=\"therorem-polya\">Therorem [P'olya]</h2>\r\n<p>Suppose that <span class=\"math inline\">\\(f(z), g(z)\\)</span> are\r\nintegral functions and that <span class=\"math inline\">\\(\\phi(р) =\r\ng\\left(f(z)\\right)\\)</span> has finite order. Then either <span class=\"math inline\">\\(f(z)\\)</span> is a polynomial or <span class=\"math inline\">\\(g(z)\\)</span> has zero order.</p>\r\n<p>Suppose that f(z) and g(z) are transcendental, since otherwise there\r\nis nothing to prove. In this case it follows from (2.13) that</p>\r\n<p><span class=\"math display\">\\[T(r,\\phi) \\geq\r\n\\frac{1}{3}T(r^{n+1},g)\\]</span></p>\r\n<p>for all sufficiently large <span class=\"math inline\">\\(r\\)</span>,\r\nwhen <span class=\"math inline\">\\(N\\)</span> is a fixed positive integer.\r\nSince <span class=\"math inline\">\\(\\phi(z)\\)</span> has finite order\r\n<span class=\"math inline\">\\(k\\)</span>, say, we deduce that, for all\r\nsufficiently large <span class=\"math inline\">\\(r\\)</span>, we have by\r\n(2.13)</p>\r\n<p><span class=\"math display\">\\[T(r^{n+1},g) &lt; 3r^{k+1}\\]</span></p>\r\n<p>and setting <span class=\"math inline\">\\(\\rho = r^{N+1}\\)</span> we\r\ndeduce for all sufficiently large <span class=\"math inline\">\\(\\rho\\)</span></p>\r\n<p><span class=\"math display\">\\[T(\\rho,g) &lt; 3\r\n\\rho^{(k+1)/(N+1)}\\]</span></p>\r\n<p>Since <span class=\"math inline\">\\(k\\)</span> is fixed and <span class=\"math inline\">\\(N\\)</span> can be chosen as large as we please,\r\n<span class=\"math inline\">\\(g(z)\\)</span> must have zero order. This\r\nproves Theorem 2.9. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Nevanlinna R. Le théorème de Picard-Borel et la théorie des\r\nfonctions méromorphes[M]. Chelsea Publishing Company, Incorporated,\r\n1929.</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Feb 25 2024 23:11:07 GMT+0800 (中国标准时间)","title":"Nevanlinna Theory (II)","path":"2023/03/27/Nevanlinna Theory2/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-03-27T10:40:10.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-03-27T10:40:10.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Sevaral Complex Variables > Nevanlinna Theory","tags":["Sevaral Complex Variables"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Nowicki Conjecture","date":"2023-04-11T08:28:25.000Z","mathjax":true,"_content":"\n\nLet $A[\\mathbf{x}] = A[x_{1}, \\cdots, x_{n}$] be the polynomial ring in n variables over an integral domain $A$, $D$ an $A$-[derivation](https://en.wikipedia.org/wiki/Derivation_(differential_algebra)) of $A[\\mathbf{x}]$ and denote \n$$L^{D}_{ij} := D(x_{i}) x_{j} - D(x_{j}) x_{i}, \\quad \\text{ for each } i, j \\in \\{1, \\cdots, n\\}.$$\n\n\n## Theorem 1 [Nowicki 1, Conjecture 6.9.10]\nAssume that $k[\\mathbf{y}] = k[y_{1}, \\cdots, y_{n}]$ is the polynomial ring in $n$ variables over a field $k$ of characteristic zero. If $\\Delta_{n}$ is the $k[\\mathbf{y}]$-derivation of $k[\\mathbf{y}][\\mathbf{x}]$ defined by $\\Delta_{n}(x_{i}) = y_{i}$ for $i = 1, \\cdots, n$, then $\\ker \\Delta_{n}$ is generated by $L^{\\Delta_{n}}_{ij}$ for $1 ≤ i < j ≤ n$ over $k[\\mathbf{y}]$.\n\n\n## Proof of Theorem 1\n\nWe prove the conjecture by induction on $n$. \n\nStep $1$. The assertion is clear when $n = 1$. \n\nStep $n-1$. By the assumption on induction, $\\ker \\Delta_{n-1}$ is generated by $S_{n-1}$ over $k[\\mathbf{y}^{\\prime}] := k[y_{1}, \\cdots , y_{n-1}]$, since $L^{\\Delta_{n-1}}_{i,j} = L^{\\Delta_{n}}_{i,j}$ for each $i, j$.\n\nStep $n$. Split the theorem into several lemmas.\n\n## Lemma 1 \n\nThe $k[\\mathbf{y}^{\\prime}]$-derivation $\\Delta_{n-1}$ that naturally extends to a $k[\\mathbf{y}]$-derivation $(\\Delta_{n-1})_{k[\\mathbf{y}]}$ of $k[\\mathbf{y}][\\mathbf{x}^{\\prime}] := k[\\mathbf{y}][x_{1}, \\cdots, x_{n-1}]$ satisfies\n\n$$\\begin{equation}\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n} = k[\\mathbf{y}][S_{n-1}].\n\\end{equation}$$\n\n## Proof of Lemma 1\n\nAs discussed in Section 1, then $(\\Delta_{n-1})k[\\mathbf{y}] = \\Delta_{n}|_{k[\\mathbf{y}][\\mathbf{x}^{\\prime}]}$, so we have $\\ker(\\Delta_{n-1})k[\\mathbf{y}] = k[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n}$. Moreover,\n$\\ker(\\Delta_{n-1})k[\\mathbf{y}] = k[\\mathbf{y}] \\otimes_{k[\\mathbf{y}^{\\prime}]} \\ker \\Delta_{n-1}$, since $k[\\mathbf{y}]$ is flat over $k[\\mathbf{y}^{\\prime}]$. $\\square$\n\n\n\nLet $\\mathbf{e}_{1}, \\cdots , \\mathbf{e}_{n}$ be the coordinate unit vectors of $\\mathbb{R}^{n}$, $M$ the $\\mathbb{Z}$-submodule of $(\\mathbb{Z}^{n})^{2}$ generated by $(\\mathbf{e}_{j} - \\mathbf{e}_{i}, \\mathbf{e}_{i} - \\mathbf{e}_{j})$ for $1 \\leq i < j \\leq n$, and $\\Gamma = (\\mathbb{Z}^{n})^{2}/M$.  \n\n\n## Theorem 2\n\nFor each $\\gamma \\in \\Gamma$, we define $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma}$ to be the $k$-vector space generated by $\\mathbf{y}^{a}\\mathbf{x}^{b}:= y^{a_{1}} \\cdots y^{a_{n}} x^{b_{1}} \\cdots x^{b_{n}}$ for $a = (a_{1}, \\cdots , a_{n})$ and $b = (b_{1}, \\cdots , b_{n})$ in $(\\mathbb{Z}_{\\geq 0})^{n}$ such that the image of $(a, b)$ in $\\Gamma$ is equal to $\\gamma$. Then \n\n$$\\ker \\Delta_{n} = \\bigoplus_{\\gamma \\in \\Gamma} k[\\mathbf{y}] [ \\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}$$\n\n## Proof of Theorem 2\n\nNote that $\\Delta_{n}(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma})$ is contained in $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma - \\delta}$ for each $\\gamma \\in \\Gamma$, where $\\delta$ is the image of $(-\\mathbb{e}_{n}, \\mathbb{e}_{n})$ in $\\Gamma$. $\\square$\n\n\n\nHence, we are reduced to showing that each $0 \\neq \\varPhi \\in k[\\mathbf{y}][\\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}$ belongs to $k[\\mathbf{y}][S_{n}]$ for $\\gamma \\in \\Gamma$.\n\nWe may find $a = (a_{1}, \\cdots , a_{n}) \\in \\mathbb{Z}^{n}$ and $l \\in \\mathbb{Z}_{\\geq 0}$ such that the image of $(a, l\\mathbf{e}_{n})$ in $\\Gamma$ is equal to $\\gamma$. Let $m$ be the $x_{n}$-degree of $\\varPhi$, where $0 \\leq m \\leq l$, and $\\phi \\in k[\\mathbf{y}][\\mathbf{x}^{\\prime}]$ the coefficient of $x_{n}^{m}$ in $\\varPhi$. By replacing $\\varPhi$ if necessary, we may assume that $m$ is the minimum among the $x_{n}$-degrees of elements of $\\ker \\Delta_{n}\\backslash k[\\mathbf{y}][S_{n}]$. \n\n## Lemma 2 \n\nWrite $\\phi$ in expression of sum of $y_{1}\\cdots y_{n}$\n\n$$\\phi = y_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}$$\n\nwhere $L^{\\mathbf{u}} = \\prod_{1 \\leq i<j\\leq n-1} L_{i,j}^{u_{i,j}}$ for each $\\mathbf{u}$. There holds the identity\n\n$$\\begin{equation}\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\n\\end{equation}$$\n\n\n## Lemma 3\n\nThere holds the inequality\n\n$$\\begin{equation}\nm \\geq 2l - \\sum_{i=1}^{n-1} a_{i}.\n\\end{equation}$$\n\n\n\n## Proof of Lemma 2\n\n\nthen, $\\phi$ belongs to $k[\\mathbf{y}][\\mathbf{x}]_{\\mu}$, where $\\mu$ is the image of $(a, (l - m)\\mathbf{e}_{n})$ in $\\Gamma$. Furthermore, $0 = \\Delta_{n}(\\varPhi) = \\Delta_{n}(\\varphi)x^{m}_{n} + m\\phi y_{n}x_{n}^{m-1} + \\Delta_{n}(\\varPhi - \\phi x^{m}_{n})$, and the $x_{n}$-degrees of $m\\phi y_{n}x_{n}^{m-1}$ and $\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})$ are at most $m - 1$. Hence, $\\Delta_{n}(\\phi) = 0$. Thus, $\\phi$ belongs to $k[\\mathbf{y}][S_{n-1}]$ by (1). Write $\\phi = \\sum_{b,\\mathbf{u}} r^{\\prime}_{b,\\mathbf{u}}y^{b}\\hat{y}^{-\\mathbf{u}}L^{\\mathbf{u}}$, where the sum is taken over $b \\in (\\mathbb{Z}_{\\geq 0})^{n}$ and $u = (u_{i,j})_{i,j}$ with $u_{i,j} \\in \\mathbb{Z}_{\\geq 0}$ for $1 \\leq i < j \\leq n - 1$, $r^{\\prime}_{b,\\mathbf{u}} \\in k$ for each $b$ and $\\mathbf{u}$, and \n\n$\\hat{y}^{-u} = \\prod_{1\\leq i < j \\leq n-1} (y_{i}y_{j})^{-u_{i,j}}, \\quad L^{\\mathbf{u}} = \\prod_{1 \\leq i<j\\leq n-1} L_{i,j}^{u_{i,j}}$ for each $\\mathbf{u}$.\n\nWe may assume that $r_{b,\\mathbf{u}}^{\\prime} = 0$ if $\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}$ is not in $k[\\mathbf{y}]$. Let $\\eta(b, \\mathbf{u})$ be the image of $(b - |\\mathbf{u}|\\mathbf{e}_{n}, |\\mathbf{u}|\\mathbf{e}_{n})$ in $\\Gamma$, where $|\\mathbf{u}| = \\sum_{i,j} u_{i,j}$. Then, $\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}L^{\\mathbf{u}}$ belongs to $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\eta(b,\\mathbf{u})}$ for each $b$ and $\\mathbf{u}$ where $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}] := k[\\mathbf{y}][\\mathbf{x}][(y_{1} \\cdots y_{n})^{-1}]$, since $(y_{i}y_{j})^{-1} L_{i,j}$ belongs to $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\delta}$ for each $i, j$.  Since $\\phi$ is in $k[\\mathbf{y}][\\mathbf{x}]_{\\mu}$, and $\\mu$ is the image of $(a, (l - m)\\mathbf{e}_{n})$, we may assume that $r_{b,\\mathbf{u}}^{\\prime} = 0$ unless $|u| = l - m$ and $b = a + (l - m)\\mathbf{e}_{n}$. For each $\\mathbf{u}$ with $r_{\\mathbf{u}} := r^{\\prime}_{a + (l-m) \\mathbf{e}_{n},\\mathbf{u}}\\neq 0$, write $\\mathbf{y}^{a} y_{n}^{l-m} \\hat{\\mathbf{y}}^{-\\mathbf{u}} = y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} y_{n}^{s}$, where $\\rho_{i}(u) \\in \\mathbb{Z}_{\\geq 0}$ for $i = 1, \\cdots , n - 1$, and $s = a_{n} + l - m$. Then, we have $\\phi = y_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}$. Since $|u| = l - m$, it follows that\n\n\n$$\\begin{equation}\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\n\\end{equation}$$\n\n## Proof of Lemma 3\n\nTake $\\varPhi$ which does not satisfy (3) so that $m$ would be the minimum among the $x_{n}$-degrees of such polynomials. Then, $t:= 2l - \\sum_{i=1}^{n-1}a_{i} -m$ is positive, and $\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) = m - t$ for each $\\mathbf{u}$ by (2). Hence, the $x_{n}$-degree of\n\n$$\\varPhi_{1}:= \\sum_{\\mathbf{u}} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} L_{n,i}^{\\rho_{i}(\\mathbf{u})} = \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} (y_{i}x_{n} - y_{n}x_{i})^{\\rho_{i}(\\mathbf{u})}$$\n\n\nis $m - t$. The coefficient of $x_{n}^{n-t}$ in $y_{n}^{s}\\varPhi_{1}$ is equal to $\\phi$, so the coefficient of $x_{n}^{m}$ in $y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$ is equal to that in $y_{1}^{t}\\varPhi$. Consequently, the $x_{n}$-degree $m^{\\prime}$ of $\\varPhi_{2}:= y_{1}^{t}\\varPhi - y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$ is less than $m$. We claim that $\\varPhi_{2} = 0$. In fact, if $\\gamma^{\\prime}$ is the image of $(a + t\\mathbf{e}_{1}, l\\mathbf{e}_{n})$ in $\\Gamma$, and $(a^{\\prime}_{1}, \\cdots , a_{n}^{\\prime}\n) := a + t\\mathbf{e}_{1}$, then $\\varPhi_{2}$ belongs to $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma^{\\prime}} \\cap \\ker \\Delta_{n}$, and\n\n\n$$2l - \\sum_{i=1}^{n-1} a^{\\prime}_{i} = 2l - \\sum_{i=1}^{n-1} a_{i} - t = m > m^{\\prime}$$\n\n\nThis implies that $\\varPhi_{2} = 0$ by the minimality of $m$. Hence, $y_{1}^{t} \\varPhi= y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$. Thus, $\\varPhi_{1}$ is divisible by $y_{1}$, since neither are $y_{n}$ and $L_{n,1}$. Recall that the kernel of a locally nilpotent derivation $D$ of an integral domain $R$ containing $Q$ is factorially closed in $R$, that is, $D(f g) =\n0$ implies $D(f ) = D(g) = 0$ for each $f, g \\in R \\ \\{0\\}$ (cf. [2, Proposition 1.3.32 (iii)]). Note\nthat $\\Delta_{n}$ is locally nilpotent, $\\Delta_{n}(\\varPhi_{1}) = 0$, $\\varPhi_{1} \\neq 0$ and $\\Delta_{n}(x_{n}) \\neq 0$. Hence, $\\varPhi_{1}$ is not divisible by $x_{n}$. By substituting zero for $x_{n}$, we obtain from $\\varPhi_{1}$ a nonzero polynomial\n\n$$\\sum_{\\mathbf{u}}r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} (- y_{n} x_{i})^{\\rho_{i}(\\mathbf{u})} = ( - y_{n} )^{m-i} \\varPsi, \\text{ where } \\varPsi = \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} x_{i}^{\\rho_{i}(\\mathbf{u})}.$$\n\nThen, $\\varPhi \\neq 0$, and $\\varPhi$ is divisible by $y_{1}$, since so is $\\phi_{1}$. Define $\\sigma \\in \\text{Aut}_{k} k[\\mathbf{y}][\\mathbf{x}]$ by $\\sigma(x_{i}) =\ny_{i}$ and $\\sigma(y_{i}) = x_{i}$ for $i = 1, \\cdots, n$. Then, $\\sigma(\\varPhi)$ is divisible by $x_{1}$. On the other hand, $\\sigma(L_{i,j}) = L_{j,i}$ and $\\sigma(x_{i}) = y_{i}$ are in $\\ker \\Delta_{n}$ for each $i, j$, so $\\sigma(\\varPsi)$ belongs to $\\ker \\Delta_{n}$. Thus, we have $\\sigma(\\varPsi) = 0$, because $x_{1}$ is not in $\\ker \\Delta_[n]$ and $\\ker \\Delta_{n}$ is factorially closed in $k[\\mathbf{y}][\\mathbf{x}]$. This contradicts that $\\varPsi \\neq 0$. $\\square$\n\n\n## Proof of Theorem 1\n\n\nIn fact, (3) implies that $\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) \\geq m$ by (2), so we have $\\sum_{i=1}^{n-1}\\rho_{i}^{\\prime}(\\mathbf{u})  = m$ for some\nintegers $0 \\leq \\rho^{\\prime}_{i}(\\mathbf{u}) \\leq \\rho_{i}(\\mathbf{u})$ for $i = 1, \\cdots, n - 1$ for each $u$. Then,\n\n$$\\varPhi^{\\prime} := y_{n}^{s} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}) - \\rho_{i}^{\\prime}(\\mathbf{u})} L_{n,i}^{\\rho_{i}^{\\prime}(\\mathbf{u})} = y_{n}^{s} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}) - \\rho_{i}^{\\prime}(\\mathbf{u}) } (y_{i}x_{n} - x_{n}y_{i})^{\\rho_{i}^{\\prime}(\\mathbf{u}) }$$\n\n\nis an element of $k[\\mathbf{y}][S_{n}]$ having $x_{n}$-degree $m$, in which the coefficient of $x_{n}^{m}$ is equal to $\\phi$. Hence, the $x_{n}$-degree of $\\varPhi - \\varPhi^{\\prime}$ is less than $m$. Since $\\varPhi - \\varPhi^{\\prime}$ is an element of $\\ker \\Delta_{n} \\backslash k[\\mathbf{y}][S_{n}]$, this contradicts the minimality of $m$. $\\square$\n\n\n","source":"_posts/Nowicki Conjecture.md","raw":"---\ntitle: Nowicki Conjecture\ndate: 2023-04-11 16:28:25\ntags:\n    - [Notes]\ncategories:\n    - [Notes]\nmathjax: true\n---\n\n\nLet $A[\\mathbf{x}] = A[x_{1}, \\cdots, x_{n}$] be the polynomial ring in n variables over an integral domain $A$, $D$ an $A$-[derivation](https://en.wikipedia.org/wiki/Derivation_(differential_algebra)) of $A[\\mathbf{x}]$ and denote \n$$L^{D}_{ij} := D(x_{i}) x_{j} - D(x_{j}) x_{i}, \\quad \\text{ for each } i, j \\in \\{1, \\cdots, n\\}.$$\n\n\n## Theorem 1 [Nowicki 1, Conjecture 6.9.10]\nAssume that $k[\\mathbf{y}] = k[y_{1}, \\cdots, y_{n}]$ is the polynomial ring in $n$ variables over a field $k$ of characteristic zero. If $\\Delta_{n}$ is the $k[\\mathbf{y}]$-derivation of $k[\\mathbf{y}][\\mathbf{x}]$ defined by $\\Delta_{n}(x_{i}) = y_{i}$ for $i = 1, \\cdots, n$, then $\\ker \\Delta_{n}$ is generated by $L^{\\Delta_{n}}_{ij}$ for $1 ≤ i < j ≤ n$ over $k[\\mathbf{y}]$.\n\n\n## Proof of Theorem 1\n\nWe prove the conjecture by induction on $n$. \n\nStep $1$. The assertion is clear when $n = 1$. \n\nStep $n-1$. By the assumption on induction, $\\ker \\Delta_{n-1}$ is generated by $S_{n-1}$ over $k[\\mathbf{y}^{\\prime}] := k[y_{1}, \\cdots , y_{n-1}]$, since $L^{\\Delta_{n-1}}_{i,j} = L^{\\Delta_{n}}_{i,j}$ for each $i, j$.\n\nStep $n$. Split the theorem into several lemmas.\n\n## Lemma 1 \n\nThe $k[\\mathbf{y}^{\\prime}]$-derivation $\\Delta_{n-1}$ that naturally extends to a $k[\\mathbf{y}]$-derivation $(\\Delta_{n-1})_{k[\\mathbf{y}]}$ of $k[\\mathbf{y}][\\mathbf{x}^{\\prime}] := k[\\mathbf{y}][x_{1}, \\cdots, x_{n-1}]$ satisfies\n\n$$\\begin{equation}\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n} = k[\\mathbf{y}][S_{n-1}].\n\\end{equation}$$\n\n## Proof of Lemma 1\n\nAs discussed in Section 1, then $(\\Delta_{n-1})k[\\mathbf{y}] = \\Delta_{n}|_{k[\\mathbf{y}][\\mathbf{x}^{\\prime}]}$, so we have $\\ker(\\Delta_{n-1})k[\\mathbf{y}] = k[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n}$. Moreover,\n$\\ker(\\Delta_{n-1})k[\\mathbf{y}] = k[\\mathbf{y}] \\otimes_{k[\\mathbf{y}^{\\prime}]} \\ker \\Delta_{n-1}$, since $k[\\mathbf{y}]$ is flat over $k[\\mathbf{y}^{\\prime}]$. $\\square$\n\n\n\nLet $\\mathbf{e}_{1}, \\cdots , \\mathbf{e}_{n}$ be the coordinate unit vectors of $\\mathbb{R}^{n}$, $M$ the $\\mathbb{Z}$-submodule of $(\\mathbb{Z}^{n})^{2}$ generated by $(\\mathbf{e}_{j} - \\mathbf{e}_{i}, \\mathbf{e}_{i} - \\mathbf{e}_{j})$ for $1 \\leq i < j \\leq n$, and $\\Gamma = (\\mathbb{Z}^{n})^{2}/M$.  \n\n\n## Theorem 2\n\nFor each $\\gamma \\in \\Gamma$, we define $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma}$ to be the $k$-vector space generated by $\\mathbf{y}^{a}\\mathbf{x}^{b}:= y^{a_{1}} \\cdots y^{a_{n}} x^{b_{1}} \\cdots x^{b_{n}}$ for $a = (a_{1}, \\cdots , a_{n})$ and $b = (b_{1}, \\cdots , b_{n})$ in $(\\mathbb{Z}_{\\geq 0})^{n}$ such that the image of $(a, b)$ in $\\Gamma$ is equal to $\\gamma$. Then \n\n$$\\ker \\Delta_{n} = \\bigoplus_{\\gamma \\in \\Gamma} k[\\mathbf{y}] [ \\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}$$\n\n## Proof of Theorem 2\n\nNote that $\\Delta_{n}(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma})$ is contained in $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma - \\delta}$ for each $\\gamma \\in \\Gamma$, where $\\delta$ is the image of $(-\\mathbb{e}_{n}, \\mathbb{e}_{n})$ in $\\Gamma$. $\\square$\n\n\n\nHence, we are reduced to showing that each $0 \\neq \\varPhi \\in k[\\mathbf{y}][\\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}$ belongs to $k[\\mathbf{y}][S_{n}]$ for $\\gamma \\in \\Gamma$.\n\nWe may find $a = (a_{1}, \\cdots , a_{n}) \\in \\mathbb{Z}^{n}$ and $l \\in \\mathbb{Z}_{\\geq 0}$ such that the image of $(a, l\\mathbf{e}_{n})$ in $\\Gamma$ is equal to $\\gamma$. Let $m$ be the $x_{n}$-degree of $\\varPhi$, where $0 \\leq m \\leq l$, and $\\phi \\in k[\\mathbf{y}][\\mathbf{x}^{\\prime}]$ the coefficient of $x_{n}^{m}$ in $\\varPhi$. By replacing $\\varPhi$ if necessary, we may assume that $m$ is the minimum among the $x_{n}$-degrees of elements of $\\ker \\Delta_{n}\\backslash k[\\mathbf{y}][S_{n}]$. \n\n## Lemma 2 \n\nWrite $\\phi$ in expression of sum of $y_{1}\\cdots y_{n}$\n\n$$\\phi = y_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}$$\n\nwhere $L^{\\mathbf{u}} = \\prod_{1 \\leq i<j\\leq n-1} L_{i,j}^{u_{i,j}}$ for each $\\mathbf{u}$. There holds the identity\n\n$$\\begin{equation}\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\n\\end{equation}$$\n\n\n## Lemma 3\n\nThere holds the inequality\n\n$$\\begin{equation}\nm \\geq 2l - \\sum_{i=1}^{n-1} a_{i}.\n\\end{equation}$$\n\n\n\n## Proof of Lemma 2\n\n\nthen, $\\phi$ belongs to $k[\\mathbf{y}][\\mathbf{x}]_{\\mu}$, where $\\mu$ is the image of $(a, (l - m)\\mathbf{e}_{n})$ in $\\Gamma$. Furthermore, $0 = \\Delta_{n}(\\varPhi) = \\Delta_{n}(\\varphi)x^{m}_{n} + m\\phi y_{n}x_{n}^{m-1} + \\Delta_{n}(\\varPhi - \\phi x^{m}_{n})$, and the $x_{n}$-degrees of $m\\phi y_{n}x_{n}^{m-1}$ and $\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})$ are at most $m - 1$. Hence, $\\Delta_{n}(\\phi) = 0$. Thus, $\\phi$ belongs to $k[\\mathbf{y}][S_{n-1}]$ by (1). Write $\\phi = \\sum_{b,\\mathbf{u}} r^{\\prime}_{b,\\mathbf{u}}y^{b}\\hat{y}^{-\\mathbf{u}}L^{\\mathbf{u}}$, where the sum is taken over $b \\in (\\mathbb{Z}_{\\geq 0})^{n}$ and $u = (u_{i,j})_{i,j}$ with $u_{i,j} \\in \\mathbb{Z}_{\\geq 0}$ for $1 \\leq i < j \\leq n - 1$, $r^{\\prime}_{b,\\mathbf{u}} \\in k$ for each $b$ and $\\mathbf{u}$, and \n\n$\\hat{y}^{-u} = \\prod_{1\\leq i < j \\leq n-1} (y_{i}y_{j})^{-u_{i,j}}, \\quad L^{\\mathbf{u}} = \\prod_{1 \\leq i<j\\leq n-1} L_{i,j}^{u_{i,j}}$ for each $\\mathbf{u}$.\n\nWe may assume that $r_{b,\\mathbf{u}}^{\\prime} = 0$ if $\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}$ is not in $k[\\mathbf{y}]$. Let $\\eta(b, \\mathbf{u})$ be the image of $(b - |\\mathbf{u}|\\mathbf{e}_{n}, |\\mathbf{u}|\\mathbf{e}_{n})$ in $\\Gamma$, where $|\\mathbf{u}| = \\sum_{i,j} u_{i,j}$. Then, $\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}L^{\\mathbf{u}}$ belongs to $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\eta(b,\\mathbf{u})}$ for each $b$ and $\\mathbf{u}$ where $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}] := k[\\mathbf{y}][\\mathbf{x}][(y_{1} \\cdots y_{n})^{-1}]$, since $(y_{i}y_{j})^{-1} L_{i,j}$ belongs to $k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}]_{\\delta}$ for each $i, j$.  Since $\\phi$ is in $k[\\mathbf{y}][\\mathbf{x}]_{\\mu}$, and $\\mu$ is the image of $(a, (l - m)\\mathbf{e}_{n})$, we may assume that $r_{b,\\mathbf{u}}^{\\prime} = 0$ unless $|u| = l - m$ and $b = a + (l - m)\\mathbf{e}_{n}$. For each $\\mathbf{u}$ with $r_{\\mathbf{u}} := r^{\\prime}_{a + (l-m) \\mathbf{e}_{n},\\mathbf{u}}\\neq 0$, write $\\mathbf{y}^{a} y_{n}^{l-m} \\hat{\\mathbf{y}}^{-\\mathbf{u}} = y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} y_{n}^{s}$, where $\\rho_{i}(u) \\in \\mathbb{Z}_{\\geq 0}$ for $i = 1, \\cdots , n - 1$, and $s = a_{n} + l - m$. Then, we have $\\phi = y_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}$. Since $|u| = l - m$, it follows that\n\n\n$$\\begin{equation}\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\n\\end{equation}$$\n\n## Proof of Lemma 3\n\nTake $\\varPhi$ which does not satisfy (3) so that $m$ would be the minimum among the $x_{n}$-degrees of such polynomials. Then, $t:= 2l - \\sum_{i=1}^{n-1}a_{i} -m$ is positive, and $\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) = m - t$ for each $\\mathbf{u}$ by (2). Hence, the $x_{n}$-degree of\n\n$$\\varPhi_{1}:= \\sum_{\\mathbf{u}} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} L_{n,i}^{\\rho_{i}(\\mathbf{u})} = \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} (y_{i}x_{n} - y_{n}x_{i})^{\\rho_{i}(\\mathbf{u})}$$\n\n\nis $m - t$. The coefficient of $x_{n}^{n-t}$ in $y_{n}^{s}\\varPhi_{1}$ is equal to $\\phi$, so the coefficient of $x_{n}^{m}$ in $y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$ is equal to that in $y_{1}^{t}\\varPhi$. Consequently, the $x_{n}$-degree $m^{\\prime}$ of $\\varPhi_{2}:= y_{1}^{t}\\varPhi - y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$ is less than $m$. We claim that $\\varPhi_{2} = 0$. In fact, if $\\gamma^{\\prime}$ is the image of $(a + t\\mathbf{e}_{1}, l\\mathbf{e}_{n})$ in $\\Gamma$, and $(a^{\\prime}_{1}, \\cdots , a_{n}^{\\prime}\n) := a + t\\mathbf{e}_{1}$, then $\\varPhi_{2}$ belongs to $k[\\mathbf{y}][\\mathbf{x}]_{\\gamma^{\\prime}} \\cap \\ker \\Delta_{n}$, and\n\n\n$$2l - \\sum_{i=1}^{n-1} a^{\\prime}_{i} = 2l - \\sum_{i=1}^{n-1} a_{i} - t = m > m^{\\prime}$$\n\n\nThis implies that $\\varPhi_{2} = 0$ by the minimality of $m$. Hence, $y_{1}^{t} \\varPhi= y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}$. Thus, $\\varPhi_{1}$ is divisible by $y_{1}$, since neither are $y_{n}$ and $L_{n,1}$. Recall that the kernel of a locally nilpotent derivation $D$ of an integral domain $R$ containing $Q$ is factorially closed in $R$, that is, $D(f g) =\n0$ implies $D(f ) = D(g) = 0$ for each $f, g \\in R \\ \\{0\\}$ (cf. [2, Proposition 1.3.32 (iii)]). Note\nthat $\\Delta_{n}$ is locally nilpotent, $\\Delta_{n}(\\varPhi_{1}) = 0$, $\\varPhi_{1} \\neq 0$ and $\\Delta_{n}(x_{n}) \\neq 0$. Hence, $\\varPhi_{1}$ is not divisible by $x_{n}$. By substituting zero for $x_{n}$, we obtain from $\\varPhi_{1}$ a nonzero polynomial\n\n$$\\sum_{\\mathbf{u}}r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} (- y_{n} x_{i})^{\\rho_{i}(\\mathbf{u})} = ( - y_{n} )^{m-i} \\varPsi, \\text{ where } \\varPsi = \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} x_{i}^{\\rho_{i}(\\mathbf{u})}.$$\n\nThen, $\\varPhi \\neq 0$, and $\\varPhi$ is divisible by $y_{1}$, since so is $\\phi_{1}$. Define $\\sigma \\in \\text{Aut}_{k} k[\\mathbf{y}][\\mathbf{x}]$ by $\\sigma(x_{i}) =\ny_{i}$ and $\\sigma(y_{i}) = x_{i}$ for $i = 1, \\cdots, n$. Then, $\\sigma(\\varPhi)$ is divisible by $x_{1}$. On the other hand, $\\sigma(L_{i,j}) = L_{j,i}$ and $\\sigma(x_{i}) = y_{i}$ are in $\\ker \\Delta_{n}$ for each $i, j$, so $\\sigma(\\varPsi)$ belongs to $\\ker \\Delta_{n}$. Thus, we have $\\sigma(\\varPsi) = 0$, because $x_{1}$ is not in $\\ker \\Delta_[n]$ and $\\ker \\Delta_{n}$ is factorially closed in $k[\\mathbf{y}][\\mathbf{x}]$. This contradicts that $\\varPsi \\neq 0$. $\\square$\n\n\n## Proof of Theorem 1\n\n\nIn fact, (3) implies that $\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) \\geq m$ by (2), so we have $\\sum_{i=1}^{n-1}\\rho_{i}^{\\prime}(\\mathbf{u})  = m$ for some\nintegers $0 \\leq \\rho^{\\prime}_{i}(\\mathbf{u}) \\leq \\rho_{i}(\\mathbf{u})$ for $i = 1, \\cdots, n - 1$ for each $u$. Then,\n\n$$\\varPhi^{\\prime} := y_{n}^{s} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}) - \\rho_{i}^{\\prime}(\\mathbf{u})} L_{n,i}^{\\rho_{i}^{\\prime}(\\mathbf{u})} = y_{n}^{s} \\sum_{\\mathbf{u}} r_{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}) - \\rho_{i}^{\\prime}(\\mathbf{u}) } (y_{i}x_{n} - x_{n}y_{i})^{\\rho_{i}^{\\prime}(\\mathbf{u}) }$$\n\n\nis an element of $k[\\mathbf{y}][S_{n}]$ having $x_{n}$-degree $m$, in which the coefficient of $x_{n}^{m}$ is equal to $\\phi$. Hence, the $x_{n}$-degree of $\\varPhi - \\varPhi^{\\prime}$ is less than $m$. Since $\\varPhi - \\varPhi^{\\prime}$ is an element of $\\ker \\Delta_{n} \\backslash k[\\mathbf{y}][S_{n}]$, this contradicts the minimality of $m$. $\\square$\n\n\n","slug":"Nowicki Conjecture","published":1,"updated":"2024-02-25T15:11:07.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5s4001um8nx0x5l1c2b","content":"<p>Let <span class=\"math inline\">\\(A[\\mathbf{x}] = A[x_{1}, \\cdots,\r\nx_{n}\\)</span>] be the polynomial ring in n variables over an integral\r\ndomain <span class=\"math inline\">\\(A\\)</span>, <span class=\"math inline\">\\(D\\)</span> an <span class=\"math inline\">\\(A\\)</span>-<a href=\"https://en.wikipedia.org/wiki/Derivation_(differential_algebra)\">derivation</a>\r\nof <span class=\"math inline\">\\(A[\\mathbf{x}]\\)</span> and denote <span class=\"math display\">\\[L^{D}_{ij} := D(x_{i}) x_{j} - D(x_{j}) x_{i},\r\n\\quad \\text{ for each } i, j \\in \\{1, \\cdots, n\\}.\\]</span></p>\r\n<h2 id=\"theorem-1-nowicki-1-conjecture-6.9.10\">Theorem 1 [Nowicki 1,\r\nConjecture 6.9.10]</h2>\r\n<p>Assume that <span class=\"math inline\">\\(k[\\mathbf{y}] = k[y_{1},\r\n\\cdots, y_{n}]\\)</span> is the polynomial ring in <span class=\"math inline\">\\(n\\)</span> variables over a field <span class=\"math inline\">\\(k\\)</span> of characteristic zero. If <span class=\"math inline\">\\(\\Delta_{n}\\)</span> is the <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>-derivation of <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span> defined by\r\n<span class=\"math inline\">\\(\\Delta_{n}(x_{i}) = y_{i}\\)</span> for <span class=\"math inline\">\\(i = 1, \\cdots, n\\)</span>, then <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> is generated by <span class=\"math inline\">\\(L^{\\Delta_{n}}_{ij}\\)</span> for <span class=\"math inline\">\\(1 ≤ i &lt; j ≤ n\\)</span> over <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>.</p>\r\n<h2 id=\"proof-of-theorem-1\">Proof of Theorem 1</h2>\r\n<p>We prove the conjecture by induction on <span class=\"math inline\">\\(n\\)</span>.</p>\r\n<p>Step <span class=\"math inline\">\\(1\\)</span>. The assertion is clear\r\nwhen <span class=\"math inline\">\\(n = 1\\)</span>.</p>\r\n<p>Step <span class=\"math inline\">\\(n-1\\)</span>. By the assumption on\r\ninduction, <span class=\"math inline\">\\(\\ker \\Delta_{n-1}\\)</span> is\r\ngenerated by <span class=\"math inline\">\\(S_{n-1}\\)</span> over <span class=\"math inline\">\\(k[\\mathbf{y}^{\\prime}] := k[y_{1}, \\cdots ,\r\ny_{n-1}]\\)</span>, since <span class=\"math inline\">\\(L^{\\Delta_{n-1}}_{i,j} =\r\nL^{\\Delta_{n}}_{i,j}\\)</span> for each <span class=\"math inline\">\\(i,\r\nj\\)</span>.</p>\r\n<p>Step <span class=\"math inline\">\\(n\\)</span>. Split the theorem into\r\nseveral lemmas.</p>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>The <span class=\"math inline\">\\(k[\\mathbf{y}^{\\prime}]\\)</span>-derivation <span class=\"math inline\">\\(\\Delta_{n-1}\\)</span> that naturally extends to a\r\n<span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>-derivation <span class=\"math inline\">\\((\\Delta_{n-1})_{k[\\mathbf{y}]}\\)</span> of <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}^{\\prime}] :=\r\nk[\\mathbf{y}][x_{1}, \\cdots, x_{n-1}]\\)</span> satisfies</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n} =\r\nk[\\mathbf{y}][S_{n-1}].\r\n\\end{equation}\\]</span></p>\r\n<h2 id=\"proof-of-lemma-1\">Proof of Lemma 1</h2>\r\n<p>As discussed in Section 1, then <span class=\"math inline\">\\((\\Delta_{n-1})k[\\mathbf{y}] =\r\n\\Delta_{n}|_{k[\\mathbf{y}][\\mathbf{x}^{\\prime}]}\\)</span>, so we have\r\n<span class=\"math inline\">\\(\\ker(\\Delta_{n-1})k[\\mathbf{y}] =\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n}\\)</span>.\r\nMoreover, <span class=\"math inline\">\\(\\ker(\\Delta_{n-1})k[\\mathbf{y}] =\r\nk[\\mathbf{y}] \\otimes_{k[\\mathbf{y}^{\\prime}]} \\ker\r\n\\Delta_{n-1}\\)</span>, since <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span> is flat over <span class=\"math inline\">\\(k[\\mathbf{y}^{\\prime}]\\)</span>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<p>Let <span class=\"math inline\">\\(\\mathbf{e}_{1}, \\cdots ,\r\n\\mathbf{e}_{n}\\)</span> be the coordinate unit vectors of <span class=\"math inline\">\\(\\mathbb{R}^{n}\\)</span>, <span class=\"math inline\">\\(M\\)</span> the <span class=\"math inline\">\\(\\mathbb{Z}\\)</span>-submodule of <span class=\"math inline\">\\((\\mathbb{Z}^{n})^{2}\\)</span> generated by <span class=\"math inline\">\\((\\mathbf{e}_{j} - \\mathbf{e}_{i}, \\mathbf{e}_{i} -\r\n\\mathbf{e}_{j})\\)</span> for <span class=\"math inline\">\\(1 \\leq i &lt; j\r\n\\leq n\\)</span>, and <span class=\"math inline\">\\(\\Gamma =\r\n(\\mathbb{Z}^{n})^{2}/M\\)</span>.</p>\r\n<h2 id=\"theorem-2\">Theorem 2</h2>\r\n<p>For each <span class=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span>, we\r\ndefine <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma}\\)</span> to be\r\nthe <span class=\"math inline\">\\(k\\)</span>-vector space generated by\r\n<span class=\"math inline\">\\(\\mathbf{y}^{a}\\mathbf{x}^{b}:= y^{a_{1}}\r\n\\cdots y^{a_{n}} x^{b_{1}} \\cdots x^{b_{n}}\\)</span> for <span class=\"math inline\">\\(a = (a_{1}, \\cdots , a_{n})\\)</span> and <span class=\"math inline\">\\(b = (b_{1}, \\cdots , b_{n})\\)</span> in <span class=\"math inline\">\\((\\mathbb{Z}_{\\geq 0})^{n}\\)</span> such that the\r\nimage of <span class=\"math inline\">\\((a, b)\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span> is equal to <span class=\"math inline\">\\(\\gamma\\)</span>. Then</p>\r\n<p><span class=\"math display\">\\[\\ker \\Delta_{n} = \\bigoplus_{\\gamma \\in\r\n\\Gamma} k[\\mathbf{y}] [ \\mathbf{x}]_{\\gamma} \\cap \\ker\r\n\\Delta_{n}\\]</span></p>\r\n<h2 id=\"proof-of-theorem-2\">Proof of Theorem 2</h2>\r\n<p>Note that <span class=\"math inline\">\\(\\Delta_{n}(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma})\\)</span>\r\nis contained in <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma -\r\n\\delta}\\)</span> for each <span class=\"math inline\">\\(\\gamma \\in\r\n\\Gamma\\)</span>, where <span class=\"math inline\">\\(\\delta\\)</span> is\r\nthe image of <span class=\"math inline\">\\((-\\mathbb{e}_{n},\r\n\\mathbb{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span>.\r\n<span class=\"math inline\">\\(\\square\\)</span></p>\r\n<p>Hence, we are reduced to showing that each <span class=\"math inline\">\\(0 \\neq \\varPhi \\in\r\nk[\\mathbf{y}][\\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}\\)</span> belongs\r\nto <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> for <span class=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span>.</p>\r\n<p>We may find <span class=\"math inline\">\\(a = (a_{1}, \\cdots , a_{n})\r\n\\in \\mathbb{Z}^{n}\\)</span> and <span class=\"math inline\">\\(l \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> such that the image of <span class=\"math inline\">\\((a, l\\mathbf{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span> is equal to <span class=\"math inline\">\\(\\gamma\\)</span>. Let <span class=\"math inline\">\\(m\\)</span> be the <span class=\"math inline\">\\(x_{n}\\)</span>-degree of <span class=\"math inline\">\\(\\varPhi\\)</span>, where <span class=\"math inline\">\\(0 \\leq m \\leq l\\)</span>, and <span class=\"math inline\">\\(\\phi \\in\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}]\\)</span> the coefficient of <span class=\"math inline\">\\(x_{n}^{m}\\)</span> in <span class=\"math inline\">\\(\\varPhi\\)</span>. By replacing <span class=\"math inline\">\\(\\varPhi\\)</span> if necessary, we may assume that\r\n<span class=\"math inline\">\\(m\\)</span> is the minimum among the <span class=\"math inline\">\\(x_{n}\\)</span>-degrees of elements of <span class=\"math inline\">\\(\\ker \\Delta_{n}\\backslash\r\nk[\\mathbf{y}][S_{n}]\\)</span>.</p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>Write <span class=\"math inline\">\\(\\phi\\)</span> in expression of sum\r\nof <span class=\"math inline\">\\(y_{1}\\cdots y_{n}\\)</span></p>\r\n<p><span class=\"math display\">\\[\\phi = y_{n}^{s}\\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})}\r\n\\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(L^{\\mathbf{u}} = \\prod_{1 \\leq\r\ni&lt;j\\leq n-1} L_{i,j}^{u_{i,j}}\\)</span> for each <span class=\"math inline\">\\(\\mathbf{u}\\)</span>. There holds the identity</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\r\n\\end{equation}\\]</span></p>\r\n<h2 id=\"lemma-3\">Lemma 3</h2>\r\n<p>There holds the inequality</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm \\geq 2l - \\sum_{i=1}^{n-1} a_{i}.\r\n\\end{equation}\\]</span></p>\r\n<h2 id=\"proof-of-lemma-2\">Proof of Lemma 2</h2>\r\n<p>then, <span class=\"math inline\">\\(\\phi\\)</span> belongs to <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\mu}\\)</span>, where\r\n<span class=\"math inline\">\\(\\mu\\)</span> is the image of <span class=\"math inline\">\\((a, (l - m)\\mathbf{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span>. Furthermore, <span class=\"math inline\">\\(0 = \\Delta_{n}(\\varPhi) =\r\n\\Delta_{n}(\\varphi)x^{m}_{n} + m\\phi y_{n}x_{n}^{m-1} +\r\n\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})\\)</span>, and the <span class=\"math inline\">\\(x_{n}\\)</span>-degrees of <span class=\"math inline\">\\(m\\phi y_{n}x_{n}^{m-1}\\)</span> and <span class=\"math inline\">\\(\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})\\)</span> are\r\nat most <span class=\"math inline\">\\(m - 1\\)</span>. Hence, <span class=\"math inline\">\\(\\Delta_{n}(\\phi) = 0\\)</span>. Thus, <span class=\"math inline\">\\(\\phi\\)</span> belongs to <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n-1}]\\)</span> by (1). Write\r\n<span class=\"math inline\">\\(\\phi = \\sum_{b,\\mathbf{u}}\r\nr^{\\prime}_{b,\\mathbf{u}}y^{b}\\hat{y}^{-\\mathbf{u}}L^{\\mathbf{u}}\\)</span>,\r\nwhere the sum is taken over <span class=\"math inline\">\\(b \\in\r\n(\\mathbb{Z}_{\\geq 0})^{n}\\)</span> and <span class=\"math inline\">\\(u =\r\n(u_{i,j})_{i,j}\\)</span> with <span class=\"math inline\">\\(u_{i,j} \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> for <span class=\"math inline\">\\(1 \\leq i\r\n&lt; j \\leq n - 1\\)</span>, <span class=\"math inline\">\\(r^{\\prime}_{b,\\mathbf{u}} \\in k\\)</span> for each\r\n<span class=\"math inline\">\\(b\\)</span> and <span class=\"math inline\">\\(\\mathbf{u}\\)</span>, and</p>\r\n<p><span class=\"math inline\">\\(\\hat{y}^{-u} = \\prod_{1\\leq i &lt; j \\leq\r\nn-1} (y_{i}y_{j})^{-u_{i,j}}, \\quad L^{\\mathbf{u}} = \\prod_{1 \\leq\r\ni&lt;j\\leq n-1} L_{i,j}^{u_{i,j}}\\)</span> for each <span class=\"math inline\">\\(\\mathbf{u}\\)</span>.</p>\r\n<p>We may assume that <span class=\"math inline\">\\(r_{b,\\mathbf{u}}^{\\prime} = 0\\)</span> if <span class=\"math inline\">\\(\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}\\)</span>\r\nis not in <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>. Let <span class=\"math inline\">\\(\\eta(b, \\mathbf{u})\\)</span> be the image of <span class=\"math inline\">\\((b - |\\mathbf{u}|\\mathbf{e}_{n},\r\n|\\mathbf{u}|\\mathbf{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span>, where <span class=\"math inline\">\\(|\\mathbf{u}| = \\sum_{i,j} u_{i,j}\\)</span>. Then,\r\n<span class=\"math inline\">\\(\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}L^{\\mathbf{u}}\\)</span>\r\nbelongs to <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\eta(b,\\mathbf{u})}\\)</span> for each <span class=\"math inline\">\\(b\\)</span> and <span class=\"math inline\">\\(\\mathbf{u}\\)</span> where <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}] :=\r\nk[\\mathbf{y}][\\mathbf{x}][(y_{1} \\cdots y_{n})^{-1}]\\)</span>, since\r\n<span class=\"math inline\">\\((y_{i}y_{j})^{-1} L_{i,j}\\)</span> belongs\r\nto <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\delta}\\)</span> for each <span class=\"math inline\">\\(i, j\\)</span>. Since <span class=\"math inline\">\\(\\phi\\)</span> is in <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\mu}\\)</span>, and\r\n<span class=\"math inline\">\\(\\mu\\)</span> is the image of <span class=\"math inline\">\\((a, (l - m)\\mathbf{e}_{n})\\)</span>, we may assume\r\nthat <span class=\"math inline\">\\(r_{b,\\mathbf{u}}^{\\prime} = 0\\)</span>\r\nunless <span class=\"math inline\">\\(|u| = l - m\\)</span> and <span class=\"math inline\">\\(b = a + (l - m)\\mathbf{e}_{n}\\)</span>. For each\r\n<span class=\"math inline\">\\(\\mathbf{u}\\)</span> with <span class=\"math inline\">\\(r_{\\mathbf{u}} := r^{\\prime}_{a + (l-m)\r\n\\mathbf{e}_{n},\\mathbf{u}}\\neq 0\\)</span>, write <span class=\"math inline\">\\(\\mathbf{y}^{a} y_{n}^{l-m}\r\n\\hat{\\mathbf{y}}^{-\\mathbf{u}} = y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots\r\ny_{n-1}^{\\rho_{n-1}(\\mathbf{u})} y_{n}^{s}\\)</span>, where <span class=\"math inline\">\\(\\rho_{i}(u) \\in \\mathbb{Z}_{\\geq 0}\\)</span> for\r\n<span class=\"math inline\">\\(i = 1, \\cdots , n - 1\\)</span>, and <span class=\"math inline\">\\(s = a_{n} + l - m\\)</span>. Then, we have <span class=\"math inline\">\\(\\phi = y_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}}\r\ny_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})}\r\nL^{\\mathbf{u}}\\)</span>. Since <span class=\"math inline\">\\(|u| = l -\r\nm\\)</span>, it follows that</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\r\n\\end{equation}\\]</span></p>\r\n<h2 id=\"proof-of-lemma-3\">Proof of Lemma 3</h2>\r\n<p>Take <span class=\"math inline\">\\(\\varPhi\\)</span> which does not\r\nsatisfy (3) so that <span class=\"math inline\">\\(m\\)</span> would be the\r\nminimum among the <span class=\"math inline\">\\(x_{n}\\)</span>-degrees of\r\nsuch polynomials. Then, <span class=\"math inline\">\\(t:= 2l -\r\n\\sum_{i=1}^{n-1}a_{i} -m\\)</span> is positive, and <span class=\"math inline\">\\(\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) = m -\r\nt\\)</span> for each <span class=\"math inline\">\\(\\mathbf{u}\\)</span> by\r\n(2). Hence, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree of</p>\r\n<p><span class=\"math display\">\\[\\varPhi_{1}:= \\sum_{\\mathbf{u}}\r\n\\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\nL_{n,i}^{\\rho_{i}(\\mathbf{u})} = \\sum_{\\mathbf{u}} r_{\\mathbf{u}}\r\nL^{\\mathbf{u}} \\prod_{i=1}^{n-1} (y_{i}x_{n} -\r\ny_{n}x_{i})^{\\rho_{i}(\\mathbf{u})}\\]</span></p>\r\n<p>is <span class=\"math inline\">\\(m - t\\)</span>. The coefficient of\r\n<span class=\"math inline\">\\(x_{n}^{n-t}\\)</span> in <span class=\"math inline\">\\(y_{n}^{s}\\varPhi_{1}\\)</span> is equal to <span class=\"math inline\">\\(\\phi\\)</span>, so the coefficient of <span class=\"math inline\">\\(x_{n}^{m}\\)</span> in <span class=\"math inline\">\\(y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span> is equal\r\nto that in <span class=\"math inline\">\\(y_{1}^{t}\\varPhi\\)</span>.\r\nConsequently, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree\r\n<span class=\"math inline\">\\(m^{\\prime}\\)</span> of <span class=\"math inline\">\\(\\varPhi_{2}:= y_{1}^{t}\\varPhi -\r\ny_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span> is less than <span class=\"math inline\">\\(m\\)</span>. We claim that <span class=\"math inline\">\\(\\varPhi_{2} = 0\\)</span>. In fact, if <span class=\"math inline\">\\(\\gamma^{\\prime}\\)</span> is the image of <span class=\"math inline\">\\((a + t\\mathbf{e}_{1}, l\\mathbf{e}_{n})\\)</span> in\r\n<span class=\"math inline\">\\(\\Gamma\\)</span>, and <span class=\"math inline\">\\((a^{\\prime}_{1}, \\cdots , a_{n}^{\\prime}\r\n) := a + t\\mathbf{e}_{1}\\)</span>, then <span class=\"math inline\">\\(\\varPhi_{2}\\)</span> belongs to <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma^{\\prime}} \\cap\r\n\\ker \\Delta_{n}\\)</span>, and</p>\r\n<p><span class=\"math display\">\\[2l - \\sum_{i=1}^{n-1} a^{\\prime}_{i} =\r\n2l - \\sum_{i=1}^{n-1} a_{i} - t = m &gt; m^{\\prime}\\]</span></p>\r\n<p>This implies that <span class=\"math inline\">\\(\\varPhi_{2} =\r\n0\\)</span> by the minimality of <span class=\"math inline\">\\(m\\)</span>.\r\nHence, <span class=\"math inline\">\\(y_{1}^{t} \\varPhi=\r\ny_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span>. Thus, <span class=\"math inline\">\\(\\varPhi_{1}\\)</span> is divisible by <span class=\"math inline\">\\(y_{1}\\)</span>, since neither are <span class=\"math inline\">\\(y_{n}\\)</span> and <span class=\"math inline\">\\(L_{n,1}\\)</span>. Recall that the kernel of a\r\nlocally nilpotent derivation <span class=\"math inline\">\\(D\\)</span> of\r\nan integral domain <span class=\"math inline\">\\(R\\)</span> containing\r\n<span class=\"math inline\">\\(Q\\)</span> is factorially closed in <span class=\"math inline\">\\(R\\)</span>, that is, <span class=\"math inline\">\\(D(f g) =\r\n0\\)</span> implies <span class=\"math inline\">\\(D(f ) = D(g) = 0\\)</span>\r\nfor each <span class=\"math inline\">\\(f, g \\in R \\ \\{0\\}\\)</span> (cf.\r\n[2, Proposition 1.3.32 (iii)]). Note that <span class=\"math inline\">\\(\\Delta_{n}\\)</span> is locally nilpotent, <span class=\"math inline\">\\(\\Delta_{n}(\\varPhi_{1}) = 0\\)</span>, <span class=\"math inline\">\\(\\varPhi_{1} \\neq 0\\)</span> and <span class=\"math inline\">\\(\\Delta_{n}(x_{n}) \\neq 0\\)</span>. Hence, <span class=\"math inline\">\\(\\varPhi_{1}\\)</span> is not divisible by <span class=\"math inline\">\\(x_{n}\\)</span>. By substituting zero for <span class=\"math inline\">\\(x_{n}\\)</span>, we obtain from <span class=\"math inline\">\\(\\varPhi_{1}\\)</span> a nonzero polynomial</p>\r\n<p><span class=\"math display\">\\[\\sum_{\\mathbf{u}}r_{\\mathbf{u}}\r\nL^{\\mathbf{u}} \\prod_{i=1}^{n-1} (- y_{n} x_{i})^{\\rho_{i}(\\mathbf{u})}\r\n= ( - y_{n} )^{m-i} \\varPsi, \\text{ where } \\varPsi = \\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\nx_{i}^{\\rho_{i}(\\mathbf{u})}.\\]</span></p>\r\n<p>Then, <span class=\"math inline\">\\(\\varPhi \\neq 0\\)</span>, and <span class=\"math inline\">\\(\\varPhi\\)</span> is divisible by <span class=\"math inline\">\\(y_{1}\\)</span>, since so is <span class=\"math inline\">\\(\\phi_{1}\\)</span>. Define <span class=\"math inline\">\\(\\sigma \\in \\text{Aut}_{k}\r\nk[\\mathbf{y}][\\mathbf{x}]\\)</span> by <span class=\"math inline\">\\(\\sigma(x_{i}) =\r\ny_{i}\\)</span> and <span class=\"math inline\">\\(\\sigma(y_{i}) =\r\nx_{i}\\)</span> for <span class=\"math inline\">\\(i = 1, \\cdots,\r\nn\\)</span>. Then, <span class=\"math inline\">\\(\\sigma(\\varPhi)\\)</span>\r\nis divisible by <span class=\"math inline\">\\(x_{1}\\)</span>. On the other\r\nhand, <span class=\"math inline\">\\(\\sigma(L_{i,j}) = L_{j,i}\\)</span> and\r\n<span class=\"math inline\">\\(\\sigma(x_{i}) = y_{i}\\)</span> are in <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> for each <span class=\"math inline\">\\(i, j\\)</span>, so <span class=\"math inline\">\\(\\sigma(\\varPsi)\\)</span> belongs to <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span>. Thus, we have <span class=\"math inline\">\\(\\sigma(\\varPsi) = 0\\)</span>, because <span class=\"math inline\">\\(x_{1}\\)</span> is not in <span class=\"math inline\">\\(\\ker \\Delta_[n]\\)</span> and <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> is factorially closed in\r\n<span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span>. This\r\ncontradicts that <span class=\"math inline\">\\(\\varPsi \\neq 0\\)</span>.\r\n<span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"proof-of-theorem-1-1\">Proof of Theorem 1</h2>\r\n<p>In fact, (3) implies that <span class=\"math inline\">\\(\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) \\geq\r\nm\\)</span> by (2), so we have <span class=\"math inline\">\\(\\sum_{i=1}^{n-1}\\rho_{i}^{\\prime}(\\mathbf{u})  =\r\nm\\)</span> for some integers <span class=\"math inline\">\\(0 \\leq\r\n\\rho^{\\prime}_{i}(\\mathbf{u}) \\leq \\rho_{i}(\\mathbf{u})\\)</span> for\r\n<span class=\"math inline\">\\(i = 1, \\cdots, n - 1\\)</span> for each <span class=\"math inline\">\\(u\\)</span>. Then,</p>\r\n<p><span class=\"math display\">\\[\\varPhi^{\\prime} := y_{n}^{s}\r\n\\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\ny_{i}^{\\rho_{i}(\\mathbf{u}) - \\rho_{i}^{\\prime}(\\mathbf{u})}\r\nL_{n,i}^{\\rho_{i}^{\\prime}(\\mathbf{u})} = y_{n}^{s} \\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}) -\r\n\\rho_{i}^{\\prime}(\\mathbf{u}) } (y_{i}x_{n} -\r\nx_{n}y_{i})^{\\rho_{i}^{\\prime}(\\mathbf{u}) }\\]</span></p>\r\n<p>is an element of <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> having <span class=\"math inline\">\\(x_{n}\\)</span>-degree <span class=\"math inline\">\\(m\\)</span>, in which the coefficient of <span class=\"math inline\">\\(x_{n}^{m}\\)</span> is equal to <span class=\"math inline\">\\(\\phi\\)</span>. Hence, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree of <span class=\"math inline\">\\(\\varPhi - \\varPhi^{\\prime}\\)</span> is less than\r\n<span class=\"math inline\">\\(m\\)</span>. Since <span class=\"math inline\">\\(\\varPhi - \\varPhi^{\\prime}\\)</span> is an element\r\nof <span class=\"math inline\">\\(\\ker \\Delta_{n} \\backslash\r\nk[\\mathbf{y}][S_{n}]\\)</span>, this contradicts the minimality of <span class=\"math inline\">\\(m\\)</span>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>Let <span class=\"math inline\">\\(A[\\mathbf{x}] = A[x_{1}, \\cdots,\r\nx_{n}\\)</span>] be the polynomial ring in n variables over an integral\r\ndomain <span class=\"math inline\">\\(A\\)</span>, <span class=\"math inline\">\\(D\\)</span> an <span class=\"math inline\">\\(A\\)</span>-<a href=\"https://en.wikipedia.org/wiki/Derivation_(differential_algebra)\">derivation</a>\r\nof <span class=\"math inline\">\\(A[\\mathbf{x}]\\)</span> and denote <span class=\"math display\">\\[L^{D}_{ij} := D(x_{i}) x_{j} - D(x_{j}) x_{i},\r\n\\quad \\text{ for each } i, j \\in \\{1, \\cdots, n\\}.\\]</span></p>\r\n<h2 id=\"theorem-1-nowicki-1-conjecture-6.9.10\">Theorem 1 [Nowicki 1,\r\nConjecture 6.9.10]</h2>\r\n<p>Assume that <span class=\"math inline\">\\(k[\\mathbf{y}] = k[y_{1},\r\n\\cdots, y_{n}]\\)</span> is the polynomial ring in <span class=\"math inline\">\\(n\\)</span> variables over a field <span class=\"math inline\">\\(k\\)</span> of characteristic zero. If <span class=\"math inline\">\\(\\Delta_{n}\\)</span> is the <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>-derivation of <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span> defined by\r\n<span class=\"math inline\">\\(\\Delta_{n}(x_{i}) = y_{i}\\)</span> for <span class=\"math inline\">\\(i = 1, \\cdots, n\\)</span>, then <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> is generated by <span class=\"math inline\">\\(L^{\\Delta_{n}}_{ij}\\)</span> for <span class=\"math inline\">\\(1 ≤ i &lt; j ≤ n\\)</span> over <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>.</p>\r\n<h2 id=\"proof-of-theorem-1\">Proof of Theorem 1</h2>\r\n<p>We prove the conjecture by induction on <span class=\"math inline\">\\(n\\)</span>.</p>\r\n<p>Step <span class=\"math inline\">\\(1\\)</span>. The assertion is clear\r\nwhen <span class=\"math inline\">\\(n = 1\\)</span>.</p>\r\n<p>Step <span class=\"math inline\">\\(n-1\\)</span>. By the assumption on\r\ninduction, <span class=\"math inline\">\\(\\ker \\Delta_{n-1}\\)</span> is\r\ngenerated by <span class=\"math inline\">\\(S_{n-1}\\)</span> over <span class=\"math inline\">\\(k[\\mathbf{y}^{\\prime}] := k[y_{1}, \\cdots ,\r\ny_{n-1}]\\)</span>, since <span class=\"math inline\">\\(L^{\\Delta_{n-1}}_{i,j} =\r\nL^{\\Delta_{n}}_{i,j}\\)</span> for each <span class=\"math inline\">\\(i,\r\nj\\)</span>.</p>\r\n<p>Step <span class=\"math inline\">\\(n\\)</span>. Split the theorem into\r\nseveral lemmas.</p>\r\n<h2 id=\"lemma-1\">Lemma 1</h2>\r\n<p>The <span class=\"math inline\">\\(k[\\mathbf{y}^{\\prime}]\\)</span>-derivation <span class=\"math inline\">\\(\\Delta_{n-1}\\)</span> that naturally extends to a\r\n<span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>-derivation <span class=\"math inline\">\\((\\Delta_{n-1})_{k[\\mathbf{y}]}\\)</span> of <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}^{\\prime}] :=\r\nk[\\mathbf{y}][x_{1}, \\cdots, x_{n-1}]\\)</span> satisfies</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n} =\r\nk[\\mathbf{y}][S_{n-1}].\r\n\\end{equation}\\]</span></p>\r\n<h2 id=\"proof-of-lemma-1\">Proof of Lemma 1</h2>\r\n<p>As discussed in Section 1, then <span class=\"math inline\">\\((\\Delta_{n-1})k[\\mathbf{y}] =\r\n\\Delta_{n}|_{k[\\mathbf{y}][\\mathbf{x}^{\\prime}]}\\)</span>, so we have\r\n<span class=\"math inline\">\\(\\ker(\\Delta_{n-1})k[\\mathbf{y}] =\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}] \\cap \\ker \\Delta_{n}\\)</span>.\r\nMoreover, <span class=\"math inline\">\\(\\ker(\\Delta_{n-1})k[\\mathbf{y}] =\r\nk[\\mathbf{y}] \\otimes_{k[\\mathbf{y}^{\\prime}]} \\ker\r\n\\Delta_{n-1}\\)</span>, since <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span> is flat over <span class=\"math inline\">\\(k[\\mathbf{y}^{\\prime}]\\)</span>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<p>Let <span class=\"math inline\">\\(\\mathbf{e}_{1}, \\cdots ,\r\n\\mathbf{e}_{n}\\)</span> be the coordinate unit vectors of <span class=\"math inline\">\\(\\mathbb{R}^{n}\\)</span>, <span class=\"math inline\">\\(M\\)</span> the <span class=\"math inline\">\\(\\mathbb{Z}\\)</span>-submodule of <span class=\"math inline\">\\((\\mathbb{Z}^{n})^{2}\\)</span> generated by <span class=\"math inline\">\\((\\mathbf{e}_{j} - \\mathbf{e}_{i}, \\mathbf{e}_{i} -\r\n\\mathbf{e}_{j})\\)</span> for <span class=\"math inline\">\\(1 \\leq i &lt; j\r\n\\leq n\\)</span>, and <span class=\"math inline\">\\(\\Gamma =\r\n(\\mathbb{Z}^{n})^{2}/M\\)</span>.</p>\r\n<h2 id=\"theorem-2\">Theorem 2</h2>\r\n<p>For each <span class=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span>, we\r\ndefine <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma}\\)</span> to be\r\nthe <span class=\"math inline\">\\(k\\)</span>-vector space generated by\r\n<span class=\"math inline\">\\(\\mathbf{y}^{a}\\mathbf{x}^{b}:= y^{a_{1}}\r\n\\cdots y^{a_{n}} x^{b_{1}} \\cdots x^{b_{n}}\\)</span> for <span class=\"math inline\">\\(a = (a_{1}, \\cdots , a_{n})\\)</span> and <span class=\"math inline\">\\(b = (b_{1}, \\cdots , b_{n})\\)</span> in <span class=\"math inline\">\\((\\mathbb{Z}_{\\geq 0})^{n}\\)</span> such that the\r\nimage of <span class=\"math inline\">\\((a, b)\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span> is equal to <span class=\"math inline\">\\(\\gamma\\)</span>. Then</p>\r\n<p><span class=\"math display\">\\[\\ker \\Delta_{n} = \\bigoplus_{\\gamma \\in\r\n\\Gamma} k[\\mathbf{y}] [ \\mathbf{x}]_{\\gamma} \\cap \\ker\r\n\\Delta_{n}\\]</span></p>\r\n<h2 id=\"proof-of-theorem-2\">Proof of Theorem 2</h2>\r\n<p>Note that <span class=\"math inline\">\\(\\Delta_{n}(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma})\\)</span>\r\nis contained in <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma -\r\n\\delta}\\)</span> for each <span class=\"math inline\">\\(\\gamma \\in\r\n\\Gamma\\)</span>, where <span class=\"math inline\">\\(\\delta\\)</span> is\r\nthe image of <span class=\"math inline\">\\((-\\mathbb{e}_{n},\r\n\\mathbb{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span>.\r\n<span class=\"math inline\">\\(\\square\\)</span></p>\r\n<p>Hence, we are reduced to showing that each <span class=\"math inline\">\\(0 \\neq \\varPhi \\in\r\nk[\\mathbf{y}][\\mathbf{x}]_{\\gamma} \\cap \\ker \\Delta_{n}\\)</span> belongs\r\nto <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> for <span class=\"math inline\">\\(\\gamma \\in \\Gamma\\)</span>.</p>\r\n<p>We may find <span class=\"math inline\">\\(a = (a_{1}, \\cdots , a_{n})\r\n\\in \\mathbb{Z}^{n}\\)</span> and <span class=\"math inline\">\\(l \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> such that the image of <span class=\"math inline\">\\((a, l\\mathbf{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span> is equal to <span class=\"math inline\">\\(\\gamma\\)</span>. Let <span class=\"math inline\">\\(m\\)</span> be the <span class=\"math inline\">\\(x_{n}\\)</span>-degree of <span class=\"math inline\">\\(\\varPhi\\)</span>, where <span class=\"math inline\">\\(0 \\leq m \\leq l\\)</span>, and <span class=\"math inline\">\\(\\phi \\in\r\nk[\\mathbf{y}][\\mathbf{x}^{\\prime}]\\)</span> the coefficient of <span class=\"math inline\">\\(x_{n}^{m}\\)</span> in <span class=\"math inline\">\\(\\varPhi\\)</span>. By replacing <span class=\"math inline\">\\(\\varPhi\\)</span> if necessary, we may assume that\r\n<span class=\"math inline\">\\(m\\)</span> is the minimum among the <span class=\"math inline\">\\(x_{n}\\)</span>-degrees of elements of <span class=\"math inline\">\\(\\ker \\Delta_{n}\\backslash\r\nk[\\mathbf{y}][S_{n}]\\)</span>.</p>\r\n<h2 id=\"lemma-2\">Lemma 2</h2>\r\n<p>Write <span class=\"math inline\">\\(\\phi\\)</span> in expression of sum\r\nof <span class=\"math inline\">\\(y_{1}\\cdots y_{n}\\)</span></p>\r\n<p><span class=\"math display\">\\[\\phi = y_{n}^{s}\\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} y_{1}^{\\rho_{1}(\\mathbf{u})}\r\n\\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})} L^{\\mathbf{u}}\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(L^{\\mathbf{u}} = \\prod_{1 \\leq\r\ni&lt;j\\leq n-1} L_{i,j}^{u_{i,j}}\\)</span> for each <span class=\"math inline\">\\(\\mathbf{u}\\)</span>. There holds the identity</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\r\n\\end{equation}\\]</span></p>\r\n<h2 id=\"lemma-3\">Lemma 3</h2>\r\n<p>There holds the inequality</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nm \\geq 2l - \\sum_{i=1}^{n-1} a_{i}.\r\n\\end{equation}\\]</span></p>\r\n<h2 id=\"proof-of-lemma-2\">Proof of Lemma 2</h2>\r\n<p>then, <span class=\"math inline\">\\(\\phi\\)</span> belongs to <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\mu}\\)</span>, where\r\n<span class=\"math inline\">\\(\\mu\\)</span> is the image of <span class=\"math inline\">\\((a, (l - m)\\mathbf{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span>. Furthermore, <span class=\"math inline\">\\(0 = \\Delta_{n}(\\varPhi) =\r\n\\Delta_{n}(\\varphi)x^{m}_{n} + m\\phi y_{n}x_{n}^{m-1} +\r\n\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})\\)</span>, and the <span class=\"math inline\">\\(x_{n}\\)</span>-degrees of <span class=\"math inline\">\\(m\\phi y_{n}x_{n}^{m-1}\\)</span> and <span class=\"math inline\">\\(\\Delta_{n}(\\varPhi - \\phi x^{m}_{n})\\)</span> are\r\nat most <span class=\"math inline\">\\(m - 1\\)</span>. Hence, <span class=\"math inline\">\\(\\Delta_{n}(\\phi) = 0\\)</span>. Thus, <span class=\"math inline\">\\(\\phi\\)</span> belongs to <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n-1}]\\)</span> by (1). Write\r\n<span class=\"math inline\">\\(\\phi = \\sum_{b,\\mathbf{u}}\r\nr^{\\prime}_{b,\\mathbf{u}}y^{b}\\hat{y}^{-\\mathbf{u}}L^{\\mathbf{u}}\\)</span>,\r\nwhere the sum is taken over <span class=\"math inline\">\\(b \\in\r\n(\\mathbb{Z}_{\\geq 0})^{n}\\)</span> and <span class=\"math inline\">\\(u =\r\n(u_{i,j})_{i,j}\\)</span> with <span class=\"math inline\">\\(u_{i,j} \\in\r\n\\mathbb{Z}_{\\geq 0}\\)</span> for <span class=\"math inline\">\\(1 \\leq i\r\n&lt; j \\leq n - 1\\)</span>, <span class=\"math inline\">\\(r^{\\prime}_{b,\\mathbf{u}} \\in k\\)</span> for each\r\n<span class=\"math inline\">\\(b\\)</span> and <span class=\"math inline\">\\(\\mathbf{u}\\)</span>, and</p>\r\n<p><span class=\"math inline\">\\(\\hat{y}^{-u} = \\prod_{1\\leq i &lt; j \\leq\r\nn-1} (y_{i}y_{j})^{-u_{i,j}}, \\quad L^{\\mathbf{u}} = \\prod_{1 \\leq\r\ni&lt;j\\leq n-1} L_{i,j}^{u_{i,j}}\\)</span> for each <span class=\"math inline\">\\(\\mathbf{u}\\)</span>.</p>\r\n<p>We may assume that <span class=\"math inline\">\\(r_{b,\\mathbf{u}}^{\\prime} = 0\\)</span> if <span class=\"math inline\">\\(\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}\\)</span>\r\nis not in <span class=\"math inline\">\\(k[\\mathbf{y}]\\)</span>. Let <span class=\"math inline\">\\(\\eta(b, \\mathbf{u})\\)</span> be the image of <span class=\"math inline\">\\((b - |\\mathbf{u}|\\mathbf{e}_{n},\r\n|\\mathbf{u}|\\mathbf{e}_{n})\\)</span> in <span class=\"math inline\">\\(\\Gamma\\)</span>, where <span class=\"math inline\">\\(|\\mathbf{u}| = \\sum_{i,j} u_{i,j}\\)</span>. Then,\r\n<span class=\"math inline\">\\(\\mathbf{y}^{b}\\hat{\\mathbf{y}}^{-\\mathbf{u}}L^{\\mathbf{u}}\\)</span>\r\nbelongs to <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\eta(b,\\mathbf{u})}\\)</span> for each <span class=\"math inline\">\\(b\\)</span> and <span class=\"math inline\">\\(\\mathbf{u}\\)</span> where <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm 1}][\\mathbf{x}] :=\r\nk[\\mathbf{y}][\\mathbf{x}][(y_{1} \\cdots y_{n})^{-1}]\\)</span>, since\r\n<span class=\"math inline\">\\((y_{i}y_{j})^{-1} L_{i,j}\\)</span> belongs\r\nto <span class=\"math inline\">\\(k[\\mathbf{y}^{\\pm\r\n1}][\\mathbf{x}]_{\\delta}\\)</span> for each <span class=\"math inline\">\\(i, j\\)</span>. Since <span class=\"math inline\">\\(\\phi\\)</span> is in <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\mu}\\)</span>, and\r\n<span class=\"math inline\">\\(\\mu\\)</span> is the image of <span class=\"math inline\">\\((a, (l - m)\\mathbf{e}_{n})\\)</span>, we may assume\r\nthat <span class=\"math inline\">\\(r_{b,\\mathbf{u}}^{\\prime} = 0\\)</span>\r\nunless <span class=\"math inline\">\\(|u| = l - m\\)</span> and <span class=\"math inline\">\\(b = a + (l - m)\\mathbf{e}_{n}\\)</span>. For each\r\n<span class=\"math inline\">\\(\\mathbf{u}\\)</span> with <span class=\"math inline\">\\(r_{\\mathbf{u}} := r^{\\prime}_{a + (l-m)\r\n\\mathbf{e}_{n},\\mathbf{u}}\\neq 0\\)</span>, write <span class=\"math inline\">\\(\\mathbf{y}^{a} y_{n}^{l-m}\r\n\\hat{\\mathbf{y}}^{-\\mathbf{u}} = y_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots\r\ny_{n-1}^{\\rho_{n-1}(\\mathbf{u})} y_{n}^{s}\\)</span>, where <span class=\"math inline\">\\(\\rho_{i}(u) \\in \\mathbb{Z}_{\\geq 0}\\)</span> for\r\n<span class=\"math inline\">\\(i = 1, \\cdots , n - 1\\)</span>, and <span class=\"math inline\">\\(s = a_{n} + l - m\\)</span>. Then, we have <span class=\"math inline\">\\(\\phi = y_{n}^{s}\\sum_{\\mathbf{u}} r_{\\mathbf{u}}\r\ny_{1}^{\\rho_{1}(\\mathbf{u})} \\cdots  y_{n-1}^{\\rho_{n-1}(\\mathbf{u})}\r\nL^{\\mathbf{u}}\\)</span>. Since <span class=\"math inline\">\\(|u| = l -\r\nm\\)</span>, it follows that</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\sum_{i=1}^{n-1} \\rho_{i} (\\mathbf{u}) = \\sum_{i=1}^{n-1}a_{i} - 2(l-m)\r\n\\end{equation}\\]</span></p>\r\n<h2 id=\"proof-of-lemma-3\">Proof of Lemma 3</h2>\r\n<p>Take <span class=\"math inline\">\\(\\varPhi\\)</span> which does not\r\nsatisfy (3) so that <span class=\"math inline\">\\(m\\)</span> would be the\r\nminimum among the <span class=\"math inline\">\\(x_{n}\\)</span>-degrees of\r\nsuch polynomials. Then, <span class=\"math inline\">\\(t:= 2l -\r\n\\sum_{i=1}^{n-1}a_{i} -m\\)</span> is positive, and <span class=\"math inline\">\\(\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) = m -\r\nt\\)</span> for each <span class=\"math inline\">\\(\\mathbf{u}\\)</span> by\r\n(2). Hence, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree of</p>\r\n<p><span class=\"math display\">\\[\\varPhi_{1}:= \\sum_{\\mathbf{u}}\r\n\\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\nL_{n,i}^{\\rho_{i}(\\mathbf{u})} = \\sum_{\\mathbf{u}} r_{\\mathbf{u}}\r\nL^{\\mathbf{u}} \\prod_{i=1}^{n-1} (y_{i}x_{n} -\r\ny_{n}x_{i})^{\\rho_{i}(\\mathbf{u})}\\]</span></p>\r\n<p>is <span class=\"math inline\">\\(m - t\\)</span>. The coefficient of\r\n<span class=\"math inline\">\\(x_{n}^{n-t}\\)</span> in <span class=\"math inline\">\\(y_{n}^{s}\\varPhi_{1}\\)</span> is equal to <span class=\"math inline\">\\(\\phi\\)</span>, so the coefficient of <span class=\"math inline\">\\(x_{n}^{m}\\)</span> in <span class=\"math inline\">\\(y_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span> is equal\r\nto that in <span class=\"math inline\">\\(y_{1}^{t}\\varPhi\\)</span>.\r\nConsequently, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree\r\n<span class=\"math inline\">\\(m^{\\prime}\\)</span> of <span class=\"math inline\">\\(\\varPhi_{2}:= y_{1}^{t}\\varPhi -\r\ny_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span> is less than <span class=\"math inline\">\\(m\\)</span>. We claim that <span class=\"math inline\">\\(\\varPhi_{2} = 0\\)</span>. In fact, if <span class=\"math inline\">\\(\\gamma^{\\prime}\\)</span> is the image of <span class=\"math inline\">\\((a + t\\mathbf{e}_{1}, l\\mathbf{e}_{n})\\)</span> in\r\n<span class=\"math inline\">\\(\\Gamma\\)</span>, and <span class=\"math inline\">\\((a^{\\prime}_{1}, \\cdots , a_{n}^{\\prime}\r\n) := a + t\\mathbf{e}_{1}\\)</span>, then <span class=\"math inline\">\\(\\varPhi_{2}\\)</span> belongs to <span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]_{\\gamma^{\\prime}} \\cap\r\n\\ker \\Delta_{n}\\)</span>, and</p>\r\n<p><span class=\"math display\">\\[2l - \\sum_{i=1}^{n-1} a^{\\prime}_{i} =\r\n2l - \\sum_{i=1}^{n-1} a_{i} - t = m &gt; m^{\\prime}\\]</span></p>\r\n<p>This implies that <span class=\"math inline\">\\(\\varPhi_{2} =\r\n0\\)</span> by the minimality of <span class=\"math inline\">\\(m\\)</span>.\r\nHence, <span class=\"math inline\">\\(y_{1}^{t} \\varPhi=\r\ny_{n}^{s}\\varPhi_{1}L_{n,1}^{t}\\)</span>. Thus, <span class=\"math inline\">\\(\\varPhi_{1}\\)</span> is divisible by <span class=\"math inline\">\\(y_{1}\\)</span>, since neither are <span class=\"math inline\">\\(y_{n}\\)</span> and <span class=\"math inline\">\\(L_{n,1}\\)</span>. Recall that the kernel of a\r\nlocally nilpotent derivation <span class=\"math inline\">\\(D\\)</span> of\r\nan integral domain <span class=\"math inline\">\\(R\\)</span> containing\r\n<span class=\"math inline\">\\(Q\\)</span> is factorially closed in <span class=\"math inline\">\\(R\\)</span>, that is, <span class=\"math inline\">\\(D(f g) =\r\n0\\)</span> implies <span class=\"math inline\">\\(D(f ) = D(g) = 0\\)</span>\r\nfor each <span class=\"math inline\">\\(f, g \\in R \\ \\{0\\}\\)</span> (cf.\r\n[2, Proposition 1.3.32 (iii)]). Note that <span class=\"math inline\">\\(\\Delta_{n}\\)</span> is locally nilpotent, <span class=\"math inline\">\\(\\Delta_{n}(\\varPhi_{1}) = 0\\)</span>, <span class=\"math inline\">\\(\\varPhi_{1} \\neq 0\\)</span> and <span class=\"math inline\">\\(\\Delta_{n}(x_{n}) \\neq 0\\)</span>. Hence, <span class=\"math inline\">\\(\\varPhi_{1}\\)</span> is not divisible by <span class=\"math inline\">\\(x_{n}\\)</span>. By substituting zero for <span class=\"math inline\">\\(x_{n}\\)</span>, we obtain from <span class=\"math inline\">\\(\\varPhi_{1}\\)</span> a nonzero polynomial</p>\r\n<p><span class=\"math display\">\\[\\sum_{\\mathbf{u}}r_{\\mathbf{u}}\r\nL^{\\mathbf{u}} \\prod_{i=1}^{n-1} (- y_{n} x_{i})^{\\rho_{i}(\\mathbf{u})}\r\n= ( - y_{n} )^{m-i} \\varPsi, \\text{ where } \\varPsi = \\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\nx_{i}^{\\rho_{i}(\\mathbf{u})}.\\]</span></p>\r\n<p>Then, <span class=\"math inline\">\\(\\varPhi \\neq 0\\)</span>, and <span class=\"math inline\">\\(\\varPhi\\)</span> is divisible by <span class=\"math inline\">\\(y_{1}\\)</span>, since so is <span class=\"math inline\">\\(\\phi_{1}\\)</span>. Define <span class=\"math inline\">\\(\\sigma \\in \\text{Aut}_{k}\r\nk[\\mathbf{y}][\\mathbf{x}]\\)</span> by <span class=\"math inline\">\\(\\sigma(x_{i}) =\r\ny_{i}\\)</span> and <span class=\"math inline\">\\(\\sigma(y_{i}) =\r\nx_{i}\\)</span> for <span class=\"math inline\">\\(i = 1, \\cdots,\r\nn\\)</span>. Then, <span class=\"math inline\">\\(\\sigma(\\varPhi)\\)</span>\r\nis divisible by <span class=\"math inline\">\\(x_{1}\\)</span>. On the other\r\nhand, <span class=\"math inline\">\\(\\sigma(L_{i,j}) = L_{j,i}\\)</span> and\r\n<span class=\"math inline\">\\(\\sigma(x_{i}) = y_{i}\\)</span> are in <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> for each <span class=\"math inline\">\\(i, j\\)</span>, so <span class=\"math inline\">\\(\\sigma(\\varPsi)\\)</span> belongs to <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span>. Thus, we have <span class=\"math inline\">\\(\\sigma(\\varPsi) = 0\\)</span>, because <span class=\"math inline\">\\(x_{1}\\)</span> is not in <span class=\"math inline\">\\(\\ker \\Delta_[n]\\)</span> and <span class=\"math inline\">\\(\\ker \\Delta_{n}\\)</span> is factorially closed in\r\n<span class=\"math inline\">\\(k[\\mathbf{y}][\\mathbf{x}]\\)</span>. This\r\ncontradicts that <span class=\"math inline\">\\(\\varPsi \\neq 0\\)</span>.\r\n<span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"proof-of-theorem-1-1\">Proof of Theorem 1</h2>\r\n<p>In fact, (3) implies that <span class=\"math inline\">\\(\\sum_{i=1}^{n-1} \\rho_{i}(\\mathbf{u}) \\geq\r\nm\\)</span> by (2), so we have <span class=\"math inline\">\\(\\sum_{i=1}^{n-1}\\rho_{i}^{\\prime}(\\mathbf{u})  =\r\nm\\)</span> for some integers <span class=\"math inline\">\\(0 \\leq\r\n\\rho^{\\prime}_{i}(\\mathbf{u}) \\leq \\rho_{i}(\\mathbf{u})\\)</span> for\r\n<span class=\"math inline\">\\(i = 1, \\cdots, n - 1\\)</span> for each <span class=\"math inline\">\\(u\\)</span>. Then,</p>\r\n<p><span class=\"math display\">\\[\\varPhi^{\\prime} := y_{n}^{s}\r\n\\sum_{\\mathbf{u}} r_{\\mathbf{u}} L^{\\mathbf{u}} \\prod_{i=1}^{n-1}\r\ny_{i}^{\\rho_{i}(\\mathbf{u}) - \\rho_{i}^{\\prime}(\\mathbf{u})}\r\nL_{n,i}^{\\rho_{i}^{\\prime}(\\mathbf{u})} = y_{n}^{s} \\sum_{\\mathbf{u}}\r\nr_{\\mathbf{u}} \\prod_{i=1}^{n-1} y_{i}^{\\rho_{i}(\\mathbf{u}) -\r\n\\rho_{i}^{\\prime}(\\mathbf{u}) } (y_{i}x_{n} -\r\nx_{n}y_{i})^{\\rho_{i}^{\\prime}(\\mathbf{u}) }\\]</span></p>\r\n<p>is an element of <span class=\"math inline\">\\(k[\\mathbf{y}][S_{n}]\\)</span> having <span class=\"math inline\">\\(x_{n}\\)</span>-degree <span class=\"math inline\">\\(m\\)</span>, in which the coefficient of <span class=\"math inline\">\\(x_{n}^{m}\\)</span> is equal to <span class=\"math inline\">\\(\\phi\\)</span>. Hence, the <span class=\"math inline\">\\(x_{n}\\)</span>-degree of <span class=\"math inline\">\\(\\varPhi - \\varPhi^{\\prime}\\)</span> is less than\r\n<span class=\"math inline\">\\(m\\)</span>. Since <span class=\"math inline\">\\(\\varPhi - \\varPhi^{\\prime}\\)</span> is an element\r\nof <span class=\"math inline\">\\(\\ker \\Delta_{n} \\backslash\r\nk[\\mathbf{y}][S_{n}]\\)</span>, this contradicts the minimality of <span class=\"math inline\">\\(m\\)</span>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Feb 25 2024 23:11:07 GMT+0800 (中国标准时间)","title":"Nowicki Conjecture","path":"2023/04/11/Nowicki Conjecture/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-04-11T08:28:25.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-04-11T08:28:25.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Notes","tags":["Notes"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Quadratic Reciprocity Law","date":"2023-03-27T10:42:10.000Z","mathjax":true,"_content":"\n\n# Quadratic Reciprocity Law\n\n## The Reciprocity Law one\n\nLet $p$ and $q$ be distinct odd prime numbers, and define the Legendre symbol as\n\n$$\\left({\\frac{q}{p}}\\right)=\n\\begin{cases}1&{\\text{if }}n^{2}\\equiv q{\\mod {p}}{\\text{ for some integer }}n\\\\\n-1&{\\text{otherwise}}\n\\end{cases}$$\nThen\n\n$$\\left(\\frac {p}{q}\\right)\\left(\\frac{q}{p}\\right)=(-1)^{p^{\\prime}q^{\\prime}}.$$\n\nwhere $p^{\\prime} = \\frac{p-1}{2}$ and $q^{\\prime}=\\frac{q-1}{2}$.\n\n![](QRL.png)\n\nSince $p^{\\prime}q^{\\prime}$ is even if either $p$ or $q$ is of the form $4n+1$, and odd if both are of the form $4n + 3$, we can also state the theorem as\n\n## The Reciprocity Law two\n\nIf $p$ and $q$ are odd primes, then\n$$\\left(\\frac {p}{q}\\right) = \\left(\\frac{q}{p}\\right)$$\nunless both $p$ and $q$ are of the forv $4n+3$, in which case\n$$\\left(\\frac {p}{q}\\right) = - \\left(\\frac{q}{p}\\right)$$\n\n## The Reciprocity Lemma\nIf \n$$S(q,p) = \\sum_{s=1}^{p^{\\prime}}\\left[\\frac{sq}{p}\\right],$$\nthen\n$$S(q,p) + S(p,q) = p^{\\prime}q^{\\prime}.$$\n\nThe proof may be stated in a geometrical form. In the figure $AC$ and $BC$ are $x = p$, $y=q$, and $KM$ and $LM$ are $x = p^{\\prime}$, $y = q^{\\prime}$. If (as in the figure) $p > q$, then $q^{\\prime}/p^{\\prime} < q/p$, and $M$ falls below the\ndiagonal $OC$. Since\n$$q^{\\prime} < \\frac{qp^{\\prime}}{p} < q^{\\prime}-l,$$\nthere is no integer between $KM = q^{\\prime}$ and $KN = qp^{\\prime}/p$.\n\nWe count up, in two different ways, the number of lattice points in\nthe rectangle $OKML$, counting the points on $KM$ and $LM$ but not\nthose on the axes. In the first place, this number is plainly $p^{\\prime}q^{\\prime}$. But there are no lattice points on $OC$ (since $p$ and $q$ are prime), and none in the triangle $PMN$ except perhaps on $PM$. Hence the number of\nlattice points in $OKML$ is the sum of those in the triangles $OKN$ and $OLP$ (counting those on $KN$ and $LP$ but not those on the axes). The number on $ST$, the line $x = s$, is $[sq/p]$, since $sq/p$ is the ordinate of $T$. Hence the number in $OKN$ is\n$$\\sum_{s=1}^{p^{\\prime}}\\left[\\frac{sq}{p}\\right] = S(q,p)$$\nSimilarly, the number in $OLP$ is $S(p, q)$, and the conclusion follows.\n\n\n## The proof of Reciprocity Law\n\nWe can write\n\\begin{equation}\n\\label{eq: summing}\nkq = p \\left[\\frac{kq}{p}\\right] + u_{k}\n\\end{equation}\nwhere $1\\leq k \\leq p^{\\prime}$, $1 \\leq u_{k} \\leq p-1$.\nHere $u_k$ is the least positive residue of $kq (\\bmod \\, p)$. If $u_k = v_k \\leq  p^{\\prime}$, then $u_k$ is one of the minimal residues $r_i$, while if $u_k = w_k > p^{\\prime}$, then $u_k - p$ is one of the minimal residues $-r^{\\prime}_{j}$. Thus\n$$r_i = v_k, \\quad r^{\\prime}_{j} = p - w_k$$\nfor every $i,j$ and some $k$.\n\nThe $r_i$ and $r_j^{\\prime}$ are the numbers $1,2,\\dots,p^{\\prime}$ in some order. Hence, if\n$$R = \\sum r_i = \\sum v_k, \\quad R^{\\prime} = \\sum r_{j}^{\\prime} = \\sum (p - w_k) = up - \\sum w_k$$\n(where $\\mu$ is the number of $r_j^{\\prime}$), we have\n$$R+R^{\\prime} = \\sum_{\\nu=1}^{p^{\\prime}} \\nu = \\frac{1}{2}\\frac{p-1}{2}\\frac{p+1}{2} = \\frac{p^2 -1}{8},$$\nand so \n\\begin{equation}\n\\label{eq: From}\n\\mu p +\\sum v_k - \\sum w_k = \\frac{1}{8}(p^2-1)\n\\end{equation}\nOn the other hand, summing \\eqref{eq: summing} from $k=1$ to $k=p^{\\prime}$, we have\n\\begin{equation}\n\\label{eq: and}\n\\frac{1}{8} q (p^2-1) = p S(q,p) + \\sum u_{k} = p S(q,p) + \\sum v_{k} + \\sum w_k.\n\\end{equation}\nFrom \\eqref{eq: From} and \\eqref{eq: and} we deduce\n\\begin{equation}\n\\label{eq: of}\n\\frac{1}{8} (p^2-1) (q-1) = pS(q,p) + 2\\sum w_k - \\mu p.\n\\end{equation}\nNow $q-1$ is even, and $p^2 -1 \\equiv 0 (\\bmod 8)$; so that the left-hand side of \\eqref{eq: of} is even, and also the second term on the right. Hence (since $p$ is odd)\n$$S(q,p) \\equiv \\mu (\\bmod 2),$$\nand therefore, by Gauss's lemma,\n$$\\left(\\frac {q}{p}\\right) = (-1)^{\\mu} = (-1)^{S(q,p)}.$$\nFinally, \n$$\\left(\\frac {q}{p}\\right)\\left(\\frac {p}{q}\\right) = (-1)^{S(q,p) + S(p,q)} = (-1)^{p^{\\prime}q^{\\prime}}$$\nby preceding lemma.\n\n\n\n\n\n\n[1] Hardy G.H., Wright E.M. - An Introduction to the Theory of Numbers (1975)","source":"_posts/Quadratic Reciprocity Law.md","raw":"---\ntitle: Quadratic Reciprocity Law\ndate: 2023-03-27 18:42:10\ntags: \n    - [Algebraic Number Theory]\ncategories: \n    - [Algebraic Number Theory]\nmathjax: true\n---\n\n\n# Quadratic Reciprocity Law\n\n## The Reciprocity Law one\n\nLet $p$ and $q$ be distinct odd prime numbers, and define the Legendre symbol as\n\n$$\\left({\\frac{q}{p}}\\right)=\n\\begin{cases}1&{\\text{if }}n^{2}\\equiv q{\\mod {p}}{\\text{ for some integer }}n\\\\\n-1&{\\text{otherwise}}\n\\end{cases}$$\nThen\n\n$$\\left(\\frac {p}{q}\\right)\\left(\\frac{q}{p}\\right)=(-1)^{p^{\\prime}q^{\\prime}}.$$\n\nwhere $p^{\\prime} = \\frac{p-1}{2}$ and $q^{\\prime}=\\frac{q-1}{2}$.\n\n![](QRL.png)\n\nSince $p^{\\prime}q^{\\prime}$ is even if either $p$ or $q$ is of the form $4n+1$, and odd if both are of the form $4n + 3$, we can also state the theorem as\n\n## The Reciprocity Law two\n\nIf $p$ and $q$ are odd primes, then\n$$\\left(\\frac {p}{q}\\right) = \\left(\\frac{q}{p}\\right)$$\nunless both $p$ and $q$ are of the forv $4n+3$, in which case\n$$\\left(\\frac {p}{q}\\right) = - \\left(\\frac{q}{p}\\right)$$\n\n## The Reciprocity Lemma\nIf \n$$S(q,p) = \\sum_{s=1}^{p^{\\prime}}\\left[\\frac{sq}{p}\\right],$$\nthen\n$$S(q,p) + S(p,q) = p^{\\prime}q^{\\prime}.$$\n\nThe proof may be stated in a geometrical form. In the figure $AC$ and $BC$ are $x = p$, $y=q$, and $KM$ and $LM$ are $x = p^{\\prime}$, $y = q^{\\prime}$. If (as in the figure) $p > q$, then $q^{\\prime}/p^{\\prime} < q/p$, and $M$ falls below the\ndiagonal $OC$. Since\n$$q^{\\prime} < \\frac{qp^{\\prime}}{p} < q^{\\prime}-l,$$\nthere is no integer between $KM = q^{\\prime}$ and $KN = qp^{\\prime}/p$.\n\nWe count up, in two different ways, the number of lattice points in\nthe rectangle $OKML$, counting the points on $KM$ and $LM$ but not\nthose on the axes. In the first place, this number is plainly $p^{\\prime}q^{\\prime}$. But there are no lattice points on $OC$ (since $p$ and $q$ are prime), and none in the triangle $PMN$ except perhaps on $PM$. Hence the number of\nlattice points in $OKML$ is the sum of those in the triangles $OKN$ and $OLP$ (counting those on $KN$ and $LP$ but not those on the axes). The number on $ST$, the line $x = s$, is $[sq/p]$, since $sq/p$ is the ordinate of $T$. Hence the number in $OKN$ is\n$$\\sum_{s=1}^{p^{\\prime}}\\left[\\frac{sq}{p}\\right] = S(q,p)$$\nSimilarly, the number in $OLP$ is $S(p, q)$, and the conclusion follows.\n\n\n## The proof of Reciprocity Law\n\nWe can write\n\\begin{equation}\n\\label{eq: summing}\nkq = p \\left[\\frac{kq}{p}\\right] + u_{k}\n\\end{equation}\nwhere $1\\leq k \\leq p^{\\prime}$, $1 \\leq u_{k} \\leq p-1$.\nHere $u_k$ is the least positive residue of $kq (\\bmod \\, p)$. If $u_k = v_k \\leq  p^{\\prime}$, then $u_k$ is one of the minimal residues $r_i$, while if $u_k = w_k > p^{\\prime}$, then $u_k - p$ is one of the minimal residues $-r^{\\prime}_{j}$. Thus\n$$r_i = v_k, \\quad r^{\\prime}_{j} = p - w_k$$\nfor every $i,j$ and some $k$.\n\nThe $r_i$ and $r_j^{\\prime}$ are the numbers $1,2,\\dots,p^{\\prime}$ in some order. Hence, if\n$$R = \\sum r_i = \\sum v_k, \\quad R^{\\prime} = \\sum r_{j}^{\\prime} = \\sum (p - w_k) = up - \\sum w_k$$\n(where $\\mu$ is the number of $r_j^{\\prime}$), we have\n$$R+R^{\\prime} = \\sum_{\\nu=1}^{p^{\\prime}} \\nu = \\frac{1}{2}\\frac{p-1}{2}\\frac{p+1}{2} = \\frac{p^2 -1}{8},$$\nand so \n\\begin{equation}\n\\label{eq: From}\n\\mu p +\\sum v_k - \\sum w_k = \\frac{1}{8}(p^2-1)\n\\end{equation}\nOn the other hand, summing \\eqref{eq: summing} from $k=1$ to $k=p^{\\prime}$, we have\n\\begin{equation}\n\\label{eq: and}\n\\frac{1}{8} q (p^2-1) = p S(q,p) + \\sum u_{k} = p S(q,p) + \\sum v_{k} + \\sum w_k.\n\\end{equation}\nFrom \\eqref{eq: From} and \\eqref{eq: and} we deduce\n\\begin{equation}\n\\label{eq: of}\n\\frac{1}{8} (p^2-1) (q-1) = pS(q,p) + 2\\sum w_k - \\mu p.\n\\end{equation}\nNow $q-1$ is even, and $p^2 -1 \\equiv 0 (\\bmod 8)$; so that the left-hand side of \\eqref{eq: of} is even, and also the second term on the right. Hence (since $p$ is odd)\n$$S(q,p) \\equiv \\mu (\\bmod 2),$$\nand therefore, by Gauss's lemma,\n$$\\left(\\frac {q}{p}\\right) = (-1)^{\\mu} = (-1)^{S(q,p)}.$$\nFinally, \n$$\\left(\\frac {q}{p}\\right)\\left(\\frac {p}{q}\\right) = (-1)^{S(q,p) + S(p,q)} = (-1)^{p^{\\prime}q^{\\prime}}$$\nby preceding lemma.\n\n\n\n\n\n\n[1] Hardy G.H., Wright E.M. - An Introduction to the Theory of Numbers (1975)","slug":"Quadratic Reciprocity Law","published":1,"updated":"2025-01-03T09:36:01.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5s4001xm8nx793lbboa","content":"<h1 id=\"quadratic-reciprocity-law\">Quadratic Reciprocity Law</h1>\r\n<h2 id=\"the-reciprocity-law-one\">The Reciprocity Law one</h2>\r\n<p>Let <span class=\"math inline\">\\(p\\)</span> and <span class=\"math inline\">\\(q\\)</span> be distinct odd prime numbers, and\r\ndefine the Legendre symbol as</p>\r\n<p><span class=\"math display\">\\[\\left({\\frac{q}{p}}\\right)=\r\n\\begin{cases}1&amp;{\\text{if }}n^{2}\\equiv q{\\mod {p}}{\\text{ for some\r\ninteger }}n\\\\\r\n-1&amp;{\\text{otherwise}}\r\n\\end{cases}\\]</span> Then</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac\r\n{p}{q}\\right)\\left(\\frac{q}{p}\\right)=(-1)^{p^{\\prime}q^{\\prime}}.\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(p^{\\prime} = \\frac{p-1}{2}\\)</span>\r\nand <span class=\"math inline\">\\(q^{\\prime}=\\frac{q-1}{2}\\)</span>.</p>\r\n<p><img src=\"/2023/03/27/Quadratic%20Reciprocity%20Law/QRL.png\"></p>\r\n<p>Since <span class=\"math inline\">\\(p^{\\prime}q^{\\prime}\\)</span> is\r\neven if either <span class=\"math inline\">\\(p\\)</span> or <span class=\"math inline\">\\(q\\)</span> is of the form <span class=\"math inline\">\\(4n+1\\)</span>, and odd if both are of the form\r\n<span class=\"math inline\">\\(4n + 3\\)</span>, we can also state the\r\ntheorem as</p>\r\n<h2 id=\"the-reciprocity-law-two\">The Reciprocity Law two</h2>\r\n<p>If <span class=\"math inline\">\\(p\\)</span> and <span class=\"math inline\">\\(q\\)</span> are odd primes, then <span class=\"math display\">\\[\\left(\\frac {p}{q}\\right) =\r\n\\left(\\frac{q}{p}\\right)\\]</span> unless both <span class=\"math inline\">\\(p\\)</span> and <span class=\"math inline\">\\(q\\)</span> are of the forv <span class=\"math inline\">\\(4n+3\\)</span>, in which case <span class=\"math display\">\\[\\left(\\frac {p}{q}\\right) = -\r\n\\left(\\frac{q}{p}\\right)\\]</span></p>\r\n<h2 id=\"the-reciprocity-lemma\">The Reciprocity Lemma</h2>\r\n<p>If <span class=\"math display\">\\[S(q,p) =\r\n\\sum_{s=1}^{p^{\\prime}}\\left[\\frac{sq}{p}\\right],\\]</span> then <span class=\"math display\">\\[S(q,p) + S(p,q) =\r\np^{\\prime}q^{\\prime}.\\]</span></p>\r\n<p>The proof may be stated in a geometrical form. In the figure <span class=\"math inline\">\\(AC\\)</span> and <span class=\"math inline\">\\(BC\\)</span> are <span class=\"math inline\">\\(x =\r\np\\)</span>, <span class=\"math inline\">\\(y=q\\)</span>, and <span class=\"math inline\">\\(KM\\)</span> and <span class=\"math inline\">\\(LM\\)</span> are <span class=\"math inline\">\\(x =\r\np^{\\prime}\\)</span>, <span class=\"math inline\">\\(y =\r\nq^{\\prime}\\)</span>. If (as in the figure) <span class=\"math inline\">\\(p\r\n&gt; q\\)</span>, then <span class=\"math inline\">\\(q^{\\prime}/p^{\\prime}\r\n&lt; q/p\\)</span>, and <span class=\"math inline\">\\(M\\)</span> falls\r\nbelow the diagonal <span class=\"math inline\">\\(OC\\)</span>. Since <span class=\"math display\">\\[q^{\\prime} &lt; \\frac{qp^{\\prime}}{p} &lt;\r\nq^{\\prime}-l,\\]</span> there is no integer between <span class=\"math inline\">\\(KM = q^{\\prime}\\)</span> and <span class=\"math inline\">\\(KN = qp^{\\prime}/p\\)</span>.</p>\r\n<p>We count up, in two different ways, the number of lattice points in\r\nthe rectangle <span class=\"math inline\">\\(OKML\\)</span>, counting the\r\npoints on <span class=\"math inline\">\\(KM\\)</span> and <span class=\"math inline\">\\(LM\\)</span> but not those on the axes. In the\r\nfirst place, this number is plainly <span class=\"math inline\">\\(p^{\\prime}q^{\\prime}\\)</span>. But there are no\r\nlattice points on <span class=\"math inline\">\\(OC\\)</span> (since <span class=\"math inline\">\\(p\\)</span> and <span class=\"math inline\">\\(q\\)</span> are prime), and none in the triangle\r\n<span class=\"math inline\">\\(PMN\\)</span> except perhaps on <span class=\"math inline\">\\(PM\\)</span>. Hence the number of lattice points in\r\n<span class=\"math inline\">\\(OKML\\)</span> is the sum of those in the\r\ntriangles <span class=\"math inline\">\\(OKN\\)</span> and <span class=\"math inline\">\\(OLP\\)</span> (counting those on <span class=\"math inline\">\\(KN\\)</span> and <span class=\"math inline\">\\(LP\\)</span> but not those on the axes). The number\r\non <span class=\"math inline\">\\(ST\\)</span>, the line <span class=\"math inline\">\\(x = s\\)</span>, is <span class=\"math inline\">\\([sq/p]\\)</span>, since <span class=\"math inline\">\\(sq/p\\)</span> is the ordinate of <span class=\"math inline\">\\(T\\)</span>. Hence the number in <span class=\"math inline\">\\(OKN\\)</span> is <span class=\"math display\">\\[\\sum_{s=1}^{p^{\\prime}}\\left[\\frac{sq}{p}\\right]\r\n= S(q,p)\\]</span> Similarly, the number in <span class=\"math inline\">\\(OLP\\)</span> is <span class=\"math inline\">\\(S(p,\r\nq)\\)</span>, and the conclusion follows.</p>\r\n<h2 id=\"the-proof-of-reciprocity-law\">The proof of Reciprocity Law</h2>\r\n<p>We can write <span class=\"math display\">\\[\\begin{equation}\r\n\\label{eq: summing}\r\nkq = p \\left[\\frac{kq}{p}\\right] + u_{k}\r\n\\end{equation}\\]</span> where <span class=\"math inline\">\\(1\\leq k \\leq\r\np^{\\prime}\\)</span>, <span class=\"math inline\">\\(1 \\leq u_{k} \\leq\r\np-1\\)</span>. Here <span class=\"math inline\">\\(u_k\\)</span> is the least\r\npositive residue of <span class=\"math inline\">\\(kq (\\bmod \\,\r\np)\\)</span>. If <span class=\"math inline\">\\(u_k = v_k\r\n\\leq  p^{\\prime}\\)</span>, then <span class=\"math inline\">\\(u_k\\)</span>\r\nis one of the minimal residues <span class=\"math inline\">\\(r_i\\)</span>,\r\nwhile if <span class=\"math inline\">\\(u_k = w_k &gt; p^{\\prime}\\)</span>,\r\nthen <span class=\"math inline\">\\(u_k - p\\)</span> is one of the minimal\r\nresidues <span class=\"math inline\">\\(-r^{\\prime}_{j}\\)</span>. Thus\r\n<span class=\"math display\">\\[r_i = v_k, \\quad r^{\\prime}_{j} = p -\r\nw_k\\]</span> for every <span class=\"math inline\">\\(i,j\\)</span> and some\r\n<span class=\"math inline\">\\(k\\)</span>.</p>\r\n<p>The <span class=\"math inline\">\\(r_i\\)</span> and <span class=\"math inline\">\\(r_j^{\\prime}\\)</span> are the numbers <span class=\"math inline\">\\(1,2,\\dots,p^{\\prime}\\)</span> in some order.\r\nHence, if <span class=\"math display\">\\[R = \\sum r_i = \\sum v_k, \\quad\r\nR^{\\prime} = \\sum r_{j}^{\\prime} = \\sum (p - w_k) = up - \\sum\r\nw_k\\]</span> (where <span class=\"math inline\">\\(\\mu\\)</span> is the\r\nnumber of <span class=\"math inline\">\\(r_j^{\\prime}\\)</span>), we have\r\n<span class=\"math display\">\\[R+R^{\\prime} = \\sum_{\\nu=1}^{p^{\\prime}}\r\n\\nu = \\frac{1}{2}\\frac{p-1}{2}\\frac{p+1}{2} = \\frac{p^2 -1}{8},\\]</span>\r\nand so <span class=\"math display\">\\[\\begin{equation}\r\n\\label{eq: From}\r\n\\mu p +\\sum v_k - \\sum w_k = \\frac{1}{8}(p^2-1)\r\n\\end{equation}\\]</span> On the other hand, summing <span class=\"math inline\">\\(\\eqref{eq: summing}\\)</span> from <span class=\"math inline\">\\(k=1\\)</span> to <span class=\"math inline\">\\(k=p^{\\prime}\\)</span>, we have <span class=\"math display\">\\[\\begin{equation}\r\n\\label{eq: and}\r\n\\frac{1}{8} q (p^2-1) = p S(q,p) + \\sum u_{k} = p S(q,p) + \\sum v_{k} +\r\n\\sum w_k.\r\n\\end{equation}\\]</span> From <span class=\"math inline\">\\(\\eqref{eq:\r\nFrom}\\)</span> and <span class=\"math inline\">\\(\\eqref{eq: and}\\)</span>\r\nwe deduce <span class=\"math display\">\\[\\begin{equation}\r\n\\label{eq: of}\r\n\\frac{1}{8} (p^2-1) (q-1) = pS(q,p) + 2\\sum w_k - \\mu p.\r\n\\end{equation}\\]</span> Now <span class=\"math inline\">\\(q-1\\)</span> is\r\neven, and <span class=\"math inline\">\\(p^2 -1 \\equiv 0 (\\bmod\r\n8)\\)</span>; so that the left-hand side of <span class=\"math inline\">\\(\\eqref{eq: of}\\)</span> is even, and also the\r\nsecond term on the right. Hence (since <span class=\"math inline\">\\(p\\)</span> is odd) <span class=\"math display\">\\[S(q,p) \\equiv \\mu (\\bmod 2),\\]</span> and\r\ntherefore, by Gauss's lemma, <span class=\"math display\">\\[\\left(\\frac\r\n{q}{p}\\right) = (-1)^{\\mu} = (-1)^{S(q,p)}.\\]</span> Finally, <span class=\"math display\">\\[\\left(\\frac {q}{p}\\right)\\left(\\frac\r\n{p}{q}\\right) = (-1)^{S(q,p) + S(p,q)} =\r\n(-1)^{p^{\\prime}q^{\\prime}}\\]</span> by preceding lemma.</p>\r\n<p>[1] Hardy G.H., Wright E.M. - An Introduction to the Theory of\r\nNumbers (1975)</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"quadratic-reciprocity-law\">Quadratic Reciprocity Law</h1>\r\n<h2 id=\"the-reciprocity-law-one\">The Reciprocity Law one</h2>\r\n<p>Let <span class=\"math inline\">\\(p\\)</span> and <span class=\"math inline\">\\(q\\)</span> be distinct odd prime numbers, and\r\ndefine the Legendre symbol as</p>\r\n<p><span class=\"math display\">\\[\\left({\\frac{q}{p}}\\right)=\r\n\\begin{cases}1&amp;{\\text{if }}n^{2}\\equiv q{\\mod {p}}{\\text{ for some\r\ninteger }}n\\\\\r\n-1&amp;{\\text{otherwise}}\r\n\\end{cases}\\]</span> Then</p>\r\n<p><span class=\"math display\">\\[\\left(\\frac\r\n{p}{q}\\right)\\left(\\frac{q}{p}\\right)=(-1)^{p^{\\prime}q^{\\prime}}.\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(p^{\\prime} = \\frac{p-1}{2}\\)</span>\r\nand <span class=\"math inline\">\\(q^{\\prime}=\\frac{q-1}{2}\\)</span>.</p>\r\n<p><img src=\"/2023/03/27/Quadratic%20Reciprocity%20Law/QRL.png\"></p>\r\n<p>Since <span class=\"math inline\">\\(p^{\\prime}q^{\\prime}\\)</span> is\r\neven if either <span class=\"math inline\">\\(p\\)</span> or <span class=\"math inline\">\\(q\\)</span> is of the form <span class=\"math inline\">\\(4n+1\\)</span>, and odd if both are of the form\r\n<span class=\"math inline\">\\(4n + 3\\)</span>, we can also state the\r\ntheorem as</p>\r\n<h2 id=\"the-reciprocity-law-two\">The Reciprocity Law two</h2>\r\n<p>If <span class=\"math inline\">\\(p\\)</span> and <span class=\"math inline\">\\(q\\)</span> are odd primes, then <span class=\"math display\">\\[\\left(\\frac {p}{q}\\right) =\r\n\\left(\\frac{q}{p}\\right)\\]</span> unless both <span class=\"math inline\">\\(p\\)</span> and <span class=\"math inline\">\\(q\\)</span> are of the forv <span class=\"math inline\">\\(4n+3\\)</span>, in which case <span class=\"math display\">\\[\\left(\\frac {p}{q}\\right) = -\r\n\\left(\\frac{q}{p}\\right)\\]</span></p>\r\n<h2 id=\"the-reciprocity-lemma\">The Reciprocity Lemma</h2>\r\n<p>If <span class=\"math display\">\\[S(q,p) =\r\n\\sum_{s=1}^{p^{\\prime}}\\left[\\frac{sq}{p}\\right],\\]</span> then <span class=\"math display\">\\[S(q,p) + S(p,q) =\r\np^{\\prime}q^{\\prime}.\\]</span></p>\r\n<p>The proof may be stated in a geometrical form. In the figure <span class=\"math inline\">\\(AC\\)</span> and <span class=\"math inline\">\\(BC\\)</span> are <span class=\"math inline\">\\(x =\r\np\\)</span>, <span class=\"math inline\">\\(y=q\\)</span>, and <span class=\"math inline\">\\(KM\\)</span> and <span class=\"math inline\">\\(LM\\)</span> are <span class=\"math inline\">\\(x =\r\np^{\\prime}\\)</span>, <span class=\"math inline\">\\(y =\r\nq^{\\prime}\\)</span>. If (as in the figure) <span class=\"math inline\">\\(p\r\n&gt; q\\)</span>, then <span class=\"math inline\">\\(q^{\\prime}/p^{\\prime}\r\n&lt; q/p\\)</span>, and <span class=\"math inline\">\\(M\\)</span> falls\r\nbelow the diagonal <span class=\"math inline\">\\(OC\\)</span>. Since <span class=\"math display\">\\[q^{\\prime} &lt; \\frac{qp^{\\prime}}{p} &lt;\r\nq^{\\prime}-l,\\]</span> there is no integer between <span class=\"math inline\">\\(KM = q^{\\prime}\\)</span> and <span class=\"math inline\">\\(KN = qp^{\\prime}/p\\)</span>.</p>\r\n<p>We count up, in two different ways, the number of lattice points in\r\nthe rectangle <span class=\"math inline\">\\(OKML\\)</span>, counting the\r\npoints on <span class=\"math inline\">\\(KM\\)</span> and <span class=\"math inline\">\\(LM\\)</span> but not those on the axes. In the\r\nfirst place, this number is plainly <span class=\"math inline\">\\(p^{\\prime}q^{\\prime}\\)</span>. But there are no\r\nlattice points on <span class=\"math inline\">\\(OC\\)</span> (since <span class=\"math inline\">\\(p\\)</span> and <span class=\"math inline\">\\(q\\)</span> are prime), and none in the triangle\r\n<span class=\"math inline\">\\(PMN\\)</span> except perhaps on <span class=\"math inline\">\\(PM\\)</span>. Hence the number of lattice points in\r\n<span class=\"math inline\">\\(OKML\\)</span> is the sum of those in the\r\ntriangles <span class=\"math inline\">\\(OKN\\)</span> and <span class=\"math inline\">\\(OLP\\)</span> (counting those on <span class=\"math inline\">\\(KN\\)</span> and <span class=\"math inline\">\\(LP\\)</span> but not those on the axes). The number\r\non <span class=\"math inline\">\\(ST\\)</span>, the line <span class=\"math inline\">\\(x = s\\)</span>, is <span class=\"math inline\">\\([sq/p]\\)</span>, since <span class=\"math inline\">\\(sq/p\\)</span> is the ordinate of <span class=\"math inline\">\\(T\\)</span>. Hence the number in <span class=\"math inline\">\\(OKN\\)</span> is <span class=\"math display\">\\[\\sum_{s=1}^{p^{\\prime}}\\left[\\frac{sq}{p}\\right]\r\n= S(q,p)\\]</span> Similarly, the number in <span class=\"math inline\">\\(OLP\\)</span> is <span class=\"math inline\">\\(S(p,\r\nq)\\)</span>, and the conclusion follows.</p>\r\n<h2 id=\"the-proof-of-reciprocity-law\">The proof of Reciprocity Law</h2>\r\n<p>We can write <span class=\"math display\">\\[\\begin{equation}\r\n\\label{eq: summing}\r\nkq = p \\left[\\frac{kq}{p}\\right] + u_{k}\r\n\\end{equation}\\]</span> where <span class=\"math inline\">\\(1\\leq k \\leq\r\np^{\\prime}\\)</span>, <span class=\"math inline\">\\(1 \\leq u_{k} \\leq\r\np-1\\)</span>. Here <span class=\"math inline\">\\(u_k\\)</span> is the least\r\npositive residue of <span class=\"math inline\">\\(kq (\\bmod \\,\r\np)\\)</span>. If <span class=\"math inline\">\\(u_k = v_k\r\n\\leq  p^{\\prime}\\)</span>, then <span class=\"math inline\">\\(u_k\\)</span>\r\nis one of the minimal residues <span class=\"math inline\">\\(r_i\\)</span>,\r\nwhile if <span class=\"math inline\">\\(u_k = w_k &gt; p^{\\prime}\\)</span>,\r\nthen <span class=\"math inline\">\\(u_k - p\\)</span> is one of the minimal\r\nresidues <span class=\"math inline\">\\(-r^{\\prime}_{j}\\)</span>. Thus\r\n<span class=\"math display\">\\[r_i = v_k, \\quad r^{\\prime}_{j} = p -\r\nw_k\\]</span> for every <span class=\"math inline\">\\(i,j\\)</span> and some\r\n<span class=\"math inline\">\\(k\\)</span>.</p>\r\n<p>The <span class=\"math inline\">\\(r_i\\)</span> and <span class=\"math inline\">\\(r_j^{\\prime}\\)</span> are the numbers <span class=\"math inline\">\\(1,2,\\dots,p^{\\prime}\\)</span> in some order.\r\nHence, if <span class=\"math display\">\\[R = \\sum r_i = \\sum v_k, \\quad\r\nR^{\\prime} = \\sum r_{j}^{\\prime} = \\sum (p - w_k) = up - \\sum\r\nw_k\\]</span> (where <span class=\"math inline\">\\(\\mu\\)</span> is the\r\nnumber of <span class=\"math inline\">\\(r_j^{\\prime}\\)</span>), we have\r\n<span class=\"math display\">\\[R+R^{\\prime} = \\sum_{\\nu=1}^{p^{\\prime}}\r\n\\nu = \\frac{1}{2}\\frac{p-1}{2}\\frac{p+1}{2} = \\frac{p^2 -1}{8},\\]</span>\r\nand so <span class=\"math display\">\\[\\begin{equation}\r\n\\label{eq: From}\r\n\\mu p +\\sum v_k - \\sum w_k = \\frac{1}{8}(p^2-1)\r\n\\end{equation}\\]</span> On the other hand, summing <span class=\"math inline\">\\(\\eqref{eq: summing}\\)</span> from <span class=\"math inline\">\\(k=1\\)</span> to <span class=\"math inline\">\\(k=p^{\\prime}\\)</span>, we have <span class=\"math display\">\\[\\begin{equation}\r\n\\label{eq: and}\r\n\\frac{1}{8} q (p^2-1) = p S(q,p) + \\sum u_{k} = p S(q,p) + \\sum v_{k} +\r\n\\sum w_k.\r\n\\end{equation}\\]</span> From <span class=\"math inline\">\\(\\eqref{eq:\r\nFrom}\\)</span> and <span class=\"math inline\">\\(\\eqref{eq: and}\\)</span>\r\nwe deduce <span class=\"math display\">\\[\\begin{equation}\r\n\\label{eq: of}\r\n\\frac{1}{8} (p^2-1) (q-1) = pS(q,p) + 2\\sum w_k - \\mu p.\r\n\\end{equation}\\]</span> Now <span class=\"math inline\">\\(q-1\\)</span> is\r\neven, and <span class=\"math inline\">\\(p^2 -1 \\equiv 0 (\\bmod\r\n8)\\)</span>; so that the left-hand side of <span class=\"math inline\">\\(\\eqref{eq: of}\\)</span> is even, and also the\r\nsecond term on the right. Hence (since <span class=\"math inline\">\\(p\\)</span> is odd) <span class=\"math display\">\\[S(q,p) \\equiv \\mu (\\bmod 2),\\]</span> and\r\ntherefore, by Gauss's lemma, <span class=\"math display\">\\[\\left(\\frac\r\n{q}{p}\\right) = (-1)^{\\mu} = (-1)^{S(q,p)}.\\]</span> Finally, <span class=\"math display\">\\[\\left(\\frac {q}{p}\\right)\\left(\\frac\r\n{p}{q}\\right) = (-1)^{S(q,p) + S(p,q)} =\r\n(-1)^{p^{\\prime}q^{\\prime}}\\]</span> by preceding lemma.</p>\r\n<p>[1] Hardy G.H., Wright E.M. - An Introduction to the Theory of\r\nNumbers (1975)</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":"/2023/03/27/Quadratic%20Reciprocity%20Law/QRL.png","popularPost_tmp_gaData":{"updated":"Fri Jan 03 2025 17:36:01 GMT+0800 (中国标准时间)","title":"Quadratic Reciprocity Law","path":"2023/03/27/Quadratic Reciprocity Law/","eyeCatchImage":"/2023/03/27/Quadratic%20Reciprocity%20Law/QRL.png","excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-03-27T10:42:10.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-03-27T10:42:10.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Algebraic Number Theory","tags":["Algebraic Number Theory"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"The Discovery of Neptune (By J.E. Littlewood)","date":"2023-04-04T12:02:28.000Z","mathjax":true,"_content":"\nNeptune was discovered in 1846 as a result of mathematical calculation, done independently and practically simultaneously by Adams and le Verrier. The full story abounds in unexpected twists, and is complicated by personal matters, some of them rather painful. There is a fascinating account in Professor W. M. Smart's ***John Couch Adams and the Discovery of Neptune***, published by the Royal Astronomical Society, 1947. I am concerned only with limited parts of the field.\n\nTo refresh the reader's memory of what has been said from time to time about the discovery I will begin with some representative quotations. In ***The Story of the Heavens*** (1886) Sir Robert Ball has passages:' the name of le Verrier rose to a pinnacle hardly surpassed in any age or country' ... 'profound meditations for many months' ... 'long tand arduous labour guided by consummate mathematical artifice'. The author is not above a bit of popular appeal in this book —— 'if the ellipse has not the perfect simplicity of the circle, it has at least the charm of variety ... an outline of perfect grace, and an association with ennobling conceptions' —— but on Neptune he is speaking as a professional. An excellent modern book on the history of astronomy has, so late as 1938:' probably the most daring mathematical enterprise of the century ... this amazing task, like which nothing had ever been attempted before'.\n\nThe immediate reaction was natural enough. Celestial Mechanics in general, and the theory of perturbations in particular, had developed into a very elaborate and high-brow subject; the problem of explaining the misbehaviour of Uranus by a new planet was one of 'inverse' theory, and the common feeling was that the problem was difficult up to or beyond the point of impossibility. One might speculate\nat some length on reasons for this opinion (one, perhaps was confusion between different meanings of the technica term 'insoluble'[^1]). When Adams and le Verrier provec the opinion wrong (and after all ***any*** mathematical proof is\na debunking of sorts) there was still something to be said for the principle that difficulties are what they seem before the event, not after. Certainly no one would grudge them their resounding fame. (Nor grudge, at a lower level, the luck of a discovery which makes a more sensational impact than its actual difficulty strictly merits; in point of fact this luck never does happen to the second-rate.)\nIf the discovery has had a very long run one must remember that there is a time-lag\n; people cannot be always reconsidering opinions, and having said something once even the most intelligent tend to go on repeating it. The phrase was still in vogue that 'only 3 people understand Relativity' at a time when Eddington was complaining that the trouble about Relativity as an examination subject in 'Part III' was that it was such a soft option.\n\nIn what I am going to say I am far from imputing stupidity to people certainly less stupid than myself. My little ***jeuz d'esprit*** are not going to hurt anyone, and I refuse to be deterred by the fear of being thought disrespectful to\ngreat men. I have not been alone in a lurking suspicion that a much simpler approach might succeed. On the one hand, aim at the minimum needed to make observational discovery practicable; specifically at the time $t_{0}$ of conjunction.[^2] On the other, forget the high-brow and laborious perturbation\ntheory, and try 'school mathematics'. (I admit to the human weakness of being spurred on by the mild piquancy success would have.) To begin with I found things oddly elusive (and incidentally committed some gross stupidities). In the end an absurdly simple line emerged: I can imagine its being called a dirty trick, nor would I deny that there is some truth in the accusation. The only way to make my\ncase is to carry out the actual 'prediction' of $t_{0}$ from the observational data, with all the cards on the table (so that anyone can check against unconscious\nor conscious faking). I will also write so as to take as many amateurs as\npossible with me on the little adventure.\n\n[^1]: Its attachment to the '3-body problem' misleads people to-day.\n\n[^2]: The time at which NUS is a straight line (I shall use the abbreviations S, U, N).\n\n\nA planetary 'orbit' is an ellipse with the Sun $S$ at a focus, and the radius vector $SP$ sweeps out area at a constant rate (Kepler's second law). An orbit, given its plane, is defined by 4 elements, $a$, $e$, $\\alpha$, $\\epsilon$.\nThe first 3 define the geometrical ellipse: $a$ is the semi-major axis; $e$ the eccentricity; $\\alpha$ the longitude of perihelion, i.e. with the obvious polar coordinates $r, \\theta$, $\\theta$ is the 'longitude' and $\\theta=a$ when $P$ is\nnearest $S$ (at an end of the major axis). When we know $a$ we know the 'mean angular velocity' $n$ and the associated period $p= 2 \\pi/n$; $n$ is in fact proportional to $a^{-\\frac{1}{2}}$ (Kepler's third law)[^1(2)]; further the constant rate of area sweeping is $\\frac{1}{2}abn$[^2(2)] and twice this rate is identical with the angular momentum'[^3(2)] (a.m. for short); this has the differential\ncalculus formula $r^{2}\\theta$, and it also is of course constant. The 4th element, the 'epoch' $e$, is needed to identify the origin of $t$; the exact definition is that $\\theta= \\alpha$ (perihelion) occurs at the $t$ for which $nt+ \\epsilon = \\alpha$.\n\n\n[^1(2)]: It does not depend on $e$.\n\n[^2(2)]: The total area of the ellipse is $\\pi ab$, and it is swept out in time $p$.\n\n[^3(2)]: Strictly speaking the a.m. should have the planet's mass as a factor: but $U$'s mass is irrelevant and I omit it throughout.\n\n$U$'s orbit has a period of 84 years, and an eccentricity $e$ of about $\\frac{1}{20}$. The effects of bodies other than $S$ and $N$ can be allowed for, after which we may suppose that $U$, $S$, and the eventual $N$ are the only bodies in the system; we may also suppose (all this is common form) that the movements are all in one plane. The values of $\\theta$ (for $U$) at the various times $t$ (we sometimes write $\\theta(t)$ to emphasize that $\\theta$ is 'at time $t$') may be regarded as the observational raw material (though of course the actual raw observations are made from the Earth). The $r$'s for the various $t$ are indirect and are much less well determined.\n\n\n\nThe position in 1845 was that no exact elliptic orbit would fit the observed 6 over the whole stretch 1780 to 1840.[^1(3)] The discrepancies are very small, mostly a few seconds of arc (with a sudden swoop of about 90\",see Tablel). The ratio $m$ of $N$'s mass to that of $S$ (taken as 1) is actually about 1/19000\n(the Orders of magnitude fit since m radians is about 11\").\n\n[^1(3)]: Observations after 1840 were not immediately available, and anyhow\nwere not used. Uranus was discovered in 1781. Lest the reader should be worried by small inconsistencies in my dates I mention that 1780 is 'used', the extrapolation being a safe one.\n\nIn the absence of $N$ the a.m. $A$ is constant (as stated above alias of Kepler's second law); ***the actual $N$ accelerates $A$ at times earlier than $t_{0}$ and decelerates it at later times***. The graph of $A$ against $t$ therefore rises to a maximum at $t=t_{0}$, and my first idea was that this would identify. So it would if all observations were without error (and the method would have the theoretical advantage of being unaffected by the eccentricities). But the value of $A$ at time $t$ depends on the $r$ at time $t$, and the determinations of the $A$'s are consequently too uncertain. Though the method fails it rises from the ashes in another form. For this a few more preliminaries are needed.\n\n\nThe numerical data Adams and le Verrier had to work on were not the observed\n$\\theta$'s themselves, but the differences between the observed $\\theta(t)$ and the $\\theta_{B}(t)$ of an elliptic orbit calculated by Bouvard; the 'discrepancy' $\\delta(t)$ ($\\delta$ for short) is $\\delta(t)=\\theta(t)-\\theta_{B}(t)$. [$\\theta_{B} (t)$ depends on the 'elements' of $E_{B}$, and these are subject to 'errors'. These errors are among the unknowns that the perturbation theory has to determine: our method does not mind what they are, as we shall see.] Table I gives the raw $S$'s (given in Adams's paper[^2(3)]), together with the values got by running\na smooth curve. The treatment of the start of the sudden swoop down after the long flat stretch is a bit uncertain: I drew my curve and stuck to it (but faking would make no ultimate difference). The differences show up the order of the observational errors (which naturally improve with the years something seems to have gone badly wrong in 1789); these are absolute, not relative (thus the probable\nabsolute error in $\\delta_{1} - \\delta_{2}$ is the same whether $\\delta_{1} - \\delta_{2}$ is 0.5\" or 90\"). It is worth while to work to 0.1\" and to the number\nof decimal places used in what follows, even though the last place is doubtful.\n\n[^2(3)]: ***Collected Works, I***, p. 11. These (and not the modifications he\nintroduces, which are what appear in Smart) are what is relevant for us.\n\n\n\n| Year | Observed $\\delta$ | Smooth Curve | Year | Observed $\\delta$ | Smooth Curve |\n| :---: | :-------------: | :------------: | :---: | :------------: | :--------------: |\n| 1780 | 3.5 | 3.5 | 1813 | 22.0 | 22.8 |\n| 1783 | 8.5 | 8.5 | 1816 | 22.9 | 22.5 |\n| 1786 | 12.4 | 12.5 | 1819 | 20.7 | 22.0 |\n| 1789 | 19.0 | 15.8 | 1822 | 21.0 | 21.0 |\n| 1792 | 18.7 | 18.3 | 1825 | 18.2 | 18.1 |\n| 1795 | 21.4 | 20.3 | 1828 | 10.8 | 10.3 |\n| 1798 | 21.0 | 21.6 | 1831 | -4.0 | -4.0 |\n| 1801 | 22.2 | 22.4 | 1834 | -20.8 | -20.8 |\n| 1804 | 24.2 | 22.8 | 1837 | -42.7 | -42.5 |\n| 1807 | 22.1 | 23.0 | 1840 | -66.6 | -66.6 |\n| 1810 | 23.2 | 23.0 | 1843(e) | $-$ | -94.0 |\n\nTable 1\n\nThe value for 1843 is an extrapolation; results derived from it are labelled '(e)'.\n\nAn 'effect' due to $N$ is of 'order $m$ in mathematical notation $O(m)$; if, for a particular quantity $X$, \\Delta X$ denotes (calculated $X$) —— (observed $X$), then any $\\Delta X$ is $O(m)$. The square of this (2nd order of infinitesimals) is\nextremely minute and everyone neglects it instinctively (if $a$ watch loses 10 seconds a day you don't try to correct for the further loss over the lost 10 seconds the cases are comparable). Next, an effect of $N$ is what it would be if $U$, and also $N$, moved in circles, ***plus*** a 'correction' for the actual eccentricities of the orbits. $U$'s eccentricity $e(\\frac{1}{20})$ is unusually large and it would be reasonable to expect $N$'s to be no larger (it is actually less than $\\frac{1}{100}$). The $e$'s distort the 'circular' value of the effect by 5 per cent, (or say a maximum of 10 per cent.); the 'distortion' of the effect\nis $O(em)$, the effect itself being $O(m)$. I propose to ignore things of order $O(em)$[^1(4)]: this is the first step in my argument. In particular, when we have something which is either some $\\Delta$, or $m$ itself, multiplied by a factor, we can substitute first approximations (i.e. with $e=0$), or make convenient changes that are $O(e)$, in the factor.\n\n\n[^1(4)]: I should stress that there is no question of ignoring even high powers\nof $e$ ***unaccompanied by a factor $m$*** ($e^{4}$ radians is about 1\"). The distortion in the value found for $t$ is, however, a sort of exception to\nthis. But the effect of $e$'s in distorting $t_{0}$ is unlikely to be worse than the separation they create between time of conjunction and time of closest approach. An easy calculation shows that this last time difference\nis at worst 0-8 years.\n\n\nSuppose now that $E_{l}, E_{2}$ are two (exact) elliptic orbits, yielding\n$\\theta(t)$'s that differ by amounts of the kind we are concerned with, differing, that is, by $O(m)$.[^2(4)] It is now the case that the differences satisfy the equation\n\n$$\\begin{equation}\n\\theta_{1} - \\theta_{2} = m( a + bt + c \\cos nt + d \\sin nt) + O(em)\n\\end{equation}$$\n\nwhere $a, b, c, d$ are constants depending on the two sets of elements of $E_{1}, E_{2}$, and (following our agreement about ***factors*** of $m$) $n$ is any common approximation to the mean angular velocity. I will postpone the school mathentatics\nproof of this.\n\n\n[^2(4)]: The orbits may have 'Suns' of masses differing by $O(m)$.\n\nNext, (i) let $E^{*}$ be the 'instantaneous orbit at time $t_{0}$', that is to say the orbit that $U$ would describe if $N$ were annihilated at time $t_{0}$: note that $E^{*}$ shares with $t_{0}$ the property of being 'unknown'. (ii) Let $\\vartheta$ be the perturbation of the $\\theta$ of $U$ produced by $N$ since time\n$t_{0}$.[^3(4)] Then if, at any time $t$, $\\theta$ is (as usual) $U$'s longitude, $\\theta_{B}$ is the longitude in the orbit $E_{B}$, and $\\theta^{*}$ the longitude in the orbit $E^{*}$, we have $\\vartheta = \\theta - \\theta^{*}$, and so\n\n$$\\begin{equation}\n\\delta(t) = \\theta - \\theta_{B} = (\\theta^{*} - \\theta_{B}) + \\vartheta\n\\end{equation}$$\n\nNow everything in this has a factor $m$, and we may omit any stray $O(em)$'s.\nIn particular, we may in calculating $\\vartheta$ drop any $e$ terms. But this means that ***we can calculate $\\vartheta$ as if both $U$'s and $N$'s orbits were circles***. When, however, the orbits are circles, ***$\\vartheta$ has equal and opposite values at $t$'s on equal and opposite sides of $t_{0}$***; in other words, ***if we write $t=t_{0} + \\tau$, then***\n\n$$\\begin{equation}\n\\vartheta(t) = \\Omega (\\tau)\n\\end{equation}$$\n\n***where $\\Omega (\\tau)$ is an odd[^1(5)] function of $\\tau$; i.e. $\\Omega(-\\tau)= -\\Omega(\\tau)$.***\n\n\n\n[^3(4)]: We allow, of course, ***negative*** values of $t - t_{0}$ both in $E^{*}$ and in $\\vartheta$.\n\n[^1(5)]: '$\\Omega$' is a deputy for '$O$' (initial of 'odd'), which is otherwise engaged. The italicized statement in the text is true 'by symmetry': alternatively, ***reverse*** the motions from time $t_{0}$. (The argument covers also the 'perturbation of 'the Sun' which is not so completely negligible as\nmight be supposed.)\n\n\nThis, used in combination with (1) and (2), is the essential (and very simple) point of the argument. The difference $\\theta^{*} - \\theta_{B}$ is a special case of $\\theta_{1} - \\theta_{2}$ in (1). Write $t=t_{0} + \\tau$ in (1) and combine this with (2) and (3); this gives, ignoring $O(em)$'s,\n\n$$\\delta(t_{0} + \\tau) = m \\left\\{a + b t_{0} + b \\tau + c \\cos (nt_{0} + n \\tau) + d \\sin (nt_{0} + n \\tau) \\right\\} + \\Omega(\\tau)$$\n\nExpanding the $\\cos$ and $\\sin$ of sums and rearranging we have (with new constants, whose values vary with but do not concern us)\n\n$$\\delta(t_{0} + \\tau) = A - B(1 - \\cos n\\tau) + \\left\\{C \\tau + D \\sin n\\tau + \\Omega(\\tau)\\right\\}$$\n\n***The curly bracket is an odd function of $\\tau$***. Hence if we combine\nequal and opposite $\\tau$ and construct $\\delta^{*}(\\tau)$ and $\\rho(\\tau)$ to satisfy\n\n$$\\delta^{*}(\\tau) = - \\frac{1}{2} \\left\\{\\delta(t_{0}+\\tau) + \\delta(t_{0}- \\tau) - 2 \\delta(t_{0}) \\right\\}, \\rho(\\tau) = \\delta^{*}(\\tau)/(1-\\cos n\\tau)$$\n\nwe have $\\delta^{*}(\\tau)=B( 1 - \\cos n\\tau)$, and so $\\rho(\\tau)=B $ for all $\\tau$. ***If, then, we are using the right $t_{0}$ the ratio p(r) must come out constant***: this is our method for identifying $t_{0}$. The actual value of $t_{0}$ to the nearest year is 1822.\n\nTable II, in which the unit of time is 1 year (and the $n$ of $\\cos n\\tau$ is $2\\pi/84$), shows the results of trying various (the century is omitted from the dates). The last place of decimals for the $\\rho(\\tau)$ is not reliable, but of course gets better as the size of the entry $2\\delta^{*}(\\tau)$ increases: I give the numbers as they came, and they speak for themselves. $\\tau=6$ is included, though the proportionate error in $\\delta^{*}$ is then considerable.[^1(6)] For\n$t_{0}=13$ $\\rho$ goes on to 34.8 at $\\tau=27$; for $t_{0}=16$ it goes to 38.2 at $\\tau= 24$. Once the data the smooth curve values were assembled the calculations took a mere hour or so with a slide-rule. The date 1822-4 seems about the 'best' $t_{0}$.\n\n[^1(6)]: And the, values for $\\tau=6$ at $t_{0}=22, 22.4$ are more uncertain than usual because of a crisis in the smooth curve.\n\n<style>\n    body {text-align: center;} table{margin: auto;}\n</style>\n\n<table>\n    <tr>\n        <td> </td>\n        <td colspan=\"2\"> $t_{0} = 13$ </td>\n        <td colspan=\"2\"> $t_{0} = 16$ </td>\n        <td colspan=\"2\"> $t_{0} = 19$ </td>\n        <td colspan=\"2\"> $t_{0} = 22$ </td>\n        <td colspan=\"2\"> $t_{0} = 22.4$ </td>\n        <td colspan=\"2\"> $t_{0} = 25$ </td>\n        <td colspan=\"2\"> $t_{0} = 28$ </td>\n    </tr>\n    <tr>\n        <td> $\\tau$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n    </tr>\n    <tr>\n        <td> 6 </td>\n        <td> 0.6 </td>\n        <td> 3.0 </td>\n        <td> 1.0 </td>\n        <td> 5.1 </td>\n        <td> 3.6 </td>\n        <td> 18.3 </td>\n        <td> 9.2 </td>\n        <td> 47.0 </td>\n        <td> 10.6 </td>\n        <td> 53.8 </td>\n        <td> 18.2 </td>\n        <td> 92.5 </td>\n        <td> 20.4 </td>\n        <td> 103 </td>\n    </tr>\n    <tr>\n        <td> 9 </td>\n        <td> 1.8 </td>\n        <td> 4.1 </td>\n        <td> 3.9 </td>\n        <td> 9.0 </td>\n        <td> 10.7 </td>\n        <td> 24.6 </td>\n        <td> 23.2 </td>\n        <td> 53.3 </td>\n        <td> 25.0 </td>\n        <td> 57.6 </td>\n        <td> 34.5 </td>\n        <td> 79.3 </td>\n        <td> 41.1 </td>\n        <td> 94 </td>\n    </tr>\n    <tr>\n        <td> 12 </td>\n        <td> 5.3 </td>\n        <td> 7.6 </td>\n        <td> 11.9 </td>\n        <td> 15.8 </td>\n        <td> 25.0 </td>\n        <td> 33.2 </td>\n        <td> 39.8 </td>\n        <td> 53.0 </td>\n        <td> 42.2 </td>\n        <td> 56.1 </td>\n        <td> 55.9 </td>\n        <td> 74.4 </td>\n        <td> 64.7 </td>\n        <td> 86 </td>\n    </tr>\n    <tr>\n        <td> 15 </td>\n        <td> 13.7 </td>\n        <td> 12.1 </td>\n        <td> 26.6 </td>\n        <td> 23.5 </td>\n        <td> 42.0 </td>\n        <td> 37.1 </td>\n        <td> 61.5 </td>\n        <td> 54.4 </td>\n        <td> 64.0 </td>\n        <td> 56.5 </td>\n        <td> 79.8 </td>\n        <td> 70.5 </td>\n        <td> 91(e) </td>\n        <td> 80.6(e) </td>\n    </tr>\n    <tr>\n        <td> 18 </td>\n        <td> 29.3 </td>\n        <td> 18.8 </td>\n        <td> 44.2 </td>\n        <td> 28.4 </td>\n        <td> 64.1 </td>\n        <td> 41.2 </td>\n        <td> 85.8 </td>\n        <td> 55.2 </td>\n        <td> 88.6 </td>\n        <td> 57.0 </td>\n        <td> 106(e) </td>\n        <td> 86.3(e) </td>\n        <td> $-$ </td>\n        <td> $-$ </td>\n    </tr>\n    <tr>\n        <td> 21 </td>\n        <td> 48.3 </td>\n        <td> 24.1 </td>\n        <td> 67.2 </td>\n        <td> 36.6 </td>\n        <td> 89.0 </td>\n        <td> 45.5 </td>\n        <td> 113(e) </td>\n        <td> 56.5(e) </td>\n        <td> 116(e) </td>\n        <td> 58.0(e) </td>\n        <td> $-$ </td>\n        <td> $-$ </td>\n        <td> $-$ </td>\n        <td> $-$ </td>\n    </tr>\n    <caption> Table II </caption>\n</table>\n\nWe need fairly large $\\tau$ for $\\delta^{*}(\\tau)$ to have enough ignificant figures, and further to provide a range showing up whether\n$\\rho(\\tau)$ is constant or not. And we need room to manoeuvre round the final. So the method depends on the 'luck' that 1822 falls comfortably inside the period of observation 1780-1840. But some luck was needed in any case.\n\n\nIt is an important point that the method is quite indifferent to how well $E_{B}$ does its originally intended job, and ***we do not need to know (and I don't knoiv) its elements***; it is enough to know the 'discrepancy' with ***some***, 'unknown', orbit (not too bad of course). On the other hand the method ostentatiously says nothing at all about the mass or distance of $N$. I will add something on this. With $e$-terms ignored $\\vartheta(\\tau)/m$ can be calculated ***exactly*** for any given value of $\\lambda=a/a_{1}$ (ratio of the $a$'s of $U$ and $N$)[^2(6)] The idea would be to try different $A$'s, each $A$ to give a best fitting $m$, and to take the best fitting ***pair*** $\\lambda, m$. This fails, because the greater part of $\\vartheta$ is of the form $b^{\\prime}(n\\tau - \\sin n\\tau)$, and $b^{\\prime}$ is smothered by the $a, b, c, d$ of $\\theta^{*} - \\theta_{B}$, which depend on the unknown elements of $E_{B}$ ($\\vartheta$ is smothered by the 'unknown' $\\theta^{*} - \\theta_{B}$). If we knew these elements (or equivalently the raw $\\theta$) we might be able to go on. They could be recovered from the Paris Observatory archives; but\nthis article is a last moment addition to the book, I do not feel that I am on full professional duty, and in any case we should be losing the\nlight-hearted note of our adventure.\n\n\n\n[^2(6)]: From two second order differential equations. The formula involves 'quadratures', but in numerical calculation integration\nis quicker than multiplication. It would be comparatively easy to make a double entry table for $\\vartheta(\\tau, \\lambda)/m$\n\n\n\n\nThe time $t$ once known, it would be necessary to guess a value for $N$'s distance $a_{1}$; $N$'s period is then $84(a_{1}/a)^{\\frac{3}{2}}$ years, and we could 'predict' $N$'s place in 1846. The obvious first guess in 1846 was $a_{l}/a=2$, following Bode's empirical law, to which N is maliciously the first exception, the true value being\n1.58. Adams and le Verrier started with 2 (Adams coming down to 1.942 for a second round). Since from our standpoint[^1(7)] too large an\n$a_{1}$ has disproportionately bad results as against one too small,\nit would be reasonable to try 1.8. This would give a prediction (for 1846) about 10$^{\\circ}$ out, but the sweep needed would be wholly practicable.\n\n\n[^1(7)]: Perturbation theory calculations have necessarily to ***begin*** by guessing $a_{1}$; our guess need only be at the end.\n\n\nLe Verrier was less than 1$^{\\circ}$ out (Adams between 2$^{\\circ}$ and 3$^{\\circ}$); 'they pointed the telescope and saw the planet'.\nThis very close, and double, prediction is a curiosity. All the observations from 1780 to 1840 were used, and on an equal footing, and the theory purported to say where $N$ was over this whole stretch.\nWith a wrong $a_{1}$ they could be right at 1840 only by being wrong at 1780. With Adams's $a_{1}=1.94a$ $N$'s period (which depends on $a_{1}$ only) would be 227 years; he would have been wrong by 30$^{\\circ}$\nfor 1780 if the orbit were circular, and so the angular velocity uniform. But faced with a wrong $a_{1}$ the method responded gallantly\nby putting up a large eccentricity ($\\frac{1}{8}$), and assigning perihelion to the place of conjunction. The combination makes the effective distance from $S$ over the critical stretch more like\n$1.7 a_{l}$, and the resulting error at 1780 (the worst one) was only 18. (A mass 2.8 times too large was a more obvious adjustment.)\n\n\nIn much more recent times small discrepancies for $N$ and $U$ ($U$'s being in fact the more manageable ones) were analysed for a trans-Neptunian planet, and the planet Pluto was found in 1930 near the predicted place. This was a complete fluke: Pluto has a mass probably no more than $\\frac{1}{10}$ of the Earth's; any effects\nit could have on $N$ and $U$ would be hopelessly swamped by the observational errors.\n\nIt remains for me to give the (school mathematics) proof of (1) above.\nCall $e_{1} - e_{2}$ $\\Delta e$, and so on. I said above that all $\\Delta$'s were $O(m)$: this is not quite true, though my deception has been in the reader's best interests, and will not have led him astray.[^1(8)] It is true, and common sense, for $\\Delta a$, $\\Delta e$, $\\Delta n$, and $\\Delta \\epsilon$. But the 'effect' of a given Aa vanishes when $e=0$, and is proportional to $e$. So it is $e\\Delta \\alpha$, not $\\Delta \\alpha$, that is comparable with the other $\\Delta$'s and so $O(m)$.[^2(8)]\n\n\n\n[^1(8)]: 'Wen Gott betrugt is wohl betrogon.'\n\n[^2(8)]: This twist makes the 'obvious' approach of using the\nweil known expansion\n$$\\theta = nt +\\epsilon + 2e \\sin (nt + \\epsilon -a) + \\frac{5}{4}e^{2} \\sin 2 (nt + \\epsilon -a ) + \\cdots$$\nslightly tricky; we should have to keep the term in $e^{2}$. The line taken in the text side-steps this.\n\n\n\n\n\nWe start from two well-known formulae. The first is geometrical; the polar equation of the ellipse of the orbit is\n\n$$\\begin{equation}\nr = a(1- e^{2}) ( 1 +e \\cos (\\theta -a))^{-1}\n\\end{equation}$$\n\n\n\nThe second is dynamical; the equation of angular momentum (Kepler's second law) is\n\n$$\\begin{equation}r^{2} \\frac{d\\theta}{dt} = na^{2} (1-e^{2})^{\\frac{1}{2}}\\end{equation}$$\n\n\n\nSo, using dots for time differentiations,\n\n\n$$\\begin{equation}\n\\theta = n(1-e^{2})^{-\\frac{3}{2}} [1 - 2\\cos (\\theta -a) + 3e^{2} \\cos^{2} (\\theta -a ) + \\cdots]\n\\end{equation}$$\n\n\nThe first approximation (with $e=0$) is $\\theta=nt + \\epsilon$. We take\nsuffixes 1 and 2 in (6) and operate with $\\Delta$, remembering that we may take first approximations in any ***factor*** of an $m$.\n\n\nIn estimating $\\Delta\\theta$ we may, with error $O(em)$, ignore the\nfactor $(1-e^{2})^{-\\frac{3}{2}}$ in (6), since it is itself $\\left(1+O(e^{2})\\right)$, and its $\\Delta$ is $O(e\\Delta e)=O(em)$. We have, therefore, with error $O(em)$,\n\n$$\\Delta \\theta = \\Delta \\left\\{n[\\quad ]\\right\\} = [\\quad ] \\Delta n + n \\Delta [\\quad ]$$\n\nThe 1st term is $\\Delta n+O(em)$. The 2nd is\n\n$$n\\left[\\Delta e \\left\\{- 2 \\cos(\\theta -a ) + O(e)\\right\\} + \\Delta (\\theta -a ) \\left\\{2e \\sin (\\theta -a ) + O(e^{2}\\right\\}\\right]$$\n\nand we may drop the $\\theta$ in $\\Delta (\\theta - a)$ on account of the factor $O(\\epsilon)$. Summing up, we obtain\n\n$$\\Delta \\theta = m (A+B \\cos (\\theta -a ) + C \\sin (\\theta -a ) ) + O(em)$$\n\nwhere $mA=\\Delta n$, $mB = -2n\\Delta e$, $mC = -2n(e\\Delta a)$. Substituting the first approximation $\\theta=nt + \\epsilon$ in the right hand side, we have\n\n$$\\Delta \\theta = m (A+B \\cos (nt + \\epsilon -a ) + C \\sin (nt + \\epsilon -a ) ) + O(em)$$\n\n\nand integration then gives\n\n\n\n$$\\Delta \\theta = m (A+B/n \\sin (nt + \\epsilon -a ) - C/n \\cos (nt + \\epsilon -a ) ) + O(em)$$\n\n\n\nwhich, after expanding the sin and cos and rearranging, is of the desired form (I).[^1(9)]\n\n\n\n[^1(9)]: We have treated $\\Delta n$ and $\\Delta a$ as independent (the latter happens not to occur in the final formula for $\\Delta \\theta$): this amounts to allowing different masses to the two 'Suns'. The point is relevant to certain subtleties, into which I will not enter.\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/The Discovery of Neptune.md","raw":"---\ntitle: The Discovery of Neptune (By J.E. Littlewood)\ndate: 2023-04-04 20:02:28\ntags:\n    - [Miscellanies]\ncategories: \n    - [Miscellanies]\nmathjax: true\n---\n\nNeptune was discovered in 1846 as a result of mathematical calculation, done independently and practically simultaneously by Adams and le Verrier. The full story abounds in unexpected twists, and is complicated by personal matters, some of them rather painful. There is a fascinating account in Professor W. M. Smart's ***John Couch Adams and the Discovery of Neptune***, published by the Royal Astronomical Society, 1947. I am concerned only with limited parts of the field.\n\nTo refresh the reader's memory of what has been said from time to time about the discovery I will begin with some representative quotations. In ***The Story of the Heavens*** (1886) Sir Robert Ball has passages:' the name of le Verrier rose to a pinnacle hardly surpassed in any age or country' ... 'profound meditations for many months' ... 'long tand arduous labour guided by consummate mathematical artifice'. The author is not above a bit of popular appeal in this book —— 'if the ellipse has not the perfect simplicity of the circle, it has at least the charm of variety ... an outline of perfect grace, and an association with ennobling conceptions' —— but on Neptune he is speaking as a professional. An excellent modern book on the history of astronomy has, so late as 1938:' probably the most daring mathematical enterprise of the century ... this amazing task, like which nothing had ever been attempted before'.\n\nThe immediate reaction was natural enough. Celestial Mechanics in general, and the theory of perturbations in particular, had developed into a very elaborate and high-brow subject; the problem of explaining the misbehaviour of Uranus by a new planet was one of 'inverse' theory, and the common feeling was that the problem was difficult up to or beyond the point of impossibility. One might speculate\nat some length on reasons for this opinion (one, perhaps was confusion between different meanings of the technica term 'insoluble'[^1]). When Adams and le Verrier provec the opinion wrong (and after all ***any*** mathematical proof is\na debunking of sorts) there was still something to be said for the principle that difficulties are what they seem before the event, not after. Certainly no one would grudge them their resounding fame. (Nor grudge, at a lower level, the luck of a discovery which makes a more sensational impact than its actual difficulty strictly merits; in point of fact this luck never does happen to the second-rate.)\nIf the discovery has had a very long run one must remember that there is a time-lag\n; people cannot be always reconsidering opinions, and having said something once even the most intelligent tend to go on repeating it. The phrase was still in vogue that 'only 3 people understand Relativity' at a time when Eddington was complaining that the trouble about Relativity as an examination subject in 'Part III' was that it was such a soft option.\n\nIn what I am going to say I am far from imputing stupidity to people certainly less stupid than myself. My little ***jeuz d'esprit*** are not going to hurt anyone, and I refuse to be deterred by the fear of being thought disrespectful to\ngreat men. I have not been alone in a lurking suspicion that a much simpler approach might succeed. On the one hand, aim at the minimum needed to make observational discovery practicable; specifically at the time $t_{0}$ of conjunction.[^2] On the other, forget the high-brow and laborious perturbation\ntheory, and try 'school mathematics'. (I admit to the human weakness of being spurred on by the mild piquancy success would have.) To begin with I found things oddly elusive (and incidentally committed some gross stupidities). In the end an absurdly simple line emerged: I can imagine its being called a dirty trick, nor would I deny that there is some truth in the accusation. The only way to make my\ncase is to carry out the actual 'prediction' of $t_{0}$ from the observational data, with all the cards on the table (so that anyone can check against unconscious\nor conscious faking). I will also write so as to take as many amateurs as\npossible with me on the little adventure.\n\n[^1]: Its attachment to the '3-body problem' misleads people to-day.\n\n[^2]: The time at which NUS is a straight line (I shall use the abbreviations S, U, N).\n\n\nA planetary 'orbit' is an ellipse with the Sun $S$ at a focus, and the radius vector $SP$ sweeps out area at a constant rate (Kepler's second law). An orbit, given its plane, is defined by 4 elements, $a$, $e$, $\\alpha$, $\\epsilon$.\nThe first 3 define the geometrical ellipse: $a$ is the semi-major axis; $e$ the eccentricity; $\\alpha$ the longitude of perihelion, i.e. with the obvious polar coordinates $r, \\theta$, $\\theta$ is the 'longitude' and $\\theta=a$ when $P$ is\nnearest $S$ (at an end of the major axis). When we know $a$ we know the 'mean angular velocity' $n$ and the associated period $p= 2 \\pi/n$; $n$ is in fact proportional to $a^{-\\frac{1}{2}}$ (Kepler's third law)[^1(2)]; further the constant rate of area sweeping is $\\frac{1}{2}abn$[^2(2)] and twice this rate is identical with the angular momentum'[^3(2)] (a.m. for short); this has the differential\ncalculus formula $r^{2}\\theta$, and it also is of course constant. The 4th element, the 'epoch' $e$, is needed to identify the origin of $t$; the exact definition is that $\\theta= \\alpha$ (perihelion) occurs at the $t$ for which $nt+ \\epsilon = \\alpha$.\n\n\n[^1(2)]: It does not depend on $e$.\n\n[^2(2)]: The total area of the ellipse is $\\pi ab$, and it is swept out in time $p$.\n\n[^3(2)]: Strictly speaking the a.m. should have the planet's mass as a factor: but $U$'s mass is irrelevant and I omit it throughout.\n\n$U$'s orbit has a period of 84 years, and an eccentricity $e$ of about $\\frac{1}{20}$. The effects of bodies other than $S$ and $N$ can be allowed for, after which we may suppose that $U$, $S$, and the eventual $N$ are the only bodies in the system; we may also suppose (all this is common form) that the movements are all in one plane. The values of $\\theta$ (for $U$) at the various times $t$ (we sometimes write $\\theta(t)$ to emphasize that $\\theta$ is 'at time $t$') may be regarded as the observational raw material (though of course the actual raw observations are made from the Earth). The $r$'s for the various $t$ are indirect and are much less well determined.\n\n\n\nThe position in 1845 was that no exact elliptic orbit would fit the observed 6 over the whole stretch 1780 to 1840.[^1(3)] The discrepancies are very small, mostly a few seconds of arc (with a sudden swoop of about 90\",see Tablel). The ratio $m$ of $N$'s mass to that of $S$ (taken as 1) is actually about 1/19000\n(the Orders of magnitude fit since m radians is about 11\").\n\n[^1(3)]: Observations after 1840 were not immediately available, and anyhow\nwere not used. Uranus was discovered in 1781. Lest the reader should be worried by small inconsistencies in my dates I mention that 1780 is 'used', the extrapolation being a safe one.\n\nIn the absence of $N$ the a.m. $A$ is constant (as stated above alias of Kepler's second law); ***the actual $N$ accelerates $A$ at times earlier than $t_{0}$ and decelerates it at later times***. The graph of $A$ against $t$ therefore rises to a maximum at $t=t_{0}$, and my first idea was that this would identify. So it would if all observations were without error (and the method would have the theoretical advantage of being unaffected by the eccentricities). But the value of $A$ at time $t$ depends on the $r$ at time $t$, and the determinations of the $A$'s are consequently too uncertain. Though the method fails it rises from the ashes in another form. For this a few more preliminaries are needed.\n\n\nThe numerical data Adams and le Verrier had to work on were not the observed\n$\\theta$'s themselves, but the differences between the observed $\\theta(t)$ and the $\\theta_{B}(t)$ of an elliptic orbit calculated by Bouvard; the 'discrepancy' $\\delta(t)$ ($\\delta$ for short) is $\\delta(t)=\\theta(t)-\\theta_{B}(t)$. [$\\theta_{B} (t)$ depends on the 'elements' of $E_{B}$, and these are subject to 'errors'. These errors are among the unknowns that the perturbation theory has to determine: our method does not mind what they are, as we shall see.] Table I gives the raw $S$'s (given in Adams's paper[^2(3)]), together with the values got by running\na smooth curve. The treatment of the start of the sudden swoop down after the long flat stretch is a bit uncertain: I drew my curve and stuck to it (but faking would make no ultimate difference). The differences show up the order of the observational errors (which naturally improve with the years something seems to have gone badly wrong in 1789); these are absolute, not relative (thus the probable\nabsolute error in $\\delta_{1} - \\delta_{2}$ is the same whether $\\delta_{1} - \\delta_{2}$ is 0.5\" or 90\"). It is worth while to work to 0.1\" and to the number\nof decimal places used in what follows, even though the last place is doubtful.\n\n[^2(3)]: ***Collected Works, I***, p. 11. These (and not the modifications he\nintroduces, which are what appear in Smart) are what is relevant for us.\n\n\n\n| Year | Observed $\\delta$ | Smooth Curve | Year | Observed $\\delta$ | Smooth Curve |\n| :---: | :-------------: | :------------: | :---: | :------------: | :--------------: |\n| 1780 | 3.5 | 3.5 | 1813 | 22.0 | 22.8 |\n| 1783 | 8.5 | 8.5 | 1816 | 22.9 | 22.5 |\n| 1786 | 12.4 | 12.5 | 1819 | 20.7 | 22.0 |\n| 1789 | 19.0 | 15.8 | 1822 | 21.0 | 21.0 |\n| 1792 | 18.7 | 18.3 | 1825 | 18.2 | 18.1 |\n| 1795 | 21.4 | 20.3 | 1828 | 10.8 | 10.3 |\n| 1798 | 21.0 | 21.6 | 1831 | -4.0 | -4.0 |\n| 1801 | 22.2 | 22.4 | 1834 | -20.8 | -20.8 |\n| 1804 | 24.2 | 22.8 | 1837 | -42.7 | -42.5 |\n| 1807 | 22.1 | 23.0 | 1840 | -66.6 | -66.6 |\n| 1810 | 23.2 | 23.0 | 1843(e) | $-$ | -94.0 |\n\nTable 1\n\nThe value for 1843 is an extrapolation; results derived from it are labelled '(e)'.\n\nAn 'effect' due to $N$ is of 'order $m$ in mathematical notation $O(m)$; if, for a particular quantity $X$, \\Delta X$ denotes (calculated $X$) —— (observed $X$), then any $\\Delta X$ is $O(m)$. The square of this (2nd order of infinitesimals) is\nextremely minute and everyone neglects it instinctively (if $a$ watch loses 10 seconds a day you don't try to correct for the further loss over the lost 10 seconds the cases are comparable). Next, an effect of $N$ is what it would be if $U$, and also $N$, moved in circles, ***plus*** a 'correction' for the actual eccentricities of the orbits. $U$'s eccentricity $e(\\frac{1}{20})$ is unusually large and it would be reasonable to expect $N$'s to be no larger (it is actually less than $\\frac{1}{100}$). The $e$'s distort the 'circular' value of the effect by 5 per cent, (or say a maximum of 10 per cent.); the 'distortion' of the effect\nis $O(em)$, the effect itself being $O(m)$. I propose to ignore things of order $O(em)$[^1(4)]: this is the first step in my argument. In particular, when we have something which is either some $\\Delta$, or $m$ itself, multiplied by a factor, we can substitute first approximations (i.e. with $e=0$), or make convenient changes that are $O(e)$, in the factor.\n\n\n[^1(4)]: I should stress that there is no question of ignoring even high powers\nof $e$ ***unaccompanied by a factor $m$*** ($e^{4}$ radians is about 1\"). The distortion in the value found for $t$ is, however, a sort of exception to\nthis. But the effect of $e$'s in distorting $t_{0}$ is unlikely to be worse than the separation they create between time of conjunction and time of closest approach. An easy calculation shows that this last time difference\nis at worst 0-8 years.\n\n\nSuppose now that $E_{l}, E_{2}$ are two (exact) elliptic orbits, yielding\n$\\theta(t)$'s that differ by amounts of the kind we are concerned with, differing, that is, by $O(m)$.[^2(4)] It is now the case that the differences satisfy the equation\n\n$$\\begin{equation}\n\\theta_{1} - \\theta_{2} = m( a + bt + c \\cos nt + d \\sin nt) + O(em)\n\\end{equation}$$\n\nwhere $a, b, c, d$ are constants depending on the two sets of elements of $E_{1}, E_{2}$, and (following our agreement about ***factors*** of $m$) $n$ is any common approximation to the mean angular velocity. I will postpone the school mathentatics\nproof of this.\n\n\n[^2(4)]: The orbits may have 'Suns' of masses differing by $O(m)$.\n\nNext, (i) let $E^{*}$ be the 'instantaneous orbit at time $t_{0}$', that is to say the orbit that $U$ would describe if $N$ were annihilated at time $t_{0}$: note that $E^{*}$ shares with $t_{0}$ the property of being 'unknown'. (ii) Let $\\vartheta$ be the perturbation of the $\\theta$ of $U$ produced by $N$ since time\n$t_{0}$.[^3(4)] Then if, at any time $t$, $\\theta$ is (as usual) $U$'s longitude, $\\theta_{B}$ is the longitude in the orbit $E_{B}$, and $\\theta^{*}$ the longitude in the orbit $E^{*}$, we have $\\vartheta = \\theta - \\theta^{*}$, and so\n\n$$\\begin{equation}\n\\delta(t) = \\theta - \\theta_{B} = (\\theta^{*} - \\theta_{B}) + \\vartheta\n\\end{equation}$$\n\nNow everything in this has a factor $m$, and we may omit any stray $O(em)$'s.\nIn particular, we may in calculating $\\vartheta$ drop any $e$ terms. But this means that ***we can calculate $\\vartheta$ as if both $U$'s and $N$'s orbits were circles***. When, however, the orbits are circles, ***$\\vartheta$ has equal and opposite values at $t$'s on equal and opposite sides of $t_{0}$***; in other words, ***if we write $t=t_{0} + \\tau$, then***\n\n$$\\begin{equation}\n\\vartheta(t) = \\Omega (\\tau)\n\\end{equation}$$\n\n***where $\\Omega (\\tau)$ is an odd[^1(5)] function of $\\tau$; i.e. $\\Omega(-\\tau)= -\\Omega(\\tau)$.***\n\n\n\n[^3(4)]: We allow, of course, ***negative*** values of $t - t_{0}$ both in $E^{*}$ and in $\\vartheta$.\n\n[^1(5)]: '$\\Omega$' is a deputy for '$O$' (initial of 'odd'), which is otherwise engaged. The italicized statement in the text is true 'by symmetry': alternatively, ***reverse*** the motions from time $t_{0}$. (The argument covers also the 'perturbation of 'the Sun' which is not so completely negligible as\nmight be supposed.)\n\n\nThis, used in combination with (1) and (2), is the essential (and very simple) point of the argument. The difference $\\theta^{*} - \\theta_{B}$ is a special case of $\\theta_{1} - \\theta_{2}$ in (1). Write $t=t_{0} + \\tau$ in (1) and combine this with (2) and (3); this gives, ignoring $O(em)$'s,\n\n$$\\delta(t_{0} + \\tau) = m \\left\\{a + b t_{0} + b \\tau + c \\cos (nt_{0} + n \\tau) + d \\sin (nt_{0} + n \\tau) \\right\\} + \\Omega(\\tau)$$\n\nExpanding the $\\cos$ and $\\sin$ of sums and rearranging we have (with new constants, whose values vary with but do not concern us)\n\n$$\\delta(t_{0} + \\tau) = A - B(1 - \\cos n\\tau) + \\left\\{C \\tau + D \\sin n\\tau + \\Omega(\\tau)\\right\\}$$\n\n***The curly bracket is an odd function of $\\tau$***. Hence if we combine\nequal and opposite $\\tau$ and construct $\\delta^{*}(\\tau)$ and $\\rho(\\tau)$ to satisfy\n\n$$\\delta^{*}(\\tau) = - \\frac{1}{2} \\left\\{\\delta(t_{0}+\\tau) + \\delta(t_{0}- \\tau) - 2 \\delta(t_{0}) \\right\\}, \\rho(\\tau) = \\delta^{*}(\\tau)/(1-\\cos n\\tau)$$\n\nwe have $\\delta^{*}(\\tau)=B( 1 - \\cos n\\tau)$, and so $\\rho(\\tau)=B $ for all $\\tau$. ***If, then, we are using the right $t_{0}$ the ratio p(r) must come out constant***: this is our method for identifying $t_{0}$. The actual value of $t_{0}$ to the nearest year is 1822.\n\nTable II, in which the unit of time is 1 year (and the $n$ of $\\cos n\\tau$ is $2\\pi/84$), shows the results of trying various (the century is omitted from the dates). The last place of decimals for the $\\rho(\\tau)$ is not reliable, but of course gets better as the size of the entry $2\\delta^{*}(\\tau)$ increases: I give the numbers as they came, and they speak for themselves. $\\tau=6$ is included, though the proportionate error in $\\delta^{*}$ is then considerable.[^1(6)] For\n$t_{0}=13$ $\\rho$ goes on to 34.8 at $\\tau=27$; for $t_{0}=16$ it goes to 38.2 at $\\tau= 24$. Once the data the smooth curve values were assembled the calculations took a mere hour or so with a slide-rule. The date 1822-4 seems about the 'best' $t_{0}$.\n\n[^1(6)]: And the, values for $\\tau=6$ at $t_{0}=22, 22.4$ are more uncertain than usual because of a crisis in the smooth curve.\n\n<style>\n    body {text-align: center;} table{margin: auto;}\n</style>\n\n<table>\n    <tr>\n        <td> </td>\n        <td colspan=\"2\"> $t_{0} = 13$ </td>\n        <td colspan=\"2\"> $t_{0} = 16$ </td>\n        <td colspan=\"2\"> $t_{0} = 19$ </td>\n        <td colspan=\"2\"> $t_{0} = 22$ </td>\n        <td colspan=\"2\"> $t_{0} = 22.4$ </td>\n        <td colspan=\"2\"> $t_{0} = 25$ </td>\n        <td colspan=\"2\"> $t_{0} = 28$ </td>\n    </tr>\n    <tr>\n        <td> $\\tau$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n        <td> $2\\delta^{*}(\\tau)$ </td>\n        <td> $\\rho(\\tau)$ </td>\n    </tr>\n    <tr>\n        <td> 6 </td>\n        <td> 0.6 </td>\n        <td> 3.0 </td>\n        <td> 1.0 </td>\n        <td> 5.1 </td>\n        <td> 3.6 </td>\n        <td> 18.3 </td>\n        <td> 9.2 </td>\n        <td> 47.0 </td>\n        <td> 10.6 </td>\n        <td> 53.8 </td>\n        <td> 18.2 </td>\n        <td> 92.5 </td>\n        <td> 20.4 </td>\n        <td> 103 </td>\n    </tr>\n    <tr>\n        <td> 9 </td>\n        <td> 1.8 </td>\n        <td> 4.1 </td>\n        <td> 3.9 </td>\n        <td> 9.0 </td>\n        <td> 10.7 </td>\n        <td> 24.6 </td>\n        <td> 23.2 </td>\n        <td> 53.3 </td>\n        <td> 25.0 </td>\n        <td> 57.6 </td>\n        <td> 34.5 </td>\n        <td> 79.3 </td>\n        <td> 41.1 </td>\n        <td> 94 </td>\n    </tr>\n    <tr>\n        <td> 12 </td>\n        <td> 5.3 </td>\n        <td> 7.6 </td>\n        <td> 11.9 </td>\n        <td> 15.8 </td>\n        <td> 25.0 </td>\n        <td> 33.2 </td>\n        <td> 39.8 </td>\n        <td> 53.0 </td>\n        <td> 42.2 </td>\n        <td> 56.1 </td>\n        <td> 55.9 </td>\n        <td> 74.4 </td>\n        <td> 64.7 </td>\n        <td> 86 </td>\n    </tr>\n    <tr>\n        <td> 15 </td>\n        <td> 13.7 </td>\n        <td> 12.1 </td>\n        <td> 26.6 </td>\n        <td> 23.5 </td>\n        <td> 42.0 </td>\n        <td> 37.1 </td>\n        <td> 61.5 </td>\n        <td> 54.4 </td>\n        <td> 64.0 </td>\n        <td> 56.5 </td>\n        <td> 79.8 </td>\n        <td> 70.5 </td>\n        <td> 91(e) </td>\n        <td> 80.6(e) </td>\n    </tr>\n    <tr>\n        <td> 18 </td>\n        <td> 29.3 </td>\n        <td> 18.8 </td>\n        <td> 44.2 </td>\n        <td> 28.4 </td>\n        <td> 64.1 </td>\n        <td> 41.2 </td>\n        <td> 85.8 </td>\n        <td> 55.2 </td>\n        <td> 88.6 </td>\n        <td> 57.0 </td>\n        <td> 106(e) </td>\n        <td> 86.3(e) </td>\n        <td> $-$ </td>\n        <td> $-$ </td>\n    </tr>\n    <tr>\n        <td> 21 </td>\n        <td> 48.3 </td>\n        <td> 24.1 </td>\n        <td> 67.2 </td>\n        <td> 36.6 </td>\n        <td> 89.0 </td>\n        <td> 45.5 </td>\n        <td> 113(e) </td>\n        <td> 56.5(e) </td>\n        <td> 116(e) </td>\n        <td> 58.0(e) </td>\n        <td> $-$ </td>\n        <td> $-$ </td>\n        <td> $-$ </td>\n        <td> $-$ </td>\n    </tr>\n    <caption> Table II </caption>\n</table>\n\nWe need fairly large $\\tau$ for $\\delta^{*}(\\tau)$ to have enough ignificant figures, and further to provide a range showing up whether\n$\\rho(\\tau)$ is constant or not. And we need room to manoeuvre round the final. So the method depends on the 'luck' that 1822 falls comfortably inside the period of observation 1780-1840. But some luck was needed in any case.\n\n\nIt is an important point that the method is quite indifferent to how well $E_{B}$ does its originally intended job, and ***we do not need to know (and I don't knoiv) its elements***; it is enough to know the 'discrepancy' with ***some***, 'unknown', orbit (not too bad of course). On the other hand the method ostentatiously says nothing at all about the mass or distance of $N$. I will add something on this. With $e$-terms ignored $\\vartheta(\\tau)/m$ can be calculated ***exactly*** for any given value of $\\lambda=a/a_{1}$ (ratio of the $a$'s of $U$ and $N$)[^2(6)] The idea would be to try different $A$'s, each $A$ to give a best fitting $m$, and to take the best fitting ***pair*** $\\lambda, m$. This fails, because the greater part of $\\vartheta$ is of the form $b^{\\prime}(n\\tau - \\sin n\\tau)$, and $b^{\\prime}$ is smothered by the $a, b, c, d$ of $\\theta^{*} - \\theta_{B}$, which depend on the unknown elements of $E_{B}$ ($\\vartheta$ is smothered by the 'unknown' $\\theta^{*} - \\theta_{B}$). If we knew these elements (or equivalently the raw $\\theta$) we might be able to go on. They could be recovered from the Paris Observatory archives; but\nthis article is a last moment addition to the book, I do not feel that I am on full professional duty, and in any case we should be losing the\nlight-hearted note of our adventure.\n\n\n\n[^2(6)]: From two second order differential equations. The formula involves 'quadratures', but in numerical calculation integration\nis quicker than multiplication. It would be comparatively easy to make a double entry table for $\\vartheta(\\tau, \\lambda)/m$\n\n\n\n\nThe time $t$ once known, it would be necessary to guess a value for $N$'s distance $a_{1}$; $N$'s period is then $84(a_{1}/a)^{\\frac{3}{2}}$ years, and we could 'predict' $N$'s place in 1846. The obvious first guess in 1846 was $a_{l}/a=2$, following Bode's empirical law, to which N is maliciously the first exception, the true value being\n1.58. Adams and le Verrier started with 2 (Adams coming down to 1.942 for a second round). Since from our standpoint[^1(7)] too large an\n$a_{1}$ has disproportionately bad results as against one too small,\nit would be reasonable to try 1.8. This would give a prediction (for 1846) about 10$^{\\circ}$ out, but the sweep needed would be wholly practicable.\n\n\n[^1(7)]: Perturbation theory calculations have necessarily to ***begin*** by guessing $a_{1}$; our guess need only be at the end.\n\n\nLe Verrier was less than 1$^{\\circ}$ out (Adams between 2$^{\\circ}$ and 3$^{\\circ}$); 'they pointed the telescope and saw the planet'.\nThis very close, and double, prediction is a curiosity. All the observations from 1780 to 1840 were used, and on an equal footing, and the theory purported to say where $N$ was over this whole stretch.\nWith a wrong $a_{1}$ they could be right at 1840 only by being wrong at 1780. With Adams's $a_{1}=1.94a$ $N$'s period (which depends on $a_{1}$ only) would be 227 years; he would have been wrong by 30$^{\\circ}$\nfor 1780 if the orbit were circular, and so the angular velocity uniform. But faced with a wrong $a_{1}$ the method responded gallantly\nby putting up a large eccentricity ($\\frac{1}{8}$), and assigning perihelion to the place of conjunction. The combination makes the effective distance from $S$ over the critical stretch more like\n$1.7 a_{l}$, and the resulting error at 1780 (the worst one) was only 18. (A mass 2.8 times too large was a more obvious adjustment.)\n\n\nIn much more recent times small discrepancies for $N$ and $U$ ($U$'s being in fact the more manageable ones) were analysed for a trans-Neptunian planet, and the planet Pluto was found in 1930 near the predicted place. This was a complete fluke: Pluto has a mass probably no more than $\\frac{1}{10}$ of the Earth's; any effects\nit could have on $N$ and $U$ would be hopelessly swamped by the observational errors.\n\nIt remains for me to give the (school mathematics) proof of (1) above.\nCall $e_{1} - e_{2}$ $\\Delta e$, and so on. I said above that all $\\Delta$'s were $O(m)$: this is not quite true, though my deception has been in the reader's best interests, and will not have led him astray.[^1(8)] It is true, and common sense, for $\\Delta a$, $\\Delta e$, $\\Delta n$, and $\\Delta \\epsilon$. But the 'effect' of a given Aa vanishes when $e=0$, and is proportional to $e$. So it is $e\\Delta \\alpha$, not $\\Delta \\alpha$, that is comparable with the other $\\Delta$'s and so $O(m)$.[^2(8)]\n\n\n\n[^1(8)]: 'Wen Gott betrugt is wohl betrogon.'\n\n[^2(8)]: This twist makes the 'obvious' approach of using the\nweil known expansion\n$$\\theta = nt +\\epsilon + 2e \\sin (nt + \\epsilon -a) + \\frac{5}{4}e^{2} \\sin 2 (nt + \\epsilon -a ) + \\cdots$$\nslightly tricky; we should have to keep the term in $e^{2}$. The line taken in the text side-steps this.\n\n\n\n\n\nWe start from two well-known formulae. The first is geometrical; the polar equation of the ellipse of the orbit is\n\n$$\\begin{equation}\nr = a(1- e^{2}) ( 1 +e \\cos (\\theta -a))^{-1}\n\\end{equation}$$\n\n\n\nThe second is dynamical; the equation of angular momentum (Kepler's second law) is\n\n$$\\begin{equation}r^{2} \\frac{d\\theta}{dt} = na^{2} (1-e^{2})^{\\frac{1}{2}}\\end{equation}$$\n\n\n\nSo, using dots for time differentiations,\n\n\n$$\\begin{equation}\n\\theta = n(1-e^{2})^{-\\frac{3}{2}} [1 - 2\\cos (\\theta -a) + 3e^{2} \\cos^{2} (\\theta -a ) + \\cdots]\n\\end{equation}$$\n\n\nThe first approximation (with $e=0$) is $\\theta=nt + \\epsilon$. We take\nsuffixes 1 and 2 in (6) and operate with $\\Delta$, remembering that we may take first approximations in any ***factor*** of an $m$.\n\n\nIn estimating $\\Delta\\theta$ we may, with error $O(em)$, ignore the\nfactor $(1-e^{2})^{-\\frac{3}{2}}$ in (6), since it is itself $\\left(1+O(e^{2})\\right)$, and its $\\Delta$ is $O(e\\Delta e)=O(em)$. We have, therefore, with error $O(em)$,\n\n$$\\Delta \\theta = \\Delta \\left\\{n[\\quad ]\\right\\} = [\\quad ] \\Delta n + n \\Delta [\\quad ]$$\n\nThe 1st term is $\\Delta n+O(em)$. The 2nd is\n\n$$n\\left[\\Delta e \\left\\{- 2 \\cos(\\theta -a ) + O(e)\\right\\} + \\Delta (\\theta -a ) \\left\\{2e \\sin (\\theta -a ) + O(e^{2}\\right\\}\\right]$$\n\nand we may drop the $\\theta$ in $\\Delta (\\theta - a)$ on account of the factor $O(\\epsilon)$. Summing up, we obtain\n\n$$\\Delta \\theta = m (A+B \\cos (\\theta -a ) + C \\sin (\\theta -a ) ) + O(em)$$\n\nwhere $mA=\\Delta n$, $mB = -2n\\Delta e$, $mC = -2n(e\\Delta a)$. Substituting the first approximation $\\theta=nt + \\epsilon$ in the right hand side, we have\n\n$$\\Delta \\theta = m (A+B \\cos (nt + \\epsilon -a ) + C \\sin (nt + \\epsilon -a ) ) + O(em)$$\n\n\nand integration then gives\n\n\n\n$$\\Delta \\theta = m (A+B/n \\sin (nt + \\epsilon -a ) - C/n \\cos (nt + \\epsilon -a ) ) + O(em)$$\n\n\n\nwhich, after expanding the sin and cos and rearranging, is of the desired form (I).[^1(9)]\n\n\n\n[^1(9)]: We have treated $\\Delta n$ and $\\Delta a$ as independent (the latter happens not to occur in the final formula for $\\Delta \\theta$): this amounts to allowing different masses to the two 'Suns'. The point is relevant to certain subtleties, into which I will not enter.\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"The Discovery of Neptune","published":1,"updated":"2024-11-16T20:30:59.517Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5s50021m8nx2ljlheei","content":"<p>Neptune was discovered in 1846 as a result of mathematical\r\ncalculation, done independently and practically simultaneously by Adams\r\nand le Verrier. The full story abounds in unexpected twists, and is\r\ncomplicated by personal matters, some of them rather painful. There is a\r\nfascinating account in Professor W. M. Smart's <strong><em>John Couch\r\nAdams and the Discovery of Neptune</em></strong>, published by the Royal\r\nAstronomical Society, 1947. I am concerned only with limited parts of\r\nthe field.</p>\r\n<p>To refresh the reader's memory of what has been said from time to\r\ntime about the discovery I will begin with some representative\r\nquotations. In <strong><em>The Story of the Heavens</em></strong> (1886)\r\nSir Robert Ball has passages:' the name of le Verrier rose to a pinnacle\r\nhardly surpassed in any age or country' ... 'profound meditations for\r\nmany months' ... 'long tand arduous labour guided by consummate\r\nmathematical artifice'. The author is not above a bit of popular appeal\r\nin this book —— 'if the ellipse has not the perfect simplicity of the\r\ncircle, it has at least the charm of variety ... an outline of perfect\r\ngrace, and an association with ennobling conceptions' —— but on Neptune\r\nhe is speaking as a professional. An excellent modern book on the\r\nhistory of astronomy has, so late as 1938:' probably the most daring\r\nmathematical enterprise of the century ... this amazing task, like which\r\nnothing had ever been attempted before'.</p>\r\n<p>The immediate reaction was natural enough. Celestial Mechanics in\r\ngeneral, and the theory of perturbations in particular, had developed\r\ninto a very elaborate and high-brow subject; the problem of explaining\r\nthe misbehaviour of Uranus by a new planet was one of 'inverse' theory,\r\nand the common feeling was that the problem was difficult up to or\r\nbeyond the point of impossibility. One might speculate at some length on\r\nreasons for this opinion (one, perhaps was confusion between different\r\nmeanings of the technica term 'insoluble'<a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a>).\r\nWhen Adams and le Verrier provec the opinion wrong (and after all\r\n<strong><em>any</em></strong> mathematical proof is a debunking of\r\nsorts) there was still something to be said for the principle that\r\ndifficulties are what they seem before the event, not after. Certainly\r\nno one would grudge them their resounding fame. (Nor grudge, at a lower\r\nlevel, the luck of a discovery which makes a more sensational impact\r\nthan its actual difficulty strictly merits; in point of fact this luck\r\nnever does happen to the second-rate.) If the discovery has had a very\r\nlong run one must remember that there is a time-lag ; people cannot be\r\nalways reconsidering opinions, and having said something once even the\r\nmost intelligent tend to go on repeating it. The phrase was still in\r\nvogue that 'only 3 people understand Relativity' at a time when\r\nEddington was complaining that the trouble about Relativity as an\r\nexamination subject in 'Part III' was that it was such a soft\r\noption.</p>\r\n<p>In what I am going to say I am far from imputing stupidity to people\r\ncertainly less stupid than myself. My little <strong><em>jeuz\r\nd'esprit</em></strong> are not going to hurt anyone, and I refuse to be\r\ndeterred by the fear of being thought disrespectful to great men. I have\r\nnot been alone in a lurking suspicion that a much simpler approach might\r\nsucceed. On the one hand, aim at the minimum needed to make\r\nobservational discovery practicable; specifically at the time <span class=\"math inline\">\\(t_{0}\\)</span> of conjunction.<a href=\"#fn2\" class=\"footnote-ref\" id=\"fnref2\" role=\"doc-noteref\"><sup>2</sup></a> On\r\nthe other, forget the high-brow and laborious perturbation theory, and\r\ntry 'school mathematics'. (I admit to the human weakness of being\r\nspurred on by the mild piquancy success would have.) To begin with I\r\nfound things oddly elusive (and incidentally committed some gross\r\nstupidities). In the end an absurdly simple line emerged: I can imagine\r\nits being called a dirty trick, nor would I deny that there is some\r\ntruth in the accusation. The only way to make my case is to carry out\r\nthe actual 'prediction' of <span class=\"math inline\">\\(t_{0}\\)</span>\r\nfrom the observational data, with all the cards on the table (so that\r\nanyone can check against unconscious or conscious faking). I will also\r\nwrite so as to take as many amateurs as possible with me on the little\r\nadventure.</p>\r\n<p>A planetary 'orbit' is an ellipse with the Sun <span class=\"math inline\">\\(S\\)</span> at a focus, and the radius vector <span class=\"math inline\">\\(SP\\)</span> sweeps out area at a constant rate\r\n(Kepler's second law). An orbit, given its plane, is defined by 4\r\nelements, <span class=\"math inline\">\\(a\\)</span>, <span class=\"math inline\">\\(e\\)</span>, <span class=\"math inline\">\\(\\alpha\\)</span>, <span class=\"math inline\">\\(\\epsilon\\)</span>. The first 3 define the\r\ngeometrical ellipse: <span class=\"math inline\">\\(a\\)</span> is the\r\nsemi-major axis; <span class=\"math inline\">\\(e\\)</span> the\r\neccentricity; <span class=\"math inline\">\\(\\alpha\\)</span> the longitude\r\nof perihelion, i.e. with the obvious polar coordinates <span class=\"math inline\">\\(r, \\theta\\)</span>, <span class=\"math inline\">\\(\\theta\\)</span> is the 'longitude' and <span class=\"math inline\">\\(\\theta=a\\)</span> when <span class=\"math inline\">\\(P\\)</span> is nearest <span class=\"math inline\">\\(S\\)</span> (at an end of the major axis). When we\r\nknow <span class=\"math inline\">\\(a\\)</span> we know the 'mean angular\r\nvelocity' <span class=\"math inline\">\\(n\\)</span> and the associated\r\nperiod <span class=\"math inline\">\\(p= 2 \\pi/n\\)</span>; <span class=\"math inline\">\\(n\\)</span> is in fact proportional to <span class=\"math inline\">\\(a^{-\\frac{1}{2}}\\)</span> (Kepler's third law)<a href=\"#fn3\" class=\"footnote-ref\" id=\"fnref3\" role=\"doc-noteref\"><sup>3</sup></a>; further the constant rate of area\r\nsweeping is <span class=\"math inline\">\\(\\frac{1}{2}abn\\)</span><a href=\"#fn4\" class=\"footnote-ref\" id=\"fnref4\" role=\"doc-noteref\"><sup>4</sup></a> and twice this rate is identical\r\nwith the angular momentum'<a href=\"#fn5\" class=\"footnote-ref\" id=\"fnref5\" role=\"doc-noteref\"><sup>5</sup></a> (a.m. for short); this\r\nhas the differential calculus formula <span class=\"math inline\">\\(r^{2}\\theta\\)</span>, and it also is of course\r\nconstant. The 4th element, the 'epoch' <span class=\"math inline\">\\(e\\)</span>, is needed to identify the origin of\r\n<span class=\"math inline\">\\(t\\)</span>; the exact definition is that\r\n<span class=\"math inline\">\\(\\theta= \\alpha\\)</span> (perihelion) occurs\r\nat the <span class=\"math inline\">\\(t\\)</span> for which <span class=\"math inline\">\\(nt+ \\epsilon = \\alpha\\)</span>.</p>\r\n<p><span class=\"math inline\">\\(U\\)</span>'s orbit has a period of 84\r\nyears, and an eccentricity <span class=\"math inline\">\\(e\\)</span> of\r\nabout <span class=\"math inline\">\\(\\frac{1}{20}\\)</span>. The effects of\r\nbodies other than <span class=\"math inline\">\\(S\\)</span> and <span class=\"math inline\">\\(N\\)</span> can be allowed for, after which we may\r\nsuppose that <span class=\"math inline\">\\(U\\)</span>, <span class=\"math inline\">\\(S\\)</span>, and the eventual <span class=\"math inline\">\\(N\\)</span> are the only bodies in the system; we\r\nmay also suppose (all this is common form) that the movements are all in\r\none plane. The values of <span class=\"math inline\">\\(\\theta\\)</span>\r\n(for <span class=\"math inline\">\\(U\\)</span>) at the various times <span class=\"math inline\">\\(t\\)</span> (we sometimes write <span class=\"math inline\">\\(\\theta(t)\\)</span> to emphasize that <span class=\"math inline\">\\(\\theta\\)</span> is 'at time <span class=\"math inline\">\\(t\\)</span>') may be regarded as the observational\r\nraw material (though of course the actual raw observations are made from\r\nthe Earth). The <span class=\"math inline\">\\(r\\)</span>'s for the various\r\n<span class=\"math inline\">\\(t\\)</span> are indirect and are much less\r\nwell determined.</p>\r\n<p>The position in 1845 was that no exact elliptic orbit would fit the\r\nobserved 6 over the whole stretch 1780 to 1840.<a href=\"#fn6\" class=\"footnote-ref\" id=\"fnref6\" role=\"doc-noteref\"><sup>6</sup></a> The\r\ndiscrepancies are very small, mostly a few seconds of arc (with a sudden\r\nswoop of about 90\",see Tablel). The ratio <span class=\"math inline\">\\(m\\)</span> of <span class=\"math inline\">\\(N\\)</span>'s mass to that of <span class=\"math inline\">\\(S\\)</span> (taken as 1) is actually about 1/19000\r\n(the Orders of magnitude fit since m radians is about 11\").</p>\r\n<p>In the absence of <span class=\"math inline\">\\(N\\)</span> the a.m.\r\n<span class=\"math inline\">\\(A\\)</span> is constant (as stated above\r\nalias of Kepler's second law); <strong><em>the actual <span class=\"math inline\">\\(N\\)</span> accelerates <span class=\"math inline\">\\(A\\)</span> at times earlier than <span class=\"math inline\">\\(t_{0}\\)</span> and decelerates it at later\r\ntimes</em></strong>. The graph of <span class=\"math inline\">\\(A\\)</span>\r\nagainst <span class=\"math inline\">\\(t\\)</span> therefore rises to a\r\nmaximum at <span class=\"math inline\">\\(t=t_{0}\\)</span>, and my first\r\nidea was that this would identify. So it would if all observations were\r\nwithout error (and the method would have the theoretical advantage of\r\nbeing unaffected by the eccentricities). But the value of <span class=\"math inline\">\\(A\\)</span> at time <span class=\"math inline\">\\(t\\)</span> depends on the <span class=\"math inline\">\\(r\\)</span> at time <span class=\"math inline\">\\(t\\)</span>, and the determinations of the <span class=\"math inline\">\\(A\\)</span>'s are consequently too uncertain.\r\nThough the method fails it rises from the ashes in another form. For\r\nthis a few more preliminaries are needed.</p>\r\n<p>The numerical data Adams and le Verrier had to work on were not the\r\nobserved <span class=\"math inline\">\\(\\theta\\)</span>'s themselves, but\r\nthe differences between the observed <span class=\"math inline\">\\(\\theta(t)\\)</span> and the <span class=\"math inline\">\\(\\theta_{B}(t)\\)</span> of an elliptic orbit\r\ncalculated by Bouvard; the 'discrepancy' <span class=\"math inline\">\\(\\delta(t)\\)</span> (<span class=\"math inline\">\\(\\delta\\)</span> for short) is <span class=\"math inline\">\\(\\delta(t)=\\theta(t)-\\theta_{B}(t)\\)</span>. [<span class=\"math inline\">\\(\\theta_{B} (t)\\)</span> depends on the 'elements'\r\nof <span class=\"math inline\">\\(E_{B}\\)</span>, and these are subject to\r\n'errors'. These errors are among the unknowns that the perturbation\r\ntheory has to determine: our method does not mind what they are, as we\r\nshall see.] Table I gives the raw <span class=\"math inline\">\\(S\\)</span>'s (given in Adams's paper<a href=\"#fn7\" class=\"footnote-ref\" id=\"fnref7\" role=\"doc-noteref\"><sup>7</sup></a>),\r\ntogether with the values got by running a smooth curve. The treatment of\r\nthe start of the sudden swoop down after the long flat stretch is a bit\r\nuncertain: I drew my curve and stuck to it (but faking would make no\r\nultimate difference). The differences show up the order of the\r\nobservational errors (which naturally improve with the years something\r\nseems to have gone badly wrong in 1789); these are absolute, not\r\nrelative (thus the probable absolute error in <span class=\"math inline\">\\(\\delta_{1} - \\delta_{2}\\)</span> is the same\r\nwhether <span class=\"math inline\">\\(\\delta_{1} - \\delta_{2}\\)</span> is\r\n0.5\" or 90\"). It is worth while to work to 0.1\" and to the number of\r\ndecimal places used in what follows, even though the last place is\r\ndoubtful.</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 7%\">\r\n<col style=\"width: 21%\">\r\n<col style=\"width: 20%\">\r\n<col style=\"width: 7%\">\r\n<col style=\"width: 20%\">\r\n<col style=\"width: 23%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">Year</th>\r\n<th style=\"text-align: center;\">Observed <span class=\"math inline\">\\(\\delta\\)</span></th>\r\n<th style=\"text-align: center;\">Smooth Curve</th>\r\n<th style=\"text-align: center;\">Year</th>\r\n<th style=\"text-align: center;\">Observed <span class=\"math inline\">\\(\\delta\\)</span></th>\r\n<th style=\"text-align: center;\">Smooth Curve</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1780</td>\r\n<td style=\"text-align: center;\">3.5</td>\r\n<td style=\"text-align: center;\">3.5</td>\r\n<td style=\"text-align: center;\">1813</td>\r\n<td style=\"text-align: center;\">22.0</td>\r\n<td style=\"text-align: center;\">22.8</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1783</td>\r\n<td style=\"text-align: center;\">8.5</td>\r\n<td style=\"text-align: center;\">8.5</td>\r\n<td style=\"text-align: center;\">1816</td>\r\n<td style=\"text-align: center;\">22.9</td>\r\n<td style=\"text-align: center;\">22.5</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1786</td>\r\n<td style=\"text-align: center;\">12.4</td>\r\n<td style=\"text-align: center;\">12.5</td>\r\n<td style=\"text-align: center;\">1819</td>\r\n<td style=\"text-align: center;\">20.7</td>\r\n<td style=\"text-align: center;\">22.0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1789</td>\r\n<td style=\"text-align: center;\">19.0</td>\r\n<td style=\"text-align: center;\">15.8</td>\r\n<td style=\"text-align: center;\">1822</td>\r\n<td style=\"text-align: center;\">21.0</td>\r\n<td style=\"text-align: center;\">21.0</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1792</td>\r\n<td style=\"text-align: center;\">18.7</td>\r\n<td style=\"text-align: center;\">18.3</td>\r\n<td style=\"text-align: center;\">1825</td>\r\n<td style=\"text-align: center;\">18.2</td>\r\n<td style=\"text-align: center;\">18.1</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1795</td>\r\n<td style=\"text-align: center;\">21.4</td>\r\n<td style=\"text-align: center;\">20.3</td>\r\n<td style=\"text-align: center;\">1828</td>\r\n<td style=\"text-align: center;\">10.8</td>\r\n<td style=\"text-align: center;\">10.3</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1798</td>\r\n<td style=\"text-align: center;\">21.0</td>\r\n<td style=\"text-align: center;\">21.6</td>\r\n<td style=\"text-align: center;\">1831</td>\r\n<td style=\"text-align: center;\">-4.0</td>\r\n<td style=\"text-align: center;\">-4.0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1801</td>\r\n<td style=\"text-align: center;\">22.2</td>\r\n<td style=\"text-align: center;\">22.4</td>\r\n<td style=\"text-align: center;\">1834</td>\r\n<td style=\"text-align: center;\">-20.8</td>\r\n<td style=\"text-align: center;\">-20.8</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1804</td>\r\n<td style=\"text-align: center;\">24.2</td>\r\n<td style=\"text-align: center;\">22.8</td>\r\n<td style=\"text-align: center;\">1837</td>\r\n<td style=\"text-align: center;\">-42.7</td>\r\n<td style=\"text-align: center;\">-42.5</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1807</td>\r\n<td style=\"text-align: center;\">22.1</td>\r\n<td style=\"text-align: center;\">23.0</td>\r\n<td style=\"text-align: center;\">1840</td>\r\n<td style=\"text-align: center;\">-66.6</td>\r\n<td style=\"text-align: center;\">-66.6</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1810</td>\r\n<td style=\"text-align: center;\">23.2</td>\r\n<td style=\"text-align: center;\">23.0</td>\r\n<td style=\"text-align: center;\">1843(e)</td>\r\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(-\\)</span></td>\r\n<td style=\"text-align: center;\">-94.0</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>Table 1</p>\r\n<p>The value for 1843 is an extrapolation; results derived from it are\r\nlabelled '(e)'.</p>\r\n<p>An 'effect' due to <span class=\"math inline\">\\(N\\)</span> is of\r\n'order <span class=\"math inline\">\\(m\\)</span> in mathematical notation\r\n<span class=\"math inline\">\\(O(m)\\)</span>; if, for a particular quantity\r\n<span class=\"math inline\">\\(X\\)</span>, X$ denotes (calculated <span class=\"math inline\">\\(X\\)</span>) —— (observed <span class=\"math inline\">\\(X\\)</span>), then any <span class=\"math inline\">\\(\\Delta X\\)</span> is <span class=\"math inline\">\\(O(m)\\)</span>. The square of this (2nd order of\r\ninfinitesimals) is extremely minute and everyone neglects it\r\ninstinctively (if <span class=\"math inline\">\\(a\\)</span> watch loses 10\r\nseconds a day you don't try to correct for the further loss over the\r\nlost 10 seconds the cases are comparable). Next, an effect of <span class=\"math inline\">\\(N\\)</span> is what it would be if <span class=\"math inline\">\\(U\\)</span>, and also <span class=\"math inline\">\\(N\\)</span>, moved in circles,\r\n<strong><em>plus</em></strong> a 'correction' for the actual\r\neccentricities of the orbits. <span class=\"math inline\">\\(U\\)</span>'s\r\neccentricity <span class=\"math inline\">\\(e(\\frac{1}{20})\\)</span> is\r\nunusually large and it would be reasonable to expect <span class=\"math inline\">\\(N\\)</span>'s to be no larger (it is actually less\r\nthan <span class=\"math inline\">\\(\\frac{1}{100}\\)</span>). The <span class=\"math inline\">\\(e\\)</span>'s distort the 'circular' value of the\r\neffect by 5 per cent, (or say a maximum of 10 per cent.); the\r\n'distortion' of the effect is <span class=\"math inline\">\\(O(em)\\)</span>, the effect itself being <span class=\"math inline\">\\(O(m)\\)</span>. I propose to ignore things of order\r\n<span class=\"math inline\">\\(O(em)\\)</span><a href=\"#fn8\" class=\"footnote-ref\" id=\"fnref8\" role=\"doc-noteref\"><sup>8</sup></a>:\r\nthis is the first step in my argument. In particular, when we have\r\nsomething which is either some <span class=\"math inline\">\\(\\Delta\\)</span>, or <span class=\"math inline\">\\(m\\)</span> itself, multiplied by a factor, we can\r\nsubstitute first approximations (i.e. with <span class=\"math inline\">\\(e=0\\)</span>), or make convenient changes that are\r\n<span class=\"math inline\">\\(O(e)\\)</span>, in the factor.</p>\r\n<p>Suppose now that <span class=\"math inline\">\\(E_{l}, E_{2}\\)</span>\r\nare two (exact) elliptic orbits, yielding <span class=\"math inline\">\\(\\theta(t)\\)</span>'s that differ by amounts of the\r\nkind we are concerned with, differing, that is, by <span class=\"math inline\">\\(O(m)\\)</span>.<a href=\"#fn9\" class=\"footnote-ref\" id=\"fnref9\" role=\"doc-noteref\"><sup>9</sup></a> It is now the case that\r\nthe differences satisfy the equation</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\theta_{1} - \\theta_{2} = m( a + bt + c \\cos nt + d \\sin nt) + O(em)\r\n\\end{equation}\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(a, b, c, d\\)</span> are constants\r\ndepending on the two sets of elements of <span class=\"math inline\">\\(E_{1}, E_{2}\\)</span>, and (following our\r\nagreement about <strong><em>factors</em></strong> of <span class=\"math inline\">\\(m\\)</span>) <span class=\"math inline\">\\(n\\)</span>\r\nis any common approximation to the mean angular velocity. I will\r\npostpone the school mathentatics proof of this.</p>\r\n<p>Next, (i) let <span class=\"math inline\">\\(E^{*}\\)</span> be the\r\n'instantaneous orbit at time <span class=\"math inline\">\\(t_{0}\\)</span>', that is to say the orbit that\r\n<span class=\"math inline\">\\(U\\)</span> would describe if <span class=\"math inline\">\\(N\\)</span> were annihilated at time <span class=\"math inline\">\\(t_{0}\\)</span>: note that <span class=\"math inline\">\\(E^{*}\\)</span> shares with <span class=\"math inline\">\\(t_{0}\\)</span> the property of being 'unknown'.\r\n(ii) Let <span class=\"math inline\">\\(\\vartheta\\)</span> be the\r\nperturbation of the <span class=\"math inline\">\\(\\theta\\)</span> of <span class=\"math inline\">\\(U\\)</span> produced by <span class=\"math inline\">\\(N\\)</span> since time <span class=\"math inline\">\\(t_{0}\\)</span>.<a href=\"#fn10\" class=\"footnote-ref\" id=\"fnref10\" role=\"doc-noteref\"><sup>10</sup></a>\r\nThen if, at any time <span class=\"math inline\">\\(t\\)</span>, <span class=\"math inline\">\\(\\theta\\)</span> is (as usual) <span class=\"math inline\">\\(U\\)</span>'s longitude, <span class=\"math inline\">\\(\\theta_{B}\\)</span> is the longitude in the orbit\r\n<span class=\"math inline\">\\(E_{B}\\)</span>, and <span class=\"math inline\">\\(\\theta^{*}\\)</span> the longitude in the orbit\r\n<span class=\"math inline\">\\(E^{*}\\)</span>, we have <span class=\"math inline\">\\(\\vartheta = \\theta - \\theta^{*}\\)</span>, and\r\nso</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\delta(t) = \\theta - \\theta_{B} = (\\theta^{*} - \\theta_{B}) + \\vartheta\r\n\\end{equation}\\]</span></p>\r\n<p>Now everything in this has a factor <span class=\"math inline\">\\(m\\)</span>, and we may omit any stray <span class=\"math inline\">\\(O(em)\\)</span>'s. In particular, we may in\r\ncalculating <span class=\"math inline\">\\(\\vartheta\\)</span> drop any\r\n<span class=\"math inline\">\\(e\\)</span> terms. But this means that\r\n<strong><em>we can calculate <span class=\"math inline\">\\(\\vartheta\\)</span> as if both <span class=\"math inline\">\\(U\\)</span>'s and <span class=\"math inline\">\\(N\\)</span>'s orbits were circles</em></strong>.\r\nWhen, however, the orbits are circles, <strong><em><span class=\"math inline\">\\(\\vartheta\\)</span> has equal and opposite values\r\nat <span class=\"math inline\">\\(t\\)</span>'s on equal and opposite sides\r\nof <span class=\"math inline\">\\(t_{0}\\)</span></em></strong>; in other\r\nwords, <strong><em>if we write <span class=\"math inline\">\\(t=t_{0} +\r\n\\tau\\)</span>, then</em></strong></p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\vartheta(t) = \\Omega (\\tau)\r\n\\end{equation}\\]</span></p>\r\n<p><strong><em>where <span class=\"math inline\">\\(\\Omega (\\tau)\\)</span>\r\nis an odd<a href=\"#fn11\" class=\"footnote-ref\" id=\"fnref11\" role=\"doc-noteref\"><sup>11</sup></a> function of <span class=\"math inline\">\\(\\tau\\)</span>; i.e. <span class=\"math inline\">\\(\\Omega(-\\tau)=\r\n-\\Omega(\\tau)\\)</span>.</em></strong></p>\r\n<p>This, used in combination with (1) and (2), is the essential (and\r\nvery simple) point of the argument. The difference <span class=\"math inline\">\\(\\theta^{*} - \\theta_{B}\\)</span> is a special case\r\nof <span class=\"math inline\">\\(\\theta_{1} - \\theta_{2}\\)</span> in (1).\r\nWrite <span class=\"math inline\">\\(t=t_{0} + \\tau\\)</span> in (1) and\r\ncombine this with (2) and (3); this gives, ignoring <span class=\"math inline\">\\(O(em)\\)</span>'s,</p>\r\n<p><span class=\"math display\">\\[\\delta(t_{0} + \\tau) = m \\left\\{a + b\r\nt_{0} + b \\tau + c \\cos (nt_{0} + n \\tau) + d \\sin (nt_{0} + n \\tau)\r\n\\right\\} + \\Omega(\\tau)\\]</span></p>\r\n<p>Expanding the <span class=\"math inline\">\\(\\cos\\)</span> and <span class=\"math inline\">\\(\\sin\\)</span> of sums and rearranging we have\r\n(with new constants, whose values vary with but do not concern us)</p>\r\n<p><span class=\"math display\">\\[\\delta(t_{0} + \\tau) = A - B(1 - \\cos\r\nn\\tau) + \\left\\{C \\tau + D \\sin n\\tau +\r\n\\Omega(\\tau)\\right\\}\\]</span></p>\r\n<p><strong><em>The curly bracket is an odd function of <span class=\"math inline\">\\(\\tau\\)</span></em></strong>. Hence if we combine\r\nequal and opposite <span class=\"math inline\">\\(\\tau\\)</span> and\r\nconstruct <span class=\"math inline\">\\(\\delta^{*}(\\tau)\\)</span> and\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span> to satisfy</p>\r\n<p><span class=\"math display\">\\[\\delta^{*}(\\tau) = - \\frac{1}{2}\r\n\\left\\{\\delta(t_{0}+\\tau) + \\delta(t_{0}- \\tau) - 2 \\delta(t_{0})\r\n\\right\\}, \\rho(\\tau) = \\delta^{*}(\\tau)/(1-\\cos n\\tau)\\]</span></p>\r\n<p>we have <span class=\"math inline\">\\(\\delta^{*}(\\tau)=B( 1 - \\cos\r\nn\\tau)\\)</span>, and so $()=B $ for all <span class=\"math inline\">\\(\\tau\\)</span>. <strong><em>If, then, we are using\r\nthe right <span class=\"math inline\">\\(t_{0}\\)</span> the ratio p(r) must\r\ncome out constant</em></strong>: this is our method for identifying\r\n<span class=\"math inline\">\\(t_{0}\\)</span>. The actual value of <span class=\"math inline\">\\(t_{0}\\)</span> to the nearest year is 1822.</p>\r\n<p>Table II, in which the unit of time is 1 year (and the <span class=\"math inline\">\\(n\\)</span> of <span class=\"math inline\">\\(\\cos\r\nn\\tau\\)</span> is <span class=\"math inline\">\\(2\\pi/84\\)</span>), shows\r\nthe results of trying various (the century is omitted from the dates).\r\nThe last place of decimals for the <span class=\"math inline\">\\(\\rho(\\tau)\\)</span> is not reliable, but of course\r\ngets better as the size of the entry <span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span> increases: I give the\r\nnumbers as they came, and they speak for themselves. <span class=\"math inline\">\\(\\tau=6\\)</span> is included, though the\r\nproportionate error in <span class=\"math inline\">\\(\\delta^{*}\\)</span>\r\nis then considerable.<a href=\"#fn12\" class=\"footnote-ref\" id=\"fnref12\" role=\"doc-noteref\"><sup>12</sup></a> For <span class=\"math inline\">\\(t_{0}=13\\)</span> <span class=\"math inline\">\\(\\rho\\)</span> goes on to 34.8 at <span class=\"math inline\">\\(\\tau=27\\)</span>; for <span class=\"math inline\">\\(t_{0}=16\\)</span> it goes to 38.2 at <span class=\"math inline\">\\(\\tau= 24\\)</span>. Once the data the smooth curve\r\nvalues were assembled the calculations took a mere hour or so with a\r\nslide-rule. The date 1822-4 seems about the 'best' <span class=\"math inline\">\\(t_{0}\\)</span>.</p>\r\n<style>\r\n    body {text-align: center;} table{margin: auto;}\r\n</style>\r\n<table>\r\n<tr>\r\n<td>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 13\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 16\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 19\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 22\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 22.4\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 25\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 28\\)</span>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n<span class=\"math inline\">\\(\\tau\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n6\r\n</td>\r\n<td>\r\n0.6\r\n</td>\r\n<td>\r\n3.0\r\n</td>\r\n<td>\r\n1.0\r\n</td>\r\n<td>\r\n5.1\r\n</td>\r\n<td>\r\n3.6\r\n</td>\r\n<td>\r\n18.3\r\n</td>\r\n<td>\r\n9.2\r\n</td>\r\n<td>\r\n47.0\r\n</td>\r\n<td>\r\n10.6\r\n</td>\r\n<td>\r\n53.8\r\n</td>\r\n<td>\r\n18.2\r\n</td>\r\n<td>\r\n92.5\r\n</td>\r\n<td>\r\n20.4\r\n</td>\r\n<td>\r\n103\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n9\r\n</td>\r\n<td>\r\n1.8\r\n</td>\r\n<td>\r\n4.1\r\n</td>\r\n<td>\r\n3.9\r\n</td>\r\n<td>\r\n9.0\r\n</td>\r\n<td>\r\n10.7\r\n</td>\r\n<td>\r\n24.6\r\n</td>\r\n<td>\r\n23.2\r\n</td>\r\n<td>\r\n53.3\r\n</td>\r\n<td>\r\n25.0\r\n</td>\r\n<td>\r\n57.6\r\n</td>\r\n<td>\r\n34.5\r\n</td>\r\n<td>\r\n79.3\r\n</td>\r\n<td>\r\n41.1\r\n</td>\r\n<td>\r\n94\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n12\r\n</td>\r\n<td>\r\n5.3\r\n</td>\r\n<td>\r\n7.6\r\n</td>\r\n<td>\r\n11.9\r\n</td>\r\n<td>\r\n15.8\r\n</td>\r\n<td>\r\n25.0\r\n</td>\r\n<td>\r\n33.2\r\n</td>\r\n<td>\r\n39.8\r\n</td>\r\n<td>\r\n53.0\r\n</td>\r\n<td>\r\n42.2\r\n</td>\r\n<td>\r\n56.1\r\n</td>\r\n<td>\r\n55.9\r\n</td>\r\n<td>\r\n74.4\r\n</td>\r\n<td>\r\n64.7\r\n</td>\r\n<td>\r\n86\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n15\r\n</td>\r\n<td>\r\n13.7\r\n</td>\r\n<td>\r\n12.1\r\n</td>\r\n<td>\r\n26.6\r\n</td>\r\n<td>\r\n23.5\r\n</td>\r\n<td>\r\n42.0\r\n</td>\r\n<td>\r\n37.1\r\n</td>\r\n<td>\r\n61.5\r\n</td>\r\n<td>\r\n54.4\r\n</td>\r\n<td>\r\n64.0\r\n</td>\r\n<td>\r\n56.5\r\n</td>\r\n<td>\r\n79.8\r\n</td>\r\n<td>\r\n70.5\r\n</td>\r\n<td>\r\n91(e)\r\n</td>\r\n<td>\r\n80.6(e)\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n18\r\n</td>\r\n<td>\r\n29.3\r\n</td>\r\n<td>\r\n18.8\r\n</td>\r\n<td>\r\n44.2\r\n</td>\r\n<td>\r\n28.4\r\n</td>\r\n<td>\r\n64.1\r\n</td>\r\n<td>\r\n41.2\r\n</td>\r\n<td>\r\n85.8\r\n</td>\r\n<td>\r\n55.2\r\n</td>\r\n<td>\r\n88.6\r\n</td>\r\n<td>\r\n57.0\r\n</td>\r\n<td>\r\n106(e)\r\n</td>\r\n<td>\r\n86.3(e)\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n21\r\n</td>\r\n<td>\r\n48.3\r\n</td>\r\n<td>\r\n24.1\r\n</td>\r\n<td>\r\n67.2\r\n</td>\r\n<td>\r\n36.6\r\n</td>\r\n<td>\r\n89.0\r\n</td>\r\n<td>\r\n45.5\r\n</td>\r\n<td>\r\n113(e)\r\n</td>\r\n<td>\r\n56.5(e)\r\n</td>\r\n<td>\r\n116(e)\r\n</td>\r\n<td>\r\n58.0(e)\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n</tr>\r\n<caption>\r\nTable II\r\n</caption>\r\n</table>\r\n<p>We need fairly large <span class=\"math inline\">\\(\\tau\\)</span> for\r\n<span class=\"math inline\">\\(\\delta^{*}(\\tau)\\)</span> to have enough\r\nignificant figures, and further to provide a range showing up whether\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span> is constant or not. And\r\nwe need room to manoeuvre round the final. So the method depends on the\r\n'luck' that 1822 falls comfortably inside the period of observation\r\n1780-1840. But some luck was needed in any case.</p>\r\n<p>It is an important point that the method is quite indifferent to how\r\nwell <span class=\"math inline\">\\(E_{B}\\)</span> does its originally\r\nintended job, and <strong><em>we do not need to know (and I don't knoiv)\r\nits elements</em></strong>; it is enough to know the 'discrepancy' with\r\n<strong><em>some</em></strong>, 'unknown', orbit (not too bad of\r\ncourse). On the other hand the method ostentatiously says nothing at all\r\nabout the mass or distance of <span class=\"math inline\">\\(N\\)</span>. I\r\nwill add something on this. With <span class=\"math inline\">\\(e\\)</span>-terms ignored <span class=\"math inline\">\\(\\vartheta(\\tau)/m\\)</span> can be calculated\r\n<strong><em>exactly</em></strong> for any given value of <span class=\"math inline\">\\(\\lambda=a/a_{1}\\)</span> (ratio of the <span class=\"math inline\">\\(a\\)</span>'s of <span class=\"math inline\">\\(U\\)</span> and <span class=\"math inline\">\\(N\\)</span>)<a href=\"#fn13\" class=\"footnote-ref\" id=\"fnref13\" role=\"doc-noteref\"><sup>13</sup></a> The idea would be to\r\ntry different <span class=\"math inline\">\\(A\\)</span>'s, each <span class=\"math inline\">\\(A\\)</span> to give a best fitting <span class=\"math inline\">\\(m\\)</span>, and to take the best fitting\r\n<strong><em>pair</em></strong> <span class=\"math inline\">\\(\\lambda,\r\nm\\)</span>. This fails, because the greater part of <span class=\"math inline\">\\(\\vartheta\\)</span> is of the form <span class=\"math inline\">\\(b^{\\prime}(n\\tau - \\sin n\\tau)\\)</span>, and <span class=\"math inline\">\\(b^{\\prime}\\)</span> is smothered by the <span class=\"math inline\">\\(a, b, c, d\\)</span> of <span class=\"math inline\">\\(\\theta^{*} - \\theta_{B}\\)</span>, which depend on\r\nthe unknown elements of <span class=\"math inline\">\\(E_{B}\\)</span>\r\n(<span class=\"math inline\">\\(\\vartheta\\)</span> is smothered by the\r\n'unknown' <span class=\"math inline\">\\(\\theta^{*} - \\theta_{B}\\)</span>).\r\nIf we knew these elements (or equivalently the raw <span class=\"math inline\">\\(\\theta\\)</span>) we might be able to go on. They\r\ncould be recovered from the Paris Observatory archives; but this article\r\nis a last moment addition to the book, I do not feel that I am on full\r\nprofessional duty, and in any case we should be losing the light-hearted\r\nnote of our adventure.</p>\r\n<p>The time <span class=\"math inline\">\\(t\\)</span> once known, it would\r\nbe necessary to guess a value for <span class=\"math inline\">\\(N\\)</span>'s distance <span class=\"math inline\">\\(a_{1}\\)</span>; <span class=\"math inline\">\\(N\\)</span>'s period is then <span class=\"math inline\">\\(84(a_{1}/a)^{\\frac{3}{2}}\\)</span> years, and we\r\ncould 'predict' <span class=\"math inline\">\\(N\\)</span>'s place in 1846.\r\nThe obvious first guess in 1846 was <span class=\"math inline\">\\(a_{l}/a=2\\)</span>, following Bode's empirical\r\nlaw, to which N is maliciously the first exception, the true value being\r\n1.58. Adams and le Verrier started with 2 (Adams coming down to 1.942\r\nfor a second round). Since from our standpoint<a href=\"#fn14\" class=\"footnote-ref\" id=\"fnref14\" role=\"doc-noteref\"><sup>14</sup></a>\r\ntoo large an <span class=\"math inline\">\\(a_{1}\\)</span> has\r\ndisproportionately bad results as against one too small, it would be\r\nreasonable to try 1.8. This would give a prediction (for 1846) about\r\n10<span class=\"math inline\">\\(^{\\circ}\\)</span> out, but the sweep\r\nneeded would be wholly practicable.</p>\r\n<p>Le Verrier was less than 1<span class=\"math inline\">\\(^{\\circ}\\)</span> out (Adams between 2<span class=\"math inline\">\\(^{\\circ}\\)</span> and 3<span class=\"math inline\">\\(^{\\circ}\\)</span>); 'they pointed the telescope\r\nand saw the planet'. This very close, and double, prediction is a\r\ncuriosity. All the observations from 1780 to 1840 were used, and on an\r\nequal footing, and the theory purported to say where <span class=\"math inline\">\\(N\\)</span> was over this whole stretch. With a\r\nwrong <span class=\"math inline\">\\(a_{1}\\)</span> they could be right at\r\n1840 only by being wrong at 1780. With Adams's <span class=\"math inline\">\\(a_{1}=1.94a\\)</span> <span class=\"math inline\">\\(N\\)</span>'s period (which depends on <span class=\"math inline\">\\(a_{1}\\)</span> only) would be 227 years; he would\r\nhave been wrong by 30<span class=\"math inline\">\\(^{\\circ}\\)</span> for\r\n1780 if the orbit were circular, and so the angular velocity uniform.\r\nBut faced with a wrong <span class=\"math inline\">\\(a_{1}\\)</span> the\r\nmethod responded gallantly by putting up a large eccentricity (<span class=\"math inline\">\\(\\frac{1}{8}\\)</span>), and assigning perihelion to\r\nthe place of conjunction. The combination makes the effective distance\r\nfrom <span class=\"math inline\">\\(S\\)</span> over the critical stretch\r\nmore like <span class=\"math inline\">\\(1.7 a_{l}\\)</span>, and the\r\nresulting error at 1780 (the worst one) was only 18. (A mass 2.8 times\r\ntoo large was a more obvious adjustment.)</p>\r\n<p>In much more recent times small discrepancies for <span class=\"math inline\">\\(N\\)</span> and <span class=\"math inline\">\\(U\\)</span> (<span class=\"math inline\">\\(U\\)</span>'s being in fact the more manageable\r\nones) were analysed for a trans-Neptunian planet, and the planet Pluto\r\nwas found in 1930 near the predicted place. This was a complete fluke:\r\nPluto has a mass probably no more than <span class=\"math inline\">\\(\\frac{1}{10}\\)</span> of the Earth's; any effects\r\nit could have on <span class=\"math inline\">\\(N\\)</span> and <span class=\"math inline\">\\(U\\)</span> would be hopelessly swamped by the\r\nobservational errors.</p>\r\n<p>It remains for me to give the (school mathematics) proof of (1)\r\nabove. Call <span class=\"math inline\">\\(e_{1} - e_{2}\\)</span> <span class=\"math inline\">\\(\\Delta e\\)</span>, and so on. I said above that\r\nall <span class=\"math inline\">\\(\\Delta\\)</span>'s were <span class=\"math inline\">\\(O(m)\\)</span>: this is not quite true, though my\r\ndeception has been in the reader's best interests, and will not have led\r\nhim astray.<a href=\"#fn15\" class=\"footnote-ref\" id=\"fnref15\" role=\"doc-noteref\"><sup>15</sup></a> It is true, and common sense, for\r\n<span class=\"math inline\">\\(\\Delta a\\)</span>, <span class=\"math inline\">\\(\\Delta e\\)</span>, <span class=\"math inline\">\\(\\Delta n\\)</span>, and <span class=\"math inline\">\\(\\Delta \\epsilon\\)</span>. But the 'effect' of a\r\ngiven Aa vanishes when <span class=\"math inline\">\\(e=0\\)</span>, and is\r\nproportional to <span class=\"math inline\">\\(e\\)</span>. So it is <span class=\"math inline\">\\(e\\Delta \\alpha\\)</span>, not <span class=\"math inline\">\\(\\Delta \\alpha\\)</span>, that is comparable with\r\nthe other <span class=\"math inline\">\\(\\Delta\\)</span>'s and so <span class=\"math inline\">\\(O(m)\\)</span>.<a href=\"#fn16\" class=\"footnote-ref\" id=\"fnref16\" role=\"doc-noteref\"><sup>16</sup></a></p>\r\n<p>We start from two well-known formulae. The first is geometrical; the\r\npolar equation of the ellipse of the orbit is</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nr = a(1- e^{2}) ( 1 +e \\cos (\\theta -a))^{-1}\r\n\\end{equation}\\]</span></p>\r\n<p>The second is dynamical; the equation of angular momentum (Kepler's\r\nsecond law) is</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}r^{2} \\frac{d\\theta}{dt}\r\n= na^{2} (1-e^{2})^{\\frac{1}{2}}\\end{equation}\\]</span></p>\r\n<p>So, using dots for time differentiations,</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\theta = n(1-e^{2})^{-\\frac{3}{2}} [1 - 2\\cos (\\theta -a) + 3e^{2}\r\n\\cos^{2} (\\theta -a ) + \\cdots]\r\n\\end{equation}\\]</span></p>\r\n<p>The first approximation (with <span class=\"math inline\">\\(e=0\\)</span>) is <span class=\"math inline\">\\(\\theta=nt + \\epsilon\\)</span>. We take suffixes 1\r\nand 2 in (6) and operate with <span class=\"math inline\">\\(\\Delta\\)</span>, remembering that we may take\r\nfirst approximations in any <strong><em>factor</em></strong> of an <span class=\"math inline\">\\(m\\)</span>.</p>\r\n<p>In estimating <span class=\"math inline\">\\(\\Delta\\theta\\)</span> we\r\nmay, with error <span class=\"math inline\">\\(O(em)\\)</span>, ignore the\r\nfactor <span class=\"math inline\">\\((1-e^{2})^{-\\frac{3}{2}}\\)</span> in\r\n(6), since it is itself <span class=\"math inline\">\\(\\left(1+O(e^{2})\\right)\\)</span>, and its <span class=\"math inline\">\\(\\Delta\\)</span> is <span class=\"math inline\">\\(O(e\\Delta e)=O(em)\\)</span>. We have, therefore,\r\nwith error <span class=\"math inline\">\\(O(em)\\)</span>,</p>\r\n<p><span class=\"math display\">\\[\\Delta \\theta = \\Delta \\left\\{n[\\quad\r\n]\\right\\} = [\\quad ] \\Delta n + n \\Delta [\\quad ]\\]</span></p>\r\n<p>The 1st term is <span class=\"math inline\">\\(\\Delta n+O(em)\\)</span>.\r\nThe 2nd is</p>\r\n<p><span class=\"math display\">\\[n\\left[\\Delta e \\left\\{- 2 \\cos(\\theta\r\n-a ) + O(e)\\right\\} + \\Delta (\\theta -a ) \\left\\{2e \\sin (\\theta -a ) +\r\nO(e^{2}\\right\\}\\right]\\]</span></p>\r\n<p>and we may drop the <span class=\"math inline\">\\(\\theta\\)</span> in\r\n<span class=\"math inline\">\\(\\Delta (\\theta - a)\\)</span> on account of\r\nthe factor <span class=\"math inline\">\\(O(\\epsilon)\\)</span>. Summing up,\r\nwe obtain</p>\r\n<p><span class=\"math display\">\\[\\Delta \\theta = m (A+B \\cos (\\theta -a )\r\n+ C \\sin (\\theta -a ) ) + O(em)\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(mA=\\Delta n\\)</span>, <span class=\"math inline\">\\(mB = -2n\\Delta e\\)</span>, <span class=\"math inline\">\\(mC = -2n(e\\Delta a)\\)</span>. Substituting the\r\nfirst approximation <span class=\"math inline\">\\(\\theta=nt +\r\n\\epsilon\\)</span> in the right hand side, we have</p>\r\n<p><span class=\"math display\">\\[\\Delta \\theta = m (A+B \\cos (nt +\r\n\\epsilon -a ) + C \\sin (nt + \\epsilon -a ) ) + O(em)\\]</span></p>\r\n<p>and integration then gives</p>\r\n<p><span class=\"math display\">\\[\\Delta \\theta = m (A+B/n \\sin (nt +\r\n\\epsilon -a ) - C/n \\cos (nt + \\epsilon -a ) ) + O(em)\\]</span></p>\r\n<p>which, after expanding the sin and cos and rearranging, is of the\r\ndesired form (I).<a href=\"#fn17\" class=\"footnote-ref\" id=\"fnref17\" role=\"doc-noteref\"><sup>17</sup></a></p>\r\n<section id=\"footnotes\" class=\"footnotes footnotes-end-of-document\" role=\"doc-endnotes\">\r\n<hr>\r\n<ol>\r\n<li id=\"fn1\"><p>Its attachment to the '3-body problem' misleads people\r\nto-day.<a href=\"#fnref1\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn2\"><p>The time at which NUS is a straight line (I shall use\r\nthe abbreviations S, U, N).<a href=\"#fnref2\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn3\"><p>It does not depend on <span class=\"math inline\">\\(e\\)</span>.<a href=\"#fnref3\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn4\"><p>The total area of the ellipse is <span class=\"math inline\">\\(\\pi ab\\)</span>, and it is swept out in time <span class=\"math inline\">\\(p\\)</span>.<a href=\"#fnref4\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn5\"><p>Strictly speaking the a.m. should have the planet's mass\r\nas a factor: but <span class=\"math inline\">\\(U\\)</span>'s mass is\r\nirrelevant and I omit it throughout.<a href=\"#fnref5\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn6\"><p>Observations after 1840 were not immediately available,\r\nand anyhow were not used. Uranus was discovered in 1781. Lest the reader\r\nshould be worried by small inconsistencies in my dates I mention that\r\n1780 is 'used', the extrapolation being a safe one.<a href=\"#fnref6\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn7\"><p><strong><em>Collected Works, I</em></strong>, p. 11.\r\nThese (and not the modifications he introduces, which are what appear in\r\nSmart) are what is relevant for us.<a href=\"#fnref7\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn8\"><p>I should stress that there is no question of ignoring\r\neven high powers of <span class=\"math inline\">\\(e\\)</span>\r\n<strong><em>unaccompanied by a factor <span class=\"math inline\">\\(m\\)</span></em></strong> (<span class=\"math inline\">\\(e^{4}\\)</span> radians is about 1\"). The\r\ndistortion in the value found for <span class=\"math inline\">\\(t\\)</span>\r\nis, however, a sort of exception to this. But the effect of <span class=\"math inline\">\\(e\\)</span>'s in distorting <span class=\"math inline\">\\(t_{0}\\)</span> is unlikely to be worse than the\r\nseparation they create between time of conjunction and time of closest\r\napproach. An easy calculation shows that this last time difference is at\r\nworst 0-8 years.<a href=\"#fnref8\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn9\"><p>The orbits may have 'Suns' of masses differing by <span class=\"math inline\">\\(O(m)\\)</span>.<a href=\"#fnref9\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn10\"><p>We allow, of course, <strong><em>negative</em></strong>\r\nvalues of <span class=\"math inline\">\\(t - t_{0}\\)</span> both in <span class=\"math inline\">\\(E^{*}\\)</span> and in <span class=\"math inline\">\\(\\vartheta\\)</span>.<a href=\"#fnref10\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn11\"><p>'<span class=\"math inline\">\\(\\Omega\\)</span>' is a\r\ndeputy for '<span class=\"math inline\">\\(O\\)</span>' (initial of 'odd'),\r\nwhich is otherwise engaged. The italicized statement in the text is true\r\n'by symmetry': alternatively, <strong><em>reverse</em></strong> the\r\nmotions from time <span class=\"math inline\">\\(t_{0}\\)</span>. (The\r\nargument covers also the 'perturbation of 'the Sun' which is not so\r\ncompletely negligible as might be supposed.)<a href=\"#fnref11\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn12\"><p>And the, values for <span class=\"math inline\">\\(\\tau=6\\)</span> at <span class=\"math inline\">\\(t_{0}=22, 22.4\\)</span> are more uncertain than\r\nusual because of a crisis in the smooth curve.<a href=\"#fnref12\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn13\"><p>From two second order differential equations. The\r\nformula involves 'quadratures', but in numerical calculation integration\r\nis quicker than multiplication. It would be comparatively easy to make a\r\ndouble entry table for <span class=\"math inline\">\\(\\vartheta(\\tau,\r\n\\lambda)/m\\)</span><a href=\"#fnref13\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn14\"><p>Perturbation theory calculations have necessarily to\r\n<strong><em>begin</em></strong> by guessing <span class=\"math inline\">\\(a_{1}\\)</span>; our guess need only be at the\r\nend.<a href=\"#fnref14\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn15\"><p>'Wen Gott betrugt is wohl betrogon.'<a href=\"#fnref15\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn16\"><p>This twist makes the 'obvious' approach of using the\r\nweil known expansion <span class=\"math display\">\\[\\theta = nt +\\epsilon\r\n+ 2e \\sin (nt + \\epsilon -a) + \\frac{5}{4}e^{2} \\sin 2 (nt + \\epsilon -a\r\n) + \\cdots\\]</span> slightly tricky; we should have to keep the term in\r\n<span class=\"math inline\">\\(e^{2}\\)</span>. The line taken in the text\r\nside-steps this.<a href=\"#fnref16\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn17\"><p>We have treated <span class=\"math inline\">\\(\\Delta\r\nn\\)</span> and <span class=\"math inline\">\\(\\Delta a\\)</span> as\r\nindependent (the latter happens not to occur in the final formula for\r\n<span class=\"math inline\">\\(\\Delta \\theta\\)</span>): this amounts to\r\nallowing different masses to the two 'Suns'. The point is relevant to\r\ncertain subtleties, into which I will not enter.<a href=\"#fnref17\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n</ol>\r\n</section>\r\n","site":{"data":{}},"excerpt":"","more":"<p>Neptune was discovered in 1846 as a result of mathematical\r\ncalculation, done independently and practically simultaneously by Adams\r\nand le Verrier. The full story abounds in unexpected twists, and is\r\ncomplicated by personal matters, some of them rather painful. There is a\r\nfascinating account in Professor W. M. Smart's <strong><em>John Couch\r\nAdams and the Discovery of Neptune</em></strong>, published by the Royal\r\nAstronomical Society, 1947. I am concerned only with limited parts of\r\nthe field.</p>\r\n<p>To refresh the reader's memory of what has been said from time to\r\ntime about the discovery I will begin with some representative\r\nquotations. In <strong><em>The Story of the Heavens</em></strong> (1886)\r\nSir Robert Ball has passages:' the name of le Verrier rose to a pinnacle\r\nhardly surpassed in any age or country' ... 'profound meditations for\r\nmany months' ... 'long tand arduous labour guided by consummate\r\nmathematical artifice'. The author is not above a bit of popular appeal\r\nin this book —— 'if the ellipse has not the perfect simplicity of the\r\ncircle, it has at least the charm of variety ... an outline of perfect\r\ngrace, and an association with ennobling conceptions' —— but on Neptune\r\nhe is speaking as a professional. An excellent modern book on the\r\nhistory of astronomy has, so late as 1938:' probably the most daring\r\nmathematical enterprise of the century ... this amazing task, like which\r\nnothing had ever been attempted before'.</p>\r\n<p>The immediate reaction was natural enough. Celestial Mechanics in\r\ngeneral, and the theory of perturbations in particular, had developed\r\ninto a very elaborate and high-brow subject; the problem of explaining\r\nthe misbehaviour of Uranus by a new planet was one of 'inverse' theory,\r\nand the common feeling was that the problem was difficult up to or\r\nbeyond the point of impossibility. One might speculate at some length on\r\nreasons for this opinion (one, perhaps was confusion between different\r\nmeanings of the technica term 'insoluble'<a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a>).\r\nWhen Adams and le Verrier provec the opinion wrong (and after all\r\n<strong><em>any</em></strong> mathematical proof is a debunking of\r\nsorts) there was still something to be said for the principle that\r\ndifficulties are what they seem before the event, not after. Certainly\r\nno one would grudge them their resounding fame. (Nor grudge, at a lower\r\nlevel, the luck of a discovery which makes a more sensational impact\r\nthan its actual difficulty strictly merits; in point of fact this luck\r\nnever does happen to the second-rate.) If the discovery has had a very\r\nlong run one must remember that there is a time-lag ; people cannot be\r\nalways reconsidering opinions, and having said something once even the\r\nmost intelligent tend to go on repeating it. The phrase was still in\r\nvogue that 'only 3 people understand Relativity' at a time when\r\nEddington was complaining that the trouble about Relativity as an\r\nexamination subject in 'Part III' was that it was such a soft\r\noption.</p>\r\n<p>In what I am going to say I am far from imputing stupidity to people\r\ncertainly less stupid than myself. My little <strong><em>jeuz\r\nd'esprit</em></strong> are not going to hurt anyone, and I refuse to be\r\ndeterred by the fear of being thought disrespectful to great men. I have\r\nnot been alone in a lurking suspicion that a much simpler approach might\r\nsucceed. On the one hand, aim at the minimum needed to make\r\nobservational discovery practicable; specifically at the time <span class=\"math inline\">\\(t_{0}\\)</span> of conjunction.<a href=\"#fn2\" class=\"footnote-ref\" id=\"fnref2\" role=\"doc-noteref\"><sup>2</sup></a> On\r\nthe other, forget the high-brow and laborious perturbation theory, and\r\ntry 'school mathematics'. (I admit to the human weakness of being\r\nspurred on by the mild piquancy success would have.) To begin with I\r\nfound things oddly elusive (and incidentally committed some gross\r\nstupidities). In the end an absurdly simple line emerged: I can imagine\r\nits being called a dirty trick, nor would I deny that there is some\r\ntruth in the accusation. The only way to make my case is to carry out\r\nthe actual 'prediction' of <span class=\"math inline\">\\(t_{0}\\)</span>\r\nfrom the observational data, with all the cards on the table (so that\r\nanyone can check against unconscious or conscious faking). I will also\r\nwrite so as to take as many amateurs as possible with me on the little\r\nadventure.</p>\r\n<p>A planetary 'orbit' is an ellipse with the Sun <span class=\"math inline\">\\(S\\)</span> at a focus, and the radius vector <span class=\"math inline\">\\(SP\\)</span> sweeps out area at a constant rate\r\n(Kepler's second law). An orbit, given its plane, is defined by 4\r\nelements, <span class=\"math inline\">\\(a\\)</span>, <span class=\"math inline\">\\(e\\)</span>, <span class=\"math inline\">\\(\\alpha\\)</span>, <span class=\"math inline\">\\(\\epsilon\\)</span>. The first 3 define the\r\ngeometrical ellipse: <span class=\"math inline\">\\(a\\)</span> is the\r\nsemi-major axis; <span class=\"math inline\">\\(e\\)</span> the\r\neccentricity; <span class=\"math inline\">\\(\\alpha\\)</span> the longitude\r\nof perihelion, i.e. with the obvious polar coordinates <span class=\"math inline\">\\(r, \\theta\\)</span>, <span class=\"math inline\">\\(\\theta\\)</span> is the 'longitude' and <span class=\"math inline\">\\(\\theta=a\\)</span> when <span class=\"math inline\">\\(P\\)</span> is nearest <span class=\"math inline\">\\(S\\)</span> (at an end of the major axis). When we\r\nknow <span class=\"math inline\">\\(a\\)</span> we know the 'mean angular\r\nvelocity' <span class=\"math inline\">\\(n\\)</span> and the associated\r\nperiod <span class=\"math inline\">\\(p= 2 \\pi/n\\)</span>; <span class=\"math inline\">\\(n\\)</span> is in fact proportional to <span class=\"math inline\">\\(a^{-\\frac{1}{2}}\\)</span> (Kepler's third law)<a href=\"#fn3\" class=\"footnote-ref\" id=\"fnref3\" role=\"doc-noteref\"><sup>3</sup></a>; further the constant rate of area\r\nsweeping is <span class=\"math inline\">\\(\\frac{1}{2}abn\\)</span><a href=\"#fn4\" class=\"footnote-ref\" id=\"fnref4\" role=\"doc-noteref\"><sup>4</sup></a> and twice this rate is identical\r\nwith the angular momentum'<a href=\"#fn5\" class=\"footnote-ref\" id=\"fnref5\" role=\"doc-noteref\"><sup>5</sup></a> (a.m. for short); this\r\nhas the differential calculus formula <span class=\"math inline\">\\(r^{2}\\theta\\)</span>, and it also is of course\r\nconstant. The 4th element, the 'epoch' <span class=\"math inline\">\\(e\\)</span>, is needed to identify the origin of\r\n<span class=\"math inline\">\\(t\\)</span>; the exact definition is that\r\n<span class=\"math inline\">\\(\\theta= \\alpha\\)</span> (perihelion) occurs\r\nat the <span class=\"math inline\">\\(t\\)</span> for which <span class=\"math inline\">\\(nt+ \\epsilon = \\alpha\\)</span>.</p>\r\n<p><span class=\"math inline\">\\(U\\)</span>'s orbit has a period of 84\r\nyears, and an eccentricity <span class=\"math inline\">\\(e\\)</span> of\r\nabout <span class=\"math inline\">\\(\\frac{1}{20}\\)</span>. The effects of\r\nbodies other than <span class=\"math inline\">\\(S\\)</span> and <span class=\"math inline\">\\(N\\)</span> can be allowed for, after which we may\r\nsuppose that <span class=\"math inline\">\\(U\\)</span>, <span class=\"math inline\">\\(S\\)</span>, and the eventual <span class=\"math inline\">\\(N\\)</span> are the only bodies in the system; we\r\nmay also suppose (all this is common form) that the movements are all in\r\none plane. The values of <span class=\"math inline\">\\(\\theta\\)</span>\r\n(for <span class=\"math inline\">\\(U\\)</span>) at the various times <span class=\"math inline\">\\(t\\)</span> (we sometimes write <span class=\"math inline\">\\(\\theta(t)\\)</span> to emphasize that <span class=\"math inline\">\\(\\theta\\)</span> is 'at time <span class=\"math inline\">\\(t\\)</span>') may be regarded as the observational\r\nraw material (though of course the actual raw observations are made from\r\nthe Earth). The <span class=\"math inline\">\\(r\\)</span>'s for the various\r\n<span class=\"math inline\">\\(t\\)</span> are indirect and are much less\r\nwell determined.</p>\r\n<p>The position in 1845 was that no exact elliptic orbit would fit the\r\nobserved 6 over the whole stretch 1780 to 1840.<a href=\"#fn6\" class=\"footnote-ref\" id=\"fnref6\" role=\"doc-noteref\"><sup>6</sup></a> The\r\ndiscrepancies are very small, mostly a few seconds of arc (with a sudden\r\nswoop of about 90\",see Tablel). The ratio <span class=\"math inline\">\\(m\\)</span> of <span class=\"math inline\">\\(N\\)</span>'s mass to that of <span class=\"math inline\">\\(S\\)</span> (taken as 1) is actually about 1/19000\r\n(the Orders of magnitude fit since m radians is about 11\").</p>\r\n<p>In the absence of <span class=\"math inline\">\\(N\\)</span> the a.m.\r\n<span class=\"math inline\">\\(A\\)</span> is constant (as stated above\r\nalias of Kepler's second law); <strong><em>the actual <span class=\"math inline\">\\(N\\)</span> accelerates <span class=\"math inline\">\\(A\\)</span> at times earlier than <span class=\"math inline\">\\(t_{0}\\)</span> and decelerates it at later\r\ntimes</em></strong>. The graph of <span class=\"math inline\">\\(A\\)</span>\r\nagainst <span class=\"math inline\">\\(t\\)</span> therefore rises to a\r\nmaximum at <span class=\"math inline\">\\(t=t_{0}\\)</span>, and my first\r\nidea was that this would identify. So it would if all observations were\r\nwithout error (and the method would have the theoretical advantage of\r\nbeing unaffected by the eccentricities). But the value of <span class=\"math inline\">\\(A\\)</span> at time <span class=\"math inline\">\\(t\\)</span> depends on the <span class=\"math inline\">\\(r\\)</span> at time <span class=\"math inline\">\\(t\\)</span>, and the determinations of the <span class=\"math inline\">\\(A\\)</span>'s are consequently too uncertain.\r\nThough the method fails it rises from the ashes in another form. For\r\nthis a few more preliminaries are needed.</p>\r\n<p>The numerical data Adams and le Verrier had to work on were not the\r\nobserved <span class=\"math inline\">\\(\\theta\\)</span>'s themselves, but\r\nthe differences between the observed <span class=\"math inline\">\\(\\theta(t)\\)</span> and the <span class=\"math inline\">\\(\\theta_{B}(t)\\)</span> of an elliptic orbit\r\ncalculated by Bouvard; the 'discrepancy' <span class=\"math inline\">\\(\\delta(t)\\)</span> (<span class=\"math inline\">\\(\\delta\\)</span> for short) is <span class=\"math inline\">\\(\\delta(t)=\\theta(t)-\\theta_{B}(t)\\)</span>. [<span class=\"math inline\">\\(\\theta_{B} (t)\\)</span> depends on the 'elements'\r\nof <span class=\"math inline\">\\(E_{B}\\)</span>, and these are subject to\r\n'errors'. These errors are among the unknowns that the perturbation\r\ntheory has to determine: our method does not mind what they are, as we\r\nshall see.] Table I gives the raw <span class=\"math inline\">\\(S\\)</span>'s (given in Adams's paper<a href=\"#fn7\" class=\"footnote-ref\" id=\"fnref7\" role=\"doc-noteref\"><sup>7</sup></a>),\r\ntogether with the values got by running a smooth curve. The treatment of\r\nthe start of the sudden swoop down after the long flat stretch is a bit\r\nuncertain: I drew my curve and stuck to it (but faking would make no\r\nultimate difference). The differences show up the order of the\r\nobservational errors (which naturally improve with the years something\r\nseems to have gone badly wrong in 1789); these are absolute, not\r\nrelative (thus the probable absolute error in <span class=\"math inline\">\\(\\delta_{1} - \\delta_{2}\\)</span> is the same\r\nwhether <span class=\"math inline\">\\(\\delta_{1} - \\delta_{2}\\)</span> is\r\n0.5\" or 90\"). It is worth while to work to 0.1\" and to the number of\r\ndecimal places used in what follows, even though the last place is\r\ndoubtful.</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 7%\">\r\n<col style=\"width: 21%\">\r\n<col style=\"width: 20%\">\r\n<col style=\"width: 7%\">\r\n<col style=\"width: 20%\">\r\n<col style=\"width: 23%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">Year</th>\r\n<th style=\"text-align: center;\">Observed <span class=\"math inline\">\\(\\delta\\)</span></th>\r\n<th style=\"text-align: center;\">Smooth Curve</th>\r\n<th style=\"text-align: center;\">Year</th>\r\n<th style=\"text-align: center;\">Observed <span class=\"math inline\">\\(\\delta\\)</span></th>\r\n<th style=\"text-align: center;\">Smooth Curve</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1780</td>\r\n<td style=\"text-align: center;\">3.5</td>\r\n<td style=\"text-align: center;\">3.5</td>\r\n<td style=\"text-align: center;\">1813</td>\r\n<td style=\"text-align: center;\">22.0</td>\r\n<td style=\"text-align: center;\">22.8</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1783</td>\r\n<td style=\"text-align: center;\">8.5</td>\r\n<td style=\"text-align: center;\">8.5</td>\r\n<td style=\"text-align: center;\">1816</td>\r\n<td style=\"text-align: center;\">22.9</td>\r\n<td style=\"text-align: center;\">22.5</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1786</td>\r\n<td style=\"text-align: center;\">12.4</td>\r\n<td style=\"text-align: center;\">12.5</td>\r\n<td style=\"text-align: center;\">1819</td>\r\n<td style=\"text-align: center;\">20.7</td>\r\n<td style=\"text-align: center;\">22.0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1789</td>\r\n<td style=\"text-align: center;\">19.0</td>\r\n<td style=\"text-align: center;\">15.8</td>\r\n<td style=\"text-align: center;\">1822</td>\r\n<td style=\"text-align: center;\">21.0</td>\r\n<td style=\"text-align: center;\">21.0</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1792</td>\r\n<td style=\"text-align: center;\">18.7</td>\r\n<td style=\"text-align: center;\">18.3</td>\r\n<td style=\"text-align: center;\">1825</td>\r\n<td style=\"text-align: center;\">18.2</td>\r\n<td style=\"text-align: center;\">18.1</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1795</td>\r\n<td style=\"text-align: center;\">21.4</td>\r\n<td style=\"text-align: center;\">20.3</td>\r\n<td style=\"text-align: center;\">1828</td>\r\n<td style=\"text-align: center;\">10.8</td>\r\n<td style=\"text-align: center;\">10.3</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1798</td>\r\n<td style=\"text-align: center;\">21.0</td>\r\n<td style=\"text-align: center;\">21.6</td>\r\n<td style=\"text-align: center;\">1831</td>\r\n<td style=\"text-align: center;\">-4.0</td>\r\n<td style=\"text-align: center;\">-4.0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1801</td>\r\n<td style=\"text-align: center;\">22.2</td>\r\n<td style=\"text-align: center;\">22.4</td>\r\n<td style=\"text-align: center;\">1834</td>\r\n<td style=\"text-align: center;\">-20.8</td>\r\n<td style=\"text-align: center;\">-20.8</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1804</td>\r\n<td style=\"text-align: center;\">24.2</td>\r\n<td style=\"text-align: center;\">22.8</td>\r\n<td style=\"text-align: center;\">1837</td>\r\n<td style=\"text-align: center;\">-42.7</td>\r\n<td style=\"text-align: center;\">-42.5</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">1807</td>\r\n<td style=\"text-align: center;\">22.1</td>\r\n<td style=\"text-align: center;\">23.0</td>\r\n<td style=\"text-align: center;\">1840</td>\r\n<td style=\"text-align: center;\">-66.6</td>\r\n<td style=\"text-align: center;\">-66.6</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">1810</td>\r\n<td style=\"text-align: center;\">23.2</td>\r\n<td style=\"text-align: center;\">23.0</td>\r\n<td style=\"text-align: center;\">1843(e)</td>\r\n<td style=\"text-align: center;\"><span class=\"math inline\">\\(-\\)</span></td>\r\n<td style=\"text-align: center;\">-94.0</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>Table 1</p>\r\n<p>The value for 1843 is an extrapolation; results derived from it are\r\nlabelled '(e)'.</p>\r\n<p>An 'effect' due to <span class=\"math inline\">\\(N\\)</span> is of\r\n'order <span class=\"math inline\">\\(m\\)</span> in mathematical notation\r\n<span class=\"math inline\">\\(O(m)\\)</span>; if, for a particular quantity\r\n<span class=\"math inline\">\\(X\\)</span>, X$ denotes (calculated <span class=\"math inline\">\\(X\\)</span>) —— (observed <span class=\"math inline\">\\(X\\)</span>), then any <span class=\"math inline\">\\(\\Delta X\\)</span> is <span class=\"math inline\">\\(O(m)\\)</span>. The square of this (2nd order of\r\ninfinitesimals) is extremely minute and everyone neglects it\r\ninstinctively (if <span class=\"math inline\">\\(a\\)</span> watch loses 10\r\nseconds a day you don't try to correct for the further loss over the\r\nlost 10 seconds the cases are comparable). Next, an effect of <span class=\"math inline\">\\(N\\)</span> is what it would be if <span class=\"math inline\">\\(U\\)</span>, and also <span class=\"math inline\">\\(N\\)</span>, moved in circles,\r\n<strong><em>plus</em></strong> a 'correction' for the actual\r\neccentricities of the orbits. <span class=\"math inline\">\\(U\\)</span>'s\r\neccentricity <span class=\"math inline\">\\(e(\\frac{1}{20})\\)</span> is\r\nunusually large and it would be reasonable to expect <span class=\"math inline\">\\(N\\)</span>'s to be no larger (it is actually less\r\nthan <span class=\"math inline\">\\(\\frac{1}{100}\\)</span>). The <span class=\"math inline\">\\(e\\)</span>'s distort the 'circular' value of the\r\neffect by 5 per cent, (or say a maximum of 10 per cent.); the\r\n'distortion' of the effect is <span class=\"math inline\">\\(O(em)\\)</span>, the effect itself being <span class=\"math inline\">\\(O(m)\\)</span>. I propose to ignore things of order\r\n<span class=\"math inline\">\\(O(em)\\)</span><a href=\"#fn8\" class=\"footnote-ref\" id=\"fnref8\" role=\"doc-noteref\"><sup>8</sup></a>:\r\nthis is the first step in my argument. In particular, when we have\r\nsomething which is either some <span class=\"math inline\">\\(\\Delta\\)</span>, or <span class=\"math inline\">\\(m\\)</span> itself, multiplied by a factor, we can\r\nsubstitute first approximations (i.e. with <span class=\"math inline\">\\(e=0\\)</span>), or make convenient changes that are\r\n<span class=\"math inline\">\\(O(e)\\)</span>, in the factor.</p>\r\n<p>Suppose now that <span class=\"math inline\">\\(E_{l}, E_{2}\\)</span>\r\nare two (exact) elliptic orbits, yielding <span class=\"math inline\">\\(\\theta(t)\\)</span>'s that differ by amounts of the\r\nkind we are concerned with, differing, that is, by <span class=\"math inline\">\\(O(m)\\)</span>.<a href=\"#fn9\" class=\"footnote-ref\" id=\"fnref9\" role=\"doc-noteref\"><sup>9</sup></a> It is now the case that\r\nthe differences satisfy the equation</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\theta_{1} - \\theta_{2} = m( a + bt + c \\cos nt + d \\sin nt) + O(em)\r\n\\end{equation}\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(a, b, c, d\\)</span> are constants\r\ndepending on the two sets of elements of <span class=\"math inline\">\\(E_{1}, E_{2}\\)</span>, and (following our\r\nagreement about <strong><em>factors</em></strong> of <span class=\"math inline\">\\(m\\)</span>) <span class=\"math inline\">\\(n\\)</span>\r\nis any common approximation to the mean angular velocity. I will\r\npostpone the school mathentatics proof of this.</p>\r\n<p>Next, (i) let <span class=\"math inline\">\\(E^{*}\\)</span> be the\r\n'instantaneous orbit at time <span class=\"math inline\">\\(t_{0}\\)</span>', that is to say the orbit that\r\n<span class=\"math inline\">\\(U\\)</span> would describe if <span class=\"math inline\">\\(N\\)</span> were annihilated at time <span class=\"math inline\">\\(t_{0}\\)</span>: note that <span class=\"math inline\">\\(E^{*}\\)</span> shares with <span class=\"math inline\">\\(t_{0}\\)</span> the property of being 'unknown'.\r\n(ii) Let <span class=\"math inline\">\\(\\vartheta\\)</span> be the\r\nperturbation of the <span class=\"math inline\">\\(\\theta\\)</span> of <span class=\"math inline\">\\(U\\)</span> produced by <span class=\"math inline\">\\(N\\)</span> since time <span class=\"math inline\">\\(t_{0}\\)</span>.<a href=\"#fn10\" class=\"footnote-ref\" id=\"fnref10\" role=\"doc-noteref\"><sup>10</sup></a>\r\nThen if, at any time <span class=\"math inline\">\\(t\\)</span>, <span class=\"math inline\">\\(\\theta\\)</span> is (as usual) <span class=\"math inline\">\\(U\\)</span>'s longitude, <span class=\"math inline\">\\(\\theta_{B}\\)</span> is the longitude in the orbit\r\n<span class=\"math inline\">\\(E_{B}\\)</span>, and <span class=\"math inline\">\\(\\theta^{*}\\)</span> the longitude in the orbit\r\n<span class=\"math inline\">\\(E^{*}\\)</span>, we have <span class=\"math inline\">\\(\\vartheta = \\theta - \\theta^{*}\\)</span>, and\r\nso</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\delta(t) = \\theta - \\theta_{B} = (\\theta^{*} - \\theta_{B}) + \\vartheta\r\n\\end{equation}\\]</span></p>\r\n<p>Now everything in this has a factor <span class=\"math inline\">\\(m\\)</span>, and we may omit any stray <span class=\"math inline\">\\(O(em)\\)</span>'s. In particular, we may in\r\ncalculating <span class=\"math inline\">\\(\\vartheta\\)</span> drop any\r\n<span class=\"math inline\">\\(e\\)</span> terms. But this means that\r\n<strong><em>we can calculate <span class=\"math inline\">\\(\\vartheta\\)</span> as if both <span class=\"math inline\">\\(U\\)</span>'s and <span class=\"math inline\">\\(N\\)</span>'s orbits were circles</em></strong>.\r\nWhen, however, the orbits are circles, <strong><em><span class=\"math inline\">\\(\\vartheta\\)</span> has equal and opposite values\r\nat <span class=\"math inline\">\\(t\\)</span>'s on equal and opposite sides\r\nof <span class=\"math inline\">\\(t_{0}\\)</span></em></strong>; in other\r\nwords, <strong><em>if we write <span class=\"math inline\">\\(t=t_{0} +\r\n\\tau\\)</span>, then</em></strong></p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\vartheta(t) = \\Omega (\\tau)\r\n\\end{equation}\\]</span></p>\r\n<p><strong><em>where <span class=\"math inline\">\\(\\Omega (\\tau)\\)</span>\r\nis an odd<a href=\"#fn11\" class=\"footnote-ref\" id=\"fnref11\" role=\"doc-noteref\"><sup>11</sup></a> function of <span class=\"math inline\">\\(\\tau\\)</span>; i.e. <span class=\"math inline\">\\(\\Omega(-\\tau)=\r\n-\\Omega(\\tau)\\)</span>.</em></strong></p>\r\n<p>This, used in combination with (1) and (2), is the essential (and\r\nvery simple) point of the argument. The difference <span class=\"math inline\">\\(\\theta^{*} - \\theta_{B}\\)</span> is a special case\r\nof <span class=\"math inline\">\\(\\theta_{1} - \\theta_{2}\\)</span> in (1).\r\nWrite <span class=\"math inline\">\\(t=t_{0} + \\tau\\)</span> in (1) and\r\ncombine this with (2) and (3); this gives, ignoring <span class=\"math inline\">\\(O(em)\\)</span>'s,</p>\r\n<p><span class=\"math display\">\\[\\delta(t_{0} + \\tau) = m \\left\\{a + b\r\nt_{0} + b \\tau + c \\cos (nt_{0} + n \\tau) + d \\sin (nt_{0} + n \\tau)\r\n\\right\\} + \\Omega(\\tau)\\]</span></p>\r\n<p>Expanding the <span class=\"math inline\">\\(\\cos\\)</span> and <span class=\"math inline\">\\(\\sin\\)</span> of sums and rearranging we have\r\n(with new constants, whose values vary with but do not concern us)</p>\r\n<p><span class=\"math display\">\\[\\delta(t_{0} + \\tau) = A - B(1 - \\cos\r\nn\\tau) + \\left\\{C \\tau + D \\sin n\\tau +\r\n\\Omega(\\tau)\\right\\}\\]</span></p>\r\n<p><strong><em>The curly bracket is an odd function of <span class=\"math inline\">\\(\\tau\\)</span></em></strong>. Hence if we combine\r\nequal and opposite <span class=\"math inline\">\\(\\tau\\)</span> and\r\nconstruct <span class=\"math inline\">\\(\\delta^{*}(\\tau)\\)</span> and\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span> to satisfy</p>\r\n<p><span class=\"math display\">\\[\\delta^{*}(\\tau) = - \\frac{1}{2}\r\n\\left\\{\\delta(t_{0}+\\tau) + \\delta(t_{0}- \\tau) - 2 \\delta(t_{0})\r\n\\right\\}, \\rho(\\tau) = \\delta^{*}(\\tau)/(1-\\cos n\\tau)\\]</span></p>\r\n<p>we have <span class=\"math inline\">\\(\\delta^{*}(\\tau)=B( 1 - \\cos\r\nn\\tau)\\)</span>, and so $()=B $ for all <span class=\"math inline\">\\(\\tau\\)</span>. <strong><em>If, then, we are using\r\nthe right <span class=\"math inline\">\\(t_{0}\\)</span> the ratio p(r) must\r\ncome out constant</em></strong>: this is our method for identifying\r\n<span class=\"math inline\">\\(t_{0}\\)</span>. The actual value of <span class=\"math inline\">\\(t_{0}\\)</span> to the nearest year is 1822.</p>\r\n<p>Table II, in which the unit of time is 1 year (and the <span class=\"math inline\">\\(n\\)</span> of <span class=\"math inline\">\\(\\cos\r\nn\\tau\\)</span> is <span class=\"math inline\">\\(2\\pi/84\\)</span>), shows\r\nthe results of trying various (the century is omitted from the dates).\r\nThe last place of decimals for the <span class=\"math inline\">\\(\\rho(\\tau)\\)</span> is not reliable, but of course\r\ngets better as the size of the entry <span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span> increases: I give the\r\nnumbers as they came, and they speak for themselves. <span class=\"math inline\">\\(\\tau=6\\)</span> is included, though the\r\nproportionate error in <span class=\"math inline\">\\(\\delta^{*}\\)</span>\r\nis then considerable.<a href=\"#fn12\" class=\"footnote-ref\" id=\"fnref12\" role=\"doc-noteref\"><sup>12</sup></a> For <span class=\"math inline\">\\(t_{0}=13\\)</span> <span class=\"math inline\">\\(\\rho\\)</span> goes on to 34.8 at <span class=\"math inline\">\\(\\tau=27\\)</span>; for <span class=\"math inline\">\\(t_{0}=16\\)</span> it goes to 38.2 at <span class=\"math inline\">\\(\\tau= 24\\)</span>. Once the data the smooth curve\r\nvalues were assembled the calculations took a mere hour or so with a\r\nslide-rule. The date 1822-4 seems about the 'best' <span class=\"math inline\">\\(t_{0}\\)</span>.</p>\r\n<style>\r\n    body {text-align: center;} table{margin: auto;}\r\n</style>\r\n<table>\r\n<tr>\r\n<td>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 13\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 16\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 19\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 22\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 22.4\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 25\\)</span>\r\n</td>\r\n<td colspan=\"2\">\r\n<span class=\"math inline\">\\(t_{0} = 28\\)</span>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n<span class=\"math inline\">\\(\\tau\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(2\\delta^{*}(\\tau)\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n6\r\n</td>\r\n<td>\r\n0.6\r\n</td>\r\n<td>\r\n3.0\r\n</td>\r\n<td>\r\n1.0\r\n</td>\r\n<td>\r\n5.1\r\n</td>\r\n<td>\r\n3.6\r\n</td>\r\n<td>\r\n18.3\r\n</td>\r\n<td>\r\n9.2\r\n</td>\r\n<td>\r\n47.0\r\n</td>\r\n<td>\r\n10.6\r\n</td>\r\n<td>\r\n53.8\r\n</td>\r\n<td>\r\n18.2\r\n</td>\r\n<td>\r\n92.5\r\n</td>\r\n<td>\r\n20.4\r\n</td>\r\n<td>\r\n103\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n9\r\n</td>\r\n<td>\r\n1.8\r\n</td>\r\n<td>\r\n4.1\r\n</td>\r\n<td>\r\n3.9\r\n</td>\r\n<td>\r\n9.0\r\n</td>\r\n<td>\r\n10.7\r\n</td>\r\n<td>\r\n24.6\r\n</td>\r\n<td>\r\n23.2\r\n</td>\r\n<td>\r\n53.3\r\n</td>\r\n<td>\r\n25.0\r\n</td>\r\n<td>\r\n57.6\r\n</td>\r\n<td>\r\n34.5\r\n</td>\r\n<td>\r\n79.3\r\n</td>\r\n<td>\r\n41.1\r\n</td>\r\n<td>\r\n94\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n12\r\n</td>\r\n<td>\r\n5.3\r\n</td>\r\n<td>\r\n7.6\r\n</td>\r\n<td>\r\n11.9\r\n</td>\r\n<td>\r\n15.8\r\n</td>\r\n<td>\r\n25.0\r\n</td>\r\n<td>\r\n33.2\r\n</td>\r\n<td>\r\n39.8\r\n</td>\r\n<td>\r\n53.0\r\n</td>\r\n<td>\r\n42.2\r\n</td>\r\n<td>\r\n56.1\r\n</td>\r\n<td>\r\n55.9\r\n</td>\r\n<td>\r\n74.4\r\n</td>\r\n<td>\r\n64.7\r\n</td>\r\n<td>\r\n86\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n15\r\n</td>\r\n<td>\r\n13.7\r\n</td>\r\n<td>\r\n12.1\r\n</td>\r\n<td>\r\n26.6\r\n</td>\r\n<td>\r\n23.5\r\n</td>\r\n<td>\r\n42.0\r\n</td>\r\n<td>\r\n37.1\r\n</td>\r\n<td>\r\n61.5\r\n</td>\r\n<td>\r\n54.4\r\n</td>\r\n<td>\r\n64.0\r\n</td>\r\n<td>\r\n56.5\r\n</td>\r\n<td>\r\n79.8\r\n</td>\r\n<td>\r\n70.5\r\n</td>\r\n<td>\r\n91(e)\r\n</td>\r\n<td>\r\n80.6(e)\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n18\r\n</td>\r\n<td>\r\n29.3\r\n</td>\r\n<td>\r\n18.8\r\n</td>\r\n<td>\r\n44.2\r\n</td>\r\n<td>\r\n28.4\r\n</td>\r\n<td>\r\n64.1\r\n</td>\r\n<td>\r\n41.2\r\n</td>\r\n<td>\r\n85.8\r\n</td>\r\n<td>\r\n55.2\r\n</td>\r\n<td>\r\n88.6\r\n</td>\r\n<td>\r\n57.0\r\n</td>\r\n<td>\r\n106(e)\r\n</td>\r\n<td>\r\n86.3(e)\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n21\r\n</td>\r\n<td>\r\n48.3\r\n</td>\r\n<td>\r\n24.1\r\n</td>\r\n<td>\r\n67.2\r\n</td>\r\n<td>\r\n36.6\r\n</td>\r\n<td>\r\n89.0\r\n</td>\r\n<td>\r\n45.5\r\n</td>\r\n<td>\r\n113(e)\r\n</td>\r\n<td>\r\n56.5(e)\r\n</td>\r\n<td>\r\n116(e)\r\n</td>\r\n<td>\r\n58.0(e)\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n<td>\r\n<span class=\"math inline\">\\(-\\)</span>\r\n</td>\r\n</tr>\r\n<caption>\r\nTable II\r\n</caption>\r\n</table>\r\n<p>We need fairly large <span class=\"math inline\">\\(\\tau\\)</span> for\r\n<span class=\"math inline\">\\(\\delta^{*}(\\tau)\\)</span> to have enough\r\nignificant figures, and further to provide a range showing up whether\r\n<span class=\"math inline\">\\(\\rho(\\tau)\\)</span> is constant or not. And\r\nwe need room to manoeuvre round the final. So the method depends on the\r\n'luck' that 1822 falls comfortably inside the period of observation\r\n1780-1840. But some luck was needed in any case.</p>\r\n<p>It is an important point that the method is quite indifferent to how\r\nwell <span class=\"math inline\">\\(E_{B}\\)</span> does its originally\r\nintended job, and <strong><em>we do not need to know (and I don't knoiv)\r\nits elements</em></strong>; it is enough to know the 'discrepancy' with\r\n<strong><em>some</em></strong>, 'unknown', orbit (not too bad of\r\ncourse). On the other hand the method ostentatiously says nothing at all\r\nabout the mass or distance of <span class=\"math inline\">\\(N\\)</span>. I\r\nwill add something on this. With <span class=\"math inline\">\\(e\\)</span>-terms ignored <span class=\"math inline\">\\(\\vartheta(\\tau)/m\\)</span> can be calculated\r\n<strong><em>exactly</em></strong> for any given value of <span class=\"math inline\">\\(\\lambda=a/a_{1}\\)</span> (ratio of the <span class=\"math inline\">\\(a\\)</span>'s of <span class=\"math inline\">\\(U\\)</span> and <span class=\"math inline\">\\(N\\)</span>)<a href=\"#fn13\" class=\"footnote-ref\" id=\"fnref13\" role=\"doc-noteref\"><sup>13</sup></a> The idea would be to\r\ntry different <span class=\"math inline\">\\(A\\)</span>'s, each <span class=\"math inline\">\\(A\\)</span> to give a best fitting <span class=\"math inline\">\\(m\\)</span>, and to take the best fitting\r\n<strong><em>pair</em></strong> <span class=\"math inline\">\\(\\lambda,\r\nm\\)</span>. This fails, because the greater part of <span class=\"math inline\">\\(\\vartheta\\)</span> is of the form <span class=\"math inline\">\\(b^{\\prime}(n\\tau - \\sin n\\tau)\\)</span>, and <span class=\"math inline\">\\(b^{\\prime}\\)</span> is smothered by the <span class=\"math inline\">\\(a, b, c, d\\)</span> of <span class=\"math inline\">\\(\\theta^{*} - \\theta_{B}\\)</span>, which depend on\r\nthe unknown elements of <span class=\"math inline\">\\(E_{B}\\)</span>\r\n(<span class=\"math inline\">\\(\\vartheta\\)</span> is smothered by the\r\n'unknown' <span class=\"math inline\">\\(\\theta^{*} - \\theta_{B}\\)</span>).\r\nIf we knew these elements (or equivalently the raw <span class=\"math inline\">\\(\\theta\\)</span>) we might be able to go on. They\r\ncould be recovered from the Paris Observatory archives; but this article\r\nis a last moment addition to the book, I do not feel that I am on full\r\nprofessional duty, and in any case we should be losing the light-hearted\r\nnote of our adventure.</p>\r\n<p>The time <span class=\"math inline\">\\(t\\)</span> once known, it would\r\nbe necessary to guess a value for <span class=\"math inline\">\\(N\\)</span>'s distance <span class=\"math inline\">\\(a_{1}\\)</span>; <span class=\"math inline\">\\(N\\)</span>'s period is then <span class=\"math inline\">\\(84(a_{1}/a)^{\\frac{3}{2}}\\)</span> years, and we\r\ncould 'predict' <span class=\"math inline\">\\(N\\)</span>'s place in 1846.\r\nThe obvious first guess in 1846 was <span class=\"math inline\">\\(a_{l}/a=2\\)</span>, following Bode's empirical\r\nlaw, to which N is maliciously the first exception, the true value being\r\n1.58. Adams and le Verrier started with 2 (Adams coming down to 1.942\r\nfor a second round). Since from our standpoint<a href=\"#fn14\" class=\"footnote-ref\" id=\"fnref14\" role=\"doc-noteref\"><sup>14</sup></a>\r\ntoo large an <span class=\"math inline\">\\(a_{1}\\)</span> has\r\ndisproportionately bad results as against one too small, it would be\r\nreasonable to try 1.8. This would give a prediction (for 1846) about\r\n10<span class=\"math inline\">\\(^{\\circ}\\)</span> out, but the sweep\r\nneeded would be wholly practicable.</p>\r\n<p>Le Verrier was less than 1<span class=\"math inline\">\\(^{\\circ}\\)</span> out (Adams between 2<span class=\"math inline\">\\(^{\\circ}\\)</span> and 3<span class=\"math inline\">\\(^{\\circ}\\)</span>); 'they pointed the telescope\r\nand saw the planet'. This very close, and double, prediction is a\r\ncuriosity. All the observations from 1780 to 1840 were used, and on an\r\nequal footing, and the theory purported to say where <span class=\"math inline\">\\(N\\)</span> was over this whole stretch. With a\r\nwrong <span class=\"math inline\">\\(a_{1}\\)</span> they could be right at\r\n1840 only by being wrong at 1780. With Adams's <span class=\"math inline\">\\(a_{1}=1.94a\\)</span> <span class=\"math inline\">\\(N\\)</span>'s period (which depends on <span class=\"math inline\">\\(a_{1}\\)</span> only) would be 227 years; he would\r\nhave been wrong by 30<span class=\"math inline\">\\(^{\\circ}\\)</span> for\r\n1780 if the orbit were circular, and so the angular velocity uniform.\r\nBut faced with a wrong <span class=\"math inline\">\\(a_{1}\\)</span> the\r\nmethod responded gallantly by putting up a large eccentricity (<span class=\"math inline\">\\(\\frac{1}{8}\\)</span>), and assigning perihelion to\r\nthe place of conjunction. The combination makes the effective distance\r\nfrom <span class=\"math inline\">\\(S\\)</span> over the critical stretch\r\nmore like <span class=\"math inline\">\\(1.7 a_{l}\\)</span>, and the\r\nresulting error at 1780 (the worst one) was only 18. (A mass 2.8 times\r\ntoo large was a more obvious adjustment.)</p>\r\n<p>In much more recent times small discrepancies for <span class=\"math inline\">\\(N\\)</span> and <span class=\"math inline\">\\(U\\)</span> (<span class=\"math inline\">\\(U\\)</span>'s being in fact the more manageable\r\nones) were analysed for a trans-Neptunian planet, and the planet Pluto\r\nwas found in 1930 near the predicted place. This was a complete fluke:\r\nPluto has a mass probably no more than <span class=\"math inline\">\\(\\frac{1}{10}\\)</span> of the Earth's; any effects\r\nit could have on <span class=\"math inline\">\\(N\\)</span> and <span class=\"math inline\">\\(U\\)</span> would be hopelessly swamped by the\r\nobservational errors.</p>\r\n<p>It remains for me to give the (school mathematics) proof of (1)\r\nabove. Call <span class=\"math inline\">\\(e_{1} - e_{2}\\)</span> <span class=\"math inline\">\\(\\Delta e\\)</span>, and so on. I said above that\r\nall <span class=\"math inline\">\\(\\Delta\\)</span>'s were <span class=\"math inline\">\\(O(m)\\)</span>: this is not quite true, though my\r\ndeception has been in the reader's best interests, and will not have led\r\nhim astray.<a href=\"#fn15\" class=\"footnote-ref\" id=\"fnref15\" role=\"doc-noteref\"><sup>15</sup></a> It is true, and common sense, for\r\n<span class=\"math inline\">\\(\\Delta a\\)</span>, <span class=\"math inline\">\\(\\Delta e\\)</span>, <span class=\"math inline\">\\(\\Delta n\\)</span>, and <span class=\"math inline\">\\(\\Delta \\epsilon\\)</span>. But the 'effect' of a\r\ngiven Aa vanishes when <span class=\"math inline\">\\(e=0\\)</span>, and is\r\nproportional to <span class=\"math inline\">\\(e\\)</span>. So it is <span class=\"math inline\">\\(e\\Delta \\alpha\\)</span>, not <span class=\"math inline\">\\(\\Delta \\alpha\\)</span>, that is comparable with\r\nthe other <span class=\"math inline\">\\(\\Delta\\)</span>'s and so <span class=\"math inline\">\\(O(m)\\)</span>.<a href=\"#fn16\" class=\"footnote-ref\" id=\"fnref16\" role=\"doc-noteref\"><sup>16</sup></a></p>\r\n<p>We start from two well-known formulae. The first is geometrical; the\r\npolar equation of the ellipse of the orbit is</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\nr = a(1- e^{2}) ( 1 +e \\cos (\\theta -a))^{-1}\r\n\\end{equation}\\]</span></p>\r\n<p>The second is dynamical; the equation of angular momentum (Kepler's\r\nsecond law) is</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}r^{2} \\frac{d\\theta}{dt}\r\n= na^{2} (1-e^{2})^{\\frac{1}{2}}\\end{equation}\\]</span></p>\r\n<p>So, using dots for time differentiations,</p>\r\n<p><span class=\"math display\">\\[\\begin{equation}\r\n\\theta = n(1-e^{2})^{-\\frac{3}{2}} [1 - 2\\cos (\\theta -a) + 3e^{2}\r\n\\cos^{2} (\\theta -a ) + \\cdots]\r\n\\end{equation}\\]</span></p>\r\n<p>The first approximation (with <span class=\"math inline\">\\(e=0\\)</span>) is <span class=\"math inline\">\\(\\theta=nt + \\epsilon\\)</span>. We take suffixes 1\r\nand 2 in (6) and operate with <span class=\"math inline\">\\(\\Delta\\)</span>, remembering that we may take\r\nfirst approximations in any <strong><em>factor</em></strong> of an <span class=\"math inline\">\\(m\\)</span>.</p>\r\n<p>In estimating <span class=\"math inline\">\\(\\Delta\\theta\\)</span> we\r\nmay, with error <span class=\"math inline\">\\(O(em)\\)</span>, ignore the\r\nfactor <span class=\"math inline\">\\((1-e^{2})^{-\\frac{3}{2}}\\)</span> in\r\n(6), since it is itself <span class=\"math inline\">\\(\\left(1+O(e^{2})\\right)\\)</span>, and its <span class=\"math inline\">\\(\\Delta\\)</span> is <span class=\"math inline\">\\(O(e\\Delta e)=O(em)\\)</span>. We have, therefore,\r\nwith error <span class=\"math inline\">\\(O(em)\\)</span>,</p>\r\n<p><span class=\"math display\">\\[\\Delta \\theta = \\Delta \\left\\{n[\\quad\r\n]\\right\\} = [\\quad ] \\Delta n + n \\Delta [\\quad ]\\]</span></p>\r\n<p>The 1st term is <span class=\"math inline\">\\(\\Delta n+O(em)\\)</span>.\r\nThe 2nd is</p>\r\n<p><span class=\"math display\">\\[n\\left[\\Delta e \\left\\{- 2 \\cos(\\theta\r\n-a ) + O(e)\\right\\} + \\Delta (\\theta -a ) \\left\\{2e \\sin (\\theta -a ) +\r\nO(e^{2}\\right\\}\\right]\\]</span></p>\r\n<p>and we may drop the <span class=\"math inline\">\\(\\theta\\)</span> in\r\n<span class=\"math inline\">\\(\\Delta (\\theta - a)\\)</span> on account of\r\nthe factor <span class=\"math inline\">\\(O(\\epsilon)\\)</span>. Summing up,\r\nwe obtain</p>\r\n<p><span class=\"math display\">\\[\\Delta \\theta = m (A+B \\cos (\\theta -a )\r\n+ C \\sin (\\theta -a ) ) + O(em)\\]</span></p>\r\n<p>where <span class=\"math inline\">\\(mA=\\Delta n\\)</span>, <span class=\"math inline\">\\(mB = -2n\\Delta e\\)</span>, <span class=\"math inline\">\\(mC = -2n(e\\Delta a)\\)</span>. Substituting the\r\nfirst approximation <span class=\"math inline\">\\(\\theta=nt +\r\n\\epsilon\\)</span> in the right hand side, we have</p>\r\n<p><span class=\"math display\">\\[\\Delta \\theta = m (A+B \\cos (nt +\r\n\\epsilon -a ) + C \\sin (nt + \\epsilon -a ) ) + O(em)\\]</span></p>\r\n<p>and integration then gives</p>\r\n<p><span class=\"math display\">\\[\\Delta \\theta = m (A+B/n \\sin (nt +\r\n\\epsilon -a ) - C/n \\cos (nt + \\epsilon -a ) ) + O(em)\\]</span></p>\r\n<p>which, after expanding the sin and cos and rearranging, is of the\r\ndesired form (I).<a href=\"#fn17\" class=\"footnote-ref\" id=\"fnref17\" role=\"doc-noteref\"><sup>17</sup></a></p>\r\n<section id=\"footnotes\" class=\"footnotes footnotes-end-of-document\" role=\"doc-endnotes\">\r\n<hr>\r\n<ol>\r\n<li id=\"fn1\"><p>Its attachment to the '3-body problem' misleads people\r\nto-day.<a href=\"#fnref1\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn2\"><p>The time at which NUS is a straight line (I shall use\r\nthe abbreviations S, U, N).<a href=\"#fnref2\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn3\"><p>It does not depend on <span class=\"math inline\">\\(e\\)</span>.<a href=\"#fnref3\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn4\"><p>The total area of the ellipse is <span class=\"math inline\">\\(\\pi ab\\)</span>, and it is swept out in time <span class=\"math inline\">\\(p\\)</span>.<a href=\"#fnref4\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn5\"><p>Strictly speaking the a.m. should have the planet's mass\r\nas a factor: but <span class=\"math inline\">\\(U\\)</span>'s mass is\r\nirrelevant and I omit it throughout.<a href=\"#fnref5\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn6\"><p>Observations after 1840 were not immediately available,\r\nand anyhow were not used. Uranus was discovered in 1781. Lest the reader\r\nshould be worried by small inconsistencies in my dates I mention that\r\n1780 is 'used', the extrapolation being a safe one.<a href=\"#fnref6\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn7\"><p><strong><em>Collected Works, I</em></strong>, p. 11.\r\nThese (and not the modifications he introduces, which are what appear in\r\nSmart) are what is relevant for us.<a href=\"#fnref7\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn8\"><p>I should stress that there is no question of ignoring\r\neven high powers of <span class=\"math inline\">\\(e\\)</span>\r\n<strong><em>unaccompanied by a factor <span class=\"math inline\">\\(m\\)</span></em></strong> (<span class=\"math inline\">\\(e^{4}\\)</span> radians is about 1\"). The\r\ndistortion in the value found for <span class=\"math inline\">\\(t\\)</span>\r\nis, however, a sort of exception to this. But the effect of <span class=\"math inline\">\\(e\\)</span>'s in distorting <span class=\"math inline\">\\(t_{0}\\)</span> is unlikely to be worse than the\r\nseparation they create between time of conjunction and time of closest\r\napproach. An easy calculation shows that this last time difference is at\r\nworst 0-8 years.<a href=\"#fnref8\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn9\"><p>The orbits may have 'Suns' of masses differing by <span class=\"math inline\">\\(O(m)\\)</span>.<a href=\"#fnref9\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn10\"><p>We allow, of course, <strong><em>negative</em></strong>\r\nvalues of <span class=\"math inline\">\\(t - t_{0}\\)</span> both in <span class=\"math inline\">\\(E^{*}\\)</span> and in <span class=\"math inline\">\\(\\vartheta\\)</span>.<a href=\"#fnref10\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn11\"><p>'<span class=\"math inline\">\\(\\Omega\\)</span>' is a\r\ndeputy for '<span class=\"math inline\">\\(O\\)</span>' (initial of 'odd'),\r\nwhich is otherwise engaged. The italicized statement in the text is true\r\n'by symmetry': alternatively, <strong><em>reverse</em></strong> the\r\nmotions from time <span class=\"math inline\">\\(t_{0}\\)</span>. (The\r\nargument covers also the 'perturbation of 'the Sun' which is not so\r\ncompletely negligible as might be supposed.)<a href=\"#fnref11\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn12\"><p>And the, values for <span class=\"math inline\">\\(\\tau=6\\)</span> at <span class=\"math inline\">\\(t_{0}=22, 22.4\\)</span> are more uncertain than\r\nusual because of a crisis in the smooth curve.<a href=\"#fnref12\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn13\"><p>From two second order differential equations. The\r\nformula involves 'quadratures', but in numerical calculation integration\r\nis quicker than multiplication. It would be comparatively easy to make a\r\ndouble entry table for <span class=\"math inline\">\\(\\vartheta(\\tau,\r\n\\lambda)/m\\)</span><a href=\"#fnref13\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn14\"><p>Perturbation theory calculations have necessarily to\r\n<strong><em>begin</em></strong> by guessing <span class=\"math inline\">\\(a_{1}\\)</span>; our guess need only be at the\r\nend.<a href=\"#fnref14\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn15\"><p>'Wen Gott betrugt is wohl betrogon.'<a href=\"#fnref15\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn16\"><p>This twist makes the 'obvious' approach of using the\r\nweil known expansion <span class=\"math display\">\\[\\theta = nt +\\epsilon\r\n+ 2e \\sin (nt + \\epsilon -a) + \\frac{5}{4}e^{2} \\sin 2 (nt + \\epsilon -a\r\n) + \\cdots\\]</span> slightly tricky; we should have to keep the term in\r\n<span class=\"math inline\">\\(e^{2}\\)</span>. The line taken in the text\r\nside-steps this.<a href=\"#fnref16\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn17\"><p>We have treated <span class=\"math inline\">\\(\\Delta\r\nn\\)</span> and <span class=\"math inline\">\\(\\Delta a\\)</span> as\r\nindependent (the latter happens not to occur in the final formula for\r\n<span class=\"math inline\">\\(\\Delta \\theta\\)</span>): this amounts to\r\nallowing different masses to the two 'Suns'. The point is relevant to\r\ncertain subtleties, into which I will not enter.<a href=\"#fnref17\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n</ol>\r\n</section>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Nov 17 2024 04:30:59 GMT+0800 (中国标准时间)","title":"The Discovery of Neptune (By J.E. Littlewood)","path":"2023/04/04/The Discovery of Neptune/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-04-04T12:02:28.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-04-04T12:02:28.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Miscellanies","tags":["Miscellanies"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Naimark's Problem","date":"2023-04-10T00:21:52.000Z","mathjax":true,"_content":"\nWe list some open problems in C$^{*}$-algebra:\n\n## Question 1 (Naimark's Problem):  \nEvery C$^{*}$-algebra that has only one irreducible $*$-representation up to unitary equivalence is isomorphic to the $*$-algebra of compact operators on some (not necessarily separable) Hilbert space.\n\nWhether Naimark problem is  independent of $\\mathsf{ZFC}$?\n\nAkemann & Weaver (2004)[^1] used the $\\diamondsuit$-Principle to construct a C$^{*}$-algebra with $\\aleph _{1}$ generators that serves as a counterexample to Naimark's Problem. But in general its consistency remains unknown. \n\n[^1]: Akemann, Charles; Weaver, Nik (2004), \"Consistency of a counterexample to Naimark's problem\", Proceedings of the National Academy of Sciences of the United States of America, 101 (20): 7522–7525\n\n\n\n## Question 2:  \n\n\nEvery C$^{*}$-algebras of density of continuum $\\aleph_{1} = 2^{\\aleph_{0}}$ has no nonseparable commutative subalgebra.[^2]\n\nAkemann & Donner (1979) constructs example with a C$^{*}$-algebra with $\\aleph _{1}$ generators with only separable abelian C$^{*}$-subalgebras. Bice and Koszmider (2017)[^3] remove their assumption of the continuum hypothesis. Whether \n\n\n[^2]: C. Akemann and J. Doner, A nonseparable C$^{*}$-algebra with only separable abelian C$^{*}$-subalgebras. Bull. London Math. Soc. 11 (1979), no. 3, 279–284.\n\n[^3]: Bice, T., & Koszmider, P. (2017). A note on the Akemann-Doner and Farah-Wofsey constructions. Proceedings of the American Mathematical Society, 145(2), 681-687.\n\n\n<!-- more --> \n\n## Question 3:  \n\nEvery amenable operator algebra is isomorphic to a (necessarily nuclear) C$^{*}$-algebra.\n\n\nResolved. Choi, Farah, & Ozawa (2013) [^4] construct a counterexample to this problem in non-separable case, whereas separable case remains open.\n\n\n[^4]: Choi, Y., Farah, I., & Ozawa, N. (2014, February). A NONSEPARABLE AMENABLE OPERATOR ALGEBRA WHICH IS NOT ISOMORPHIC TO A-ALGEBRA. In Forum of Mathematics, Sigma (Vol. 2, p. e2). Cambridge University Press.\n\n\n## Question 4:  \n\nDo there exist non-discrete second countable locally compact groups which are C$^{*}$-simple?[^5]\n\n[^5]: Pierre de la Harpe, On simplicity of reduced C$^{*}$-algebras of groups, Bull. Lond. Math. Soc.\n\nResolved. Suzuki (2017).[^6] \n\n[^6]: Suzuki, Y. (2017). Elementary constructions of non-discrete 𝐶*-simple groups. Proceedings of the American Mathematical Society, 145(3), 1369-1371.\n\n\n# Reference\n\n[1] Naimark, M. A. (1948), \"Rings with involutions\", Uspekhi Mat. Nauk, 3: 52-145\n\n[2] Naimark, M. A. (1951), \"On a problem in the theory of rings with involution\", Uspekhi Mat. Nauk, 6: 160-164\n\n\n\n","source":"_posts/The Naimark Problem.md","raw":"---\ntitle: Naimark's Problem\ndate: 2023-04-10 08:21:52\ntags:\n    - [Notes]\ncategories:\n    - [Notes]\nmathjax: true\n---\n\nWe list some open problems in C$^{*}$-algebra:\n\n## Question 1 (Naimark's Problem):  \nEvery C$^{*}$-algebra that has only one irreducible $*$-representation up to unitary equivalence is isomorphic to the $*$-algebra of compact operators on some (not necessarily separable) Hilbert space.\n\nWhether Naimark problem is  independent of $\\mathsf{ZFC}$?\n\nAkemann & Weaver (2004)[^1] used the $\\diamondsuit$-Principle to construct a C$^{*}$-algebra with $\\aleph _{1}$ generators that serves as a counterexample to Naimark's Problem. But in general its consistency remains unknown. \n\n[^1]: Akemann, Charles; Weaver, Nik (2004), \"Consistency of a counterexample to Naimark's problem\", Proceedings of the National Academy of Sciences of the United States of America, 101 (20): 7522–7525\n\n\n\n## Question 2:  \n\n\nEvery C$^{*}$-algebras of density of continuum $\\aleph_{1} = 2^{\\aleph_{0}}$ has no nonseparable commutative subalgebra.[^2]\n\nAkemann & Donner (1979) constructs example with a C$^{*}$-algebra with $\\aleph _{1}$ generators with only separable abelian C$^{*}$-subalgebras. Bice and Koszmider (2017)[^3] remove their assumption of the continuum hypothesis. Whether \n\n\n[^2]: C. Akemann and J. Doner, A nonseparable C$^{*}$-algebra with only separable abelian C$^{*}$-subalgebras. Bull. London Math. Soc. 11 (1979), no. 3, 279–284.\n\n[^3]: Bice, T., & Koszmider, P. (2017). A note on the Akemann-Doner and Farah-Wofsey constructions. Proceedings of the American Mathematical Society, 145(2), 681-687.\n\n\n<!-- more --> \n\n## Question 3:  \n\nEvery amenable operator algebra is isomorphic to a (necessarily nuclear) C$^{*}$-algebra.\n\n\nResolved. Choi, Farah, & Ozawa (2013) [^4] construct a counterexample to this problem in non-separable case, whereas separable case remains open.\n\n\n[^4]: Choi, Y., Farah, I., & Ozawa, N. (2014, February). A NONSEPARABLE AMENABLE OPERATOR ALGEBRA WHICH IS NOT ISOMORPHIC TO A-ALGEBRA. In Forum of Mathematics, Sigma (Vol. 2, p. e2). Cambridge University Press.\n\n\n## Question 4:  \n\nDo there exist non-discrete second countable locally compact groups which are C$^{*}$-simple?[^5]\n\n[^5]: Pierre de la Harpe, On simplicity of reduced C$^{*}$-algebras of groups, Bull. Lond. Math. Soc.\n\nResolved. Suzuki (2017).[^6] \n\n[^6]: Suzuki, Y. (2017). Elementary constructions of non-discrete 𝐶*-simple groups. Proceedings of the American Mathematical Society, 145(3), 1369-1371.\n\n\n# Reference\n\n[1] Naimark, M. A. (1948), \"Rings with involutions\", Uspekhi Mat. Nauk, 3: 52-145\n\n[2] Naimark, M. A. (1951), \"On a problem in the theory of rings with involution\", Uspekhi Mat. Nauk, 6: 160-164\n\n\n\n","slug":"The Naimark Problem","published":1,"updated":"2024-02-25T15:11:07.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5sc003vm8nxfuexfda0","content":"<p>We list some open problems in C<span class=\"math inline\">\\(^{*}\\)</span>-algebra:</p>\r\n<h2 id=\"question-1-naimarks-problem\">Question 1 (Naimark's\r\nProblem):</h2>\r\n<p>Every C<span class=\"math inline\">\\(^{*}\\)</span>-algebra that has\r\nonly one irreducible <span class=\"math inline\">\\(*\\)</span>-representation up to unitary\r\nequivalence is isomorphic to the <span class=\"math inline\">\\(*\\)</span>-algebra of compact operators on some\r\n(not necessarily separable) Hilbert space.</p>\r\n<p>Whether Naimark problem is independent of <span class=\"math inline\">\\(\\mathsf{ZFC}\\)</span>?</p>\r\n<p>Akemann &amp; Weaver (2004)<a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a> used the <span class=\"math inline\">\\(\\diamondsuit\\)</span>-Principle to construct a\r\nC<span class=\"math inline\">\\(^{*}\\)</span>-algebra with <span class=\"math inline\">\\(\\aleph _{1}\\)</span> generators that serves as a\r\ncounterexample to Naimark's Problem. But in general its consistency\r\nremains unknown.</p>\r\n<h2 id=\"question-2\">Question 2:</h2>\r\n<p>Every C<span class=\"math inline\">\\(^{*}\\)</span>-algebras of density\r\nof continuum <span class=\"math inline\">\\(\\aleph_{1} =\r\n2^{\\aleph_{0}}\\)</span> has no nonseparable commutative subalgebra.<a href=\"#fn2\" class=\"footnote-ref\" id=\"fnref2\" role=\"doc-noteref\"><sup>2</sup></a></p>\r\n<p>Akemann &amp; Donner (1979) constructs example with a C<span class=\"math inline\">\\(^{*}\\)</span>-algebra with <span class=\"math inline\">\\(\\aleph _{1}\\)</span> generators with only\r\nseparable abelian C<span class=\"math inline\">\\(^{*}\\)</span>-subalgebras. Bice and Koszmider\r\n(2017)<a href=\"#fn3\" class=\"footnote-ref\" id=\"fnref3\" role=\"doc-noteref\"><sup>3</sup></a> remove their assumption of the\r\ncontinuum hypothesis. Whether</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"question-3\">Question 3:</h2>\r\n<p>Every amenable operator algebra is isomorphic to a (necessarily\r\nnuclear) C<span class=\"math inline\">\\(^{*}\\)</span>-algebra.</p>\r\n<p>Resolved. Choi, Farah, &amp; Ozawa (2013) <a href=\"#fn4\" class=\"footnote-ref\" id=\"fnref4\" role=\"doc-noteref\"><sup>4</sup></a>\r\nconstruct a counterexample to this problem in non-separable case,\r\nwhereas separable case remains open.</p>\r\n<h2 id=\"question-4\">Question 4:</h2>\r\n<p>Do there exist non-discrete second countable locally compact groups\r\nwhich are C<span class=\"math inline\">\\(^{*}\\)</span>-simple?<a href=\"#fn5\" class=\"footnote-ref\" id=\"fnref5\" role=\"doc-noteref\"><sup>5</sup></a></p>\r\n<p>Resolved. Suzuki (2017).<a href=\"#fn6\" class=\"footnote-ref\" id=\"fnref6\" role=\"doc-noteref\"><sup>6</sup></a></p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Naimark, M. A. (1948), \"Rings with involutions\", Uspekhi Mat.\r\nNauk, 3: 52-145</p>\r\n<p>[2] Naimark, M. A. (1951), \"On a problem in the theory of rings with\r\ninvolution\", Uspekhi Mat. Nauk, 6: 160-164</p>\r\n<section id=\"footnotes\" class=\"footnotes footnotes-end-of-document\" role=\"doc-endnotes\">\r\n<hr>\r\n<ol>\r\n<li id=\"fn1\"><p>Akemann, Charles; Weaver, Nik (2004), \"Consistency of a\r\ncounterexample to Naimark's problem\", Proceedings of the National\r\nAcademy of Sciences of the United States of America, 101 (20):\r\n7522–7525<a href=\"#fnref1\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn2\"><p>C. Akemann and J. Doner, A nonseparable C<span class=\"math inline\">\\(^{*}\\)</span>-algebra with only separable abelian\r\nC<span class=\"math inline\">\\(^{*}\\)</span>-subalgebras. Bull. London\r\nMath. Soc. 11 (1979), no. 3, 279–284.<a href=\"#fnref2\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn3\"><p>Bice, T., &amp; Koszmider, P. (2017). A note on the\r\nAkemann-Doner and Farah-Wofsey constructions. Proceedings of the\r\nAmerican Mathematical Society, 145(2), 681-687.<a href=\"#fnref3\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn4\"><p>Choi, Y., Farah, I., &amp; Ozawa, N. (2014, February). A\r\nNONSEPARABLE AMENABLE OPERATOR ALGEBRA WHICH IS NOT ISOMORPHIC TO\r\nA-ALGEBRA. In Forum of Mathematics, Sigma (Vol. 2, p. e2). Cambridge\r\nUniversity Press.<a href=\"#fnref4\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn5\"><p>Pierre de la Harpe, On simplicity of reduced C<span class=\"math inline\">\\(^{*}\\)</span>-algebras of groups, Bull. Lond.\r\nMath. Soc.<a href=\"#fnref5\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn6\"><p>Suzuki, Y. (2017). Elementary constructions of\r\nnon-discrete 𝐶*-simple groups. Proceedings of the American Mathematical\r\nSociety, 145(3), 1369-1371.<a href=\"#fnref6\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n</ol>\r\n</section>\r\n","site":{"data":{}},"excerpt":"<p>We list some open problems in C<span class=\"math inline\">\\(^{*}\\)</span>-algebra:</p>\r\n<h2 id=\"question-1-naimarks-problem\">Question 1 (Naimark's\r\nProblem):</h2>\r\n<p>Every C<span class=\"math inline\">\\(^{*}\\)</span>-algebra that has\r\nonly one irreducible <span class=\"math inline\">\\(*\\)</span>-representation up to unitary\r\nequivalence is isomorphic to the <span class=\"math inline\">\\(*\\)</span>-algebra of compact operators on some\r\n(not necessarily separable) Hilbert space.</p>\r\n<p>Whether Naimark problem is independent of <span class=\"math inline\">\\(\\mathsf{ZFC}\\)</span>?</p>\r\n<p>Akemann &amp; Weaver (2004)<a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a> used the <span class=\"math inline\">\\(\\diamondsuit\\)</span>-Principle to construct a\r\nC<span class=\"math inline\">\\(^{*}\\)</span>-algebra with <span class=\"math inline\">\\(\\aleph _{1}\\)</span> generators that serves as a\r\ncounterexample to Naimark's Problem. But in general its consistency\r\nremains unknown.</p>\r\n<h2 id=\"question-2\">Question 2:</h2>\r\n<p>Every C<span class=\"math inline\">\\(^{*}\\)</span>-algebras of density\r\nof continuum <span class=\"math inline\">\\(\\aleph_{1} =\r\n2^{\\aleph_{0}}\\)</span> has no nonseparable commutative subalgebra.<a href=\"#fn2\" class=\"footnote-ref\" id=\"fnref2\" role=\"doc-noteref\"><sup>2</sup></a></p>\r\n<p>Akemann &amp; Donner (1979) constructs example with a C<span class=\"math inline\">\\(^{*}\\)</span>-algebra with <span class=\"math inline\">\\(\\aleph _{1}\\)</span> generators with only\r\nseparable abelian C<span class=\"math inline\">\\(^{*}\\)</span>-subalgebras. Bice and Koszmider\r\n(2017)<a href=\"#fn3\" class=\"footnote-ref\" id=\"fnref3\" role=\"doc-noteref\"><sup>3</sup></a> remove their assumption of the\r\ncontinuum hypothesis. Whether</p>","more":"<h2 id=\"question-3\">Question 3:</h2>\r\n<p>Every amenable operator algebra is isomorphic to a (necessarily\r\nnuclear) C<span class=\"math inline\">\\(^{*}\\)</span>-algebra.</p>\r\n<p>Resolved. Choi, Farah, &amp; Ozawa (2013) <a href=\"#fn4\" class=\"footnote-ref\" id=\"fnref4\" role=\"doc-noteref\"><sup>4</sup></a>\r\nconstruct a counterexample to this problem in non-separable case,\r\nwhereas separable case remains open.</p>\r\n<h2 id=\"question-4\">Question 4:</h2>\r\n<p>Do there exist non-discrete second countable locally compact groups\r\nwhich are C<span class=\"math inline\">\\(^{*}\\)</span>-simple?<a href=\"#fn5\" class=\"footnote-ref\" id=\"fnref5\" role=\"doc-noteref\"><sup>5</sup></a></p>\r\n<p>Resolved. Suzuki (2017).<a href=\"#fn6\" class=\"footnote-ref\" id=\"fnref6\" role=\"doc-noteref\"><sup>6</sup></a></p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Naimark, M. A. (1948), \"Rings with involutions\", Uspekhi Mat.\r\nNauk, 3: 52-145</p>\r\n<p>[2] Naimark, M. A. (1951), \"On a problem in the theory of rings with\r\ninvolution\", Uspekhi Mat. Nauk, 6: 160-164</p>\r\n<section id=\"footnotes\" class=\"footnotes footnotes-end-of-document\" role=\"doc-endnotes\">\r\n<hr>\r\n<ol>\r\n<li id=\"fn1\"><p>Akemann, Charles; Weaver, Nik (2004), \"Consistency of a\r\ncounterexample to Naimark's problem\", Proceedings of the National\r\nAcademy of Sciences of the United States of America, 101 (20):\r\n7522–7525<a href=\"#fnref1\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn2\"><p>C. Akemann and J. Doner, A nonseparable C<span class=\"math inline\">\\(^{*}\\)</span>-algebra with only separable abelian\r\nC<span class=\"math inline\">\\(^{*}\\)</span>-subalgebras. Bull. London\r\nMath. Soc. 11 (1979), no. 3, 279–284.<a href=\"#fnref2\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn3\"><p>Bice, T., &amp; Koszmider, P. (2017). A note on the\r\nAkemann-Doner and Farah-Wofsey constructions. Proceedings of the\r\nAmerican Mathematical Society, 145(2), 681-687.<a href=\"#fnref3\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn4\"><p>Choi, Y., Farah, I., &amp; Ozawa, N. (2014, February). A\r\nNONSEPARABLE AMENABLE OPERATOR ALGEBRA WHICH IS NOT ISOMORPHIC TO\r\nA-ALGEBRA. In Forum of Mathematics, Sigma (Vol. 2, p. e2). Cambridge\r\nUniversity Press.<a href=\"#fnref4\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn5\"><p>Pierre de la Harpe, On simplicity of reduced C<span class=\"math inline\">\\(^{*}\\)</span>-algebras of groups, Bull. Lond.\r\nMath. Soc.<a href=\"#fnref5\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n<li id=\"fn6\"><p>Suzuki, Y. (2017). Elementary constructions of\r\nnon-discrete 𝐶*-simple groups. Proceedings of the American Mathematical\r\nSociety, 145(3), 1369-1371.<a href=\"#fnref6\" class=\"footnote-back\" role=\"doc-backlink\">↩︎</a></p></li>\r\n</ol>\r\n</section>","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Feb 25 2024 23:11:07 GMT+0800 (中国标准时间)","title":"Naimark's Problem","path":"2023/04/10/The Naimark Problem/","eyeCatchImage":null,"excerpt":"<p>We list some open problems in C<span class=\"math inline\">\\(^{*}\\)</span>-algebra:</p>\r\n<h2 id=\"question-1-naimarks-problem\">Question 1 (Naimark's\r\nProblem):</h2>\r\n<p>Every C<span class=\"math inline\">\\(^{*}\\)</span>-algebra that has\r\nonly one irreducible <span class=\"math inline\">\\(*\\)</span>-representation up to unitary\r\nequivalence is isomorphic to the <span class=\"math inline\">\\(*\\)</span>-algebra of compact operators on some\r\n(not necessarily separable) Hilbert space.</p>\r\n<p>Whether Naimark problem is independent of <span class=\"math inline\">\\(\\mathsf{ZFC}\\)</span>?</p>\r\n<p>Akemann &amp; Weaver (2004)<a href=\"#fn1\" class=\"footnote-ref\" id=\"fnref1\" role=\"doc-noteref\"><sup>1</sup></a> used the <span class=\"math inline\">\\(\\diamondsuit\\)</span>-Principle to construct a\r\nC<span class=\"math inline\">\\(^{*}\\)</span>-algebra with <span class=\"math inline\">\\(\\aleph _{1}\\)</span> generators that serves as a\r\ncounterexample to Naimark's Problem. But in general its consistency\r\nremains unknown.</p>\r\n<h2 id=\"question-2\">Question 2:</h2>\r\n<p>Every C<span class=\"math inline\">\\(^{*}\\)</span>-algebras of density\r\nof continuum <span class=\"math inline\">\\(\\aleph_{1} =\r\n2^{\\aleph_{0}}\\)</span> has no nonseparable commutative subalgebra.<a href=\"#fn2\" class=\"footnote-ref\" id=\"fnref2\" role=\"doc-noteref\"><sup>2</sup></a></p>\r\n<p>Akemann &amp; Donner (1979) constructs example with a C<span class=\"math inline\">\\(^{*}\\)</span>-algebra with <span class=\"math inline\">\\(\\aleph _{1}\\)</span> generators with only\r\nseparable abelian C<span class=\"math inline\">\\(^{*}\\)</span>-subalgebras. Bice and Koszmider\r\n(2017)<a href=\"#fn3\" class=\"footnote-ref\" id=\"fnref3\" role=\"doc-noteref\"><sup>3</sup></a> remove their assumption of the\r\ncontinuum hypothesis. Whether</p>","date":{"_isAMomentObject":true,"_i":"2023-04-10T00:21:52.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-04-10T00:21:52.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Notes","tags":["Notes"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"Zariski Topology","date":"2023-03-22T23:13:04.000Z","mathjax":true,"_content":"\n## Definition\n\nLet $A$ be commutative ring with unit. $\\text{Spec}(A)$ is the collection of prime ideals of $A$. \n\n\n$V(E)$ is the collection of prime ideals containing $E \\subseteq A$. $\\{V(E); E \\subseteq A\\}$ is a collection of closed subsets of $\\text{Spec} (A)$, since\n\n1. $V(1)=\\emptyset, V(0) =X$. Hence [Axiom of Closed Set I](https://en.wikipedia.org/wiki/Closed_set) is satisfied.\n\t \n2.  $\\cap_{i \\in I} V(E_{i}) =V(\\cup_{i \\in I} E_{i})$. Hence [Axiom of Closed Set II](https://en.wikipedia.org/wiki/Closed_set) is satisfied.\n\t \n3. To verify axiom III, Consider the ideal $\\mathsf{a}_{1}$ generated by $E_{1}$ and the ideal $\\mathsf{a}_{2}$ generated by $E_{2}$. Note that $V(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2}) \\subseteq V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2})$. Then, for any prime ideal $\\mathsf{p}$ containing $\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}$, we have $\\mathsf{a}_{1} \\subseteq \\mathsf{p}$ or $\\mathsf{a}_{2} \\subseteq \\mathsf{p}$, since\n\n$$ x_{1},x_{2} \\notin \\mathsf{p} \\Rightarrow x_{1}x_{2} \\notin \\mathsf{p} \\text{ while }\\,\\, x_{1}\\in \\mathsf{a}_{1}, x_{2}\\in \\mathsf{a}_{2} \\Rightarrow x_{1}x_{2} \\in \n\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}$$\n\nThis proves $V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}) \\subseteq V(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2})$. Therefore, these sets equal to each other $V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}) = V(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2})$, which verifies [Axiom of Closed Set III](https://en.wikipedia.org/wiki/Closed_set). $\\square$\n\n\n## Proporsition 1 [Topological basis]\n\nGiven an element $f$ in $A$, we define $X_{f}$ to be the complement of $V(f)$ in $X=\\text{Spec}(A)$, so\n$$ \\mathscr{U}^{\\prime} = \\{X_{f}; f\\in A\\}$$\n\nis a [topological basis](https://en.wikipedia.org/wiki/Base_(topology)) for\n$$\\mathscr{U} = \\{ X\\backslash V(E); E \\subseteq A\\}$$\n\nTo see more clearly, Choose an open set $O \\in \\mathscr{U}$, it must be the complement of a closed set $V(E)$ generated by some subset $E$ of ring $A$, that is, $O = X\\backslash V(E)$. Decompose $E$ into the union of its components $\\left\\{f\\right\\}$ we have $E = \\cup_{f\\in E}\\{f\\}$, by utilize axiom of closed set III\n\n$$\n    O =X\\backslash \\left(\\cap_{f \\in E} V(f)\\right) = \\cup_{f\\in E} \\left(X \\backslash V(f)\\right) =\\cup_{f\\in E} X_{f}\n$$\n\nThat is to say $\\mathscr{U}^{\\prime}$ is a topological basis for $\\mathscr{U}$. $\\square$\n\n<br> \n\n## Proporsition 1 [Countability Axiom, not $C_{1}$]\n\n## Example \nLet $A$ be [UFD](https://en.wikipedia.org/wiki/Unique_factorization_domain). $I$ is an index set, $|I| \\geq \\aleph_{1}$. For each index $i\\in I$ associate with a variable $x_{i}$, Consider polynomial ring with coeffiecients in $A$\n$$ A[I] := \\{\\sum a_{i_{1},i_{2},\\cdots,i_{k}} x_{i_{i}}^{n_{1}}x_{i_{2}}^{n_{2}} \\cdots x_{i_{k}}^{n_{k}} :\na_{i_{1},i_{2},\\cdots,i_{k}}\\in A \\}$$\n\\text{ where sum is over finite term}. Since $A[I]$ in integral domain, $(0)$ is a prime ideal. The Zariski topological basis $\\{X_{f}; {f \\in A(I)}\\}$ for ring $A(I)$ with emptyset exception, that is $f\\neq 0$, is a neighborhood basis at $(0)$ for $\\text{Spec}(A[I])$ . Since $A[I]$ is either UFD, $A[I]$ contains uncoutable many prime idels $(x_{i}), {i \\in I}$, which implies $A[I]$ dose not satisfies [first-countable axiom $C_{1}$](https://en.wikipedia.org/wiki/First-countable_space).\n\nFor topological space, we are also interested in its separation, compactness and connectedness etc.\n\n## Proporsition 2 [Separation Axiom $T_{0}$]\n\n\nA topological space $(X,\\mathscr{U})$ satisfies [separtion axiom $T_{0}$](https://en.wikipedia.org/wiki/Kolmogorov_space) separation, if for any $x,y \\in X$, $x\\neq y$, there exists open set $U \\in \\mathscr{U}$, such that $x\\in U, y \\notin U$ of if $y \\in U, x \\notin U$. \n\nLet $x,y$ be distinct two points in $X=\\text{Spec}(A)$, i.e. two distinct prime ideals $\\mathsf{p}_{x},\\mathsf{p}_{y}$ of ring $A$:\n\t\n1. If $\\mathsf{p}_{x} \\subseteq \\mathsf{p}_{y}$, then $V(\\mathsf{p}_{y}) \\subseteq V(\\mathsf{p}_{x})$. Taking $U= X \\backslash V(\\mathsf{p}_{y})$ we have $x\\in U, y \\notin U$.\n\t\n2. If $\\mathsf{p}_{x} \\subsetneq \\mathsf{p}_{y}$, thereby $\\mathsf{p}_{y} \\notin V(\\mathsf{p}_{x})$. Taking $U = X \\backslash V(\\mathsf{p}_{x})$ we have $y \\in U, x \\notin U$.\n\t\nThis together impies that $X=\\text{Spec}(A)$ satisfies separation axiom $T_{0}$. $\\square$\n\n## Propersition 3 [Compactness]\n\nWe next prove $X = \\text{Spec} (A)$ is (compact)[]. It only suffices to consider covering from topological basis $\\{X_{f}; {f\\in E}\\}$, where $E\\neq \\emptyset$ is a subset of ring $A$. Accrording to (De Morgan law)[] and axiom of closed set III, nota that\n$$\nX \\backslash \\left(\\cup_{f\\in E} X_{f}\\right) = \\cap_{f\\in E} \\left(X \\backslash X_{f} \\right) = V (\\cup_{f\\in E}  \\{f\\})\n$$\nhence $\\cup_{f\\in E} X_{f} = X \\Leftrightarrow  V(E) =\\emptyset$. Let the ideal generated by $E$ be $\\mathsf{a}$, we show that $\\mathsf{a}= (1) $: \n\t\n> Let $\\Sigma$ consist of non-trivial ideals of $A$. Since the non-decreasing chain of ideals are also an ideal, by Zorn lemma, if $\\Sigma \\neq \\emptyset$, $\\Sigma$ contains a maximal element $\\mathsf{a}_{0}$ with respect to $\\subseteq$-partial ordering; it is indeed an maximal ideal. (Otherwise, if there exist another $\\mathsf{a}_{0}^{\\prime}$ such that $\\mathsf{a}_{0} \\subseteq \\mathsf{a}_{0}^{\\prime}$, $\\mathsf{a}_{0}^{\\prime} = \\mathsf{a}_{0} \\cup \\mathsf{a}_{0}^{\\prime}$ is maximal with respect to inclusion relation.) It also can be proved that if $\\mathsf{a} \\neq (1)$, $\\mathsf{a}$ is contained in a maximal ideal. Hence if $\\mathsf{a} \\neq (1)$, $V(\\mathsf{a})$ contains at least an element. Contradiction. $\\square$ [[See Zorn lemma]](https://en.wikipedia.org/wiki/Zorn%27s_lemma)\n\nTherefore $1$ can be represented by a finite sum of products of elements from $E$ and $A$:\n$$1 = g_{1}f_{1} + \\cdots + g_{n}f_{n}, \\quad g_{i}\\in A, f_{i} \\in E, 1 \\leq i \\leq n$$\nTake $F= \\{f_{1}, \\cdots, f_{n}\\}$, thereby $V(F) = \\emptyset$, which implies $\\{X_{f}; {f \\in F}\\}$ covers $X$. $\\square$\n\n## Definition [Nilradical and Radical]\nThe ideal $\\mathfrak{R}$ of all nipotents in a commutative ring $A$ with unit $1$ is the insection of all prime ideals of $A$, that is,\n$$\n\\mathfrak{R} = \\bigcap_{\\mathsf{p} \\text{ is a prime ideal of $A$}} \\mathsf{p}\n$$\n\nOf course $\\mathfrak{R}$ is an ideal closed under addition and multiplicatio. We split the proof in two steps:\n\n1. If $\\mathsf{p}$ is a prime ideal, then $\\mathfrak{R}\\subseteq \\mathsf{p}$. Since $0 \\in \\mathsf{p}$, and we know for any $f \\in \\mathfrak{R}$, there exist an integer $n>0$ such that \n$$f^{n} \\in \\mathsf{p} \\Rightarrow \\cdots \\Rightarrow  f \\in \\mathsf{p}$$\n\n2. If $f$ in not nilpotent, then there is a prime ideal $\\mathsf{p} \\cap \\{f\\} = \\emptyset$. Let \n$$\\Sigma = \\left\\{ \\mathsf{a} \\text{ is an ideal of $A$}: \\text{for any $n \\in \\mathbb{N}_{*}$, }f^{n} \\notin \\mathsf{a} \\right\\}$$\n\n> Since $(0) \\in \\Sigma$. By Zorn lemma, $\\Sigma$ contains maximal element $\\mathsf{p}$ with respect to $\\subseteq$-inclusion partial ordering. This $\\mathsf{p}$ is indeed a prime ideal, because: \n> For any $x,y \\notin \\mathsf{p}$, thanks to the maximal proporty of $\\mathsf{p}$ we have $\\mathsf{p} +  (x)$, $\\mathsf{p} + (y)$ $\\notin \\Sigma$; however,\n> $$\\begin{aligned}\t\n    f^{m} \\in\\mathsf{p} + (x) &, f^{n} \\in \\mathsf{p} +(y) \\Rightarrow f^{m+n} \\in \\mathsf{p} + (xy) \n\\end{aligned}$$\n> implies $\\mathsf{p} + (xy)  \\notin \\Sigma$; therefore $xy \\notin \\mathsf{p}$. $\\square$\n\nDenote\n$$r(\\mathsf{a}): = \\{f\\in A: \\text{there exist integer } n >0 \\text{ such that } f^{n} \\in \\mathsf{a}\\}$$\nwhich is the intersection of all prime ideals containing $\\mathsf{a}$ by [correspondence theorem](https://en.wikipedia.org/wiki/Isomorphism_theorems).\n\n## Definition [Irreducibility]\nA topological space $(X,\\mathscr{U})$ is said to be [irreducible]() if $X\\neq \\emptyset$ and $X$ can't be union of any two non-empty open sets $X = X_{1} \\cup X_{2}$, or equivalently, if $U_{1}, U_{2} \\neq \\emptyset$ are any two non-empty open sets, then $U_{1} \\cap U_{2} \\neq \\emptyset$. \n\n\n**Remark:** According to the definition, irreducibility if finer than connectness, because two open sets $X_{1},X_{2}$ can be intersected.\n\n\n## Theorem 1[Irreducibility]\n\n$\\text{Spec}(A)$ is irreducible if and only if its nilradical $\\mathfrak{R}$ of $A$ is a prime ideal. \n\t\nFor any two non-empty open sets $\\cup_{f \\in F} X_{f}$ and $\\cup_{g \\in G} X_{g}$ in $X=\\text{Spec}(A)$. \n$$\n\\begin{aligned}\n\t\t\\cup_{f \\in F} X_{f} \\neq \\emptyset &\\Leftrightarrow \\cap_{f \\in E} V(f) \\neq X \\Leftrightarrow \\exists f_{0} \\notin \\mathfrak{R}\\\\\n\t\t\\left(\\cup_{f \\in F} X_{f}\\right) \\cap \\left(\\cup_{g \\in G} X_{g}\\right) \\neq \\emptyset &\\Leftrightarrow \\cup_{f \\in F, g\\in G} \\left(X_{fg}\\right) \\neq \\emptyset \\Leftrightarrow \\exists f_{0}\\in F, g_{0} \\in G, f_{0}g_{0} \\notin \\mathfrak{R} \n\\end{aligned}\n$$\n\n**Remark 1:** Singletons $\\{x\\}, x\\in X$ are irreducible subspaces; the closure of irreducible subspaces in $X$ are irreducible subspaces. \n\n**Remark 2:** Each singleton $\\{x\\}, x\\in X$ contained in a maximal irreducible subspace of $X$, which is called [irreducible component](https://en.wikipedia.org/wiki/Irreducible_component). The irrducible components cover $X$.  \n\n**Remark 3:**\nIn an irreducible Hausdorff space $X$, the irrducible components of $X$ are singletons. However, the conected components, for instance, Euclidean space, are itself. \n\n\n\nBy taking quotient $A/\\mathsf{p}$ and noting that there is a one-to-one correspondence $h:\\mathsf{a} \\mapsto \\mathsf{a}/ \\mathsf{p}$ between $V(\\mathsf{p})$ and $\\text{Spec}(A/\\mathsf{p})$ that preserves prime ideals, there is a one-to-one correspondence between $r(\\mathsf{p}) = \\cap_{\\mathsf{p}_{x} \\in V(\\mathsf{p})} \\mathsf{p}_{x}$ and $\\mathfrak{R} (A/\\mathsf{p}) =  \\cap_{x\\in \\text{Spec}(A/\\mathsf{p})} x$, as is shown in the diagram\n\n$$\\begin{align}\n    \\require{AMScd} \n    \\begin{CD} \n\t\tV(\\mathsf{p}) @>>h> \\text{Spec} (A/\\mathsf{p})\\\\\n\t\t@VV{\\tiny \\text{cap}}V @VV{\\tiny \\text{cap}}V\\\\\n\t\tr(\\mathsf{p}) @>>h> \\mathfrak{R} (A/\\mathsf{p})\n\t\\end{CD}\n\\end{align}$$\n\nAccording to above theorem and\n\n> Non-zero ring $A$ has minimal prime ideals with respect to set inclusion.\nBy Zorn's lemma, it only suffices to prove that the intersection $\\cap_{n}\\mathsf{p}_{n}$ of a non-increasing sequence of prime ideals $\\cdots \\supseteq \\mathsf{p}_{n} \\supseteq \\mathsf{p}_{n+1}\\supseteq \\cdots$ is also a prime ideal. \nBy considering $x,y \\in A, xy \\in \\cap_{n}\\mathsf{p}_{n}$, we have for each $n$, either $x$ or $y$ belongs to $\\mathsf{p}_{n}$. Then one of $x$ and $y$ occurs in $\\mathsf{p}_{n}$ for infinitely many times, say, for example, $x  \\in \\cap_{n}\\mathsf{p}_{n}$. $\\square$\n\n\n\nwe only need to show that $h$ is a homeomorphism, which is indeed true since $h$ maps $V(\\mathsf{a}) \\cap V(\\mathsf{p}) = V(\\mathsf{a} + \\mathsf{p})$ to $V((\\mathsf{a} + \\mathsf{p})/ \\mathsf{p})$ and vice versa, where $\\mathsf{a}$ is an ideal of $A$. Similarily, the closed subspace $V(\\mathsf{p})$ of $\\text{Spec}(A)$ is irreducible if and only if $r(\\mathsf{p})$ is a prime ideal, where $\\mathsf{p}$ is an ideal of $A$. $\\square$ \n\n\n\t\n## Property 4 [Homomorphism]\n\nLet $\\phi: A \\to B$ be homomorphism that preserves unit. $X=\\text{Spec}(A) , Y=\\text{Spec}(B)$. Since $\\phi^{-1}$ draws back prime ideals in $Y$ into prime ideals in $X$, $\\phi$ introduces naturally a mapping\n$\\phi^{*}:  \\text{Spec}(B) \\to \\text{Spec}(A)$ by $\\mathsf{q} \\mapsto \\phi^{-1} (\\mathsf{q})$\n\n\n1. It is easy to verify that $(\\phi^{*})^{-1}(X_{f}) =Y_{\\phi(f)}$, which implies $\\phi^{*}$ is continuous. \n\t\n2. If $\\phi$ is surjective, then $\\phi^{*}$ is injective. By [Fundamental theorem on homomorphisms](https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms), $A/\\ker(\\phi) \\cong B$. Note in above we mention that $\\phi$ is a homeomorphism mappping, thereby $\\phi^{*}$ establish a homeomorphism between $Y=\\text{Spec}(B)$ and $V\\left(\\ker(\\phi)\\right)$.\n\n3. $\\overline{\\phi^{*}(V(\\mathsf{b}))} = V(\\phi^{*}(\\mathsf{b}))$. Hence if $\\phi$ is injective, then $\\phi^{*}(Y)$ is dense in $X$. Let $\\mathsf{q} \\in V(\\mathsf{b})$ and note that $\\phi^{*}(\\mathsf{b}) = \\phi^{-1}(\\mathsf{b}) \\subseteq \\phi^{-1}(\\mathsf{q}) $, so $\\phi^{-1}(\\mathsf{q}) \\in V(\\phi^{*}(\\mathsf{b}))$ and $\\mathsf{q} \\in \\phi(V(\\phi^{*}(\\mathsf{b})))$. Thus $V(\\mathsf{b}) \\subseteq \\phi(V(\\phi^{*}(\\mathsf{b})))$. Then note that\n$$y \\in \\overline{\\{x\\}} \\Leftrightarrow \\overline{\\{y\\}} \\subseteq \\overline{\\{x\\}} \\Leftrightarrow V(\\mathsf{p}_{y}) \\subseteq V(\\mathsf{p}_{x}) \\Leftrightarrow \\mathsf{p}_{x} \\subseteq \\mathsf{p}_{y}$$\nwhich says $\\overline{\\{x\\}} = V\\left(\\mathsf{p}(={x})\\right)$; $V(\\mathsf{b})$ is obviously the minimal closed set in $X$ which contains $\\phi^{*}(V(\\mathsf{b}))$ since $\\phi^{*}(\\mathsf{b}) \\in \\phi^{*}(V(\\mathsf{b}))$.\n\n\n\n$$\\begin{align}\n    \\require{AMScd} \n    \\begin{CD} \n\t\tX @<<{\\phi^*}< Y\\\\\n\t\t@AA{\\tiny \\text{$\\cup$}}A  @AA{\\tiny \\text{$\\cup$}}A\\\\\n\t\tV_A(\\phi^* (\\mathsf{b})) @<<{\\phi^*}< V_B(\\mathsf{b})\\\\\n\t\t@AA{\\text{$*$}}A  @AA{\\text{$*$}}A\\\\\n\t\t\\text{Spec}(A/\\phi^* (\\mathsf{b})) @<<{\\tilde\\phi^*}< \\text{Spec} (B/\\mathsf{b})\n\t\\end{CD} \n\\end{align}$$\n\n\n**Example:** Let $A$ be an integral domain with just one non-zero prime ideal $\\mathsf{p}$. and let $K$ be the field of fractions of $A$. Let $B=(A/\\mathsf{p}) \\times K$. Define $\\phi: A \\to B$ by $\\phi(x) = (\\bar{x}, x)$, where $\\bar{x}$ is the image of $x$ in $A/\\mathsf{p}$. $\\phi^{*}$ is bijective but not a homeomorphism: Since $A/\\mathsf{p}$ is also a field, hence $B = (A/\\mathsf{p}) \\times K$ has only two prime ideals\n$$\\left\\{(1)\\times(0), (0) \\times(1)\\right\\}$$\nDirect computation yields $\\phi^{*}$ is a bijection. However, $\\{(1) \\times (0)\\}$ is a closed set of $\\text{Spec}(B)$ whereas $\\{(0)\\}$ is not closed in $\\text{Spec}(A)$.\n\n\n## More on Separation Axiom [$T_{1}$, $T_{2}$]\nWe define \n$$\\mathscr{V}^{\\prime} = \\left\\{ \\phi^{*}\\left(\\text{Spec}(B)\\right): \\text{ where $\\phi:A \\to B$ is ring homomorphism} \\right\\}$$\nIt can be verified that $\\mathscr{V}^{\\prime}$ satisfies axiom of closed set. The topology in $\\text{Spec}(A)$ is called [constructable topology](https://en.wikipedia.org/wiki/Constructible_topology). which is finer than Zariski topology.\n\n\n1. $A/\\mathfrak{R}$ is [absolutely flat]() ($\\mathfrak{R}$ being the nilradical of $A$).\n2. Every prime ideal of $A$ is maximal.\n3. $\\text{Spec} (A)$ is a $T_{1}$-space (i.e., every subset consisting of a single point is closed).\n4. $\\text{Spec} (A)$ is Hausdorff.\n5. The Zariski topology and the constructible topology on $\\text{Spec} (A)$ coincide\n\n\n\n## Proporsition 5 [Connectedness]\n\t\nIf a commutative ring $A$ with unit can be represented as direct product of non-zero ring, $A_{i}, i=1, 2, \\cdots, n$, By a standard result in commutative ring, the ideals $A=\\prod_{i=1}^{n}A_{i}$ has the form\n\n$$\\mathsf{a}_{1} \\times \\cdots \\times \\mathsf{a}_{i} \\times \\cdots \\times \\mathsf{a}_{n}, \\text{ where $\\mathsf{a}_{i}$ are ideals of $A_{i}$} $$\t\nEspecially, prime ideals in $A$ has the form\n\n$$(1) \\times \\cdots \\times \\mathsf{p}_{i} \\times \\cdots \\times (1), \\text{ where $\\mathsf{p}_{i}$ are prime ideals of $A_{i}$}$$\n\nFor ring $A=\\prod_{i=1}^{n}A_{i}$, the spectrum $X = \\text{Spec}(A)$ is the disjoint union of $X_{i}, i =1,2,\\cdots,n$, where $X_{i}$ consists of prime ideals containing $(1) \\times \\cdots \\times \\underset{i}{(0)} \\times \\cdots \\times (1)$, homeomorphic to $\\text{Spec}(A_{i})$. Hence $X=\\text{Spec}(A)$ is not connected. $\\square$\n\nConversly, if the subsets $X_{1}, X_{2} \\neq \\emptyset, X_{1} \\cap X_{2} = \\emptyset$ of $X=\\text{Spec}(A)$ satisfies $X_{1} \\cup X_{2} = X$. According to the definition of spectrum, we have $X_{1} =V(\\mathsf{a}_{1}), X_{2} =V(\\mathsf{a}_{2}),$ where $\\mathsf{a}_{1},\\mathsf{a}_{2}$ are ideals of ring $A$, and\n$$\n\\begin{aligned}\nV(\\mathsf{a}_{1}) \\cap V(\\mathsf{a}_{2}) = V(\\mathsf{a}_{1} +\\mathsf{a}_{2}) =\\emptyset &\\Rightarrow \n\\mathsf{a}_{1} +\\mathsf{a}_{2} = (1)\\\\\nV(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2}) = V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}) = X &\\Rightarrow \n\\mathsf{a}_{1} \\cap \\mathsf{a}_{2} \\subseteq \\mathfrak{R}\n\\end{aligned}\n$$\nthere exist $x_{1} \\in \\mathsf{a}_{1}, x_{2} \\in \\mathsf{a}_{2}$, and integer $n>0$ such that \n$$\n\\begin{aligned}\nx_{1} + x_{2} &=1\\\\\n(x_{1} x_{2})^{n} &=0\n\\end{aligned}\n$$\nDue to elementary arithmetic it finds that \n$$r(x_{1}^{n}) + r(x_{2}^{n}) =1 \\Rightarrow (x_{1}^{n}) + (x_{2}^{n}) =1 $$.\nTherefore we can find an idempotent $e\\neq 0,1 \\in (x_{1}^{n})$ such that $1 - e \\in (x_{2}^{n})$, and $e(1 - e) = 0$, because the non-empty assumption of $X_{i}, i=1,2$. Thereby $A$ can be decomposed as the direct product of $eA$ and $(1-e) A$. $ \\square$\n\t\nWe summarize the result below:\n\nLet $A$ be any commutative ring with unit. The following statements are equivalent:\n\n1. $X = \\text{Spec} (A)$ is disconnected.\n\n2. $A \\cong A_{1} \\times A_{2}$ where neither of the rings $A_{1}$ or $A_{2}$ is the zero ring.\n\n3. $A$ contains an idempotent $\\neq 0,1$.\n\n\n**Remark:**  Local ring, that is, ring with only one maximal ideal, is always connected.\n\n# Reference \n\n[1] Michael Atiyah. Introduction to commutative algebra. CRC Press, 2018.\n\n[2] Suzanne C Dieudonne. History Algebraic Geometry. CRC Press, 1985.\n\n[3] Bartel L Van der Waerden. A history of algebra: From al-Khwārizmī to Emmy Noether.\nSpringer Science & Business Media, 2013.\n\n\n","source":"_posts/Zariski topology.md","raw":"---\ntitle: Zariski Topology\ndate: 2023-03-23 07:13:04\ntag: \n    - [Algebraic Geometry]\ncategories:\n    - [Commutative Algebra, Algebraic Geometry]\nmathjax: true\n---\n\n## Definition\n\nLet $A$ be commutative ring with unit. $\\text{Spec}(A)$ is the collection of prime ideals of $A$. \n\n\n$V(E)$ is the collection of prime ideals containing $E \\subseteq A$. $\\{V(E); E \\subseteq A\\}$ is a collection of closed subsets of $\\text{Spec} (A)$, since\n\n1. $V(1)=\\emptyset, V(0) =X$. Hence [Axiom of Closed Set I](https://en.wikipedia.org/wiki/Closed_set) is satisfied.\n\t \n2.  $\\cap_{i \\in I} V(E_{i}) =V(\\cup_{i \\in I} E_{i})$. Hence [Axiom of Closed Set II](https://en.wikipedia.org/wiki/Closed_set) is satisfied.\n\t \n3. To verify axiom III, Consider the ideal $\\mathsf{a}_{1}$ generated by $E_{1}$ and the ideal $\\mathsf{a}_{2}$ generated by $E_{2}$. Note that $V(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2}) \\subseteq V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2})$. Then, for any prime ideal $\\mathsf{p}$ containing $\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}$, we have $\\mathsf{a}_{1} \\subseteq \\mathsf{p}$ or $\\mathsf{a}_{2} \\subseteq \\mathsf{p}$, since\n\n$$ x_{1},x_{2} \\notin \\mathsf{p} \\Rightarrow x_{1}x_{2} \\notin \\mathsf{p} \\text{ while }\\,\\, x_{1}\\in \\mathsf{a}_{1}, x_{2}\\in \\mathsf{a}_{2} \\Rightarrow x_{1}x_{2} \\in \n\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}$$\n\nThis proves $V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}) \\subseteq V(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2})$. Therefore, these sets equal to each other $V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}) = V(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2})$, which verifies [Axiom of Closed Set III](https://en.wikipedia.org/wiki/Closed_set). $\\square$\n\n\n## Proporsition 1 [Topological basis]\n\nGiven an element $f$ in $A$, we define $X_{f}$ to be the complement of $V(f)$ in $X=\\text{Spec}(A)$, so\n$$ \\mathscr{U}^{\\prime} = \\{X_{f}; f\\in A\\}$$\n\nis a [topological basis](https://en.wikipedia.org/wiki/Base_(topology)) for\n$$\\mathscr{U} = \\{ X\\backslash V(E); E \\subseteq A\\}$$\n\nTo see more clearly, Choose an open set $O \\in \\mathscr{U}$, it must be the complement of a closed set $V(E)$ generated by some subset $E$ of ring $A$, that is, $O = X\\backslash V(E)$. Decompose $E$ into the union of its components $\\left\\{f\\right\\}$ we have $E = \\cup_{f\\in E}\\{f\\}$, by utilize axiom of closed set III\n\n$$\n    O =X\\backslash \\left(\\cap_{f \\in E} V(f)\\right) = \\cup_{f\\in E} \\left(X \\backslash V(f)\\right) =\\cup_{f\\in E} X_{f}\n$$\n\nThat is to say $\\mathscr{U}^{\\prime}$ is a topological basis for $\\mathscr{U}$. $\\square$\n\n<br> \n\n## Proporsition 1 [Countability Axiom, not $C_{1}$]\n\n## Example \nLet $A$ be [UFD](https://en.wikipedia.org/wiki/Unique_factorization_domain). $I$ is an index set, $|I| \\geq \\aleph_{1}$. For each index $i\\in I$ associate with a variable $x_{i}$, Consider polynomial ring with coeffiecients in $A$\n$$ A[I] := \\{\\sum a_{i_{1},i_{2},\\cdots,i_{k}} x_{i_{i}}^{n_{1}}x_{i_{2}}^{n_{2}} \\cdots x_{i_{k}}^{n_{k}} :\na_{i_{1},i_{2},\\cdots,i_{k}}\\in A \\}$$\n\\text{ where sum is over finite term}. Since $A[I]$ in integral domain, $(0)$ is a prime ideal. The Zariski topological basis $\\{X_{f}; {f \\in A(I)}\\}$ for ring $A(I)$ with emptyset exception, that is $f\\neq 0$, is a neighborhood basis at $(0)$ for $\\text{Spec}(A[I])$ . Since $A[I]$ is either UFD, $A[I]$ contains uncoutable many prime idels $(x_{i}), {i \\in I}$, which implies $A[I]$ dose not satisfies [first-countable axiom $C_{1}$](https://en.wikipedia.org/wiki/First-countable_space).\n\nFor topological space, we are also interested in its separation, compactness and connectedness etc.\n\n## Proporsition 2 [Separation Axiom $T_{0}$]\n\n\nA topological space $(X,\\mathscr{U})$ satisfies [separtion axiom $T_{0}$](https://en.wikipedia.org/wiki/Kolmogorov_space) separation, if for any $x,y \\in X$, $x\\neq y$, there exists open set $U \\in \\mathscr{U}$, such that $x\\in U, y \\notin U$ of if $y \\in U, x \\notin U$. \n\nLet $x,y$ be distinct two points in $X=\\text{Spec}(A)$, i.e. two distinct prime ideals $\\mathsf{p}_{x},\\mathsf{p}_{y}$ of ring $A$:\n\t\n1. If $\\mathsf{p}_{x} \\subseteq \\mathsf{p}_{y}$, then $V(\\mathsf{p}_{y}) \\subseteq V(\\mathsf{p}_{x})$. Taking $U= X \\backslash V(\\mathsf{p}_{y})$ we have $x\\in U, y \\notin U$.\n\t\n2. If $\\mathsf{p}_{x} \\subsetneq \\mathsf{p}_{y}$, thereby $\\mathsf{p}_{y} \\notin V(\\mathsf{p}_{x})$. Taking $U = X \\backslash V(\\mathsf{p}_{x})$ we have $y \\in U, x \\notin U$.\n\t\nThis together impies that $X=\\text{Spec}(A)$ satisfies separation axiom $T_{0}$. $\\square$\n\n## Propersition 3 [Compactness]\n\nWe next prove $X = \\text{Spec} (A)$ is (compact)[]. It only suffices to consider covering from topological basis $\\{X_{f}; {f\\in E}\\}$, where $E\\neq \\emptyset$ is a subset of ring $A$. Accrording to (De Morgan law)[] and axiom of closed set III, nota that\n$$\nX \\backslash \\left(\\cup_{f\\in E} X_{f}\\right) = \\cap_{f\\in E} \\left(X \\backslash X_{f} \\right) = V (\\cup_{f\\in E}  \\{f\\})\n$$\nhence $\\cup_{f\\in E} X_{f} = X \\Leftrightarrow  V(E) =\\emptyset$. Let the ideal generated by $E$ be $\\mathsf{a}$, we show that $\\mathsf{a}= (1) $: \n\t\n> Let $\\Sigma$ consist of non-trivial ideals of $A$. Since the non-decreasing chain of ideals are also an ideal, by Zorn lemma, if $\\Sigma \\neq \\emptyset$, $\\Sigma$ contains a maximal element $\\mathsf{a}_{0}$ with respect to $\\subseteq$-partial ordering; it is indeed an maximal ideal. (Otherwise, if there exist another $\\mathsf{a}_{0}^{\\prime}$ such that $\\mathsf{a}_{0} \\subseteq \\mathsf{a}_{0}^{\\prime}$, $\\mathsf{a}_{0}^{\\prime} = \\mathsf{a}_{0} \\cup \\mathsf{a}_{0}^{\\prime}$ is maximal with respect to inclusion relation.) It also can be proved that if $\\mathsf{a} \\neq (1)$, $\\mathsf{a}$ is contained in a maximal ideal. Hence if $\\mathsf{a} \\neq (1)$, $V(\\mathsf{a})$ contains at least an element. Contradiction. $\\square$ [[See Zorn lemma]](https://en.wikipedia.org/wiki/Zorn%27s_lemma)\n\nTherefore $1$ can be represented by a finite sum of products of elements from $E$ and $A$:\n$$1 = g_{1}f_{1} + \\cdots + g_{n}f_{n}, \\quad g_{i}\\in A, f_{i} \\in E, 1 \\leq i \\leq n$$\nTake $F= \\{f_{1}, \\cdots, f_{n}\\}$, thereby $V(F) = \\emptyset$, which implies $\\{X_{f}; {f \\in F}\\}$ covers $X$. $\\square$\n\n## Definition [Nilradical and Radical]\nThe ideal $\\mathfrak{R}$ of all nipotents in a commutative ring $A$ with unit $1$ is the insection of all prime ideals of $A$, that is,\n$$\n\\mathfrak{R} = \\bigcap_{\\mathsf{p} \\text{ is a prime ideal of $A$}} \\mathsf{p}\n$$\n\nOf course $\\mathfrak{R}$ is an ideal closed under addition and multiplicatio. We split the proof in two steps:\n\n1. If $\\mathsf{p}$ is a prime ideal, then $\\mathfrak{R}\\subseteq \\mathsf{p}$. Since $0 \\in \\mathsf{p}$, and we know for any $f \\in \\mathfrak{R}$, there exist an integer $n>0$ such that \n$$f^{n} \\in \\mathsf{p} \\Rightarrow \\cdots \\Rightarrow  f \\in \\mathsf{p}$$\n\n2. If $f$ in not nilpotent, then there is a prime ideal $\\mathsf{p} \\cap \\{f\\} = \\emptyset$. Let \n$$\\Sigma = \\left\\{ \\mathsf{a} \\text{ is an ideal of $A$}: \\text{for any $n \\in \\mathbb{N}_{*}$, }f^{n} \\notin \\mathsf{a} \\right\\}$$\n\n> Since $(0) \\in \\Sigma$. By Zorn lemma, $\\Sigma$ contains maximal element $\\mathsf{p}$ with respect to $\\subseteq$-inclusion partial ordering. This $\\mathsf{p}$ is indeed a prime ideal, because: \n> For any $x,y \\notin \\mathsf{p}$, thanks to the maximal proporty of $\\mathsf{p}$ we have $\\mathsf{p} +  (x)$, $\\mathsf{p} + (y)$ $\\notin \\Sigma$; however,\n> $$\\begin{aligned}\t\n    f^{m} \\in\\mathsf{p} + (x) &, f^{n} \\in \\mathsf{p} +(y) \\Rightarrow f^{m+n} \\in \\mathsf{p} + (xy) \n\\end{aligned}$$\n> implies $\\mathsf{p} + (xy)  \\notin \\Sigma$; therefore $xy \\notin \\mathsf{p}$. $\\square$\n\nDenote\n$$r(\\mathsf{a}): = \\{f\\in A: \\text{there exist integer } n >0 \\text{ such that } f^{n} \\in \\mathsf{a}\\}$$\nwhich is the intersection of all prime ideals containing $\\mathsf{a}$ by [correspondence theorem](https://en.wikipedia.org/wiki/Isomorphism_theorems).\n\n## Definition [Irreducibility]\nA topological space $(X,\\mathscr{U})$ is said to be [irreducible]() if $X\\neq \\emptyset$ and $X$ can't be union of any two non-empty open sets $X = X_{1} \\cup X_{2}$, or equivalently, if $U_{1}, U_{2} \\neq \\emptyset$ are any two non-empty open sets, then $U_{1} \\cap U_{2} \\neq \\emptyset$. \n\n\n**Remark:** According to the definition, irreducibility if finer than connectness, because two open sets $X_{1},X_{2}$ can be intersected.\n\n\n## Theorem 1[Irreducibility]\n\n$\\text{Spec}(A)$ is irreducible if and only if its nilradical $\\mathfrak{R}$ of $A$ is a prime ideal. \n\t\nFor any two non-empty open sets $\\cup_{f \\in F} X_{f}$ and $\\cup_{g \\in G} X_{g}$ in $X=\\text{Spec}(A)$. \n$$\n\\begin{aligned}\n\t\t\\cup_{f \\in F} X_{f} \\neq \\emptyset &\\Leftrightarrow \\cap_{f \\in E} V(f) \\neq X \\Leftrightarrow \\exists f_{0} \\notin \\mathfrak{R}\\\\\n\t\t\\left(\\cup_{f \\in F} X_{f}\\right) \\cap \\left(\\cup_{g \\in G} X_{g}\\right) \\neq \\emptyset &\\Leftrightarrow \\cup_{f \\in F, g\\in G} \\left(X_{fg}\\right) \\neq \\emptyset \\Leftrightarrow \\exists f_{0}\\in F, g_{0} \\in G, f_{0}g_{0} \\notin \\mathfrak{R} \n\\end{aligned}\n$$\n\n**Remark 1:** Singletons $\\{x\\}, x\\in X$ are irreducible subspaces; the closure of irreducible subspaces in $X$ are irreducible subspaces. \n\n**Remark 2:** Each singleton $\\{x\\}, x\\in X$ contained in a maximal irreducible subspace of $X$, which is called [irreducible component](https://en.wikipedia.org/wiki/Irreducible_component). The irrducible components cover $X$.  \n\n**Remark 3:**\nIn an irreducible Hausdorff space $X$, the irrducible components of $X$ are singletons. However, the conected components, for instance, Euclidean space, are itself. \n\n\n\nBy taking quotient $A/\\mathsf{p}$ and noting that there is a one-to-one correspondence $h:\\mathsf{a} \\mapsto \\mathsf{a}/ \\mathsf{p}$ between $V(\\mathsf{p})$ and $\\text{Spec}(A/\\mathsf{p})$ that preserves prime ideals, there is a one-to-one correspondence between $r(\\mathsf{p}) = \\cap_{\\mathsf{p}_{x} \\in V(\\mathsf{p})} \\mathsf{p}_{x}$ and $\\mathfrak{R} (A/\\mathsf{p}) =  \\cap_{x\\in \\text{Spec}(A/\\mathsf{p})} x$, as is shown in the diagram\n\n$$\\begin{align}\n    \\require{AMScd} \n    \\begin{CD} \n\t\tV(\\mathsf{p}) @>>h> \\text{Spec} (A/\\mathsf{p})\\\\\n\t\t@VV{\\tiny \\text{cap}}V @VV{\\tiny \\text{cap}}V\\\\\n\t\tr(\\mathsf{p}) @>>h> \\mathfrak{R} (A/\\mathsf{p})\n\t\\end{CD}\n\\end{align}$$\n\nAccording to above theorem and\n\n> Non-zero ring $A$ has minimal prime ideals with respect to set inclusion.\nBy Zorn's lemma, it only suffices to prove that the intersection $\\cap_{n}\\mathsf{p}_{n}$ of a non-increasing sequence of prime ideals $\\cdots \\supseteq \\mathsf{p}_{n} \\supseteq \\mathsf{p}_{n+1}\\supseteq \\cdots$ is also a prime ideal. \nBy considering $x,y \\in A, xy \\in \\cap_{n}\\mathsf{p}_{n}$, we have for each $n$, either $x$ or $y$ belongs to $\\mathsf{p}_{n}$. Then one of $x$ and $y$ occurs in $\\mathsf{p}_{n}$ for infinitely many times, say, for example, $x  \\in \\cap_{n}\\mathsf{p}_{n}$. $\\square$\n\n\n\nwe only need to show that $h$ is a homeomorphism, which is indeed true since $h$ maps $V(\\mathsf{a}) \\cap V(\\mathsf{p}) = V(\\mathsf{a} + \\mathsf{p})$ to $V((\\mathsf{a} + \\mathsf{p})/ \\mathsf{p})$ and vice versa, where $\\mathsf{a}$ is an ideal of $A$. Similarily, the closed subspace $V(\\mathsf{p})$ of $\\text{Spec}(A)$ is irreducible if and only if $r(\\mathsf{p})$ is a prime ideal, where $\\mathsf{p}$ is an ideal of $A$. $\\square$ \n\n\n\t\n## Property 4 [Homomorphism]\n\nLet $\\phi: A \\to B$ be homomorphism that preserves unit. $X=\\text{Spec}(A) , Y=\\text{Spec}(B)$. Since $\\phi^{-1}$ draws back prime ideals in $Y$ into prime ideals in $X$, $\\phi$ introduces naturally a mapping\n$\\phi^{*}:  \\text{Spec}(B) \\to \\text{Spec}(A)$ by $\\mathsf{q} \\mapsto \\phi^{-1} (\\mathsf{q})$\n\n\n1. It is easy to verify that $(\\phi^{*})^{-1}(X_{f}) =Y_{\\phi(f)}$, which implies $\\phi^{*}$ is continuous. \n\t\n2. If $\\phi$ is surjective, then $\\phi^{*}$ is injective. By [Fundamental theorem on homomorphisms](https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms), $A/\\ker(\\phi) \\cong B$. Note in above we mention that $\\phi$ is a homeomorphism mappping, thereby $\\phi^{*}$ establish a homeomorphism between $Y=\\text{Spec}(B)$ and $V\\left(\\ker(\\phi)\\right)$.\n\n3. $\\overline{\\phi^{*}(V(\\mathsf{b}))} = V(\\phi^{*}(\\mathsf{b}))$. Hence if $\\phi$ is injective, then $\\phi^{*}(Y)$ is dense in $X$. Let $\\mathsf{q} \\in V(\\mathsf{b})$ and note that $\\phi^{*}(\\mathsf{b}) = \\phi^{-1}(\\mathsf{b}) \\subseteq \\phi^{-1}(\\mathsf{q}) $, so $\\phi^{-1}(\\mathsf{q}) \\in V(\\phi^{*}(\\mathsf{b}))$ and $\\mathsf{q} \\in \\phi(V(\\phi^{*}(\\mathsf{b})))$. Thus $V(\\mathsf{b}) \\subseteq \\phi(V(\\phi^{*}(\\mathsf{b})))$. Then note that\n$$y \\in \\overline{\\{x\\}} \\Leftrightarrow \\overline{\\{y\\}} \\subseteq \\overline{\\{x\\}} \\Leftrightarrow V(\\mathsf{p}_{y}) \\subseteq V(\\mathsf{p}_{x}) \\Leftrightarrow \\mathsf{p}_{x} \\subseteq \\mathsf{p}_{y}$$\nwhich says $\\overline{\\{x\\}} = V\\left(\\mathsf{p}(={x})\\right)$; $V(\\mathsf{b})$ is obviously the minimal closed set in $X$ which contains $\\phi^{*}(V(\\mathsf{b}))$ since $\\phi^{*}(\\mathsf{b}) \\in \\phi^{*}(V(\\mathsf{b}))$.\n\n\n\n$$\\begin{align}\n    \\require{AMScd} \n    \\begin{CD} \n\t\tX @<<{\\phi^*}< Y\\\\\n\t\t@AA{\\tiny \\text{$\\cup$}}A  @AA{\\tiny \\text{$\\cup$}}A\\\\\n\t\tV_A(\\phi^* (\\mathsf{b})) @<<{\\phi^*}< V_B(\\mathsf{b})\\\\\n\t\t@AA{\\text{$*$}}A  @AA{\\text{$*$}}A\\\\\n\t\t\\text{Spec}(A/\\phi^* (\\mathsf{b})) @<<{\\tilde\\phi^*}< \\text{Spec} (B/\\mathsf{b})\n\t\\end{CD} \n\\end{align}$$\n\n\n**Example:** Let $A$ be an integral domain with just one non-zero prime ideal $\\mathsf{p}$. and let $K$ be the field of fractions of $A$. Let $B=(A/\\mathsf{p}) \\times K$. Define $\\phi: A \\to B$ by $\\phi(x) = (\\bar{x}, x)$, where $\\bar{x}$ is the image of $x$ in $A/\\mathsf{p}$. $\\phi^{*}$ is bijective but not a homeomorphism: Since $A/\\mathsf{p}$ is also a field, hence $B = (A/\\mathsf{p}) \\times K$ has only two prime ideals\n$$\\left\\{(1)\\times(0), (0) \\times(1)\\right\\}$$\nDirect computation yields $\\phi^{*}$ is a bijection. However, $\\{(1) \\times (0)\\}$ is a closed set of $\\text{Spec}(B)$ whereas $\\{(0)\\}$ is not closed in $\\text{Spec}(A)$.\n\n\n## More on Separation Axiom [$T_{1}$, $T_{2}$]\nWe define \n$$\\mathscr{V}^{\\prime} = \\left\\{ \\phi^{*}\\left(\\text{Spec}(B)\\right): \\text{ where $\\phi:A \\to B$ is ring homomorphism} \\right\\}$$\nIt can be verified that $\\mathscr{V}^{\\prime}$ satisfies axiom of closed set. The topology in $\\text{Spec}(A)$ is called [constructable topology](https://en.wikipedia.org/wiki/Constructible_topology). which is finer than Zariski topology.\n\n\n1. $A/\\mathfrak{R}$ is [absolutely flat]() ($\\mathfrak{R}$ being the nilradical of $A$).\n2. Every prime ideal of $A$ is maximal.\n3. $\\text{Spec} (A)$ is a $T_{1}$-space (i.e., every subset consisting of a single point is closed).\n4. $\\text{Spec} (A)$ is Hausdorff.\n5. The Zariski topology and the constructible topology on $\\text{Spec} (A)$ coincide\n\n\n\n## Proporsition 5 [Connectedness]\n\t\nIf a commutative ring $A$ with unit can be represented as direct product of non-zero ring, $A_{i}, i=1, 2, \\cdots, n$, By a standard result in commutative ring, the ideals $A=\\prod_{i=1}^{n}A_{i}$ has the form\n\n$$\\mathsf{a}_{1} \\times \\cdots \\times \\mathsf{a}_{i} \\times \\cdots \\times \\mathsf{a}_{n}, \\text{ where $\\mathsf{a}_{i}$ are ideals of $A_{i}$} $$\t\nEspecially, prime ideals in $A$ has the form\n\n$$(1) \\times \\cdots \\times \\mathsf{p}_{i} \\times \\cdots \\times (1), \\text{ where $\\mathsf{p}_{i}$ are prime ideals of $A_{i}$}$$\n\nFor ring $A=\\prod_{i=1}^{n}A_{i}$, the spectrum $X = \\text{Spec}(A)$ is the disjoint union of $X_{i}, i =1,2,\\cdots,n$, where $X_{i}$ consists of prime ideals containing $(1) \\times \\cdots \\times \\underset{i}{(0)} \\times \\cdots \\times (1)$, homeomorphic to $\\text{Spec}(A_{i})$. Hence $X=\\text{Spec}(A)$ is not connected. $\\square$\n\nConversly, if the subsets $X_{1}, X_{2} \\neq \\emptyset, X_{1} \\cap X_{2} = \\emptyset$ of $X=\\text{Spec}(A)$ satisfies $X_{1} \\cup X_{2} = X$. According to the definition of spectrum, we have $X_{1} =V(\\mathsf{a}_{1}), X_{2} =V(\\mathsf{a}_{2}),$ where $\\mathsf{a}_{1},\\mathsf{a}_{2}$ are ideals of ring $A$, and\n$$\n\\begin{aligned}\nV(\\mathsf{a}_{1}) \\cap V(\\mathsf{a}_{2}) = V(\\mathsf{a}_{1} +\\mathsf{a}_{2}) =\\emptyset &\\Rightarrow \n\\mathsf{a}_{1} +\\mathsf{a}_{2} = (1)\\\\\nV(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2}) = V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}) = X &\\Rightarrow \n\\mathsf{a}_{1} \\cap \\mathsf{a}_{2} \\subseteq \\mathfrak{R}\n\\end{aligned}\n$$\nthere exist $x_{1} \\in \\mathsf{a}_{1}, x_{2} \\in \\mathsf{a}_{2}$, and integer $n>0$ such that \n$$\n\\begin{aligned}\nx_{1} + x_{2} &=1\\\\\n(x_{1} x_{2})^{n} &=0\n\\end{aligned}\n$$\nDue to elementary arithmetic it finds that \n$$r(x_{1}^{n}) + r(x_{2}^{n}) =1 \\Rightarrow (x_{1}^{n}) + (x_{2}^{n}) =1 $$.\nTherefore we can find an idempotent $e\\neq 0,1 \\in (x_{1}^{n})$ such that $1 - e \\in (x_{2}^{n})$, and $e(1 - e) = 0$, because the non-empty assumption of $X_{i}, i=1,2$. Thereby $A$ can be decomposed as the direct product of $eA$ and $(1-e) A$. $ \\square$\n\t\nWe summarize the result below:\n\nLet $A$ be any commutative ring with unit. The following statements are equivalent:\n\n1. $X = \\text{Spec} (A)$ is disconnected.\n\n2. $A \\cong A_{1} \\times A_{2}$ where neither of the rings $A_{1}$ or $A_{2}$ is the zero ring.\n\n3. $A$ contains an idempotent $\\neq 0,1$.\n\n\n**Remark:**  Local ring, that is, ring with only one maximal ideal, is always connected.\n\n# Reference \n\n[1] Michael Atiyah. Introduction to commutative algebra. CRC Press, 2018.\n\n[2] Suzanne C Dieudonne. History Algebraic Geometry. CRC Press, 1985.\n\n[3] Bartel L Van der Waerden. A history of algebra: From al-Khwārizmī to Emmy Noether.\nSpringer Science & Business Media, 2013.\n\n\n","slug":"Zariski topology","published":1,"updated":"2024-02-25T15:11:07.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5sc003wm8nxbmmi9mko","content":"<h2 id=\"definition\">Definition</h2>\r\n<p>Let <span class=\"math inline\">\\(A\\)</span> be commutative ring with\r\nunit. <span class=\"math inline\">\\(\\text{Spec}(A)\\)</span> is the\r\ncollection of prime ideals of <span class=\"math inline\">\\(A\\)</span>.</p>\r\n<p><span class=\"math inline\">\\(V(E)\\)</span> is the collection of prime\r\nideals containing <span class=\"math inline\">\\(E \\subseteq A\\)</span>.\r\n<span class=\"math inline\">\\(\\{V(E); E \\subseteq A\\}\\)</span> is a\r\ncollection of closed subsets of <span class=\"math inline\">\\(\\text{Spec}\r\n(A)\\)</span>, since</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(V(1)=\\emptyset, V(0) =X\\)</span>.\r\nHence <a href=\"https://en.wikipedia.org/wiki/Closed_set\">Axiom of Closed\r\nSet I</a> is satisfied.</p></li>\r\n<li><p><span class=\"math inline\">\\(\\cap_{i \\in I} V(E_{i}) =V(\\cup_{i\r\n\\in I} E_{i})\\)</span>. Hence <a href=\"https://en.wikipedia.org/wiki/Closed_set\">Axiom of Closed Set\r\nII</a> is satisfied.</p></li>\r\n<li><p>To verify axiom III, Consider the ideal <span class=\"math inline\">\\(\\mathsf{a}_{1}\\)</span> generated by <span class=\"math inline\">\\(E_{1}\\)</span> and the ideal <span class=\"math inline\">\\(\\mathsf{a}_{2}\\)</span> generated by <span class=\"math inline\">\\(E_{2}\\)</span>. Note that <span class=\"math inline\">\\(V(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2}) \\subseteq\r\nV(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2})\\)</span>. Then, for any prime\r\nideal <span class=\"math inline\">\\(\\mathsf{p}\\)</span> containing <span class=\"math inline\">\\(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}\\)</span>, we\r\nhave <span class=\"math inline\">\\(\\mathsf{a}_{1} \\subseteq\r\n\\mathsf{p}\\)</span> or <span class=\"math inline\">\\(\\mathsf{a}_{2}\r\n\\subseteq \\mathsf{p}\\)</span>, since</p></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[ x_{1},x_{2} \\notin \\mathsf{p}\r\n\\Rightarrow x_{1}x_{2} \\notin \\mathsf{p} \\text{ while }\\,\\, x_{1}\\in\r\n\\mathsf{a}_{1}, x_{2}\\in \\mathsf{a}_{2} \\Rightarrow x_{1}x_{2} \\in\r\n\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}\\]</span></p>\r\n<p>This proves <span class=\"math inline\">\\(V(\\mathsf{a}_{1} \\cap\r\n\\mathsf{a}_{2}) \\subseteq V(\\mathsf{a}_{1}) \\cup\r\nV(\\mathsf{a}_{2})\\)</span>. Therefore, these sets equal to each other\r\n<span class=\"math inline\">\\(V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}) =\r\nV(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2})\\)</span>, which verifies <a href=\"https://en.wikipedia.org/wiki/Closed_set\">Axiom of Closed Set\r\nIII</a>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"proporsition-1-topological-basis\">Proporsition 1 [Topological\r\nbasis]</h2>\r\n<p>Given an element <span class=\"math inline\">\\(f\\)</span> in <span class=\"math inline\">\\(A\\)</span>, we define <span class=\"math inline\">\\(X_{f}\\)</span> to be the complement of <span class=\"math inline\">\\(V(f)\\)</span> in <span class=\"math inline\">\\(X=\\text{Spec}(A)\\)</span>, so <span class=\"math display\">\\[ \\mathscr{U}^{\\prime} = \\{X_{f}; f\\in\r\nA\\}\\]</span></p>\r\n<p>is a <a href=\"https://en.wikipedia.org/wiki/Base_(topology)\">topological\r\nbasis</a> for <span class=\"math display\">\\[\\mathscr{U} = \\{ X\\backslash\r\nV(E); E \\subseteq A\\}\\]</span></p>\r\n<p>To see more clearly, Choose an open set <span class=\"math inline\">\\(O\r\n\\in \\mathscr{U}\\)</span>, it must be the complement of a closed set\r\n<span class=\"math inline\">\\(V(E)\\)</span> generated by some subset <span class=\"math inline\">\\(E\\)</span> of ring <span class=\"math inline\">\\(A\\)</span>, that is, <span class=\"math inline\">\\(O\r\n= X\\backslash V(E)\\)</span>. Decompose <span class=\"math inline\">\\(E\\)</span> into the union of its components <span class=\"math inline\">\\(\\left\\{f\\right\\}\\)</span> we have <span class=\"math inline\">\\(E = \\cup_{f\\in E}\\{f\\}\\)</span>, by utilize axiom\r\nof closed set III</p>\r\n<p><span class=\"math display\">\\[\r\n    O =X\\backslash \\left(\\cap_{f \\in E} V(f)\\right) = \\cup_{f\\in E}\r\n\\left(X \\backslash V(f)\\right) =\\cup_{f\\in E} X_{f}\r\n\\]</span></p>\r\n<p>That is to say <span class=\"math inline\">\\(\\mathscr{U}^{\\prime}\\)</span> is a topological\r\nbasis for <span class=\"math inline\">\\(\\mathscr{U}\\)</span>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<p><br></p>\r\n<h2 id=\"proporsition-1-countability-axiom-not-c_1\">Proporsition 1\r\n[Countability Axiom, not <span class=\"math inline\">\\(C_{1}\\)</span>]</h2>\r\n<h2 id=\"example\">Example</h2>\r\n<p>Let <span class=\"math inline\">\\(A\\)</span> be <a href=\"https://en.wikipedia.org/wiki/Unique_factorization_domain\">UFD</a>.\r\n<span class=\"math inline\">\\(I\\)</span> is an index set, <span class=\"math inline\">\\(|I| \\geq \\aleph_{1}\\)</span>. For each index <span class=\"math inline\">\\(i\\in I\\)</span> associate with a variable <span class=\"math inline\">\\(x_{i}\\)</span>, Consider polynomial ring with\r\ncoeffiecients in <span class=\"math inline\">\\(A\\)</span> <span class=\"math display\">\\[ A[I] := \\{\\sum a_{i_{1},i_{2},\\cdots,i_{k}}\r\nx_{i_{i}}^{n_{1}}x_{i_{2}}^{n_{2}} \\cdots x_{i_{k}}^{n_{k}} :\r\na_{i_{1},i_{2},\\cdots,i_{k}}\\in A \\}\\]</span> . Since <span class=\"math inline\">\\(A[I]\\)</span> in integral domain, <span class=\"math inline\">\\((0)\\)</span> is a prime ideal. The Zariski\r\ntopological basis <span class=\"math inline\">\\(\\{X_{f}; {f \\in\r\nA(I)}\\}\\)</span> for ring <span class=\"math inline\">\\(A(I)\\)</span> with\r\nemptyset exception, that is <span class=\"math inline\">\\(f\\neq\r\n0\\)</span>, is a neighborhood basis at <span class=\"math inline\">\\((0)\\)</span> for <span class=\"math inline\">\\(\\text{Spec}(A[I])\\)</span> . Since <span class=\"math inline\">\\(A[I]\\)</span> is either UFD, <span class=\"math inline\">\\(A[I]\\)</span> contains uncoutable many prime idels\r\n<span class=\"math inline\">\\((x_{i}), {i \\in I}\\)</span>, which implies\r\n<span class=\"math inline\">\\(A[I]\\)</span> dose not satisfies <a href=\"https://en.wikipedia.org/wiki/First-countable_space\">first-countable\r\naxiom <span class=\"math inline\">\\(C_{1}\\)</span></a>.</p>\r\n<p>For topological space, we are also interested in its separation,\r\ncompactness and connectedness etc.</p>\r\n<h2 id=\"proporsition-2-separation-axiom-t_0\">Proporsition 2 [Separation\r\nAxiom <span class=\"math inline\">\\(T_{0}\\)</span>]</h2>\r\n<p>A topological space <span class=\"math inline\">\\((X,\\mathscr{U})\\)</span> satisfies <a href=\"https://en.wikipedia.org/wiki/Kolmogorov_space\">separtion axiom\r\n<span class=\"math inline\">\\(T_{0}\\)</span></a> separation, if for any\r\n<span class=\"math inline\">\\(x,y \\in X\\)</span>, <span class=\"math inline\">\\(x\\neq y\\)</span>, there exists open set <span class=\"math inline\">\\(U \\in \\mathscr{U}\\)</span>, such that <span class=\"math inline\">\\(x\\in U, y \\notin U\\)</span> of if <span class=\"math inline\">\\(y \\in U, x \\notin U\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(x,y\\)</span> be distinct two points\r\nin <span class=\"math inline\">\\(X=\\text{Spec}(A)\\)</span>, i.e. two\r\ndistinct prime ideals <span class=\"math inline\">\\(\\mathsf{p}_{x},\\mathsf{p}_{y}\\)</span> of ring\r\n<span class=\"math inline\">\\(A\\)</span>:</p>\r\n<ol type=\"1\">\r\n<li><p>If <span class=\"math inline\">\\(\\mathsf{p}_{x} \\subseteq\r\n\\mathsf{p}_{y}\\)</span>, then <span class=\"math inline\">\\(V(\\mathsf{p}_{y}) \\subseteq\r\nV(\\mathsf{p}_{x})\\)</span>. Taking <span class=\"math inline\">\\(U= X\r\n\\backslash V(\\mathsf{p}_{y})\\)</span> we have <span class=\"math inline\">\\(x\\in U, y \\notin U\\)</span>.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(\\mathsf{p}_{x} \\subsetneq\r\n\\mathsf{p}_{y}\\)</span>, thereby <span class=\"math inline\">\\(\\mathsf{p}_{y} \\notin V(\\mathsf{p}_{x})\\)</span>.\r\nTaking <span class=\"math inline\">\\(U = X \\backslash\r\nV(\\mathsf{p}_{x})\\)</span> we have <span class=\"math inline\">\\(y \\in U,\r\nx \\notin U\\)</span>.</p></li>\r\n</ol>\r\n<p>This together impies that <span class=\"math inline\">\\(X=\\text{Spec}(A)\\)</span> satisfies separation\r\naxiom <span class=\"math inline\">\\(T_{0}\\)</span>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"propersition-3-compactness\">Propersition 3 [Compactness]</h2>\r\n<p>We next prove <span class=\"math inline\">\\(X = \\text{Spec}\r\n(A)\\)</span> is (compact)[]. It only suffices to consider covering from\r\ntopological basis <span class=\"math inline\">\\(\\{X_{f}; {f\\in\r\nE}\\}\\)</span>, where <span class=\"math inline\">\\(E\\neq\r\n\\emptyset\\)</span> is a subset of ring <span class=\"math inline\">\\(A\\)</span>. Accrording to (De Morgan law)[] and\r\naxiom of closed set III, nota that <span class=\"math display\">\\[\r\nX \\backslash \\left(\\cup_{f\\in E} X_{f}\\right) = \\cap_{f\\in E} \\left(X\r\n\\backslash X_{f} \\right) = V (\\cup_{f\\in E}  \\{f\\})\r\n\\]</span> hence <span class=\"math inline\">\\(\\cup_{f\\in E} X_{f} = X\r\n\\Leftrightarrow  V(E) =\\emptyset\\)</span>. Let the ideal generated by\r\n<span class=\"math inline\">\\(E\\)</span> be <span class=\"math inline\">\\(\\mathsf{a}\\)</span>, we show that $= (1) $:</p>\r\n<blockquote>\r\n<p>Let <span class=\"math inline\">\\(\\Sigma\\)</span> consist of\r\nnon-trivial ideals of <span class=\"math inline\">\\(A\\)</span>. Since the\r\nnon-decreasing chain of ideals are also an ideal, by Zorn lemma, if\r\n<span class=\"math inline\">\\(\\Sigma \\neq \\emptyset\\)</span>, <span class=\"math inline\">\\(\\Sigma\\)</span> contains a maximal element <span class=\"math inline\">\\(\\mathsf{a}_{0}\\)</span> with respect to <span class=\"math inline\">\\(\\subseteq\\)</span>-partial ordering; it is indeed\r\nan maximal ideal. (Otherwise, if there exist another <span class=\"math inline\">\\(\\mathsf{a}_{0}^{\\prime}\\)</span> such that <span class=\"math inline\">\\(\\mathsf{a}_{0} \\subseteq\r\n\\mathsf{a}_{0}^{\\prime}\\)</span>, <span class=\"math inline\">\\(\\mathsf{a}_{0}^{\\prime} = \\mathsf{a}_{0} \\cup\r\n\\mathsf{a}_{0}^{\\prime}\\)</span> is maximal with respect to inclusion\r\nrelation.) It also can be proved that if <span class=\"math inline\">\\(\\mathsf{a} \\neq (1)\\)</span>, <span class=\"math inline\">\\(\\mathsf{a}\\)</span> is contained in a maximal\r\nideal. Hence if <span class=\"math inline\">\\(\\mathsf{a} \\neq\r\n(1)\\)</span>, <span class=\"math inline\">\\(V(\\mathsf{a})\\)</span>\r\ncontains at least an element. Contradiction. <span class=\"math inline\">\\(\\square\\)</span> <a href=\"https://en.wikipedia.org/wiki/Zorn%27s_lemma\">[See Zorn\r\nlemma]</a></p>\r\n</blockquote>\r\n<p>Therefore <span class=\"math inline\">\\(1\\)</span> can be represented\r\nby a finite sum of products of elements from <span class=\"math inline\">\\(E\\)</span> and <span class=\"math inline\">\\(A\\)</span>: <span class=\"math display\">\\[1 =\r\ng_{1}f_{1} + \\cdots + g_{n}f_{n}, \\quad g_{i}\\in A, f_{i} \\in E, 1 \\leq\r\ni \\leq n\\]</span> Take <span class=\"math inline\">\\(F= \\{f_{1}, \\cdots,\r\nf_{n}\\}\\)</span>, thereby <span class=\"math inline\">\\(V(F) =\r\n\\emptyset\\)</span>, which implies <span class=\"math inline\">\\(\\{X_{f};\r\n{f \\in F}\\}\\)</span> covers <span class=\"math inline\">\\(X\\)</span>.\r\n<span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"definition-nilradical-and-radical\">Definition [Nilradical and\r\nRadical]</h2>\r\n<p>The ideal <span class=\"math inline\">\\(\\mathfrak{R}\\)</span> of all\r\nnipotents in a commutative ring <span class=\"math inline\">\\(A\\)</span>\r\nwith unit <span class=\"math inline\">\\(1\\)</span> is the insection of all\r\nprime ideals of <span class=\"math inline\">\\(A\\)</span>, that is, <span class=\"math display\">\\[\r\n\\mathfrak{R} = \\bigcap_{\\mathsf{p} \\text{ is a prime ideal of $A$}}\r\n\\mathsf{p}\r\n\\]</span></p>\r\n<p>Of course <span class=\"math inline\">\\(\\mathfrak{R}\\)</span> is an\r\nideal closed under addition and multiplicatio. We split the proof in two\r\nsteps:</p>\r\n<ol type=\"1\">\r\n<li><p>If <span class=\"math inline\">\\(\\mathsf{p}\\)</span> is a prime\r\nideal, then <span class=\"math inline\">\\(\\mathfrak{R}\\subseteq\r\n\\mathsf{p}\\)</span>. Since <span class=\"math inline\">\\(0 \\in\r\n\\mathsf{p}\\)</span>, and we know for any <span class=\"math inline\">\\(f\r\n\\in \\mathfrak{R}\\)</span>, there exist an integer <span class=\"math inline\">\\(n&gt;0\\)</span> such that <span class=\"math display\">\\[f^{n} \\in \\mathsf{p} \\Rightarrow \\cdots\r\n\\Rightarrow  f \\in \\mathsf{p}\\]</span></p></li>\r\n<li><p>If <span class=\"math inline\">\\(f\\)</span> in not nilpotent, then\r\nthere is a prime ideal <span class=\"math inline\">\\(\\mathsf{p} \\cap \\{f\\}\r\n= \\emptyset\\)</span>. Let <span class=\"math display\">\\[\\Sigma = \\left\\{\r\n\\mathsf{a} \\text{ is an ideal of $A$}: \\text{for any $n \\in\r\n\\mathbb{N}_{*}$, }f^{n} \\notin \\mathsf{a} \\right\\}\\]</span></p></li>\r\n</ol>\r\n<blockquote>\r\n<p>Since <span class=\"math inline\">\\((0) \\in \\Sigma\\)</span>. By Zorn\r\nlemma, <span class=\"math inline\">\\(\\Sigma\\)</span> contains maximal\r\nelement <span class=\"math inline\">\\(\\mathsf{p}\\)</span> with respect to\r\n<span class=\"math inline\">\\(\\subseteq\\)</span>-inclusion partial\r\nordering. This <span class=\"math inline\">\\(\\mathsf{p}\\)</span> is indeed\r\na prime ideal, because: For any <span class=\"math inline\">\\(x,y \\notin\r\n\\mathsf{p}\\)</span>, thanks to the maximal proporty of <span class=\"math inline\">\\(\\mathsf{p}\\)</span> we have <span class=\"math inline\">\\(\\mathsf{p} +  (x)\\)</span>, <span class=\"math inline\">\\(\\mathsf{p} + (y)\\)</span> <span class=\"math inline\">\\(\\notin \\Sigma\\)</span>; however, <span class=\"math display\">\\[\\begin{aligned}\r\nf^{m} \\in\\mathsf{p} + (x) &amp;, f^{n} \\in \\mathsf{p} +(y) \\Rightarrow\r\nf^{m+n} \\in \\mathsf{p} + (xy)\r\n\\end{aligned}\\]</span> implies <span class=\"math inline\">\\(\\mathsf{p} +\r\n(xy)  \\notin \\Sigma\\)</span>; therefore <span class=\"math inline\">\\(xy\r\n\\notin \\mathsf{p}\\)</span>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n</blockquote>\r\n<p>Denote <span class=\"math display\">\\[r(\\mathsf{a}): = \\{f\\in A:\r\n\\text{there exist integer } n &gt;0 \\text{ such that } f^{n} \\in\r\n\\mathsf{a}\\}\\]</span> which is the intersection of all prime ideals\r\ncontaining <span class=\"math inline\">\\(\\mathsf{a}\\)</span> by <a href=\"https://en.wikipedia.org/wiki/Isomorphism_theorems\">correspondence\r\ntheorem</a>.</p>\r\n<h2 id=\"definition-irreducibility\">Definition [Irreducibility]</h2>\r\n<p>A topological space <span class=\"math inline\">\\((X,\\mathscr{U})\\)</span> is said to be <a href>irreducible</a> if <span class=\"math inline\">\\(X\\neq\r\n\\emptyset\\)</span> and <span class=\"math inline\">\\(X\\)</span> can't be\r\nunion of any two non-empty open sets <span class=\"math inline\">\\(X =\r\nX_{1} \\cup X_{2}\\)</span>, or equivalently, if <span class=\"math inline\">\\(U_{1}, U_{2} \\neq \\emptyset\\)</span> are any two\r\nnon-empty open sets, then <span class=\"math inline\">\\(U_{1} \\cap U_{2}\r\n\\neq \\emptyset\\)</span>.</p>\r\n<p><strong>Remark:</strong> According to the definition, irreducibility\r\nif finer than connectness, because two open sets <span class=\"math inline\">\\(X_{1},X_{2}\\)</span> can be intersected.</p>\r\n<h2 id=\"theorem-1irreducibility\">Theorem 1[Irreducibility]</h2>\r\n<p><span class=\"math inline\">\\(\\text{Spec}(A)\\)</span> is irreducible if\r\nand only if its nilradical <span class=\"math inline\">\\(\\mathfrak{R}\\)</span> of <span class=\"math inline\">\\(A\\)</span> is a prime ideal.</p>\r\n<p>For any two non-empty open sets <span class=\"math inline\">\\(\\cup_{f\r\n\\in F} X_{f}\\)</span> and <span class=\"math inline\">\\(\\cup_{g \\in G}\r\nX_{g}\\)</span> in <span class=\"math inline\">\\(X=\\text{Spec}(A)\\)</span>.\r\n<span class=\"math display\">\\[\r\n\\begin{aligned}\r\n        \\cup_{f \\in F} X_{f} \\neq \\emptyset &amp;\\Leftrightarrow \\cap_{f\r\n\\in E} V(f) \\neq X \\Leftrightarrow \\exists f_{0} \\notin \\mathfrak{R}\\\\\r\n        \\left(\\cup_{f \\in F} X_{f}\\right) \\cap \\left(\\cup_{g \\in G}\r\nX_{g}\\right) \\neq \\emptyset &amp;\\Leftrightarrow \\cup_{f \\in F, g\\in G}\r\n\\left(X_{fg}\\right) \\neq \\emptyset \\Leftrightarrow \\exists f_{0}\\in F,\r\ng_{0} \\in G, f_{0}g_{0} \\notin \\mathfrak{R}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><strong>Remark 1:</strong> Singletons <span class=\"math inline\">\\(\\{x\\}, x\\in X\\)</span> are irreducible subspaces;\r\nthe closure of irreducible subspaces in <span class=\"math inline\">\\(X\\)</span> are irreducible subspaces.</p>\r\n<p><strong>Remark 2:</strong> Each singleton <span class=\"math inline\">\\(\\{x\\}, x\\in X\\)</span> contained in a maximal\r\nirreducible subspace of <span class=\"math inline\">\\(X\\)</span>, which is\r\ncalled <a href=\"https://en.wikipedia.org/wiki/Irreducible_component\">irreducible\r\ncomponent</a>. The irrducible components cover <span class=\"math inline\">\\(X\\)</span>.</p>\r\n<p><strong>Remark 3:</strong> In an irreducible Hausdorff space <span class=\"math inline\">\\(X\\)</span>, the irrducible components of <span class=\"math inline\">\\(X\\)</span> are singletons. However, the conected\r\ncomponents, for instance, Euclidean space, are itself.</p>\r\n<p>By taking quotient <span class=\"math inline\">\\(A/\\mathsf{p}\\)</span>\r\nand noting that there is a one-to-one correspondence <span class=\"math inline\">\\(h:\\mathsf{a} \\mapsto \\mathsf{a}/\r\n\\mathsf{p}\\)</span> between <span class=\"math inline\">\\(V(\\mathsf{p})\\)</span> and <span class=\"math inline\">\\(\\text{Spec}(A/\\mathsf{p})\\)</span> that preserves\r\nprime ideals, there is a one-to-one correspondence between <span class=\"math inline\">\\(r(\\mathsf{p}) = \\cap_{\\mathsf{p}_{x} \\in\r\nV(\\mathsf{p})} \\mathsf{p}_{x}\\)</span> and <span class=\"math inline\">\\(\\mathfrak{R} (A/\\mathsf{p}) =  \\cap_{x\\in\r\n\\text{Spec}(A/\\mathsf{p})} x\\)</span>, as is shown in the diagram</p>\r\n<p><span class=\"math display\">\\[\\begin{align}\r\n    \\require{AMScd}\r\n    \\begin{CD}\r\n        V(\\mathsf{p}) @&gt;&gt;h&gt; \\text{Spec} (A/\\mathsf{p})\\\\\r\n        @VV{\\tiny \\text{cap}}V @VV{\\tiny \\text{cap}}V\\\\\r\n        r(\\mathsf{p}) @&gt;&gt;h&gt; \\mathfrak{R} (A/\\mathsf{p})\r\n    \\end{CD}\r\n\\end{align}\\]</span></p>\r\n<p>According to above theorem and</p>\r\n<blockquote>\r\n<p>Non-zero ring <span class=\"math inline\">\\(A\\)</span> has minimal\r\nprime ideals with respect to set inclusion. By Zorn's lemma, it only\r\nsuffices to prove that the intersection <span class=\"math inline\">\\(\\cap_{n}\\mathsf{p}_{n}\\)</span> of a\r\nnon-increasing sequence of prime ideals <span class=\"math inline\">\\(\\cdots \\supseteq \\mathsf{p}_{n} \\supseteq\r\n\\mathsf{p}_{n+1}\\supseteq \\cdots\\)</span> is also a prime ideal. By\r\nconsidering <span class=\"math inline\">\\(x,y \\in A, xy \\in\r\n\\cap_{n}\\mathsf{p}_{n}\\)</span>, we have for each <span class=\"math inline\">\\(n\\)</span>, either <span class=\"math inline\">\\(x\\)</span> or <span class=\"math inline\">\\(y\\)</span> belongs to <span class=\"math inline\">\\(\\mathsf{p}_{n}\\)</span>. Then one of <span class=\"math inline\">\\(x\\)</span> and <span class=\"math inline\">\\(y\\)</span> occurs in <span class=\"math inline\">\\(\\mathsf{p}_{n}\\)</span> for infinitely many times,\r\nsay, for example, <span class=\"math inline\">\\(x  \\in\r\n\\cap_{n}\\mathsf{p}_{n}\\)</span>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n</blockquote>\r\n<p>we only need to show that <span class=\"math inline\">\\(h\\)</span> is a\r\nhomeomorphism, which is indeed true since <span class=\"math inline\">\\(h\\)</span> maps <span class=\"math inline\">\\(V(\\mathsf{a}) \\cap V(\\mathsf{p}) = V(\\mathsf{a} +\r\n\\mathsf{p})\\)</span> to <span class=\"math inline\">\\(V((\\mathsf{a} +\r\n\\mathsf{p})/ \\mathsf{p})\\)</span> and vice versa, where <span class=\"math inline\">\\(\\mathsf{a}\\)</span> is an ideal of <span class=\"math inline\">\\(A\\)</span>. Similarily, the closed subspace <span class=\"math inline\">\\(V(\\mathsf{p})\\)</span> of <span class=\"math inline\">\\(\\text{Spec}(A)\\)</span> is irreducible if and only\r\nif <span class=\"math inline\">\\(r(\\mathsf{p})\\)</span> is a prime ideal,\r\nwhere <span class=\"math inline\">\\(\\mathsf{p}\\)</span> is an ideal of\r\n<span class=\"math inline\">\\(A\\)</span>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"property-4-homomorphism\">Property 4 [Homomorphism]</h2>\r\n<p>Let <span class=\"math inline\">\\(\\phi: A \\to B\\)</span> be\r\nhomomorphism that preserves unit. <span class=\"math inline\">\\(X=\\text{Spec}(A) , Y=\\text{Spec}(B)\\)</span>.\r\nSince <span class=\"math inline\">\\(\\phi^{-1}\\)</span> draws back prime\r\nideals in <span class=\"math inline\">\\(Y\\)</span> into prime ideals in\r\n<span class=\"math inline\">\\(X\\)</span>, <span class=\"math inline\">\\(\\phi\\)</span> introduces naturally a mapping <span class=\"math inline\">\\(\\phi^{*}:  \\text{Spec}(B) \\to\r\n\\text{Spec}(A)\\)</span> by <span class=\"math inline\">\\(\\mathsf{q}\r\n\\mapsto \\phi^{-1} (\\mathsf{q})\\)</span></p>\r\n<ol type=\"1\">\r\n<li><p>It is easy to verify that <span class=\"math inline\">\\((\\phi^{*})^{-1}(X_{f}) =Y_{\\phi(f)}\\)</span>,\r\nwhich implies <span class=\"math inline\">\\(\\phi^{*}\\)</span> is\r\ncontinuous.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(\\phi\\)</span> is surjective, then\r\n<span class=\"math inline\">\\(\\phi^{*}\\)</span> is injective. By <a href=\"https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms\">Fundamental\r\ntheorem on homomorphisms</a>, <span class=\"math inline\">\\(A/\\ker(\\phi)\r\n\\cong B\\)</span>. Note in above we mention that <span class=\"math inline\">\\(\\phi\\)</span> is a homeomorphism mappping, thereby\r\n<span class=\"math inline\">\\(\\phi^{*}\\)</span> establish a homeomorphism\r\nbetween <span class=\"math inline\">\\(Y=\\text{Spec}(B)\\)</span> and <span class=\"math inline\">\\(V\\left(\\ker(\\phi)\\right)\\)</span>.</p></li>\r\n<li><p><span class=\"math inline\">\\(\\overline{\\phi^{*}(V(\\mathsf{b}))} =\r\nV(\\phi^{*}(\\mathsf{b}))\\)</span>. Hence if <span class=\"math inline\">\\(\\phi\\)</span> is injective, then <span class=\"math inline\">\\(\\phi^{*}(Y)\\)</span> is dense in <span class=\"math inline\">\\(X\\)</span>. Let <span class=\"math inline\">\\(\\mathsf{q} \\in V(\\mathsf{b})\\)</span> and note\r\nthat $^{*}() = ^{-1}() ^{-1}() $, so <span class=\"math inline\">\\(\\phi^{-1}(\\mathsf{q}) \\in\r\nV(\\phi^{*}(\\mathsf{b}))\\)</span> and <span class=\"math inline\">\\(\\mathsf{q} \\in\r\n\\phi(V(\\phi^{*}(\\mathsf{b})))\\)</span>. Thus <span class=\"math inline\">\\(V(\\mathsf{b}) \\subseteq\r\n\\phi(V(\\phi^{*}(\\mathsf{b})))\\)</span>. Then note that <span class=\"math display\">\\[y \\in \\overline{\\{x\\}} \\Leftrightarrow\r\n\\overline{\\{y\\}} \\subseteq \\overline{\\{x\\}} \\Leftrightarrow\r\nV(\\mathsf{p}_{y}) \\subseteq V(\\mathsf{p}_{x}) \\Leftrightarrow\r\n\\mathsf{p}_{x} \\subseteq \\mathsf{p}_{y}\\]</span> which says <span class=\"math inline\">\\(\\overline{\\{x\\}} =\r\nV\\left(\\mathsf{p}(={x})\\right)\\)</span>; <span class=\"math inline\">\\(V(\\mathsf{b})\\)</span> is obviously the minimal\r\nclosed set in <span class=\"math inline\">\\(X\\)</span> which contains\r\n<span class=\"math inline\">\\(\\phi^{*}(V(\\mathsf{b}))\\)</span> since <span class=\"math inline\">\\(\\phi^{*}(\\mathsf{b}) \\in\r\n\\phi^{*}(V(\\mathsf{b}))\\)</span>.</p></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\begin{align}\r\n    \\require{AMScd}\r\n    \\begin{CD}\r\n        X @&lt;&lt;{\\phi^*}&lt; Y\\\\\r\n        @AA{\\tiny \\text{$\\cup$}}A  @AA{\\tiny \\text{$\\cup$}}A\\\\\r\n        V_A(\\phi^* (\\mathsf{b})) @&lt;&lt;{\\phi^*}&lt; V_B(\\mathsf{b})\\\\\r\n        @AA{\\text{$*$}}A  @AA{\\text{$*$}}A\\\\\r\n        \\text{Spec}(A/\\phi^* (\\mathsf{b})) @&lt;&lt;{\\tilde\\phi^*}&lt;\r\n\\text{Spec} (B/\\mathsf{b})\r\n    \\end{CD}\r\n\\end{align}\\]</span></p>\r\n<p><strong>Example:</strong> Let <span class=\"math inline\">\\(A\\)</span>\r\nbe an integral domain with just one non-zero prime ideal <span class=\"math inline\">\\(\\mathsf{p}\\)</span>. and let <span class=\"math inline\">\\(K\\)</span> be the field of fractions of <span class=\"math inline\">\\(A\\)</span>. Let <span class=\"math inline\">\\(B=(A/\\mathsf{p}) \\times K\\)</span>. Define <span class=\"math inline\">\\(\\phi: A \\to B\\)</span> by <span class=\"math inline\">\\(\\phi(x) = (\\bar{x}, x)\\)</span>, where <span class=\"math inline\">\\(\\bar{x}\\)</span> is the image of <span class=\"math inline\">\\(x\\)</span> in <span class=\"math inline\">\\(A/\\mathsf{p}\\)</span>. <span class=\"math inline\">\\(\\phi^{*}\\)</span> is bijective but not a\r\nhomeomorphism: Since <span class=\"math inline\">\\(A/\\mathsf{p}\\)</span>\r\nis also a field, hence <span class=\"math inline\">\\(B = (A/\\mathsf{p})\r\n\\times K\\)</span> has only two prime ideals <span class=\"math display\">\\[\\left\\{(1)\\times(0), (0)\r\n\\times(1)\\right\\}\\]</span> Direct computation yields <span class=\"math inline\">\\(\\phi^{*}\\)</span> is a bijection. However, <span class=\"math inline\">\\(\\{(1) \\times (0)\\}\\)</span> is a closed set of\r\n<span class=\"math inline\">\\(\\text{Spec}(B)\\)</span> whereas <span class=\"math inline\">\\(\\{(0)\\}\\)</span> is not closed in <span class=\"math inline\">\\(\\text{Spec}(A)\\)</span>.</p>\r\n<h2 id=\"more-on-separation-axiom-t_1-t_2\">More on Separation Axiom\r\n[<span class=\"math inline\">\\(T_{1}\\)</span>, <span class=\"math inline\">\\(T_{2}\\)</span>]</h2>\r\n<p>We define <span class=\"math display\">\\[\\mathscr{V}^{\\prime} = \\left\\{\r\n\\phi^{*}\\left(\\text{Spec}(B)\\right): \\text{ where $\\phi:A \\to B$ is ring\r\nhomomorphism} \\right\\}\\]</span> It can be verified that <span class=\"math inline\">\\(\\mathscr{V}^{\\prime}\\)</span> satisfies axiom of\r\nclosed set. The topology in <span class=\"math inline\">\\(\\text{Spec}(A)\\)</span> is called <a href=\"https://en.wikipedia.org/wiki/Constructible_topology\">constructable\r\ntopology</a>. which is finer than Zariski topology.</p>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(A/\\mathfrak{R}\\)</span> is <a href>absolutely flat</a> (<span class=\"math inline\">\\(\\mathfrak{R}\\)</span> being the nilradical of\r\n<span class=\"math inline\">\\(A\\)</span>).</li>\r\n<li>Every prime ideal of <span class=\"math inline\">\\(A\\)</span> is\r\nmaximal.</li>\r\n<li><span class=\"math inline\">\\(\\text{Spec} (A)\\)</span> is a <span class=\"math inline\">\\(T_{1}\\)</span>-space (i.e., every subset\r\nconsisting of a single point is closed).</li>\r\n<li><span class=\"math inline\">\\(\\text{Spec} (A)\\)</span> is\r\nHausdorff.</li>\r\n<li>The Zariski topology and the constructible topology on <span class=\"math inline\">\\(\\text{Spec} (A)\\)</span> coincide</li>\r\n</ol>\r\n<h2 id=\"proporsition-5-connectedness\">Proporsition 5\r\n[Connectedness]</h2>\r\n<p>If a commutative ring <span class=\"math inline\">\\(A\\)</span> with\r\nunit can be represented as direct product of non-zero ring, <span class=\"math inline\">\\(A_{i}, i=1, 2, \\cdots, n\\)</span>, By a standard\r\nresult in commutative ring, the ideals <span class=\"math inline\">\\(A=\\prod_{i=1}^{n}A_{i}\\)</span> has the form</p>\r\n<p><span class=\"math display\">\\[\\mathsf{a}_{1} \\times \\cdots \\times\r\n\\mathsf{a}_{i} \\times \\cdots \\times \\mathsf{a}_{n}, \\text{ where\r\n$\\mathsf{a}_{i}$ are ideals of $A_{i}$} \\]</span><br>\r\nEspecially, prime ideals in <span class=\"math inline\">\\(A\\)</span> has\r\nthe form</p>\r\n<p><span class=\"math display\">\\[(1) \\times \\cdots \\times \\mathsf{p}_{i}\r\n\\times \\cdots \\times (1), \\text{ where $\\mathsf{p}_{i}$ are prime ideals\r\nof $A_{i}$}\\]</span></p>\r\n<p>For ring <span class=\"math inline\">\\(A=\\prod_{i=1}^{n}A_{i}\\)</span>,\r\nthe spectrum <span class=\"math inline\">\\(X = \\text{Spec}(A)\\)</span> is\r\nthe disjoint union of <span class=\"math inline\">\\(X_{i}, i\r\n=1,2,\\cdots,n\\)</span>, where <span class=\"math inline\">\\(X_{i}\\)</span>\r\nconsists of prime ideals containing <span class=\"math inline\">\\((1)\r\n\\times \\cdots \\times \\underset{i}{(0)} \\times \\cdots \\times\r\n(1)\\)</span>, homeomorphic to <span class=\"math inline\">\\(\\text{Spec}(A_{i})\\)</span>. Hence <span class=\"math inline\">\\(X=\\text{Spec}(A)\\)</span> is not connected. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<p>Conversly, if the subsets <span class=\"math inline\">\\(X_{1}, X_{2}\r\n\\neq \\emptyset, X_{1} \\cap X_{2} = \\emptyset\\)</span> of <span class=\"math inline\">\\(X=\\text{Spec}(A)\\)</span> satisfies <span class=\"math inline\">\\(X_{1} \\cup X_{2} = X\\)</span>. According to the\r\ndefinition of spectrum, we have <span class=\"math inline\">\\(X_{1}\r\n=V(\\mathsf{a}_{1}), X_{2} =V(\\mathsf{a}_{2}),\\)</span> where <span class=\"math inline\">\\(\\mathsf{a}_{1},\\mathsf{a}_{2}\\)</span> are ideals\r\nof ring <span class=\"math inline\">\\(A\\)</span>, and <span class=\"math display\">\\[\r\n\\begin{aligned}\r\nV(\\mathsf{a}_{1}) \\cap V(\\mathsf{a}_{2}) = V(\\mathsf{a}_{1}\r\n+\\mathsf{a}_{2}) =\\emptyset &amp;\\Rightarrow\r\n\\mathsf{a}_{1} +\\mathsf{a}_{2} = (1)\\\\\r\nV(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2}) = V(\\mathsf{a}_{1} \\cap\r\n\\mathsf{a}_{2}) = X &amp;\\Rightarrow\r\n\\mathsf{a}_{1} \\cap \\mathsf{a}_{2} \\subseteq \\mathfrak{R}\r\n\\end{aligned}\r\n\\]</span> there exist <span class=\"math inline\">\\(x_{1} \\in\r\n\\mathsf{a}_{1}, x_{2} \\in \\mathsf{a}_{2}\\)</span>, and integer <span class=\"math inline\">\\(n&gt;0\\)</span> such that <span class=\"math display\">\\[\r\n\\begin{aligned}\r\nx_{1} + x_{2} &amp;=1\\\\\r\n(x_{1} x_{2})^{n} &amp;=0\r\n\\end{aligned}\r\n\\]</span> Due to elementary arithmetic it finds that <span class=\"math display\">\\[r(x_{1}^{n}) + r(x_{2}^{n}) =1 \\Rightarrow\r\n(x_{1}^{n}) + (x_{2}^{n}) =1 \\]</span>. Therefore we can find an\r\nidempotent <span class=\"math inline\">\\(e\\neq 0,1 \\in\r\n(x_{1}^{n})\\)</span> such that <span class=\"math inline\">\\(1 - e \\in\r\n(x_{2}^{n})\\)</span>, and <span class=\"math inline\">\\(e(1 - e) =\r\n0\\)</span>, because the non-empty assumption of <span class=\"math inline\">\\(X_{i}, i=1,2\\)</span>. Thereby <span class=\"math inline\">\\(A\\)</span> can be decomposed as the direct product\r\nof <span class=\"math inline\">\\(eA\\)</span> and <span class=\"math inline\">\\((1-e) A\\)</span>. $ $</p>\r\n<p>We summarize the result below:</p>\r\n<p>Let <span class=\"math inline\">\\(A\\)</span> be any commutative ring\r\nwith unit. The following statements are equivalent:</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(X = \\text{Spec} (A)\\)</span> is\r\ndisconnected.</p></li>\r\n<li><p><span class=\"math inline\">\\(A \\cong A_{1} \\times A_{2}\\)</span>\r\nwhere neither of the rings <span class=\"math inline\">\\(A_{1}\\)</span> or\r\n<span class=\"math inline\">\\(A_{2}\\)</span> is the zero ring.</p></li>\r\n<li><p><span class=\"math inline\">\\(A\\)</span> contains an idempotent\r\n<span class=\"math inline\">\\(\\neq 0,1\\)</span>.</p></li>\r\n</ol>\r\n<p><strong>Remark:</strong> Local ring, that is, ring with only one\r\nmaximal ideal, is always connected.</p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Michael Atiyah. Introduction to commutative algebra. CRC Press,\r\n2018.</p>\r\n<p>[2] Suzanne C Dieudonne. History Algebraic Geometry. CRC Press,\r\n1985.</p>\r\n<p>[3] Bartel L Van der Waerden. A history of algebra: From al-Khwārizmī\r\nto Emmy Noether. Springer Science &amp; Business Media, 2013.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"definition\">Definition</h2>\r\n<p>Let <span class=\"math inline\">\\(A\\)</span> be commutative ring with\r\nunit. <span class=\"math inline\">\\(\\text{Spec}(A)\\)</span> is the\r\ncollection of prime ideals of <span class=\"math inline\">\\(A\\)</span>.</p>\r\n<p><span class=\"math inline\">\\(V(E)\\)</span> is the collection of prime\r\nideals containing <span class=\"math inline\">\\(E \\subseteq A\\)</span>.\r\n<span class=\"math inline\">\\(\\{V(E); E \\subseteq A\\}\\)</span> is a\r\ncollection of closed subsets of <span class=\"math inline\">\\(\\text{Spec}\r\n(A)\\)</span>, since</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(V(1)=\\emptyset, V(0) =X\\)</span>.\r\nHence <a href=\"https://en.wikipedia.org/wiki/Closed_set\">Axiom of Closed\r\nSet I</a> is satisfied.</p></li>\r\n<li><p><span class=\"math inline\">\\(\\cap_{i \\in I} V(E_{i}) =V(\\cup_{i\r\n\\in I} E_{i})\\)</span>. Hence <a href=\"https://en.wikipedia.org/wiki/Closed_set\">Axiom of Closed Set\r\nII</a> is satisfied.</p></li>\r\n<li><p>To verify axiom III, Consider the ideal <span class=\"math inline\">\\(\\mathsf{a}_{1}\\)</span> generated by <span class=\"math inline\">\\(E_{1}\\)</span> and the ideal <span class=\"math inline\">\\(\\mathsf{a}_{2}\\)</span> generated by <span class=\"math inline\">\\(E_{2}\\)</span>. Note that <span class=\"math inline\">\\(V(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2}) \\subseteq\r\nV(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2})\\)</span>. Then, for any prime\r\nideal <span class=\"math inline\">\\(\\mathsf{p}\\)</span> containing <span class=\"math inline\">\\(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}\\)</span>, we\r\nhave <span class=\"math inline\">\\(\\mathsf{a}_{1} \\subseteq\r\n\\mathsf{p}\\)</span> or <span class=\"math inline\">\\(\\mathsf{a}_{2}\r\n\\subseteq \\mathsf{p}\\)</span>, since</p></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[ x_{1},x_{2} \\notin \\mathsf{p}\r\n\\Rightarrow x_{1}x_{2} \\notin \\mathsf{p} \\text{ while }\\,\\, x_{1}\\in\r\n\\mathsf{a}_{1}, x_{2}\\in \\mathsf{a}_{2} \\Rightarrow x_{1}x_{2} \\in\r\n\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}\\]</span></p>\r\n<p>This proves <span class=\"math inline\">\\(V(\\mathsf{a}_{1} \\cap\r\n\\mathsf{a}_{2}) \\subseteq V(\\mathsf{a}_{1}) \\cup\r\nV(\\mathsf{a}_{2})\\)</span>. Therefore, these sets equal to each other\r\n<span class=\"math inline\">\\(V(\\mathsf{a}_{1} \\cap \\mathsf{a}_{2}) =\r\nV(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2})\\)</span>, which verifies <a href=\"https://en.wikipedia.org/wiki/Closed_set\">Axiom of Closed Set\r\nIII</a>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"proporsition-1-topological-basis\">Proporsition 1 [Topological\r\nbasis]</h2>\r\n<p>Given an element <span class=\"math inline\">\\(f\\)</span> in <span class=\"math inline\">\\(A\\)</span>, we define <span class=\"math inline\">\\(X_{f}\\)</span> to be the complement of <span class=\"math inline\">\\(V(f)\\)</span> in <span class=\"math inline\">\\(X=\\text{Spec}(A)\\)</span>, so <span class=\"math display\">\\[ \\mathscr{U}^{\\prime} = \\{X_{f}; f\\in\r\nA\\}\\]</span></p>\r\n<p>is a <a href=\"https://en.wikipedia.org/wiki/Base_(topology)\">topological\r\nbasis</a> for <span class=\"math display\">\\[\\mathscr{U} = \\{ X\\backslash\r\nV(E); E \\subseteq A\\}\\]</span></p>\r\n<p>To see more clearly, Choose an open set <span class=\"math inline\">\\(O\r\n\\in \\mathscr{U}\\)</span>, it must be the complement of a closed set\r\n<span class=\"math inline\">\\(V(E)\\)</span> generated by some subset <span class=\"math inline\">\\(E\\)</span> of ring <span class=\"math inline\">\\(A\\)</span>, that is, <span class=\"math inline\">\\(O\r\n= X\\backslash V(E)\\)</span>. Decompose <span class=\"math inline\">\\(E\\)</span> into the union of its components <span class=\"math inline\">\\(\\left\\{f\\right\\}\\)</span> we have <span class=\"math inline\">\\(E = \\cup_{f\\in E}\\{f\\}\\)</span>, by utilize axiom\r\nof closed set III</p>\r\n<p><span class=\"math display\">\\[\r\n    O =X\\backslash \\left(\\cap_{f \\in E} V(f)\\right) = \\cup_{f\\in E}\r\n\\left(X \\backslash V(f)\\right) =\\cup_{f\\in E} X_{f}\r\n\\]</span></p>\r\n<p>That is to say <span class=\"math inline\">\\(\\mathscr{U}^{\\prime}\\)</span> is a topological\r\nbasis for <span class=\"math inline\">\\(\\mathscr{U}\\)</span>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<p><br></p>\r\n<h2 id=\"proporsition-1-countability-axiom-not-c_1\">Proporsition 1\r\n[Countability Axiom, not <span class=\"math inline\">\\(C_{1}\\)</span>]</h2>\r\n<h2 id=\"example\">Example</h2>\r\n<p>Let <span class=\"math inline\">\\(A\\)</span> be <a href=\"https://en.wikipedia.org/wiki/Unique_factorization_domain\">UFD</a>.\r\n<span class=\"math inline\">\\(I\\)</span> is an index set, <span class=\"math inline\">\\(|I| \\geq \\aleph_{1}\\)</span>. For each index <span class=\"math inline\">\\(i\\in I\\)</span> associate with a variable <span class=\"math inline\">\\(x_{i}\\)</span>, Consider polynomial ring with\r\ncoeffiecients in <span class=\"math inline\">\\(A\\)</span> <span class=\"math display\">\\[ A[I] := \\{\\sum a_{i_{1},i_{2},\\cdots,i_{k}}\r\nx_{i_{i}}^{n_{1}}x_{i_{2}}^{n_{2}} \\cdots x_{i_{k}}^{n_{k}} :\r\na_{i_{1},i_{2},\\cdots,i_{k}}\\in A \\}\\]</span> . Since <span class=\"math inline\">\\(A[I]\\)</span> in integral domain, <span class=\"math inline\">\\((0)\\)</span> is a prime ideal. The Zariski\r\ntopological basis <span class=\"math inline\">\\(\\{X_{f}; {f \\in\r\nA(I)}\\}\\)</span> for ring <span class=\"math inline\">\\(A(I)\\)</span> with\r\nemptyset exception, that is <span class=\"math inline\">\\(f\\neq\r\n0\\)</span>, is a neighborhood basis at <span class=\"math inline\">\\((0)\\)</span> for <span class=\"math inline\">\\(\\text{Spec}(A[I])\\)</span> . Since <span class=\"math inline\">\\(A[I]\\)</span> is either UFD, <span class=\"math inline\">\\(A[I]\\)</span> contains uncoutable many prime idels\r\n<span class=\"math inline\">\\((x_{i}), {i \\in I}\\)</span>, which implies\r\n<span class=\"math inline\">\\(A[I]\\)</span> dose not satisfies <a href=\"https://en.wikipedia.org/wiki/First-countable_space\">first-countable\r\naxiom <span class=\"math inline\">\\(C_{1}\\)</span></a>.</p>\r\n<p>For topological space, we are also interested in its separation,\r\ncompactness and connectedness etc.</p>\r\n<h2 id=\"proporsition-2-separation-axiom-t_0\">Proporsition 2 [Separation\r\nAxiom <span class=\"math inline\">\\(T_{0}\\)</span>]</h2>\r\n<p>A topological space <span class=\"math inline\">\\((X,\\mathscr{U})\\)</span> satisfies <a href=\"https://en.wikipedia.org/wiki/Kolmogorov_space\">separtion axiom\r\n<span class=\"math inline\">\\(T_{0}\\)</span></a> separation, if for any\r\n<span class=\"math inline\">\\(x,y \\in X\\)</span>, <span class=\"math inline\">\\(x\\neq y\\)</span>, there exists open set <span class=\"math inline\">\\(U \\in \\mathscr{U}\\)</span>, such that <span class=\"math inline\">\\(x\\in U, y \\notin U\\)</span> of if <span class=\"math inline\">\\(y \\in U, x \\notin U\\)</span>.</p>\r\n<p>Let <span class=\"math inline\">\\(x,y\\)</span> be distinct two points\r\nin <span class=\"math inline\">\\(X=\\text{Spec}(A)\\)</span>, i.e. two\r\ndistinct prime ideals <span class=\"math inline\">\\(\\mathsf{p}_{x},\\mathsf{p}_{y}\\)</span> of ring\r\n<span class=\"math inline\">\\(A\\)</span>:</p>\r\n<ol type=\"1\">\r\n<li><p>If <span class=\"math inline\">\\(\\mathsf{p}_{x} \\subseteq\r\n\\mathsf{p}_{y}\\)</span>, then <span class=\"math inline\">\\(V(\\mathsf{p}_{y}) \\subseteq\r\nV(\\mathsf{p}_{x})\\)</span>. Taking <span class=\"math inline\">\\(U= X\r\n\\backslash V(\\mathsf{p}_{y})\\)</span> we have <span class=\"math inline\">\\(x\\in U, y \\notin U\\)</span>.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(\\mathsf{p}_{x} \\subsetneq\r\n\\mathsf{p}_{y}\\)</span>, thereby <span class=\"math inline\">\\(\\mathsf{p}_{y} \\notin V(\\mathsf{p}_{x})\\)</span>.\r\nTaking <span class=\"math inline\">\\(U = X \\backslash\r\nV(\\mathsf{p}_{x})\\)</span> we have <span class=\"math inline\">\\(y \\in U,\r\nx \\notin U\\)</span>.</p></li>\r\n</ol>\r\n<p>This together impies that <span class=\"math inline\">\\(X=\\text{Spec}(A)\\)</span> satisfies separation\r\naxiom <span class=\"math inline\">\\(T_{0}\\)</span>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"propersition-3-compactness\">Propersition 3 [Compactness]</h2>\r\n<p>We next prove <span class=\"math inline\">\\(X = \\text{Spec}\r\n(A)\\)</span> is (compact)[]. It only suffices to consider covering from\r\ntopological basis <span class=\"math inline\">\\(\\{X_{f}; {f\\in\r\nE}\\}\\)</span>, where <span class=\"math inline\">\\(E\\neq\r\n\\emptyset\\)</span> is a subset of ring <span class=\"math inline\">\\(A\\)</span>. Accrording to (De Morgan law)[] and\r\naxiom of closed set III, nota that <span class=\"math display\">\\[\r\nX \\backslash \\left(\\cup_{f\\in E} X_{f}\\right) = \\cap_{f\\in E} \\left(X\r\n\\backslash X_{f} \\right) = V (\\cup_{f\\in E}  \\{f\\})\r\n\\]</span> hence <span class=\"math inline\">\\(\\cup_{f\\in E} X_{f} = X\r\n\\Leftrightarrow  V(E) =\\emptyset\\)</span>. Let the ideal generated by\r\n<span class=\"math inline\">\\(E\\)</span> be <span class=\"math inline\">\\(\\mathsf{a}\\)</span>, we show that $= (1) $:</p>\r\n<blockquote>\r\n<p>Let <span class=\"math inline\">\\(\\Sigma\\)</span> consist of\r\nnon-trivial ideals of <span class=\"math inline\">\\(A\\)</span>. Since the\r\nnon-decreasing chain of ideals are also an ideal, by Zorn lemma, if\r\n<span class=\"math inline\">\\(\\Sigma \\neq \\emptyset\\)</span>, <span class=\"math inline\">\\(\\Sigma\\)</span> contains a maximal element <span class=\"math inline\">\\(\\mathsf{a}_{0}\\)</span> with respect to <span class=\"math inline\">\\(\\subseteq\\)</span>-partial ordering; it is indeed\r\nan maximal ideal. (Otherwise, if there exist another <span class=\"math inline\">\\(\\mathsf{a}_{0}^{\\prime}\\)</span> such that <span class=\"math inline\">\\(\\mathsf{a}_{0} \\subseteq\r\n\\mathsf{a}_{0}^{\\prime}\\)</span>, <span class=\"math inline\">\\(\\mathsf{a}_{0}^{\\prime} = \\mathsf{a}_{0} \\cup\r\n\\mathsf{a}_{0}^{\\prime}\\)</span> is maximal with respect to inclusion\r\nrelation.) It also can be proved that if <span class=\"math inline\">\\(\\mathsf{a} \\neq (1)\\)</span>, <span class=\"math inline\">\\(\\mathsf{a}\\)</span> is contained in a maximal\r\nideal. Hence if <span class=\"math inline\">\\(\\mathsf{a} \\neq\r\n(1)\\)</span>, <span class=\"math inline\">\\(V(\\mathsf{a})\\)</span>\r\ncontains at least an element. Contradiction. <span class=\"math inline\">\\(\\square\\)</span> <a href=\"https://en.wikipedia.org/wiki/Zorn%27s_lemma\">[See Zorn\r\nlemma]</a></p>\r\n</blockquote>\r\n<p>Therefore <span class=\"math inline\">\\(1\\)</span> can be represented\r\nby a finite sum of products of elements from <span class=\"math inline\">\\(E\\)</span> and <span class=\"math inline\">\\(A\\)</span>: <span class=\"math display\">\\[1 =\r\ng_{1}f_{1} + \\cdots + g_{n}f_{n}, \\quad g_{i}\\in A, f_{i} \\in E, 1 \\leq\r\ni \\leq n\\]</span> Take <span class=\"math inline\">\\(F= \\{f_{1}, \\cdots,\r\nf_{n}\\}\\)</span>, thereby <span class=\"math inline\">\\(V(F) =\r\n\\emptyset\\)</span>, which implies <span class=\"math inline\">\\(\\{X_{f};\r\n{f \\in F}\\}\\)</span> covers <span class=\"math inline\">\\(X\\)</span>.\r\n<span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"definition-nilradical-and-radical\">Definition [Nilradical and\r\nRadical]</h2>\r\n<p>The ideal <span class=\"math inline\">\\(\\mathfrak{R}\\)</span> of all\r\nnipotents in a commutative ring <span class=\"math inline\">\\(A\\)</span>\r\nwith unit <span class=\"math inline\">\\(1\\)</span> is the insection of all\r\nprime ideals of <span class=\"math inline\">\\(A\\)</span>, that is, <span class=\"math display\">\\[\r\n\\mathfrak{R} = \\bigcap_{\\mathsf{p} \\text{ is a prime ideal of $A$}}\r\n\\mathsf{p}\r\n\\]</span></p>\r\n<p>Of course <span class=\"math inline\">\\(\\mathfrak{R}\\)</span> is an\r\nideal closed under addition and multiplicatio. We split the proof in two\r\nsteps:</p>\r\n<ol type=\"1\">\r\n<li><p>If <span class=\"math inline\">\\(\\mathsf{p}\\)</span> is a prime\r\nideal, then <span class=\"math inline\">\\(\\mathfrak{R}\\subseteq\r\n\\mathsf{p}\\)</span>. Since <span class=\"math inline\">\\(0 \\in\r\n\\mathsf{p}\\)</span>, and we know for any <span class=\"math inline\">\\(f\r\n\\in \\mathfrak{R}\\)</span>, there exist an integer <span class=\"math inline\">\\(n&gt;0\\)</span> such that <span class=\"math display\">\\[f^{n} \\in \\mathsf{p} \\Rightarrow \\cdots\r\n\\Rightarrow  f \\in \\mathsf{p}\\]</span></p></li>\r\n<li><p>If <span class=\"math inline\">\\(f\\)</span> in not nilpotent, then\r\nthere is a prime ideal <span class=\"math inline\">\\(\\mathsf{p} \\cap \\{f\\}\r\n= \\emptyset\\)</span>. Let <span class=\"math display\">\\[\\Sigma = \\left\\{\r\n\\mathsf{a} \\text{ is an ideal of $A$}: \\text{for any $n \\in\r\n\\mathbb{N}_{*}$, }f^{n} \\notin \\mathsf{a} \\right\\}\\]</span></p></li>\r\n</ol>\r\n<blockquote>\r\n<p>Since <span class=\"math inline\">\\((0) \\in \\Sigma\\)</span>. By Zorn\r\nlemma, <span class=\"math inline\">\\(\\Sigma\\)</span> contains maximal\r\nelement <span class=\"math inline\">\\(\\mathsf{p}\\)</span> with respect to\r\n<span class=\"math inline\">\\(\\subseteq\\)</span>-inclusion partial\r\nordering. This <span class=\"math inline\">\\(\\mathsf{p}\\)</span> is indeed\r\na prime ideal, because: For any <span class=\"math inline\">\\(x,y \\notin\r\n\\mathsf{p}\\)</span>, thanks to the maximal proporty of <span class=\"math inline\">\\(\\mathsf{p}\\)</span> we have <span class=\"math inline\">\\(\\mathsf{p} +  (x)\\)</span>, <span class=\"math inline\">\\(\\mathsf{p} + (y)\\)</span> <span class=\"math inline\">\\(\\notin \\Sigma\\)</span>; however, <span class=\"math display\">\\[\\begin{aligned}\r\nf^{m} \\in\\mathsf{p} + (x) &amp;, f^{n} \\in \\mathsf{p} +(y) \\Rightarrow\r\nf^{m+n} \\in \\mathsf{p} + (xy)\r\n\\end{aligned}\\]</span> implies <span class=\"math inline\">\\(\\mathsf{p} +\r\n(xy)  \\notin \\Sigma\\)</span>; therefore <span class=\"math inline\">\\(xy\r\n\\notin \\mathsf{p}\\)</span>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n</blockquote>\r\n<p>Denote <span class=\"math display\">\\[r(\\mathsf{a}): = \\{f\\in A:\r\n\\text{there exist integer } n &gt;0 \\text{ such that } f^{n} \\in\r\n\\mathsf{a}\\}\\]</span> which is the intersection of all prime ideals\r\ncontaining <span class=\"math inline\">\\(\\mathsf{a}\\)</span> by <a href=\"https://en.wikipedia.org/wiki/Isomorphism_theorems\">correspondence\r\ntheorem</a>.</p>\r\n<h2 id=\"definition-irreducibility\">Definition [Irreducibility]</h2>\r\n<p>A topological space <span class=\"math inline\">\\((X,\\mathscr{U})\\)</span> is said to be <a href>irreducible</a> if <span class=\"math inline\">\\(X\\neq\r\n\\emptyset\\)</span> and <span class=\"math inline\">\\(X\\)</span> can't be\r\nunion of any two non-empty open sets <span class=\"math inline\">\\(X =\r\nX_{1} \\cup X_{2}\\)</span>, or equivalently, if <span class=\"math inline\">\\(U_{1}, U_{2} \\neq \\emptyset\\)</span> are any two\r\nnon-empty open sets, then <span class=\"math inline\">\\(U_{1} \\cap U_{2}\r\n\\neq \\emptyset\\)</span>.</p>\r\n<p><strong>Remark:</strong> According to the definition, irreducibility\r\nif finer than connectness, because two open sets <span class=\"math inline\">\\(X_{1},X_{2}\\)</span> can be intersected.</p>\r\n<h2 id=\"theorem-1irreducibility\">Theorem 1[Irreducibility]</h2>\r\n<p><span class=\"math inline\">\\(\\text{Spec}(A)\\)</span> is irreducible if\r\nand only if its nilradical <span class=\"math inline\">\\(\\mathfrak{R}\\)</span> of <span class=\"math inline\">\\(A\\)</span> is a prime ideal.</p>\r\n<p>For any two non-empty open sets <span class=\"math inline\">\\(\\cup_{f\r\n\\in F} X_{f}\\)</span> and <span class=\"math inline\">\\(\\cup_{g \\in G}\r\nX_{g}\\)</span> in <span class=\"math inline\">\\(X=\\text{Spec}(A)\\)</span>.\r\n<span class=\"math display\">\\[\r\n\\begin{aligned}\r\n        \\cup_{f \\in F} X_{f} \\neq \\emptyset &amp;\\Leftrightarrow \\cap_{f\r\n\\in E} V(f) \\neq X \\Leftrightarrow \\exists f_{0} \\notin \\mathfrak{R}\\\\\r\n        \\left(\\cup_{f \\in F} X_{f}\\right) \\cap \\left(\\cup_{g \\in G}\r\nX_{g}\\right) \\neq \\emptyset &amp;\\Leftrightarrow \\cup_{f \\in F, g\\in G}\r\n\\left(X_{fg}\\right) \\neq \\emptyset \\Leftrightarrow \\exists f_{0}\\in F,\r\ng_{0} \\in G, f_{0}g_{0} \\notin \\mathfrak{R}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><strong>Remark 1:</strong> Singletons <span class=\"math inline\">\\(\\{x\\}, x\\in X\\)</span> are irreducible subspaces;\r\nthe closure of irreducible subspaces in <span class=\"math inline\">\\(X\\)</span> are irreducible subspaces.</p>\r\n<p><strong>Remark 2:</strong> Each singleton <span class=\"math inline\">\\(\\{x\\}, x\\in X\\)</span> contained in a maximal\r\nirreducible subspace of <span class=\"math inline\">\\(X\\)</span>, which is\r\ncalled <a href=\"https://en.wikipedia.org/wiki/Irreducible_component\">irreducible\r\ncomponent</a>. The irrducible components cover <span class=\"math inline\">\\(X\\)</span>.</p>\r\n<p><strong>Remark 3:</strong> In an irreducible Hausdorff space <span class=\"math inline\">\\(X\\)</span>, the irrducible components of <span class=\"math inline\">\\(X\\)</span> are singletons. However, the conected\r\ncomponents, for instance, Euclidean space, are itself.</p>\r\n<p>By taking quotient <span class=\"math inline\">\\(A/\\mathsf{p}\\)</span>\r\nand noting that there is a one-to-one correspondence <span class=\"math inline\">\\(h:\\mathsf{a} \\mapsto \\mathsf{a}/\r\n\\mathsf{p}\\)</span> between <span class=\"math inline\">\\(V(\\mathsf{p})\\)</span> and <span class=\"math inline\">\\(\\text{Spec}(A/\\mathsf{p})\\)</span> that preserves\r\nprime ideals, there is a one-to-one correspondence between <span class=\"math inline\">\\(r(\\mathsf{p}) = \\cap_{\\mathsf{p}_{x} \\in\r\nV(\\mathsf{p})} \\mathsf{p}_{x}\\)</span> and <span class=\"math inline\">\\(\\mathfrak{R} (A/\\mathsf{p}) =  \\cap_{x\\in\r\n\\text{Spec}(A/\\mathsf{p})} x\\)</span>, as is shown in the diagram</p>\r\n<p><span class=\"math display\">\\[\\begin{align}\r\n    \\require{AMScd}\r\n    \\begin{CD}\r\n        V(\\mathsf{p}) @&gt;&gt;h&gt; \\text{Spec} (A/\\mathsf{p})\\\\\r\n        @VV{\\tiny \\text{cap}}V @VV{\\tiny \\text{cap}}V\\\\\r\n        r(\\mathsf{p}) @&gt;&gt;h&gt; \\mathfrak{R} (A/\\mathsf{p})\r\n    \\end{CD}\r\n\\end{align}\\]</span></p>\r\n<p>According to above theorem and</p>\r\n<blockquote>\r\n<p>Non-zero ring <span class=\"math inline\">\\(A\\)</span> has minimal\r\nprime ideals with respect to set inclusion. By Zorn's lemma, it only\r\nsuffices to prove that the intersection <span class=\"math inline\">\\(\\cap_{n}\\mathsf{p}_{n}\\)</span> of a\r\nnon-increasing sequence of prime ideals <span class=\"math inline\">\\(\\cdots \\supseteq \\mathsf{p}_{n} \\supseteq\r\n\\mathsf{p}_{n+1}\\supseteq \\cdots\\)</span> is also a prime ideal. By\r\nconsidering <span class=\"math inline\">\\(x,y \\in A, xy \\in\r\n\\cap_{n}\\mathsf{p}_{n}\\)</span>, we have for each <span class=\"math inline\">\\(n\\)</span>, either <span class=\"math inline\">\\(x\\)</span> or <span class=\"math inline\">\\(y\\)</span> belongs to <span class=\"math inline\">\\(\\mathsf{p}_{n}\\)</span>. Then one of <span class=\"math inline\">\\(x\\)</span> and <span class=\"math inline\">\\(y\\)</span> occurs in <span class=\"math inline\">\\(\\mathsf{p}_{n}\\)</span> for infinitely many times,\r\nsay, for example, <span class=\"math inline\">\\(x  \\in\r\n\\cap_{n}\\mathsf{p}_{n}\\)</span>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n</blockquote>\r\n<p>we only need to show that <span class=\"math inline\">\\(h\\)</span> is a\r\nhomeomorphism, which is indeed true since <span class=\"math inline\">\\(h\\)</span> maps <span class=\"math inline\">\\(V(\\mathsf{a}) \\cap V(\\mathsf{p}) = V(\\mathsf{a} +\r\n\\mathsf{p})\\)</span> to <span class=\"math inline\">\\(V((\\mathsf{a} +\r\n\\mathsf{p})/ \\mathsf{p})\\)</span> and vice versa, where <span class=\"math inline\">\\(\\mathsf{a}\\)</span> is an ideal of <span class=\"math inline\">\\(A\\)</span>. Similarily, the closed subspace <span class=\"math inline\">\\(V(\\mathsf{p})\\)</span> of <span class=\"math inline\">\\(\\text{Spec}(A)\\)</span> is irreducible if and only\r\nif <span class=\"math inline\">\\(r(\\mathsf{p})\\)</span> is a prime ideal,\r\nwhere <span class=\"math inline\">\\(\\mathsf{p}\\)</span> is an ideal of\r\n<span class=\"math inline\">\\(A\\)</span>. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<h2 id=\"property-4-homomorphism\">Property 4 [Homomorphism]</h2>\r\n<p>Let <span class=\"math inline\">\\(\\phi: A \\to B\\)</span> be\r\nhomomorphism that preserves unit. <span class=\"math inline\">\\(X=\\text{Spec}(A) , Y=\\text{Spec}(B)\\)</span>.\r\nSince <span class=\"math inline\">\\(\\phi^{-1}\\)</span> draws back prime\r\nideals in <span class=\"math inline\">\\(Y\\)</span> into prime ideals in\r\n<span class=\"math inline\">\\(X\\)</span>, <span class=\"math inline\">\\(\\phi\\)</span> introduces naturally a mapping <span class=\"math inline\">\\(\\phi^{*}:  \\text{Spec}(B) \\to\r\n\\text{Spec}(A)\\)</span> by <span class=\"math inline\">\\(\\mathsf{q}\r\n\\mapsto \\phi^{-1} (\\mathsf{q})\\)</span></p>\r\n<ol type=\"1\">\r\n<li><p>It is easy to verify that <span class=\"math inline\">\\((\\phi^{*})^{-1}(X_{f}) =Y_{\\phi(f)}\\)</span>,\r\nwhich implies <span class=\"math inline\">\\(\\phi^{*}\\)</span> is\r\ncontinuous.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(\\phi\\)</span> is surjective, then\r\n<span class=\"math inline\">\\(\\phi^{*}\\)</span> is injective. By <a href=\"https://en.wikipedia.org/wiki/Fundamental_theorem_on_homomorphisms\">Fundamental\r\ntheorem on homomorphisms</a>, <span class=\"math inline\">\\(A/\\ker(\\phi)\r\n\\cong B\\)</span>. Note in above we mention that <span class=\"math inline\">\\(\\phi\\)</span> is a homeomorphism mappping, thereby\r\n<span class=\"math inline\">\\(\\phi^{*}\\)</span> establish a homeomorphism\r\nbetween <span class=\"math inline\">\\(Y=\\text{Spec}(B)\\)</span> and <span class=\"math inline\">\\(V\\left(\\ker(\\phi)\\right)\\)</span>.</p></li>\r\n<li><p><span class=\"math inline\">\\(\\overline{\\phi^{*}(V(\\mathsf{b}))} =\r\nV(\\phi^{*}(\\mathsf{b}))\\)</span>. Hence if <span class=\"math inline\">\\(\\phi\\)</span> is injective, then <span class=\"math inline\">\\(\\phi^{*}(Y)\\)</span> is dense in <span class=\"math inline\">\\(X\\)</span>. Let <span class=\"math inline\">\\(\\mathsf{q} \\in V(\\mathsf{b})\\)</span> and note\r\nthat $^{*}() = ^{-1}() ^{-1}() $, so <span class=\"math inline\">\\(\\phi^{-1}(\\mathsf{q}) \\in\r\nV(\\phi^{*}(\\mathsf{b}))\\)</span> and <span class=\"math inline\">\\(\\mathsf{q} \\in\r\n\\phi(V(\\phi^{*}(\\mathsf{b})))\\)</span>. Thus <span class=\"math inline\">\\(V(\\mathsf{b}) \\subseteq\r\n\\phi(V(\\phi^{*}(\\mathsf{b})))\\)</span>. Then note that <span class=\"math display\">\\[y \\in \\overline{\\{x\\}} \\Leftrightarrow\r\n\\overline{\\{y\\}} \\subseteq \\overline{\\{x\\}} \\Leftrightarrow\r\nV(\\mathsf{p}_{y}) \\subseteq V(\\mathsf{p}_{x}) \\Leftrightarrow\r\n\\mathsf{p}_{x} \\subseteq \\mathsf{p}_{y}\\]</span> which says <span class=\"math inline\">\\(\\overline{\\{x\\}} =\r\nV\\left(\\mathsf{p}(={x})\\right)\\)</span>; <span class=\"math inline\">\\(V(\\mathsf{b})\\)</span> is obviously the minimal\r\nclosed set in <span class=\"math inline\">\\(X\\)</span> which contains\r\n<span class=\"math inline\">\\(\\phi^{*}(V(\\mathsf{b}))\\)</span> since <span class=\"math inline\">\\(\\phi^{*}(\\mathsf{b}) \\in\r\n\\phi^{*}(V(\\mathsf{b}))\\)</span>.</p></li>\r\n</ol>\r\n<p><span class=\"math display\">\\[\\begin{align}\r\n    \\require{AMScd}\r\n    \\begin{CD}\r\n        X @&lt;&lt;{\\phi^*}&lt; Y\\\\\r\n        @AA{\\tiny \\text{$\\cup$}}A  @AA{\\tiny \\text{$\\cup$}}A\\\\\r\n        V_A(\\phi^* (\\mathsf{b})) @&lt;&lt;{\\phi^*}&lt; V_B(\\mathsf{b})\\\\\r\n        @AA{\\text{$*$}}A  @AA{\\text{$*$}}A\\\\\r\n        \\text{Spec}(A/\\phi^* (\\mathsf{b})) @&lt;&lt;{\\tilde\\phi^*}&lt;\r\n\\text{Spec} (B/\\mathsf{b})\r\n    \\end{CD}\r\n\\end{align}\\]</span></p>\r\n<p><strong>Example:</strong> Let <span class=\"math inline\">\\(A\\)</span>\r\nbe an integral domain with just one non-zero prime ideal <span class=\"math inline\">\\(\\mathsf{p}\\)</span>. and let <span class=\"math inline\">\\(K\\)</span> be the field of fractions of <span class=\"math inline\">\\(A\\)</span>. Let <span class=\"math inline\">\\(B=(A/\\mathsf{p}) \\times K\\)</span>. Define <span class=\"math inline\">\\(\\phi: A \\to B\\)</span> by <span class=\"math inline\">\\(\\phi(x) = (\\bar{x}, x)\\)</span>, where <span class=\"math inline\">\\(\\bar{x}\\)</span> is the image of <span class=\"math inline\">\\(x\\)</span> in <span class=\"math inline\">\\(A/\\mathsf{p}\\)</span>. <span class=\"math inline\">\\(\\phi^{*}\\)</span> is bijective but not a\r\nhomeomorphism: Since <span class=\"math inline\">\\(A/\\mathsf{p}\\)</span>\r\nis also a field, hence <span class=\"math inline\">\\(B = (A/\\mathsf{p})\r\n\\times K\\)</span> has only two prime ideals <span class=\"math display\">\\[\\left\\{(1)\\times(0), (0)\r\n\\times(1)\\right\\}\\]</span> Direct computation yields <span class=\"math inline\">\\(\\phi^{*}\\)</span> is a bijection. However, <span class=\"math inline\">\\(\\{(1) \\times (0)\\}\\)</span> is a closed set of\r\n<span class=\"math inline\">\\(\\text{Spec}(B)\\)</span> whereas <span class=\"math inline\">\\(\\{(0)\\}\\)</span> is not closed in <span class=\"math inline\">\\(\\text{Spec}(A)\\)</span>.</p>\r\n<h2 id=\"more-on-separation-axiom-t_1-t_2\">More on Separation Axiom\r\n[<span class=\"math inline\">\\(T_{1}\\)</span>, <span class=\"math inline\">\\(T_{2}\\)</span>]</h2>\r\n<p>We define <span class=\"math display\">\\[\\mathscr{V}^{\\prime} = \\left\\{\r\n\\phi^{*}\\left(\\text{Spec}(B)\\right): \\text{ where $\\phi:A \\to B$ is ring\r\nhomomorphism} \\right\\}\\]</span> It can be verified that <span class=\"math inline\">\\(\\mathscr{V}^{\\prime}\\)</span> satisfies axiom of\r\nclosed set. The topology in <span class=\"math inline\">\\(\\text{Spec}(A)\\)</span> is called <a href=\"https://en.wikipedia.org/wiki/Constructible_topology\">constructable\r\ntopology</a>. which is finer than Zariski topology.</p>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(A/\\mathfrak{R}\\)</span> is <a href>absolutely flat</a> (<span class=\"math inline\">\\(\\mathfrak{R}\\)</span> being the nilradical of\r\n<span class=\"math inline\">\\(A\\)</span>).</li>\r\n<li>Every prime ideal of <span class=\"math inline\">\\(A\\)</span> is\r\nmaximal.</li>\r\n<li><span class=\"math inline\">\\(\\text{Spec} (A)\\)</span> is a <span class=\"math inline\">\\(T_{1}\\)</span>-space (i.e., every subset\r\nconsisting of a single point is closed).</li>\r\n<li><span class=\"math inline\">\\(\\text{Spec} (A)\\)</span> is\r\nHausdorff.</li>\r\n<li>The Zariski topology and the constructible topology on <span class=\"math inline\">\\(\\text{Spec} (A)\\)</span> coincide</li>\r\n</ol>\r\n<h2 id=\"proporsition-5-connectedness\">Proporsition 5\r\n[Connectedness]</h2>\r\n<p>If a commutative ring <span class=\"math inline\">\\(A\\)</span> with\r\nunit can be represented as direct product of non-zero ring, <span class=\"math inline\">\\(A_{i}, i=1, 2, \\cdots, n\\)</span>, By a standard\r\nresult in commutative ring, the ideals <span class=\"math inline\">\\(A=\\prod_{i=1}^{n}A_{i}\\)</span> has the form</p>\r\n<p><span class=\"math display\">\\[\\mathsf{a}_{1} \\times \\cdots \\times\r\n\\mathsf{a}_{i} \\times \\cdots \\times \\mathsf{a}_{n}, \\text{ where\r\n$\\mathsf{a}_{i}$ are ideals of $A_{i}$} \\]</span><br>\r\nEspecially, prime ideals in <span class=\"math inline\">\\(A\\)</span> has\r\nthe form</p>\r\n<p><span class=\"math display\">\\[(1) \\times \\cdots \\times \\mathsf{p}_{i}\r\n\\times \\cdots \\times (1), \\text{ where $\\mathsf{p}_{i}$ are prime ideals\r\nof $A_{i}$}\\]</span></p>\r\n<p>For ring <span class=\"math inline\">\\(A=\\prod_{i=1}^{n}A_{i}\\)</span>,\r\nthe spectrum <span class=\"math inline\">\\(X = \\text{Spec}(A)\\)</span> is\r\nthe disjoint union of <span class=\"math inline\">\\(X_{i}, i\r\n=1,2,\\cdots,n\\)</span>, where <span class=\"math inline\">\\(X_{i}\\)</span>\r\nconsists of prime ideals containing <span class=\"math inline\">\\((1)\r\n\\times \\cdots \\times \\underset{i}{(0)} \\times \\cdots \\times\r\n(1)\\)</span>, homeomorphic to <span class=\"math inline\">\\(\\text{Spec}(A_{i})\\)</span>. Hence <span class=\"math inline\">\\(X=\\text{Spec}(A)\\)</span> is not connected. <span class=\"math inline\">\\(\\square\\)</span></p>\r\n<p>Conversly, if the subsets <span class=\"math inline\">\\(X_{1}, X_{2}\r\n\\neq \\emptyset, X_{1} \\cap X_{2} = \\emptyset\\)</span> of <span class=\"math inline\">\\(X=\\text{Spec}(A)\\)</span> satisfies <span class=\"math inline\">\\(X_{1} \\cup X_{2} = X\\)</span>. According to the\r\ndefinition of spectrum, we have <span class=\"math inline\">\\(X_{1}\r\n=V(\\mathsf{a}_{1}), X_{2} =V(\\mathsf{a}_{2}),\\)</span> where <span class=\"math inline\">\\(\\mathsf{a}_{1},\\mathsf{a}_{2}\\)</span> are ideals\r\nof ring <span class=\"math inline\">\\(A\\)</span>, and <span class=\"math display\">\\[\r\n\\begin{aligned}\r\nV(\\mathsf{a}_{1}) \\cap V(\\mathsf{a}_{2}) = V(\\mathsf{a}_{1}\r\n+\\mathsf{a}_{2}) =\\emptyset &amp;\\Rightarrow\r\n\\mathsf{a}_{1} +\\mathsf{a}_{2} = (1)\\\\\r\nV(\\mathsf{a}_{1}) \\cup V(\\mathsf{a}_{2}) = V(\\mathsf{a}_{1} \\cap\r\n\\mathsf{a}_{2}) = X &amp;\\Rightarrow\r\n\\mathsf{a}_{1} \\cap \\mathsf{a}_{2} \\subseteq \\mathfrak{R}\r\n\\end{aligned}\r\n\\]</span> there exist <span class=\"math inline\">\\(x_{1} \\in\r\n\\mathsf{a}_{1}, x_{2} \\in \\mathsf{a}_{2}\\)</span>, and integer <span class=\"math inline\">\\(n&gt;0\\)</span> such that <span class=\"math display\">\\[\r\n\\begin{aligned}\r\nx_{1} + x_{2} &amp;=1\\\\\r\n(x_{1} x_{2})^{n} &amp;=0\r\n\\end{aligned}\r\n\\]</span> Due to elementary arithmetic it finds that <span class=\"math display\">\\[r(x_{1}^{n}) + r(x_{2}^{n}) =1 \\Rightarrow\r\n(x_{1}^{n}) + (x_{2}^{n}) =1 \\]</span>. Therefore we can find an\r\nidempotent <span class=\"math inline\">\\(e\\neq 0,1 \\in\r\n(x_{1}^{n})\\)</span> such that <span class=\"math inline\">\\(1 - e \\in\r\n(x_{2}^{n})\\)</span>, and <span class=\"math inline\">\\(e(1 - e) =\r\n0\\)</span>, because the non-empty assumption of <span class=\"math inline\">\\(X_{i}, i=1,2\\)</span>. Thereby <span class=\"math inline\">\\(A\\)</span> can be decomposed as the direct product\r\nof <span class=\"math inline\">\\(eA\\)</span> and <span class=\"math inline\">\\((1-e) A\\)</span>. $ $</p>\r\n<p>We summarize the result below:</p>\r\n<p>Let <span class=\"math inline\">\\(A\\)</span> be any commutative ring\r\nwith unit. The following statements are equivalent:</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(X = \\text{Spec} (A)\\)</span> is\r\ndisconnected.</p></li>\r\n<li><p><span class=\"math inline\">\\(A \\cong A_{1} \\times A_{2}\\)</span>\r\nwhere neither of the rings <span class=\"math inline\">\\(A_{1}\\)</span> or\r\n<span class=\"math inline\">\\(A_{2}\\)</span> is the zero ring.</p></li>\r\n<li><p><span class=\"math inline\">\\(A\\)</span> contains an idempotent\r\n<span class=\"math inline\">\\(\\neq 0,1\\)</span>.</p></li>\r\n</ol>\r\n<p><strong>Remark:</strong> Local ring, that is, ring with only one\r\nmaximal ideal, is always connected.</p>\r\n<h1 id=\"reference\">Reference</h1>\r\n<p>[1] Michael Atiyah. Introduction to commutative algebra. CRC Press,\r\n2018.</p>\r\n<p>[2] Suzanne C Dieudonne. History Algebraic Geometry. CRC Press,\r\n1985.</p>\r\n<p>[3] Bartel L Van der Waerden. A history of algebra: From al-Khwārizmī\r\nto Emmy Noether. Springer Science &amp; Business Media, 2013.</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Feb 25 2024 23:11:07 GMT+0800 (中国标准时间)","title":"Zariski Topology","path":"2023/03/23/Zariski topology/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2023-03-22T23:13:04.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2023-03-22T23:13:04.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Commutative Algebra > Algebraic Geometry","tags":["Algebraic Geometry"],"internalLinks":[],"keywords":[],"keywordsLength":0}},{"title":"$\\blacksquare$, $\\blacklozenge$, $\\clubsuit$","mathjax":true,"date":"2024-02-18T00:50:47.000Z","_content":"\n\nIn mathematics, particularly in mathematical logic and set theory, a club set is a subset of a limit ordinal that is closed under the order topology, and is unbounded (see below) relative to the limit ordinal. The name club is a contraction of \"closed and unbounded\". Formally, \n\n- if $\\kappa$ is a limit ordinal, then a set $ C\\subseteq \\kappa$ is *closed* in $\\kappa$ if and only if for every $\\alpha <\\kappa$, if $\\sup(C\\cap \\alpha )=\\alpha \\neq 0$ then $\\alpha \\in C$. Thus, if the limit of some sequence from $C$ is less than $\\kappa$, then the limit is also in $C$.\n\n\n- If $\\kappa$ is a limit ordinal and $C\\subseteq \\kappa$ then $C$ is *unbounded* in \n$\\kappa$ if for any $\\alpha <\\kappa$, there is some $\\beta \\in C$ such that $\\alpha <\\beta$.\n\nIf a set is both closed and unbounded, then it is a *club*.\n\n\n\nIn mathematics, specifically set theory and model theory, a stationary set is a set that is not too small in the sense that it intersects all club sets and is analogous to a set of non-zero measure in measure theory. There are at least three closely related notions of stationary set, depending on whether one is looking at subsets of an ordinal, or subsets of something of given cardinality, or a powerset.\n\n\n\nIf $\\kappa$ is a cardinal of uncountable cofinality, $S\\subseteq \\kappa$, and $S$ intersects every club set in $\\kappa$ then \n$S$ is called a stationary set. If a set is not stationary.\n\nIf $S$ is a stationary set and $C$ is a club set, then their intersection $S\\cap C$ is also stationary. This is because if $D$ is any club set, then $C\\cap D$ is a club set, thus \n$(S\\cap C)\\cap D=S\\cap (C\\cap D)$ is nonempty. Therefore, $(S\\cap C)$ must be stationary.\n\n## Fodor lemma\n\nIf $\\kappa$ is a regular, uncountable cardinal, $S$ is a stationary subset of $\\kappa$, and $f:S\\rightarrow \\kappa$ is regressive (that is, $f(\\alpha )<\\alpha$ for any $\\alpha \\in S$, $\\alpha \\neq 0$) then there is some $\\gamma$ and some stationary subset $S_{0}\\subseteq S$ such that \n$f(\\alpha )=\\gamma$ for any $\\alpha \\in S_{0}$. \n\n## Proof\n\nWe can assume that $0\\notin S$ (by removing 0, if necessary). If Fodor's lemma is false, for every $\\alpha <\\kappa$ there is some club set \n$C_{\\alpha }$ such that $C_{\\alpha }\\cap f^{-1}(\\alpha )=\\emptyset$. Let $C=\\Delta_{\\alpha <\\kappa }C_{\\alpha }$. The club sets are closed under diagonal intersection, so $C$ is also club and therefore there is some \n$\\alpha \\in S\\cap C$. Then $\\alpha \\in C_{\\beta }$ for each $\\beta <\\alpha$, and so there can be no $\\beta <\\alpha$ such that $\\alpha \\in f^{-1}(\\beta )$, so $f(\\alpha )\\geq \\alpha$, a contradiction.\n\n\n\n\n## $\\blacksquare_{\\kappa}$\n\n\nIf $\\kappa$ is an uncountable cardinal, then $\\square_{\\kappa }$ asserts that there is a sequence $\\{C_{\\beta }\\mid \\beta {\\text{ a limit point of }}\\kappa ^{+}\\}$ satisfying:\n\n- $C_{\\beta }$ is a club set of $\\beta$. \n\n- If $\\operatorname{cf}\\beta <\\kappa$, then $|C_{\\beta }|<\\kappa$\n\n- If $\\gamma$ is a limit point of $C_{\\beta }$ then $C_{\\gamma }=C_{\\beta }\\cap \\gamma$\n\nJensen proved that this principle holds in the constructible universe for any uncountable cardinal $\\kappa$.\n\n## $\\blacklozenge_{\\kappa}$\n\nThere are three equivalent definitions about the diamond principle $\\lozenge$:\n\n1. There is a sequence $\\{S_{\\alpha}\\mid \\alpha < \\omega_{1}\\}$ such that $S_{\\alpha} \\subseteq \\mathcal{P}(\\alpha)$ and $|S_{\\alpha}| \\leq \\omega$ for $\\alpha < \\omega_{1}$, and: If $X \\subseteq \\omega_{1}$, then the set $\\{\\alpha < \\omega_{1} \\mid X \\cap \\alpha \\in S_{\\alpha}\\}$ is stationary in $\\omega_{1}$.\n\n\n2. There is a sequence $\\{S_{\\alpha}\\mid \\alpha < \\omega_{1}\\}$ such that $S_{\\alpha} \\subseteq \\alpha$ for $\\alpha < \\omega_{1}$ and if $X \\subseteq \\omega_{1}$, then the set $\\{\\alpha < \\omega_{1} \\mid X \\cap \\alpha = S_{\\alpha}\\}$ is stationary in $\\omega_{1}$.\n\n3. There is a sequence $\\{h_{\\alpha}\\mid \\alpha < \\omega_{1}\\}$ of functions such that for every function $h: \\omega_{1} \\to \\omega_{1}$, the set $\\{\\alpha < \\omega_{1}\\mid h\\upharpoonright \\alpha = h_{\\alpha}\\}$ is stationary.\n\nWe also introduce two stronger versions of $\\lozenge$.\n\n$\\lozenge^{*}$: There is a sequence $\\{S_{\\alpha}\\mid \\alpha < \\omega_{1}\\}$ such that $S_{\\alpha} \\subseteq \\mathcal{P}(\\alpha)$ and $|S_{\\alpha}| \\leq \\omega$ for $\\alpha < \\omega_{1}$, and: If $X \\subseteq \\omega_{1}$, then the set $\\{\\alpha < \\omega_{1} \\mid X \\cap \\alpha \\in S_{\\alpha}\\}$ contains a closed unbounded set.\n\n$\\lozenge^{+}$: There is a sequence $\\{S_{\\alpha}\\mid \\alpha < \\omega_{1}\\}$ such that $S_{\\alpha} \\subseteq \\mathcal{P}(\\alpha)$ and $|S_{\\alpha}| \\leq \\omega$ for $\\alpha < \\omega_{1}$, and: If $X \\subseteq \\omega_{1}$ there exists a closed unbounded $C \\subseteq \\omega_{1}$ such that if $\\alpha \\in C$, then $X \\cap \\alpha$, $C \\cap \\alpha \\in S_{\\alpha}$.\n\nClearly $\\lozenge^{+} \\to \\lozenge^{*} \\to \\lozenge$. Jensen has proved that the arrows cannot be reversed. \n\n### Theorem\n\n$\\lozenge$ $\\to$ CH.\n\n\n### Theorem\n\nAssume $V = L$. $\\lozenge$ is valid.\n\n\n### Theorem\n\nAssume $\\lozenge$. The there exists a Souslin tree.\n\n\n\n\n\n\n## $\\clubsuit_{\\kappa}$\n\nFor a given cardinal number $\\kappa$ and a stationary set $S\\subseteq \\kappa$, $\\clubsuit _{S}$ is the statement that there is a sequence $\\{ A_{\\delta }:\\delta \\in S \\}$ such that \n\n- every $A_{\\delta}$ is a cofinal subset of $\\delta$.\n\n- for every unbounded subset $A\\subseteq \\kappa$, there is a $\\delta$ so that $A_{\\delta }\\subseteq A$.\n\n$\\clubsuit _{\\omega _{1}}$ is usually written as just $\\clubsuit$.\n\n\nIt is clear that $\\lozenge \\to \\clubsuit$, and it was shown in 1975 that $\\clubsuit$ + CH $\\to$ $\\lozenge$; however, Saharon Shelah gave a proof in 1980 that there exists a model of $\\clubsuit$ in which CH does not hold, so $\\clubsuit$ and $\\lozenge$ are not equivalent (since $\\lozenge$ $\\to$ CH).\n\n\nJensen, R. Bj\\\"orn (1972), \"The fine structure of the constructible hierarchy\", Annals of Mathematical Logic, 4 (3): 229–308.","source":"_posts/blacksquare-blacklozenge-clubsuit.md","raw":"---\ntitle: $\\blacksquare$, $\\blacklozenge$, $\\clubsuit$\ntags:\n  - - Set Theory\n  - - Mathematical Logic\ncategories:\n  - - Set Theory\n  - - Mathematical Logic\nmathjax: true\ndate: 2024-02-18 08:50:47\n---\n\n\nIn mathematics, particularly in mathematical logic and set theory, a club set is a subset of a limit ordinal that is closed under the order topology, and is unbounded (see below) relative to the limit ordinal. The name club is a contraction of \"closed and unbounded\". Formally, \n\n- if $\\kappa$ is a limit ordinal, then a set $ C\\subseteq \\kappa$ is *closed* in $\\kappa$ if and only if for every $\\alpha <\\kappa$, if $\\sup(C\\cap \\alpha )=\\alpha \\neq 0$ then $\\alpha \\in C$. Thus, if the limit of some sequence from $C$ is less than $\\kappa$, then the limit is also in $C$.\n\n\n- If $\\kappa$ is a limit ordinal and $C\\subseteq \\kappa$ then $C$ is *unbounded* in \n$\\kappa$ if for any $\\alpha <\\kappa$, there is some $\\beta \\in C$ such that $\\alpha <\\beta$.\n\nIf a set is both closed and unbounded, then it is a *club*.\n\n\n\nIn mathematics, specifically set theory and model theory, a stationary set is a set that is not too small in the sense that it intersects all club sets and is analogous to a set of non-zero measure in measure theory. There are at least three closely related notions of stationary set, depending on whether one is looking at subsets of an ordinal, or subsets of something of given cardinality, or a powerset.\n\n\n\nIf $\\kappa$ is a cardinal of uncountable cofinality, $S\\subseteq \\kappa$, and $S$ intersects every club set in $\\kappa$ then \n$S$ is called a stationary set. If a set is not stationary.\n\nIf $S$ is a stationary set and $C$ is a club set, then their intersection $S\\cap C$ is also stationary. This is because if $D$ is any club set, then $C\\cap D$ is a club set, thus \n$(S\\cap C)\\cap D=S\\cap (C\\cap D)$ is nonempty. Therefore, $(S\\cap C)$ must be stationary.\n\n## Fodor lemma\n\nIf $\\kappa$ is a regular, uncountable cardinal, $S$ is a stationary subset of $\\kappa$, and $f:S\\rightarrow \\kappa$ is regressive (that is, $f(\\alpha )<\\alpha$ for any $\\alpha \\in S$, $\\alpha \\neq 0$) then there is some $\\gamma$ and some stationary subset $S_{0}\\subseteq S$ such that \n$f(\\alpha )=\\gamma$ for any $\\alpha \\in S_{0}$. \n\n## Proof\n\nWe can assume that $0\\notin S$ (by removing 0, if necessary). If Fodor's lemma is false, for every $\\alpha <\\kappa$ there is some club set \n$C_{\\alpha }$ such that $C_{\\alpha }\\cap f^{-1}(\\alpha )=\\emptyset$. Let $C=\\Delta_{\\alpha <\\kappa }C_{\\alpha }$. The club sets are closed under diagonal intersection, so $C$ is also club and therefore there is some \n$\\alpha \\in S\\cap C$. Then $\\alpha \\in C_{\\beta }$ for each $\\beta <\\alpha$, and so there can be no $\\beta <\\alpha$ such that $\\alpha \\in f^{-1}(\\beta )$, so $f(\\alpha )\\geq \\alpha$, a contradiction.\n\n\n\n\n## $\\blacksquare_{\\kappa}$\n\n\nIf $\\kappa$ is an uncountable cardinal, then $\\square_{\\kappa }$ asserts that there is a sequence $\\{C_{\\beta }\\mid \\beta {\\text{ a limit point of }}\\kappa ^{+}\\}$ satisfying:\n\n- $C_{\\beta }$ is a club set of $\\beta$. \n\n- If $\\operatorname{cf}\\beta <\\kappa$, then $|C_{\\beta }|<\\kappa$\n\n- If $\\gamma$ is a limit point of $C_{\\beta }$ then $C_{\\gamma }=C_{\\beta }\\cap \\gamma$\n\nJensen proved that this principle holds in the constructible universe for any uncountable cardinal $\\kappa$.\n\n## $\\blacklozenge_{\\kappa}$\n\nThere are three equivalent definitions about the diamond principle $\\lozenge$:\n\n1. There is a sequence $\\{S_{\\alpha}\\mid \\alpha < \\omega_{1}\\}$ such that $S_{\\alpha} \\subseteq \\mathcal{P}(\\alpha)$ and $|S_{\\alpha}| \\leq \\omega$ for $\\alpha < \\omega_{1}$, and: If $X \\subseteq \\omega_{1}$, then the set $\\{\\alpha < \\omega_{1} \\mid X \\cap \\alpha \\in S_{\\alpha}\\}$ is stationary in $\\omega_{1}$.\n\n\n2. There is a sequence $\\{S_{\\alpha}\\mid \\alpha < \\omega_{1}\\}$ such that $S_{\\alpha} \\subseteq \\alpha$ for $\\alpha < \\omega_{1}$ and if $X \\subseteq \\omega_{1}$, then the set $\\{\\alpha < \\omega_{1} \\mid X \\cap \\alpha = S_{\\alpha}\\}$ is stationary in $\\omega_{1}$.\n\n3. There is a sequence $\\{h_{\\alpha}\\mid \\alpha < \\omega_{1}\\}$ of functions such that for every function $h: \\omega_{1} \\to \\omega_{1}$, the set $\\{\\alpha < \\omega_{1}\\mid h\\upharpoonright \\alpha = h_{\\alpha}\\}$ is stationary.\n\nWe also introduce two stronger versions of $\\lozenge$.\n\n$\\lozenge^{*}$: There is a sequence $\\{S_{\\alpha}\\mid \\alpha < \\omega_{1}\\}$ such that $S_{\\alpha} \\subseteq \\mathcal{P}(\\alpha)$ and $|S_{\\alpha}| \\leq \\omega$ for $\\alpha < \\omega_{1}$, and: If $X \\subseteq \\omega_{1}$, then the set $\\{\\alpha < \\omega_{1} \\mid X \\cap \\alpha \\in S_{\\alpha}\\}$ contains a closed unbounded set.\n\n$\\lozenge^{+}$: There is a sequence $\\{S_{\\alpha}\\mid \\alpha < \\omega_{1}\\}$ such that $S_{\\alpha} \\subseteq \\mathcal{P}(\\alpha)$ and $|S_{\\alpha}| \\leq \\omega$ for $\\alpha < \\omega_{1}$, and: If $X \\subseteq \\omega_{1}$ there exists a closed unbounded $C \\subseteq \\omega_{1}$ such that if $\\alpha \\in C$, then $X \\cap \\alpha$, $C \\cap \\alpha \\in S_{\\alpha}$.\n\nClearly $\\lozenge^{+} \\to \\lozenge^{*} \\to \\lozenge$. Jensen has proved that the arrows cannot be reversed. \n\n### Theorem\n\n$\\lozenge$ $\\to$ CH.\n\n\n### Theorem\n\nAssume $V = L$. $\\lozenge$ is valid.\n\n\n### Theorem\n\nAssume $\\lozenge$. The there exists a Souslin tree.\n\n\n\n\n\n\n## $\\clubsuit_{\\kappa}$\n\nFor a given cardinal number $\\kappa$ and a stationary set $S\\subseteq \\kappa$, $\\clubsuit _{S}$ is the statement that there is a sequence $\\{ A_{\\delta }:\\delta \\in S \\}$ such that \n\n- every $A_{\\delta}$ is a cofinal subset of $\\delta$.\n\n- for every unbounded subset $A\\subseteq \\kappa$, there is a $\\delta$ so that $A_{\\delta }\\subseteq A$.\n\n$\\clubsuit _{\\omega _{1}}$ is usually written as just $\\clubsuit$.\n\n\nIt is clear that $\\lozenge \\to \\clubsuit$, and it was shown in 1975 that $\\clubsuit$ + CH $\\to$ $\\lozenge$; however, Saharon Shelah gave a proof in 1980 that there exists a model of $\\clubsuit$ in which CH does not hold, so $\\clubsuit$ and $\\lozenge$ are not equivalent (since $\\lozenge$ $\\to$ CH).\n\n\nJensen, R. Bj\\\"orn (1972), \"The fine structure of the constructible hierarchy\", Annals of Mathematical Logic, 4 (3): 229–308.","slug":"blacksquare-blacklozenge-clubsuit","published":1,"updated":"2024-02-25T15:11:07.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfwcr5sd003ym8nxeppacwe7","content":"<p>In mathematics, particularly in mathematical logic and set theory, a\r\nclub set is a subset of a limit ordinal that is closed under the order\r\ntopology, and is unbounded (see below) relative to the limit ordinal.\r\nThe name club is a contraction of \"closed and unbounded\". Formally,</p>\r\n<ul>\r\n<li><p>if <span class=\"math inline\">\\(\\kappa\\)</span> is a limit\r\nordinal, then a set $ C$ is <em>closed</em> in <span class=\"math inline\">\\(\\kappa\\)</span> if and only if for every <span class=\"math inline\">\\(\\alpha &lt;\\kappa\\)</span>, if <span class=\"math inline\">\\(\\sup(C\\cap \\alpha )=\\alpha \\neq 0\\)</span> then\r\n<span class=\"math inline\">\\(\\alpha \\in C\\)</span>. Thus, if the limit of\r\nsome sequence from <span class=\"math inline\">\\(C\\)</span> is less than\r\n<span class=\"math inline\">\\(\\kappa\\)</span>, then the limit is also in\r\n<span class=\"math inline\">\\(C\\)</span>.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(\\kappa\\)</span> is a limit ordinal\r\nand <span class=\"math inline\">\\(C\\subseteq \\kappa\\)</span> then <span class=\"math inline\">\\(C\\)</span> is <em>unbounded</em> in <span class=\"math inline\">\\(\\kappa\\)</span> if for any <span class=\"math inline\">\\(\\alpha &lt;\\kappa\\)</span>, there is some <span class=\"math inline\">\\(\\beta \\in C\\)</span> such that <span class=\"math inline\">\\(\\alpha &lt;\\beta\\)</span>.</p></li>\r\n</ul>\r\n<p>If a set is both closed and unbounded, then it is a\r\n<em>club</em>.</p>\r\n<p>In mathematics, specifically set theory and model theory, a\r\nstationary set is a set that is not too small in the sense that it\r\nintersects all club sets and is analogous to a set of non-zero measure\r\nin measure theory. There are at least three closely related notions of\r\nstationary set, depending on whether one is looking at subsets of an\r\nordinal, or subsets of something of given cardinality, or a\r\npowerset.</p>\r\n<p>If <span class=\"math inline\">\\(\\kappa\\)</span> is a cardinal of\r\nuncountable cofinality, <span class=\"math inline\">\\(S\\subseteq\r\n\\kappa\\)</span>, and <span class=\"math inline\">\\(S\\)</span> intersects\r\nevery club set in <span class=\"math inline\">\\(\\kappa\\)</span> then <span class=\"math inline\">\\(S\\)</span> is called a stationary set. If a set is\r\nnot stationary.</p>\r\n<p>If <span class=\"math inline\">\\(S\\)</span> is a stationary set and\r\n<span class=\"math inline\">\\(C\\)</span> is a club set, then their\r\nintersection <span class=\"math inline\">\\(S\\cap C\\)</span> is also\r\nstationary. This is because if <span class=\"math inline\">\\(D\\)</span> is\r\nany club set, then <span class=\"math inline\">\\(C\\cap D\\)</span> is a\r\nclub set, thus <span class=\"math inline\">\\((S\\cap C)\\cap D=S\\cap (C\\cap\r\nD)\\)</span> is nonempty. Therefore, <span class=\"math inline\">\\((S\\cap\r\nC)\\)</span> must be stationary.</p>\r\n<h2 id=\"fodor-lemma\">Fodor lemma</h2>\r\n<p>If <span class=\"math inline\">\\(\\kappa\\)</span> is a regular,\r\nuncountable cardinal, <span class=\"math inline\">\\(S\\)</span> is a\r\nstationary subset of <span class=\"math inline\">\\(\\kappa\\)</span>, and\r\n<span class=\"math inline\">\\(f:S\\rightarrow \\kappa\\)</span> is regressive\r\n(that is, <span class=\"math inline\">\\(f(\\alpha )&lt;\\alpha\\)</span> for\r\nany <span class=\"math inline\">\\(\\alpha \\in S\\)</span>, <span class=\"math inline\">\\(\\alpha \\neq 0\\)</span>) then there is some <span class=\"math inline\">\\(\\gamma\\)</span> and some stationary subset <span class=\"math inline\">\\(S_{0}\\subseteq S\\)</span> such that <span class=\"math inline\">\\(f(\\alpha )=\\gamma\\)</span> for any <span class=\"math inline\">\\(\\alpha \\in S_{0}\\)</span>.</p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<p>We can assume that <span class=\"math inline\">\\(0\\notin S\\)</span> (by\r\nremoving 0, if necessary). If Fodor's lemma is false, for every <span class=\"math inline\">\\(\\alpha &lt;\\kappa\\)</span> there is some club set\r\n<span class=\"math inline\">\\(C_{\\alpha }\\)</span> such that <span class=\"math inline\">\\(C_{\\alpha }\\cap f^{-1}(\\alpha\r\n)=\\emptyset\\)</span>. Let <span class=\"math inline\">\\(C=\\Delta_{\\alpha\r\n&lt;\\kappa }C_{\\alpha }\\)</span>. The club sets are closed under\r\ndiagonal intersection, so <span class=\"math inline\">\\(C\\)</span> is also\r\nclub and therefore there is some <span class=\"math inline\">\\(\\alpha \\in\r\nS\\cap C\\)</span>. Then <span class=\"math inline\">\\(\\alpha \\in C_{\\beta\r\n}\\)</span> for each <span class=\"math inline\">\\(\\beta\r\n&lt;\\alpha\\)</span>, and so there can be no <span class=\"math inline\">\\(\\beta &lt;\\alpha\\)</span> such that <span class=\"math inline\">\\(\\alpha \\in f^{-1}(\\beta )\\)</span>, so <span class=\"math inline\">\\(f(\\alpha )\\geq \\alpha\\)</span>, a\r\ncontradiction.</p>\r\n<h2 id=\"blacksquare_kappa\"><span class=\"math inline\">\\(\\blacksquare_{\\kappa}\\)</span></h2>\r\n<p>If <span class=\"math inline\">\\(\\kappa\\)</span> is an uncountable\r\ncardinal, then <span class=\"math inline\">\\(\\square_{\\kappa }\\)</span>\r\nasserts that there is a sequence <span class=\"math inline\">\\(\\{C_{\\beta\r\n}\\mid \\beta {\\text{ a limit point of }}\\kappa ^{+}\\}\\)</span>\r\nsatisfying:</p>\r\n<ul>\r\n<li><p><span class=\"math inline\">\\(C_{\\beta }\\)</span> is a club set of\r\n<span class=\"math inline\">\\(\\beta\\)</span>.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(\\operatorname{cf}\\beta\r\n&lt;\\kappa\\)</span>, then <span class=\"math inline\">\\(|C_{\\beta\r\n}|&lt;\\kappa\\)</span></p></li>\r\n<li><p>If <span class=\"math inline\">\\(\\gamma\\)</span> is a limit point\r\nof <span class=\"math inline\">\\(C_{\\beta }\\)</span> then <span class=\"math inline\">\\(C_{\\gamma }=C_{\\beta }\\cap\r\n\\gamma\\)</span></p></li>\r\n</ul>\r\n<p>Jensen proved that this principle holds in the constructible universe\r\nfor any uncountable cardinal <span class=\"math inline\">\\(\\kappa\\)</span>.</p>\r\n<h2 id=\"blacklozenge_kappa\"><span class=\"math inline\">\\(\\blacklozenge_{\\kappa}\\)</span></h2>\r\n<p>There are three equivalent definitions about the diamond principle\r\n<span class=\"math inline\">\\(\\lozenge\\)</span>:</p>\r\n<ol type=\"1\">\r\n<li><p>There is a sequence <span class=\"math inline\">\\(\\{S_{\\alpha}\\mid\r\n\\alpha &lt; \\omega_{1}\\}\\)</span> such that <span class=\"math inline\">\\(S_{\\alpha} \\subseteq \\mathcal{P}(\\alpha)\\)</span>\r\nand <span class=\"math inline\">\\(|S_{\\alpha}| \\leq \\omega\\)</span> for\r\n<span class=\"math inline\">\\(\\alpha &lt; \\omega_{1}\\)</span>, and: If\r\n<span class=\"math inline\">\\(X \\subseteq \\omega_{1}\\)</span>, then the\r\nset <span class=\"math inline\">\\(\\{\\alpha &lt; \\omega_{1} \\mid X \\cap\r\n\\alpha \\in S_{\\alpha}\\}\\)</span> is stationary in <span class=\"math inline\">\\(\\omega_{1}\\)</span>.</p></li>\r\n<li><p>There is a sequence <span class=\"math inline\">\\(\\{S_{\\alpha}\\mid\r\n\\alpha &lt; \\omega_{1}\\}\\)</span> such that <span class=\"math inline\">\\(S_{\\alpha} \\subseteq \\alpha\\)</span> for <span class=\"math inline\">\\(\\alpha &lt; \\omega_{1}\\)</span> and if <span class=\"math inline\">\\(X \\subseteq \\omega_{1}\\)</span>, then the set\r\n<span class=\"math inline\">\\(\\{\\alpha &lt; \\omega_{1} \\mid X \\cap \\alpha\r\n= S_{\\alpha}\\}\\)</span> is stationary in <span class=\"math inline\">\\(\\omega_{1}\\)</span>.</p></li>\r\n<li><p>There is a sequence <span class=\"math inline\">\\(\\{h_{\\alpha}\\mid\r\n\\alpha &lt; \\omega_{1}\\}\\)</span> of functions such that for every\r\nfunction <span class=\"math inline\">\\(h: \\omega_{1} \\to\r\n\\omega_{1}\\)</span>, the set <span class=\"math inline\">\\(\\{\\alpha &lt;\r\n\\omega_{1}\\mid h\\upharpoonright \\alpha = h_{\\alpha}\\}\\)</span> is\r\nstationary.</p></li>\r\n</ol>\r\n<p>We also introduce two stronger versions of <span class=\"math inline\">\\(\\lozenge\\)</span>.</p>\r\n<p><span class=\"math inline\">\\(\\lozenge^{*}\\)</span>: There is a\r\nsequence <span class=\"math inline\">\\(\\{S_{\\alpha}\\mid \\alpha &lt;\r\n\\omega_{1}\\}\\)</span> such that <span class=\"math inline\">\\(S_{\\alpha}\r\n\\subseteq \\mathcal{P}(\\alpha)\\)</span> and <span class=\"math inline\">\\(|S_{\\alpha}| \\leq \\omega\\)</span> for <span class=\"math inline\">\\(\\alpha &lt; \\omega_{1}\\)</span>, and: If <span class=\"math inline\">\\(X \\subseteq \\omega_{1}\\)</span>, then the set\r\n<span class=\"math inline\">\\(\\{\\alpha &lt; \\omega_{1} \\mid X \\cap \\alpha\r\n\\in S_{\\alpha}\\}\\)</span> contains a closed unbounded set.</p>\r\n<p><span class=\"math inline\">\\(\\lozenge^{+}\\)</span>: There is a\r\nsequence <span class=\"math inline\">\\(\\{S_{\\alpha}\\mid \\alpha &lt;\r\n\\omega_{1}\\}\\)</span> such that <span class=\"math inline\">\\(S_{\\alpha}\r\n\\subseteq \\mathcal{P}(\\alpha)\\)</span> and <span class=\"math inline\">\\(|S_{\\alpha}| \\leq \\omega\\)</span> for <span class=\"math inline\">\\(\\alpha &lt; \\omega_{1}\\)</span>, and: If <span class=\"math inline\">\\(X \\subseteq \\omega_{1}\\)</span> there exists a\r\nclosed unbounded <span class=\"math inline\">\\(C \\subseteq\r\n\\omega_{1}\\)</span> such that if <span class=\"math inline\">\\(\\alpha \\in\r\nC\\)</span>, then <span class=\"math inline\">\\(X \\cap \\alpha\\)</span>,\r\n<span class=\"math inline\">\\(C \\cap \\alpha \\in S_{\\alpha}\\)</span>.</p>\r\n<p>Clearly <span class=\"math inline\">\\(\\lozenge^{+} \\to \\lozenge^{*} \\to\r\n\\lozenge\\)</span>. Jensen has proved that the arrows cannot be\r\nreversed.</p>\r\n<h3 id=\"theorem\">Theorem</h3>\r\n<p><span class=\"math inline\">\\(\\lozenge\\)</span> <span class=\"math inline\">\\(\\to\\)</span> CH.</p>\r\n<h3 id=\"theorem-1\">Theorem</h3>\r\n<p>Assume <span class=\"math inline\">\\(V = L\\)</span>. <span class=\"math inline\">\\(\\lozenge\\)</span> is valid.</p>\r\n<h3 id=\"theorem-2\">Theorem</h3>\r\n<p>Assume <span class=\"math inline\">\\(\\lozenge\\)</span>. The there\r\nexists a Souslin tree.</p>\r\n<h2 id=\"clubsuit_kappa\"><span class=\"math inline\">\\(\\clubsuit_{\\kappa}\\)</span></h2>\r\n<p>For a given cardinal number <span class=\"math inline\">\\(\\kappa\\)</span> and a stationary set <span class=\"math inline\">\\(S\\subseteq \\kappa\\)</span>, <span class=\"math inline\">\\(\\clubsuit _{S}\\)</span> is the statement that\r\nthere is a sequence <span class=\"math inline\">\\(\\{ A_{\\delta }:\\delta\r\n\\in S \\}\\)</span> such that</p>\r\n<ul>\r\n<li><p>every <span class=\"math inline\">\\(A_{\\delta}\\)</span> is a\r\ncofinal subset of <span class=\"math inline\">\\(\\delta\\)</span>.</p></li>\r\n<li><p>for every unbounded subset <span class=\"math inline\">\\(A\\subseteq\r\n\\kappa\\)</span>, there is a <span class=\"math inline\">\\(\\delta\\)</span>\r\nso that <span class=\"math inline\">\\(A_{\\delta }\\subseteq\r\nA\\)</span>.</p></li>\r\n</ul>\r\n<p><span class=\"math inline\">\\(\\clubsuit _{\\omega _{1}}\\)</span> is\r\nusually written as just <span class=\"math inline\">\\(\\clubsuit\\)</span>.</p>\r\n<p>It is clear that <span class=\"math inline\">\\(\\lozenge \\to\r\n\\clubsuit\\)</span>, and it was shown in 1975 that <span class=\"math inline\">\\(\\clubsuit\\)</span> + CH <span class=\"math inline\">\\(\\to\\)</span> <span class=\"math inline\">\\(\\lozenge\\)</span>; however, Saharon Shelah gave a\r\nproof in 1980 that there exists a model of <span class=\"math inline\">\\(\\clubsuit\\)</span> in which CH does not hold, so\r\n<span class=\"math inline\">\\(\\clubsuit\\)</span> and <span class=\"math inline\">\\(\\lozenge\\)</span> are not equivalent (since <span class=\"math inline\">\\(\\lozenge\\)</span> <span class=\"math inline\">\\(\\to\\)</span> CH).</p>\r\n<p>Jensen, R. Bj\"orn (1972), \"The fine structure of the constructible\r\nhierarchy\", Annals of Mathematical Logic, 4 (3): 229–308.</p>\r\n","site":{"data":{}},"excerpt":"","more":"<p>In mathematics, particularly in mathematical logic and set theory, a\r\nclub set is a subset of a limit ordinal that is closed under the order\r\ntopology, and is unbounded (see below) relative to the limit ordinal.\r\nThe name club is a contraction of \"closed and unbounded\". Formally,</p>\r\n<ul>\r\n<li><p>if <span class=\"math inline\">\\(\\kappa\\)</span> is a limit\r\nordinal, then a set $ C$ is <em>closed</em> in <span class=\"math inline\">\\(\\kappa\\)</span> if and only if for every <span class=\"math inline\">\\(\\alpha &lt;\\kappa\\)</span>, if <span class=\"math inline\">\\(\\sup(C\\cap \\alpha )=\\alpha \\neq 0\\)</span> then\r\n<span class=\"math inline\">\\(\\alpha \\in C\\)</span>. Thus, if the limit of\r\nsome sequence from <span class=\"math inline\">\\(C\\)</span> is less than\r\n<span class=\"math inline\">\\(\\kappa\\)</span>, then the limit is also in\r\n<span class=\"math inline\">\\(C\\)</span>.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(\\kappa\\)</span> is a limit ordinal\r\nand <span class=\"math inline\">\\(C\\subseteq \\kappa\\)</span> then <span class=\"math inline\">\\(C\\)</span> is <em>unbounded</em> in <span class=\"math inline\">\\(\\kappa\\)</span> if for any <span class=\"math inline\">\\(\\alpha &lt;\\kappa\\)</span>, there is some <span class=\"math inline\">\\(\\beta \\in C\\)</span> such that <span class=\"math inline\">\\(\\alpha &lt;\\beta\\)</span>.</p></li>\r\n</ul>\r\n<p>If a set is both closed and unbounded, then it is a\r\n<em>club</em>.</p>\r\n<p>In mathematics, specifically set theory and model theory, a\r\nstationary set is a set that is not too small in the sense that it\r\nintersects all club sets and is analogous to a set of non-zero measure\r\nin measure theory. There are at least three closely related notions of\r\nstationary set, depending on whether one is looking at subsets of an\r\nordinal, or subsets of something of given cardinality, or a\r\npowerset.</p>\r\n<p>If <span class=\"math inline\">\\(\\kappa\\)</span> is a cardinal of\r\nuncountable cofinality, <span class=\"math inline\">\\(S\\subseteq\r\n\\kappa\\)</span>, and <span class=\"math inline\">\\(S\\)</span> intersects\r\nevery club set in <span class=\"math inline\">\\(\\kappa\\)</span> then <span class=\"math inline\">\\(S\\)</span> is called a stationary set. If a set is\r\nnot stationary.</p>\r\n<p>If <span class=\"math inline\">\\(S\\)</span> is a stationary set and\r\n<span class=\"math inline\">\\(C\\)</span> is a club set, then their\r\nintersection <span class=\"math inline\">\\(S\\cap C\\)</span> is also\r\nstationary. This is because if <span class=\"math inline\">\\(D\\)</span> is\r\nany club set, then <span class=\"math inline\">\\(C\\cap D\\)</span> is a\r\nclub set, thus <span class=\"math inline\">\\((S\\cap C)\\cap D=S\\cap (C\\cap\r\nD)\\)</span> is nonempty. Therefore, <span class=\"math inline\">\\((S\\cap\r\nC)\\)</span> must be stationary.</p>\r\n<h2 id=\"fodor-lemma\">Fodor lemma</h2>\r\n<p>If <span class=\"math inline\">\\(\\kappa\\)</span> is a regular,\r\nuncountable cardinal, <span class=\"math inline\">\\(S\\)</span> is a\r\nstationary subset of <span class=\"math inline\">\\(\\kappa\\)</span>, and\r\n<span class=\"math inline\">\\(f:S\\rightarrow \\kappa\\)</span> is regressive\r\n(that is, <span class=\"math inline\">\\(f(\\alpha )&lt;\\alpha\\)</span> for\r\nany <span class=\"math inline\">\\(\\alpha \\in S\\)</span>, <span class=\"math inline\">\\(\\alpha \\neq 0\\)</span>) then there is some <span class=\"math inline\">\\(\\gamma\\)</span> and some stationary subset <span class=\"math inline\">\\(S_{0}\\subseteq S\\)</span> such that <span class=\"math inline\">\\(f(\\alpha )=\\gamma\\)</span> for any <span class=\"math inline\">\\(\\alpha \\in S_{0}\\)</span>.</p>\r\n<h2 id=\"proof\">Proof</h2>\r\n<p>We can assume that <span class=\"math inline\">\\(0\\notin S\\)</span> (by\r\nremoving 0, if necessary). If Fodor's lemma is false, for every <span class=\"math inline\">\\(\\alpha &lt;\\kappa\\)</span> there is some club set\r\n<span class=\"math inline\">\\(C_{\\alpha }\\)</span> such that <span class=\"math inline\">\\(C_{\\alpha }\\cap f^{-1}(\\alpha\r\n)=\\emptyset\\)</span>. Let <span class=\"math inline\">\\(C=\\Delta_{\\alpha\r\n&lt;\\kappa }C_{\\alpha }\\)</span>. The club sets are closed under\r\ndiagonal intersection, so <span class=\"math inline\">\\(C\\)</span> is also\r\nclub and therefore there is some <span class=\"math inline\">\\(\\alpha \\in\r\nS\\cap C\\)</span>. Then <span class=\"math inline\">\\(\\alpha \\in C_{\\beta\r\n}\\)</span> for each <span class=\"math inline\">\\(\\beta\r\n&lt;\\alpha\\)</span>, and so there can be no <span class=\"math inline\">\\(\\beta &lt;\\alpha\\)</span> such that <span class=\"math inline\">\\(\\alpha \\in f^{-1}(\\beta )\\)</span>, so <span class=\"math inline\">\\(f(\\alpha )\\geq \\alpha\\)</span>, a\r\ncontradiction.</p>\r\n<h2 id=\"blacksquare_kappa\"><span class=\"math inline\">\\(\\blacksquare_{\\kappa}\\)</span></h2>\r\n<p>If <span class=\"math inline\">\\(\\kappa\\)</span> is an uncountable\r\ncardinal, then <span class=\"math inline\">\\(\\square_{\\kappa }\\)</span>\r\nasserts that there is a sequence <span class=\"math inline\">\\(\\{C_{\\beta\r\n}\\mid \\beta {\\text{ a limit point of }}\\kappa ^{+}\\}\\)</span>\r\nsatisfying:</p>\r\n<ul>\r\n<li><p><span class=\"math inline\">\\(C_{\\beta }\\)</span> is a club set of\r\n<span class=\"math inline\">\\(\\beta\\)</span>.</p></li>\r\n<li><p>If <span class=\"math inline\">\\(\\operatorname{cf}\\beta\r\n&lt;\\kappa\\)</span>, then <span class=\"math inline\">\\(|C_{\\beta\r\n}|&lt;\\kappa\\)</span></p></li>\r\n<li><p>If <span class=\"math inline\">\\(\\gamma\\)</span> is a limit point\r\nof <span class=\"math inline\">\\(C_{\\beta }\\)</span> then <span class=\"math inline\">\\(C_{\\gamma }=C_{\\beta }\\cap\r\n\\gamma\\)</span></p></li>\r\n</ul>\r\n<p>Jensen proved that this principle holds in the constructible universe\r\nfor any uncountable cardinal <span class=\"math inline\">\\(\\kappa\\)</span>.</p>\r\n<h2 id=\"blacklozenge_kappa\"><span class=\"math inline\">\\(\\blacklozenge_{\\kappa}\\)</span></h2>\r\n<p>There are three equivalent definitions about the diamond principle\r\n<span class=\"math inline\">\\(\\lozenge\\)</span>:</p>\r\n<ol type=\"1\">\r\n<li><p>There is a sequence <span class=\"math inline\">\\(\\{S_{\\alpha}\\mid\r\n\\alpha &lt; \\omega_{1}\\}\\)</span> such that <span class=\"math inline\">\\(S_{\\alpha} \\subseteq \\mathcal{P}(\\alpha)\\)</span>\r\nand <span class=\"math inline\">\\(|S_{\\alpha}| \\leq \\omega\\)</span> for\r\n<span class=\"math inline\">\\(\\alpha &lt; \\omega_{1}\\)</span>, and: If\r\n<span class=\"math inline\">\\(X \\subseteq \\omega_{1}\\)</span>, then the\r\nset <span class=\"math inline\">\\(\\{\\alpha &lt; \\omega_{1} \\mid X \\cap\r\n\\alpha \\in S_{\\alpha}\\}\\)</span> is stationary in <span class=\"math inline\">\\(\\omega_{1}\\)</span>.</p></li>\r\n<li><p>There is a sequence <span class=\"math inline\">\\(\\{S_{\\alpha}\\mid\r\n\\alpha &lt; \\omega_{1}\\}\\)</span> such that <span class=\"math inline\">\\(S_{\\alpha} \\subseteq \\alpha\\)</span> for <span class=\"math inline\">\\(\\alpha &lt; \\omega_{1}\\)</span> and if <span class=\"math inline\">\\(X \\subseteq \\omega_{1}\\)</span>, then the set\r\n<span class=\"math inline\">\\(\\{\\alpha &lt; \\omega_{1} \\mid X \\cap \\alpha\r\n= S_{\\alpha}\\}\\)</span> is stationary in <span class=\"math inline\">\\(\\omega_{1}\\)</span>.</p></li>\r\n<li><p>There is a sequence <span class=\"math inline\">\\(\\{h_{\\alpha}\\mid\r\n\\alpha &lt; \\omega_{1}\\}\\)</span> of functions such that for every\r\nfunction <span class=\"math inline\">\\(h: \\omega_{1} \\to\r\n\\omega_{1}\\)</span>, the set <span class=\"math inline\">\\(\\{\\alpha &lt;\r\n\\omega_{1}\\mid h\\upharpoonright \\alpha = h_{\\alpha}\\}\\)</span> is\r\nstationary.</p></li>\r\n</ol>\r\n<p>We also introduce two stronger versions of <span class=\"math inline\">\\(\\lozenge\\)</span>.</p>\r\n<p><span class=\"math inline\">\\(\\lozenge^{*}\\)</span>: There is a\r\nsequence <span class=\"math inline\">\\(\\{S_{\\alpha}\\mid \\alpha &lt;\r\n\\omega_{1}\\}\\)</span> such that <span class=\"math inline\">\\(S_{\\alpha}\r\n\\subseteq \\mathcal{P}(\\alpha)\\)</span> and <span class=\"math inline\">\\(|S_{\\alpha}| \\leq \\omega\\)</span> for <span class=\"math inline\">\\(\\alpha &lt; \\omega_{1}\\)</span>, and: If <span class=\"math inline\">\\(X \\subseteq \\omega_{1}\\)</span>, then the set\r\n<span class=\"math inline\">\\(\\{\\alpha &lt; \\omega_{1} \\mid X \\cap \\alpha\r\n\\in S_{\\alpha}\\}\\)</span> contains a closed unbounded set.</p>\r\n<p><span class=\"math inline\">\\(\\lozenge^{+}\\)</span>: There is a\r\nsequence <span class=\"math inline\">\\(\\{S_{\\alpha}\\mid \\alpha &lt;\r\n\\omega_{1}\\}\\)</span> such that <span class=\"math inline\">\\(S_{\\alpha}\r\n\\subseteq \\mathcal{P}(\\alpha)\\)</span> and <span class=\"math inline\">\\(|S_{\\alpha}| \\leq \\omega\\)</span> for <span class=\"math inline\">\\(\\alpha &lt; \\omega_{1}\\)</span>, and: If <span class=\"math inline\">\\(X \\subseteq \\omega_{1}\\)</span> there exists a\r\nclosed unbounded <span class=\"math inline\">\\(C \\subseteq\r\n\\omega_{1}\\)</span> such that if <span class=\"math inline\">\\(\\alpha \\in\r\nC\\)</span>, then <span class=\"math inline\">\\(X \\cap \\alpha\\)</span>,\r\n<span class=\"math inline\">\\(C \\cap \\alpha \\in S_{\\alpha}\\)</span>.</p>\r\n<p>Clearly <span class=\"math inline\">\\(\\lozenge^{+} \\to \\lozenge^{*} \\to\r\n\\lozenge\\)</span>. Jensen has proved that the arrows cannot be\r\nreversed.</p>\r\n<h3 id=\"theorem\">Theorem</h3>\r\n<p><span class=\"math inline\">\\(\\lozenge\\)</span> <span class=\"math inline\">\\(\\to\\)</span> CH.</p>\r\n<h3 id=\"theorem-1\">Theorem</h3>\r\n<p>Assume <span class=\"math inline\">\\(V = L\\)</span>. <span class=\"math inline\">\\(\\lozenge\\)</span> is valid.</p>\r\n<h3 id=\"theorem-2\">Theorem</h3>\r\n<p>Assume <span class=\"math inline\">\\(\\lozenge\\)</span>. The there\r\nexists a Souslin tree.</p>\r\n<h2 id=\"clubsuit_kappa\"><span class=\"math inline\">\\(\\clubsuit_{\\kappa}\\)</span></h2>\r\n<p>For a given cardinal number <span class=\"math inline\">\\(\\kappa\\)</span> and a stationary set <span class=\"math inline\">\\(S\\subseteq \\kappa\\)</span>, <span class=\"math inline\">\\(\\clubsuit _{S}\\)</span> is the statement that\r\nthere is a sequence <span class=\"math inline\">\\(\\{ A_{\\delta }:\\delta\r\n\\in S \\}\\)</span> such that</p>\r\n<ul>\r\n<li><p>every <span class=\"math inline\">\\(A_{\\delta}\\)</span> is a\r\ncofinal subset of <span class=\"math inline\">\\(\\delta\\)</span>.</p></li>\r\n<li><p>for every unbounded subset <span class=\"math inline\">\\(A\\subseteq\r\n\\kappa\\)</span>, there is a <span class=\"math inline\">\\(\\delta\\)</span>\r\nso that <span class=\"math inline\">\\(A_{\\delta }\\subseteq\r\nA\\)</span>.</p></li>\r\n</ul>\r\n<p><span class=\"math inline\">\\(\\clubsuit _{\\omega _{1}}\\)</span> is\r\nusually written as just <span class=\"math inline\">\\(\\clubsuit\\)</span>.</p>\r\n<p>It is clear that <span class=\"math inline\">\\(\\lozenge \\to\r\n\\clubsuit\\)</span>, and it was shown in 1975 that <span class=\"math inline\">\\(\\clubsuit\\)</span> + CH <span class=\"math inline\">\\(\\to\\)</span> <span class=\"math inline\">\\(\\lozenge\\)</span>; however, Saharon Shelah gave a\r\nproof in 1980 that there exists a model of <span class=\"math inline\">\\(\\clubsuit\\)</span> in which CH does not hold, so\r\n<span class=\"math inline\">\\(\\clubsuit\\)</span> and <span class=\"math inline\">\\(\\lozenge\\)</span> are not equivalent (since <span class=\"math inline\">\\(\\lozenge\\)</span> <span class=\"math inline\">\\(\\to\\)</span> CH).</p>\r\n<p>Jensen, R. Bj\"orn (1972), \"The fine structure of the constructible\r\nhierarchy\", Annals of Mathematical Logic, 4 (3): 229–308.</p>\r\n","popularPost_tmp_postPath":true,"eyeCatchImage":null,"popularPost_tmp_gaData":{"updated":"Sun Feb 25 2024 23:11:07 GMT+0800 (中国标准时间)","title":"$\\blacksquare$, $\\blacklozenge$, $\\clubsuit$","path":"2024/02/18/blacksquare-blacklozenge-clubsuit/","eyeCatchImage":null,"excerpt":null,"date":{"_isAMomentObject":true,"_i":"2024-02-18T00:50:47.000Z","_isUTC":false,"_pf":{"empty":false,"unusedTokens":[],"unusedInput":[],"overflow":-2,"charsLeftOver":0,"nullInput":false,"invalidEra":null,"invalidMonth":null,"invalidFormat":false,"userInvalidated":false,"iso":false,"parsedDateParts":[],"era":null,"meridiem":null,"rfc2822":false,"weekdayMismatch":false},"_locale":{"_calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"_longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"_invalidDate":"Invalid date","_dayOfMonthOrdinalParse":{},"_relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"_months":["January","February","March","April","May","June","July","August","September","October","November","December"],"_monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"_week":{"dow":0,"doy":6},"_weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"_weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"_weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"_meridiemParse":{},"_eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"_abbr":"en","_config":{"calendar":{"sameDay":"[Today at] LT","nextDay":"[Tomorrow at] LT","nextWeek":"dddd [at] LT","lastDay":"[Yesterday at] LT","lastWeek":"[Last] dddd [at] LT","sameElse":"L"},"longDateFormat":{"LTS":"h:mm:ss A","LT":"h:mm A","L":"MM/DD/YYYY","LL":"MMMM D, YYYY","LLL":"MMMM D, YYYY h:mm A","LLLL":"dddd, MMMM D, YYYY h:mm A"},"invalidDate":"Invalid date","dayOfMonthOrdinalParse":{},"relativeTime":{"future":"in %s","past":"%s ago","s":"a few seconds","ss":"%d seconds","m":"a minute","mm":"%d minutes","h":"an hour","hh":"%d hours","d":"a day","dd":"%d days","w":"a week","ww":"%d weeks","M":"a month","MM":"%d months","y":"a year","yy":"%d years"},"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"monthsShort":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"week":{"dow":0,"doy":6},"weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"weekdaysMin":["Su","Mo","Tu","We","Th","Fr","Sa"],"weekdaysShort":["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],"meridiemParse":{},"eras":[{"since":"0001-01-01","until":null,"offset":1,"name":"Anno Domini","narrow":"AD","abbr":"AD"},{"since":"0000-12-31","until":null,"offset":1,"name":"Before Christ","narrow":"BC","abbr":"BC"}],"abbr":"en"},"_dayOfMonthOrdinalParseLenient":{}},"_d":"2024-02-18T00:50:47.000Z","_isValid":true,"_z":null},"pv":0,"totalPV":0,"categories":"Set Theory > Mathematical Logic","tags":["Set Theory","Mathematical Logic"],"internalLinks":[],"keywords":[],"keywordsLength":0}}],"PostAsset":[{"_id":"source/_posts/Quadratic Reciprocity Law/QRL.png","post":"cmfwcr5s4001xm8nx793lbboa","slug":"QRL.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cmfwcr5rn0001m8nx1kisf6in","category_id":"cmfwcr5rs0007m8nxfqlc3n13","_id":"cmfwcr5rw000nm8nxcrcn0p1i"},{"post_id":"cmfwcr5rs0009m8nxc31d69nm","category_id":"cmfwcr5rx000tm8nxh4c0e8mz","_id":"cmfwcr5s00017m8nx4p1m14wb"},{"post_id":"cmfwcr5ry000ym8nx5u59dojq","category_id":"cmfwcr5rx000tm8nxh4c0e8mz","_id":"cmfwcr5s1001bm8nx28a26na5"},{"post_id":"cmfwcr5rz0011m8nxf6lc372f","category_id":"cmfwcr5rx000tm8nxh4c0e8mz","_id":"cmfwcr5s2001gm8nxdqdlgnth"},{"post_id":"cmfwcr5ru000gm8nx37fh750q","category_id":"cmfwcr5rz000zm8nxacng6eor","_id":"cmfwcr5s3001jm8nx1v22gz8q"},{"post_id":"cmfwcr5rp0003m8nxc4cwbyec","category_id":"cmfwcr5ru000dm8nx6ap79txh","_id":"cmfwcr5s3001om8nx3dxhg8cb"},{"post_id":"cmfwcr5rp0003m8nxc4cwbyec","category_id":"cmfwcr5s00015m8nxb7hg144u","_id":"cmfwcr5s4001rm8nx6z5h94dr"},{"post_id":"cmfwcr5s1001am8nx1jo6b3qd","category_id":"cmfwcr5ru000dm8nx6ap79txh","_id":"cmfwcr5s4001vm8nxgpmw0dme"},{"post_id":"cmfwcr5s1001am8nx1jo6b3qd","category_id":"cmfwcr5s00015m8nxb7hg144u","_id":"cmfwcr5s5001ym8nxew6x57s4"},{"post_id":"cmfwcr5rw000mm8nxaaux5d59","category_id":"cmfwcr5ru000dm8nx6ap79txh","_id":"cmfwcr5s50024m8nx5uko95un"},{"post_id":"cmfwcr5rw000mm8nxaaux5d59","category_id":"cmfwcr5s3001lm8nx82mz9ocv","_id":"cmfwcr5s60026m8nx6gi12ff4"},{"post_id":"cmfwcr5s3001pm8nx2p388tm4","category_id":"cmfwcr5ru000dm8nx6ap79txh","_id":"cmfwcr5s6002am8nx3t504giz"},{"post_id":"cmfwcr5s3001pm8nx2p388tm4","category_id":"cmfwcr5s3001lm8nx82mz9ocv","_id":"cmfwcr5s6002cm8nx0jftemtx"},{"post_id":"cmfwcr5s4001xm8nx793lbboa","category_id":"cmfwcr5rs0007m8nxfqlc3n13","_id":"cmfwcr5s6002fm8nx99lk59w1"},{"post_id":"cmfwcr5rx000qm8nx9p3a199r","category_id":"cmfwcr5s50022m8nx8f2gf5z0","_id":"cmfwcr5s6002hm8nx7fyic6l1"},{"post_id":"cmfwcr5ry000wm8nx6fn01ob0","category_id":"cmfwcr5s6002em8nxhg0o9nsy","_id":"cmfwcr5s7002om8nxfgnda2yl"},{"post_id":"cmfwcr5s2001im8nx1qggbdnk","category_id":"cmfwcr5ru000dm8nx6ap79txh","_id":"cmfwcr5s8002xm8nx980m5rm2"},{"post_id":"cmfwcr5s2001im8nx1qggbdnk","category_id":"cmfwcr5s3001lm8nx82mz9ocv","_id":"cmfwcr5s8002ym8nxcvnp0ozp"},{"post_id":"cmfwcr5s4001um8nx0x5l1c2b","category_id":"cmfwcr5s50022m8nx8f2gf5z0","_id":"cmfwcr5s80031m8nxfsjhddit"},{"post_id":"cmfwcr5s50021m8nx2ljlheei","category_id":"cmfwcr5s6002em8nxhg0o9nsy","_id":"cmfwcr5s90034m8nx8zpxakun"},{"post_id":"cmfwcr5rx000um8nx9tqj2r7h","category_id":"cmfwcr5s60028m8nx253k5ets","_id":"cmfwcr5s90036m8nx9brhhf25"},{"post_id":"cmfwcr5rx000um8nx9tqj2r7h","category_id":"cmfwcr5s80032m8nxbf2g1y9f","_id":"cmfwcr5s90037m8nxbu6yh0py"},{"post_id":"cmfwcr5rz0013m8nx9qrm1x4x","category_id":"cmfwcr5s50022m8nx8f2gf5z0","_id":"cmfwcr5s90039m8nx45ay05fh"},{"post_id":"cmfwcr5rz0013m8nx9qrm1x4x","category_id":"cmfwcr5s80033m8nx994943ff","_id":"cmfwcr5s9003am8nx4hjb6zd7"},{"post_id":"cmfwcr5s2001fm8nxcrj7dy0x","category_id":"cmfwcr5s7002qm8nxf19o79of","_id":"cmfwcr5sa003dm8nxc2o13f3n"},{"post_id":"cmfwcr5s2001fm8nxcrj7dy0x","category_id":"cmfwcr5s90038m8nxdiha9ncy","_id":"cmfwcr5sa003em8nx4xgh7cg7"},{"post_id":"cmfwcr5s3001mm8nx9my9d75h","category_id":"cmfwcr5s50022m8nx8f2gf5z0","_id":"cmfwcr5sa003hm8nx79qdhaar"},{"post_id":"cmfwcr5s3001mm8nx9my9d75h","category_id":"cmfwcr5s80033m8nx994943ff","_id":"cmfwcr5sa003im8nx7kff9552"},{"post_id":"cmfwcr5rr0006m8nxbad6crzj","category_id":"cmfwcr5rw000km8nxfri53nzw","_id":"cmfwcr5sa003km8nxf9ijc2tl"},{"post_id":"cmfwcr5rr0006m8nxbad6crzj","category_id":"cmfwcr5s4001tm8nx07fu0vrd","_id":"cmfwcr5sa003lm8nxb26taww9"},{"post_id":"cmfwcr5rr0006m8nxbad6crzj","category_id":"cmfwcr5s8002zm8nx8fe111i2","_id":"cmfwcr5sa003mm8nxbcvu8dz3"},{"post_id":"cmfwcr5rr0006m8nxbad6crzj","category_id":"cmfwcr5sa003fm8nx5rv5bfn2","_id":"cmfwcr5sa003nm8nxare92cwn"},{"post_id":"cmfwcr5s00018m8nxfxxpdxlw","category_id":"cmfwcr5s50022m8nx8f2gf5z0","_id":"cmfwcr5sb003om8nxdbmu3ruy"},{"post_id":"cmfwcr5s00018m8nxfxxpdxlw","category_id":"cmfwcr5s90035m8nxh0wqgvt3","_id":"cmfwcr5sb003pm8nxcp14cl0v"},{"post_id":"cmfwcr5s00018m8nxfxxpdxlw","category_id":"cmfwcr5sa003gm8nx13qa1p61","_id":"cmfwcr5sb003qm8nx1e66fuvj"},{"post_id":"cmfwcr5rv000im8nx7mwd9k08","category_id":"cmfwcr5rw000km8nxfri53nzw","_id":"cmfwcr5sb003rm8nx7vay00wt"},{"post_id":"cmfwcr5rv000im8nx7mwd9k08","category_id":"cmfwcr5s4001tm8nx07fu0vrd","_id":"cmfwcr5sb003sm8nxc6r4bncj"},{"post_id":"cmfwcr5rv000im8nx7mwd9k08","category_id":"cmfwcr5s8002zm8nx8fe111i2","_id":"cmfwcr5sb003tm8nxd9tw5lmq"},{"post_id":"cmfwcr5rv000im8nx7mwd9k08","category_id":"cmfwcr5sa003fm8nx5rv5bfn2","_id":"cmfwcr5sb003um8nxdniehfn8"},{"post_id":"cmfwcr5sc003vm8nxfuexfda0","category_id":"cmfwcr5s50022m8nx8f2gf5z0","_id":"cmfwcr5sd0041m8nxgm1wf1oy"},{"post_id":"cmfwcr5sc003wm8nxbmmi9mko","category_id":"cmfwcr5s7002qm8nxf19o79of","_id":"cmfwcr5sd0043m8nx9278esf3"},{"post_id":"cmfwcr5sc003wm8nxbmmi9mko","category_id":"cmfwcr5s90038m8nxdiha9ncy","_id":"cmfwcr5sd0044m8nx1x8o5pwd"},{"post_id":"cmfwcr5sd003ym8nxeppacwe7","category_id":"cmfwcr5rx000tm8nxh4c0e8mz","_id":"cmfwcr5sd0045m8nxcgzrfmrs"},{"post_id":"cmfwcr5sd003ym8nxeppacwe7","category_id":"cmfwcr5s80033m8nx994943ff","_id":"cmfwcr5sd0046m8nx4m9wd8me"}],"PostTag":[{"post_id":"cmfwcr5rn0001m8nx1kisf6in","tag_id":"cmfwcr5rq0004m8nxba3mgs5e","_id":"cmfwcr5ru000em8nxhckr8fxc"},{"post_id":"cmfwcr5rp0003m8nxc4cwbyec","tag_id":"cmfwcr5rt000cm8nx7q6g9ck2","_id":"cmfwcr5rw000om8nxh3ysdjzw"},{"post_id":"cmfwcr5rw000mm8nxaaux5d59","tag_id":"cmfwcr5rt000cm8nx7q6g9ck2","_id":"cmfwcr5rx000sm8nx4la2b4uj"},{"post_id":"cmfwcr5rr0006m8nxbad6crzj","tag_id":"cmfwcr5rw000jm8nxh7os4fwl","_id":"cmfwcr5ry000vm8nx2rhohjjx"},{"post_id":"cmfwcr5rs0009m8nxc31d69nm","tag_id":"cmfwcr5rx000rm8nxg78504hs","_id":"cmfwcr5rz0010m8nxf1x7cbfi"},{"post_id":"cmfwcr5ry000ym8nx5u59dojq","tag_id":"cmfwcr5rx000rm8nxg78504hs","_id":"cmfwcr5rz0012m8nxe2lhd868"},{"post_id":"cmfwcr5rz0011m8nxf6lc372f","tag_id":"cmfwcr5rx000rm8nxg78504hs","_id":"cmfwcr5s00016m8nxgtoghcej"},{"post_id":"cmfwcr5ru000gm8nx37fh750q","tag_id":"cmfwcr5ry000xm8nx6vssfhck","_id":"cmfwcr5s10019m8nx2p8217vn"},{"post_id":"cmfwcr5rv000im8nx7mwd9k08","tag_id":"cmfwcr5rw000jm8nxh7os4fwl","_id":"cmfwcr5s2001em8nx925ubbrj"},{"post_id":"cmfwcr5s1001am8nx1jo6b3qd","tag_id":"cmfwcr5rt000cm8nx7q6g9ck2","_id":"cmfwcr5s2001hm8nxhoyu30fg"},{"post_id":"cmfwcr5rx000qm8nx9p3a199r","tag_id":"cmfwcr5s1001cm8nx2g28a3jh","_id":"cmfwcr5s3001nm8nx92jv3cit"},{"post_id":"cmfwcr5s2001im8nx1qggbdnk","tag_id":"cmfwcr5rt000cm8nx7q6g9ck2","_id":"cmfwcr5s4001qm8nx768u60gz"},{"post_id":"cmfwcr5rx000um8nx9tqj2r7h","tag_id":"cmfwcr5s3001km8nx8rwr57on","_id":"cmfwcr5s4001wm8nx1uqhawys"},{"post_id":"cmfwcr5s3001pm8nx2p388tm4","tag_id":"cmfwcr5rt000cm8nx7q6g9ck2","_id":"cmfwcr5s5001zm8nx2qkw1s3a"},{"post_id":"cmfwcr5s4001um8nx0x5l1c2b","tag_id":"cmfwcr5s1001cm8nx2g28a3jh","_id":"cmfwcr5s50023m8nxepg1fcf1"},{"post_id":"cmfwcr5ry000wm8nx6fn01ob0","tag_id":"cmfwcr5s4001sm8nxd8fx6wdx","_id":"cmfwcr5s60025m8nxdy6r6nmt"},{"post_id":"cmfwcr5s4001xm8nx793lbboa","tag_id":"cmfwcr5rq0004m8nxba3mgs5e","_id":"cmfwcr5s60029m8nxeazk44kw"},{"post_id":"cmfwcr5s50021m8nx2ljlheei","tag_id":"cmfwcr5s4001sm8nxd8fx6wdx","_id":"cmfwcr5s6002bm8nxf4fn7kg9"},{"post_id":"cmfwcr5rz0013m8nx9qrm1x4x","tag_id":"cmfwcr5s1001cm8nx2g28a3jh","_id":"cmfwcr5s6002gm8nx07e9gzdu"},{"post_id":"cmfwcr5rz0013m8nx9qrm1x4x","tag_id":"cmfwcr5s60027m8nx7692adws","_id":"cmfwcr5s6002im8nx1rm1guy9"},{"post_id":"cmfwcr5s00018m8nxfxxpdxlw","tag_id":"cmfwcr5s1001cm8nx2g28a3jh","_id":"cmfwcr5s7002nm8nx2tut2c8n"},{"post_id":"cmfwcr5s00018m8nxfxxpdxlw","tag_id":"cmfwcr5s6002jm8nx6xyadx7z","_id":"cmfwcr5s7002pm8nx6o1b8cwa"},{"post_id":"cmfwcr5s3001mm8nx9my9d75h","tag_id":"cmfwcr5s1001cm8nx2g28a3jh","_id":"cmfwcr5s7002rm8nxfjx88xe8"},{"post_id":"cmfwcr5s3001mm8nx9my9d75h","tag_id":"cmfwcr5s60027m8nx7692adws","_id":"cmfwcr5s7002sm8nx5wdbgroa"},{"post_id":"cmfwcr5sc003vm8nxfuexfda0","tag_id":"cmfwcr5s1001cm8nx2g28a3jh","_id":"cmfwcr5sd003xm8nx3r2j0izf"},{"post_id":"cmfwcr5sc003wm8nxbmmi9mko","tag_id":"cmfwcr5ry000xm8nx6vssfhck","_id":"cmfwcr5sd003zm8nxfeav93qx"},{"post_id":"cmfwcr5sd003ym8nxeppacwe7","tag_id":"cmfwcr5rx000rm8nxg78504hs","_id":"cmfwcr5sd0040m8nx2o6j0cub"},{"post_id":"cmfwcr5sd003ym8nxeppacwe7","tag_id":"cmfwcr5s60027m8nx7692adws","_id":"cmfwcr5sd0042m8nxhilo88po"}],"Tag":[{"name":"Algebraic Number Theory","_id":"cmfwcr5rq0004m8nxba3mgs5e"},{"name":"Sevaral Complex Variables","_id":"cmfwcr5rt000cm8nx7q6g9ck2"},{"name":"Hilbert's 23 Problems,Algebraic Number Theory","_id":"cmfwcr5rw000jm8nxh7os4fwl"},{"name":"Set Theory","_id":"cmfwcr5rx000rm8nxg78504hs"},{"name":"Algebraic Geometry","_id":"cmfwcr5ry000xm8nx6vssfhck"},{"name":"Notes","_id":"cmfwcr5s1001cm8nx2g28a3jh"},{"name":"Hilbert's 23 Problems,Mathematical Logic","_id":"cmfwcr5s3001km8nx8rwr57on"},{"name":"Miscellanies","_id":"cmfwcr5s4001sm8nxd8fx6wdx"},{"name":"Mathematical Logic","_id":"cmfwcr5s60027m8nx7692adws"},{"name":"Hilbert's 23 Problems","_id":"cmfwcr5s6002jm8nx6xyadx7z"}]}}